<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>8-20 使用模块机制分析内核</title>
    <url>/2023/09/11/8-20-%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>内核编程</category>
      </categories>
      <tags>
        <tag>模块机制</tag>
      </tags>
  </entry>
  <entry>
    <title>8-19 模块机制实现分析（下）</title>
    <url>/2023/09/11/8-19-%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>内核编程</category>
      </categories>
      <tags>
        <tag>模块机制</tag>
      </tags>
  </entry>
  <entry>
    <title>8-18 模块机制实现分析（上）</title>
    <url>/2023/09/11/8-18-%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>内核编程</category>
      </categories>
      <tags>
        <tag>模块机制</tag>
      </tags>
  </entry>
  <entry>
    <title>8-17 模块的运行过程</title>
    <url>/2023/09/11/8-17-%E6%A8%A1%E5%9D%97%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>内核编程</category>
      </categories>
      <tags>
        <tag>模块机制</tag>
      </tags>
  </entry>
  <entry>
    <title>8-16 编写一个字符驱动</title>
    <url>/2023/09/11/8-16-%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>内核编程</category>
      </categories>
      <tags>
        <tag>模块机制</tag>
      </tags>
  </entry>
  <entry>
    <title>8-15 模块间的依赖和自动加载</title>
    <url>/2023/09/11/8-15-%E6%A8%A1%E5%9D%97%E9%97%B4%E7%9A%84%E4%BE%9D%E8%B5%96%E5%92%8C%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>内核编程</category>
      </categories>
      <tags>
        <tag>模块机制</tag>
      </tags>
  </entry>
  <entry>
    <title>8-14 多文件构成的内核模块</title>
    <url>/2023/09/11/8-14-%E5%A4%9A%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>内核编程</category>
      </categories>
      <tags>
        <tag>模块机制</tag>
      </tags>
  </entry>
  <entry>
    <title>8-13 内核模块的头文件</title>
    <url>/2023/09/11/8-13-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>内核编程</category>
      </categories>
      <tags>
        <tag>模块机制</tag>
      </tags>
  </entry>
  <entry>
    <title>8-12 模块的版本控制</title>
    <url>/2023/09/11/8-12-%E6%A8%A1%E5%9D%97%E7%9A%84%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>内核编程</category>
      </categories>
      <tags>
        <tag>模块机制</tag>
      </tags>
  </entry>
  <entry>
    <title>8-11 EXPORT_SYMBOL</title>
    <url>/2023/09/11/8-11-EXPORT-SYMBOL/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>内核编程</category>
      </categories>
      <tags>
        <tag>模块机制</tag>
      </tags>
  </entry>
  <entry>
    <title>8-10 通过U-boot给内核模块传参</title>
    <url>/2023/09/11/8-10-%E9%80%9A%E8%BF%87U-boot%E7%BB%99%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E4%BC%A0%E5%8F%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>内核编程</category>
      </categories>
      <tags>
        <tag>模块机制</tag>
      </tags>
  </entry>
  <entry>
    <title>8-9 模块参数</title>
    <url>/2023/09/11/8-9-%E6%A8%A1%E5%9D%97%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>内核编程</category>
      </categories>
      <tags>
        <tag>模块机制</tag>
      </tags>
  </entry>
  <entry>
    <title>8-8 模块的Makefile分析</title>
    <url>/2023/09/11/8-8-%E6%A8%A1%E5%9D%97%E7%9A%84Makefile%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>内核编程</category>
      </categories>
      <tags>
        <tag>模块机制</tag>
      </tags>
  </entry>
  <entry>
    <title>8-7 模块的out-of-tree编译</title>
    <url>/2023/09/11/8-7-%E6%A8%A1%E5%9D%97%E7%9A%84out-of-tree%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>内核编程</category>
      </categories>
      <tags>
        <tag>模块机制</tag>
      </tags>
  </entry>
  <entry>
    <title>8-6 将模块编译进内核</title>
    <url>/2023/09/11/8-6-%E5%B0%86%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E8%BF%9B%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>内核编程</category>
      </categories>
      <tags>
        <tag>模块机制</tag>
      </tags>
  </entry>
  <entry>
    <title>8-5 模块签名机制</title>
    <url>/2023/09/11/8-5-%E6%A8%A1%E5%9D%97%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>内核编程</category>
      </categories>
      <tags>
        <tag>模块机制</tag>
      </tags>
  </entry>
  <entry>
    <title>8-4 内核污染（kernel tainted）</title>
    <url>/2023/09/11/8-4-%E5%86%85%E6%A0%B8%E6%B1%A1%E6%9F%93%EF%BC%88kernel-tainted%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>内核编程</category>
      </categories>
      <tags>
        <tag>模块机制</tag>
      </tags>
  </entry>
  <entry>
    <title>8-3 内核许可声明</title>
    <url>/2023/09/11/8-3-%E5%86%85%E6%A0%B8%E8%AE%B8%E5%8F%AF%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>内核编程</category>
      </categories>
      <tags>
        <tag>模块机制</tag>
      </tags>
  </entry>
  <entry>
    <title>8-2 内核模块的构成</title>
    <url>/2023/09/11/8-2-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%9A%84%E6%9E%84%E6%88%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>内核编程</category>
      </categories>
      <tags>
        <tag>模块机制</tag>
      </tags>
  </entry>
  <entry>
    <title>8-1 可加载模块的概念</title>
    <url>/2023/09/11/8-1-%E5%8F%AF%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>内核编程</category>
      </categories>
      <tags>
        <tag>模块机制</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/09/10/04%20recovery%E7%9A%84%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>0-8 U-Boot编译过程浅析</title>
    <url>/2023/09/10/0-8%20U-Boot%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、U-Boot源代码获取"><a href="#一、U-Boot源代码获取" class="headerlink" title="一、U-Boot源代码获取"></a>一、U-Boot源代码获取</h2><p>可以参考我之前输出的这篇文章：</p>
<blockquote>
<p>[<a href="https://blog.csdn.net/Neutionwei/article/details/123462959">RK356x] [Firefly-Linux] 10min带你获取、了解与编译U-Boot源代码</a></p>
</blockquote>
<p>切换成<code>linux_release_v1.2.3a</code>版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote update</span><br><span class="line">git checkout -b rk356x/linux_release_v1.2.3a rk356x/linux_release_v1.2.3a</span><br></pre></td></tr></table></figure>

<h2 id="二、编译RK3568"><a href="#二、编译RK3568" class="headerlink" title="二、编译RK3568"></a>二、编译RK3568</h2><p>RK356x 配置文件查看：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122159362.png" alt="img">清除历史编译状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure>

<p>使用 <code>make.sh</code> 配置 <code>configs/rk3568_defconfig</code> 并编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./make.sh rk3568</span><br></pre></td></tr></table></figure>

<h2 id="三、编译日志分析"><a href="#三、编译日志分析" class="headerlink" title="三、编译日志分析"></a>三、编译日志分析</h2><p>常用编译变量说明：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>HOSTCC</code></td>
<td>PC 机 gcc 编译命令</td>
</tr>
<tr>
<td><code>HOSTCXX</code></td>
<td>PC 机 g++ 编译命令</td>
</tr>
<tr>
<td><code>HOSTLD</code></td>
<td>PC 机 ld 链接命令</td>
</tr>
<tr>
<td><code>CC</code></td>
<td>交叉工具链 gcc 编译命令</td>
</tr>
<tr>
<td><code>CPP</code></td>
<td>交叉工具链 gcc -E 编译命令</td>
</tr>
<tr>
<td><code>LD</code></td>
<td>交叉工具链 ld 链接命令</td>
</tr>
<tr>
<td><code>OBJCOPY</code></td>
<td>交叉工具链 objcopy 命令</td>
</tr>
<tr>
<td><code>OBJDUMP</code></td>
<td>交叉工具链 objdump 链接命令</td>
</tr>
<tr>
<td><code>DTC</code></td>
<td>设备树编译命令 dtc</td>
</tr>
<tr>
<td><code>CHECK</code></td>
<td>执行静态检查 sparse</td>
</tr>
</tbody></table>
<p>摘自顶层<code>Makefile</code>：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122159859.png" alt="img"><br>注意：上图中的<code>cc</code>与<code>gcc</code>是同一个东西！</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122159833.png" alt="img"></p>
<p>编译日志主要分成以下几部分：</p>
<ol>
<li>配置文件生成</li>
<li>工具目录编译</li>
<li>U-Boot核心代码交叉编译</li>
<li>U-Boot目标文件生成</li>
<li>设备树编译并追加到U-Boot目标文件</li>
<li>TPL与SPL代码编译</li>
<li>TPL与SPL目标文件生成</li>
<li>最终固件打包</li>
</ol>
<h3 id="3-1-配置文件生成"><a href="#3-1-配置文件生成" class="headerlink" title="3.1 配置文件生成"></a>3.1 配置文件生成</h3><p>执行<code>make rk3568_defconfig -j8</code>命令，生成<code>.config</code>：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122159751.png" alt="img"><br>执行<code>scripts/kconfig/conf --silentoldconfig Kconfig</code>，这个话主要是检查是否有新的配置项，这里是清除历史输出文件后进行编译，因此所有配置项都认为是新的！</p>
<p>在这个过程根据<code>config.h</code>文件配置<code>u-boot.cfg</code>、<code>spl/u-boot.cfg</code>、<code>	/u-boot.cfg</code>等文件，然后产生了各自的<code>autoconf.mk</code>文件。编译<code>sam-offsets.s</code>产生<code>u-boot.lds</code>链接脚本。</p>
<p>另外<code>include/generated/version_autogenerated.h</code>是描述版本信息的头文件。<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122159822.png" alt="img"></p>
<h3 id="3-2-工具目录编译"><a href="#3-2-工具目录编译" class="headerlink" title="3.2 工具目录编译"></a>3.2 工具目录编译</h3><p>对<code>tools</code>下的工具进行一系列编译：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122159815.png" alt="img"></p>
<h3 id="3-3-U-Boot核心代码交叉编译"><a href="#3-3-U-Boot核心代码交叉编译" class="headerlink" title="3.3 U-Boot核心代码交叉编译"></a>3.3 U-Boot核心代码交叉编译</h3><p>编译完成<code>tools</code>目录后，开始交叉编译核心代码，我们会看到有非常多<code>build-in.o</code>，这个输出文件很有意思，它是该文件所处目录所有<code>*.o</code>文件的集合体，例如<code>arch/arm/cpu/built-in.o</code>，那它就是<code>arch/arm/cpu/</code>目录所有<code>*.o</code>文件的集合体！</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122159840.png" alt="img"><br>核心代码的编译过程主要涉及<code>arch</code>架构代码目录、<code>common</code>通用目录、<code>cmd</code>命令目录与<code>driver</code>驱动目录，当然还有<code>lib</code>公共库目录与<code>examles</code>例程目录，注意这个编译过程不是按照顺序编译打印的，这个因为前面使用<code>-j8</code>编译选项，这个选项的意思是打开8个线程并发编译：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122159970.png" alt="img"><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122159113.png" alt="img"><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122159108.png" alt="img"></p>
<h3 id="3-4-U-Boot目标文件生成"><a href="#3-4-U-Boot目标文件生成" class="headerlink" title="3.4 U-Boot目标文件生成"></a>3.4 U-Boot目标文件生成</h3><p>核心代码交叉编译完毕后链接之前所有的<code>built-in.o</code>文件，通过<code>objcopy</code>命令生成<code>u-boot-nodtb.bin</code>文件与<code>u-boot.sym</code>符号表，并且使用<code>relocate-rela</code>工具对<code>u-boot-nodtb.bin</code>静态reloc（静态<code>rela.dyn</code>修复）：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122159124.png" alt="img"></p>
<h3 id="3-5-设备树编译并追加到U-Boot目标文件"><a href="#3-5-设备树编译并追加到U-Boot目标文件" class="headerlink" title="3.5 设备树编译并追加到U-Boot目标文件"></a>3.5 设备树编译并追加到U-Boot目标文件</h3><p>接下来是编译设备树<code>dts</code>，并且产生<code>dt.dtb</code>（u-boot设备树<code>dtb</code>文件）、<code>dt-spl.dtb</code>（spl设备树<code>dtb</code>文件）、<code>dt-tpl.dtb</code>（tpl设备树<code>dtb</code>文件），并且把<code>dtb</code>文件追加到u-boot文件生成<code>u-boot.bin</code>文件：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122159130.png" alt="img"></p>
<h3 id="3-6-TPL与SPL代码编译"><a href="#3-6-TPL与SPL代码编译" class="headerlink" title="3.6 TPL与SPL代码编译"></a>3.6 TPL与SPL代码编译</h3><p><code>spl</code>是初始化DDR内存使用的，而<code>spl</code>相当于一个精简版u-boot，，只不过它的目的是加载u-boot固件，它们编译套路与U-Boot核心代码类似，注意的是它会把编译生成的<code>*.o</code>搬到<code>tpl</code>、<code>spl</code>目录，<code>tpl</code>、<code>spl</code>目录树的排布与U-Boot目录树一样：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122159177.png" alt="img"></p>
<h3 id="3-7-TPL与SPL目标文件生成"><a href="#3-7-TPL与SPL目标文件生成" class="headerlink" title="3.7 TPL与SPL目标文件生成"></a>3.7 TPL与SPL目标文件生成</h3><p><code>u-boot-spl.lds</code>是<code>spl</code>的链接脚本，<code>u-boot-spl.dtb</code>是<code>spl</code>的设备树<code>dtb</code>文件：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122159221.png" alt="img"><br><code>u-boot-spl-nodtb.bin</code>是<code>spl</code>目标文件，同样地把设备树<code>dtb</code>文件追加进去并产生<code>u-boot-spl.bin</code>文件：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122159361.png" alt="img"><br><code>u-boot-tpl-nodtb.bin</code>是<code>tpl</code>目标文件，注意这里直接复制成<code>u-boot-tpl.bin</code>（没有追加设备树<code>dtb</code>文件）：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122159367.png" alt="img"></p>
<p>还有一点需要注意的是，<code>u-boot-tpl.bin</code>是不能烧录进RK356x的，这是因为<code>tpl</code>相关代码，RK官方并没有开源！我们需要使用<code>rkbin</code>的<code>ddr.bin</code>文件替换！</p>
<h3 id="3-8-最终固件打包"><a href="#3-8-最终固件打包" class="headerlink" title="3.8 最终固件打包"></a>3.8 最终固件打包</h3><p>首先通过<code>rkbin/RKTRUST/RK3568TRUST.ini</code>文件描述的内容把<code>u-boot.bin</code>打包成<code>u-boot.itb</code>，紧接着根据 FIT 描述文件的内容把 ATF、OP-TEE、U-Boot、MCU 打包到一起（当然也包括设备树 DTB）：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122159407.png" alt="img"><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122159412.png" alt="img"><br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122159495.png" alt="img"><br>最后生成的固件为<code>uboot.img</code>，并且根据<code>rkbin/RKBOOT/RK3568MINIALL.ini</code>文件生成<code>rk356x_spl_loader_v1.12.112.bin</code>（注意这里并没有打包我们编译产生的<code>u-boot-spl.bin</code>文件，而是打包存放于<code>rkbin</code>目录下的<code>spl.bin</code>文件）</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122159479.png" alt="img"></p>
]]></content>
      <categories>
        <category>瑞芯微脚本分析</category>
      </categories>
      <tags>
        <tag>瑞芯微脚本分析</tag>
      </tags>
  </entry>
  <entry>
    <title>0-7 bootloader引导流程</title>
    <url>/2023/09/10/0-7%20bootloader%E5%BC%95%E5%AF%BC%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、RK芯片通用引导流程"><a href="#一、RK芯片通用引导流程" class="headerlink" title="一、RK芯片通用引导流程"></a>一、RK芯片通用引导流程</h1><p>对于RK芯片的引导流程，我们可以参考以下这张图：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122126953.jpeg" alt="img"></p>
<p>根据两种<code>Boot Flow</code>，我们可以一次梳理两种不同的引导流程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Boot Code -&gt; idbloader.img(miniloader) -&gt; uboot.img -&gt; boot.img -&gt; rootfs.img</span><br><span class="line">Boot Code -&gt; idbloader.img(TPL/SPL) -&gt; uboot.itb -&gt; boot.img -&gt; rootfs.img</span><br></pre></td></tr></table></figure>

<p>对于<code>idbloader.img</code>，我们会发现有相似的地方：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ddr.bin &lt;-&gt; u-boot-tpl.bin</span><br><span class="line">rkxx_miniloader_vx.xx.bin &lt;-&gt; u-boot-spl.bin</span><br></pre></td></tr></table></figure>

<p>此时我们会问，为什么会有两套引导流程？</p>
<p>事实上<code>idbloader.img(miniloader)</code>这套引导方案是RK定制的，它们并没有开源的，RK发布的是二进制文件，它们都存放于<code>rkbin</code>目录下，例如<code>RK356x</code>：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122137381.png" alt="image-20230912213741344"></p>
<p>注意上图中红方框处：rk3588_spl_v1.11.bin<code>实际上指的是</code>rkxx_miniloader_vx.xx.bin&#96;！</p>
<h1 id="二、RK356x引导流程"><a href="#二、RK356x引导流程" class="headerlink" title="二、RK356x引导流程"></a>二、RK356x引导流程</h1><p>下面通过<code>RK356x</code>的启动日志进行简要分析！</p>
<h2 id="2-1-ddr-bin运行"><a href="#2-1-ddr-bin运行" class="headerlink" title="2.1 ddr.bin运行"></a>2.1 ddr.bin运行</h2><p><code>RK3588</code>上电后，我们看到的第一阶段日志是关于DDR的，这主要是对DDR进行初始化，我们看到使用的是<code>LPDDR4</code>，频率逐步从<code>528MHz </code>切换到<code>2112MHz</code>，并且进行一些读写训练操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DDR Version V1.08 20220617</span><br><span class="line">LPDDR4X, 2112MHz</span><br><span class="line">channel[0] BW=16 Col=10 Bk=8 CS0 Row=16 CS=1 Die BW=16 Size=1024MB</span><br><span class="line">channel[1] BW=16 Col=10 Bk=8 CS0 Row=16 CS=1 Die BW=16 Size=1024MB</span><br><span class="line">channel[2] BW=16 Col=10 Bk=8 CS0 Row=16 CS=1 Die BW=16 Size=1024MB</span><br><span class="line">channel[3] BW=16 Col=10 Bk=8 CS0 Row=16 CS=1 Die BW=16 Size=1024MB</span><br><span class="line">Manufacturer ID:0x1 Samsung</span><br><span class="line">CH0 RX Vref:33.7%, TX Vref:21.8%,0.0%</span><br><span class="line">CH1 RX Vref:32.7%, TX Vref:18.8%,0.0%</span><br><span class="line">CH2 RX Vref:30.7%, TX Vref:17.8%,0.0%</span><br><span class="line">CH3 RX Vref:34.7%, TX Vref:18.8%,0.0%</span><br><span class="line">change to F1: 528MHz</span><br><span class="line">change to F2: 1068MHz</span><br><span class="line">change to F3: 1560MHz</span><br><span class="line">change to F0: 2112MHz</span><br><span class="line">out</span><br></pre></td></tr></table></figure>

<h2 id="2-2-spl-bin运行"><a href="#2-2-spl-bin运行" class="headerlink" title="2.2 spl.bin运行"></a>2.2 spl.bin运行</h2><p>​	接下来我们会看到SPL的板级初始化，紧接着逐步从<code>MMC2</code>（<code>SD</code>卡）、<code>MMC1</code>（<code>eMMC</code>）寻找<code>U-boot.img</code>（包括<code>atf-1</code>、<code>uboot</code>、<code>fdt</code>、<code>atf-2</code>、<code>atf-3</code>、<code>atf-4</code>、<code>atf-5</code>、<code>optee</code>），通过<code>atf-1</code>来运行<code>uboot</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">U-Boot SPL board init</span><br><span class="line">U-Boot SPL 2017.09-orangepi (Apr 21 2023 - 10:35:39)</span><br><span class="line">Trying to boot from MMC1</span><br><span class="line">Trying fit image at 0x4000 sector</span><br><span class="line">## Verified-boot: 0</span><br><span class="line">## Checking atf-1 0x00040000 ... sha256(806278dba1...) + OK</span><br><span class="line">## Checking uboot 0x00200000 ... sha256(a14cd96f5d...) + OK</span><br><span class="line">## Checking fdt 0x00349350 ... sha256(cf0060a3cf...) + OK</span><br><span class="line">## Checking atf-2 0x000f0000 ... sha256(c00c7fd75b...) + OK</span><br><span class="line">## Checking atf-3 0xff100000 ... sha256(71c3a5841b...) + OK</span><br><span class="line">## Checking atf-4 0xff001000 ... sha256(2301cf73be...) + OK</span><br><span class="line">Jumping to U-Boot(0x00200000) via ARM Trusted Firmware(0x00040000)</span><br><span class="line">Total: 209.584 ms</span><br></pre></td></tr></table></figure>

<p>注意<code>atf-*</code>与<code>optee</code>这些是 <code>ARM trust</code> 固件，属于另外一个领域，有兴趣可以参考以下文章：</p>
<blockquote>
<p><a href="https://blog.csdn.net/Neutionwei/article/details/111395775">https://blog.csdn.net/Neutionwei/article/details/111395775</a><br><a href="https://blog.csdn.net/Neutionwei/article/det">https://blog.csdn.net/Neutionwei/article/det</a></p>
</blockquote>
<h2 id="2-3-atf运行"><a href="#2-3-atf运行" class="headerlink" title="2.3 atf运行"></a>2.3 atf运行</h2><p>运行<code>BL31</code>，初始化与运行<code>BL32</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">INFO:    Preloader serial: 2</span><br><span class="line">NOTICE:  BL31: v2.3():v2.3-405-gb52c2eadd:derrick.huang</span><br><span class="line">NOTICE:  BL31: Built : 11:23:47, Aug 15 2022</span><br><span class="line">INFO:    spec: 0x13</span><br><span class="line">INFO:    ext 32k is valid</span><br><span class="line">INFO:    GICv3 without legacy support detected.</span><br><span class="line">INFO:    ARM GICv3 driver initialized in EL3</span><br><span class="line">INFO:    system boots from cpu-hwid-0</span><br><span class="line">INFO:    idle_st=0x21fff, pd_st=0x11fff9, repair_st=0xfff70001</span><br><span class="line">INFO:    dfs DDR fsp_params[0].freq_mhz= 2112MHz</span><br><span class="line">INFO:    dfs DDR fsp_params[1].freq_mhz= 528MHz</span><br><span class="line">INFO:    dfs DDR fsp_params[2].freq_mhz= 1068MHz</span><br><span class="line">INFO:    dfs DDR fsp_params[3].freq_mhz= 1560MHz</span><br><span class="line">INFO:    BL31: Initialising Exception Handling Framework</span><br><span class="line">INFO:    BL31: Initializing runtime services</span><br><span class="line">WARNING: No OPTEE provided by BL2 boot loader, Booting device without OPTEE initialization. SMC`s destined for OPTEE will return SMC_UNK</span><br><span class="line">ERROR:   Error initializing runtime service opteed_fast</span><br><span class="line">INFO:    BL31: Preparing for EL3 exit to normal world</span><br><span class="line">INFO:    Entry point address = 0x200000</span><br><span class="line">INFO:    SPSR = 0x3c9</span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<h2 id="2-4-uboot运行"><a href="#2-4-uboot运行" class="headerlink" title="2.4 uboot运行"></a>2.4 uboot运行</h2><h3 id="2-4-1-设备环境初始化"><a href="#2-4-1-设备环境初始化" class="headerlink" title="2.4.1 设备环境初始化"></a>2.4.1 设备环境初始化</h3><p>从<code>atf</code>切换到<code>uboot</code>之后，<code>uboot</code>依次执行以下操作：</p>
<ol>
<li>打印一些必要的信息：板型、串口、内存、系统内存初始化、代码重定位情况；</li>
<li>获取<code>MMC</code>存储器信息，打印当前启动的存储器（<code>atags</code>）；</li>
<li>获取存储器分区情况并加载内核设备树；</li>
<li>初始化<code>I2C0</code>、初始化<code>PMIC</code>电源芯片、相关芯片供电电压与<code>IO</code>电源域；</li>
<li>初始化<code>DRM</code>框架以及显示器接口（<code>HDMI</code>）;</li>
<li>初始化时钟树。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">U-Boot 2017.09-orangepi (Apr 21 2023 - 10:35:39 +0800)</span><br><span class="line"></span><br><span class="line">Model: Orange Pi 5B</span><br><span class="line">PreSerial: 2, raw, 0xfeb50000</span><br><span class="line">DRAM:  3.7 GiB</span><br><span class="line">Sysmem: init</span><br><span class="line">Relocation Offset: eda2d000</span><br><span class="line">Relocation fdt: eb9f9008 - eb9fecb8</span><br><span class="line">CR: M/C/I</span><br><span class="line">Using default environment</span><br><span class="line"></span><br><span class="line">mmc@fe2c0000: 0, mmc@fe2e0000: 1</span><br><span class="line">Bootdev(atags): mmc 0</span><br><span class="line">MMC0: Legacy, 52Mhz</span><br><span class="line">PartType: EFI</span><br><span class="line">DM: v2</span><br><span class="line">boot mode: None</span><br><span class="line">Model: Orange Pi 5B</span><br><span class="line">CLK: (sync kernel. arm: enter 1008000 KHz, init 1008000 KHz, kernel 0N/A)</span><br><span class="line">  b0pll 24000 KHz</span><br><span class="line">  b1pll 24000 KHz</span><br><span class="line">  lpll 24000 KHz</span><br><span class="line">  v0pll 24000 KHz</span><br><span class="line">  aupll 24000 KHz</span><br><span class="line">  cpll 1500000 KHz</span><br><span class="line">  gpll 1188000 KHz</span><br><span class="line">  npll 24000 KHz</span><br><span class="line">  ppll 1100000 KHz</span><br><span class="line">  aclk_center_root 702000 KHz</span><br><span class="line">  pclk_center_root 100000 KHz</span><br><span class="line">  hclk_center_root 396000 KHz</span><br><span class="line">  aclk_center_low_root 500000 KHz</span><br><span class="line">  aclk_top_root 750000 KHz</span><br><span class="line">  pclk_top_root 100000 KHz</span><br><span class="line">  aclk_low_top_root 396000 KHz</span><br><span class="line">Net:   No ethernet found.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-内核的加载"><a href="#2-4-2-内核的加载" class="headerlink" title="2.4.2 内核的加载"></a>2.4.2 内核的加载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switch to partitions #0, OK</span><br><span class="line">mmc0 is current device</span><br><span class="line">mmc@fe2c0000: 0 (SD)</span><br><span class="line">mmc@fe2e0000: 1</span><br><span class="line">switch to partitions #0, OK</span><br><span class="line">mmc0 is current device</span><br><span class="line">Scanning mmc 0:1...</span><br><span class="line">Found U-Boot script /boot.scr</span><br><span class="line">reading /boot.scr</span><br><span class="line">3411 bytes read in 4 ms (832 KiB/s)</span><br><span class="line">## Executing script at 00500000</span><br><span class="line">Boot script loaded from mmc 0</span><br><span class="line">reading /orangepiEnv.txt</span><br><span class="line">222 bytes read in 3 ms (72.3 KiB/s)</span><br><span class="line">reading /uInitrd</span><br><span class="line">18641659 bytes read in 1844 ms (9.6 MiB/s)</span><br><span class="line">reading /Image</span><br><span class="line">34736640 bytes read in 3049 ms (10.9 MiB/s)</span><br><span class="line">reading /dtb/rockchip/rk3588s-orangepi-5b.dtb</span><br><span class="line">233728 bytes read in 24 ms (9.3 MiB/s)</span><br><span class="line">reading /dtb/rockchip/overlay/rk3588-fixup.scr</span><br><span class="line">2756 bytes read in 6 ms (448.2 KiB/s)</span><br><span class="line">Applying kernel provided DT fixup script (rk3588-fixup.scr)</span><br><span class="line">## Executing script at 09000000</span><br><span class="line">Fdt Ramdisk skip relocation</span><br><span class="line">## Loading init Ramdisk from Legacy Image at 0a200000 ...</span><br><span class="line">   Image Name:   uInitrd</span><br><span class="line">   Image Type:   AArch64 Linux RAMDisk Image (gzip compressed)</span><br><span class="line">   Data Size:    18641595 Bytes = 17.8 MiB</span><br><span class="line">   Load Address: 00000000</span><br><span class="line">   Entry Point:  00000000</span><br><span class="line">   Verifying Checksum ... OK</span><br><span class="line">## Flattened Device Tree blob at 0x0a100000</span><br><span class="line">   Booting using the fdt blob at 0x0a100000</span><br><span class="line">   reserving fdt memory region: addr=a100000 size=9f000</span><br><span class="line">  &#x27;reserved-memory&#x27; ramoops@110000: addr=110000 size=f0000</span><br><span class="line">   Using Device Tree in place at 000000000a100000, end 000000000a1a1fff</span><br><span class="line">Adding bank: 0x00200000 - 0xf0000000 (size: 0xefe00000)</span><br><span class="line">Total: 5283.754 ms</span><br><span class="line"></span><br><span class="line">Starting kernel ...</span><br></pre></td></tr></table></figure>

<p>从<code>Starting kernel ...</code>开始，<code>uboot</code>的生命周期结束，之后产生的打印是由内核产生的！</p>
<p>值得注意的是，加载<code>Flat Device Tree</code>设备树之后，日志还打印了相关映像加载情况，这部分非常有用，我们以后再深入分析！</p>
<h1 id="三、BootRom阶段做了什么？"><a href="#三、BootRom阶段做了什么？" class="headerlink" title="三、BootRom阶段做了什么？"></a>三、BootRom阶段做了什么？</h1><p><code>BootRom</code>固件是Rockchip原厂芯片出厂时烧录到内部存储器的，目的是从各个外部存储媒介中加载<code>miniloader</code>(<code>tpl</code> + <code>spl</code>)！</p>
<p>以下是摘自《Rockchip RK3568 TRM Part1 V1.1-20210301》，它很清晰地说明了BootRom阶段做了什么事情：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122155809.png" alt="img"></p>
<p>我们按照正常引导走一遍：</p>
<ol>
<li>从<code>0x0000FFFF</code>地址读取第一条指令运行；</li>
<li>逐一检查与校验<code>Nor Flash</code>、<code>Nand Flash</code>、<code>eMMC</code>、<code>SD/MMC</code>中的<code>ID BLOCK</code>（RK 固件定义在第 <code>64</code> 扇区）；</li>
<li>假如我们的固件存放于<code>eMMC</code>，那么校验<code>ID BLOCK</code>成功后就读取<code>DDR</code>初始化代码到<code>SYSTEM_SRAM</code>；</li>
<li>紧接着运行刚刚读取的代码来初始化<code>DDR</code>；</li>
<li>初始化<code>DDR</code>后<code>DDR</code>就可以工作了，把引导代码加载到<code>DDR</code>并调到<code>DDR</code>继续运行。</li>
</ol>
<p>如果各个存储器都没有找到<code>ID BLOCK</code>，那么会执行以下操作：</p>
<ol>
<li>等待请求<code>DDR</code>程序（即在<code>RKDevTool</code>工具可以看到处于<code>Maskrom</code>模式）：</li>
</ol>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122156818.png" alt="img"></p>
<h1 id="四、RK固件在存储器中是如何分布的？"><a href="#四、RK固件在存储器中是如何分布的？" class="headerlink" title="四、RK固件在存储器中是如何分布的？"></a>四、RK固件在存储器中是如何分布的？</h1><p>如下图，其中 RK356x和rk3588 是没有使用 <code>trust</code>分区，这个要注意：	</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122156681.png" alt="img"></p>
<p>另外要注意的是从<code>loader2</code>分区开始所有的分区大小与起始地址是由<code>parameter.txt</code>文件进行描述，具体参考：</p>
<blockquote>
<p><a href="https://blog.csdn.net/Neutionwei/article/details/122911086">https://blog.csdn.net/Neutionwei/article/details/122911086</a></p>
</blockquote>
]]></content>
      <categories>
        <category>瑞芯微脚本分析</category>
      </categories>
      <tags>
        <tag>瑞芯微脚本分析</tag>
      </tags>
  </entry>
  <entry>
    <title>0-10 make.sh+rk3568编译命令执行分析（中）</title>
    <url>/2023/09/10/0-10%20make.sh+rk3568%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="4-6-执行fit-sh脚本"><a href="#4-6-执行fit-sh脚本" class="headerlink" title="4.6 执行fit.sh脚本"></a>4.6 执行fit.sh脚本</h3><p>在上一节 4.5 中执行<code>pack_fit_image</code>函数，这个函数会调用<code>fit.sh</code>脚本：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208166.png" alt="img"></p>
<p><code>SCRIPT_FIT</code>的定义：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208192.png" alt="img"><br>具体参数传递：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208179.png" alt="img"></p>
<p>脚本函数执行如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208171.png" alt="img"><br>打开该脚本，添加打印：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208022.png" alt="img"><br>执行以下命令会输出具体的执行过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./scripts/fit.sh --ini-trust ../rkbin/RKTRUST/RK3568TRUST.ini --ini-loader ../rkbin/RKBOOT/RK3568MINIALL.ini --chip RK3568</span><br></pre></td></tr></table></figure>

<h4 id="4-6-1-编译相关变量初始化"><a href="#4-6-1-编译相关变量初始化" class="headerlink" title="4.6.1 编译相关变量初始化"></a>4.6.1 编译相关变量初始化</h4><p>打印日志：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208197.png" alt="img"><br>源代码：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208348.png" alt="img"></p>
<h4 id="4-6-2-执行fit-process-args"><a href="#4-6-2-执行fit-process-args" class="headerlink" title="4.6.2 执行fit_process_args"></a>4.6.2 执行fit_process_args</h4><p>打印日志：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208426.png" alt="img"></p>
<p><code>fit_process_args</code>函数解析<code>--ini-trust</code>参数，用于指定<code>rkbin</code>的<code>RK3568TRUST.ini</code>文件，同理<code>--ini-loader</code>指定<code>RK3568MINIALL.ini</code>文件，同时指定芯片平台<code>--chip</code>为<code>RK3568</code>，<code>fit_process_args</code>函数定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fit_process_args()</span><br><span class="line">&#123;</span><br><span class="line">	if [ $# -eq 0 ]; then</span><br><span class="line">		help</span><br><span class="line">		exit 0</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	while [ $# -gt 0 ]; do</span><br><span class="line">		case $1 in</span><br><span class="line">			--args)</span><br><span class="line">				ARG_VALIDATE=$2</span><br><span class="line">				shift 2</span><br><span class="line">				;;</span><br><span class="line">			--boot_img)     # boot.img</span><br><span class="line">				ARG_BOOT_IMG=$2</span><br><span class="line">				shift 2</span><br><span class="line">				;;</span><br><span class="line">			--chip)</span><br><span class="line">				ARG_CHIP=$2</span><br><span class="line">				shift 2</span><br><span class="line">				;;</span><br><span class="line">			--recovery_img) # recovery.img</span><br><span class="line">				ARG_RECOVERY_IMG=$2</span><br><span class="line">				shift 2</span><br><span class="line">				;;</span><br><span class="line">			--boot_img_dir) # boot.img components directory</span><br><span class="line">				ARG_BOOT_IMG_DIR=$2</span><br><span class="line">				shift 2</span><br><span class="line">				;;</span><br><span class="line">			--no-check)     # No hostcc fit signature check</span><br><span class="line">				ARG_NO_CHECK=&quot;y&quot;</span><br><span class="line">				shift 1</span><br><span class="line">				;;</span><br><span class="line">			--ini-trust)    # Assign trust ini file</span><br><span class="line">				ARG_INI_TRUST=$2</span><br><span class="line">				shift 2</span><br><span class="line">				;;</span><br><span class="line">			--ini-loader)   # Assign loader ini file</span><br><span class="line">				ARG_INI_LOADER=$2</span><br><span class="line">				shift 2</span><br><span class="line">				;;</span><br><span class="line">			--spl-new)      # Use current build u-boot-spl.bin to pack loader</span><br><span class="line">				ARG_SPL_NEW=&quot;y&quot;</span><br><span class="line">				shift 1</span><br><span class="line">				;;</span><br><span class="line">			--rollback-index-boot)</span><br><span class="line">				ARG_ROLLBACK_IDX_BOOT=$2</span><br><span class="line">				arg_check_decimal $2</span><br><span class="line">				shift 2</span><br><span class="line">				;;</span><br><span class="line">			--rollback-index-recovery)</span><br><span class="line">				ARG_ROLLBACK_IDX_RECOVERY=$2</span><br><span class="line">				arg_check_decimal $2</span><br><span class="line">				shift 2</span><br><span class="line">				;;</span><br><span class="line">			--rollback-index-uboot)</span><br><span class="line">				ARG_ROLLBACK_IDX_UBOOT=$2</span><br><span class="line">				arg_check_decimal $2</span><br><span class="line">				shift 2</span><br><span class="line">				;;</span><br><span class="line">			--version-uboot)</span><br><span class="line">				ARG_VER_UBOOT=$2</span><br><span class="line">				arg_check_decimal $2</span><br><span class="line">				shift 2</span><br><span class="line">				;;</span><br><span class="line">			--version-boot)</span><br><span class="line">				ARG_VER_BOOT=$2</span><br><span class="line">				arg_check_decimal $2</span><br><span class="line">				shift 2</span><br><span class="line">				;;</span><br><span class="line">			--version-recovery)</span><br><span class="line">				ARG_VER_RECOVERY=$2</span><br><span class="line">				arg_check_decimal $2</span><br><span class="line">				shift 2</span><br><span class="line">				;;</span><br><span class="line">			--burn-key-hash)</span><br><span class="line">				ARG_BURN_KEY_HASH=&quot;y&quot;</span><br><span class="line">				shift 1</span><br><span class="line">				;;</span><br><span class="line">			*)</span><br><span class="line">				help</span><br><span class="line">				exit 1</span><br><span class="line">				;;</span><br><span class="line">		esac</span><br><span class="line">	done</span><br><span class="line"></span><br><span class="line">	if grep -q &#x27;^CONFIG_FIT_SIGNATURE=y&#x27; .config ; then</span><br><span class="line">		ARG_SIGN=&quot;y&quot;</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位置参数可以用<code>shift</code>命令左移。比如<code>shift 3</code>表示原来的<code>$4</code>现在变成<code>$1</code>，原来的<code>$5</code>现在变成<code>$2</code>等等，原来的<code>$1</code>、<code>$2</code>、<code>$3</code>丢弃，<code>$0</code>不移动。不带参数的<code>shift</code>命令相当于<code>shift 1</code>。</p>
</blockquote>
<h4 id="4-6-3-执行fit-raw-compile"><a href="#4-6-3-执行fit-raw-compile" class="headerlink" title="4.6.3 执行fit_raw_compile"></a>4.6.3 执行fit_raw_compile</h4><p>打印日志：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208448.png" alt="在这里插入图片描述"></p>
<p><code>fit_raw_compile</code>函数在此处只是重新创建<code>fit</code>目录，函数体如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208459.png" alt="img"></p>
<h4 id="4-6-4-执行fit-gen-uboot-itb"><a href="#4-6-4-执行fit-gen-uboot-itb" class="headerlink" title="4.6.4 执行fit_gen_uboot_itb"></a>4.6.4 执行fit_gen_uboot_itb</h4><p>打印日志：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208542.png" alt="img"><br><code>fit_gen_uboot_itb</code>函数从命名来看应该是产生<code>uboot.itb</code>文件，从日志可以知道，它调用了<code>make.sh</code>脚本，执行的命令是<code>./make.sh itb ../rkbin/RKTURST/RK3568TRUST.ini</code>，接下来执行类似与<code>./make.sh rk3568</code>，只是此时传入进去的参数是<code>itb</code>：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208486.png" alt="img"></p>
<p>打印日志：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208648.png" alt="img"><br>执行<code>process_args</code>等等，大部分与<code>./make.sh rk3568</code>一样：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208747.png" alt="img"></p>
<p>后面有差异的地方是从执行<code>sub_commands</code>函数开始，传入的参数是之前的<code>itb</code>，然后调用<code>pack_uboot_itb_image</code>函数：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208794.png" alt="img"></p>
<p>源代码：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208753.png" alt="img"></p>
<p><code>pack_uboot_itb_image</code>函数解析<code>../rkbin/RKTURST/RK3568TRUST.ini</code>文件的内容，文件内容如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208773.png" alt="img"></p>
<p>把<code>bl31.elf</code>与<code>tee.bin</code>二进制文件拷贝到uboot目录：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208028.png" alt="img"><br><code>mcu*.bin</code>因为<code>../rkbin/RKTURST/RK3568TRUST.ini</code>文件并没有描述，因此实际上并没有拷贝!<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208966.png" alt="img"><br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208007.png" alt="img"></p>
<p><code>load*.bin</code>因为<code>../rkbin/RKTURST/RK3568TRUST.ini</code>文件也没有描述，故没有拷贝!<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208041.png" alt="img"><br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208115.png" alt="img"><br>这个阶段执行的代码如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208128.png" alt="img"><br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208293.png" alt="img"></p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208301.png" alt="img"></p>
<p><code>fit_gen_uboot_itb</code>函数执行到后面会执行<code>arch/arm/mach-rockchop/make_fit_atf.sh</code>脚本，这个脚本在<code>.config</code>文件中有指定：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208308.png" alt="img"><br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208115.png" alt="img"></p>
<p>使用该脚本执行<code>arch/arm/mach-rockchip/make_fit_atf.sh -t 0x08400000</code>命令：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208421.png" alt="img"><br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208434.png" alt="img"></p>
<p>这个脚本是用于生成固件描述文件<code>u-boot.its</code>，内容如下：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208470.png" alt="img"></p>
<p>接着执行<code>./tools/mkimage -f u-boot.its -E u-boot.itb</code>命令生成<code>u-boot.itb</code>：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208550.png" alt="img"><br><code>mkimage</code>的用法如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208686.png" alt="img"><br><code>-E</code>是什么意思？看源代码：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208621.png" alt="img"></p>
<p>接下来执行<code>check_its u-boot.its</code>：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208721.png" alt="img"><br>这个函数功能就是检查<code>u-boot.its</code>，源代码如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208828.png" alt="img"><br>接下来执行<code>./make.sh loader ../rkbin/RKBOOT/RK3568MINIALL.ini</code>，原理与之前的类似的：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208756.png" alt="img"></p>
<p>打印日志（保留主要）：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208778.png" alt="img"></p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208880.png" alt="img"><br>调用<code>process_args</code>函数等等（保留主要）：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208090.png" alt="img"></p>
<p>调用<code>sub_commands</code>函数等等（保留主要）：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208034.png" alt="img"><br>执行<code>./make.sh loader ../rkbin/RKBOOT/RK3568MINIALL.ini</code>最终调用到<code>pack_loader_image</code>函数：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208041.png" alt="img"><br><code>pack_loader_image</code>函数，里面调用<code>loader.sh</code>脚本：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208095.png" alt="img"><br>对<code>loader.sh</code>脚本也添加打印：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208077.png" alt="img"><br>打印日志如下，可以看到实际上是调用了<code>boot_merger</code>来打包loader：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208119.png" alt="img"><br>这个<code>boot_merger</code>存放在<code>rkbin/tools</code>目录，是不开源的二进制文件，用法如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208401.png" alt="img"><br><code>loader.sh</code>脚本源代码如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208429.png" alt="img"></p>
<p>回到<code>fit_gen_uboot_itb</code>函数，打印：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208376.png" alt="img"><br>删除历史文件，把<code>u-boot.its</code>移动到<code>fit</code>目录，源代码如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208382.png" alt="img"></p>
<p>调用<code>fit_gen_uboot_img</code>打包<code>uboot.img</code>：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208407.png" alt="img"></p>
<p>源代码：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208411.png" alt="img"><br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208757.png" alt="img"></p>
<p>执行过程：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208688.png" alt="img"><br>紧接着打包loader，实际上并没有运行：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208712.png" alt="img"><br>源代码：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208726.png" alt="img"><br>打印信息：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208734.png" alt="img"><br>源代码：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208776.png" alt="img"><br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208999.png" alt="img"><br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208166.png" alt="img"><br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208024.png" alt="img"><br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208006.png" alt="img"><br>至此<code>fit.sh</code>执行完毕！</p>
<h3 id="4-7-执行finish"><a href="#4-7-执行finish" class="headerlink" title="4.7 执行finish"></a>4.7 执行finish</h3><p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208063.png" alt="img"><br>打印完成信息：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208034.png" alt="img"></p>
<p>还有最后打印工具链与编译结束时间：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122208268.png" alt="img"></p>
]]></content>
      <categories>
        <category>瑞芯微脚本分析</category>
      </categories>
      <tags>
        <tag>瑞芯微脚本分析</tag>
      </tags>
  </entry>
  <entry>
    <title>0-11 .make.sh rk3568编译命令执行分析（下）</title>
    <url>/2023/09/10/0-11%20.make.sh%20rk3568%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><h3 id="5-1-编译脚本运行流程"><a href="#5-1-编译脚本运行流程" class="headerlink" title="5.1 编译脚本运行流程"></a>5.1 编译脚本运行流程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./make.sh rk3568</span><br><span class="line">    process_args rk3568 # 参数解析</span><br><span class="line">        make rk3568_defconfig # 生成.config</span><br><span class="line">    prepare # 指定rkbin路径与平台类似为fit</span><br><span class="line">    select_toolchain # 指定交叉工具链</span><br><span class="line">    select_chip_info # 指定芯片信息</span><br><span class="line">    fixup_platform_configure # 没作用</span><br><span class="line">    select_ini_file # 指定rkbin目录的ini文件</span><br><span class="line">    handle_args_late # 添加ini文件作为参数</span><br><span class="line">    sub_commands # 传入rk3568参数，执行unwind_addr_or_continue</span><br><span class="line">        unwind_addr_or_continue # 没作用</span><br><span class="line">    clean_files # 清除历史文件</span><br><span class="line">    make PYTHON=python2 CROSS_COMPILE=$&#123;TOOLCHAIN&#125; all --jobs=$&#123;JOB&#125; # 编译u-boot</span><br><span class="line">    pack_images # 打包固件</span><br><span class="line">        pack_fit_image --ini-trust ../rkbin/RKTRUST/RK3568TRUST.ini --ini-loader ../rkbin/RKBOOT/RK3568MINIALL.ini # 根据ini文件打包fit格式固件</span><br><span class="line">            ./scripts/fit.sh --ini-trust ../rkbin/RKTRUST/RK3568TRUST.ini --ini-loader ../rkbin/RKBOOT/RK3568MINIALL.ini --chip RK3568</span><br><span class="line">                fit_process_args --ini-trust ../rkbin/RKTRUST/RK3568TRUST.ini --ini-loader ../rkbin/RKBOOT/RK3568MINIALL.ini --chip RK3568 # 记录这三个参数</span><br><span class="line">                fit_raw_compile # 创建fit目录</span><br><span class="line">                fit_gen_uboot_itb # 产生u-boot.itb</span><br><span class="line">                    ./make.sh itb ../rkbin/RKTRUST/RK3568TRUST.ini</span><br><span class="line">                        process_args itb ../rkbin/RKTRUST/RK3568TRUST.ini # 参数解析</span><br><span class="line">                        ...</span><br><span class="line">                        sub_commands # 传入itb参数，执行unwind_addr_or_continue</span><br><span class="line">                            pack_uboot_itb_image # 打包u-boot.itb</span><br><span class="line">                                arch/arm/mach-rockchip/make_fit_atf.sh -t 0x08400000 &gt; u-boot.its # 生成u-boot.its</span><br><span class="line">                                ./tools/mkimage -f u-boot.its -E u-boot.itb # 根据u-boot.its生成u-boot.itb</span><br><span class="line">                    check_its u-boot.its # 校验u-boot.its</span><br><span class="line">                    ./make.sh loader ../rkbin/RKBOOT/RK3568MINIALL.ini</span><br><span class="line">                        process_args loader ../rkbin/RKBOOT/RK3568MINIALL.ini # 参数解析</span><br><span class="line">                        ...</span><br><span class="line">                        sub_commands # 传入loader参数，执行pack_loader_image</span><br><span class="line">                            pack_loader_image # 打包*_loader_*.bin</span><br><span class="line">                                ./scripts/loader.sh --ini ../rkbin/RKBOOT/RK3568MINIALL.ini</span><br><span class="line">                                    cd ../rkbin</span><br><span class="line">                                    ./tools/boot_merger RKBOOT/RK3568MINIALL.ini # 合成*_loader_*.bin</span><br><span class="line">                                    cd -</span><br><span class="line">                                    mv ../rkbin/*_loader_*.bin ./</span><br><span class="line">                    mv u-boot.its fit/</span><br><span class="line">                fit_gen_uboot_img # 产生uboot.img</span><br><span class="line">                    for ((i = 0; i &lt; 2; i++));</span><br><span class="line">                    do</span><br><span class="line">                        cat fit/uboot.itb &gt;&gt; uboot.img</span><br><span class="line">                        truncate -s %2048K uboot.img</span><br><span class="line">                    done</span><br><span class="line">                fit_gen_loader # 没作用</span><br><span class="line">                fit_msg_uboot # 打印uboot fit信息</span><br><span class="line">                fit_msg_recovery # 没作用</span><br><span class="line">                fit_msg_boot # 没作用</span><br><span class="line">                fit_msg_loader # 没作用</span><br><span class="line">    finish # 打印完成信息</span><br><span class="line">    echo $&#123;TOOLCHAIN&#125; # 打印工具链</span><br><span class="line">    date # 打印编译结束时间</span><br></pre></td></tr></table></figure>

<h3 id="5-2-简要分析"><a href="#5-2-简要分析" class="headerlink" title="5.2 简要分析"></a>5.2 简要分析</h3><h4 id="5-2-1-config文件生成"><a href="#5-2-1-config文件生成" class="headerlink" title="5.2.1 .config文件生成"></a>5.2.1 .config文件生成</h4><p><code>./make.sh rk3568</code>把参数字符串合成<code>rk3568_defconfig</code>，再生成<code>.config</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make rk3568_defconfig</span><br></pre></td></tr></table></figure>

<h4 id="5-2-2-原始uboot编译"><a href="#5-2-2-原始uboot编译" class="headerlink" title="5.2.2 原始uboot编译"></a>5.2.2 原始uboot编译</h4><p><code>make.sh</code>脚本指定<code>TOOLCHAIN</code>工具链与<code>JOB</code>线程数参数，再编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make PYTHON=python2 CROSS_COMPILE=$&#123;TOOLCHAIN&#125; all --jobs=$&#123;JOB&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-3-打包机制浅析"><a href="#5-2-3-打包机制浅析" class="headerlink" title="5.2.3 打包机制浅析"></a>5.2.3 打包机制浅析</h4><p><code>fit.sh</code>脚本通过指定的<code>rkbin</code>的<code>ini</code>文件来打包。</p>
<ul>
<li><p>对于打包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u-boot.itb</span><br></pre></td></tr></table></figure>

<p>，通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rkbin/RKTRUST/RK3568TRUST.ini</span><br></pre></td></tr></table></figure>

<p>文件描述内容，调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arch/arm/mach-rockchip/make_fit_atf.sh</span><br></pre></td></tr></table></figure>

<p>脚本生成相应的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u-boot.its</span><br></pre></td></tr></table></figure>

<p>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arch/arm/mach-rockchip/make_fit_atf.sh -t 0x08400000 &gt; u-boot.its</span><br></pre></td></tr></table></figure>

<p>然后使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tool/mkimage</span><br></pre></td></tr></table></figure>

<p>工具生成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u-boot.itb</span><br></pre></td></tr></table></figure>

<p>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./tools/mkimage -f u-boot.its -E u-boot.itb</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于打包<code>*_loader_*.bin</code>，通过<code>rkbin/RKBOOT/RK3568MINIALL.ini</code>文件描述内容，调用<code>scripts/loader.sh</code>脚本，该脚本使用<code>rkbin/tools/boot_merger</code>不开源二进制工具合成<code>*_loader_*.bin</code>。</p>
</li>
<li><p>对于打包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uboot.img</span><br></pre></td></tr></table></figure>

<p>，它由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uboot.itb</span><br></pre></td></tr></table></figure>

<p>通过以下命令产生（注意</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uboot.itb</span><br></pre></td></tr></table></figure>

<p>与</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u-boot.itb</span><br></pre></td></tr></table></figure>

<p>是一样的）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for ((i = 0; i &lt; 2; i++));</span><br><span class="line">do</span><br><span class="line">  cat fit/uboot.itb &gt;&gt; uboot.img</span><br><span class="line">  truncate -s %2048K uboot.img</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意最终烧录的固件是<code>*_loader_*.bin</code>与<code>uboot.img</code>，且需要是瑞芯微的工具：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122209586.png" alt="img"></p>
]]></content>
      <categories>
        <category>瑞芯微脚本分析</category>
      </categories>
      <tags>
        <tag>瑞芯微脚本分析</tag>
      </tags>
  </entry>
  <entry>
    <title>0-12  .make.sh脚本的用法</title>
    <url>/2023/09/10/0-12%20%20.make.sh%E8%84%9A%E6%9C%AC%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>直接在<code>u-boot</code>根目录执行<code>./make.sh -h</code>命令就能看到用法：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122210874.png" alt="img"></p>
<h2 id="一、固件构建"><a href="#一、固件构建" class="headerlink" title="一、固件构建"></a>一、固件构建</h2><p>构建<code>rk3568</code>固件其实就是<code>./make.sh rk3568</code>，实际选用的是<code>rk3568_defconfig</code>，这里的构建固件一定要确保<code>configs</code>目录有相应的<code>*_defconfig</code>与<code>*.config</code>文件：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122210739.png" alt="img"><br>如果是相同的<code>.config</code>文件，再次构建直接执行<code>./make.sh</code>即可！</p>
<p>除此之外，<code>./make.sh env</code>用于构建<code>fw_printenv</code>工具：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122210743.png" alt="img"></p>
<p><code>fw_printenv</code>是U-Boot提供的一个给linux使用的env工具。通过这个工具，用户可以在linux上访问、修改env的内容。使用该工具要求env区域必须位于一个kernel可见的分区上（建议独立分区），本质上是通过kernel sys下的存储节点访问到env区域。</p>
<p>几个重要文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./tools/env/fw_printenv // env读写工具</span><br><span class="line">./tools/env/fw_env.config // env配置文件</span><br><span class="line">./tools/env/README // env读写工具说明文档</span><br></pre></td></tr></table></figure>

<h2 id="二、固件打包"><a href="#二、固件打包" class="headerlink" title="二、固件打包"></a>二、固件打包</h2><p>固件打包有时候有特殊需求的时候会用到，用法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./make.sh trust // 打包trust</span><br><span class="line">./make.sh loader // 打包loader</span><br><span class="line">./make.sh trust &lt;ini-file&gt; // 打包trust时指定ini文件</span><br><span class="line">./make.sh loader &lt;ini-file&gt; // 打包loader时指定ini文件</span><br><span class="line">./make.sh --spl // 用u-boot-spl.bin替换miniloader，打包成loader</span><br><span class="line">./make.sh --tpl // 用u-boot-tpl.bin替换ddr，打包成loader</span><br><span class="line">./make.sh --tpl -spl // 用u-boot-tpl.bin与u-boot-spl.bin替换ddr与miniloader，打包成loader</span><br><span class="line">./make.sh itb // 打包u-boot.itb（64位平台只支持打包ATF和U-Boot，OP-TEE</span><br><span class="line">不打包）</span><br></pre></td></tr></table></figure>

<p>但是由于<code>rk3568</code>的固件是使用FIT格式来打包的，因此以下命令都不支持<code>rk3568</code>（以下命令支持非FIT格式打包）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./make.sh trust // 打包trust</span><br><span class="line">./make.sh loader // 打包loader</span><br><span class="line">./make.sh trust &lt;ini-file&gt; // 打包trust时指定ini文件</span><br><span class="line">./make.sh loader &lt;ini-file&gt; // 打包loader时指定ini文件</span><br></pre></td></tr></table></figure>

<p>另外使用编译出来的<code>tpl</code>是无法启动的，因此对于<code>rk3568</code>，只有以下命令使用是有效果的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./make.sh --spl 用u-boot-spl.bin替换miniloader，打包成loader</span><br><span class="line">./make.sh --spl-new // ./make.sh --spl 命令只打包但不编译，此命令会重新编译再</span><br><span class="line">打包。</span><br><span class="line">./make.sh itb // 打包u-boot.itb（64位平台只支持打包ATF和U-Boot，OP-TEE</span><br><span class="line">不打包）</span><br></pre></td></tr></table></figure>

<h2 id="三、反汇编调试"><a href="#三、反汇编调试" class="headerlink" title="三、反汇编调试"></a>三、反汇编调试</h2><p>反汇编调试用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./make.sh elf-[x] [type] // 反汇编：使用-[x]参数, [type]可选择是否反汇编SPL或TPL</span><br><span class="line">./make.sh elf // 反汇编u-boot文件，默认使用-D参数</span><br><span class="line">./make.sh elf-S // 反汇编u-boot文件，使用-S参数</span><br><span class="line">./make.sh elf-d // 反汇编u-boot文件，使用-d参数</span><br><span class="line">./make.sh elf spl // 反汇编tpl/u-boot-tpl文件，默认使用-D参数</span><br><span class="line">./make.sh elf tpl // 反汇编spl/u-boot-tpl文件，默认使用-D参数</span><br><span class="line">./make.sh &lt;addr&gt; // 需要addr对应的函数名和代码位置</span><br><span class="line">./make.sh map // 打开u-boot.map</span><br><span class="line">./make.sh sym // 打开u-boot.sym</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>瑞芯微脚本分析</category>
      </categories>
      <tags>
        <tag>瑞芯微脚本分析</tag>
      </tags>
  </entry>
  <entry>
    <title>0-6 uboot目录下 make.sh 脚本分析</title>
    <url>/2023/09/10/0-6%20uboot%E7%9B%AE%E5%BD%95%E4%B8%8B%20make.sh%20%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./make.sh rk3588 CROSS_COMPILE=/home/topeet/Linux/3588-linux/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-</span><br></pre></td></tr></table></figure>

<p>使用make.sh进行的构建内容如上所示：</p>
<p>make.sh具体内容如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Copyright (c) 2019 Fuzhou Rockchip Electronics Co., Ltd</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># SPDX-License-Identifier: GPL-2.0</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># set -e 的作用是在脚本执行过程中，如果任何一条命令出现了错误，脚本会立即停止执行</span></span></span><br><span class="line">set -e</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询CPU的线程数</span></span><br><span class="line">JOB=`sed -n &quot;N;/processor/p&quot; /proc/cpuinfo|wc -l`</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询RK的一系列的默认配置文件</span></span><br><span class="line">SUPPORT_LIST=`ls configs/*[r,p][x,v,k][0-9][0-9]*_defconfig`</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$1</span>为输入的第一个参数。如果是上面的命令，那么CMD_ARGS为rk3588</span></span><br><span class="line">CMD_ARGS=$1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">########################################## User can modify #############################################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置编译器的路径，设置RKBIN的路径</span></span><br><span class="line">RKBIN_TOOLS=../rkbin/tools</span><br><span class="line">CROSS_COMPILE_ARM32=../prebuilts/gcc/linux-x86/arm/gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-</span><br><span class="line">CROSS_COMPILE_ARM64=../prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">########################################## User not touch #############################################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Declare global INI file searching index name <span class="keyword">for</span> every chip, update <span class="keyword">in</span> select_chip_info()</span></span><br><span class="line">RKCHIP=</span><br><span class="line">RKCHIP_LABEL=</span><br><span class="line">RKCHIP_LOADER=</span><br><span class="line">RKCHIP_TRUST=</span><br><span class="line">INI_TRUST=</span><br><span class="line">INI_LOADER=</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Declare rkbin repository path, updated <span class="keyword">in</span> prepare()</span></span><br><span class="line">RKBIN=</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Declare global toolchain path <span class="keyword">for</span> CROSS_COMPILE, updated <span class="keyword">in</span> select_toolchain()</span></span><br><span class="line">TOOLCHAIN=</span><br><span class="line">TOOLCHAIN_NM=</span><br><span class="line">TOOLCHAIN_OBJDUMP=</span><br><span class="line">TOOLCHAIN_ADDR2LINE=</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Declare global plaform configure, updated <span class="keyword">in</span> fixup_platform_configure()</span></span><br><span class="line">PLAT_RSA=</span><br><span class="line">PLAT_SHA=</span><br><span class="line">PLAT_UBOOT_SIZE=</span><br><span class="line">PLAT_TRUST_SIZE=</span><br><span class="line">PLAT_TYPE=&quot;RKFW&quot; # default</span><br><span class="line"></span><br><span class="line">SRCTREE=`pwd`</span><br><span class="line">SCRIPT_FIT=&quot;$&#123;SRCTREE&#125;/scripts/fit.sh&quot;</span><br><span class="line"></span><br><span class="line">SCRIPT_ATF=&quot;$&#123;SRCTREE&#125;/scripts/atf.sh&quot;</span><br><span class="line">SCRIPT_TOS=&quot;$&#123;SRCTREE&#125;/scripts/tos.sh&quot;</span><br><span class="line">SCRIPT_SPL=&quot;$&#123;SRCTREE&#125;/scripts/spl.sh&quot;</span><br><span class="line">SCRIPT_UBOOT=&quot;$&#123;SRCTREE&#125;/scripts/uboot.sh&quot;</span><br><span class="line">SCRIPT_LOADER=&quot;$&#123;SRCTREE&#125;/scripts/loader.sh&quot;</span><br><span class="line">SCRIPT_DECOMP=&quot;$&#123;SRCTREE&#125;/scripts/decomp.sh&quot;</span><br><span class="line">CC_FILE=&quot;.cc&quot;</span><br><span class="line">REP_DIR=&quot;./rep&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">########################################################################################################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">帮助信息</span></span><br><span class="line">function help()</span><br><span class="line">&#123;</span><br><span class="line">	echo</span><br><span class="line">	echo &quot;Usage:&quot;</span><br><span class="line">	echo &quot;	./make.sh [board|sub-command]&quot;</span><br><span class="line">	echo</span><br><span class="line">	echo &quot;	 - board:        board name of defconfig&quot;</span><br><span class="line">	echo &quot;	 - sub-command:  elf*|loader|trust|uboot|--spl|--tpl|itb|map|sym|&lt;addr&gt;&quot;</span><br><span class="line">	echo &quot;	 - ini:          ini file to pack trust/loader&quot;</span><br><span class="line">	echo</span><br><span class="line">	echo &quot;Output:&quot;</span><br><span class="line">	echo &quot;	 When board built okay, there are uboot/trust/loader images in current directory&quot;</span><br><span class="line">	echo</span><br><span class="line">	echo &quot;Example:&quot;</span><br><span class="line">	echo</span><br><span class="line">	echo &quot;1. Build:&quot;</span><br><span class="line">	echo &quot;	./make.sh evb-rk3399               --- build for evb-rk3399_defconfig&quot;</span><br><span class="line">	echo &quot;	./make.sh firefly-rk3288           --- build for firefly-rk3288_defconfig&quot;</span><br><span class="line">	echo &quot;	./make.sh EXT_DTB=rk-kernel.dtb    --- build with exist .config and external dtb&quot;</span><br><span class="line">	echo &quot;	./make.sh                          --- build with exist .config&quot;</span><br><span class="line">	echo &quot;	./make.sh env                      --- build envtools&quot;</span><br><span class="line">	echo</span><br><span class="line">	echo &quot;2. Pack:&quot;</span><br><span class="line">	echo &quot;	./make.sh uboot                    --- pack uboot.img&quot;</span><br><span class="line">	echo &quot;	./make.sh trust                    --- pack trust.img&quot;</span><br><span class="line">	echo &quot;	./make.sh trust &lt;ini&gt;              --- pack trust img with assigned ini file&quot;</span><br><span class="line">	echo &quot;	./make.sh loader                   --- pack loader bin&quot;</span><br><span class="line">	echo &quot;	./make.sh loader &lt;ini&gt;             --- pack loader img with assigned ini file&quot;</span><br><span class="line">	echo &quot;	./make.sh --spl                    --- pack loader with u-boot-spl.bin&quot;</span><br><span class="line">	echo &quot;	./make.sh --tpl                    --- pack loader with u-boot-tpl.bin&quot;</span><br><span class="line">	echo &quot;	./make.sh --tpl --spl              --- pack loader with u-boot-tpl.bin and u-boot-spl.bin&quot;</span><br><span class="line">	echo</span><br><span class="line">	echo &quot;3. Debug:&quot;</span><br><span class="line">	echo &quot;	./make.sh elf                      --- dump elf file with -D(default)&quot;</span><br><span class="line">	echo &quot;	./make.sh elf-S                    --- dump elf file with -S&quot;</span><br><span class="line">	echo &quot;	./make.sh elf-d                    --- dump elf file with -d&quot;</span><br><span class="line">	echo &quot;	./make.sh elf-*                    --- dump elf file with -*&quot;</span><br><span class="line">	echo &quot;	./make.sh &lt;no reloc_addr&gt;          --- unwind address(no relocated)&quot;</span><br><span class="line">	echo &quot;	./make.sh &lt;reloc_addr-reloc_off&gt;   --- unwind address(relocated)&quot;</span><br><span class="line">	echo &quot;	./make.sh map                      --- cat u-boot.map&quot;</span><br><span class="line">	echo &quot;	./make.sh sym                      --- cat u-boot.sym&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从指定的文件中提取以给定的<span class="variable">$&#123;1&#125;</span>变量作为前缀的行，并删除<span class="variable">$&#123;1&#125;</span>=后面的内容</span></span><br><span class="line">function filt_val()</span><br><span class="line">&#123;</span><br><span class="line">	sed -n &quot;/$&#123;1&#125;=/s/$&#123;1&#125;=//p&quot; $2 | tr -d &#x27;\r&#x27; | tr -d &#x27;&quot;&#x27;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">看最后的打印ARM64_TRUSTZONE为y，PLAT_TYPE为FIT</span></span><br><span class="line">function prepare()</span><br><span class="line">&#123;</span><br><span class="line">	if [ -d $&#123;RKBIN_TOOLS&#125; ]; then</span><br><span class="line">		absolute_path=$(cd `dirname $&#123;RKBIN_TOOLS&#125;`; pwd)</span><br><span class="line">		RKBIN=$&#123;absolute_path&#125;</span><br><span class="line">	else</span><br><span class="line">		echo &quot;ERROR: No ../rkbin repository&quot;</span><br><span class="line">		exit 1</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if grep -Eq &#x27;&#x27;^CONFIG_ARM64=y&#x27;|&#x27;^CONFIG_ARM64_BOOT_AARCH32=y&#x27;&#x27; .config ; then</span><br><span class="line">		ARM64_TRUSTZONE=&quot;y&quot;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if grep  -q &#x27;^CONFIG_ROCKCHIP_FIT_IMAGE_PACK=y&#x27; .config ; then</span><br><span class="line">		PLAT_TYPE=&quot;FIT&quot;</span><br><span class="line">	elif grep  -q &#x27;^CONFIG_SPL_DECOMP_HEADER=y&#x27; .config ; then</span><br><span class="line">		PLAT_TYPE=&quot;DECOMP&quot;</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看传入的参数，进行轮询，从而确定编译对象</span></span><br><span class="line">function process_args()</span><br><span class="line">&#123;</span><br><span class="line">	while [ $# -gt 0 ]; do</span><br><span class="line">		case $1 in</span><br><span class="line">			*help|--h|-h)</span><br><span class="line">				help</span><br><span class="line">				exit 0</span><br><span class="line">				;;</span><br><span class="line">			CROSS_COMPILE=*)  # set CROSS_COMPILE</span><br><span class="line">				ARG_COMPILE=&quot;y&quot;</span><br><span class="line">				CROSS_COMPILE_ARM32=$&#123;1#*=&#125;</span><br><span class="line">				CROSS_COMPILE_ARM64=$&#123;1#*=&#125;</span><br><span class="line">				if [ $&#123;CMD_ARGS&#125; == $1 ]; then</span><br><span class="line">					shift 1</span><br><span class="line">					CMD_ARGS=$1</span><br><span class="line">				else</span><br><span class="line">					shift 1</span><br><span class="line">				fi</span><br><span class="line">				;;</span><br><span class="line">                #build with exist .config：使用已存在的.config文件进行构建。</span><br><span class="line">                #loader|trust|uboot：打包镜像。</span><br><span class="line">                #debug*|map|sym|elf*|nm：调试命令。</span><br><span class="line">                #env：构建环境工具。</span><br><span class="line">                #itb：打包ITB镜像。</span><br><span class="line">                #fit：打包非安全的uboot.img和boot.img。			</span><br><span class="line">                #&#x27;&#x27;|loader|trust|uboot|debug*|itb|env|fit|map|sym|elf*|nm)</span><br><span class="line">				if [ &quot;$2&quot; == &quot;spl&quot; -o &quot;$2&quot; == &quot;tpl&quot; ]; then</span><br><span class="line">					ARG_TSPL=$2</span><br><span class="line">					shift 1</span><br><span class="line">				fi</span><br><span class="line">				shift 1</span><br><span class="line">				;;</span><br><span class="line"><span class="meta prompt_">			# </span><span class="language-bash">trust/loader ini files <span class="keyword">for</span> packing trust.img/loader.img</span></span><br><span class="line">			*.ini|*.INI)</span><br><span class="line">				if [ ! -f $1 ]; then</span><br><span class="line">					echo &quot;ERROR: No $1&quot;</span><br><span class="line">				fi</span><br><span class="line">				if grep -q &#x27;CODE471_OPTION&#x27; $1 ; then</span><br><span class="line">					ARG_INI_LOADER=$1</span><br><span class="line">				elif grep -Eq &#x27;&#x27;BL31_OPTION&#x27;|&#x27;TOS&#x27;&#x27; $1 ; then</span><br><span class="line">					ARG_INI_TRUST=$1</span><br><span class="line">				fi</span><br><span class="line">				shift 1</span><br><span class="line">				;;</span><br><span class="line">			--sz-trust) # set trust size</span><br><span class="line">				ARG_TRUST_SIZE=&quot;--size $2 $3&quot;</span><br><span class="line">				shift 3</span><br><span class="line">				;;</span><br><span class="line">			--sz-uboot) # set uboot size</span><br><span class="line">				ARG_UBOOT_SIZE=&quot;--size $2 $3&quot;</span><br><span class="line">				shift 3</span><br><span class="line">				;;</span><br><span class="line">			--raw-compile)  # FIT: build but not pack image</span><br><span class="line">				ARG_RAW_COMPILE=&quot;y&quot;</span><br><span class="line">				shift 1</span><br><span class="line">				;;</span><br><span class="line">			--no-uboot) # FIT: pack uboot.img without u-boot</span><br><span class="line">				ARG_NO_UBOOT=&quot;y&quot;</span><br><span class="line">				shift 1</span><br><span class="line">				;;</span><br><span class="line">			--idblock)  # pack idblock.bin</span><br><span class="line">				shift 1</span><br><span class="line">				;;</span><br><span class="line">			--tpl|tpl)  # use tpl file</span><br><span class="line">				ARG_TPL_BIN=&quot;tpl/u-boot-tpl.bin&quot;</span><br><span class="line">				shift 1</span><br><span class="line">				;;</span><br><span class="line">			--spl|spl*) # use spl file</span><br><span class="line">				ARG_SPL_BIN=&quot;spl/u-boot-spl.bin&quot;</span><br><span class="line">				shift 1</span><br><span class="line">				;;</span><br><span class="line">			--uboot|--fdt|--optee|--mcu|--bl31) # uboot.img components</span><br><span class="line">				mkdir -p $&#123;REP_DIR&#125;</span><br><span class="line">				if [ ! -f $2 ]; then</span><br><span class="line">					echo &quot;ERROR: No $2&quot;</span><br><span class="line">					exit 1</span><br><span class="line">				fi</span><br><span class="line">				if [ &quot;$1&quot; == &quot;--uboot&quot; ]; then</span><br><span class="line">					cp $2 $&#123;REP_DIR&#125;/u-boot-nodtb.bin</span><br><span class="line">				elif [ &quot;$1&quot; == &quot;--fdt&quot; ]; then</span><br><span class="line">					cp $2 $&#123;REP_DIR&#125;/u-boot.dtb</span><br><span class="line">				elif [ &quot;$1&quot; == &quot;--optee&quot; ]; then</span><br><span class="line">					cp $2 $&#123;REP_DIR&#125;/tee.bin</span><br><span class="line">				elif [ &quot;$1&quot; == &quot;--mcu&quot; ]; then</span><br><span class="line">					cp $2 $&#123;REP_DIR&#125;/mcu.bin</span><br><span class="line">				elif [ &quot;$1&quot; == &quot;--bl31&quot; ]; then</span><br><span class="line">					if ! file $2 | grep &#x27;ELF &#x27; &gt;/dev/null 2&gt;&amp;1 ; then</span><br><span class="line">						echo &quot;ERROR: $2 is not a bl31.elf file&quot;</span><br><span class="line">						exit 1</span><br><span class="line">					fi</span><br><span class="line">					cp $2 $&#123;REP_DIR&#125;/bl31.elf</span><br><span class="line">				fi</span><br><span class="line">				shift 2</span><br><span class="line">				;;</span><br><span class="line">			*)</span><br><span class="line">				#1. FIT scripts args</span><br><span class="line">				NUM=$($&#123;SCRIPT_FIT&#125; --args $1)</span><br><span class="line">				if  [ $&#123;NUM&#125; -ne 0 ]; then</span><br><span class="line">					[ $&#123;NUM&#125; -eq 1 ] &amp;&amp; ARG_LIST_FIT=&quot;$&#123;ARG_LIST_FIT&#125; $1&quot;</span><br><span class="line">					[ $&#123;NUM&#125; -eq 2 ] &amp;&amp; ARG_LIST_FIT=&quot;$&#123;ARG_LIST_FIT&#125; $1 $2&quot;</span><br><span class="line">					shift $&#123;NUM&#125;</span><br><span class="line">					continue</span><br><span class="line">				#2. unwind function address</span><br><span class="line">				elif [ -z $(echo $1 | sed &#x27;s/[0-9,a-f,A-F,x,X,-]//g&#x27;) ]; then</span><br><span class="line">					ARG_FUNCADDR=$1</span><br><span class="line">				#3. make defconfig</span><br><span class="line">				else</span><br><span class="line">					ARG_BOARD=$1</span><br><span class="line">					if [ ! -f configs/$&#123;ARG_BOARD&#125;_defconfig -a ! -f configs/$&#123;ARG_BOARD&#125;.config ]; then</span><br><span class="line">						echo -e &quot;\n$&#123;SUPPORT_LIST&#125;\n&quot;</span><br><span class="line">						echo &quot;ERROR: No configs/$&#123;ARG_BOARD&#125;_defconfig&quot;</span><br><span class="line">						exit 1</span><br><span class="line">					elif [ -f configs/$&#123;ARG_BOARD&#125;.config ]; then</span><br><span class="line">						BASE1_DEFCONFIG=`filt_val &quot;CONFIG_BASE_DEFCONFIG&quot; configs/$&#123;ARG_BOARD&#125;.config`</span><br><span class="line">						BASE0_DEFCONFIG=`filt_val &quot;CONFIG_BASE_DEFCONFIG&quot; configs/$&#123;BASE1_DEFCONFIG&#125;`</span><br><span class="line">						MAKE_CMD=&quot;make $&#123;BASE0_DEFCONFIG&#125; $&#123;BASE1_DEFCONFIG&#125; $&#123;ARG_BOARD&#125;.config -j$&#123;JOB&#125;&quot;</span><br><span class="line">						echo &quot;## $&#123;MAKE_CMD&#125;&quot;</span><br><span class="line">						make $&#123;BASE0_DEFCONFIG&#125; $&#123;BASE1_DEFCONFIG&#125; $&#123;ARG_BOARD&#125;.config $&#123;OPTION&#125;</span><br><span class="line">						rm -f $&#123;CC_FILE&#125;</span><br><span class="line">					else</span><br><span class="line">						MAKE_CMD=&quot;make $&#123;ARG_BOARD&#125;_defconfig -j$&#123;JOB&#125;&quot;</span><br><span class="line">						echo &quot;## $&#123;MAKE_CMD&#125;&quot;</span><br><span class="line">						make $&#123;ARG_BOARD&#125;_defconfig $&#123;OPTION&#125;</span><br><span class="line">						rm -f $&#123;CC_FILE&#125;</span><br><span class="line">					fi</span><br><span class="line">				fi</span><br><span class="line">				shift 1</span><br><span class="line">				;;</span><br><span class="line">		esac</span><br><span class="line">	done</span><br><span class="line"></span><br><span class="line">	if [ ! -f .config ]; then</span><br><span class="line">		echo</span><br><span class="line">		echo &quot;ERROR: No .config&quot;</span><br><span class="line">		help</span><br><span class="line">		exit 1</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选择交叉编译器</span></span><br><span class="line">function select_toolchain()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">If no outer CROSS_COMPILE, look <span class="keyword">for</span> it from CC_FILE.</span></span><br><span class="line">	if [ &quot;$&#123;ARG_COMPILE&#125;&quot; != &quot;y&quot; ]; then</span><br><span class="line">		if [ -f $&#123;CC_FILE&#125; ]; then</span><br><span class="line">			CROSS_COMPILE_ARM32=`cat $&#123;CC_FILE&#125;`</span><br><span class="line">			CROSS_COMPILE_ARM64=`cat $&#123;CC_FILE&#125;`</span><br><span class="line">		else</span><br><span class="line">			if grep -q &#x27;^CONFIG_ARM64=y&#x27; .config ; then</span><br><span class="line">				CROSS_COMPILE_ARM64=$(cd `dirname $&#123;CROSS_COMPILE_ARM64&#125;`; pwd)&quot;/aarch64-linux-gnu-&quot;</span><br><span class="line">			else</span><br><span class="line">				CROSS_COMPILE_ARM32=$(cd `dirname $&#123;CROSS_COMPILE_ARM32&#125;`; pwd)&quot;/arm-linux-gnueabihf-&quot;</span><br><span class="line">			fi</span><br><span class="line">		fi</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if grep -q &#x27;^CONFIG_ARM64=y&#x27; .config ; then</span><br><span class="line">		TOOLCHAIN=$&#123;CROSS_COMPILE_ARM64&#125;</span><br><span class="line">		TOOLCHAIN_NM=$&#123;CROSS_COMPILE_ARM64&#125;nm</span><br><span class="line">		TOOLCHAIN_OBJDUMP=$&#123;CROSS_COMPILE_ARM64&#125;objdump</span><br><span class="line">		TOOLCHAIN_ADDR2LINE=$&#123;CROSS_COMPILE_ARM64&#125;addr2line</span><br><span class="line">	else</span><br><span class="line">		TOOLCHAIN=$&#123;CROSS_COMPILE_ARM32&#125;</span><br><span class="line">		TOOLCHAIN_NM=$&#123;CROSS_COMPILE_ARM32&#125;nm</span><br><span class="line">		TOOLCHAIN_OBJDUMP=$&#123;CROSS_COMPILE_ARM32&#125;objdump</span><br><span class="line">		TOOLCHAIN_ADDR2LINE=$&#123;CROSS_COMPILE_ARM32&#125;addr2line</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [ ! `which $&#123;TOOLCHAIN&#125;gcc` ]; then</span><br><span class="line">		echo &quot;ERROR: No find $&#123;TOOLCHAIN&#125;gcc&quot;</span><br><span class="line">		exit 1</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">save to CC_FILE</span></span><br><span class="line">	if [ &quot;$&#123;ARG_COMPILE&#125;&quot; == &quot;y&quot; ]; then</span><br><span class="line">		echo &quot;$&#123;TOOLCHAIN&#125;&quot; &gt; $&#123;CC_FILE&#125;</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># We select chip info to do:</span></span></span><br><span class="line">    #RKCHIP：用于修复平台配置。</span><br><span class="line">    #RKCHIP_LOADER：搜索ini文件以打包loader。</span><br><span class="line">    #RKCHIP_TRUST：搜索ini文件以打包trust。</span><br><span class="line">    #RKCHIP_LABEL：显示构建信息。</span><br><span class="line">function select_chip_info()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Read RKCHIP firstly from .config</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">The regular expression that matching:</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"> - PX30, PX3SE</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"> - RK????, RK????X</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"> - RV????</span></span><br><span class="line">	CHIP_PATTERN=&#x27;^CONFIG_ROCKCHIP_[R,P][X,V,K][0-9ESX]&#123;1,5&#125;&#x27;</span><br><span class="line">	RKCHIP=`egrep -o $&#123;CHIP_PATTERN&#125; .config`</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">default</span></span><br><span class="line">	RKCHIP=$&#123;RKCHIP##*_&#125;</span><br><span class="line">	RKCHIP_LOADER=$&#123;RKCHIP&#125;</span><br><span class="line">	RKCHIP_TRUST=$&#123;RKCHIP&#125;</span><br><span class="line">	RKCHIP_LABEL=`filt_val &quot;CONFIG_CHIP_NAME&quot; .config`</span><br><span class="line">	if [ -z &quot;$&#123;RKCHIP_LABEL&#125;&quot; ]; then</span><br><span class="line">		RKCHIP_LABEL=$&#123;RKCHIP&#125;</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指明了在进行芯片配置时的优先级顺序，以及通过不同方式指定的优先级 Priority: default &lt; CHIP_CFG_FIXUP_TABLE() &lt; make.sh args</span></span><br><span class="line">function fixup_platform_configure()</span><br><span class="line">&#123;</span><br><span class="line">	U_KB=`filt_val &quot;CONFIG_UBOOT_SIZE_KB&quot; .config`</span><br><span class="line">	U_NUM=`filt_val &quot;CONFIG_UBOOT_NUM&quot; .config`</span><br><span class="line">	T_KB=`filt_val &quot;CONFIG_TRUST_SIZE_KB&quot; .config`</span><br><span class="line">	T_NUM=`filt_val &quot;CONFIG_TRUST_NUM&quot; .config`</span><br><span class="line">	SHA=`filt_val &quot;CONFIG_TRUST_SHA_MODE&quot; .config`</span><br><span class="line">	RSA=`filt_val &quot;CONFIG_TRUST_RSA_MODE&quot; .config`</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">.config</span></span><br><span class="line">	PLAT_UBOOT_SIZE=&quot;--size $&#123;U_KB&#125; $&#123;U_NUM&#125;&quot;</span><br><span class="line">	PLAT_TRUST_SIZE=&quot;--size $&#123;T_KB&#125; $&#123;T_NUM&#125;&quot;</span><br><span class="line">	PLAT_SHA=&quot;--sha $&#123;SHA&#125;&quot;</span><br><span class="line">	PLAT_RSA=&quot;--rsa $&#123;RSA&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">./make.sh args</span></span><br><span class="line">	if [ ! -z &quot;$&#123;ARG_UBOOT_SIZE&#125;&quot; ]; then</span><br><span class="line">		PLAT_UBOOT_SIZE=$&#123;ARG_UBOOT_SIZE&#125;</span><br><span class="line">	fi</span><br><span class="line">	if [ ! -z &quot;$&#123;ARG_TRUST_SIZE&#125;&quot; ]; then</span><br><span class="line">		PLAT_TRUST_SIZE=$&#123;ARG_TRUST_SIZE&#125;</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选择ini文件</span></span><br><span class="line">function select_ini_file()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">default</span></span><br><span class="line">	INI_LOADER=$&#123;RKBIN&#125;/RKBOOT/$&#123;RKCHIP_LOADER&#125;MINIALL.ini</span><br><span class="line">	if [ &quot;$&#123;ARM64_TRUSTZONE&#125;&quot; == &quot;y&quot; ]; then</span><br><span class="line">		INI_TRUST=$&#123;RKBIN&#125;/RKTRUST/$&#123;RKCHIP_TRUST&#125;TRUST.ini</span><br><span class="line">	else</span><br><span class="line">		INI_TRUST=$&#123;RKBIN&#125;/RKTRUST/$&#123;RKCHIP_TRUST&#125;TOS.ini</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">defconfig</span></span><br><span class="line">	NAME=`filt_val &quot;CONFIG_LOADER_INI&quot; .config`</span><br><span class="line">	if [ ! -z &quot;$&#123;NAME&#125;&quot; ]; then</span><br><span class="line">		INI_LOADER=$&#123;RKBIN&#125;/RKBOOT/$&#123;NAME&#125;</span><br><span class="line">	fi</span><br><span class="line">	NAME=`filt_val &quot;CONFIG_TRUST_INI&quot; .config`</span><br><span class="line">	if [ ! -z &quot;$&#123;NAME&#125;&quot; ]; then</span><br><span class="line">		INI_TRUST=$&#123;RKBIN&#125;/RKTRUST/$&#123;NAME&#125;</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">args</span></span><br><span class="line">	if [ ! -z &quot;$&#123;ARG_INI_TRUST&#125;&quot; ]; then</span><br><span class="line">		INI_TRUST=$&#123;ARG_INI_TRUST&#125;</span><br><span class="line">	fi</span><br><span class="line">	if [ ! -z &quot;$&#123;ARG_INI_LOADER&#125;&quot; ]; then</span><br><span class="line">		INI_LOADER=$&#123;ARG_INI_LOADER&#125;</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">各个功能的实现</span></span><br><span class="line">function sub_commands()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">skip <span class="string">&quot;--&quot;</span> parameter, such as <span class="string">&quot;--rollback-index-...&quot;</span></span></span><br><span class="line">	if [[ $&#123;CMD_ARGS&#125; != --* ]]; then</span><br><span class="line">		CMD=$&#123;CMD_ARGS%-*&#125;</span><br><span class="line">		ARG=$&#123;CMD_ARGS#*-&#125;</span><br><span class="line">	else</span><br><span class="line">		CMD=$&#123;CMD_ARGS&#125;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [ &quot;$&#123;ARG_TSPL&#125;&quot; == &quot;tpl&quot; -o &quot;$&#123;ARG_TSPL&#125;&quot; == &quot;spl&quot; ]; then</span><br><span class="line">		ELF=`find -name u-boot-$&#123;ARG_TSPL&#125;`</span><br><span class="line">		MAP=`find -name u-boot-$&#123;ARG_TSPL&#125;.map`</span><br><span class="line">		SYM=`find -name u-boot-$&#123;ARG_TSPL&#125;.sym`</span><br><span class="line">	else</span><br><span class="line">		ELF=u-boot</span><br><span class="line">		MAP=u-boot.map</span><br><span class="line">		SYM=u-boot.sym</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	case $&#123;CMD&#125; in</span><br><span class="line">		elf|nm)</span><br><span class="line">			if [ &quot;$&#123;CMD&#125;&quot; == &quot;nm&quot; ]; then</span><br><span class="line">				echo -e &quot;\n$&#123;ELF&#125;:     file format elf\n&quot;</span><br><span class="line">				$&#123;TOOLCHAIN_NM&#125; -r --size $&#123;ELF&#125; | grep -iv &#x27;b&#x27; | less</span><br><span class="line">			else</span><br><span class="line">				if [ &quot;$&#123;CMD&#125;&quot; == &quot;elf&quot; -a &quot;$&#123;ARG&#125;&quot; == &quot;elf&quot; ]; then</span><br><span class="line">					ARG=D # default</span><br><span class="line">				fi</span><br><span class="line">				$&#123;TOOLCHAIN_OBJDUMP&#125; -$&#123;ARG&#125; $&#123;ELF&#125; | less</span><br><span class="line">			fi</span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		map|sym)</span><br><span class="line">			if [ $&#123;CMD&#125; == &quot;map&quot; ]; then</span><br><span class="line">				cat $&#123;MAP&#125; | less</span><br><span class="line">			else</span><br><span class="line">				cat $&#123;SYM&#125; | less</span><br><span class="line">			fi</span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		debug)</span><br><span class="line">			./scripts/rkpatch.sh $&#123;ARG&#125;</span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		fit)</span><br><span class="line"><span class="meta prompt_">			# </span><span class="language-bash">Non-secure</span></span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash">&#123;SCRIPT_FIT&#125; --boot_img_dir images/ <span class="variable">$&#123;ARG_LIST_FIT&#125;</span></span></span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		uboot)</span><br><span class="line">			pack_uboot_image</span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		trust)</span><br><span class="line">			pack_trust_image</span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		loader)</span><br><span class="line">			pack_loader_image</span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		itb)</span><br><span class="line">			pack_uboot_itb_image</span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		env)</span><br><span class="line">			make CROSS_COMPILE=$&#123;TOOLCHAIN&#125; envtools</span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		--idblock)</span><br><span class="line">			pack_idblock</span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		--tpl|--spl|tpl|spl)</span><br><span class="line">			pack_spl_loader_image</span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		*)</span><br><span class="line">			unwind_addr_or_continue</span><br><span class="line">			;;</span><br><span class="line">	esac</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据给定的函数地址（FUNCADDR）在符号表（SYM）中查找对应的函数符号，并使用工具链的addr2line命令获取函数的源代码位置信息</span></span><br><span class="line">function unwind_addr_or_continue()</span><br><span class="line">&#123;</span><br><span class="line">	FUNCADDR=$&#123;ARG_FUNCADDR&#125;</span><br><span class="line">	RELOCOFF=$&#123;FUNCADDR#*-&#125;</span><br><span class="line">	FUNCADDR=$&#123;FUNCADDR%-*&#125;</span><br><span class="line"></span><br><span class="line">	if [ -z $(echo $&#123;FUNCADDR&#125; | sed &#x27;s/[0-9,a-f,A-F,x,X,-]//g&#x27;) ] &amp;&amp; [ $&#123;FUNCADDR&#125; ]; then</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">With prefix: <span class="string">&#x27;0x&#x27;</span> or <span class="string">&#x27;0X&#x27;</span></span></span><br><span class="line">		if [ `echo $&#123;FUNCADDR&#125; | sed -n &quot;/0[x,X]/p&quot; | wc -l` -ne 0 ]; then</span><br><span class="line">			FUNCADDR=`echo $&#123;FUNCADDR&#125; | awk &#x27;&#123; print strtonum($0) &#125;&#x27;`</span><br><span class="line">			FUNCADDR=`echo &quot;obase=16;$&#123;FUNCADDR&#125;&quot;|bc | tr &#x27;[A-Z]&#x27; &#x27;[a-z]&#x27;`</span><br><span class="line">		fi</span><br><span class="line">		if [ `echo $&#123;RELOCOFF&#125; | sed -n &quot;/0[x,X]/p&quot; | wc -l` -ne 0 ] &amp;&amp; [ $&#123;RELOCOFF&#125; ]; then</span><br><span class="line">			RELOCOFF=`echo $&#123;RELOCOFF&#125; | awk &#x27;&#123; print strtonum($0) &#125;&#x27;`</span><br><span class="line">			RELOCOFF=`echo &quot;obase=16;$&#123;RELOCOFF&#125;&quot;|bc | tr &#x27;[A-Z]&#x27; &#x27;[a-z]&#x27;`</span><br><span class="line">		fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">If reloc address is assigned, <span class="keyword">do</span> sub</span></span><br><span class="line">		if [ &quot;$&#123;FUNCADDR&#125;&quot; != &quot;$&#123;RELOCOFF&#125;&quot; ]; then</span><br><span class="line"><span class="meta prompt_">			# </span><span class="language-bash">Hex -&gt; Dec -&gt; SUB -&gt; Hex</span></span><br><span class="line">			FUNCADDR=`echo $((16#$&#123;FUNCADDR&#125;))`</span><br><span class="line">			RELOCOFF=`echo $((16#$&#123;RELOCOFF&#125;))`</span><br><span class="line">			FUNCADDR=$((FUNCADDR-RELOCOFF))</span><br><span class="line">			FUNCADDR=$(echo &quot;obase=16;$&#123;FUNCADDR&#125;&quot;|bc | tr &#x27;[A-Z]&#x27; &#x27;[a-z]&#x27;)</span><br><span class="line">		fi</span><br><span class="line"></span><br><span class="line">		echo</span><br><span class="line">		sed -n &quot;/$&#123;FUNCADDR&#125;/p&quot; $&#123;SYM&#125;</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">&#123;TOOLCHAIN_ADDR2LINE&#125; -e <span class="variable">$&#123;ELF&#125;</span> <span class="variable">$&#123;FUNCADDR&#125;</span></span></span><br><span class="line">		exit 0</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包生成一个名为idblock.bin的文件</span></span><br><span class="line">function pack_idblock()</span><br><span class="line">&#123;</span><br><span class="line">	INI=$&#123;INI_LOADER&#125;</span><br><span class="line">	if [ ! -f $&#123;INI&#125; ]; then</span><br><span class="line">		echo &quot;ERROR: No $&#123;INI&#125;&quot;</span><br><span class="line">		exit 1</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">chip</span></span><br><span class="line">	COMMON_H=`grep &quot;_common.h:&quot; include/autoconf.mk.dep | awk -F &quot;/&quot; &#x27;&#123; printf $3 &#125;&#x27;`</span><br><span class="line">	PLAT=$&#123;COMMON_H%_*&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">file</span></span><br><span class="line">	SPL_BIN=$&#123;RKBIN&#125;/`filt_val &quot;FlashBoot&quot; $&#123;INI&#125;`</span><br><span class="line">	TPL_BIN=$&#123;RKBIN&#125;/`filt_val &quot;FlashData&quot; $&#123;INI&#125;`</span><br><span class="line">	if [ ! -z &quot;$&#123;ARG_SPL_BIN&#125;&quot; ]; then</span><br><span class="line">		SPL_BIN=$&#123;ARG_SPL_BIN&#125;</span><br><span class="line">	fi</span><br><span class="line">	if [ ! -z &quot;$&#123;ARG_TPL_BIN&#125;&quot; ]; then</span><br><span class="line">		TPL_BIN=$&#123;ARG_TPL_BIN&#125;</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">pack</span></span><br><span class="line">	rm idblock.bin -f</span><br><span class="line">	./tools/mkimage -n $&#123;PLAT&#125; -T rksd -d $&#123;TPL_BIN&#125;:$&#123;SPL_BIN&#125; idblock.bin</span><br><span class="line">	echo &quot;Input:&quot;</span><br><span class="line">	echo &quot;    $&#123;INI&#125;&quot;</span><br><span class="line">	echo &quot;    $&#123;TPL_BIN&#125;&quot;</span><br><span class="line">	echo &quot;    $&#123;SPL_BIN&#125;&quot;</span><br><span class="line">	echo</span><br><span class="line">	echo &quot;Pack $&#123;PLAT&#125; idblock.bin okay!&quot;</span><br><span class="line">	echo</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包生成uboot_itb镜像</span></span><br><span class="line">function pack_uboot_itb_image()</span><br><span class="line">&#123;</span><br><span class="line">	INI=$&#123;INI_TRUST&#125;</span><br><span class="line">	if [ ! -f $&#123;INI&#125; ]; then</span><br><span class="line">		echo &quot;ERROR: No $&#123;INI&#125;&quot;</span><br><span class="line">		exit 1</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [ &quot;$&#123;ARM64_TRUSTZONE&#125;&quot; == &quot;y&quot; ]; then</span><br><span class="line">		BL31_ELF=`sed -n &#x27;/_bl31_/s/PATH=//p&#x27; $&#123;INI&#125; | tr -d &#x27;\r&#x27;`</span><br><span class="line">		BL32_BIN=`sed -n &#x27;/_bl32_/s/PATH=//p&#x27; $&#123;INI&#125; | tr -d &#x27;\r&#x27;`</span><br><span class="line">		rm bl31.elf tee.bin -rf</span><br><span class="line">		cp $&#123;RKBIN&#125;/$&#123;BL31_ELF&#125; bl31.elf</span><br><span class="line">		if grep BL32_OPTION -A 1 $&#123;INI&#125; | grep SEC=1 ; then</span><br><span class="line">			cp $&#123;RKBIN&#125;/$&#123;BL32_BIN&#125; tee.bin</span><br><span class="line">			TEE_OFFSET=`grep BL32_OPTION -A 3 $&#123;INI&#125; | grep ADDR= | awk -F &quot;=&quot; &#x27;&#123; printf $2 &#125;&#x27; | tr -d &#x27;\r&#x27;`</span><br><span class="line">			TEE_ARG=&quot;-t $&#123;TEE_OFFSET&#125;&quot;</span><br><span class="line">		fi</span><br><span class="line">	else</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">TOS</span></span><br><span class="line">		TOS=`filt_val &quot;TOS&quot; $&#123;INI&#125;`</span><br><span class="line">		TOSTA=`filt_val &quot;TOSTA&quot; $&#123;INI&#125;`</span><br><span class="line">		if [ ! -z &quot;$&#123;TOSTA&#125;&quot; ]; then</span><br><span class="line">			cp $&#123;RKBIN&#125;/$&#123;TOSTA&#125; tee.bin</span><br><span class="line">		elif [ ! -z &quot;$&#123;TOS&#125;&quot; ]; then</span><br><span class="line">			cp $&#123;RKBIN&#125;/$&#123;TOS&#125;   tee.bin</span><br><span class="line">		else</span><br><span class="line">			echo &quot;WARN: No tee bin&quot;</span><br><span class="line">		fi</span><br><span class="line">		if [ ! -z &quot;$&#123;TOSTA&#125;&quot; -o ! -z &quot;$&#123;TOS&#125;&quot; ]; then</span><br><span class="line">			TEE_OFFSET=`filt_val &quot;ADDR&quot; $&#123;INI&#125;`</span><br><span class="line">			if [ &quot;$&#123;TEE_OFFSET&#125;&quot; == &quot;&quot; ]; then</span><br><span class="line">				TEE_OFFSET=0x8400000</span><br><span class="line">			fi</span><br><span class="line">			TEE_ARG=&quot;-t $&#123;TEE_OFFSET&#125;&quot;</span><br><span class="line">		fi</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">MCUs</span></span><br><span class="line">	for ((i=0; i&lt;5; i++))</span><br><span class="line">	do</span><br><span class="line">		MCU_BIN=&quot;mcu$&#123;i&#125;.bin&quot;</span><br><span class="line">		MCU_IDX=&quot;MCU$&#123;i&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">compatible: use <span class="string">&quot;MCU&quot;</span> to replace <span class="string">&quot;MCU0&quot;</span> <span class="keyword">if</span> <span class="string">&quot;MCU&quot;</span> is present.</span></span><br><span class="line">		ENABLED=`awk -F&quot;,&quot; &#x27;/MCU=/  &#123; printf $3 &#125;&#x27; $&#123;INI&#125; | tr -d &#x27; &#x27;`</span><br><span class="line">		if [ $&#123;i&#125; -eq 0 ]; then</span><br><span class="line">			ENABLED=`awk -F&quot;,&quot; &#x27;/MCU=/  &#123; printf $3 &#125;&#x27; $&#123;INI&#125; | tr -d &#x27; &#x27;`</span><br><span class="line">			if [ ! -z $&#123;ENABLED&#125; ]; then</span><br><span class="line">				MCU_IDX=&quot;MCU&quot;</span><br><span class="line">			fi</span><br><span class="line">		fi</span><br><span class="line"></span><br><span class="line">		ENABLED=`awk -F &quot;,&quot; &#x27;/&#x27;$&#123;MCU_IDX&#125;&#x27;=/  &#123; printf $3 &#125;&#x27; $&#123;INI&#125; | tr -d &#x27; &#x27;`</span><br><span class="line">		if [ &quot;$&#123;ENABLED&#125;&quot; == &quot;enabled&quot; -o &quot;$&#123;ENABLED&#125;&quot; == &quot;okay&quot; ]; then</span><br><span class="line">			NAME=`awk -F &quot;,&quot; &#x27;/&#x27;$&#123;MCU_IDX&#125;&#x27;=/ &#123; printf $1 &#125;&#x27; $&#123;INI&#125; | tr -d &#x27; &#x27; | awk -F &quot;=&quot; &#x27;&#123; print $2 &#125;&#x27;`</span><br><span class="line">			OFFS=`awk -F &quot;,&quot; &#x27;/&#x27;$&#123;MCU_IDX&#125;&#x27;=/ &#123; printf $2 &#125;&#x27; $&#123;INI&#125; | tr -d &#x27; &#x27;`</span><br><span class="line">			cp $&#123;RKBIN&#125;/$&#123;NAME&#125; $&#123;MCU_BIN&#125;</span><br><span class="line">			if [ -z $&#123;OFFS&#125; ]; then</span><br><span class="line">				echo &quot;ERROR: No $&#123;MCU_BIN&#125; address in $&#123;INI&#125;&quot;</span><br><span class="line">				exit 1</span><br><span class="line">			fi</span><br><span class="line">			MCU_ARG=$&#123;MCU_ARG&#125;&quot; -m$&#123;i&#125; $&#123;OFFS&#125;&quot;</span><br><span class="line">		fi</span><br><span class="line">	done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Loadables</span></span><br><span class="line">	for ((i=0; i&lt;5; i++))</span><br><span class="line">	do</span><br><span class="line">		LOAD_BIN=&quot;load$&#123;i&#125;.bin&quot;</span><br><span class="line">		LOAD_IDX=&quot;LOAD$&#123;i&#125;&quot;</span><br><span class="line">		ENABLED=`awk -F &quot;,&quot; &#x27;/&#x27;$&#123;LOAD_IDX&#125;&#x27;=/  &#123; printf $3 &#125;&#x27; $&#123;INI&#125; | tr -d &#x27; &#x27;`</span><br><span class="line">		if [ &quot;$&#123;ENABLED&#125;&quot; == &quot;enabled&quot; -o &quot;$&#123;ENABLED&#125;&quot; == &quot;okay&quot; ]; then</span><br><span class="line">			NAME=`awk -F &quot;,&quot; &#x27;/&#x27;$&#123;LOAD_IDX&#125;&#x27;=/ &#123; printf $1 &#125;&#x27; $&#123;INI&#125; | tr -d &#x27; &#x27; | awk -F &quot;=&quot; &#x27;&#123; print $2 &#125;&#x27;`</span><br><span class="line">			OFFS=`awk -F &quot;,&quot; &#x27;/&#x27;$&#123;LOAD_IDX&#125;&#x27;=/ &#123; printf $2 &#125;&#x27; $&#123;INI&#125; | tr -d &#x27; &#x27;`</span><br><span class="line">			cp $&#123;RKBIN&#125;/$&#123;NAME&#125; $&#123;LOAD_BIN&#125;</span><br><span class="line">			if [ -z $&#123;OFFS&#125; ]; then</span><br><span class="line">				echo &quot;ERROR: No $&#123;LOAD_BIN&#125; address in $&#123;INI&#125;&quot;</span><br><span class="line">				exit 1</span><br><span class="line">			fi</span><br><span class="line">			LOAD_ARG=$&#123;LOAD_ARG&#125;&quot; -l$&#123;i&#125; $&#123;OFFS&#125;&quot;</span><br><span class="line">		fi</span><br><span class="line">	done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">COMPRESSION</span></span><br><span class="line">	COMPRESSION=`awk -F&quot;,&quot; &#x27;/COMPRESSION=/  &#123; printf $1 &#125;&#x27; $&#123;INI&#125; | tr -d &#x27; &#x27; | cut -c 13-`</span><br><span class="line">	if [ ! -z &quot;$&#123;COMPRESSION&#125;&quot; -a &quot;$&#123;COMPRESSION&#125;&quot; != &quot;none&quot; ]; then</span><br><span class="line">		COMPRESSION_ARG=&quot;-c $&#123;COMPRESSION&#125;&quot;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [ -d $&#123;REP_DIR&#125; ]; then</span><br><span class="line">		mv $&#123;REP_DIR&#125;/* ./</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	SPL_FIT_SOURCE=`filt_val &quot;CONFIG_SPL_FIT_SOURCE&quot; .config`</span><br><span class="line">	if [ ! -z $&#123;SPL_FIT_SOURCE&#125; ]; then</span><br><span class="line">		cp $&#123;SPL_FIT_SOURCE&#125; u-boot.its</span><br><span class="line">	else</span><br><span class="line">		SPL_FIT_GENERATOR=`filt_val &quot;CONFIG_SPL_FIT_GENERATOR&quot; .config`</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">*.py is the legacy one.</span></span><br><span class="line">		if [[ $&#123;SPL_FIT_GENERATOR&#125; == *.py ]]; then</span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash">&#123;SPL_FIT_GENERATOR&#125; u-boot.dtb &gt; u-boot.its</span></span><br><span class="line">		else</span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash">&#123;SPL_FIT_GENERATOR&#125; <span class="variable">$&#123;TEE_ARG&#125;</span> <span class="variable">$&#123;COMPRESSION_ARG&#125;</span> <span class="variable">$&#123;MCU_ARG&#125;</span> <span class="variable">$&#123;LOAD_ARG&#125;</span> &gt; u-boot.its</span></span><br><span class="line">		fi</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	./tools/mkimage -f u-boot.its -E u-boot.itb &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">	echo &quot;pack u-boot.itb okay! Input: $&#123;INI&#125;&quot;</span><br><span class="line">	echo</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包生成spl_loader镜像</span></span><br><span class="line">function pack_spl_loader_image()</span><br><span class="line">&#123;</span><br><span class="line">	rm -f *loader*.bin *download*.bin *idblock*.img</span><br><span class="line">	cd $&#123;RKBIN&#125;</span><br><span class="line">	DEF_PATH=$&#123;RKBIN&#125;/`filt_val &quot;^PATH&quot; $&#123;INI_LOADER&#125;`</span><br><span class="line">	IDB_PATH=$&#123;RKBIN&#125;/`filt_val &quot;IDB_PATH&quot; $&#123;INI_LOADER&#125;`</span><br><span class="line">	if [ ! -z &quot;$&#123;ARG_SPL_BIN&#125;&quot; -a ! -z &quot;$&#123;ARG_TPL_BIN&#125;&quot; ]; then</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">&#123;SCRIPT_SPL&#125; --ini <span class="variable">$&#123;INI_LOADER&#125;</span> --tpl <span class="variable">$&#123;SRCTREE&#125;</span>/<span class="variable">$&#123;ARG_TPL_BIN&#125;</span> --spl <span class="variable">$&#123;SRCTREE&#125;</span>/<span class="variable">$&#123;ARG_SPL_BIN&#125;</span></span></span><br><span class="line">	elif [ ! -z &quot;$&#123;ARG_TPL_BIN&#125;&quot; ]; then</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">&#123;SCRIPT_SPL&#125; --ini <span class="variable">$&#123;INI_LOADER&#125;</span> --tpl <span class="variable">$&#123;SRCTREE&#125;</span>/<span class="variable">$&#123;ARG_TPL_BIN&#125;</span></span></span><br><span class="line">	else</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">&#123;SCRIPT_SPL&#125; --ini <span class="variable">$&#123;INI_LOADER&#125;</span> --spl <span class="variable">$&#123;SRCTREE&#125;</span>/<span class="variable">$&#123;ARG_SPL_BIN&#125;</span></span></span><br><span class="line">	fi</span><br><span class="line">	cd -</span><br><span class="line">	if [ -f $&#123;DEF_PATH&#125; ]; then</span><br><span class="line">		mv $&#123;DEF_PATH&#125; ./</span><br><span class="line">	fi</span><br><span class="line">	if [ -f $&#123;IDB_PATH&#125; ]; then</span><br><span class="line">		mv $&#123;IDB_PATH&#125; ./</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包生成uboot镜像</span></span><br><span class="line">function pack_uboot_image()</span><br><span class="line">&#123;</span><br><span class="line">	rm u-boot.img u-boot-dtb.img -f</span><br><span class="line">	LOAD_ADDR=`sed -n &quot;/CONFIG_SYS_TEXT_BASE=/s/CONFIG_SYS_TEXT_BASE=//p&quot; include/autoconf.mk|tr -d &#x27;\r&#x27;`</span><br><span class="line">	if [ -z &quot;$&#123;LOAD_ADDR&#125;&quot; ]; then</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">upstream U-Boot</span></span><br><span class="line">		LOAD_ADDR=`grep CONFIG_SYS_TEXT_BASE include/generated/autoconf.h | awk &#x27;&#123; print $3 &#125;&#x27; | tr -d &#x27;\r&#x27;`</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [ -z &quot;$&#123;LOAD_ADDR&#125;&quot; ]; then</span><br><span class="line">		echo &quot;ERROR: No CONFIG_SYS_TEXT_BASE for u-boot&quot;;</span><br><span class="line">		exit 1</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">&#123;SCRIPT_UBOOT&#125; --load <span class="variable">$&#123;LOAD_ADDR&#125;</span> <span class="variable">$&#123;PLAT_UBOOT_SIZE&#125;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包生成loader镜像</span></span><br><span class="line">function pack_loader_image()</span><br><span class="line">&#123;</span><br><span class="line">	rm -f *loader*.bin *download*.bin *idblock*.img</span><br><span class="line">	cd $&#123;RKBIN&#125;</span><br><span class="line">	DEF_PATH=$&#123;RKBIN&#125;/`filt_val &quot;^PATH&quot; $&#123;INI_LOADER&#125;`</span><br><span class="line">	IDB_PATH=$&#123;RKBIN&#125;/`filt_val &quot;IDB_PATH&quot; $&#123;INI_LOADER&#125;`</span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">&#123;SCRIPT_LOADER&#125; --ini <span class="variable">$&#123;INI_LOADER&#125;</span></span></span><br><span class="line">	cd -</span><br><span class="line">	if [ -f $&#123;DEF_PATH&#125; ]; then</span><br><span class="line">		mv $&#123;DEF_PATH&#125; ./</span><br><span class="line">	fi</span><br><span class="line">	if [ -f $&#123;IDB_PATH&#125; ]; then</span><br><span class="line">		mv $&#123;IDB_PATH&#125; ./</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包生成trust镜像</span></span><br><span class="line">function pack_trust_image()</span><br><span class="line">&#123;</span><br><span class="line">	DRAM_BASE=`filt_val &quot;CONFIG_SYS_SDRAM_BASE&quot; include/autoconf.mk`</span><br><span class="line"></span><br><span class="line">	rm trust*.img -f</span><br><span class="line">	cd $&#123;RKBIN&#125;</span><br><span class="line">	if [ &quot;$&#123;ARM64_TRUSTZONE&#125;&quot; == &quot;y&quot; ]; then</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">&#123;SCRIPT_ATF&#125; --ini <span class="variable">$&#123;INI_TRUST&#125;</span> <span class="variable">$&#123;PLAT_SHA&#125;</span> <span class="variable">$&#123;PLAT_RSA&#125;</span> <span class="variable">$&#123;PLAT_TRUST_SIZE&#125;</span></span></span><br><span class="line">	else</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">&#123;SCRIPT_TOS&#125; --ini <span class="variable">$&#123;INI_TRUST&#125;</span> --base <span class="variable">$&#123;DRAM_BASE&#125;</span> <span class="variable">$&#123;PLAT_TRUST_SIZE&#125;</span></span></span><br><span class="line">	fi</span><br><span class="line">	cd -</span><br><span class="line">	if [ -f $&#123;RKBIN&#125;/trust*.img ]; then</span><br><span class="line">		mv $&#123;RKBIN&#125;/trust*.img ./</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包生成fit镜像</span></span><br><span class="line">function pack_fit_image()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">check host tools</span></span><br><span class="line">	if ! which dtc &gt;/dev/null 2&gt;&amp;1 ; then</span><br><span class="line">		echo &quot;ERROR: No &#x27;dtc&#x27;, please: apt-get install device-tree-compiler&quot;</span><br><span class="line">		exit 1</span><br><span class="line">	elif [ &quot;$&#123;ARM64_TRUSTZONE&#125;&quot; == &quot;y&quot; ]; then</span><br><span class="line">		if ! which python2 &gt;/dev/null 2&gt;&amp;1 ; then</span><br><span class="line">			echo &quot;ERROR: No python2&quot;</span><br><span class="line">			exit 1</span><br><span class="line">		fi</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">If we don<span class="string">&#x27;t plan to have uboot in uboot.img in case of: SPL =&gt; Trust =&gt; Kernel, creating empty files.</span></span></span><br><span class="line">	if [ &quot;$&#123;ARG_NO_UBOOT&#125;&quot; == &quot;y&quot; ]; then</span><br><span class="line">		rm u-boot-nodtb.bin u-boot.dtb -f</span><br><span class="line">		touch u-boot-nodtb.bin u-boot.dtb</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	rm uboot.img trust*.img -rf</span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash"><span class="string">&#123;SCRIPT_FIT&#125; $&#123;ARG_LIST_FIT&#125; --chip $&#123;RKCHIP_LABEL&#125;</span></span></span><br><span class="line"></span><br><span class="line">	rm $&#123;REP_DIR&#125; -rf</span><br><span class="line">	echo &quot;pack uboot.img okay! Input: $&#123;INI_TRUST&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function handle_args_late()</span><br><span class="line">&#123;</span><br><span class="line">	ARG_LIST_FIT=&quot;$&#123;ARG_LIST_FIT&#125; --ini-trust $&#123;INI_TRUST&#125; --ini-loader $&#123;INI_LOADER&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">清理文件</span></span></span><br><span class="line">function clean_files()</span><br><span class="line">&#123;</span><br><span class="line">	rm spl/u-boot-spl.dtb tpl/u-boot-tpl.dtb u-boot.dtb -f</span><br><span class="line">	rm spl/u-boot-spl tpl/u-boot-tpl u-boot -f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function pack_images()</span><br><span class="line">&#123;</span><br><span class="line">	if [ &quot;$&#123;ARG_RAW_COMPILE&#125;&quot; != &quot;y&quot; ]; then</span><br><span class="line">		if [ &quot;$&#123;PLAT_TYPE&#125;&quot; == &quot;FIT&quot; ]; then</span><br><span class="line">			pack_fit_image $&#123;ARG_LIST_FIT&#125;</span><br><span class="line">		elif [ &quot;$&#123;PLAT_TYPE&#125;&quot; == &quot;DECOMP&quot; ]; then</span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash"><span class="string">&#123;SCRIPT_DECOMP&#125; $&#123;ARG_LIST_FIT&#125; --chip $&#123;RKCHIP_LABEL&#125;</span></span></span><br><span class="line">		else</span><br><span class="line">			pack_uboot_image</span><br><span class="line">			pack_trust_image</span><br><span class="line">			pack_loader_image</span><br><span class="line">		fi</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">编译完成</span></span></span><br><span class="line">function finish()</span><br><span class="line">&#123;</span><br><span class="line">	echo</span><br><span class="line">	if [ &quot;$&#123;ARG_BOARD&#125;&quot; == &quot;&quot; ]; then</span><br><span class="line">		echo &quot;Platform $&#123;RKCHIP_LABEL&#125; is build OK, with exist .config&quot;</span><br><span class="line">	else</span><br><span class="line">		echo &quot;Platform $&#123;RKCHIP_LABEL&#125; is build OK, with new .config($&#123;MAKE_CMD&#125;)&quot;</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process_args $*</span><br><span class="line">prepare</span><br><span class="line">select_toolchain</span><br><span class="line">select_chip_info</span><br><span class="line">fixup_platform_configure</span><br><span class="line">select_ini_file</span><br><span class="line">handle_args_late</span><br><span class="line">sub_commands</span><br><span class="line">clean_files</span><br><span class="line">make PYTHON=python2 CROSS_COMPILE=$&#123;TOOLCHAIN&#125; all --jobs=$&#123;JOB&#125;</span><br><span class="line">pack_images</span><br><span class="line">finish</span><br><span class="line">echo $&#123;TOOLCHAIN&#125;</span><br><span class="line">date</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>瑞芯微脚本分析</category>
      </categories>
      <tags>
        <tag>瑞芯微脚本分析</tag>
      </tags>
  </entry>
  <entry>
    <title>0-9 .make.sh rk3568编译命令执行分析（上）</title>
    <url>/2023/09/10/0-9%20.make.sh%20rk3568%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89%20/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、打开脚本冗余输出"><a href="#一、打开脚本冗余输出" class="headerlink" title="一、打开脚本冗余输出"></a>一、打开脚本冗余输出</h2><p>在<code>make.sh</code>添加<code>set -x</code>：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207615.png" alt="img"><br>然后执行编译即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./make.sh rk3568</span><br></pre></td></tr></table></figure>

<h2 id="二、编译线程数设置"><a href="#二、编译线程数设置" class="headerlink" title="二、编译线程数设置"></a>二、编译线程数设置</h2><p>从输出来看，把变量<code>JOB</code>赋值为<code>8</code>：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207547.png" alt="img"><br>这个变量<code>JOB</code>用于后续以下编译命令使用（多线程编译用于提高编译速度）：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207647.png" alt="img"></p>
<h2 id="三、编译相关变量初始化"><a href="#三、编译相关变量初始化" class="headerlink" title="三、编译相关变量初始化"></a>三、编译相关变量初始化</h2><p>把编译命令<code>./make.sh rk3568</code>的<code>rk3568</code>赋值到<code>CMD_ARGS</code>变量，并制定工具链目录与声明一些变量：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207594.png" alt="img"><br>脚本源代码（注释中指明<code>RKBIN_TOOLS</code>、<code>CROSS_COMPILE_ARM32</code>与<code>CROSS_COMPILE_ARM64</code>变量用户可以修改制定）：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207618.png" alt="img"><br>制定目录树路径与脚本工具（这些都是RK自定义的脚本工具）：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207588.png" alt="img"><br>脚本源代码：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207795.png" alt="img"></p>
<h2 id="四、执行脚本函数与编译"><a href="#四、执行脚本函数与编译" class="headerlink" title="四、执行脚本函数与编译"></a>四、执行脚本函数与编译</h2><p>脚本函数与编译按照顺序执行如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207832.png" alt="img"></p>
<h3 id="4-1-执行process-args与prepare"><a href="#4-1-执行process-args与prepare" class="headerlink" title="4.1 执行process_args与prepare"></a>4.1 执行process_args与prepare</h3><p>首先执行<code>process_args</code>函数，传递的参数是<code>rk3568</code>，在此处主要是用于生成<code>.config</code>使用，从输出信息看，目的是执行了<code>make rk3568_defconfig</code>，接着执行<code>prepare</code>函数，它主要制定<code>RKBIN</code>的真实路径、是否使能<code>ARM64_TRUSTZONE</code>与<code>PLAT_TYPE</code>是否为<code>FIT</code>格式：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207907.png" alt="img"><code>process_args rk3568</code>执行的源代码如下：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207899.png" alt="img"><code>prepare</code>函数执行如下：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207920.png" alt="img"></p>
<h3 id="4-2-执行select-toolchain与select-chip-info"><a href="#4-2-执行select-toolchain与select-chip-info" class="headerlink" title="4.2 执行select_toolchain与select_chip_info"></a>4.2 执行select_toolchain与select_chip_info</h3><p><code>select_toolchain</code> 函数是选择交叉工具链的意思，从打印日志可以看出，它首先判断系统是否是64位，然后从<code>../prebuilts/gcc/linux-x86/aarch64/</code>目录寻找交叉工具链，设置<code>TOOLCHAIN</code>、<code>TOOLCHAIN_NM</code>、<code>TOOLCHAIN_OBJDUMP</code>与<code>TOOLCHAIN_ADDR2LINE</code>；<code>select_chip_info</code>函数则为选择芯片信息，通过<code>.config</code>文件的<code>CONFIG_ROCKCHIP_RK3568</code>配置，设置<code>RKCHIP</code>、<code>RKCHIP_LOADER</code>、<code>RKCHIP_TRUST</code>与<code>RKCHIP_LABEL</code>环境变量：<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207978.png" alt="img"><br><code>select_toolchain</code>函数执行如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207074.png" alt="img"><br><code>select_chip_info</code>函数执行如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207105.png" alt="img">这里还有注释说明了这些<code>RKCHIP</code>环境变量的作用！</p>
<h3 id="4-3-执行fixup-platform-configure"><a href="#4-3-执行fixup-platform-configure" class="headerlink" title="4.3 执行fixup_platform_configure"></a>4.3 执行fixup_platform_configure</h3><p>我们看到这个很多个环境变量都是没有值的，这说明在 RK356x，<code>fixup_platform_configure</code>函数其实用不到：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207151.png" alt="img"><br><code>fixup_platform_configure</code>函数执行如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207192.png" alt="img"></p>
<h3 id="4-4-执行select-ini-file、handle-args-late与sub-commands"><a href="#4-4-执行select-ini-file、handle-args-late与sub-commands" class="headerlink" title="4.4 执行select_ini_file、handle_args_late与sub_commands"></a>4.4 执行select_ini_file、handle_args_late与sub_commands</h3><p><code>select_ini_file</code> 函数用于选择<code>rkbin</code>目录下对应平台的<code>ini</code>文件，包括<code>INI_LOADER</code>与<code>INI_TRUST</code>；<code>handle_args_late</code>解决通过命令参数制定<code>ini</code>，并保存到<code>ARG_LIST_FIT</code>；<code>sub_commands</code>设置一些 U-Boot EFL、符号文件与映射文件等等：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207226.png" alt="img"><br><code>select_ini_file</code> 函数执行如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207276.png" alt="img"><br>从代码可以看出，<code>ini</code>文件既有默认指定，也能在配置文件与命令参数中指定！</p>
<p><code>handle_args_late</code> 函数执行如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207354.png" alt="img"></p>
<p><code>sub_commands</code> 函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sub_commands()</span><br><span class="line">&#123;</span><br><span class="line">	# skip &quot;--&quot; parameter, such as &quot;--rollback-index-...&quot;</span><br><span class="line">	if [[ $&#123;CMD_ARGS&#125; != --* ]]; then</span><br><span class="line">		CMD=$&#123;CMD_ARGS%-*&#125;</span><br><span class="line">		ARG=$&#123;CMD_ARGS#*-&#125;</span><br><span class="line">	else</span><br><span class="line">		CMD=$&#123;CMD_ARGS&#125;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [ &quot;$&#123;ARG_TSPL&#125;&quot; == &quot;tpl&quot; -o &quot;$&#123;ARG_TSPL&#125;&quot; == &quot;spl&quot; ]; then</span><br><span class="line">		ELF=`find -name u-boot-$&#123;ARG_TSPL&#125;`</span><br><span class="line">		MAP=`find -name u-boot-$&#123;ARG_TSPL&#125;.map`</span><br><span class="line">		SYM=`find -name u-boot-$&#123;ARG_TSPL&#125;.sym`</span><br><span class="line">	else</span><br><span class="line">		ELF=u-boot</span><br><span class="line">		MAP=u-boot.map</span><br><span class="line">		SYM=u-boot.sym</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	case $&#123;CMD&#125; in</span><br><span class="line">		elf|nm)</span><br><span class="line">			if [ &quot;$&#123;CMD&#125;&quot; == &quot;nm&quot; ]; then</span><br><span class="line">				echo -e &quot;\n$&#123;ELF&#125;:     file format elf\n&quot;</span><br><span class="line">				$&#123;TOOLCHAIN_NM&#125; -r --size $&#123;ELF&#125; | grep -iv &#x27;b&#x27; | less</span><br><span class="line">			else</span><br><span class="line">				if [ &quot;$&#123;CMD&#125;&quot; == &quot;elf&quot; -a &quot;$&#123;ARG&#125;&quot; == &quot;elf&quot; ]; then</span><br><span class="line">					ARG=D # default</span><br><span class="line">				fi</span><br><span class="line">				$&#123;TOOLCHAIN_OBJDUMP&#125; -$&#123;ARG&#125; $&#123;ELF&#125; | less</span><br><span class="line">			fi</span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		map|sym)</span><br><span class="line">			if [ $&#123;CMD&#125; == &quot;map&quot; ]; then</span><br><span class="line">				cat $&#123;MAP&#125; | less</span><br><span class="line">			else</span><br><span class="line">				cat $&#123;SYM&#125; | less</span><br><span class="line">			fi</span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		debug)</span><br><span class="line">			./scripts/rkpatch.sh $&#123;ARG&#125;</span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		fit)</span><br><span class="line">			# Non-secure</span><br><span class="line">			$&#123;SCRIPT_FIT&#125; --boot_img_dir images/ $&#123;ARG_LIST_FIT&#125;</span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		uboot)</span><br><span class="line">			pack_uboot_image</span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		trust)</span><br><span class="line">			pack_trust_image</span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		loader)</span><br><span class="line">			pack_loader_image</span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		itb)</span><br><span class="line">			pack_uboot_itb_image</span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		env)</span><br><span class="line">			make CROSS_COMPILE=$&#123;TOOLCHAIN&#125; envtools</span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		--idblock)</span><br><span class="line">			pack_idblock</span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		--tpl|--spl|tpl|spl)</span><br><span class="line">			pack_spl_loader_image</span><br><span class="line">			exit 0</span><br><span class="line">			;;</span><br><span class="line">		*)</span><br><span class="line">			unwind_addr_or_continue</span><br><span class="line">			;;</span><br><span class="line">	esac</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sub_commands</code> 函数功能丰富，只有传特定参数的时候才能用到！</p>
<h3 id="4-5-执行clean-files、make与pack-images"><a href="#4-5-执行clean-files、make与pack-images" class="headerlink" title="4.5 执行clean_files、make与pack_images"></a>4.5 执行clean_files、make与pack_images</h3><p><code>clean_files</code>函数删除历史编译产生的的<code>dtb</code>、<code>spl</code>、<code>tpl</code>与<code>u-boot</code>文件；然后执行<code>make</code>开启<code>8</code>线程编译；最后是<code>pack_images</code>打包固件，由 RK356x 使用 FIT 格式打包，因此调用<code>pack_fit_image</code>函数，参数是前面<code>handle_args_late</code>函数执行的结果，在<code>pack_fit_image</code>函数中继续调用<code>script/fit.sh</code>脚本：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207378.png" alt="img"><code>clean_files</code>函数执行如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207411.png" alt="img"><br><code>make</code>执行如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207532.png" alt="img"><br><code>pack_images</code>函数执行如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207636.png" alt="img"><br><code>pack_fit_image</code>函数执行如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309122207668.png" alt="img"></p>
]]></content>
      <categories>
        <category>瑞芯微脚本分析</category>
      </categories>
      <tags>
        <tag>瑞芯微脚本分析</tag>
      </tags>
  </entry>
  <entry>
    <title>0-5 SPL的编译</title>
    <url>/2023/09/10/0-5%20SPL%E7%9A%84%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Version V1.08 20220617</span><br><span class="line">LPDDR4X, 2112MHz</span><br><span class="line">channel[0] BW=16 Col=10 Bk=8 CS0 Row=16 CS=1 Die BW=16 Size=1024MB</span><br><span class="line">channel[1] BW=16 Col=10 Bk=8 CS0 Row=16 CS=1 Die BW=16 Size=1024MB</span><br><span class="line">channel[2] BW=16 Col=10 Bk=8 CS0 Row=16 CS=1 Die BW=16 Size=1024MB</span><br><span class="line">channel[3] BW=16 Col=10 Bk=8 CS0 Row=16 CS=1 Die BW=16 Size=1024MB</span><br><span class="line">Manufacturer ID:0x1 Samsung</span><br><span class="line">CH0 RX Vref:33.7%, TX Vref:21.8%,0.0%</span><br><span class="line">CH1 RX Vref:32.7%, TX Vref:18.8%,0.0%</span><br><span class="line">CH2 RX Vref:30.7%, TX Vref:17.8%,0.0%</span><br><span class="line">CH3 RX Vref:34.7%, TX Vref:18.8%,0.0%</span><br><span class="line">change to F1: 528MHz</span><br><span class="line">change to F2: 1068MHz</span><br><span class="line">change to F3: 1560MHz</span><br><span class="line">change to F0: 2112MHz</span><br><span class="line">out</span><br><span class="line">U-Boot SPL board init</span><br><span class="line">U-Boot SPL 2017.09-orangepi (Apr 21 2023 - 10:35:39)</span><br><span class="line">Trying to boot from MMC1</span><br><span class="line">Trying fit image at 0x4000 sector</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Verified-boot: 0</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Checking atf-1 0x00040000 ... sha256(806278dba1...) + OK</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Checking uboot 0x00200000 ... sha256(a14cd96f5d...) + OK</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Checking fdt 0x00349350 ... sha256(cf0060a3cf...) + OK</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Checking atf-2 0x000f0000 ... sha256(c00c7fd75b...) + OK</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Checking atf-3 0xff100000 ... sha256(71c3a5841b...) + OK</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Checking atf-4 0xff001000 ... sha256(2301cf73be...) + OK</span></span></span><br><span class="line">Jumping to U-Boot(0x00200000) via ARM Trusted Firmware(0x00040000)</span><br><span class="line">Total: 209.584 ms</span><br><span class="line"></span><br><span class="line">INFO:    Preloader serial: 2</span><br><span class="line">NOTICE:  BL31: v2.3():v2.3-405-gb52c2eadd:derrick.huang</span><br><span class="line">NOTICE:  BL31: Built : 11:23:47, Aug 15 2022</span><br><span class="line">INFO:    spec: 0x13</span><br><span class="line">INFO:    ext 32k is valid</span><br><span class="line">INFO:    GICv3 without legacy support detected.</span><br><span class="line">INFO:    ARM GICv3 driver initialized in EL3</span><br><span class="line">INFO:    system boots from cpu-hwid-0</span><br><span class="line">INFO:    idle_st=0x21fff, pd_st=0x11fff9, repair_st=0xfff70001</span><br><span class="line">INFO:    dfs DDR fsp_params[0].freq_mhz= 2112MHz</span><br><span class="line">INFO:    dfs DDR fsp_params[1].freq_mhz= 528MHz</span><br><span class="line">INFO:    dfs DDR fsp_params[2].freq_mhz= 1068MHz</span><br><span class="line">INFO:    dfs DDR fsp_params[3].freq_mhz= 1560MHz</span><br><span class="line">INFO:    BL31: Initialising Exception Handling Framework</span><br><span class="line">INFO:    BL31: Initializing runtime services</span><br><span class="line">WARNING: No OPTEE provided by BL2 boot loader, Booting device without OPTEE initialization. SMC`s destined for OPTEE will return SMC_UNK</span><br><span class="line">ERROR:   Error initializing runtime service opteed_fast</span><br><span class="line">INFO:    BL31: Preparing for EL3 exit to normal world</span><br><span class="line">INFO:    Entry point address = 0x200000</span><br><span class="line">INFO:    SPSR = 0x3c9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">U-Boot 2017.09-orangepi (Apr 21 2023 - 10:35:39 +0800)</span><br><span class="line"></span><br><span class="line">Model: Orange Pi 5B</span><br><span class="line">PreSerial: 2, raw, 0xfeb50000</span><br><span class="line">DRAM:  3.7 GiB</span><br><span class="line">Sysmem: init</span><br><span class="line">Relocation Offset: eda2d000</span><br><span class="line">Relocation fdt: eb9f9008 - eb9fecb8</span><br><span class="line">CR: M/C/I</span><br><span class="line">Using default environment</span><br><span class="line"></span><br><span class="line">mmc@fe2c0000: 0, mmc@fe2e0000: 1</span><br><span class="line">Bootdev(atags): mmc 0</span><br><span class="line">MMC0: Legacy, 52Mhz</span><br><span class="line">PartType: EFI</span><br><span class="line">DM: v2</span><br><span class="line">boot mode: None</span><br><span class="line">Model: Orange Pi 5B</span><br><span class="line">CLK: (sync kernel. arm: enter 1008000 KHz, init 1008000 KHz, kernel 0N/A)</span><br><span class="line">  b0pll 24000 KHz</span><br><span class="line">  b1pll 24000 KHz</span><br><span class="line">  lpll 24000 KHz</span><br><span class="line">  v0pll 24000 KHz</span><br><span class="line">  aupll 24000 KHz</span><br><span class="line">  cpll 1500000 KHz</span><br><span class="line">  gpll 1188000 KHz</span><br><span class="line">  npll 24000 KHz</span><br><span class="line">  ppll 1100000 KHz</span><br><span class="line">  aclk_center_root 702000 KHz</span><br><span class="line">  pclk_center_root 100000 KHz</span><br><span class="line">  hclk_center_root 396000 KHz</span><br><span class="line">  aclk_center_low_root 500000 KHz</span><br><span class="line">  aclk_top_root 750000 KHz</span><br><span class="line">  pclk_top_root 100000 KHz</span><br><span class="line">  aclk_low_top_root 396000 KHz</span><br><span class="line">Net:   No ethernet found.</span><br><span class="line">Hit key to stop autoboot(&#x27;CTRL+C&#x27;):  0</span><br><span class="line">switch to partitions #0, OK</span><br><span class="line">mmc0 is current device</span><br><span class="line">mmc@fe2c0000: 0 (SD)</span><br><span class="line">mmc@fe2e0000: 1</span><br><span class="line">switch to partitions #0, OK</span><br><span class="line">mmc0 is current device</span><br><span class="line">Scanning mmc 0:1...</span><br><span class="line">Found U-Boot script /boot.scr</span><br><span class="line">reading /boot.scr</span><br><span class="line">3411 bytes read in 4 ms (832 KiB/s)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Executing script at 00500000</span></span></span><br><span class="line">Boot script loaded from mmc 0</span><br><span class="line">reading /orangepiEnv.txt</span><br><span class="line">222 bytes read in 3 ms (72.3 KiB/s)</span><br><span class="line">reading /uInitrd</span><br><span class="line">18641659 bytes read in 1844 ms (9.6 MiB/s)</span><br><span class="line">reading /Image</span><br><span class="line">34736640 bytes read in 3049 ms (10.9 MiB/s)</span><br><span class="line">reading /dtb/rockchip/rk3588s-orangepi-5b.dtb</span><br><span class="line">233728 bytes read in 24 ms (9.3 MiB/s)</span><br><span class="line">reading /dtb/rockchip/overlay/rk3588-fixup.scr</span><br><span class="line">2756 bytes read in 6 ms (448.2 KiB/s)</span><br><span class="line">Applying kernel provided DT fixup script (rk3588-fixup.scr)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Executing script at 09000000</span></span></span><br><span class="line">Fdt Ramdisk skip relocation</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Loading init Ramdisk from Legacy Image at 0a200000 ...</span></span></span><br><span class="line">   Image Name:   uInitrd</span><br><span class="line">   Image Type:   AArch64 Linux RAMDisk Image (gzip compressed)</span><br><span class="line">   Data Size:    18641595 Bytes = 17.8 MiB</span><br><span class="line">   Load Address: 00000000</span><br><span class="line">   Entry Point:  00000000</span><br><span class="line">   Verifying Checksum ... OK</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Flattened Device Tree blob at 0x0a100000</span></span></span><br><span class="line">   Booting using the fdt blob at 0x0a100000</span><br><span class="line">   reserving fdt memory region: addr=a100000 size=9f000</span><br><span class="line">  &#x27;reserved-memory&#x27; ramoops@110000: addr=110000 size=f0000</span><br><span class="line">   Using Device Tree in place at 000000000a100000, end 000000000a1a1fff</span><br><span class="line">Adding bank: 0x00200000 - 0xf0000000 (size: 0xefe00000)</span><br><span class="line">Total: 5283.754 ms</span><br><span class="line"></span><br><span class="line">Starting kernel ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>瑞芯微脚本分析</category>
      </categories>
      <tags>
        <tag>瑞芯微脚本分析</tag>
      </tags>
  </entry>
  <entry>
    <title>0-5 Loader的编译</title>
    <url>/2023/09/10/0-5%20Loader%E7%9A%84%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>瑞芯微脚本分析</category>
      </categories>
      <tags>
        <tag>瑞芯微脚本分析</tag>
      </tags>
  </entry>
  <entry>
    <title>0-4 kernel的编译</title>
    <url>/2023/09/10/0-4%20kernel%E7%9A%84%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>瑞芯微脚本分析</category>
      </categories>
      <tags>
        <tag>瑞芯微脚本分析</tag>
      </tags>
  </entry>
  <entry>
    <title>0-3 uboot的编译</title>
    <url>/2023/09/10/0-3%20uboot%E7%9A%84%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-1-编译uboot-的全部命令"><a href="#3-1-编译uboot-的全部命令" class="headerlink" title="3.1 编译uboot 的全部命令"></a>3.1 编译uboot 的全部命令</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置环境变量 LC_ALL，用于定义程序的本地化设置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 LC_ALL 设置为 C，表示使用标准的C语言环境，忽略本地化设置</span></span><br><span class="line">export LC_ALL=C</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置环境变量 LD_LIBRARY_PATH，用于指定动态链接库的搜索路径</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 LD_LIBRARY_PATH 设置为空，表示清空动态链接库搜索路径</span></span><br><span class="line">export LD_LIBRARY_PATH=</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">错误处理函数</span></span><br><span class="line">err_handler()</span><br><span class="line">&#123;</span><br><span class="line">	ret=$?</span><br><span class="line">	[ &quot;$ret&quot; -eq 0 ] &amp;&amp; return</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">打印错误信息</span></span><br><span class="line">	echo &quot;ERROR: Running $&#123;FUNCNAME[1]&#125; failed!&quot;</span><br><span class="line">	echo &quot;ERROR: exit code $ret from line $&#123;BASH_LINENO[0]&#125;:&quot;</span><br><span class="line">	echo &quot;    $BASH_COMMAND&quot;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">退出脚本</span></span><br><span class="line">	exit $ret</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置错误处理函数为 <span class="built_in">trap</span> 的处理程序，当发生错误时调用 err_handler() 函数</span></span><br><span class="line">trap &#x27;err_handler&#x27; ERR</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 shell 的错误处理行为</span></span><br><span class="line">set -eE</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取当前脚本所在目录的绝对路径，并赋值给 COMMON_DIR 变量</span></span><br><span class="line">COMMON_DIR=&quot;$(dirname &quot;$(realpath &quot;$0&quot;)&quot;)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据 COMMON_DIR 计算出顶级目录的绝对路径，并赋值给 TOP_DIR 变量，这里多说一下，这里的build.sh是软链接，所以这里需要确认顶层目录</span></span><br><span class="line">TOP_DIR=&quot;$(realpath &quot;$COMMON_DIR/../../..&quot;)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到顶级目录</span></span><br><span class="line">cd &quot;$TOP_DIR&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 rockdev 目录（如果不存在）</span></span><br><span class="line">mkdir -p rockdev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 BOARD_CONFIG 变量为顶级目录下的 device/rockchip/.BoardConfig.mk 文件的绝对路径</span></span><br><span class="line">BOARD_CONFIG=&quot;$TOP_DIR/device/rockchip/.BoardConfig.mk&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取 CHIP_DIR 变量的绝对路径，该变量指向顶级目录下的 device/rockchip/.target_product 目录</span></span><br><span class="line">CHIP_DIR=&quot;$(realpath $TOP_DIR/device/rockchip/.target_product)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查配置函数</span></span><br><span class="line">check_config()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">清除变量 missing</span></span><br><span class="line">	unset missing</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">遍历传入的参数列表</span></span><br><span class="line"></span><br><span class="line">	for var in $@; do</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">使用 <span class="built_in">eval</span> 检查变量是否存在值，如果存在则跳过</span></span><br><span class="line">		eval [ \$$var ] &amp;&amp; continue</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">将缺失的配置变量记录到 missing 变量中</span></span><br><span class="line">		missing=&quot;$missing $var&quot;</span><br><span class="line">	done</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果所有配置变量均存在值，则返回0表示检查通过</span></span><br><span class="line">	[ -z &quot;$missing&quot; ] &amp;&amp; return 0</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果存在缺失的配置变量，则输出错误信息并返回1</span></span><br><span class="line">	echo &quot;Skipping $&#123;FUNCNAME[1]&#125; for missing configs: $missing.&quot;</span><br><span class="line">	return 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置交叉编译工具链和相关参数</span></span><br><span class="line">setup_cross_compile()</span><br><span class="line">&#123;</span><br><span class="line">	if [ &quot;$RK_CHIP&quot; = &quot;rv1126_rv1109&quot; ]; then</span><br><span class="line">		TOOLCHAIN_OS=rockchip</span><br><span class="line">	else</span><br><span class="line">		TOOLCHAIN_OS=none</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">将 RK_KERNEL_ARCH 中的 arm64 替换为 aarch64</span></span><br><span class="line">	TOOLCHAIN_ARCH=$&#123;RK_KERNEL_ARCH/arm64/aarch64&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">查找匹配的 GCC 工具链路径</span></span><br><span class="line">	TOOLCHAIN_DIR=&quot;$(realpath prebuilts/gcc/*/$TOOLCHAIN_ARCH/gcc-arm-*)&quot;</span><br><span class="line">	GCC=&quot;$(find &quot;$TOOLCHAIN_DIR&quot; -name &quot;*$TOOLCHAIN_OS*-gcc&quot;)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">检查是否存在可执行的 GCC 工具链</span></span><br><span class="line">	if [ ! -x &quot;$GCC&quot; ]; then</span><br><span class="line">		echo &quot;No prebuilt GCC toolchain!&quot;</span><br><span class="line">		return 1</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">设置交叉编译前缀</span></span><br><span class="line">	export CROSS_COMPILE=&quot;$&#123;GCC%gcc&#125;&quot;</span><br><span class="line">	echo &quot;Using prebuilt GCC toolchain: $CROSS_COMPILE&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">获取可用的处理器核心数量</span></span><br><span class="line">	NUM_CPUS=$(getconf _NPROCESSORS_ONLN 2&gt;/dev/null || echo 1)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">设置并发编译任务数，默认为处理器核心数量加一</span></span><br><span class="line">	JLEVEL=$&#123;RK_JOBS:-$(( $NUM_CPUS + 1 ))&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">定义内核编译命令</span></span><br><span class="line">	KMAKE=&quot;make -C kernel/ ARCH=$RK_KERNEL_ARCH -j$JLEVEL&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">预构建 U-Boot 函数</span></span><br><span class="line">prebuild_uboot()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">构建 U-Boot 的编译命令字符串</span></span><br><span class="line">	UBOOT_COMPILE_COMMANDS=&quot;\</span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash">&#123;RK_TRUST_INI_CONFIG:+../rkbin/RKTRUST/<span class="variable">$RK_TRUST_INI_CONFIG</span>&#125; \</span></span><br><span class="line"><span class="language-bash">			<span class="variable">$&#123;RK_SPL_INI_CONFIG:+../rkbin/RKBOOT/$RK_SPL_INI_CONFIG&#125;</span> \</span></span><br><span class="line"><span class="language-bash">			<span class="variable">$&#123;RK_UBOOT_SIZE_CONFIG:+--sz-uboot $RK_UBOOT_SIZE_CONFIG&#125;</span> \</span></span><br><span class="line"><span class="language-bash">			<span class="variable">$&#123;RK_TRUST_SIZE_CONFIG:+--sz-trust $RK_TRUST_SIZE_CONFIG&#125;</span><span class="string">&quot;</span></span></span><br><span class="line">	UBOOT_COMPILE_COMMANDS=&quot;$(echo $UBOOT_COMPILE_COMMANDS)&quot;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"><span class="string">如果启用 RAMDISK 安全启动，则添加相关的编译命令选项</span></span></span><br><span class="line">	if [ &quot;$RK_RAMDISK_SECURITY_BOOTUP&quot; = &quot;true&quot; ];then</span><br><span class="line">		UBOOT_COMPILE_COMMANDS=&quot; \</span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash"><span class="string">UBOOT_COMPILE_COMMANDS \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">			<span class="variable">$&#123;RK_ROLLBACK_INDEX_BOOT:+--rollback-index-boot $RK_ROLLBACK_INDEX_BOOT&#125;</span> \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">			<span class="variable">$&#123;RK_ROLLBACK_INDEX_UBOOT:+--rollback-index-uboot $RK_ROLLBACK_INDEX_UBOOT&#125;</span> &quot;</span></span></span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">预构建安全启动的 U-Boot 函数</span></span><br><span class="line">prebuild_security_uboot()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">获取传入的模式参数</span></span><br><span class="line">	local mode=$1</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果启用 RAMDISK 安全启动，则添加相关的编译命令选项</span></span><br><span class="line">	if [ &quot;$RK_RAMDISK_SECURITY_BOOTUP&quot; = &quot;true&quot; ];then</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">如果 RK_SECURITY_OTP_DEBUG 不等于 <span class="string">&quot;true&quot;</span>，则添加 --burn-key-hash 选项</span></span><br><span class="line">		if [ &quot;$RK_SECURITY_OTP_DEBUG&quot; != &quot;true&quot; ]; then</span><br><span class="line">			UBOOT_COMPILE_COMMANDS=&quot;$UBOOT_COMPILE_COMMANDS --burn-key-hash&quot;</span><br><span class="line">		fi</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">根据传入的模式参数进行不同的处理</span></span><br><span class="line">		case &quot;$&#123;mode:-normal&#125;&quot; in</span><br><span class="line"><span class="meta prompt_">			# </span><span class="language-bash">对于 uboot 模式，不需要额外的处理</span></span><br><span class="line">			uboot)</span><br><span class="line">				;;</span><br><span class="line"><span class="meta prompt_">			# </span><span class="language-bash">对于 boot 模式，添加 --boot_img 选项，并设置值为 <span class="variable">$TOP_DIR</span>/u-boot/boot.img</span></span><br><span class="line">			boot)</span><br><span class="line">				UBOOT_COMPILE_COMMANDS=&quot; \</span><br><span class="line">					--boot_img $TOP_DIR/u-boot/boot.img \</span><br><span class="line">					$UBOOT_COMPILE_COMMANDS &quot;</span><br><span class="line">				;;</span><br><span class="line"><span class="meta prompt_">			# </span><span class="language-bash">对于 recovery 模式，添加 --recovery_img 选项，并设置值为 <span class="variable">$TOP_DIR</span>/u-boot/recovery.img</span></span><br><span class="line">			recovery)</span><br><span class="line">				UBOOT_COMPILE_COMMANDS=&quot; \</span><br><span class="line">					--recovery_img $TOP_DIR/u-boot/recovery.img</span><br><span class="line">					$UBOOT_COMPILE_COMMANDS &quot;</span><br><span class="line">				;;</span><br><span class="line">			*)</span><br><span class="line"><span class="meta prompt_">			# </span><span class="language-bash">对于其他模式，默认添加 --boot_img 选项，并设置值为 <span class="variable">$TOP_DIR</span>/u-boot/boot.img</span></span><br><span class="line">				UBOOT_COMPILE_COMMANDS=&quot; \</span><br><span class="line">					--boot_img $TOP_DIR/u-boot/boot.img \</span><br><span class="line">					$UBOOT_COMPILE_COMMANDS &quot;</span><br><span class="line">				# 如果 RK_PACKAGE_FILE_AB 为空，则添加 --recovery_img 选项，并设置值为 $TOP_DIR/u-boot/recovery.img</span><br><span class="line">				test -z &quot;$&#123;RK_PACKAGE_FILE_AB&#125;&quot; &amp;&amp; \</span><br><span class="line">					UBOOT_COMPILE_COMMANDS=&quot;$UBOOT_COMPILE_COMMANDS --recovery_img $TOP_DIR/u-boot/recovery.img&quot;</span><br><span class="line">				;;</span><br><span class="line">		esac</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">使用 <span class="built_in">echo</span> 命令重新赋值 UBOOT_COMPILE_COMMANDS 变量，去除多余空格</span></span><br><span class="line">		UBOOT_COMPILE_COMMANDS=&quot;$(echo $UBOOT_COMPILE_COMMANDS)&quot;</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建 U-Boot</span></span><br><span class="line">build_uboot()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">检查 RK_UBOOT_DEFCONFIG 配置是否存在，若不存在则返回</span></span><br><span class="line">	check_config RK_UBOOT_DEFCONFIG || return 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">设置交叉编译工具链和相关参数</span></span><br><span class="line">	setup_cross_compile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">准备 U-Boot 构建所需的文件</span></span><br><span class="line">	prebuild_uboot</span><br><span class="line">	prebuild_security_uboot $@</span><br><span class="line"></span><br><span class="line">	echo &quot;============Start building uboot============&quot;</span><br><span class="line">	echo &quot;TARGET_UBOOT_CONFIG=$RK_UBOOT_DEFCONFIG&quot;</span><br><span class="line">	echo &quot;=========================================&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">进入 u-boot 目录并删除旧的 *_loader_*.bin 文件</span></span><br><span class="line">	cd u-boot</span><br><span class="line">	rm -f *_loader_*.bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">构建 U-Boot</span></span><br><span class="line">	if [ -n &quot;$RK_UBOOT_DEFCONFIG_FRAGMENT&quot; ]; then</span><br><span class="line">		if [ -f &quot;configs/$&#123;RK_UBOOT_DEFCONFIG&#125;_defconfig&quot; ]; then</span><br><span class="line">			UBOOT_CONFIGS=&quot;$&#123;RK_UBOOT_DEFCONFIG&#125;_defconfig&quot;</span><br><span class="line">		else</span><br><span class="line">			UBOOT_CONFIGS=&quot;$&#123;RK_UBOOT_DEFCONFIG&#125;.config&quot;</span><br><span class="line">		fi</span><br><span class="line">		UBOOT_CONFIGS=&quot;$UBOOT_CONFIGS $RK_UBOOT_DEFCONFIG_FRAGMENT&quot;</span><br><span class="line">	else</span><br><span class="line">		UBOOT_CONFIGS=&quot;$RK_UBOOT_DEFCONFIG&quot;</span><br><span class="line">	fi</span><br><span class="line">	./make.sh $UBOOT_CONFIGS $UBOOT_COMPILE_COMMANDS \</span><br><span class="line">		CROSS_COMPILE=$CROSS_COMPILE</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果需要更新 RK_IDBLOCK_SPL，则执行带有 --idblock 和 --spl 参数的 make.sh</span></span><br><span class="line">	if [ &quot;$RK_IDBLOCK_UPDATE_SPL&quot; = &quot;true&quot; ]; then</span><br><span class="line">		./make.sh --idblock --spl</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	cd ..</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果需要进行 RAMDISK 安全启动，则创建链接到 rockdev 目录的 boot.img 和 recovery.img</span></span><br><span class="line">	if [ &quot;$RK_RAMDISK_SECURITY_BOOTUP&quot; = &quot;true&quot; ];then</span><br><span class="line">		ln -rsf u-boot/boot.img rockdev/</span><br><span class="line">		test -z &quot;$&#123;RK_PACKAGE_FILE_AB&#125;&quot; &amp;&amp; \</span><br><span class="line">			ln -rsf u-boot/recovery.img rockdev/ || true</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">创建链接到 rockdev 目录的 MiniLoaderAll.bin、uboot.img 和 trust.img（如果存在）</span></span><br><span class="line">	LOADER=&quot;$(echo u-boot/*_loader_*v*.bin | head -1)&quot;</span><br><span class="line">	SPL=&quot;$(echo u-boot/*_loader_spl.bin | head -1)&quot;</span><br><span class="line">	ln -rsf &quot;$&#123;LOADER:-$SPL&#125;&quot; rockdev/MiniLoaderAll.bin</span><br><span class="line">	ln -rsf u-boot/uboot.img rockdev/</span><br><span class="line">	[ ! -e u-boot/trust.img ] || \</span><br><span class="line">		ln -rsf u-boot/trust.img rockdev/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">完成构建流程</span></span><br><span class="line">	finish_build</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-2-配置文件检查（第一步）"><a href="#3-2-配置文件检查（第一步）" class="headerlink" title="3.2 配置文件检查（第一步）"></a>3.2 配置文件检查（第一步）</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查 RK_UBOOT_DEFCONFIG 配置是否存在，若不存在则返回</span></span><br><span class="line">check_config RK_UBOOT_DEFCONFIG || return 0</span><br></pre></td></tr></table></figure>

<p>RK_UBOOT_DEFCONFIG 环境变量在板子选择的配置文件中已经确定了，具体内容如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export RK_UBOOT_DEFCONFIG=rk3588</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Uboot镜像格式类型：fit（扁平化镜像树）</span></span><br><span class="line"></span><br><span class="line">export RK_UBOOT_FORMAT_TYPE=fit</span><br></pre></td></tr></table></figure>



<p>check_config函数内容如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查配置函数</span></span><br><span class="line">check_config()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">清除变量 missing</span></span><br><span class="line">	unset missing</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">遍历传入的参数列表</span></span><br><span class="line"></span><br><span class="line">	for var in $@; do</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">使用 <span class="built_in">eval</span> 检查变量是否存在值，如果存在则跳过</span></span><br><span class="line">		eval [ \$$var ] &amp;&amp; continue</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">将缺失的配置变量记录到 missing 变量中</span></span><br><span class="line">		missing=&quot;$missing $var&quot;</span><br><span class="line">	done</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果所有配置变量均存在值，则返回0表示检查通过</span></span><br><span class="line">	[ -z &quot;$missing&quot; ] &amp;&amp; return 0</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果存在缺失的配置变量，则输出错误信息并返回1</span></span><br><span class="line">	echo &quot;Skipping $&#123;FUNCNAME[1]&#125; for missing configs: $missing.&quot;</span><br><span class="line">	return 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个检查只是检查配置是否全部填充，没有什么特别的，还是很简单的。</p>
<h1 id="3-3-设置交叉编译工具链和相关参数（第二步）"><a href="#3-3-设置交叉编译工具链和相关参数（第二步）" class="headerlink" title="3.3 设置交叉编译工具链和相关参数（第二步）"></a>3.3 设置交叉编译工具链和相关参数（第二步）</h1><p>设置交叉编译工具链的函数内容如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置交叉编译工具链和相关参数</span></span><br><span class="line">setup_cross_compile()</span><br><span class="line">&#123;</span><br><span class="line">	if [ &quot;$RK_CHIP&quot; = &quot;rv1126_rv1109&quot; ]; then</span><br><span class="line">		TOOLCHAIN_OS=rockchip</span><br><span class="line">	else</span><br><span class="line">		TOOLCHAIN_OS=none</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">将 RK_KERNEL_ARCH 中的 arm64 替换为 aarch64</span></span><br><span class="line">	TOOLCHAIN_ARCH=$&#123;RK_KERNEL_ARCH/arm64/aarch64&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">查找匹配的 GCC 工具链路径</span></span><br><span class="line">	</span><br><span class="line">	TOOLCHAIN_DIR=&quot;$(realpath prebuilts/gcc/*/$TOOLCHAIN_ARCH/gcc-arm-*)&quot;</span><br><span class="line">	GCC=&quot;$(find &quot;$TOOLCHAIN_DIR&quot; -name &quot;*$TOOLCHAIN_OS*-gcc&quot;)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">检查是否存在可执行的 GCC 工具链</span></span><br><span class="line">	if [ ! -x &quot;$GCC&quot; ]; then</span><br><span class="line">		echo &quot;No prebuilt GCC toolchain!&quot;</span><br><span class="line">		return 1</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">设置交叉编译前缀</span></span><br><span class="line">	export CROSS_COMPILE=&quot;$&#123;GCC%gcc&#125;&quot;</span><br><span class="line">	echo &quot;Using prebuilt GCC toolchain: $CROSS_COMPILE&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">获取可用的处理器核心数量</span></span><br><span class="line">	NUM_CPUS=$(getconf _NPROCESSORS_ONLN 2&gt;/dev/null || echo 1)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">设置并发编译任务数，默认为处理器核心数量加一</span></span><br><span class="line">	JLEVEL=$&#123;RK_JOBS:-$(( $NUM_CPUS + 1 ))&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">定义内核编译命令</span></span><br><span class="line">	KMAKE=&quot;make -C kernel/ ARCH=$RK_KERNEL_ARCH -j$JLEVEL&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>​	设置交叉编译器</li>
<li>​	设置编译时的线程数</li>
<li>​	定义内核编译命令KMAKE</li>
</ul>
<p>设置交叉编译器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export ARCH=arm64</span><br><span class="line"></span><br><span class="line">export CROSS_COMPILE=/home/topeet/Linux/3588-linux/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-</span><br></pre></td></tr></table></figure>



<h1 id="3-4-uboot编译前预处理（第三步）"><a href="#3-4-uboot编译前预处理（第三步）" class="headerlink" title="3.4 uboot编译前预处理（第三步）"></a>3.4 uboot编译前预处理（第三步）</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">prebuild_uboot</span><br><span class="line">prebuild_security_uboot $@</span><br></pre></td></tr></table></figure>

<p>首先是prebuild_uboot寒素具体内容如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">预构建 U-Boot 函数</span></span><br><span class="line">prebuild_uboot()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">构建 U-Boot 的编译命令字符串</span></span><br><span class="line">	UBOOT_COMPILE_COMMANDS=&quot;\</span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash">&#123;RK_TRUST_INI_CONFIG:+../rkbin/RKTRUST/<span class="variable">$RK_TRUST_INI_CONFIG</span>&#125; \</span></span><br><span class="line"><span class="language-bash">			<span class="variable">$&#123;RK_SPL_INI_CONFIG:+../rkbin/RKBOOT/$RK_SPL_INI_CONFIG&#125;</span> \</span></span><br><span class="line"><span class="language-bash">			<span class="variable">$&#123;RK_UBOOT_SIZE_CONFIG:+--sz-uboot $RK_UBOOT_SIZE_CONFIG&#125;</span> \</span></span><br><span class="line"><span class="language-bash">			<span class="variable">$&#123;RK_TRUST_SIZE_CONFIG:+--sz-trust $RK_TRUST_SIZE_CONFIG&#125;</span><span class="string">&quot;</span></span></span><br><span class="line">	UBOOT_COMPILE_COMMANDS=&quot;$(echo $UBOOT_COMPILE_COMMANDS)&quot;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"><span class="string">如果启用 RAMDISK 安全启动，则添加相关的编译命令选项</span></span></span><br><span class="line">	if [ &quot;$RK_RAMDISK_SECURITY_BOOTUP&quot; = &quot;true&quot; ];then</span><br><span class="line">		UBOOT_COMPILE_COMMANDS=&quot; \</span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash"><span class="string">UBOOT_COMPILE_COMMANDS \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">			<span class="variable">$&#123;RK_ROLLBACK_INDEX_BOOT:+--rollback-index-boot $RK_ROLLBACK_INDEX_BOOT&#125;</span> \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">			<span class="variable">$&#123;RK_ROLLBACK_INDEX_UBOOT:+--rollback-index-uboot $RK_ROLLBACK_INDEX_UBOOT&#125;</span> &quot;</span></span></span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	虽然确实进去了这个函数，但实际上是没有进行任何步骤的，因为根本就没有上述任何环境变量的设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">预构建安全启动的 U-Boot 函数</span></span><br><span class="line">prebuild_security_uboot()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">获取传入的模式参数</span></span><br><span class="line">	local mode=$1</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果启用 RAMDISK 安全启动，则添加相关的编译命令选项</span></span><br><span class="line">	if [ &quot;$RK_RAMDISK_SECURITY_BOOTUP&quot; = &quot;true&quot; ];then</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">如果 RK_SECURITY_OTP_DEBUG 不等于 <span class="string">&quot;true&quot;</span>，则添加 --burn-key-hash 选项</span></span><br><span class="line">		if [ &quot;$RK_SECURITY_OTP_DEBUG&quot; != &quot;true&quot; ]; then</span><br><span class="line">			UBOOT_COMPILE_COMMANDS=&quot;$UBOOT_COMPILE_COMMANDS --burn-key-hash&quot;</span><br><span class="line">		fi</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">根据传入的模式参数进行不同的处理</span></span><br><span class="line">		case &quot;$&#123;mode:-normal&#125;&quot; in</span><br><span class="line"><span class="meta prompt_">			# </span><span class="language-bash">对于 uboot 模式，不需要额外的处理</span></span><br><span class="line">			uboot)</span><br><span class="line">				;;</span><br><span class="line"><span class="meta prompt_">			# </span><span class="language-bash">对于 boot 模式，添加 --boot_img 选项，并设置值为 <span class="variable">$TOP_DIR</span>/u-boot/boot.img</span></span><br><span class="line">			boot)</span><br><span class="line">				UBOOT_COMPILE_COMMANDS=&quot; \</span><br><span class="line">					--boot_img $TOP_DIR/u-boot/boot.img \</span><br><span class="line">					$UBOOT_COMPILE_COMMANDS &quot;</span><br><span class="line">				;;</span><br><span class="line"><span class="meta prompt_">			# </span><span class="language-bash">对于 recovery 模式，添加 --recovery_img 选项，并设置值为 <span class="variable">$TOP_DIR</span>/u-boot/recovery.img</span></span><br><span class="line">			recovery)</span><br><span class="line">				UBOOT_COMPILE_COMMANDS=&quot; \</span><br><span class="line">					--recovery_img $TOP_DIR/u-boot/recovery.img</span><br><span class="line">					$UBOOT_COMPILE_COMMANDS &quot;</span><br><span class="line">				;;</span><br><span class="line">			*)</span><br><span class="line"><span class="meta prompt_">			# </span><span class="language-bash">对于其他模式，默认添加 --boot_img 选项，并设置值为 <span class="variable">$TOP_DIR</span>/u-boot/boot.img</span></span><br><span class="line">				UBOOT_COMPILE_COMMANDS=&quot; \</span><br><span class="line">					--boot_img $TOP_DIR/u-boot/boot.img \</span><br><span class="line">					$UBOOT_COMPILE_COMMANDS &quot;</span><br><span class="line">				# 如果 RK_PACKAGE_FILE_AB 为空，则添加 --recovery_img 选项，并设置值为 $TOP_DIR/u-boot/recovery.img</span><br><span class="line">				test -z &quot;$&#123;RK_PACKAGE_FILE_AB&#125;&quot; &amp;&amp; \</span><br><span class="line">					UBOOT_COMPILE_COMMANDS=&quot;$UBOOT_COMPILE_COMMANDS --recovery_img $TOP_DIR/u-boot/recovery.img&quot;</span><br><span class="line">				;;</span><br><span class="line">		esac</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">使用 <span class="built_in">echo</span> 命令重新赋值 UBOOT_COMPILE_COMMANDS 变量，去除多余空格</span></span><br><span class="line">		UBOOT_COMPILE_COMMANDS=&quot;$(echo $UBOOT_COMPILE_COMMANDS)&quot;</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-5-删除之前的编译（第4步）"><a href="#3-5-删除之前的编译（第4步）" class="headerlink" title="3.5 删除之前的编译（第4步）"></a>3.5 删除之前的编译（第4步）</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入 u-boot 目录并删除旧的 *_loader_*.bin 文件</span></span><br><span class="line">cd u-boot</span><br><span class="line">rm -f *_loader_*.bin</span><br></pre></td></tr></table></figure>

<p>这也就是之前为什么每次都要重新编译的原因</p>
<h1 id="3-5-删除之前的编译（第4步）-1"><a href="#3-5-删除之前的编译（第4步）-1" class="headerlink" title="3.5 删除之前的编译（第4步）"></a>3.5 删除之前的编译（第4步）</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建 U-Boot</span></span><br><span class="line">if [ -n &quot;$RK_UBOOT_DEFCONFIG_FRAGMENT&quot; ]; then</span><br><span class="line">	if [ -f &quot;configs/$&#123;RK_UBOOT_DEFCONFIG&#125;_defconfig&quot; ]; then</span><br><span class="line">		UBOOT_CONFIGS=&quot;$&#123;RK_UBOOT_DEFCONFIG&#125;_defconfig&quot;</span><br><span class="line">	else</span><br><span class="line">		UBOOT_CONFIGS=&quot;$&#123;RK_UBOOT_DEFCONFIG&#125;.config&quot;</span><br><span class="line">	fi</span><br><span class="line">	UBOOT_CONFIGS=&quot;$UBOOT_CONFIGS $RK_UBOOT_DEFCONFIG_FRAGMENT&quot;</span><br><span class="line">else</span><br><span class="line">	UBOOT_CONFIGS=&quot;$RK_UBOOT_DEFCONFIG&quot;</span><br><span class="line">fi</span><br><span class="line">./make.sh $UBOOT_CONFIGS $UBOOT_COMPILE_COMMANDS \</span><br><span class="line">	CROSS_COMPILE=$CROSS_COMPILE</span><br></pre></td></tr></table></figure>

<p>​	上面的第一个if是不成立的，因为并没有RK_UBOOT_DEFCONFIG_FRAGMENT宏定义，所以会进入第二个else判断，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">UBOOT_CONFIGS=&quot;$RK_UBOOT_DEFCONFIG&quot;</span><br><span class="line">./make.sh $UBOOT_CONFIGS $UBOOT_COMPILE_COMMANDS \</span><br><span class="line">	CROSS_COMPILE=$CROSS_COMPILE</span><br></pre></td></tr></table></figure>

<p>最终也就是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./make.sh rk3588 CROSS_COMPILE=/home/topeet/Linux/3588-linux/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-</span><br></pre></td></tr></table></figure>

<p>这里面多出来了一个make.sh脚本，所以这里先去分析一下make.sh脚本</p>
]]></content>
      <categories>
        <category>瑞芯微脚本分析</category>
      </categories>
      <tags>
        <tag>瑞芯微脚本分析</tag>
      </tags>
  </entry>
  <entry>
    <title>0-2 板子的选择</title>
    <url>/2023/09/10/0-2%20%E6%9D%BF%E5%AD%90%E7%9A%84%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="2-1-board选择"><a href="#2-1-board选择" class="headerlink" title="2.1 board选择"></a>2.1 board选择</h1><p>但其实上是默认情况下这里的配置文件已经搞好了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选择板卡函数</span></span><br><span class="line">choose_board()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">获取板卡配置文件列表到 BOARD_ARRAY 数组</span></span><br><span class="line">	BOARD_ARRAY=( $(cd $&#123;CHIP_DIR&#125;/; ls BoardConfig*.mk | sort) )</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">获取板卡数组的长度</span>	</span><br><span class="line">	RK_TARGET_BOARD_ARRAY_LEN=$&#123;#BOARD_ARRAY[@]&#125;</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果板卡数组长度为0，则表示没有可用的板卡配置文件，输出错误信息并返回-1</span></span><br><span class="line">	if [ $RK_TARGET_BOARD_ARRAY_LEN -eq 0 ]; then</span><br><span class="line">		echo &quot;No available Board Config&quot;</span><br><span class="line">		return -1</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	echo</span><br><span class="line">	echo &quot;You&#x27;re building on Linux&quot;</span><br><span class="line">	echo &quot;Lunch menu...pick a combo:&quot;</span><br><span class="line">	echo &quot;&quot;</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">输出可用的板卡配置文件列表</span></span><br><span class="line">	echo &quot;0. default BoardConfig.mk&quot;</span><br><span class="line">	echo $&#123;BOARD_ARRAY[@]&#125; | xargs -n 1 | sed &quot;=&quot; | sed &quot;N;s/\n/. /&quot;</span><br><span class="line"></span><br><span class="line">	local INDEX</span><br><span class="line">	read -p &quot;Which would you like? [0]: &quot; INDEX</span><br><span class="line">	INDEX=$(($&#123;INDEX:-0&#125; - 1))</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">根据用户选择的索引确定所选的板卡配置文件</span></span><br><span class="line">	if echo $INDEX | grep -vq [^0-9]; then</span><br><span class="line">		BOARD=&quot;$&#123;BOARD_ARRAY[$INDEX]&#125;&quot;</span><br><span class="line">	else</span><br><span class="line">		echo &quot;Lunching for Default BoardConfig.mk boards...&quot;</span><br><span class="line">		BOARD=BoardConfig.mk</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">创建符号链接，将所选的板卡配置文件链接到 BOARD_CONFIG 变量指定的路径</span></span><br><span class="line">	ln -rsf &quot;$CHIP_DIR/$BOARD&quot; &quot;$BOARD_CONFIG&quot;</span><br><span class="line">	echo &quot;switching to board: $(realpath $BOARD_CONFIG)&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">预处理选项</span></span><br><span class="line">unset POST_OPTIONS</span><br><span class="line">for option in $OPTIONS; do</span><br><span class="line">    case $option in</span><br><span class="line">        BoardConfig*.mk)</span><br><span class="line">            option=&quot;$CHIP_DIR/$option&quot;</span><br><span class="line">            ;&amp;</span><br><span class="line">        *.mk)</span><br><span class="line">            CONF=$(realpath $option)</span><br><span class="line">            echo &quot;切换到配置文件: $CONF&quot;</span><br><span class="line">            if [ ! -f $CONF ]; then</span><br><span class="line">                echo &quot;文件不存在!&quot;</span><br><span class="line">                exit 1</span><br><span class="line">            fi</span><br><span class="line"></span><br><span class="line">            ln -rsf $CONF $BOARD_CONFIG</span><br><span class="line">            ;;</span><br><span class="line">        lunch) choose_board ;;</span><br><span class="line">        kernel-4.4|kernel-4.19|kernel-5.10)</span><br><span class="line">            RK_KERNEL_VERSION=$&#123;option#kernel-&#125;</span><br><span class="line">            ;;</span><br><span class="line">        *) POST_OPTIONS=&quot;$POST_OPTIONS $option&quot;;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>总共分为了两次options的遍历，如果是options里面有mk相关的就会进入choose_board，choose_board里面的命令其实也就是一个软连接，倒是挺简单的。</p>
<p>而下面的这两句命令是一定会执行的，下面的$TOP_DIR&#x2F;device&#x2F;rockchip&#x2F;.BoardConfig.mk，在choose_board确定了，但是CHIP_DIR不知道啥时候确定的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 BOARD_CONFIG 变量为顶级目录下的 device/rockchip/.BoardConfig.mk 文件的绝对路径</span></span><br><span class="line">BOARD_CONFIG=&quot;$TOP_DIR/device/rockchip/.BoardConfig.mk&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取 CHIP_DIR 变量的绝对路径，该变量指向顶级目录下的 device/rockchip/.target_product 目录</span></span><br><span class="line">CHIP_DIR=&quot;$(realpath $TOP_DIR/device/rockchip/.target_product)&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309102123667.png" alt="image-20230910212319606"></p>
<h1 id="2-2-BoardConfig-mk文件介绍"><a href="#2-2-BoardConfig-mk文件介绍" class="headerlink" title="2.2 .BoardConfig.mk文件介绍"></a>2.2 .BoardConfig.mk文件介绍</h1><p>具体内容如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">目标架构</span></span><br><span class="line">export RK_KERNEL_ARCH=arm64</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Uboot的配置</span></span><br><span class="line">export RK_UBOOT_DEFCONFIG=rk3588</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Uboot镜像格式类型：fit（扁平化镜像树）</span></span><br><span class="line">export RK_UBOOT_FORMAT_TYPE=fit</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内核的配置</span></span><br><span class="line">export RK_KERNEL_DEFCONFIG=rockchip_linux_defconfig</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内核的配置片段</span></span><br><span class="line">export RK_KERNEL_DEFCONFIG_FRAGMENT=rk3588_linux.config</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内核设备树</span></span><br><span class="line">export RK_KERNEL_DTS=rk3588-evb7-lp4-v10-linux</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">boot镜像类型</span></span><br><span class="line">export RK_BOOT_IMG=boot.img</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内核镜像路径</span></span><br><span class="line">export RK_KERNEL_IMG=kernel/arch/arm64/boot/Image</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内核镜像格式类型：fit（扁平化镜像树）</span></span><br><span class="line">export RK_KERNEL_FIT_ITS=boot.its</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">GPT表的参数</span></span><br><span class="line">export RK_PARAMETER=parameter.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Buildroot的配置</span></span><br><span class="line">export RK_CFG_BUILDROOT=rockchip_rk3588</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Recovery的配置</span></span><br><span class="line">export RK_CFG_RECOVERY=rockchip_rk3588_recovery</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Recovery镜像格式类型：fit（扁平化镜像树）</span></span><br><span class="line">export RK_RECOVERY_FIT_ITS=boot4recovery.its</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Pcba的配置</span></span><br><span class="line">export RK_CFG_PCBA=rockchip_rk3588_pcba</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">目标芯片</span></span><br><span class="line">export RK_CHIP=rk3588</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置根文件系统的类型，包括ext2、ext4和squashfs</span></span><br><span class="line">export RK_ROOTFS_TYPE=ext4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Debian版本（debian10: buster，debian11: bullseye）</span></span><br><span class="line">export RK_DEBIAN_VERSION=bullseye</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Yocto的机器</span></span><br><span class="line">export RK_YOCTO_MACHINE=rockchip-rk3588-evb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">misc镜像</span></span><br><span class="line">export RK_MISC=wipe_all-misc.img</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义软件包文件</span></span><br><span class="line">export RK_PACKAGE_FILE=rk3588-package-file</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义WiFi和蓝牙芯片</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">兼容Realtek和AP6XXX WiFi：RK_WIFIBT_CHIP=ALL_AP</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">兼容Realtek和CYWXXX WiFi：RK_WIFIBT_CHIP=ALL_CY</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单一WiFi配置：AP6256或CYW43455：RK_WIFIBT_CHIP=AP6256</span></span><br><span class="line">export RK_WIFIBT_CHIP=ALL_AP</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义BT串口</span></span><br><span class="line">export RK_WIFIBT_TTY=ttyS8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;dev&gt;:&lt;mount point&gt;:&lt;fs <span class="built_in">type</span>&gt;:&lt;mount flags&gt;:&lt;<span class="built_in">source</span> <span class="built_in">dir</span>&gt;:&lt;image size(M|K|auto)&gt;:[options]</span></span><br><span class="line">export RK_EXTRA_PARTITIONS=&quot;oem:/oem:ext2:defaults:oem_normal:auto:resize@userdata:/userdata:ext2:defaults:userdata_normal:auto:resize&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>瑞芯微脚本分析</category>
      </categories>
      <tags>
        <tag>瑞芯微脚本分析</tag>
      </tags>
  </entry>
  <entry>
    <title>0-1 瑞芯微build-sh脚本分析</title>
    <url>/2023/09/10/0-1%20%E7%91%9E%E8%8A%AF%E5%BE%AEbuild-sh%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>build.sh脚本内容如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置环境变量 LC_ALL，用于定义程序的本地化设置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 LC_ALL 设置为 C，表示使用标准的C语言环境，忽略本地化设置</span></span><br><span class="line">export LC_ALL=C</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置环境变量 LD_LIBRARY_PATH，用于指定动态链接库的搜索路径</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 LD_LIBRARY_PATH 设置为空，表示清空动态链接库搜索路径</span></span><br><span class="line">export LD_LIBRARY_PATH=</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">错误处理函数</span></span><br><span class="line">err_handler()</span><br><span class="line">&#123;</span><br><span class="line">	ret=$?</span><br><span class="line">	[ &quot;$ret&quot; -eq 0 ] &amp;&amp; return</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">打印错误信息</span></span><br><span class="line">	echo &quot;ERROR: Running $&#123;FUNCNAME[1]&#125; failed!&quot;</span><br><span class="line">	echo &quot;ERROR: exit code $ret from line $&#123;BASH_LINENO[0]&#125;:&quot;</span><br><span class="line">	echo &quot;    $BASH_COMMAND&quot;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">退出脚本</span></span><br><span class="line">	exit $ret</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置错误处理函数为 <span class="built_in">trap</span> 的处理程序，当发生错误时调用 err_handler() 函数</span></span><br><span class="line">trap &#x27;err_handler&#x27; ERR</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 shell 的错误处理行为</span></span><br><span class="line">set -eE</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">完成构建操作</span></span><br><span class="line">finish_build()</span><br><span class="line">&#123;</span><br><span class="line">	echo &quot;Running $&#123;FUNCNAME[1]&#125; succeeded.&quot;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">切换到顶级目录</span></span><br><span class="line">	cd $TOP_DIR</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查配置函数</span></span><br><span class="line">check_config()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">清除变量 missing</span></span><br><span class="line">	unset missing</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">遍历传入的参数列表</span></span><br><span class="line"></span><br><span class="line">	for var in $@; do</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">使用 <span class="built_in">eval</span> 检查变量是否存在值，如果存在则跳过</span></span><br><span class="line">		eval [ \$$var ] &amp;&amp; continue</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">将缺失的配置变量记录到 missing 变量中</span></span><br><span class="line">		missing=&quot;$missing $var&quot;</span><br><span class="line">	done</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果所有配置变量均存在值，则返回0表示检查通过</span></span><br><span class="line">	[ -z &quot;$missing&quot; ] &amp;&amp; return 0</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果存在缺失的配置变量，则输出错误信息并返回1</span></span><br><span class="line">	echo &quot;Skipping $&#123;FUNCNAME[1]&#125; for missing configs: $missing.&quot;</span><br><span class="line">	return 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选择板卡函数</span></span><br><span class="line">choose_board()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">获取板卡配置文件列表到 BOARD_ARRAY 数组</span></span><br><span class="line">	BOARD_ARRAY=( $(cd $&#123;CHIP_DIR&#125;/; ls BoardConfig*.mk | sort) )</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">获取板卡数组的长度</span>	</span><br><span class="line">	RK_TARGET_BOARD_ARRAY_LEN=$&#123;#BOARD_ARRAY[@]&#125;</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果板卡数组长度为0，则表示没有可用的板卡配置文件，输出错误信息并返回-1</span></span><br><span class="line">	if [ $RK_TARGET_BOARD_ARRAY_LEN -eq 0 ]; then</span><br><span class="line">		echo &quot;No available Board Config&quot;</span><br><span class="line">		return -1</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	echo</span><br><span class="line">	echo &quot;You&#x27;re building on Linux&quot;</span><br><span class="line">	echo &quot;Lunch menu...pick a combo:&quot;</span><br><span class="line">	echo &quot;&quot;</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">输出可用的板卡配置文件列表</span></span><br><span class="line">	echo &quot;0. default BoardConfig.mk&quot;</span><br><span class="line">	echo $&#123;BOARD_ARRAY[@]&#125; | xargs -n 1 | sed &quot;=&quot; | sed &quot;N;s/\n/. /&quot;</span><br><span class="line"></span><br><span class="line">	local INDEX</span><br><span class="line">	read -p &quot;Which would you like? [0]: &quot; INDEX</span><br><span class="line">	INDEX=$(($&#123;INDEX:-0&#125; - 1))</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">根据用户选择的索引确定所选的板卡配置文件</span></span><br><span class="line">	if echo $INDEX | grep -vq [^0-9]; then</span><br><span class="line">		BOARD=&quot;$&#123;BOARD_ARRAY[$INDEX]&#125;&quot;</span><br><span class="line">	else</span><br><span class="line">		echo &quot;Lunching for Default BoardConfig.mk boards...&quot;</span><br><span class="line">		BOARD=BoardConfig.mk</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">创建符号链接，将所选的板卡配置文件链接到 BOARD_CONFIG 变量指定的路径</span></span><br><span class="line">	ln -rsf &quot;$CHIP_DIR/$BOARD&quot; &quot;$BOARD_CONFIG&quot;</span><br><span class="line">	echo &quot;switching to board: $(realpath $BOARD_CONFIG)&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取当前脚本所在目录的绝对路径，并赋值给 COMMON_DIR 变量</span></span><br><span class="line">COMMON_DIR=&quot;$(dirname &quot;$(realpath &quot;$0&quot;)&quot;)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据 COMMON_DIR 计算出顶级目录的绝对路径，并赋值给 TOP_DIR 变量</span></span><br><span class="line">TOP_DIR=&quot;$(realpath &quot;$COMMON_DIR/../../..&quot;)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到顶级目录</span></span><br><span class="line">cd &quot;$TOP_DIR&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 rockdev 目录（如果不存在）</span></span><br><span class="line">mkdir -p rockdev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 BOARD_CONFIG 变量为顶级目录下的 device/rockchip/.BoardConfig.mk 文件的绝对路径</span></span><br><span class="line">BOARD_CONFIG=&quot;$TOP_DIR/device/rockchip/.BoardConfig.mk&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取 CHIP_DIR 变量的绝对路径，该变量指向顶级目录下的 device/rockchip/.target_product 目录</span></span><br><span class="line">CHIP_DIR=&quot;$(realpath $TOP_DIR/device/rockchip/.target_product)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">预构建 U-Boot 函数</span></span><br><span class="line">prebuild_uboot()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">构建 U-Boot 的编译命令字符串</span></span><br><span class="line">	UBOOT_COMPILE_COMMANDS=&quot;\</span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash">&#123;RK_TRUST_INI_CONFIG:+../rkbin/RKTRUST/<span class="variable">$RK_TRUST_INI_CONFIG</span>&#125; \</span></span><br><span class="line"><span class="language-bash">			<span class="variable">$&#123;RK_SPL_INI_CONFIG:+../rkbin/RKBOOT/$RK_SPL_INI_CONFIG&#125;</span> \</span></span><br><span class="line"><span class="language-bash">			<span class="variable">$&#123;RK_UBOOT_SIZE_CONFIG:+--sz-uboot $RK_UBOOT_SIZE_CONFIG&#125;</span> \</span></span><br><span class="line"><span class="language-bash">			<span class="variable">$&#123;RK_TRUST_SIZE_CONFIG:+--sz-trust $RK_TRUST_SIZE_CONFIG&#125;</span><span class="string">&quot;</span></span></span><br><span class="line">	UBOOT_COMPILE_COMMANDS=&quot;$(echo $UBOOT_COMPILE_COMMANDS)&quot;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"><span class="string">如果启用 RAMDISK 安全启动，则添加相关的编译命令选项</span></span></span><br><span class="line">	if [ &quot;$RK_RAMDISK_SECURITY_BOOTUP&quot; = &quot;true&quot; ];then</span><br><span class="line">		UBOOT_COMPILE_COMMANDS=&quot; \</span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash"><span class="string">UBOOT_COMPILE_COMMANDS \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">			<span class="variable">$&#123;RK_ROLLBACK_INDEX_BOOT:+--rollback-index-boot $RK_ROLLBACK_INDEX_BOOT&#125;</span> \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">			<span class="variable">$&#123;RK_ROLLBACK_INDEX_UBOOT:+--rollback-index-uboot $RK_ROLLBACK_INDEX_UBOOT&#125;</span> &quot;</span></span></span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">预构建安全启动的 U-Boot 函数</span></span><br><span class="line">prebuild_security_uboot()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">获取传入的模式参数</span></span><br><span class="line">	local mode=$1</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果启用 RAMDISK 安全启动，则添加相关的编译命令选项</span></span><br><span class="line">	if [ &quot;$RK_RAMDISK_SECURITY_BOOTUP&quot; = &quot;true&quot; ];then</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">如果 RK_SECURITY_OTP_DEBUG 不等于 <span class="string">&quot;true&quot;</span>，则添加 --burn-key-hash 选项</span></span><br><span class="line">		if [ &quot;$RK_SECURITY_OTP_DEBUG&quot; != &quot;true&quot; ]; then</span><br><span class="line">			UBOOT_COMPILE_COMMANDS=&quot;$UBOOT_COMPILE_COMMANDS --burn-key-hash&quot;</span><br><span class="line">		fi</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">根据传入的模式参数进行不同的处理</span></span><br><span class="line">		case &quot;$&#123;mode:-normal&#125;&quot; in</span><br><span class="line"><span class="meta prompt_">			# </span><span class="language-bash">对于 uboot 模式，不需要额外的处理</span></span><br><span class="line">			uboot)</span><br><span class="line">				;;</span><br><span class="line"><span class="meta prompt_">			# </span><span class="language-bash">对于 boot 模式，添加 --boot_img 选项，并设置值为 <span class="variable">$TOP_DIR</span>/u-boot/boot.img</span></span><br><span class="line">			boot)</span><br><span class="line">				UBOOT_COMPILE_COMMANDS=&quot; \</span><br><span class="line">					--boot_img $TOP_DIR/u-boot/boot.img \</span><br><span class="line">					$UBOOT_COMPILE_COMMANDS &quot;</span><br><span class="line">				;;</span><br><span class="line"><span class="meta prompt_">			# </span><span class="language-bash">对于 recovery 模式，添加 --recovery_img 选项，并设置值为 <span class="variable">$TOP_DIR</span>/u-boot/recovery.img</span></span><br><span class="line">			recovery)</span><br><span class="line">				UBOOT_COMPILE_COMMANDS=&quot; \</span><br><span class="line">					--recovery_img $TOP_DIR/u-boot/recovery.img</span><br><span class="line">					$UBOOT_COMPILE_COMMANDS &quot;</span><br><span class="line">				;;</span><br><span class="line">			*)</span><br><span class="line"><span class="meta prompt_">			# </span><span class="language-bash">对于其他模式，默认添加 --boot_img 选项，并设置值为 <span class="variable">$TOP_DIR</span>/u-boot/boot.img</span></span><br><span class="line">				UBOOT_COMPILE_COMMANDS=&quot; \</span><br><span class="line">					--boot_img $TOP_DIR/u-boot/boot.img \</span><br><span class="line">					$UBOOT_COMPILE_COMMANDS &quot;</span><br><span class="line">				# 如果 RK_PACKAGE_FILE_AB 为空，则添加 --recovery_img 选项，并设置值为 $TOP_DIR/u-boot/recovery.img</span><br><span class="line">				test -z &quot;$&#123;RK_PACKAGE_FILE_AB&#125;&quot; &amp;&amp; \</span><br><span class="line">					UBOOT_COMPILE_COMMANDS=&quot;$UBOOT_COMPILE_COMMANDS --recovery_img $TOP_DIR/u-boot/recovery.img&quot;</span><br><span class="line">				;;</span><br><span class="line">		esac</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">使用 <span class="built_in">echo</span> 命令重新赋值 UBOOT_COMPILE_COMMANDS 变量，去除多余空格</span></span><br><span class="line">		UBOOT_COMPILE_COMMANDS=&quot;$(echo $UBOOT_COMPILE_COMMANDS)&quot;</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用法函数，打印脚本的使用说明</span></span><br><span class="line">usage()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">打印使用说明</span></span><br><span class="line">	echo &quot;Usage: build.sh [OPTIONS]&quot;</span><br><span class="line">	echo &quot;Available options:&quot;</span><br><span class="line">	echo &quot;BoardConfig*.mk    -switch to specified board config&quot;</span><br><span class="line">	echo &quot;lunch              -list current SDK boards and switch to specified board config&quot;</span><br><span class="line">	echo &quot;wifibt             -build wifibt&quot;</span><br><span class="line">	echo &quot;uboot              -build uboot&quot;</span><br><span class="line">	echo &quot;uefi		 -build uefi&quot;</span><br><span class="line">	echo &quot;spl                -build spl&quot;</span><br><span class="line">	echo &quot;loader             -build loader&quot;</span><br><span class="line">	echo &quot;kernel-4.4         -build kernel 4.4&quot;</span><br><span class="line">	echo &quot;kernel-4.19        -build kernel 4.19&quot;</span><br><span class="line">	echo &quot;kernel-5.10        -build kernel 5.10&quot;</span><br><span class="line">	echo &quot;kernel             -build kernel&quot;</span><br><span class="line">	echo &quot;modules            -build kernel modules&quot;</span><br><span class="line">	echo &quot;rootfs             -build rootfs (default is buildroot)&quot;</span><br><span class="line">	echo &quot;buildroot          -build buildroot rootfs&quot;</span><br><span class="line">	echo &quot;yocto              -build yocto rootfs&quot;</span><br><span class="line">	echo &quot;debian             -build debian rootfs&quot;</span><br><span class="line">	echo &quot;pcba               -build pcba&quot;</span><br><span class="line">	echo &quot;recovery           -build recovery&quot;</span><br><span class="line">	echo &quot;all                -build uboot, kernel, rootfs, recovery image&quot;</span><br><span class="line">	echo &quot;cleanall           -clean uboot, kernel, rootfs, recovery&quot;</span><br><span class="line">	echo &quot;firmware           -pack all the image we need to boot up system&quot;</span><br><span class="line">	echo &quot;updateimg          -pack update image&quot;</span><br><span class="line">	echo &quot;otapackage         -pack ab update otapackage image (update_ota.img)&quot;</span><br><span class="line">	echo &quot;sdpackage          -pack update sdcard package image (update_sdcard.img)&quot;</span><br><span class="line">	echo &quot;save               -save images, patches, commands used to debug&quot;</span><br><span class="line">	echo &quot;allsave            -build all &amp; firmware &amp; updateimg &amp; save&quot;</span><br><span class="line">	echo &quot;info               -see the current board building information&quot;</span><br><span class="line">	echo &quot;&quot;</span><br><span class="line">	echo &quot;createkeys         -create secureboot root keys&quot;</span><br><span class="line">	echo &quot;security_rootfs    -build rootfs and some relevant images with security paramter (just for dm-v)&quot;</span><br><span class="line">	echo &quot;security_boot      -build boot with security paramter&quot;</span><br><span class="line">	echo &quot;security_uboot     -build uboot with security paramter&quot;</span><br><span class="line">	echo &quot;security_recovery  -build recovery with security paramter&quot;</span><br><span class="line">	echo &quot;security_check     -check security paramter if it&#x27;s good&quot;</span><br><span class="line">	echo &quot;&quot;</span><br><span class="line">	echo &quot;Default option is &#x27;allsave&#x27;.&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建信息函数，打印当前构建的相关信息</span></span><br><span class="line">build_info()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果 CHIP_DIR 路径不存在，则打印错误信息，表示未找到目标芯片</span></span><br><span class="line">	if [ ! -L $CHIP_DIR ];then</span><br><span class="line">		echo &quot;No found target chip!!!&quot;</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果 BOARD_CONFIG 路径不存在，则打印错误信息，表示未找到目标板级配置</span></span><br><span class="line">	if [ ! -L $BOARD_CONFIG ];then</span><br><span class="line">		echo &quot;No found target board config!!!&quot;</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果存在 .repo/manifest.xml 文件，则获取 SDK 版本号，并打印构建的 SDK 版本</span></span><br><span class="line">	if [ -f .repo/manifest.xml ]; then</span><br><span class="line">		local sdk_ver=&quot;&quot;</span><br><span class="line">		sdk_ver=`grep &quot;include name&quot;  .repo/manifest.xml | awk -F\&quot; &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">		sdk_ver=`realpath .repo/manifests/$&#123;sdk_ver&#125;`</span><br><span class="line">		echo &quot;Build SDK version: `basename $&#123;sdk_ver&#125;`&quot;</span><br><span class="line">	else</span><br><span class="line">		echo &quot;Not found .repo/manifest.xml [ignore] !!!&quot;</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">打印当前构建的信息，包括目标芯片、目标板级配置和一些目标的其他配置参数</span></span><br><span class="line">	echo &quot;Current Building Information:&quot;</span><br><span class="line">	echo &quot;Target Chip: $CHIP_DIR&quot;</span><br><span class="line">	echo &quot;Target BoardConfig: `realpath $BOARD_CONFIG`&quot;</span><br><span class="line">	echo &quot;Target Misc config:&quot;</span><br><span class="line">	echo &quot;`env |grep &quot;^RK_&quot; | grep -v &quot;=$&quot; | sort`&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">根据 RK_KERNEL_ARCH 变量的值确定设备树（dtb）的路径，并删除已存在的 dtb 文件</span></span><br><span class="line">	if [ &quot;$RK_KERNEL_ARCH&quot; == &quot;arm&quot; ]; then</span><br><span class="line">		dtb=&quot;kernel/arch/arm/boot/dts/$&#123;RK_KERNEL_DTS&#125;.dtb&quot;</span><br><span class="line">	else</span><br><span class="line">		dtb=&quot;kernel/arch/arm64/boot/dts/rockchip/$&#123;RK_KERNEL_DTS&#125;.dtb&quot;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	rm -f $dtb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">使用 <span class="variable">$KMAKE</span> dtbs 命令生成设备树（dtb）文件</span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">KMAKE dtbs</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">调用 build_check_power_domain 函数检查电源域</span></span><br><span class="line">	build_check_power_domain</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建检查电源域函数，用于检查电源域配置是否正确</span></span><br><span class="line">build_check_power_domain()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">定义临时文件和变量</span></span><br><span class="line">	local dump_kernel_dtb_file</span><br><span class="line">	local tmp_phandle_file</span><br><span class="line">	local tmp_io_domain_file</span><br><span class="line">	local tmp_regulator_microvolt_file</span><br><span class="line">	local tmp_final_target</span><br><span class="line">	local tmp_none_item</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">根据 RK_KERNEL_ARCH 变量的值确定设备树（dts）文件的路径</span></span><br><span class="line">	if [ &quot;$RK_KERNEL_ARCH&quot; == &quot;arm&quot; ]; then</span><br><span class="line">		dts=&quot;kernel/arch/arm/boot/dts/$RK_KERNEL_DTS&quot;</span><br><span class="line">	else</span><br><span class="line">		dts=&quot;kernel/arch/arm64/boot/dts/rockchip/$RK_KERNEL_DTS&quot;</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">定义临时文件的路径</span></span><br><span class="line">	dump_kernel_dtb_file=$&#123;dts&#125;.dump.dts</span><br><span class="line">	tmp_phandle_file=`mktemp`</span><br><span class="line">	tmp_io_domain_file=`mktemp`</span><br><span class="line">	tmp_regulator_microvolt_file=`mktemp`</span><br><span class="line">	tmp_final_target=`mktemp`</span><br><span class="line">	tmp_grep_file=`mktemp`</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">将设备树二进制文件转换为文本格式，并保存为 dump_kernel_dtb_file</span></span><br><span class="line">	dtc -I dtb -O dts -o $&#123;dump_kernel_dtb_file&#125; $&#123;dts&#125;.dtb 2&gt;/dev/null</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果 RK_SYSTEM_CHECK_METHOD 变量的值为 <span class="string">&quot;DM-E&quot;</span>，则检查是否在设备树中添加了 optee-tz 的兼容性</span></span><br><span class="line">	if [ &quot;$RK_SYSTEM_CHECK_METHOD&quot; = &quot;DM-E&quot; ] ; then</span><br><span class="line">		if ! grep &quot;compatible = \&quot;linaro,optee-tz\&quot;;&quot; $dump_kernel_dtb_file &gt; /dev/null 2&gt;&amp;1 ; then</span><br><span class="line">			echo &quot;Please add: &quot;</span><br><span class="line">			echo &quot;        optee: optee &#123;&quot;</span><br><span class="line">			echo &quot;                compatible = \&quot;linaro,optee-tz\&quot;;&quot;</span><br><span class="line">			echo &quot;                method = \&quot;smc\&quot;;&quot;</span><br><span class="line">			echo &quot;                status = \&quot;okay\&quot;;&quot;</span><br><span class="line">			echo &quot;        &#125;&quot;</span><br><span class="line">			echo &quot;To your dts file&quot;</span><br><span class="line">			return -1;</span><br><span class="line">		fi</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">使用正则表达式从设备树中提取 io-domains 配置，并保存到临时文件 tmp_io_domain_file 和 tmp_grep_file</span></span><br><span class="line">	if ! grep -Pzo &quot;io-domains\s*&#123;(\n|\w|-|;|=|&lt;|&gt;|\&quot;|_|\s|,)*&#125;;&quot; $dump_kernel_dtb_file 1&gt;$tmp_grep_file 2&gt;/dev/null; then</span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;Not Found io-domains in <span class="variable">$&#123;dts&#125;</span>.dts&quot;</span></span></span><br><span class="line">		rm -f $tmp_grep_file</span><br><span class="line">		return 0</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">从临时文件 tmp_grep_file 中提取供电（supply）信息，并保存到临时文件 tmp_io_domain_file</span></span><br><span class="line">	grep -a supply $tmp_grep_file &gt; $tmp_io_domain_file</span><br><span class="line">	rm -f $tmp_grep_file</span><br><span class="line">	awk &#x27;&#123;print &quot;phandle = &quot; $3&#125;&#x27; $tmp_io_domain_file &gt; $tmp_phandle_file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">逐行读取临时文件 tmp_phandle_file 和 tmp_io_domain_file，并进行处理</span></span><br><span class="line">	while IFS= read -r item_phandle &amp;&amp; IFS= read -u 3 -r item_domain</span><br><span class="line">	do</span><br><span class="line">		echo &quot;$&#123;item_domain% *&#125;&quot; &gt;&gt; $tmp_regulator_microvolt_file</span><br><span class="line">		tmp_none_item=$&#123;item_domain% *&#125;</span><br><span class="line">		cmds=&quot;grep -Pzo \&quot;&#123;(\\n|\w|-|;|=|&lt;|&gt;|\\\&quot;|_|\s)*&quot;$item_phandle\&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">使用 <span class="built_in">eval</span> 执行命令，从设备树中提取相应的 regulator-m..-microvolt 配置，并将结果保存到临时文件 tmp_regulator_microvolt_file</span></span><br><span class="line">		eval &quot;$cmds $dump_kernel_dtb_file | strings | grep &quot;regulator-m..-microvolt&quot; &gt;&gt; $tmp_regulator_microvolt_file&quot; || \</span><br><span class="line">			eval &quot;sed -i \&quot;/$&#123;tmp_none_item&#125;/d\&quot; $tmp_regulator_microvolt_file&quot; &amp;&amp; continue</span><br><span class="line"></span><br><span class="line">		echo &gt;&gt; $tmp_regulator_microvolt_file</span><br><span class="line">	done &lt; $tmp_phandle_file 3&lt;$tmp_io_domain_file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">逐行读取临时文件 tmp_regulator_microvolt_file，生成最终的目标文件 tmp_final_target</span></span><br><span class="line">	while read -r regulator_val</span><br><span class="line">	do</span><br><span class="line">		if echo $&#123;regulator_val&#125; | grep supply &amp;&gt;/dev/null; then</span><br><span class="line">			echo -e &quot;\n\n\e[1;33m$&#123;regulator_val%*=&#125;\e[0m&quot; &gt;&gt; $tmp_final_target</span><br><span class="line">		else</span><br><span class="line">			tmp_none_item=$&#123;regulator_val##*&lt;&#125;</span><br><span class="line">			tmp_none_item=$&#123;tmp_none_item%%&gt;*&#125;</span><br><span class="line">			echo -e &quot;$&#123;regulator_val%%&lt;*&#125; \e[1;31m$(( $tmp_none_item / 1000 ))mV\e[0m&quot; &gt;&gt; $tmp_final_target</span><br><span class="line">		fi</span><br><span class="line">	done &lt; $tmp_regulator_microvolt_file</span><br><span class="line"></span><br><span class="line">	echo -e &quot;\e[41;1;30m PLEASE CHECK BOARD GPIO POWER DOMAIN CONFIGURATION !!!!!\e[0m&quot;</span><br><span class="line">	echo -e &quot;\e[41;1;30m &lt;&lt;&lt; ESPECIALLY Wi-Fi/Flash/Ethernet IO power domain &gt;&gt;&gt; !!!!!\e[0m&quot;</span><br><span class="line">	echo -e &quot;\e[41;1;30m Check Node [pmu_io_domains] in the file: $&#123;dts&#125;.dts \e[0m&quot;</span><br><span class="line">	echo</span><br><span class="line">	echo -e &quot;\e[41;1;30m 请再次确认板级的电源域配置！！！！！！\e[0m&quot;</span><br><span class="line">	echo -e &quot;\e[41;1;30m &lt;&lt;&lt; 特别是Wi-Fi，FLASH，以太网这几路IO电源的配置 &gt;&gt;&gt; ！！！！！\e[0m&quot;</span><br><span class="line">	echo -e &quot;\e[41;1;30m 检查内核文件 $&#123;dts&#125;.dts 的节点 [pmu_io_domains] \e[0m&quot;</span><br><span class="line">	cat $tmp_final_target</span><br><span class="line"></span><br><span class="line">	rm -f $tmp_phandle_file</span><br><span class="line">	rm -f $tmp_regulator_microvolt_file</span><br><span class="line">	rm -f $tmp_io_domain_file</span><br><span class="line">	rm -f $tmp_final_target</span><br><span class="line">	rm -f $dump_kernel_dtb_file</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置交叉编译工具链和相关参数</span></span><br><span class="line">setup_cross_compile()</span><br><span class="line">&#123;</span><br><span class="line">	if [ &quot;$RK_CHIP&quot; = &quot;rv1126_rv1109&quot; ]; then</span><br><span class="line">		TOOLCHAIN_OS=rockchip</span><br><span class="line">	else</span><br><span class="line">		TOOLCHAIN_OS=none</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">将 RK_KERNEL_ARCH 中的 arm64 替换为 aarch64</span></span><br><span class="line">	TOOLCHAIN_ARCH=$&#123;RK_KERNEL_ARCH/arm64/aarch64&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">查找匹配的 GCC 工具链路径</span></span><br><span class="line">	TOOLCHAIN_DIR=&quot;$(realpath prebuilts/gcc/*/$TOOLCHAIN_ARCH/gcc-arm-*)&quot;</span><br><span class="line">	GCC=&quot;$(find &quot;$TOOLCHAIN_DIR&quot; -name &quot;*$TOOLCHAIN_OS*-gcc&quot;)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">检查是否存在可执行的 GCC 工具链</span></span><br><span class="line">	if [ ! -x &quot;$GCC&quot; ]; then</span><br><span class="line">		echo &quot;No prebuilt GCC toolchain!&quot;</span><br><span class="line">		return 1</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">设置交叉编译前缀</span></span><br><span class="line">	export CROSS_COMPILE=&quot;$&#123;GCC%gcc&#125;&quot;</span><br><span class="line">	echo &quot;Using prebuilt GCC toolchain: $CROSS_COMPILE&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">获取可用的处理器核心数量</span></span><br><span class="line">	NUM_CPUS=$(getconf _NPROCESSORS_ONLN 2&gt;/dev/null || echo 1)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">设置并发编译任务数，默认为处理器核心数量加一</span></span><br><span class="line">	JLEVEL=$&#123;RK_JOBS:-$(( $NUM_CPUS + 1 ))&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">定义内核编译命令</span></span><br><span class="line">	KMAKE=&quot;make -C kernel/ ARCH=$RK_KERNEL_ARCH -j$JLEVEL&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建 UEFI</span></span><br><span class="line">build_uefi()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">设置交叉编译工具链和相关参数</span></span><br><span class="line">	setup_cross_compile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">根据 RK_KERNEL_ARCH 的值确定 dtb 文件路径</span></span><br><span class="line">	if [ &quot;$RK_KERNEL_ARCH&quot; == &quot;arm&quot; ]; then</span><br><span class="line">		dtb=&quot;kernel/arch/arm/boot/dts/$&#123;RK_KERNEL_DTS&#125;.dtb&quot;</span><br><span class="line">	else</span><br><span class="line">		dtb=&quot;kernel/arch/arm64/boot/dts/rockchip/$&#123;RK_KERNEL_DTS&#125;.dtb&quot;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	echo &quot;============Start building uefi============&quot;</span><br><span class="line">	echo &quot;Copy kernel dtb $dtb to uefi/edk2-platforms/Platform/Rockchip/DeviceTree/rk3588.dtb&quot;</span><br><span class="line">	echo &quot;=========================================&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">检查 dtb 文件是否存在</span></span><br><span class="line">	if [ ! -f $dtb ]; then</span><br><span class="line">		echo &quot;Please compile the kernel before&quot;</span><br><span class="line">		return -1</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">将 dtb 文件复制到 uefi 目录</span></span><br><span class="line">	cp $dtb uefi/edk2-platforms/Platform/Rockchip/DeviceTree/rk3588.dtb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">进入 uefi 目录并执行构建脚本</span></span><br><span class="line">	cd uefi</span><br><span class="line">	./make.sh $RK_UBOOT_DEFCONFIG</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">完成构建流程</span></span><br><span class="line">	finish_build</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建 U-Boot</span></span><br><span class="line">build_uboot()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">检查 RK_UBOOT_DEFCONFIG 配置是否存在，若不存在则返回</span></span><br><span class="line">	check_config RK_UBOOT_DEFCONFIG || return 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">设置交叉编译工具链和相关参数</span></span><br><span class="line">	setup_cross_compile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">准备 U-Boot 构建所需的文件</span></span><br><span class="line">	prebuild_uboot</span><br><span class="line">	prebuild_security_uboot $@</span><br><span class="line"></span><br><span class="line">	echo &quot;============Start building uboot============&quot;</span><br><span class="line">	echo &quot;TARGET_UBOOT_CONFIG=$RK_UBOOT_DEFCONFIG&quot;</span><br><span class="line">	echo &quot;=========================================&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">进入 u-boot 目录并删除旧的 *_loader_*.bin 文件</span></span><br><span class="line">	cd u-boot</span><br><span class="line">	rm -f *_loader_*.bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">构建 U-Boot</span></span><br><span class="line">	if [ -n &quot;$RK_UBOOT_DEFCONFIG_FRAGMENT&quot; ]; then</span><br><span class="line">		if [ -f &quot;configs/$&#123;RK_UBOOT_DEFCONFIG&#125;_defconfig&quot; ]; then</span><br><span class="line">			UBOOT_CONFIGS=&quot;$&#123;RK_UBOOT_DEFCONFIG&#125;_defconfig&quot;</span><br><span class="line">		else</span><br><span class="line">			UBOOT_CONFIGS=&quot;$&#123;RK_UBOOT_DEFCONFIG&#125;.config&quot;</span><br><span class="line">		fi</span><br><span class="line">		UBOOT_CONFIGS=&quot;$UBOOT_CONFIGS $RK_UBOOT_DEFCONFIG_FRAGMENT&quot;</span><br><span class="line">	else</span><br><span class="line">		UBOOT_CONFIGS=&quot;$RK_UBOOT_DEFCONFIG&quot;</span><br><span class="line">	fi</span><br><span class="line">	./make.sh $UBOOT_CONFIGS $UBOOT_COMPILE_COMMANDS \</span><br><span class="line">		CROSS_COMPILE=$CROSS_COMPILE</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果需要更新 RK_IDBLOCK_SPL，则执行带有 --idblock 和 --spl 参数的 make.sh</span></span><br><span class="line">	if [ &quot;$RK_IDBLOCK_UPDATE_SPL&quot; = &quot;true&quot; ]; then</span><br><span class="line">		./make.sh --idblock --spl</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	cd ..</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果需要进行 RAMDISK 安全启动，则创建链接到 rockdev 目录的 boot.img 和 recovery.img</span></span><br><span class="line">	if [ &quot;$RK_RAMDISK_SECURITY_BOOTUP&quot; = &quot;true&quot; ];then</span><br><span class="line">		ln -rsf u-boot/boot.img rockdev/</span><br><span class="line">		test -z &quot;$&#123;RK_PACKAGE_FILE_AB&#125;&quot; &amp;&amp; \</span><br><span class="line">			ln -rsf u-boot/recovery.img rockdev/ || true</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">创建链接到 rockdev 目录的 MiniLoaderAll.bin、uboot.img 和 trust.img（如果存在）</span></span><br><span class="line">	LOADER=&quot;$(echo u-boot/*_loader_*v*.bin | head -1)&quot;</span><br><span class="line">	SPL=&quot;$(echo u-boot/*_loader_spl.bin | head -1)&quot;</span><br><span class="line">	ln -rsf &quot;$&#123;LOADER:-$SPL&#125;&quot; rockdev/MiniLoaderAll.bin</span><br><span class="line">	ln -rsf u-boot/uboot.img rockdev/</span><br><span class="line">	[ ! -e u-boot/trust.img ] || \</span><br><span class="line">		ln -rsf u-boot/trust.img rockdev/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">完成构建流程</span></span><br><span class="line">	finish_build</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建 SPL</span></span><br><span class="line">build_spl()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">检查 RK_SPL_DEFCONFIG 配置是否存在，若不存在则返回</span></span><br><span class="line">	check_config RK_SPL_DEFCONFIG || return 0</span><br><span class="line"></span><br><span class="line">	echo &quot;============Start building spl============&quot;</span><br><span class="line">	echo &quot;TARGET_SPL_CONFIG=$RK_SPL_DEFCONFIG&quot;</span><br><span class="line">	echo &quot;=========================================&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">进入 u-boot 目录并删除旧的 spl.bin 文件</span></span><br><span class="line">	cd u-boot</span><br><span class="line">	rm -f *spl.bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">构建 SPL</span></span><br><span class="line">	./make.sh $RK_SPL_DEFCONFIG</span><br><span class="line">	./make.sh --spl</span><br><span class="line">	cd ..</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">创建链接到 rockdev 目录的 MiniLoaderAll.bin</span></span><br><span class="line">	SPL=&quot;$(echo u-boot/*_loader_spl.bin | head -1)&quot;</span><br><span class="line">	ln -rsf &quot;$SPL&quot; rockdev/MiniLoaderAll.bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">完成构建流程</span></span><br><span class="line">	finish_build</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建 Loader</span></span><br><span class="line">build_loader()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">检查 RK_LOADER_BUILD_TARGET 配置是否存在，若不存在则返回</span></span><br><span class="line">	check_config RK_LOADER_BUILD_TARGET || return 0</span><br><span class="line"></span><br><span class="line">	echo &quot;============Start building loader============&quot;</span><br><span class="line">	echo &quot;RK_LOADER_BUILD_TARGET=$RK_LOADER_BUILD_TARGET&quot;</span><br><span class="line">	echo &quot;==========================================&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">进入 loader 目录并执行 build.sh 构建 Loader</span></span><br><span class="line">	cd loader</span><br><span class="line">	./build.sh $RK_LOADER_BUILD_TARGET</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">完成构建流程</span></span><br><span class="line">	finish_build</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建 Kernel</span></span><br><span class="line">build_kernel()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">检查 RK_KERNEL_DTS 和 RK_KERNEL_DEFCONFIG 配置是否存在，若不存在则返回</span></span><br><span class="line">	check_config RK_KERNEL_DTS RK_KERNEL_DEFCONFIG || return 0</span><br><span class="line"></span><br><span class="line">	echo &quot;============Start building kernel============&quot;</span><br><span class="line">	echo &quot;TARGET_KERNEL_ARCH   =$RK_KERNEL_ARCH&quot;</span><br><span class="line">	echo &quot;TARGET_KERNEL_CONFIG =$RK_KERNEL_DEFCONFIG&quot;</span><br><span class="line">	echo &quot;TARGET_KERNEL_DTS    =$RK_KERNEL_DTS&quot;</span><br><span class="line">	echo &quot;TARGET_KERNEL_CONFIG_FRAGMENT =$RK_KERNEL_DEFCONFIG_FRAGMENT&quot;</span><br><span class="line">	echo &quot;==========================================&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">设置交叉编译工具链</span></span><br><span class="line">	setup_cross_compile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">使用 KMAKE 构建 Kernel</span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">KMAKE <span class="variable">$RK_KERNEL_DEFCONFIG</span> <span class="variable">$RK_KERNEL_DEFCONFIG_FRAGMENT</span></span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">KMAKE <span class="variable">$RK_KERNEL_DTS</span>.img</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">检查是否存在 Kernel FIT 文件并使用 mk-fitimage.sh 创建镜像</span></span><br><span class="line">	ITS=&quot;$CHIP_DIR/$RK_KERNEL_FIT_ITS&quot;</span><br><span class="line">	if [ -f &quot;$ITS&quot; ]; then</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">COMMON_DIR/mk-fitimage.sh kernel/<span class="variable">$RK_BOOT_IMG</span> \</span></span><br><span class="line"><span class="language-bash">			<span class="string">&quot;<span class="variable">$ITS</span>&quot;</span> <span class="variable">$RK_KERNEL_IMG</span></span></span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">创建链接到 rockdev 目录的 boot.img</span></span><br><span class="line">	ln -rsf kernel/$RK_BOOT_IMG rockdev/boot.img</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">将 boot.img 复制到 u-boot 目录下，用于安全性考虑</span></span><br><span class="line">	cp rockdev/boot.img u-boot/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">构建检查电源域</span></span><br><span class="line">	build_check_power_domain</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">完成构建流程</span></span><br><span class="line">	finish_build</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建 Wi-Fi 和蓝牙</span></span><br><span class="line">build_wifibt()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">设置交叉编译工具链</span></span><br><span class="line">	setup_cross_compile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">设置 Buildroot 相关路径</span></span><br><span class="line">	BUILDROOT_OUTDIR=$TOP_DIR/buildroot/output/$RK_CFG_BUILDROOT/</span><br><span class="line">	BUILDROOT_HOST_DIR=$BUILDROOT_OUTDIR/host/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">检查 Buildroot 架构</span></span><br><span class="line">	if grep -wq aarch64 &quot;$BUILDROOT_OUTDIR/.config&quot; 2&gt;/dev/null; then</span><br><span class="line">		BUILDROOT_ARCH=arm64</span><br><span class="line">	else</span><br><span class="line">		BUILDROOT_ARCH=arm</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">获取 Buildroot GCC 和 SYSROOT 路径</span></span><br><span class="line">	BUILDROOT_GCC=&quot;$(echo $BUILDROOT_HOST_DIR/bin/*buildroot*-gcc)&quot;</span><br><span class="line">	BUILDROOT_SYSROOT=&quot;$(echo $BUILDROOT_HOST_DIR/*/sysroot/)&quot;</span><br><span class="line">	if [ ! -x &quot;$BUILDROOT_GCC&quot; -o ! -d &quot;$BUILDROOT_SYSROOT&quot; ]; then</span><br><span class="line">		echo &quot;ERROR: Buildroot not ready!&quot;</span><br><span class="line">		exit -1</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">设置 Wi-Fi 和蓝牙芯片类型和 TTY 设备</span></span><br><span class="line">	if [ -n &quot;$1&quot; ]; then</span><br><span class="line">		WIFI_CHIP=$1</span><br><span class="line">	elif [ -n &quot;$RK_WIFIBT_CHIP&quot; ]; then</span><br><span class="line">		WIFI_CHIP=$RK_WIFIBT_CHIP</span><br><span class="line">	else</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">默认为 ALL_AP</span></span><br><span class="line">		echo &quot;=== WARNNING WIFI_CHIP is NULL so default to ALL_AP ===&quot;</span><br><span class="line">		WIFI_CHIP=ALL_AP</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [ -n &quot;$2&quot; ]; then</span><br><span class="line">		BT_TTY_DEV=$2</span><br><span class="line">	elif [ -n &quot;$RK_WIFIBT_TTY&quot; ]; then</span><br><span class="line">		BT_TTY_DEV=$RK_WIFIBT_TTY</span><br><span class="line">	else</span><br><span class="line">		echo &quot;=== WARNNING BT_TTY is NULL so default to ttyS0 ===&quot;</span><br><span class="line">		BT_TTY_DEV=ttyS0</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">检查内核 .config 配置</span></span><br><span class="line">	WIFI_USB=$(grep &quot;CONFIG_USB=y&quot; $TOP_DIR/kernel/.config || true)</span><br><span class="line">	WIFI_SDIO=$(grep &quot;CONFIG_MMC=y&quot; $TOP_DIR/kernel/.config || true)</span><br><span class="line">	WIFI_PCIE=$(grep &quot;CONFIG_PCIE_DW_ROCKCHIP=y&quot; $TOP_DIR/kernel/.config || true)</span><br><span class="line">	WIFI_RFKILL=$(grep &quot;CONFIG_RFKILL=y&quot; $TOP_DIR/kernel/.config || true)</span><br><span class="line">	if [ -z &quot;$WIFI_SDIO&quot; ]; then</span><br><span class="line">		echo &quot;=== WARNNING CONFIG_MMC not set !!! ===&quot;</span><br><span class="line">	fi</span><br><span class="line">	if [ -z &quot;$WIFI_RFKILL&quot; ]; then</span><br><span class="line">		echo &quot;=== WARNNING CONFIG_USB not set !!! ===&quot;</span><br><span class="line">	fi</span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; =~ &quot;U&quot; ]]; then</span><br><span class="line">		if [ -z &quot;$WIFI_USB&quot; ]; then</span><br><span class="line">			echo &quot;=== WARNNING CONFIG_USB not set so ABORT!!! ===&quot;</span><br><span class="line">			exit 0</span><br><span class="line">		fi</span><br><span class="line">	fi</span><br><span class="line">	echo &quot;kernel config: $WIFI_USB $WIFI_SDIO $WIFI_RFKILL&quot;</span><br><span class="line"></span><br><span class="line">	TARGET_CC=$&#123;CROSS_COMPILE&#125;gcc</span><br><span class="line">	RKWIFIBT=$TOP_DIR/external/rkwifibt</span><br><span class="line">	RKWIFIBT_APP=$TOP_DIR/external/rkwifibt-app</span><br><span class="line">	TARGET_ROOTFS_DIR=$TOP_DIR/buildroot/output/$RK_CFG_BUILDROOT/target</span><br><span class="line"></span><br><span class="line">	echo &quot;========build wifibt info=======&quot;</span><br><span class="line">	echo CROSS_COMPILE=$CROSS_COMPILE</span><br><span class="line">	echo WIFI_CHIP=$WIFI_CHIP</span><br><span class="line">	echo BT_TTY_DEV=$BT_TTY_DEV</span><br><span class="line">	echo TARGET_ROOTFS_DIR=$TARGET_ROOTFS_DIR</span><br><span class="line">	echo BUILDROOT_GCC=$BUILDROOT_GCC</span><br><span class="line">	echo BUILDROOT_SYSROOT=$BUILDROOT_SYSROOT</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; =~ &quot;ALL_AP&quot; ]];then</span><br><span class="line">		echo &quot;building bcmdhd sdio&quot;</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/bcmdhd CONFIG_BCMDHD=m CONFIG_BCMDHD_SDIO=y CONFIG_BCMDHD_PCIE=</span></span><br><span class="line">		if [ -n &quot;$WIFI_PCIE&quot; ]; then</span><br><span class="line">			echo &quot;building bcmdhd pcie&quot;</span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/bcmdhd CONFIG_BCMDHD=m CONFIG_BCMDHD_PCIE=y CONFIG_BCMDHD_SDIO=</span></span><br><span class="line">		fi</span><br><span class="line">		if [ -n &quot;$WIFI_USB&quot; ]; then</span><br><span class="line">			echo &quot;building rtl8188fu usb&quot;</span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/rtl8188fu modules</span></span><br><span class="line">		fi</span><br><span class="line">		echo &quot;building rtl8189fs sdio&quot;</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/rtl8189fs modules</span></span><br><span class="line">		echo &quot;building rtl8723ds sdio&quot;</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/rtl8723ds modules</span></span><br><span class="line">		echo &quot;building rtl8821cs sdio&quot;</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/rtl8821cs modules</span></span><br><span class="line">		echo &quot;building rtl8822cs sdio&quot;</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/rtl8822cs modules</span></span><br><span class="line">		echo &quot;building rtl8852bs sdio&quot;</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/rtl8852bs modules DRV_PATH=<span class="variable">$RKWIFIBT</span>/drivers/rtl8852bs</span></span><br><span class="line">		if [ -n &quot;$WIFI_PCIE&quot; ]; then</span><br><span class="line">			echo &quot;building rtl8852be pcie&quot;</span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/rtl8852be modules DRV_PATH=<span class="variable">$RKWIFIBT</span>/drivers/rtl8852be</span></span><br><span class="line">		fi</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; =~ &quot;ALL_CY&quot; ]];then</span><br><span class="line">		echo &quot;building CYW4354&quot;</span><br><span class="line">		cp $RKWIFIBT/drivers/infineon/chips/CYW4354_Makefile $RKWIFIBT/drivers/infineon/Makefile -r</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/infineon</span></span><br><span class="line">		echo &quot;building CYW4373&quot;</span><br><span class="line">		cp $RKWIFIBT/drivers/infineon/chips/CYW4373_Makefile $RKWIFIBT/drivers/infineon/Makefile -r</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/infineon</span></span><br><span class="line">		echo &quot;building CYW43438&quot;</span><br><span class="line">		cp $RKWIFIBT/drivers/infineon/chips/CYW43438_Makefile $RKWIFIBT/drivers/infineon/Makefile -r</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/infineon</span></span><br><span class="line">		echo &quot;building CYW43455&quot;</span><br><span class="line">		cp $RKWIFIBT/drivers/infineon/chips/CYW43455_Makefile $RKWIFIBT/drivers/infineon/Makefile -r</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/infineon</span></span><br><span class="line">		echo &quot;building CYW5557X&quot;</span><br><span class="line">		cp $RKWIFIBT/drivers/infineon/chips/CYW5557X_Makefile $RKWIFIBT/drivers/infineon/Makefile -r</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/infineon</span></span><br><span class="line">		if [ -n &quot;$WIFI_PCIE&quot; ]; then</span><br><span class="line">			echo &quot;building CYW5557X_PCIE&quot;</span><br><span class="line">			cp $RKWIFIBT/drivers/infineon/chips/CYW5557X_PCIE_Makefile $RKWIFIBT/drivers/infineon/Makefile -r</span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/infineon</span></span><br><span class="line">			echo &quot;building CYW54591_PCIE&quot;</span><br><span class="line">			cp $RKWIFIBT/drivers/infineon/chips/CYW54591_PCIE_Makefile $RKWIFIBT/drivers/infineon/Makefile -r</span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/infineon</span></span><br><span class="line">		fi</span><br><span class="line">		echo &quot;building CYW54591&quot;</span><br><span class="line">		cp $RKWIFIBT/drivers/infineon/chips/CYW54591_Makefile $RKWIFIBT/drivers/infineon/Makefile -r</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/infineon</span></span><br><span class="line"></span><br><span class="line">		if [ -n &quot;$WIFI_USB&quot; ]; then</span><br><span class="line">			echo &quot;building rtl8188fu usb&quot;</span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/rtl8188fu modules</span></span><br><span class="line">		fi</span><br><span class="line">		echo &quot;building rtl8189fs sdio&quot;</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/rtl8189fs modules</span></span><br><span class="line">		echo &quot;building rtl8723ds sdio&quot;</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/rtl8723ds modules</span></span><br><span class="line">		echo &quot;building rtl8821cs sdio&quot;</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/rtl8821cs modules</span></span><br><span class="line">		echo &quot;building rtl8822cs sdio&quot;</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/rtl8822cs modules</span></span><br><span class="line">		echo &quot;building rtl8852bs sdio&quot;</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/rtl8852bs modules DRV_PATH=<span class="variable">$RKWIFIBT</span>/drivers/rtl8852bs</span></span><br><span class="line">		if [ -n &quot;$WIFI_PCIE&quot; ]; then</span><br><span class="line">			echo &quot;building rtl8852be pcie&quot;</span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/rtl8852be modules DRV_PATH=<span class="variable">$RKWIFIBT</span>/drivers/rtl8852be</span></span><br><span class="line">		fi</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; =~ &quot;AP6&quot; ]];then</span><br><span class="line">		if [[ &quot;$WIFI_CHIP&quot; = &quot;AP6275_PCIE&quot; ]];then</span><br><span class="line">			echo &quot;building bcmdhd pcie driver&quot;</span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/bcmdhd CONFIG_BCMDHD=m CONFIG_BCMDHD_PCIE=y CONFIG_BCMDHD_SDIO=</span></span><br><span class="line">		else</span><br><span class="line">			echo &quot;building bcmdhd sdio driver&quot;</span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/bcmdhd CONFIG_BCMDHD=m CONFIG_BCMDHD_SDIO=y CONFIG_BCMDHD_PCIE=</span></span><br><span class="line">		fi</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; = &quot;CYW4354&quot; ]];then</span><br><span class="line">		echo &quot;building CYW4354&quot;</span><br><span class="line">		cp $RKWIFIBT/drivers/infineon/chips/CYW4354_Makefile $RKWIFIBT/drivers/infineon/Makefile -r</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/infineon</span></span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; = &quot;CYW4373&quot; ]];then</span><br><span class="line">		echo &quot;building CYW4373&quot;</span><br><span class="line">		cp $RKWIFIBT/drivers/infineon/chips/CYW4373_Makefile $RKWIFIBT/drivers/infineon/Makefile -r</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/infineon</span></span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; = &quot;CYW43438&quot; ]];then</span><br><span class="line">		echo &quot;building CYW43438&quot;</span><br><span class="line">		cp $RKWIFIBT/drivers/infineon/chips/CYW43438_Makefile $RKWIFIBT/drivers/infineon/Makefile -r</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/infineon</span></span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; = &quot;CYW43455&quot; ]];then</span><br><span class="line">		echo &quot;building CYW43455&quot;</span><br><span class="line">		cp $RKWIFIBT/drivers/infineon/chips/CYW43455_Makefile $RKWIFIBT/drivers/infineon/Makefile -r</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/infineon</span></span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; = &quot;CYW5557X&quot; ]];then</span><br><span class="line">		echo &quot;building CYW5557X&quot;</span><br><span class="line">		cp $RKWIFIBT/drivers/infineon/chips/CYW5557X_Makefile $RKWIFIBT/drivers/infineon/Makefile -r</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/infineon</span></span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; = &quot;CYW5557X_PCIE&quot; ]];then</span><br><span class="line">		echo &quot;building CYW5557X_PCIE&quot;</span><br><span class="line">		cp $RKWIFIBT/drivers/infineon/chips/CYW5557X_PCIE_Makefile $RKWIFIBT/drivers/infineon/Makefile -r</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/infineon</span></span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; = &quot;CYW54591&quot; ]];then</span><br><span class="line">		echo &quot;building CYW54591&quot;</span><br><span class="line">		cp $RKWIFIBT/drivers/infineon/chips/CYW54591_Makefile $RKWIFIBT/drivers/infineon/Makefile -r</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/infineon</span></span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; = &quot;CYW54591_PCIE&quot; ]];then</span><br><span class="line">		echo &quot;building CYW54591_PCIE&quot;</span><br><span class="line">		cp $RKWIFIBT/drivers/infineon/chips/CYW54591_PCIE_Makefile $RKWIFIBT/drivers/infineon/Makefile -r</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/infineon</span></span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; = &quot;RTL8188FU&quot; ]];then</span><br><span class="line">		echo &quot;building rtl8188fu driver&quot;</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/rtl8188fu modules</span></span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; = &quot;RTL8189FS&quot; ]];then</span><br><span class="line">		echo &quot;building rtl8189fs driver&quot;</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/rtl8189fs modules</span></span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; = &quot;RTL8723DS&quot; ]];then</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/rtl8723ds modules</span></span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; = &quot;RTL8821CS&quot; ]];then</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/rtl8821cs modules</span></span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; = &quot;RTL8822CS&quot; ]];then</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/rtl8822cs modules</span></span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; = &quot;RTL8852BS&quot; ]];then</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/rtl8852bs modules</span></span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; = &quot;RTL8852BE&quot; ]];then</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/rtl8852be modules</span></span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	echo &quot;building brcm_tools&quot;</span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">TARGET_CC -o <span class="variable">$RKWIFIBT</span>/tools/brcm_tools/brcm_patchram_plus1 <span class="variable">$RKWIFIBT</span>/tools/brcm_tools/brcm_patchram_plus1.c</span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">TARGET_CC -o <span class="variable">$RKWIFIBT</span>/tools/brcm_tools/dhd_priv <span class="variable">$RKWIFIBT</span>/tools/brcm_tools/dhd_priv.c</span></span><br><span class="line"></span><br><span class="line">	echo &quot;building rk_wifibt_init&quot;</span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">TARGET_CC -o <span class="variable">$RKWIFIBT</span>/src/rk_wifibt_init <span class="variable">$RKWIFIBT</span>/src/rk_wifi_init.c</span></span><br><span class="line"></span><br><span class="line">	echo &quot;building realtek_tools&quot;</span><br><span class="line">	make -C $RKWIFIBT/tools/rtk_hciattach/ CC=$TARGET_CC</span><br><span class="line"></span><br><span class="line">	echo &quot;building realtek bt drivers&quot;</span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/bluetooth_uart_driver</span></span><br><span class="line">	if [ -n &quot;$WIFI_USB&quot; ]; then</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">KMAKE M=<span class="variable">$RKWIFIBT</span>/drivers/bluetooth_usb_driver</span></span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [ &quot;$RK_CHIP&quot; = &quot;rv1126_rv1109&quot; ];then</span><br><span class="line">		echo &quot;target is rv1126_rv1109, skip $RKWIFIBT_APP&quot;</span><br><span class="line">	else</span><br><span class="line">		echo &quot;building rkwifibt-app&quot;</span><br><span class="line">		make -C $RKWIFIBT_APP CC=$BUILDROOT_GCC \</span><br><span class="line">			SYSROOT=$BUILDROOT_SYSROOT ARCH=$BUILDROOT_ARCH || true</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	echo &quot;chmod +x tools&quot;</span><br><span class="line">	chmod 755 $RKWIFIBT/tools/brcm_tools/brcm_patchram_plus1</span><br><span class="line">	chmod 755 $RKWIFIBT/tools/brcm_tools/dhd_priv</span><br><span class="line">	chmod 755 $RKWIFIBT/src/rk_wifibt_init</span><br><span class="line">	chmod 755 $RKWIFIBT/tools/rtk_hciattach/rtk_hciattach</span><br><span class="line"></span><br><span class="line">	echo &quot;mkdir rootfs dir&quot; $TARGET_ROOTFS_DIR</span><br><span class="line">	rm -rf $TARGET_ROOTFS_DIR/system/lib/modules/</span><br><span class="line">	rm -rf $TARGET_ROOTFS_DIR/system/etc/firmware/</span><br><span class="line">	rm -rf $TARGET_ROOTFS_DIR/vendor/</span><br><span class="line">	rm -rf $TARGET_ROOTFS_DIR/usr/lib/modules/</span><br><span class="line">	mkdir -p $TARGET_ROOTFS_DIR/usr/lib/modules/</span><br><span class="line">	mkdir -p $TARGET_ROOTFS_DIR/system/lib/modules/</span><br><span class="line">	mkdir -p $TARGET_ROOTFS_DIR/system/etc/firmware/</span><br><span class="line">	mkdir -p $TARGET_ROOTFS_DIR/lib/firmware/rtlbt/</span><br><span class="line"></span><br><span class="line">	echo &quot;create link system-&gt;vendor&quot;</span><br><span class="line">	cd $TARGET_ROOTFS_DIR/</span><br><span class="line">	rm -rf $TARGET_ROOTFS_DIR/vendor</span><br><span class="line">	ln -rsf system $TARGET_ROOTFS_DIR/vendor</span><br><span class="line">	cd -</span><br><span class="line"></span><br><span class="line">	echo &quot;copy tools/sh to rootfs&quot;</span><br><span class="line">	cp $RKWIFIBT/bin/$BUILDROOT_ARCH/* $TARGET_ROOTFS_DIR/usr/bin/</span><br><span class="line">	cp $RKWIFIBT/sh/wifi_start.sh $TARGET_ROOTFS_DIR/usr/bin/</span><br><span class="line">	cp $RKWIFIBT/sh/wifi_ap6xxx_rftest.sh $TARGET_ROOTFS_DIR/usr/bin/</span><br><span class="line">	cp $RKWIFIBT/conf/wpa_supplicant.conf $TARGET_ROOTFS_DIR/etc/</span><br><span class="line">	cp $RKWIFIBT/conf/dnsmasq.conf $TARGET_ROOTFS_DIR/etc/</span><br><span class="line">	cp $RKWIFIBT/tools/brcm_tools/dhd_priv $TARGET_ROOTFS_DIR/usr/bin/</span><br><span class="line">	cp $RKWIFIBT/tools/brcm_tools/brcm_patchram_plus1 $TARGET_ROOTFS_DIR/usr/bin/</span><br><span class="line">	cp $RKWIFIBT/src/rk_wifibt_init $TARGET_ROOTFS_DIR/usr/bin/</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; = &quot;ALL_CY&quot; ]];then</span><br><span class="line">		echo &quot;copy infineon/realtek firmware/nvram to rootfs&quot;</span><br><span class="line">		cp $RKWIFIBT/drivers/infineon/*.ko $TARGET_ROOTFS_DIR/system/lib/modules/ || true</span><br><span class="line">		cp $RKWIFIBT/firmware/infineon/*/* $TARGET_ROOTFS_DIR/system/etc/firmware/ || true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">todo rockchip</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash"><span class="built_in">cp</span> <span class="variable">$RKWIFIBT</span>/firmware/rockchip/* <span class="variable">$TARGET_ROOTFS_DIR</span>/system/etc/firmware/</span></span><br><span class="line">		cp $RKWIFIBT/sh/bt_load_broadcom_firmware $TARGET_ROOTFS_DIR/usr/bin/</span><br><span class="line">		cp $TARGET_ROOTFS_DIR/usr/bin/bt_load_broadcom_firmware $TARGET_ROOTFS_DIR/usr/bin/bt_init.sh</span><br><span class="line">		cp $TARGET_ROOTFS_DIR/usr/bin/bt_load_broadcom_firmware $TARGET_ROOTFS_DIR/usr/bin/bt_pcba_test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">reatek</span></span><br><span class="line">		cp $RKWIFIBT/firmware/realtek/*/* $TARGET_ROOTFS_DIR/lib/firmware/</span><br><span class="line">		cp $RKWIFIBT/firmware/realtek/*/* $TARGET_ROOTFS_DIR/lib/firmware/rtlbt/</span><br><span class="line">		cp $RKWIFIBT/tools/rtk_hciattach/rtk_hciattach $TARGET_ROOTFS_DIR/usr/bin/</span><br><span class="line">		cp $RKWIFIBT/drivers/bluetooth_uart_driver/hci_uart.ko $TARGET_ROOTFS_DIR/usr/lib/modules/</span><br><span class="line">		if [ -n &quot;$WIFI_USB&quot; ]; then</span><br><span class="line">			cp $RKWIFIBT/drivers/bluetooth_usb_driver/rtk_btusb.ko $TARGET_ROOTFS_DIR/usr/lib/modules/</span><br><span class="line">		fi</span><br><span class="line"></span><br><span class="line">		rm -rf $TARGET_ROOTFS_DIR/etc/init.d/S36load_wifi_modules</span><br><span class="line">		cp $RKWIFIBT/S36load_all_wifi_modules $TARGET_ROOTFS_DIR/etc/init.d/</span><br><span class="line">		sed -i &quot;s/BT_TTY_DEV/\/dev\/$&#123;BT_TTY_DEV&#125;/g&quot; $TARGET_ROOTFS_DIR/etc/init.d/S36load_all_wifi_modules</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; = &quot;ALL_AP&quot; ]];then</span><br><span class="line">		echo &quot;copy ap6xxx/realtek firmware/nvram to rootfs&quot;</span><br><span class="line">		cp $RKWIFIBT/drivers/bcmdhd/*.ko $TARGET_ROOTFS_DIR/system/lib/modules/</span><br><span class="line">		cp $RKWIFIBT/firmware/broadcom/*/wifi/* $TARGET_ROOTFS_DIR/system/etc/firmware/ || true</span><br><span class="line">		cp $RKWIFIBT/firmware/broadcom/*/bt/* $TARGET_ROOTFS_DIR/system/etc/firmware/ || true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">todo rockchip</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash"><span class="built_in">cp</span> <span class="variable">$RKWIFIBT</span>/firmware/rockchip/* <span class="variable">$TARGET_ROOTFS_DIR</span>/system/etc/firmware/</span></span><br><span class="line">		cp $RKWIFIBT/sh/bt_load_broadcom_firmware $TARGET_ROOTFS_DIR/usr/bin/</span><br><span class="line">		cp $TARGET_ROOTFS_DIR/usr/bin/bt_load_broadcom_firmware $TARGET_ROOTFS_DIR/usr/bin/bt_init.sh</span><br><span class="line">		cp $TARGET_ROOTFS_DIR/usr/bin/bt_load_broadcom_firmware $TARGET_ROOTFS_DIR/usr/bin/bt_pcba_test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">reatek</span></span><br><span class="line">		cp -rf $RKWIFIBT/firmware/realtek/*/* $TARGET_ROOTFS_DIR/lib/firmware/</span><br><span class="line">		cp -rf $RKWIFIBT/firmware/realtek/*/* $TARGET_ROOTFS_DIR/lib/firmware/rtlbt/</span><br><span class="line">		cp $RKWIFIBT/tools/rtk_hciattach/rtk_hciattach $TARGET_ROOTFS_DIR/usr/bin/</span><br><span class="line">		cp $RKWIFIBT/drivers/bluetooth_uart_driver/hci_uart.ko $TARGET_ROOTFS_DIR/usr/lib/modules/</span><br><span class="line">		if [ -n &quot;$WIFI_USB&quot; ]; then</span><br><span class="line">			cp $RKWIFIBT/drivers/bluetooth_usb_driver/rtk_btusb.ko $TARGET_ROOTFS_DIR/usr/lib/modules/</span><br><span class="line">		fi</span><br><span class="line"></span><br><span class="line">		rm -rf $TARGET_ROOTFS_DIR/etc/init.d/S36load_wifi_modules</span><br><span class="line">		cp $RKWIFIBT/S36load_all_wifi_modules $TARGET_ROOTFS_DIR/etc/init.d/</span><br><span class="line">		sed -i &quot;s/BT_TTY_DEV/\/dev\/$&#123;BT_TTY_DEV&#125;/g&quot; $TARGET_ROOTFS_DIR/etc/init.d/S36load_all_wifi_modules</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; =~ &quot;RTL&quot; ]];then</span><br><span class="line">		echo &quot;Copy RTL file to rootfs&quot;</span><br><span class="line">		if [ -d &quot;$RKWIFIBT/firmware/realtek/$WIFI_CHIP&quot; ]; then</span><br><span class="line">			cp $RKWIFIBT/firmware/realtek/$WIFI_CHIP/* $TARGET_ROOTFS_DIR/lib/firmware/rtlbt/</span><br><span class="line">			cp $RKWIFIBT/firmware/realtek/$WIFI_CHIP/* $TARGET_ROOTFS_DIR/lib/firmware/</span><br><span class="line">		else</span><br><span class="line">			echo &quot;INFO: $WIFI_CHIP isn&#x27;t bluetooth?&quot;</span><br><span class="line">		fi</span><br><span class="line"></span><br><span class="line">		WIFI_KO_DIR=$(echo $WIFI_CHIP | tr &#x27;[A-Z]&#x27; &#x27;[a-z]&#x27;)</span><br><span class="line"></span><br><span class="line">		cp $RKWIFIBT/drivers/$WIFI_KO_DIR/*.ko $TARGET_ROOTFS_DIR/system/lib/modules/</span><br><span class="line"></span><br><span class="line">		cp $RKWIFIBT/sh/bt_load_rtk_firmware $TARGET_ROOTFS_DIR/usr/bin/</span><br><span class="line">		sed -i &quot;s/BT_TTY_DEV/\/dev\/$&#123;BT_TTY_DEV&#125;/g&quot; $TARGET_ROOTFS_DIR/usr/bin/bt_load_rtk_firmware</span><br><span class="line">		if [ -n &quot;$WIFI_USB&quot; ]; then</span><br><span class="line">			cp $RKWIFIBT/drivers/bluetooth_usb_driver/rtk_btusb.ko $TARGET_ROOTFS_DIR/usr/lib/modules/</span><br><span class="line">			sed -i &quot;s/BT_DRV/rtk_btusb/g&quot; $TARGET_ROOTFS_DIR/usr/bin/bt_load_rtk_firmware</span><br><span class="line">		else</span><br><span class="line">			cp $RKWIFIBT/drivers/bluetooth_uart_driver/hci_uart.ko $TARGET_ROOTFS_DIR/usr/lib/modules/</span><br><span class="line">			sed -i &quot;s/BT_DRV/hci_uart/g&quot; $TARGET_ROOTFS_DIR/usr/bin/bt_load_rtk_firmware</span><br><span class="line">		fi</span><br><span class="line">		cp $TARGET_ROOTFS_DIR/usr/bin/bt_load_rtk_firmware $TARGET_ROOTFS_DIR/usr/bin/bt_init.sh</span><br><span class="line">		cp $TARGET_ROOTFS_DIR/usr/bin/bt_load_rtk_firmware $TARGET_ROOTFS_DIR/usr/bin/bt_pcba_test</span><br><span class="line">		cp $RKWIFIBT/tools/rtk_hciattach/rtk_hciattach $TARGET_ROOTFS_DIR/usr/bin/</span><br><span class="line">		rm -rf $TARGET_ROOTFS_DIR/etc/init.d/S36load_all_wifi_modules</span><br><span class="line">		cp $RKWIFIBT/S36load_wifi_modules $TARGET_ROOTFS_DIR/etc/init.d/</span><br><span class="line">		sed -i &quot;s/WIFI_KO/\/system\/lib\/modules\/$WIFI_CHIP.ko/g&quot; $TARGET_ROOTFS_DIR/etc/init.d/S36load_wifi_modules</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; =~ &quot;CYW&quot; ]];then</span><br><span class="line">		echo &quot;Copy CYW file to rootfs&quot;</span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">tools</span></span><br><span class="line">		cp $RKWIFIBT/tools/brcm_tools/dhd_priv $TARGET_ROOTFS_DIR/usr/bin/</span><br><span class="line">		cp $RKWIFIBT/tools/brcm_tools/brcm_patchram_plus1 $TARGET_ROOTFS_DIR/usr/bin/</span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">firmware</span></span><br><span class="line">		cp $RKWIFIBT/firmware/infineon/$WIFI_CHIP/* $TARGET_ROOTFS_DIR/system/etc/firmware/</span><br><span class="line">		cp $RKWIFIBT/drivers/infineon/*.ko $TARGET_ROOTFS_DIR/system/lib/modules/</span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">bt</span></span><br><span class="line">		cp $RKWIFIBT/sh/bt_load_broadcom_firmware $TARGET_ROOTFS_DIR/usr/bin/</span><br><span class="line">		sed -i &quot;s/BT_TTY_DEV/\/dev\/$&#123;BT_TTY_DEV&#125;/g&quot; $TARGET_ROOTFS_DIR/usr/bin/bt_load_broadcom_firmware</span><br><span class="line">		sed -i &quot;s/BTFIRMWARE_PATH/\/system\/etc\/firmware\//g&quot; $TARGET_ROOTFS_DIR/usr/bin/bt_load_broadcom_firmware</span><br><span class="line">		cp $TARGET_ROOTFS_DIR/usr/bin/bt_load_broadcom_firmware $TARGET_ROOTFS_DIR/usr/bin/bt_init.sh</span><br><span class="line">		cp $TARGET_ROOTFS_DIR/usr/bin/bt_load_broadcom_firmware $TARGET_ROOTFS_DIR/usr/bin/bt_pcba_test</span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">wifi</span></span><br><span class="line">		rm -rf $TARGET_ROOTFS_DIR/etc/init.d/S36load_all_wifi_modules</span><br><span class="line">		cp $RKWIFIBT/S36load_wifi_modules $TARGET_ROOTFS_DIR/etc/init.d/</span><br><span class="line">		sed -i &quot;s/WIFI_KO/\/system\/lib\/modules\/$WIFI_CHIP.ko/g&quot; $TARGET_ROOTFS_DIR/etc/init.d/S36load_wifi_modules</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [[ &quot;$WIFI_CHIP&quot; =~ &quot;AP6&quot; ]];then</span><br><span class="line">		echo &quot;Copy AP file to rootfs&quot;</span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">tools</span></span><br><span class="line">		cp $RKWIFIBT/tools/brcm_tools/dhd_priv $TARGET_ROOTFS_DIR/usr/bin/</span><br><span class="line">		cp $RKWIFIBT/tools/brcm_tools/brcm_patchram_plus1 $TARGET_ROOTFS_DIR/usr/bin/</span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">firmware</span></span><br><span class="line">		cp $RKWIFIBT/firmware/broadcom/$WIFI_CHIP/wifi/* $TARGET_ROOTFS_DIR/system/etc/firmware/</span><br><span class="line">		cp $RKWIFIBT/firmware/broadcom/$WIFI_CHIP/bt/* $TARGET_ROOTFS_DIR/system/etc/firmware/</span><br><span class="line">		cp $RKWIFIBT/drivers/bcmdhd/*.ko $TARGET_ROOTFS_DIR/system/lib/modules/</span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">bt</span></span><br><span class="line">		cp $RKWIFIBT/sh/bt_load_broadcom_firmware $TARGET_ROOTFS_DIR/usr/bin/</span><br><span class="line">		sed -i &quot;s/BT_TTY_DEV/\/dev\/$&#123;BT_TTY_DEV&#125;/g&quot; $TARGET_ROOTFS_DIR/usr/bin/bt_load_broadcom_firmware</span><br><span class="line">		sed -i &quot;s/BTFIRMWARE_PATH/\/system\/etc\/firmware\//g&quot; $TARGET_ROOTFS_DIR/usr/bin/bt_load_broadcom_firmware</span><br><span class="line">		cp $TARGET_ROOTFS_DIR/usr/bin/bt_load_broadcom_firmware $TARGET_ROOTFS_DIR/usr/bin/bt_init.sh</span><br><span class="line">		cp $TARGET_ROOTFS_DIR/usr/bin/bt_load_broadcom_firmware $TARGET_ROOTFS_DIR/usr/bin/bt_pcba_test</span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">wifi</span></span><br><span class="line">		rm -rf $TARGET_ROOTFS_DIR/etc/init.d/S36load_all_wifi_modules</span><br><span class="line">		cp $RKWIFIBT/S36load_wifi_modules $TARGET_ROOTFS_DIR/etc/init.d/</span><br><span class="line">		if [[ &quot;$WIFI_CHIP&quot; =~ &quot;AP&quot; ]];then</span><br><span class="line">			sed -i &quot;s/WIFI_KO/\/system\/lib\/modules\/bcmdhd.ko/g&quot; $TARGET_ROOTFS_DIR/etc/init.d/S36load_wifi_modules</span><br><span class="line">		else</span><br><span class="line">			sed -i &quot;s/WIFI_KO/\/system\/lib\/modules\/bcmdhd_pcie.ko/g&quot; $TARGET_ROOTFS_DIR/etc/init.d/S36load_wifi_modules</span><br><span class="line">		fi</span><br><span class="line">	fi</span><br><span class="line">	finish_build</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash"><span class="built_in">exit</span> 0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建内核模块</span></span><br><span class="line">build_modules()</span><br><span class="line">&#123;</span><br><span class="line">	check_config RK_KERNEL_DEFCONFIG || return 0</span><br><span class="line"></span><br><span class="line">	echo &quot;============Start building kernel modules============&quot;</span><br><span class="line">	echo &quot;TARGET_KERNEL_ARCH   =$RK_KERNEL_ARCH&quot;</span><br><span class="line">	echo &quot;TARGET_KERNEL_CONFIG =$RK_KERNEL_DEFCONFIG&quot;</span><br><span class="line">	echo &quot;TARGET_KERNEL_CONFIG_FRAGMENT =$RK_KERNEL_DEFCONFIG_FRAGMENT&quot;</span><br><span class="line">	echo &quot;==================================================&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">设置交叉编译工具链</span></span><br><span class="line">	setup_cross_compile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">使用指定的内核配置和片段进行构建</span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">KMAKE <span class="variable">$RK_KERNEL_DEFCONFIG</span> <span class="variable">$RK_KERNEL_DEFCONFIG_FRAGMENT</span></span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">KMAKE modules</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">完成构建</span></span><br><span class="line">	finish_build</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建 Buildroot 根文件系统</span></span><br><span class="line">build_buildroot()</span><br><span class="line">&#123;</span><br><span class="line">	check_config RK_CFG_BUILDROOT || return 0</span><br><span class="line"></span><br><span class="line">	ROOTFS_DIR=$1</span><br><span class="line"></span><br><span class="line">	echo &quot;==========Start building buildroot rootfs ==========&quot;</span><br><span class="line">	echo &quot;TARGET_BUILDROOT_CONFIG=$RK_CFG_BUILDROOT&quot;</span><br><span class="line">	echo &quot;=========================================&quot;</span><br><span class="line"></span><br><span class="line">	DST_DIR=.buildroot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">使用 mk-buildroot.sh 脚本构建 Buildroot 根文件系统</span></span><br><span class="line">	/usr/bin/time -f &quot;you take %E to build buildroot&quot; \</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">COMMON_DIR/mk-buildroot.sh <span class="variable">$RK_CFG_BUILDROOT</span> <span class="variable">$DST_DIR</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">删除旧的根文件系统目录并创建新的符号链接</span></span><br><span class="line">	rm -rf $ROOTFS_DIR</span><br><span class="line">	ln -rsf $DST_DIR $ROOTFS_DIR</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">完成构建</span></span><br><span class="line">	finish_build</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kernel_version()</span><br><span class="line">&#123;</span><br><span class="line">	[ -d &quot;$1&quot; ] || return 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">定义内核版本号的关键字</span></span><br><span class="line">	VERSION_KEYS=&quot;VERSION PATCHLEVEL&quot;</span><br><span class="line">	VERSION=&quot;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">遍历关键字，获取内核版本号的各个部分</span></span><br><span class="line">	for k in $VERSION_KEYS; do</span><br><span class="line">		v=$(grep &quot;^$k = &quot; $1/Makefile | cut -d&#x27; &#x27; -f3)</span><br><span class="line">		VERSION=$&#123;VERSION:+$&#123;VERSION&#125;.&#125;$v</span><br><span class="line">	done</span><br><span class="line">	echo $VERSION</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建 Yocto rootfs</span></span><br><span class="line">build_yocto()</span><br><span class="line">&#123;</span><br><span class="line">	check_config RK_YOCTO_MACHINE || return 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">开始构建 Yocto rootfs</span></span><br><span class="line">	echo &quot;=========开始构建 Yocto rootfs=========&quot;</span><br><span class="line">	echo &quot;目标机器：$RK_YOCTO_MACHINE&quot;</span><br><span class="line">	echo &quot;=====================================&quot;</span><br><span class="line"></span><br><span class="line">	KERNEL_VERSION=$(kernel_version kernel/)</span><br><span class="line"></span><br><span class="line">	cd yocto</span><br><span class="line">	ln -rsf $RK_YOCTO_MACHINE.conf build/conf/local.conf</span><br><span class="line">	source oe-init-build-env</span><br><span class="line">	LANG=en_US.UTF-8 LANGUAGE=en_US.en LC_ALL=en_US.UTF-8 \</span><br><span class="line">		bitbake core-image-minimal -r conf/include/rksdk.conf \</span><br><span class="line">		-r conf/include/kernel-$KERNEL_VERSION.conf</span><br><span class="line"></span><br><span class="line">	finish_build</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建 debian rootfs</span></span><br><span class="line">build_debian()</span><br><span class="line">&#123;</span><br><span class="line">	ARCH=$&#123;RK_DEBIAN_ARCH:-$&#123;RK_KERNEL_ARCH&#125;&#125;</span><br><span class="line">	case $ARCH in</span><br><span class="line">		arm|armhf) ARCH=armhf ;;</span><br><span class="line">		*) ARCH=arm64 ;;</span><br><span class="line">	esac</span><br><span class="line"></span><br><span class="line">	echo &quot;=========开始构建 Debian ($ARCH) 根文件系统=========&quot;</span><br><span class="line"></span><br><span class="line">	cd debian</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">检查是否存在 linaro 版本的 Debian 根文件系统压缩包，如果不存在则执行 mk-base-debian.sh 脚本构建</span></span><br><span class="line">	if [ ! -f linaro-$RK_DEBIAN_VERSION-alip-*.tar.gz ]; then</span><br><span class="line">		RELEASE=$RK_DEBIAN_VERSION TARGET=desktop ARCH=$ARCH ./mk-base-debian.sh</span><br><span class="line">		ln -rsf linaro-$RK_DEBIAN_VERSION-alip-*.tar.gz linaro-$RK_DEBIAN_VERSION-$ARCH.tar.gz</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	VERSION=debug ARCH=$ARCH ./mk-rootfs-$RK_DEBIAN_VERSION.sh</span><br><span class="line">	./mk-image.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">完成构建</span></span><br><span class="line">	finish_build</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译文件系统</span></span><br><span class="line">build_rootfs()</span><br><span class="line">&#123;</span><br><span class="line">	check_config RK_ROOTFS_TYPE || return 0</span><br><span class="line"></span><br><span class="line">	ROOTFS=$&#123;1:-$&#123;RK_ROOTFS_SYSTEM:-buildroot&#125;&#125;</span><br><span class="line">	ROOTFS_IMG=rootfs.$&#123;RK_ROOTFS_TYPE&#125;</span><br><span class="line">	ROOTFS_DIR=.rootfs</span><br><span class="line"></span><br><span class="line">	echo &quot;==========开始构建根文件系统($ROOTFS)，输出到$ROOTFS_DIR==========&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">删除旧的根文件系统目录并创建新的目录</span></span><br><span class="line">	rm -rf $ROOTFS_DIR</span><br><span class="line">	mkdir -p $ROOTFS_DIR</span><br><span class="line"></span><br><span class="line">	case &quot;$ROOTFS&quot; in</span><br><span class="line">		yocto)</span><br><span class="line">			build_yocto</span><br><span class="line">			ln -rsf yocto/build/latest/rootfs.img \</span><br><span class="line">				$ROOTFS_DIR/rootfs.ext4</span><br><span class="line">			;;</span><br><span class="line">		debian)</span><br><span class="line">			build_debian</span><br><span class="line">			ln -rsf debian/linaro-rootfs.img \</span><br><span class="line">				$ROOTFS_DIR/rootfs.ext4</span><br><span class="line">			;;</span><br><span class="line">		buildroot)</span><br><span class="line">			build_buildroot $ROOTFS_DIR</span><br><span class="line">			build_wifibt</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">			# </span><span class="language-bash">为 wifibt 重新编译</span></span><br><span class="line">			build_buildroot $ROOTFS_DIR</span><br><span class="line">			;;</span><br><span class="line">		*)</span><br><span class="line">			echo &quot;$ROOTFS 不支持！&quot;</span><br><span class="line">			exit 1</span><br><span class="line">			;;</span><br><span class="line">	esac</span><br><span class="line"></span><br><span class="line">	if [ ! -f &quot;$ROOTFS_DIR/$ROOTFS_IMG&quot; ]; then</span><br><span class="line">		echo &quot;未生成 $ROOTFS_IMG...&quot;</span><br><span class="line">		exit 1</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	ln -rsf $ROOTFS_DIR/$ROOTFS_IMG rockdev/rootfs.img</span><br><span class="line"></span><br><span class="line">	[ ! -f $ROOTFS_DIR/oem.img ] || ln -rsf $ROOTFS_DIR/oem.img rockdev/</span><br><span class="line"></span><br><span class="line">	if [ &quot;$RK_RAMBOOT&quot; ]; then</span><br><span class="line">		/usr/bin/time -f &quot;you take %E to pack ramboot image&quot; \</span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash">COMMON_DIR/mk-ramdisk.sh rockdev/rootfs.img \</span></span><br><span class="line"><span class="language-bash">			<span class="variable">$ROOTFS_DIR</span>/ramboot.img</span></span><br><span class="line">		ln -rsf $ROOTFS_DIR/ramboot.img rockdev/boot.img</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">用于安全性</span></span><br><span class="line">		cp rockdev/boot.img u-boot/</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [ &quot;$RK_RAMDISK_SECURITY_BOOTUP&quot; = &quot;true&quot; ]; then</span><br><span class="line">		echo &quot;尝试为 $RK_SYSTEM_CHECK_METHOD 构建 init&quot;</span><br><span class="line"></span><br><span class="line">		if [ &quot;$RK_SYSTEM_CHECK_METHOD&quot; = &quot;DM-V&quot; ]; then</span><br><span class="line">			SYSTEM_IMG=rootfs.squashfs</span><br><span class="line">		else</span><br><span class="line">			SYSTEM_IMG=$ROOTFS_IMG</span><br><span class="line">		fi</span><br><span class="line">		if [ ! -f &quot;$ROOTFS_DIR/$SYSTEM_IMG&quot; ]; then</span><br><span class="line">			echo &quot;未生成 $SYSTEM_IMG...&quot;</span><br><span class="line">			exit -1</span><br><span class="line">		fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">COMMON_DIR/mk-dm.sh <span class="variable">$RK_SYSTEM_CHECK_METHOD</span> \</span></span><br><span class="line"><span class="language-bash">			<span class="variable">$ROOTFS_DIR</span>/<span class="variable">$SYSTEM_IMG</span></span></span><br><span class="line">		ln -rsf $ROOTFS_DIR/security-system.img rockdev/rootfs.img</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">完成构建</span></span><br><span class="line">	finish_build</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build_recovery()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">检查是否启用了主备份(A/B)模式的SD卡更新</span></span><br><span class="line">	if [ &quot;$RK_UPDATE_SDCARD_ENABLE_FOR_AB&quot; = &quot;true&quot; ] ;then</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">如果是启用了主备份(A/B)模式的SD卡更新，则使用相应的恢复配置</span></span><br><span class="line">		RK_CFG_RECOVERY=$RK_UPDATE_SDCARD_CFG_RECOVERY</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">检查是否存在主备份(A/B)模式的包文件</span></span><br><span class="line">	if [ ! -z &quot;$RK_PACKAGE_FILE_AB&quot; ]; then</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">如果存在主备份(A/B)模式的包文件，则直接返回，不进行构建</span></span><br><span class="line">		return 0</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">检查恢复配置是否已配置</span></span><br><span class="line">	check_config RK_CFG_RECOVERY || return 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">打印构建恢复镜像的提示信息</span></span><br><span class="line">	echo &quot;==========开始构建恢复镜像(buildroot)==========&quot;</span><br><span class="line">	echo &quot;TARGET_RECOVERY_CONFIG=$RK_CFG_RECOVERY&quot;</span><br><span class="line">	echo &quot;========================================&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">设置目标目录</span></span><br><span class="line">	DST_DIR=.recovery</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">构建恢复镜像(buildroot)</span></span><br><span class="line">	/usr/bin/time -f &quot;用时 %E 构建恢复镜像(buildroot)&quot; \</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">COMMON_DIR/mk-buildroot.sh <span class="variable">$RK_CFG_RECOVERY</span> <span class="variable">$DST_DIR</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">打包恢复镜像</span></span><br><span class="line">	/usr/bin/time -f &quot;用时 %E 打包恢复镜像&quot; \</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">COMMON_DIR/mk-ramdisk.sh <span class="variable">$DST_DIR</span>/rootfs.cpio.gz \</span></span><br><span class="line"><span class="language-bash">		<span class="variable">$DST_DIR</span>/recovery.img \</span></span><br><span class="line"><span class="language-bash">		<span class="string">&quot;<span class="variable">$CHIP_DIR</span>/<span class="variable">$RK_RECOVERY_FIT_ITS</span>&quot;</span></span></span><br><span class="line">	ln -rsf $DST_DIR/recovery.img rockdev/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">为了安全起见，将恢复镜像复制到u-boot目录</span></span><br><span class="line">	cp rockdev/recovery.img u-boot/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">完成构建</span></span><br><span class="line">	finish_build</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建PCBA</span></span><br><span class="line">build_pcba()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">检查PCBA配置是否已配置</span></span><br><span class="line">	check_config RK_CFG_PCBA || return 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">打印构建PCBA镜像的提示信息</span></span><br><span class="line">	echo &quot;==========开始构建PCBA镜像(buildroot)==========&quot;</span><br><span class="line">	echo &quot;TARGET_PCBA_CONFIG=$RK_CFG_PCBA&quot;</span><br><span class="line">	echo &quot;====================================&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">设置目标目录</span></span><br><span class="line">	DST_DIR=.pcba</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">构建PCBA镜像(buildroot)</span></span><br><span class="line">	/usr/bin/time -f &quot;用时 %E 构建PCBA镜像(buildroot)&quot; \</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">COMMON_DIR/mk-buildroot.sh <span class="variable">$RK_CFG_PCBA</span> <span class="variable">$DST_DIR</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">打包PCBA镜像</span></span><br><span class="line">	/usr/bin/time -f &quot;用时 %E 打包PCBA镜像&quot; \</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">COMMON_DIR/mk-ramdisk.sh <span class="variable">$DST_DIR</span>/rootfs.cpio.gz \</span></span><br><span class="line"><span class="language-bash">		<span class="variable">$DST_DIR</span>/pcba.img</span></span><br><span class="line">	ln -rsf $DST_DIR/pcba.img rockdev/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">完成构建</span></span><br><span class="line">	finish_build</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOT_FIXED_CONFIGS=&quot;</span><br><span class="line">	CONFIG_BLK_DEV_DM                # 启用设备映射（Device Mapper）</span><br><span class="line">	CONFIG_DM_CRYPT                  # 启用设备映射加密模块</span><br><span class="line">	CONFIG_BLK_DEV_CRYPTOLOOP        # 启用块设备加密循环设备</span><br><span class="line">	CONFIG_DM_VERITY                 # 启用设备映射完整性校验模块&quot;</span><br><span class="line"></span><br><span class="line">BOOT_OPTEE_FIXED_CONFIGS=&quot;</span><br><span class="line">	CONFIG_TEE                       # 启用可信执行环境（Trusted Execution Environment）</span><br><span class="line">	CONFIG_OPTEE                     # 启用OP-TEE（Open Portable Trusted Execution Environment）&quot;</span><br><span class="line"></span><br><span class="line">UBOOT_FIXED_CONFIGS=&quot;</span><br><span class="line">	CONFIG_FIT_SIGNATURE             # 启用FIT（Flattened Image Tree）签名支持</span><br><span class="line">	CONFIG_SPL_FIT_SIGNATURE         # 启用SPL（Secondary Program Loader）FIT签名支持&quot;</span><br><span class="line"></span><br><span class="line">UBOOT_AB_FIXED_CONFIGS=&quot;</span><br><span class="line">	CONFIG_ANDROID_AB                # 启用Android A/B分区支持&quot;</span><br><span class="line"></span><br><span class="line">ROOTFS_UPDATE_ENGINEBIN_CONFIGS=&quot;</span><br><span class="line">	BR2_PACKAGE_RECOVERY             # 启用恢复系统包</span><br><span class="line">	BR2_PACKAGE_RECOVERY_UPDATEENGINEBIN&quot;  # 启用恢复系统更新引擎二进制文件</span><br><span class="line"></span><br><span class="line">ROOTFS_AB_FIXED_CONFIGS=&quot;</span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">ROOTFS_UPDATE_ENGINEBIN_CONFIGS     <span class="comment"># 包括ROOTFS_UPDATE_ENGINEBIN_CONFIGS中的配置</span></span></span><br><span class="line">	BR2_PACKAGE_RECOVERY_BOOTCONTROL&quot;    # 启用恢复系统引导控制</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查默认配置</span></span><br><span class="line">defconfig_check()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">1. defconfig 2. fixed config</span></span><br><span class="line">	echo debug-$1   # 调试输出，显示传入的参数1</span><br><span class="line">	for i in $2   # 遍历参数2中的每个配置选项</span><br><span class="line">	do</span><br><span class="line">		echo &quot;查找 $i&quot;   # 输出正在查找的配置选项</span><br><span class="line">		result=$(cat $1 | grep &quot;$&#123;i&#125;=y&quot; -w || echo &quot;未找到&quot;)   # 在配置文件中查找配置选项，将结果存储在变量result中</span><br><span class="line">		if [ &quot;$result&quot; = &quot;未找到&quot; ]; then   # 如果未找到配置选项</span><br><span class="line">			echo -e &quot;\e[41;1;37m错误：在 $1 中未找到配置项 $&#123;i&#125; \e[0m&quot;   # 输出错误信息，配置项未找到</span><br><span class="line">			echo &quot;请确保您的配置文件包含以下列表中的选项&quot;</span><br><span class="line">			echo &quot;---------------------------------------&quot;</span><br><span class="line">			echo &quot;$2&quot;   # 输出参数2中的配置选项列表</span><br><span class="line">			echo &quot;---------------------------------------&quot;</span><br><span class="line">			return -1;   # 返回-1表示检查失败</span><br><span class="line">		fi</span><br><span class="line">	done</span><br><span class="line">	return 0   # 返回0表示检查通过</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从默认配置文件中查找字符串</span></span><br><span class="line">find_string_in_config()</span><br><span class="line">&#123;</span><br><span class="line">	result=$(cat &quot;$2&quot; | grep &quot;$1&quot; || echo &quot;No found&quot;)   # 在文件$2中查找字符串$1，将结果存储在变量result中</span><br><span class="line">	if [ &quot;$result&quot; = &quot;No found&quot; ]; then   # 如果未找到字符串</span><br><span class="line">		echo &quot;Security: No found string $1 in $2&quot;   # 输出错误信息，未找到字符串</span><br><span class="line">		return -1;   # 返回-1表示未找到</span><br><span class="line">	fi</span><br><span class="line">	return 0;   # 返回0表示找到了字符串</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_security_condition()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">check security enabled</span></span><br><span class="line">	test -z &quot;$RK_SYSTEM_CHECK_METHOD&quot; &amp;&amp; return 0</span><br><span class="line"></span><br><span class="line">	if [ ! -d u-boot/keys ]; then</span><br><span class="line">		echo &quot;ERROR: No root keys(u-boot/keys) found in u-boot&quot;</span><br><span class="line">		echo &quot;       Create it by ./build.sh createkeys or move your key to it&quot;</span><br><span class="line">		return -1</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [ &quot;$RK_SYSTEM_CHECK_METHOD&quot; = &quot;DM-E&quot; ]; then</span><br><span class="line">		if [ ! -f u-boot/keys/root_passwd ]; then</span><br><span class="line">			echo &quot;ERROR: No root passwd(u-boot/keys/root_passwd) found in u-boot&quot;</span><br><span class="line">			echo &quot;       echo your root key for sudo to u-boot/keys/root_passwd&quot;</span><br><span class="line">			echo &quot;       some operations need supper user permission when create encrypt image&quot;</span><br><span class="line">			return -1</span><br><span class="line">		fi</span><br><span class="line"></span><br><span class="line">		if [ ! -f u-boot/keys/system_enc_key ]; then</span><br><span class="line">			echo &quot;ERROR: No enc key(u-boot/keys/system_enc_key) found in u-boot&quot;</span><br><span class="line">			echo &quot;       Create it by ./build.sh createkeys or move your key to it&quot;</span><br><span class="line">			return -1</span><br><span class="line">		fi</span><br><span class="line"></span><br><span class="line">		BOOT_FIXED_CONFIGS=&quot;$&#123;BOOT_FIXED_CONFIGS&#125;</span><br><span class="line">				    $&#123;BOOT_OPTEE_FIXED_CONFIGS&#125;&quot;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	echo &quot;check kernel defconfig&quot;</span><br><span class="line">	defconfig_check \</span><br><span class="line"><span class="meta prompt_">		kernel/arch/$</span><span class="language-bash">RK_KERNEL_ARCH/configs/<span class="variable">$RK_KERNEL_DEFCONFIG</span> \</span></span><br><span class="line"><span class="language-bash">		<span class="string">&quot;<span class="variable">$BOOT_FIXED_CONFIGS</span>&quot;</span></span></span><br><span class="line"></span><br><span class="line">	if [ ! -z &quot;$&#123;RK_PACKAGE_FILE_AB&#125;&quot; ]; then</span><br><span class="line">		UBOOT_FIXED_CONFIGS=&quot;$&#123;UBOOT_FIXED_CONFIGS&#125;</span><br><span class="line">				     $&#123;UBOOT_AB_FIXED_CONFIGS&#125;&quot;</span><br><span class="line"></span><br><span class="line">		defconfig_check buildroot/configs/$&#123;RK_CFG_BUILDROOT&#125;_defconfig &quot;$ROOTFS_AB_FIXED_CONFIGS&quot;</span><br><span class="line">	fi</span><br><span class="line">	echo &quot;check uboot defconfig&quot;</span><br><span class="line">	defconfig_check u-boot/configs/$&#123;RK_UBOOT_DEFCONFIG&#125;_defconfig &quot;$UBOOT_FIXED_CONFIGS&quot;</span><br><span class="line"></span><br><span class="line">	if [ &quot;$RK_SYSTEM_CHECK_METHOD&quot; = &quot;DM-E&quot; ]; then</span><br><span class="line">		echo &quot;check ramdisk defconfig&quot;</span><br><span class="line">		defconfig_check buildroot/configs/$&#123;RK_CFG_BUILDROOT&#125;_defconfig &quot;$ROOTFS_UPDATE_ENGINEBIN_CONFIGS&quot;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	echo &quot;check rootfs defconfig&quot;</span><br><span class="line">	find_string_in_config &quot;BR2_ROOTFS_OVERLAY=\&quot;.*board/rockchip/common/security-system-overlay.*&quot; &quot;buildroot/configs/$&#123;RK_CFG_BUILDROOT&#125;_defconfig&quot;</span><br><span class="line"></span><br><span class="line">	echo &quot;Security: finish check&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">check_security_condition函数用于检查安全条件</span></span><br><span class="line">check_security_condition()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">检查是否启用了安全选项，如果未启用则直接返回0</span></span><br><span class="line">	test -z &quot;$RK_SYSTEM_CHECK_METHOD&quot; &amp;&amp; return 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">检查是否存在u-boot/keys目录，如果不存在则输出错误信息并返回-1</span></span><br><span class="line">	if [ ! -d u-boot/keys ]; then</span><br><span class="line">		echo &quot;错误：在u-boot中未找到根密钥（u-boot/keys）&quot;</span><br><span class="line">		echo &quot;      请通过./build.sh createkeys创建或将您的密钥移动到该目录中&quot;</span><br><span class="line">		return -1</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果RK_SYSTEM_CHECK_METHOD的值为DM-E，则继续进行下一步检查</span></span><br><span class="line">	if [ &quot;$RK_SYSTEM_CHECK_METHOD&quot; = &quot;DM-E&quot; ]; then</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">检查是否存在u-boot/keys/root_passwd文件，如果不存在则输出错误信息并返回-1</span></span><br><span class="line">		if [ ! -f u-boot/keys/root_passwd ]; then</span><br><span class="line">			echo &quot;错误：在u-boot中未找到根口令（u-boot/keys/root_passwd）&quot;</span><br><span class="line">			echo &quot;      请将您的根密钥（用于sudo）echo到u-boot/keys/root_passwd中&quot;</span><br><span class="line">			echo &quot;      创建加密镜像时某些操作需要超级用户权限&quot;</span><br><span class="line">			return -1</span><br><span class="line">		fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">检查是否存在u-boot/keys/system_enc_key文件，如果不存在则输出错误信息并返回-1</span></span><br><span class="line">		if [ ! -f u-boot/keys/system_enc_key ]; then</span><br><span class="line">			echo &quot;错误：在u-boot中未找到加密密钥（u-boot/keys/system_enc_key）&quot;</span><br><span class="line">			echo &quot;      请通过./build.sh createkeys创建或将您的密钥移动到该目录中&quot;</span><br><span class="line">			return -1</span><br><span class="line">		fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">将BOOT_OPTEE_FIXED_CONFIGS添加到BOOT_FIXED_CONFIGS变量中</span></span><br><span class="line">		BOOT_FIXED_CONFIGS=&quot;$&#123;BOOT_FIXED_CONFIGS&#125;</span><br><span class="line">				    $&#123;BOOT_OPTEE_FIXED_CONFIGS&#125;&quot;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	echo &quot;检查内核配置&quot;</span><br><span class="line">	defconfig_check \</span><br><span class="line"><span class="meta prompt_">		kernel/arch/$</span><span class="language-bash">RK_KERNEL_ARCH/configs/<span class="variable">$RK_KERNEL_DEFCONFIG</span> \</span></span><br><span class="line"><span class="language-bash">		<span class="string">&quot;<span class="variable">$BOOT_FIXED_CONFIGS</span>&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果RK_PACKAGE_FILE_AB不为空，则进行下一步检查</span></span><br><span class="line">	if [ ! -z &quot;$&#123;RK_PACKAGE_FILE_AB&#125;&quot; ]; then</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">将UBOOT_AB_FIXED_CONFIGS添加到UBOOT_FIXED_CONFIGS变量中</span></span><br><span class="line">		UBOOT_FIXED_CONFIGS=&quot;$&#123;UBOOT_FIXED_CONFIGS&#125;</span><br><span class="line">				     $&#123;UBOOT_AB_FIXED_CONFIGS&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">检查buildroot/configs/<span class="variable">$&#123;RK_CFG_BUILDROOT&#125;</span>_defconfig文件是否存在</span></span><br><span class="line">		defconfig_check buildroot/configs/$&#123;RK_CFG_BUILDROOT&#125;_defconfig &quot;$ROOTFS_AB_FIXED_CONFIGS&quot;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	echo &quot;检查uboot配置&quot;</span><br><span class="line">	defconfig_check u-boot/configs/$&#123;RK_UBOOT_DEFCONFIG&#125;_defconfig &quot;$UBOOT_FIXED_CONFIGS&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果RK_SYSTEM_CHECK_METHOD的值为DM-E，则继续进行下一步检查</span></span><br><span class="line">	if [ &quot;$RK_SYSTEM_CHECK_METHOD&quot; = &quot;DM-E&quot; ]; then</span><br><span class="line">		echo &quot;检查ramdisk配置&quot;</span><br><span class="line">		defconfig_check buildroot/configs/$&#123;RK_CFG_BUILDROOT&#125;_defconfig &quot;$ROOTFS_UPDATE_ENGINEBIN_CONFIGS&quot;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	echo &quot;检查rootfs配置&quot;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">在buildroot/configs/<span class="variable">$&#123;RK_CFG_BUILDROOT&#125;</span>_defconfig文件中查找字符串<span class="string">&quot;BR2_ROOTFS_OVERLAY=\&quot;.*board/rockchip/common/security-system-overlay.*&quot;</span></span></span><br><span class="line">	find_string_in_config &quot;BR2_ROOTFS_OVERLAY=\&quot;.*board/rockchip/common/security-system-overlay.*&quot; &quot;buildroot/configs/$&#123;RK_CFG_BUILDROOT&#125;_defconfig&quot;</span><br><span class="line"></span><br><span class="line">	echo &quot;安全检查完成&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清理</span></span><br><span class="line">build_cleanall()</span><br><span class="line">&#123;</span><br><span class="line">	echo &quot;clean uboot, kernel, rootfs, recovery&quot;   # 执行清理操作，清理u-boot、kernel、rootfs和recovery相关的内容</span><br><span class="line"></span><br><span class="line">	make -C u-boot distclean   # 在u-boot目录中执行distclean命令，清理构建过程产生的临时文件和目标文件</span><br><span class="line">	make -C kernel distclean   # 在kernel目录中执行distclean命令，清理构建过程产生的临时文件和目标文件</span><br><span class="line">	rm -rf buildroot/output   # 删除buildroot/output目录，清理构建rootfs过程中生成的文件</span><br><span class="line">	rm -rf yocto/build/tmp yocto/build/*cache   # 删除yocto/build/tmp目录和所有yocto/build/*cache目录，清理构建yocto过程中生成的临时文件和缓存文件</span><br><span class="line">	rm -rf debian/binary   # 删除debian/binary目录，清理构建debian包时生成的二进制文件</span><br><span class="line"></span><br><span class="line">	finish_build   # 调用finish_build函数，进行后续的清理和处理操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build_firmware()</span><br><span class="line">&#123;</span><br><span class="line">	./mkfirmware.sh $BOARD_CONFIG   # 运行mkfirmware.sh脚本，传递$BOARD_CONFIG参数，用于构建固件</span><br><span class="line"></span><br><span class="line">	finish_build   # 调用finish_build函数，进行后续的清理和处理操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build_updateimg()</span><br><span class="line">&#123;</span><br><span class="line">	IMAGE_PATH=$TOP_DIR/rockdev   # 设置IMAGE_PATH变量为$TOP_DIR/rockdev，用于存储生成的镜像文件路径</span><br><span class="line">	PACK_TOOL_DIR=$TOP_DIR/tools/linux/Linux_Pack_Firmware   # 设置PACK_TOOL_DIR变量为$TOP_DIR/tools/linux/Linux_Pack_Firmware，用于存储打包工具的路径</span><br><span class="line"></span><br><span class="line">	cd $PACK_TOOL_DIR/rockdev   # 进入$PACK_TOOL_DIR/rockdev目录</span><br><span class="line"></span><br><span class="line">	if [ -f &quot;$RK_PACKAGE_FILE_AB&quot; ]; then   # 如果存在$RK_PACKAGE_FILE_AB文件</span><br><span class="line">		build_sdcard_package   # 调用build_sdcard_package函数，构建SD卡包</span><br><span class="line">		build_otapackage   # 调用build_otapackage函数，构建OTA包</span><br><span class="line"></span><br><span class="line">		cd $PACK_TOOL_DIR/rockdev   # 返回$PACK_TOOL_DIR/rockdev目录</span><br><span class="line">		echo &quot;Make Linux a/b update_ab.img.&quot;</span><br><span class="line">		source_package_file_name=`ls -lh package-file | awk -F &#x27; &#x27; &#x27;&#123;print $NF&#125;&#x27;`   # 获取package-file的文件名</span><br><span class="line">		ln -fs &quot;$RK_PACKAGE_FILE_AB&quot; package-file   # 创建软链接，将$RK_PACKAGE_FILE_AB链接到package-file</span><br><span class="line">		./mkupdate.sh   # 运行mkupdate.sh脚本，生成update.img</span><br><span class="line">		mv update.img $IMAGE_PATH/update_ab.img   # 将生成的update.img移动到$IMAGE_PATH/update_ab.img</span><br><span class="line">		ln -fs $source_package_file_name package-file   # 创建软链接，将source_package_file_name链接到package-file</span><br><span class="line">	else</span><br><span class="line">		echo &quot;Make update.img&quot;</span><br><span class="line"></span><br><span class="line">		if [ -f &quot;$RK_PACKAGE_FILE&quot; ]; then   # 如果存在$RK_PACKAGE_FILE文件</span><br><span class="line">			source_package_file_name=`ls -lh package-file | awk -F &#x27; &#x27; &#x27;&#123;print $NF&#125;&#x27;`   # 获取package-file的文件名</span><br><span class="line">			ln -fs &quot;$RK_PACKAGE_FILE&quot; package-file   # 创建软链接，将$RK_PACKAGE_FILE链接到package-file</span><br><span class="line">			./mkupdate.sh   # 运行mkupdate.sh脚本，生成update.img</span><br><span class="line">			ln -fs $source_package_file_name package-file   # 创建软链接，将source_package_file_name链接到package-file</span><br><span class="line">		else</span><br><span class="line">			./mkupdate.sh   # 运行mkupdate.sh脚本，生成update.img</span><br><span class="line">		fi</span><br><span class="line">		mv update.img $IMAGE_PATH   # 将生成的update.img移动到$IMAGE_PATH</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	finish_build   # 调用finish_build函数，进行后续的清理和处理操作</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译ota的包</span></span><br><span class="line">build_otapackage()</span><br><span class="line">&#123;</span><br><span class="line">	IMAGE_PATH=$TOP_DIR/rockdev   # 设置IMAGE_PATH变量为$TOP_DIR/rockdev，用于存储生成的镜像文件路径</span><br><span class="line">	PACK_TOOL_DIR=$TOP_DIR/tools/linux/Linux_Pack_Firmware   # 设置PACK_TOOL_DIR变量为$TOP_DIR/tools/linux/Linux_Pack_Firmware，用于存储打包工具的路径</span><br><span class="line"></span><br><span class="line">	echo &quot;Make ota ab update_ota.img&quot;</span><br><span class="line">	cd $PACK_TOOL_DIR/rockdev   # 进入$PACK_TOOL_DIR/rockdev目录</span><br><span class="line"></span><br><span class="line">	if [ -f &quot;$RK_PACKAGE_FILE_OTA&quot; ]; then   # 如果存在$RK_PACKAGE_FILE_OTA文件</span><br><span class="line">		source_package_file_name=`ls -lh $PACK_TOOL_DIR/rockdev/package-file | awk -F &#x27; &#x27; &#x27;&#123;print $NF&#125;&#x27;`   # 获取package-file的文件名</span><br><span class="line">		ln -fs &quot;$RK_PACKAGE_FILE_OTA&quot; package-file   # 创建软链接，将$RK_PACKAGE_FILE_OTA链接到package-file</span><br><span class="line">		./mkupdate.sh   # 运行mkupdate.sh脚本，生成update.img</span><br><span class="line">		mv update.img $IMAGE_PATH/update_ota.img   # 将生成的update.img移动到$IMAGE_PATH/update_ota.img</span><br><span class="line">		ln -fs $source_package_file_name package-file   # 创建软链接，将source_package_file_name链接到package-file</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	finish_build   # 调用finish_build函数，进行后续的清理和处理操作</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译sd卡镜像</span></span><br><span class="line">build_sdcard_package()</span><br><span class="line">&#123;</span><br><span class="line">	check_config RK_UPDATE_SDCARD_ENABLE_FOR_AB || return 0   # 检查配置项 RK_UPDATE_SDCARD_ENABLE_FOR_AB，如果没有启用则返回0</span><br><span class="line"></span><br><span class="line">	local image_path=$TOP_DIR/rockdev   # 设置image_path变量为$TOP_DIR/rockdev，用于存储生成的镜像文件路径</span><br><span class="line">	local pack_tool_dir=$TOP_DIR/tools/linux/Linux_Pack_Firmware   # 设置pack_tool_dir变量为$TOP_DIR/tools/linux/Linux_Pack_Firmware，用于存储打包工具的路径</span><br><span class="line">	local rk_sdupdate_ab_misc=$&#123;RK_SDUPDATE_AB_MISC:=sdupdate-ab-misc.img&#125;   # 设置rk_sdupdate_ab_misc变量为RK_SDUPDATE_AB_MISC的值（默认为sdupdate-ab-misc.img）</span><br><span class="line">	local rk_parameter_sdupdate=$&#123;RK_PARAMETER_SDUPDATE:=parameter-sdupdate.txt&#125;   # 设置rk_parameter_sdupdate变量为RK_PARAMETER_SDUPDATE的值（默认为parameter-sdupdate.txt）</span><br><span class="line">	local rk_package_file_sdcard_update=$&#123;RK_PACKAGE_FILE_SDCARD_UPDATE:=sdcard-update-package-file&#125;   # 设置rk_package_file_sdcard_update变量为RK_PACKAGE_FILE_SDCARD_UPDATE的值（默认为sdcard-update-package-file）</span><br><span class="line">	local sdupdate_ab_misc_img=$TOP_DIR/device/rockchip/common/images/$rk_sdupdate_ab_misc   # 设置sdupdate_ab_misc_img变量为$TOP_DIR/device/rockchip/common/images/加上rk_sdupdate_ab_misc的值</span><br><span class="line">	local parameter_sdupdate=$TOP_DIR/device/rockchip/common/images/$rk_parameter_sdupdate   # 设置parameter_sdupdate变量为$TOP_DIR/device/rockchip/common/images/加上rk_parameter_sdupdate的值</span><br><span class="line">	local recovery_img=$TOP_DIR/buildroot/output/$RK_UPDATE_SDCARD_CFG_RECOVERY/images/recovery.img   # 设置recovery_img变量为$TOP_DIR/buildroot/output/加上RK_UPDATE_SDCARD_CFG_RECOVERY/images/recovery.img的值</span><br><span class="line"></span><br><span class="line">	if [ $RK_UPDATE_SDCARD_CFG_RECOVERY ]; then   # 如果存在RK_UPDATE_SDCARD_CFG_RECOVERY配置项</span><br><span class="line">		if [ -f $recovery_img ]; then   # 如果存在recovery_img文件</span><br><span class="line">			echo -n &quot;create recovery.img...&quot;   # 输出提示信息</span><br><span class="line">			ln -rsf $recovery_img $image_path/recovery.img   # 创建软链接，将recovery_img链接到$image_path/recovery.img</span><br><span class="line">		else</span><br><span class="line">			echo &quot;error: $recovery_img not found!&quot;   # 输出错误信息</span><br><span class="line">			return 1   # 返回1表示出错</span><br><span class="line">		fi</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	echo &quot;Make sdcard update update_sdcard.img&quot;   # 输出提示信息</span><br><span class="line">	cd $pack_tool_dir/rockdev   # 进入$pack_tool_dir/rockdev目录</span><br><span class="line">	if [ -f &quot;$rk_package_file_sdcard_update&quot; ]; then   # 如果存在$rk_package_file_sdcard_update文件</span><br><span class="line">		if [ $rk_parameter_sdupdate ]; then   # 如果存在$rk_parameter_sdupdate变量</span><br><span class="line">			if [ -f $parameter_sdupdate ]; then   # 如果存在$parameter_sdupdate文件</span><br><span class="line">				echo -n &quot;create sdcard update image parameter...&quot;   # 输出提示信息</span><br><span class="line">				ln -rsf $parameter_sdupdate $image_path/   # 创建软链接，将$parameter_sdupdate链接到$image_path/</span><br><span class="line">			fi</span><br><span class="line">		fi</span><br><span class="line"></span><br><span class="line">		if [ $rk_sdupdate_ab_misc ]; then   # 如果存在$rk_sdupdate_ab_misc变量</span><br><span class="line">			if [ -f $sdupdate_ab_misc_img ]; then   # 如果存在$sdupdate_ab_misc_img文件</span><br><span class="line">				echo -n &quot;create sdupdate ab misc.img...&quot;   # 输出提示信息</span><br><span class="line">				ln -rsf $sdupdate_ab_misc_img $image_path/   # 创建软链接，将$sdupdate_ab_misc_img链接到$image_path/</span><br><span class="line">			fi</span><br><span class="line">		fi</span><br><span class="line"></span><br><span class="line">		source_package_file_name=`ls -lh $pack_tool_dir/rockdev/package-file | awk -F &#x27; &#x27; &#x27;&#123;print $NF&#125;&#x27;`   # 获取$pack_tool_dir/rockdev/package-file的文件名</span><br><span class="line">		ln -fs &quot;$rk_package_file_sdcard_update&quot; package-file   # 创建软链接，将$rk_package_file_sdcard_update链接到package-file</span><br><span class="line">		./mkupdate.sh   # 运行mkupdate.sh脚本，生成update.img</span><br><span class="line">		mv update.img $image_path/update_sdcard.img   # 将生成的update.img移动到$image_path/update_sdcard.img</span><br><span class="line">		ln -fs $source_package_file_name package-file   # 创建软链接，将$source_package_file_name链接到package-file</span><br><span class="line">		rm -f $image_path/$rk_sdupdate_abmisc $image_path/$rk_parameter_sdupdate $image_path/recovery.img   # 删除$image_path/$rk_sdupdate_ab_misc、$image_path/$rk_parameter_sdupdate和$image_path/recovery.img文件</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	finish_build   # 调用finish_build函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build_save()</span><br><span class="line">&#123;</span><br><span class="line">	IMAGE_PATH=$TOP_DIR/rockdev   # 设置IMAGE_PATH变量为$TOP_DIR/rockdev，用于存储生成的镜像文件路径</span><br><span class="line">	DATE=$(date  +%Y%m%d.%H%M)   # 获取当前日期和时间，格式为YYYYMMDD.HHMM</span><br><span class="line">	STUB_PATH=Image/&quot;$RK_KERNEL_DTS&quot;_&quot;$DATE&quot;_RELEASE_TEST   # 设置STUB_PATH变量为Image/加上$RK_KERNEL_DTS、日期和_RELEASE_TEST</span><br><span class="line">	STUB_PATH=&quot;$(echo $STUB_PATH | tr &#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27;)&quot;   # 将STUB_PATH转换为大写字母</span><br><span class="line">	export STUB_PATH=$TOP_DIR/$STUB_PATH   # 导出STUB_PATH变量为$TOP_DIR/加上$STUB_PATH</span><br><span class="line">	export STUB_PATCH_PATH=$STUB_PATH/PATCHES   # 导出STUB_PATCH_PATH变量为$STUB_PATH/PATCHES</span><br><span class="line">	mkdir -p $STUB_PATH   # 创建$STUB_PATH目录</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">生成补丁文件</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	.repo/repo/repo forall -c \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#		&quot;$TOP_DIR/device/rockchip/common/gen_patches_body.sh&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">复制补丁文件</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	<span class="built_in">yes</span> | .repo/repo/repo manifest -r -o <span class="variable">$STUB_PATH</span>/manifest_<span class="variable">$&#123;DATE&#125;</span>.xml</span></span><br><span class="line">	mkdir -p $STUB_PATCH_PATH/kernel   # 创建$STUB_PATCH_PATH/kernel目录</span><br><span class="line">	cp kernel/.config $STUB_PATCH_PATH/kernel   # 复制kernel目录下的.config文件到$STUB_PATCH_PATH/kernel目录</span><br><span class="line">	cp kernel/vmlinux $STUB_PATCH_PATH/kernel   # 复制kernel目录下的vmlinux文件到$STUB_PATCH_PATH/kernel目录</span><br><span class="line">	mkdir -p $STUB_PATH/IMAGES/   # 创建$STUB_PATH/IMAGES/目录</span><br><span class="line">	cp $IMAGE_PATH/* $STUB_PATH/IMAGES/   # 复制$IMAGE_PATH目录下的所有文件到$STUB_PATH/IMAGES/目录</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">保存构建命令信息</span></span><br><span class="line">	echo &quot;UBOOT:  defconfig: $RK_UBOOT_DEFCONFIG&quot; &gt;&gt; $STUB_PATH/build_cmd_info   # 将UBOOT的配置信息写入build_cmd_info文件</span><br><span class="line">	echo &quot;KERNEL: defconfig: $RK_KERNEL_DEFCONFIG, dts: $RK_KERNEL_DTS&quot; &gt;&gt; $STUB_PATH/build_cmd_info   # 将KERNEL的配置信息写入build_cmd_info文件</span><br><span class="line">	echo &quot;BUILDROOT: $RK_CFG_BUILDROOT&quot; &gt;&gt; $STUB_PATH/build_cmd_info   # 将BUILDROOT的配置信息写入build_cmd_info文件</span><br><span class="line"></span><br><span class="line">	finish_build   # 调用finish_build函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build_allsave()</span><br><span class="line">&#123;</span><br><span class="line">	rm -fr $TOP_DIR/rockdev   # 删除$TOP_DIR/rockdev目录及其内容</span><br><span class="line">	mkdir -p $TOP_DIR/rockdev   # 创建$TOP_DIR/rockdev目录</span><br><span class="line">	build_all   # 调用build_all函数，执行全部构建过程</span><br><span class="line">	build_firmware   # 调用build_firmware函数，构建固件</span><br><span class="line">	build_updateimg   # 调用build_updateimg函数，构建更新镜像</span><br><span class="line">	build_save   # 调用build_save函数，保存构建过程中的相关文件</span><br><span class="line"></span><br><span class="line">	build_check_power_domain   # 调用build_check_power_domain函数，检查电源域配置</span><br><span class="line"></span><br><span class="line">	finish_build   # 调用finish_build函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">create_keys()</span><br><span class="line">&#123;</span><br><span class="line">	test -d u-boot/keys &amp;&amp; echo &quot;ERROR: u-boot/keys has existed&quot; &amp;&amp; return -1   # 检查u-boot/keys目录是否已存在，如果存在则输出错误信息并返回-1</span><br><span class="line"></span><br><span class="line">	mkdir u-boot/keys -p   # 创建u-boot/keys目录</span><br><span class="line"></span><br><span class="line">	./rkbin/tools/rk_sign_tool kk --bits 2048 --out u-boot/keys   # 使用rk_sign_tool工具生成密钥对，密钥长度为2048位，并存储在u-boot/keys目录下</span><br><span class="line">	ln -s private_key.pem u-boot/keys/dev.key   # 创建符号链接将private_key.pem命名为u-boot/keys/dev.key</span><br><span class="line">	ln -s public_key.pem u-boot/keys/dev.pubkey   # 创建符号链接将public_key.pem命名为u-boot/keys/dev.pubkey</span><br><span class="line"></span><br><span class="line">	openssl req -batch -new -x509 -key u-boot/keys/dev.key -out u-boot/keys/dev.crt   # 使用openssl生成自签名证书，使用u-boot/keys/dev.key作为私钥，生成的证书存储在u-boot/keys/dev.crt中</span><br><span class="line"></span><br><span class="line">	openssl rand -out u-boot/keys/system_enc_key -hex 32   # 使用openssl生成32字节的随机数，并以十六进制格式存储在u-boot/keys/system_enc_key文件中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">security_is_enabled()</span><br><span class="line">&#123;</span><br><span class="line">	if [ &quot;$RK_RAMDISK_SECURITY_BOOTUP&quot; != &quot;true&quot; ]; then   # 如果环境变量$RK_RAMDISK_SECURITY_BOOTUP不等于&quot;true&quot;</span><br><span class="line">		echo &quot;No security paramter found in $BOARD_CONFIG&quot;   # 输出错误信息，表示在$BOARD_CONFIG中未找到安全参数</span><br><span class="line">		exit -1   # 退出脚本，返回-1</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">=========================</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">build targets</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">=========================</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">OPTIONS=<span class="string">&quot;<span class="variable">$&#123;@:-allsave&#125;</span>&quot;</span></span></span><br><span class="line">if [ -z &quot;$1&quot; ]; then</span><br><span class="line">    titlestr=&quot;请选择一个选项&quot;                         # 菜单标题</span><br><span class="line">    backtitle=&quot;iTOP-RK3568构建脚本，http://www.topeet.com&quot;  # 返回标题</span><br><span class="line">    menustr=&quot;编译镜像 | u-boot| 内核| recovery| buildroot | debian | yocto | all&quot;  # 菜单选项</span><br><span class="line"></span><br><span class="line">    TTY_X=$(($(stty size | awk &#x27;&#123;print $2&#125;&#x27;)-6))  # 确定终端宽度</span><br><span class="line">    TTY_Y=$(($(stty size | awk &#x27;&#123;print $1&#125;&#x27;)-6))  # 确定终端高度</span><br><span class="line"></span><br><span class="line">    choose+=(&quot;uboot&quot;       &quot;build_uboot&quot;)      # 选项1: u-boot编译</span><br><span class="line">    choose+=(&quot;kernel&quot;       &quot;build_kernel&quot;)    # 选项2: 内核编译</span><br><span class="line">    choose+=(&quot;recovery&quot;       &quot;build_recovery&quot;)  # 选项3: recovery编译</span><br><span class="line">    choose+=(&quot;buildroot&quot;       &quot;build_rootfs buildroot&quot;)  # 选项4: 编译buildroot根文件系统</span><br><span class="line">    choose+=(&quot;debian&quot;       &quot;build_rootfs debian&quot;)         # 选项5: 编译Debian根文件系统</span><br><span class="line">    choose+=(&quot;yocto&quot;       &quot;build_rootfs yocto&quot;)           # 选项6: 编译Yocto根文件系统</span><br><span class="line">    choose+=(&quot;save&quot;       &quot;build_save&quot;)        # 选项7: 保存构建结果</span><br><span class="line">    choose+=(&quot;all&quot;       &quot;build_all&quot;)          # 选项8: 编译所有</span><br><span class="line"></span><br><span class="line">    OPTIONS=$(whiptail --title &quot;$&#123;titlestr&#125;&quot; --backtitle &quot;$&#123;backtitle&#125;&quot; --notags \</span><br><span class="line">                --menu &quot;$&#123;menustr&#125;&quot; &quot;$&#123;TTY_Y&#125;&quot; &quot;$&#123;TTY_X&#125;&quot; $((TTY_Y - 8)) \</span><br><span class="line">                --cancel-button 退出 --ok-button 选择 &quot;$&#123;choose[@]&#125;&quot; \</span><br><span class="line">                3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3)  # 使用whiptail创建菜单，并获取用户选择的选项</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">    OPTIONS=&quot;$&#123;1&#125;&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">预处理选项</span></span><br><span class="line">unset POST_OPTIONS</span><br><span class="line">for option in $OPTIONS; do</span><br><span class="line">    case $option in</span><br><span class="line">        BoardConfig*.mk)</span><br><span class="line">            option=&quot;$CHIP_DIR/$option&quot;</span><br><span class="line">            ;&amp;</span><br><span class="line">        *.mk)</span><br><span class="line">            CONF=$(realpath $option)</span><br><span class="line">            echo &quot;切换到配置文件: $CONF&quot;</span><br><span class="line">            if [ ! -f $CONF ]; then</span><br><span class="line">                echo &quot;文件不存在!&quot;</span><br><span class="line">                exit 1</span><br><span class="line">            fi</span><br><span class="line"></span><br><span class="line">            ln -rsf $CONF $BOARD_CONFIG</span><br><span class="line">            ;;</span><br><span class="line">        lunch) choose_board ;;</span><br><span class="line">        kernel-4.4|kernel-4.19|kernel-5.10)</span><br><span class="line">            RK_KERNEL_VERSION=$&#123;option#kernel-&#125;</span><br><span class="line">            ;;</span><br><span class="line">        *) POST_OPTIONS=&quot;$POST_OPTIONS $option&quot;;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">if [ -r &quot;$BOARD_CONFIG&quot; ]; then  # 如果配置文件存在且可读</span><br><span class="line">    source $BOARD_CONFIG  # 导入配置文件</span><br><span class="line">else</span><br><span class="line">    choose_board  # 否则，调用选择板型函数</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -d &quot;$CHIP_DIR/build-hooks/&quot; ]; then  # 如果存在构建钩子目录</span><br><span class="line">    for hook in $(find &quot;$CHIP_DIR/build-hooks&quot; -name &quot;*.sh&quot;); do  # 遍历所有以.sh结尾的文件</span><br><span class="line">        source &quot;$hook&quot;  # 导入每个构建钩子脚本</span><br><span class="line">    done</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回退到当前内核版本</span></span><br><span class="line">RK_KERNEL_VERSION=$&#123;RK_KERNEL_VERSION:-$(kernel_version kernel/)&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回退到5.10内核版本</span></span><br><span class="line">RK_KERNEL_VERSION=$&#123;RK_KERNEL_VERSION:-5.10&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新内核</span></span><br><span class="line">if [ &quot;$(kernel_version kernel/)&quot; != &quot;$RK_KERNEL_VERSION&quot; ]; then  # 如果当前内核版本与指定版本不一致</span><br><span class="line">    KERNEL_DIR=kernel-$RK_KERNEL_VERSION  # 设置新的内核目录名称</span><br><span class="line">    echo &quot;切换到 $KERNEL_DIR&quot;</span><br><span class="line">    if [ ! -d &quot;$KERNEL_DIR&quot; ]; then  # 如果新的内核目录不存在</span><br><span class="line">        echo &quot;不存在！&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line">    rm -rf kernel  # 删除旧的内核软链接</span><br><span class="line">    ln -rsf $KERNEL_DIR kernel  # 创建新的内核软链接</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后续选项处理</span></span><br><span class="line">for option in $POST_OPTIONS; do</span><br><span class="line">    echo &quot;处理选项: $option&quot;</span><br><span class="line">    case $option in</span><br><span class="line">        all) build_all ;;  # 执行编译所有选项</span><br><span class="line">        save) build_save ;;  # 执行保存构建结果选项</span><br><span class="line">        allsave) build_allsave ;;  # 执行编译所有并保存结果选项</span><br><span class="line">        cleanall) build_cleanall ;;  # 执行清理所有构建结果选项</span><br><span class="line">        firmware) build_firmware ;;  # 执行编译固件选项</span><br><span class="line">        updateimg) build_updateimg ;;  # 执行编译更新镜像选项</span><br><span class="line">        otapackage) build_otapackage ;;  # 执行编译OTA包选项</span><br><span class="line">        sdpackage) build_sdcard_package ;;  # 执行编译SD卡镜像选项</span><br><span class="line">        spl) build_spl ;;  # 执行编译SPL选项</span><br><span class="line">        uboot) build_uboot ;;  # 执行编译u-boot选项</span><br><span class="line">        uefi) build_uefi ;;  # 执行编译UEFI选项</span><br><span class="line">        loader) build_loader ;;  # 执行编译loader选项</span><br><span class="line">        kernel) build_kernel ;;  # 执行编译内核选项</span><br><span class="line">        wifibt)  # 执行编译Wi-Fi和蓝牙固件选项</span><br><span class="line">            build_wifibt $2 $3  # 调用编译Wi-Fi和蓝牙固件的函数，并传递参数$2和$3</span><br><span class="line">            exit 1 ;;  # 退出脚本</span><br><span class="line">        modules) build_modules ;;  # 执行编译内核模块选项</span><br><span class="line">        rootfs) build_rootfs ;;  # 执行编译根文件系统选项</span><br><span class="line">        buildroot|debian|yocto) build_rootfs $option ;;  # 执行编译指定根文件系统选项</span><br><span class="line">        pcba) build_pcba ;;  # 执行编译PCBA选项</span><br><span class="line">        recovery) build_recovery ;;  # 执行编译recovery选项</span><br><span class="line">        info) build_info ;;  # 执行显示构建信息选项</span><br><span class="line">        createkeys) create_keys ;;  # 执行生成密钥选项</span><br><span class="line">        security_boot)  # 执行启用安全引导的选项</span><br><span class="line">            security_is_enabled  # 检查安全引导是否已启用</span><br><span class="line">            build_rootfs  # 编译根文件系统</span><br><span class="line">            build_uboot boot  # 编译启动引导程序</span><br><span class="line">            ;;</span><br><span class="line">        security_uboot)  # 执行启用安全引导的u-boot选项</span><br><span class="line">            security_is_enabled  # 检查安全引导是否已启用</span><br><span class="line">            build_uboot uboot  # 编译u-boot引导程序</span><br><span class="line">            ;;</span><br><span class="line">        security_recovery)  # 执行启用安全引导的recovery选项</span><br><span class="line">            security_is_enabled  # 检查安全引导是否已启用</span><br><span class="line">            build_recovery  # 编译recovery</span><br><span class="line">            build_uboot recovery  # 编译recovery引导程序</span><br><span class="line">            ;;</span><br><span class="line">        security_check) check_security_condition ;;  # 执行检查安全条件选项</span><br><span class="line">        security_rootfs)  # 执行启用安全引导的根文件系统选项</span><br><span class="line">            security_is_enabled  # 检查安全引导是否已启用</span><br><span class="line">            build_rootfs  # 编译根文件系统</span><br><span class="line">            build_uboot  # 编译u-boot引导程序</span><br><span class="line">            echo &quot;请更新 rootfs.img / boot.img&quot;</span><br><span class="line">            ;;</span><br><span class="line">        *) usage ;;  # 显示用法</span><br><span class="line">    esac</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>瑞芯微脚本分析</category>
      </categories>
      <tags>
        <tag>瑞芯微脚本分析</tag>
      </tags>
  </entry>
  <entry>
    <title>7.19 Linux内核的面向对象思想：多态</title>
    <url>/2023/09/09/7-19-Linux%E5%86%85%E6%A0%B8%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%EF%BC%9A%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当涉及到C语言基础的结构体、指针、数组、函数指针、指针函数以及指针传参和返回值时，下面是一些相关的解释和示例：</p>
<ol>
<li><p>结构体（Structures）：</p>
<p>结构体是一种用户自定义的数据类型，它可以包含不同数据类型的成员变量。结构体提供了一种组织数据的方式，使得可以将多个相关的数据项组合在一起。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">person1</span>;</span></span><br><span class="line">person1.age = <span class="number">25</span>;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>指针（Pointers）：</p>
<p>指针是一种变量，用于存储内存地址。通过指针，可以间接地访问和操作内存中的数据。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;num; <span class="comment">// 指向num的指针</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组（Arrays）：</p>
<p>数组是一种存储相同类型数据项的连续内存区域。可以通过索引访问数组元素。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> element = arr[<span class="number">2</span>]; <span class="comment">// 访问索引为2的数组元素</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数指针（Function Pointers）：</p>
<p>函数指针指向函数的内存地址。可以通过函数指针调用相应的函数。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> (*ptr)(<span class="type">int</span>, <span class="type">int</span>) = add; <span class="comment">// 指向add函数的指针</span></span><br><span class="line"><span class="type">int</span> result = ptr(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 调用函数指针</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>指针函数（Pointer to a Function）：</p>
<p>指针函数是一个返回指针的函数。它返回指向特定类型的数据的指针。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">getArray</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> *ptr = getArray(); <span class="comment">// 调用指针函数，获取指针</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>指针传参和指针返回值：</p>
<p>在函数参数中，可以通过指针传递参数，使得函数能够修改传入的变量的值。同样，函数也可以返回指针，以便在函数外部访问函数内部创建的变量。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> *numPtr)</span> &#123;</span><br><span class="line">    (*numPtr)++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    increment(&amp;num); <span class="comment">// 通过指针传参修改num的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num); <span class="comment">// 输出 6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据结构：链表（Linked List）和队列（Queue）：</p>
<p>链表和队列都是常见的数据结构。</p>
<p>链表是一种动态数据结构，它由节点组成，每个节点包含数据和指向下一个节点的指针。链表的插入和删除操作比较高效。</p>
<p>队列是一种先进先出（FIFO）的数据结构，可以在一端插入元素，在另一端删除元素。常见的队列有顺序队列和链式队列。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 队列节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">```</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据结构和面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>7.18 Linux内核的面向对象思想：继承（下）</title>
    <url>/2023/09/09/7-18-Linux%E5%86%85%E6%A0%B8%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%EF%BC%9A%E7%BB%A7%E6%89%BF%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据结构和面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>7.17 Linux内核的面向对象思想：继承（上）</title>
    <url>/2023/09/09/7-17-Linux%E5%86%85%E6%A0%B8%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%EF%BC%9A%E7%BB%A7%E6%89%BF%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据结构和面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>7.16 Linux内核的面向对象思想：封装（下）</title>
    <url>/2023/09/09/7-16-Linux%E5%86%85%E6%A0%B8%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%EF%BC%9A%E5%B0%81%E8%A3%85%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据结构和面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>7.15 Linux内核的面向对象思想：封装（上）</title>
    <url>/2023/09/09/7-15-Linux%E5%86%85%E6%A0%B8%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%EF%BC%9A%E5%B0%81%E8%A3%85%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据结构和面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>7.14 面向对象编程：封装、继承与多态</title>
    <url>/2023/09/09/7-14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%9A%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="7-14-1-OOP"><a href="#7-14-1-OOP" class="headerlink" title="7.14.1 OOP"></a>7.14.1 OOP</h1><p>面向对象编程（Object-Oriented Programming，简称OOP）是一种程序设计范 paradigms式，它以对象作为程序的基本单元，将数据和操作封装在对象中。对象由数据成员（属性）和对这些数据进行操作的方法（函数）组成。类是对具有相似特征和行为的对象的抽象，是定义对象的模板或蓝图。</p>
<p>面向对象编程强调的是将问题领域中的实体和其相互关系映射到程序代码中。通过封装、继承和多态等机制，可以实现代码的模块化、重用性、可扩展性和可维护性。面向对象编程提供了一种更加直观和自然的方式来组织和管理复杂的程序。</p>
<p>相比之下，面向过程编程（Procedure-Oriented Programming，简称POP）将程序看作是一系列的步骤或函数的集合，通过调用函数来解决问题。面向过程编程更加强调程序的顺序性和模块化，将程序分解为多个函数，每个函数负责特定的功能。</p>
<p>面向对象编程与面向过程编程在思想和设计上存在明显的区别。面向对象编程通过封装、继承和多态等特性将数据和操作封装在对象中，强调对象与对象之间的交互和关系。而面向过程编程更加注重程序的流程和函数的调用。</p>
<h1 id="7-14-2-三大特征"><a href="#7-14-2-三大特征" class="headerlink" title="7.14.2 三大特征"></a>7.14.2 三大特征</h1><p>面向对象编程的三大特征是封装、继承和多态。</p>
<ol>
<li>封装（Encapsulation）：封装是将数据和对数据的操作封装在一个单元中，即类。类将数据成员（属性）和方法（函数）组合在一起，形成一个独立的实体。类对外部提供公共接口，通过这些接口来访问和操作数据，同时隐藏了内部的实现细节。封装提供了数据的安全性和灵活性，使得数据的修改和维护更加方便。</li>
<li>继承（Inheritance）：继承是指子类（派生类）可以继承父类（基类）的属性和方法。子类可以扩展或修改继承自父类的属性和方法，同时还可以添加自己特有的属性和方法。继承提供了代码的重用性和扩展性，可以通过定义通用的父类来抽象出共性，然后通过子类来具体实现特定的功能。</li>
<li>多态（Polymorphism）：多态是指一个接口可以有多种实现方式。在面向对象编程中，多态性允许使用父类的引用来引用子类的对象，从而实现对不同子类对象的统一处理。多态性可以通过函数的重载（Overloading）和函数的覆盖（Overriding）来实现。函数重载是指在一个类中定义多个同名但参数列表不同的函数，函数覆盖是指在子类中重新定义父类中已有的函数。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据结构和面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>7.7 Linux内核中的通用链表(上)</title>
    <url>/2023/09/09/7-7-Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E9%80%9A%E7%94%A8%E9%93%BE%E8%A1%A8-%E4%B8%8A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>双向循环链表是一种常见的链表数据结构，它的每个节点除了包含指向下一个节点的指针之外，还包含指向前一个节点的指针，形成了一个循环的链表结构。双向循环链表在进程、文件、模块、设备驱动等许多场景中被广泛使用。</p>
<p>在 Linux 内核中，双向循环链表的定义和基本操作在头文件 <code>include/linux/list.h</code> 和 <code>include/linux/types.h</code> 中进行了通用的定义。这些头文件提供了用于构建和操作双向循环链表的函数和宏定义。</p>
<p>以下是一些常用的双向循环链表操作：</p>
<ul>
<li><code>struct list_head</code>：双向循环链表节点的结构定义，包含指向前一个节点和后一个节点的指针。</li>
<li><code>INIT_LIST_HEAD(struct list_head *head)</code>：初始化一个双向循环链表头节点。</li>
<li><code>list_add(struct list_head *new, struct list_head *head)</code>：将一个节点添加到链表头部。</li>
<li><code>list_add_tail(struct list_head *new, struct list_head *head)</code>：将一个节点添加到链表尾部。</li>
<li><code>list_del(struct list_head *entry)</code>：从链表中删除一个节点。</li>
<li><code>list_empty(const struct list_head *head)</code>：检查链表是否为空。</li>
<li><code>list_for_each(pos, head)</code>：遍历链表中的每个节点。</li>
<li><code>list_entry(ptr, type, member)</code>：获取包含节点的结构体的指针。</li>
</ul>
<p>通过使用上述操作，不同的数据类型可以根据自己的需要构建自己的双向循环链表。这些操作提供了对链表的插入、删除、遍历等基本操作，使链表的管理和操作更加方便和高效。</p>
<p>需要注意的是，此处提到的是 Linux 内核中的双向循环链表实现</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据结构和面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>7.2 数据结构基础</title>
    <url>/2023/09/09/7-2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="7-2-1-什么是数据结构"><a href="#7-2-1-什么是数据结构" class="headerlink" title="7.2.1 什么是数据结构?"></a>7.2.1 什么是数据结构?</h1><p>数据结构是计算机科学中研究数据组织、存储和管理方式的一门学科。它关注如何以适当的方式组织和存储数据，以便有效地访问和操作数据。数据结构提供了一种对现实世界中的问题进行抽象和建模的方法。</p>
<p>在计算机程序中，数据结构是程序的基础，它决定了数据的组织形式和数据之间的关联关系。数据结构的设计和选择对程序的性能和效率有着重要的影响。合适的数据结构可以提高程序的执行速度、减少资源占用，并使程序更易于理解和维护。</p>
<p>常见的数据结构包括数组、链表、栈、队列、树、图等。每种数据结构都有不同的特点和适用场景。选择合适的数据结构可以根据问题的特性和需求，提高算法的效率和程序的性能。</p>
<h1 id="7-2-2-数据元素"><a href="#7-2-2-数据元素" class="headerlink" title="7.2.2 数据元素"></a>7.2.2 数据元素</h1><p>数据元素是数据的基本单位，它是构成数据集合的最小单位。在计算机科学中，数据元素可以是一个单独的值，也可以是一个包含多个值的结构。</p>
<p>C语言中的基本数据类型包括整型、浮点型、字符型等。其中，数组和结构体是用于组织和存储多个数据元素的复合数据类型。</p>
<ol>
<li><p>数组（Array）：<br>数组是一种连续存储相同类型数据元素的数据结构。数组的每个元素通过索引访问，索引从0开始。数组在内存中是一段连续的存储区域，可以按照索引快速访问和修改元素的值。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int numbers[5] = &#123;1, 2, 3, 4, 5&#125;; // 定义一个包含5个整数的数组</span><br><span class="line">int firstElement = numbers[0]; // 访问数组的第一个元素</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体（Structure）：<br>结构体是一种用户自定义的数据类型，它可以包含多个不同类型的数据元素，这些元素可以有不同的数据类型。结构体通过声明一个结构体模板来定义，然后可以创建多个结构体变量。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    char name[20];</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line">struct Person person1; // 定义一个Person类型的结构体变量</span><br><span class="line">person1.age = 25; // 访问结构体变量的成员并赋值</span><br><span class="line">```</span><br></pre></td></tr></table></figure></li>
</ol>
<p>此外，C语言还提供了其他的复合数据类型，包括共用体（Union）和枚举（Enumeration）。</p>
<p>共用体是一种特殊的数据类型，它允许在相同的内存区域存储不同类型的数据。共用体的所有成员共享同一块内存，但一次只能存储其中一个成员的值。</p>
<p>枚举是一种用于定义一组具名常量的数据类型。枚举类型定义了一系列可以取值的符号常量，这些常量可以用于程序中，提高代码的可读性和可维护性。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union Data &#123;</span><br><span class="line">    int num;</span><br><span class="line">    float decimal;</span><br><span class="line">&#125;;</span><br><span class="line">union Data myData;</span><br><span class="line">myData.num = 10; // 存储一个整数值</span><br><span class="line"></span><br><span class="line">enum Week &#123;</span><br><span class="line">    MONDAY,</span><br><span class="line">    TUESDAY,</span><br><span class="line">    WEDNESDAY,</span><br><span class="line">    THURSDAY,</span><br><span class="line">    FRIDAY,</span><br><span class="line">    SATURDAY,</span><br><span class="line">    SUNDAY</span><br><span class="line">&#125;;</span><br><span class="line">enum Week today = WEDNESDAY; // 定义一个枚举类型的变量</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">总结来说，数据元素是数据的基本单位，可以是单个值或者组合的结构。在C语言中，数组和结构体是用于组织和存储多个数据元素的基本数据类型，而共用体和枚举则提供了其他的复合数据类型的选择。</span><br></pre></td></tr></table></figure>

<h1 id="7-2-3-数据结构含义"><a href="#7-2-3-数据结构含义" class="headerlink" title="7.2.3 数据结构含义"></a>7.2.3 数据结构含义</h1><p>数据结构是指计算机中组织和存储数据的方式和方法。它涵盖了多种结构类型、逻辑结构、存储结构以及基本操作。</p>
<ol>
<li>结构类型：<br>数据结构包括多种类型，如栈（Stack）、链表（Linked List）、队列（Queue）、树（Tree）、图（Graph）等。每种结构类型都有其特定的数据组织方式和操作规则，适用于不同的问题和场景。</li>
<li>逻辑结构：<br>数据结构的逻辑结构描述了数据元素之间的关系和组织方式。主要分为线性结构和非线性结构两种。<ul>
<li>线性结构：数据元素之间存在一对一的关系，形成线性序列。常见的线性结构包括数组、链表、栈和队列等。线性结构中的数据元素排列有序，可以按照一定顺序进行访问。</li>
<li>非线性结构：数据元素之间存在一对多或多对多的关系，形成非线性的关联。常见的非线性结构包括树和图等。非线性结构中的数据元素之间没有固定的顺序，可以以分支、层次等形式进行组织。</li>
</ul>
</li>
<li>存储结构：<br>数据结构的存储结构指的是数据在计算机内存中的实际存储方式。主要分为顺序存储和链式存储两种。<ul>
<li>顺序存储：数据元素在内存中按照顺序依次存储，可以通过索引或偏移量快速访问元素。数组是一种常见的顺序存储结构。</li>
<li>链式存储：数据元素在内存中通过指针相互连接，每个元素包含指向下一个元素的指针。链表是一种常见的链式存储结构，它可以动态地分配内存，并支持灵活的插入和删除操作。</li>
</ul>
</li>
<li>基本操作：<br>数据结构的基本操作包括添加（插入）、删除、查找和遍历等。这些操作用于对数据结构中的数据进行增加、删除、搜索和访问。<ul>
<li>添加：向数据结构中插入一个新的数据元素。</li>
<li>删除：从数据结构中移除一个指定的数据元素。</li>
<li>查找：在数据结构中搜索指定的数据元素。</li>
<li>遍历：按照一定顺序访问数据结构中的所有数据元素。</li>
</ul>
</li>
</ol>
<h1 id="7-2-4-数据结构的重要性"><a href="#7-2-4-数据结构的重要性" class="headerlink" title="7.2.4 数据结构的重要性"></a>7.2.4 数据结构的重要性</h1><p>编程技能是指在软件开发过程中所需的技术和能力，包括数据结构、算法、编程语言掌握、框架使用、代码复用、性能优化和处理复杂业务逻辑等方面。</p>
<ol>
<li>数据结构和算法内功：<br>数据结构和算法是编程的内功，对于解决问题和设计高效的程序至关重要。理解不同数据结构的特点和适用场景，掌握常用的算法技巧，能够选择和设计合适的数据结构和算法来解决问题。</li>
<li>编程语言招式：<br>熟练掌握一门或多门编程语言，包括其语法、特性和常用库函数等。了解编程语言的最佳实践和常见的编码规范，能够灵活运用编程语言的特性和功能来实现程序逻辑。</li>
<li>框架分层：<br>在开发大型软件系统时，合理使用框架可以提高开发效率和代码质量。了解不同框架的分层架构和模块功能，能够根据需求选择和使用合适的框架，将业务逻辑分解为不同层次的模块，提高代码的可维护性和可扩展性。</li>
<li>代码复用：<br>通过合理的代码组织和模块化设计，实现代码的复用性。编写可复用的函数和类，遵循面向对象编程（OOP）的原则，将通用的功能封装成可调用的模块，提高代码的可读性和可维护性。</li>
<li>性能优化：<br>优化程序的性能是提升用户体验和系统效率的关键。通过合理的算法选择、数据结构优化、并发处理和资源管理等手段，提高程序的执行效率和资源利用率。</li>
<li>复杂的业务逻辑：<br>处理复杂的业务逻辑需要良好的分析和设计能力。能够理解业务需求，将复杂的问题分解为简单的子问题，并设计合适的数据结构和算法来实现复杂的业务逻辑。</li>
</ol>
<h1 id="7-2-5-工程师层级"><a href="#7-2-5-工程师层级" class="headerlink" title="7.2.5 工程师层级"></a>7.2.5 工程师层级</h1><p>工程师层级划分可以根据技能和经验的不同进行分类，通常包括以下几个层级：</p>
<ol>
<li>菜鸟：<br>菜鸟是指刚入门或者经验较少的工程师。他们对编程和软件开发的基本概念和技能还不熟悉，需要通过学习和实践来提升自己。</li>
<li>新手：<br>新手级工程师已经能够通过编程完成简单的任务，能够编写能够运行的代码，但通常只能达到demo级别。他们在遇到边界情况或者复杂问题时可能会出现异常、不稳定或者有bug，并且可能无法解决复杂的问题。在面对新的需求或者功能添加时，他们可能会导致程序结构臃肿、bug增多、难以维护。</li>
<li>老手：<br>老手工程师经过一段时间的锻炼，开始重视数据结构和算法的重要性，能够针对复杂问题进行思考和分析，并尝试使用合适的数据结构和算法来解决问题。他们也开始注重程序的健壮性、稳定性和可维护性。</li>
<li>高手：<br>高手级工程师已经具备了扎实的编程基础和经验。他们精通一门或多门编程语言，并根据需求选择不同的语言来进行开发。他们能够使用面向对象思想来抽象和解构复杂的系统，设计合理的程序结构和模块耦合。对于常见的问题和挑战，他们能够迅速找到解决方案。</li>
<li>专家：<br>专家级工程师在多个项目实战和经验积累的基础上，进一步理解面向对象思想，并能够灵活运用设计模式来解决复杂的问题。他们对架构设计有深入的了解，能够进行代码分层、模块耦合和性能优化等工作。他们不再局限于单一的编程语言，而是将语言视为工具，并能够根据需求选择最适合的语言进行开发。</li>
</ol>
<h1 id="7-2-6-Linux内核数据结构"><a href="#7-2-6-Linux内核数据结构" class="headerlink" title="7.2.6 Linux内核数据结构"></a>7.2.6 Linux内核数据结构</h1><p>在Linux内核中，有多种常用的数据结构用于管理和组织数据。以下是一些常见的数据结构及其在Linux内核中的应用：</p>
<ol>
<li>链表（Linked List）：<br>链表是一种基本的数据结构，用于在内核中管理设备、进程等资源。Linux内核中使用双向链表（doubly linked list）来表示和管理这些资源，例如设备驱动程序中的设备列表。</li>
<li>队列（Queue）：<br>队列在Linux内核中有多种应用，包括工作队列（work queue）、等待队列（wait queue）和消息队列（message queue）。工作队列用于异步执行延迟的工作，等待队列用于进程等待某个条件满足，消息队列用于进程间通信。</li>
<li>树（Tree）：<br>树是一种常见的数据结构，用于在内核中组织和管理数据。Linux内核中使用了多种树结构，包括二叉树（binary tree）、红黑树（red-black tree）和B树（B-tree）。这些树结构被广泛应用于文件系统、进程调度等功能中。</li>
<li>哈希表（Hash Table）：<br>哈希表是一种高效的数据结构，用于快速查找和存储数据。在Linux内核中，哈希表被广泛用于文件系统，例如用于管理文件索引和缓存等。哈希表可以提高文件系统的性能和快速访问文件。</li>
</ol>
<h1 id="7-2-7-线性表"><a href="#7-2-7-线性表" class="headerlink" title="7.2.7 线性表"></a>7.2.7 线性表</h1><p>线性结构是一种逻辑结构，其中数据元素之间存在一对一的线性关系。线性结构可以分为线性表、栈、队列和数组等不同的数据结构。</p>
<ol>
<li>线性表：<br>线性表是最基本的线性结构，它由相同数据类型的N个元素按照一定顺序排列而成。每个元素都有一个前趋（前驱）和后继，除了第一个元素没有前趋，最后一个元素没有后继。线性表可以通过顺序存储（如数组）或链式存储（如链表）来实现。</li>
</ol>
<p>线性表是一种基本的数据结构，按照存储方式的不同，可以分为三种分类：</p>
<ol>
<li><p>顺序存储：<br>顺序存储是指将线性表的元素按照顺序存储在一块连续的存储空间中。顺序存储可以使用数组来实现，因此顺序存储的线性表也称为顺序表或数组。顺序表的特点是可以通过下标直接访问元素，插入和删除操作需要移动元素。常见的顺序存储结构有静态数组和动态数组。</p>
</li>
<li><p>链式存储：<br>链式存储是指使用节点（Node）来表示线性表的元素，并通过节点之间的指针链接起来。每个节点包含一个数据元素和一个指向下一个节点的指针。链式存储可以实现单链表（单向链表）和双链表（双向链表）。</p>
<ul>
<li><p>单链表（Single Linked List）：每个节点只有一个指针指向下一个节点，最后一个节点的指针指向空（NULL）。</p>
</li>
<li><p>双链表（Double Linked List）：每个节点有两个指针，一个指向前一个节点，一个指向后一个节点。双链表可以支持双向遍历和插入&#x2F;删除操作。</p>
</li>
<li><p>循环链表（Circular Linked List）：循环链表是一种特殊的单链表，它的最后一个节点指向头节点，形成一个循环。循环链表可以通过任意节点遍历整个链表。</p>
</li>
<li><p>静态链表（Static Linked List）：静态链表使用数组来实现链表结构，而不是通过指针。每个节点包含数据元素和一个指向下一个节点在数组中的下标。静态链表的大小是固定的，一般用于没有动态内存分配能力的环境中。</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据结构和面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>7.1 本期学习主要内容</title>
    <url>/2023/09/09/7-1-%E6%9C%AC%E6%9C%9F%E5%AD%A6%E4%B9%A0%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据结构和面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>6.21 指针函数与函数指针</title>
    <url>/2023/09/08/6-21-%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="21-1-函数指针"><a href="#21-1-函数指针" class="headerlink" title="21.1 函数指针"></a>21.1 函数指针</h1><p>函数指针的使用示例可以如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*FuncPtr)</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is function 1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is function 2\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 声明函数指针变量</span></span><br><span class="line">    FuncPtr fp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化函数指针变量</span></span><br><span class="line">    fp = func1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数指针调用函数1</span></span><br><span class="line">    (*fp)(); <span class="comment">// 或者可以简化为 fp();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改函数指针变量的值</span></span><br><span class="line">    fp = func2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数指针调用函数2</span></span><br><span class="line">    (*fp)(); <span class="comment">// 或者可以简化为 fp();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们首先定义了一个函数指针类型 <code>FuncPtr</code>，它可以指向返回类型为 <code>int</code> 的函数。然后，我们定义了两个函数 <code>func1</code> 和 <code>func2</code>，它们都符合函数指针类型 <code>FuncPtr</code> 的定义。</p>
<p>在 <code>main</code> 函数中，我们声明了一个函数指针变量 <code>fp</code>，并将其初始化为指向 <code>func1</code>。然后，我们使用函数指针调用函数1，即 <code>(*fp)();</code> 或者简化为 <code>fp();</code>。接着，我们将函数指针变量 <code>fp</code> 修改为指向 <code>func2</code>，并再次使用函数指针调用函数2。</p>
<p>通过函数指针，我们可以动态地选择、切换和调用不同的函数，以实现更灵活的程序控制和功能。</p>
<h1 id="21-2-函数名本质"><a href="#21-2-函数名本质" class="headerlink" title="21.2 函数名本质"></a>21.2 函数名本质</h1><p>函数名本质上是指向函数的指针，它表示函数的入口地址。</p>
<p>在C语言中，函数名可以被视为函数的指针常量，它存储了函数代码的起始地址。通过函数名，我们可以直接访问和调用函数。</p>
<p>当我们使用函数名时，它会被自动转换为函数指针，指向函数代码的起始地址。因此，我们可以将函数名赋值给函数指针变量，或者直接通过函数名调用函数。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 函数指针变量</span></span><br><span class="line">    <span class="type">void</span> (*functionPtr)();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将函数名赋值给函数指针变量</span></span><br><span class="line">    functionPtr = myFunction;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">    functionPtr();  <span class="comment">// 或者可以简化为 (*functionPtr)();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个函数 <code>myFunction</code>，它不带任何参数，并打印一条消息。在 <code>main</code> 函数中，我们声明了一个函数指针变量 <code>functionPtr</code>，它指向无参数且无返回值的函数。</p>
<p>然后，我们将函数名 <code>myFunction</code> 赋值给函数指针变量 <code>functionPtr</code>。通过函数指针调用函数时，我们可以使用 <code>functionPtr()</code> 或者 <code>(*functionPtr)()</code> 的语法来调用函数。</p>
<p>因此，函数名本质上是指向函数代码起始地址的指针，它提供了一种方便的方式来访问和调用函数。</p>
<p>我们有以下代码段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int func(int a, int b);</span><br><span class="line">int (*fp) = func;</span><br><span class="line">(***fp)(1, 2);</span><br></pre></td></tr></table></figure>

<ol>
<li><code>int func(int a, int b);</code> 定义了一个名为 <code>func</code> 的函数，接受两个 <code>int</code> 类型的参数并返回 <code>int</code> 类型的值。</li>
<li><code>int (*fp) = func;</code> 声明了一个函数指针变量 <code>fp</code>，它指向具有相同参数和返回值类型的函数 <code>func</code>。在这里，<code>func</code> 函数名被隐式转换为函数指针，即 <code>&amp;func</code>，并将其赋值给函数指针变量 <code>fp</code>。</li>
<li><code>(***fp)(1, 2);</code> 使用三次间接访问运算符 <code>*</code>，间接调用了函数 <code>func</code>。这是因为 <code>fp</code> 是一个函数指针，所以我们需要通过解引用运算符来调用它所指向的函数。这里使用三个间接访问运算符是因为 <code>fp</code> 是一个指向函数指针的指针的指针。参数 <code>(1, 2)</code> 传递给函数 <code>func</code>。</li>
<li><code>fp</code> 表示函数指针变量 <code>fp</code>，它可以被用于调用函数或者传递给其他函数进行使用。</li>
</ol>
<h1 id="22-3-指针函数"><a href="#22-3-指针函数" class="headerlink" title="22.3 指针函数"></a>22.3 指针函数</h1><p>指针函数（Pointer to Function）是一个函数，其返回值是一个指针。指针函数可以像普通函数一样执行特定的操作，但其返回值是一个指针类型，指向某个数据类型的内存地址。指针函数的返回值可以用于动态分配内存、返回数组、链表等数据结构。</p>
<p><code>int * func(int a, int b);</code> 是一个指针函数的声明。</p>
<p>该声明表示 <code>func</code> 是一个函数，它接受两个 <code>int</code> 类型的参数 <code>a</code> 和 <code>b</code>，并返回一个 <code>int</code> 类型的指针。</p>
<p>在函数声明中，<code>*</code> 出现在函数名 <code>func</code> 前面，表示函数的返回值是一个指针。在这个例子中，返回值类型是 <code>int *</code>，即指向整型数据的指针。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.19 二级指针：指针数组传参</title>
    <url>/2023/09/08/6-19-%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%EF%BC%9A%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数组作为函数参数时<br>一维数组:数组名隐式转换为首元素地址——一级指针<br>指针数组:首元素地址，即指针的地址———二级指针</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309092019961.png" alt="image-20230909165453909"></p>
<p>对于给定的实参和形参类型，以下是它们之间的匹配关系：</p>
<ol>
<li><p><code>int a[5]</code> 匹配 <code>int a[]</code> 或 <code>int *p</code>：<br>实参是一个具有5个整型元素的数组。在函数调用时，可以匹配形参为可变长度的数组（省略数组大小）或指针类型的形参。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void f(int a[], int len) &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">````c</span><br><span class="line">void f(int *p, int len) &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>int *a[5]</code> 匹配 <code>int **p</code> 或 <code>int *a[]</code>：<br>实参是一个具有5个整型指针元素的数组。在函数调用时，可以匹配形参为指向指针的指针（二级指针）或指针数组类型的形参。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void f(int **p) &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">````c</span><br><span class="line">void f(int *a[]) &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>int (*p)[5]</code> 匹配 <code>int (*p)[5]</code>：<br>实参是一个指向具有5个整型元素的数组的指针。在函数调用时，可以匹配形参为指向具有5个整型元素的数组的指针类型的形参。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void f(int (*p)[5]) &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>int a[4][5]</code> 匹配 <code>int (*p)[5]</code>：<br>实参是一个具有4行5列的二维整型数组。在函数调用时，可以匹配形参为指向具有5个整型元素的数组的指针类型的形参。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void f(int (*p)[5]) &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.18 二级指针：修改指针变量</title>
    <url>/2023/09/08/6-18-%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%EF%BC%9A%E4%BF%AE%E6%94%B9%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="18-1-二级指针示例："><a href="#18-1-二级指针示例：" class="headerlink" title="18.1 二级指针示例："></a>18.1 二级指针示例：</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;a;</span><br><span class="line">    <span class="type">int</span> **pp = &amp;p;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a: %d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p: %d\n&quot;</span>, *p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**pp: %d\n&quot;</span>, **pp);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a: %p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;p: %p\n&quot;</span>, &amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;pp: %p\n&quot;</span>, &amp;pp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p: %p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pp: %p\n&quot;</span>, pp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="18-2-修改指针变量值"><a href="#18-2-修改指针变量值" class="headerlink" title="18.2 修改指针变量值"></a>18.2 修改指针变量值</h1><p>二级指针可以用于修改指针变量的值。通过将一个指针变量的地址传递给二级指针，可以通过二级指针来修改指针变量的值。这在某些情况下可以方便地在函数内部修改指针变量的指向。</p>
<p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void updatePointer(int **ptr) &#123;</span><br><span class="line">    int newValue = 20;</span><br><span class="line">    *ptr = &amp;newValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    int value = 10;</span><br><span class="line">    int *ptr = &amp;value;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Before update: %d\n&quot;, *ptr);</span><br><span class="line">    updatePointer(&amp;ptr);</span><br><span class="line">    printf(&quot;After update: %d\n&quot;, *ptr);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line">在上面的示例中，`updatePointer` 函数接收一个二级指针 `ptr`，并将其指向的一级指针指向一个新的整型变量。在 `main` 函数中，我们将指针变量 `ptr` 的地址传递给 `updatePointer` 函数，并打印了更新后的指针变量的值。</span><br></pre></td></tr></table></figure>

<h1 id="18-3-指针数组传参："><a href="#18-3-指针数组传参：" class="headerlink" title="18.3 指针数组传参："></a>18.3 指针数组传参：</h1><p>二级指针也常用于指针数组（数组中的每个元素都是指针）的传参。通过二级指针，可以传递指针数组的地址，从而在函数内部操作指针数组的元素。</p>
<p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void printStrings(char **arr, int size) &#123;</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    char *strings[] = &#123;&quot;Hello&quot;, &quot;World&quot;, &quot;C&quot;, &quot;Programming&quot;&#125;;</span><br><span class="line">    int size = sizeof(strings) / sizeof(strings[0]);</span><br><span class="line"></span><br><span class="line">    printStrings(strings, size);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line">在上面的示例中，`printStrings` 函数接收一个二级指针 `arr` 和数组的大小，然后在循环中打印指针数组中的字符串。在 `main` 函数中，我们定义了一个指针数组 `strings`，并通过传递数组名和大小来调用 `printStrings` 函数。</span><br></pre></td></tr></table></figure>

<p>二级指针可以提供更高级的灵活性，允许在函数间传递和修改指</p>
<p>二级指针:指针数组</p>
]]></content>
  </entry>
  <entry>
    <title>6.17 指针与结构体</title>
    <url>/2023/09/08/6-17-%E6%8C%87%E9%92%88%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="17-1-指针和结构体之间的相关运算符："><a href="#17-1-指针和结构体之间的相关运算符：" class="headerlink" title="17.1 指针和结构体之间的相关运算符："></a>17.1 指针和结构体之间的相关运算符：</h1><ol>
<li><p>成员访问运算符（<code>.</code>）：<br>成员访问运算符用于从结构体变量中访问其成员。它通过结构体变量名后跟一个点号（<code>.</code>），然后是要访问的成员名。</p>
<p>例如，假设有一个名为 <code>student</code> 的结构体变量，其中包含成员 <code>name</code> 和 <code>age</code>，可以使用成员访问运算符来访问它们：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span></span><br><span class="line"><span class="built_in">strcpy</span>(stu.name, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">stu.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, stu.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Age: %d\n&quot;</span>, stu.age);</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员间接访问运算符（<code>-&gt;</code>）：<br>成员间接访问运算符用于从指向结构体的指针中访问结构体的成员。它通过指针变量名后跟一个箭头符号（<code>-&gt;</code>），然后是要访问的成员名。</p>
<p>例如，假设有一个指向结构体的指针 <code>ptr</code>，其中结构体包含成员 <code>num</code>，可以使用成员间接访问运算符来访问它：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">ptr</span> =</span> &amp;stu;</span><br><span class="line">ptr-&gt;num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Number: %d\n&quot;</span>, ptr-&gt;num);</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体成员取址运算符（<code>&amp;</code>）：<br>结构体成员取址运算符用于获取结构体中特定成员的地址。它通过结构体变量名后跟一个点号（<code>.</code>）和要取址的成员名，然后再加上一个取址运算符（<code>&amp;</code>）。</p>
<p>例如，假设有一个结构体变量 <code>stu</code>，其中包含成员 <code>num</code>，可以使用结构体成员取址运算符来获取 <code>num</code> 的地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span></span><br><span class="line"><span class="type">int</span> *ptr = &amp;stu.num;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体成员自增运算符（<code>++</code>）：<br>结构体成员自增运算符用于递增结构体中的成员的值。它可以作为前缀或后缀运算符使用，即 <code>++stu.num</code> 或 <code>stu.num++</code>。</p>
<p>例如，假设有一个结构体变量 <code>stu</code>，其中包含成员 <code>num</code>，可以使用结构体成员自增运算符来递增 <code>num</code> 的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span></span><br><span class="line">stu.num = <span class="number">10</span>;</span><br><span class="line">++stu.num; <span class="comment">// 或 stu.num++;</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>间接访问运算符（<code>*</code>）：<br>间接访问运算符用于从指针指向的地址中获取存储的值。它通过指针变量前加一个星号（<code>*</code>）来实现。</p>
<p>例如，假设有一个指向结构体的指针 <code>ptr</code>，可以使用间接访问运算符来获取指针指向的结构体变量的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">ptr</span> =</span> &amp;stu;</span><br><span class="line">stu.num = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> value = *ptr; <span class="comment">// 获取指针指向的结构体变量的值</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>示例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> =</span> &#123;<span class="number">1001</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&quot;jim&quot;</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stu.num: %d\n&quot;</span>, stu.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stu.sex: %c\n&quot;</span>, stu.sex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stu.name: %s\n&quot;</span>, stu.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stu.age: %d\n&quot;</span>, stu.age);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">p</span>;</span></span><br><span class="line">    p = &amp;stu;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(*p).num: %d\n&quot;</span>, (*p).num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(*p).sex: %c\n&quot;</span>, (*p).sex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(*p).name: %s\n&quot;</span>, (*p).name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(*p).age: %d\n&quot;</span>, (*p).age);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="17-2-结构体嵌套"><a href="#17-2-结构体嵌套" class="headerlink" title="17.2 结构体嵌套"></a>17.2 结构体嵌套</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> stu_num;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">teacher</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> work_num;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">people</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">stup</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">teacher</span> <span class="title">ter</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> =</span> &#123;<span class="number">1001</span>, <span class="number">99</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">teacher</span> <span class="title">ter</span> =</span> &#123;<span class="number">8001</span>, <span class="number">8000</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">people</span> <span class="title">jim</span> =</span> &#123;<span class="string">&#x27;F&#x27;</span>, <span class="string">&quot;JimGreen&quot;</span>, <span class="number">20</span>, &amp;stu, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">people</span> <span class="title">jack</span> =</span> &#123;<span class="string">&#x27;F&#x27;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="number">50</span>, <span class="literal">NULL</span>, ter&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="17-3-结构体变量作为函数参数"><a href="#17-3-结构体变量作为函数参数" class="headerlink" title="17.3 结构体变量作为函数参数"></a>17.3 结构体变量作为函数参数</h1><p>当结构体变量作为函数参数时，可以通过值传递或指针传递的方式将结构体传递给函数。下面是两种传递结构体变量给函数的方法：</p>
<ol>
<li><p>值传递方式：<br>在值传递方式中，函数接收结构体变量的副本。这意味着函数对结构体的修改不会影响原始的结构体变量。函数的参数类型应该为结构体类型。</p>
<p>示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStudent</span><span class="params">(<span class="keyword">struct</span> student stu)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ID: %d\n&quot;</span>, stu.id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, stu.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> =</span> &#123;<span class="number">1001</span>, <span class="string">&quot;John Doe&quot;</span>&#125;;</span><br><span class="line">    printStudent(stu);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line">在上面的示例中，`printStudent` 函数通过值传递方式接收结构体变量 `stu` 的副本，并打印结构体的成员。</span><br></pre></td></tr></table></figure>
</li>
<li><p>指针传递方式：<br>在指针传递方式中，函数接收指向结构体的指针，可以通过指针直接修改原始的结构体变量。函数的参数类型应该为指向结构体的指针类型。</p>
<p>示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateStudent</span><span class="params">(<span class="keyword">struct</span> student *stu)</span> &#123;</span><br><span class="line">    stu-&gt;id = <span class="number">2001</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(stu-&gt;name, <span class="string">&quot;Jane Smith&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> =</span> &#123;<span class="number">1001</span>, <span class="string">&quot;John Doe&quot;</span>&#125;;</span><br><span class="line">    updateStudent(&amp;stu);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ID: %d\n&quot;</span>, stu.id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, stu.name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line">在上面的示例中，`updateStudent` 函数通过指针传递方式接收指向结构体的指针，并通过指针修改结构体的成员。在 `main` 函数中，我们传递了结构体变量 `stu` 的地址给 `updateStudent` 函数，并打印了更新后的结构体成员。</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.16 指针与数组的暧昧：数值指针与指针数组</title>
    <url>/2023/09/08/6-16-%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E6%9A%A7%E6%98%A7%EF%BC%9A%E6%95%B0%E5%80%BC%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>指针数组 数组指针，他们的重点都是再后面的这个词语里。</p>
<h1 id="16-1-指针数组"><a href="#16-1-指针数组" class="headerlink" title="16.1 指针数组"></a>16.1 指针数组</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *season[<span class="number">4</span>] = &#123;<span class="string">&quot;Spring&quot;</span>, <span class="string">&quot;Summer&quot;</span>, <span class="string">&quot;Autumn&quot;</span>, <span class="string">&quot;Winter&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello %s!\n&quot;</span>, season[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello Spring!</span><br><span class="line">Hello Summer!</span><br><span class="line">Hello Autumn!</span><br><span class="line">Hello Winter!</span><br></pre></td></tr></table></figure>



<p>最基础的main函数使用的就是指针数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="16-2-数组指针"><a href="#16-2-数组指针" class="headerlink" title="16.2 数组指针"></a>16.2 数组指针</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> (*pa)[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    pa = a;</span><br><span class="line">    p = a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pa: %p pa+1: %p\n&quot;</span>, pa, pa + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p: %p p+1: %p\n&quot;</span>, p, p + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pa = &amp;a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pa[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    p = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的功能是打印出数组 <code>a</code> 的一些信息。修正后的代码将按照以下顺序输出内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pa: 0x7ffdd1e2a000 pa+1: 0x7ffdd1e2a010</span><br><span class="line">p: 0x7ffdd1e2a020 p+1: 0x7ffdd1e2a024</span><br><span class="line">4 5 6 7</span><br><span class="line">4 5 6 7</span><br></pre></td></tr></table></figure>

<p>请注意，修正后的代码中已经修复了拼写错误，并且在打印指针时使用了 <code>%p</code> 格式说明符。此外，修正后的代码在循环中正确地使用了数组元素 <code>pa[0][i]</code> 和 <code>p[i]</code> 来输出数组的值。</p>
]]></content>
  </entry>
  <entry>
    <title>6.15 指针与数组的暧昧：数组名</title>
    <url>/2023/09/08/6-15-%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E6%9A%A7%E6%98%A7%EF%BC%9A%E6%95%B0%E7%BB%84%E5%90%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="15-1-数组名是一个常量指针吗"><a href="#15-1-数组名是一个常量指针吗" class="headerlink" title="15.1 数组名是一个常量指针吗?"></a>15.1 数组名是一个常量指针吗?</h1><p>数组名在C语言中被解释为一个常量指针（const pointer）。</p>
<p>具体解释如下：</p>
<ol>
<li>数组名表示数组的首个元素的地址。它是一个指针常量，即指针的值（即内存地址）不能被修改。</li>
<li>数组名的值是一个常量，不允许对其进行赋值操作。</li>
<li>数组名可以进行自增（<code>++</code>）和自减（<code>--</code>）操作，但这实际上是对指针进行操作，将指针移动到下一个或上一个元素的位置。</li>
<li>数组名可以被用于解引用操作符<code>*</code>，例如<code>*arr</code>，它等效于<code>arr[0]</code>，表示获取数组的首个元素的值。</li>
</ol>
<p>需要注意的是，虽然数组名被解释为一个常量指针，但数组中的元素可以被修改。例如，对于<code>int arr[] = &#123;1, 2, 3&#125;;</code>，可以通过<code>arr[0] = 10;</code>来修改数组的元素。</p>
<h1 id="15-2-数组名的隐式转换"><a href="#15-2-数组名的隐式转换" class="headerlink" title="15.2 数组名的隐式转换"></a>15.2 数组名的隐式转换</h1><p>数组名在许多情况下会发生隐式转换，具体取决于上下文。下面是关于数组名的一些常见情况和行为：</p>
<ol>
<li><p>数组类型：数组名表示整个数组的类型。例如，对于声明 <code>int arr[5];</code>，数组名 <code>arr</code> 的类型是 <code>int[5]</code>。</p>
</li>
<li><p>声明：在变量声明中，数组名用于指定变量名并指示其类型为数组类型。例如，<code>int arr[5];</code> 声明了一个名为 <code>arr</code> 的数组变量。</p>
</li>
<li><p>使用 <code>sizeof</code>：对数组名应用 <code>sizeof</code> 运算符将返回整个数组所占用的内存大小。例如，<code>sizeof(arr)</code> 返回整个数组 <code>arr</code> 所占用的字节数。</p>
</li>
<li><p>取址运算符 <code>&amp;</code>：对数组名应用取址运算符 <code>&amp;</code> 将返回数组的首个元素的地址。例如，<code>&amp;arr[0]</code> 或 <code>&amp;arr</code> 都可以获得数组 <code>arr</code> 的首个元素的地址。</p>
</li>
<li><p>右值：在大多数情况下，数组名被视为右值，即它代表了数组的首个元素的地址，而不是可以进行赋值的左值。因此，不能对数组名进行赋值操作。</p>
</li>
<li><p>间接访问运算符 <code>*</code>：通过对数组名应用间接访问运算符 <code>*</code>，可以获取数组的首个元素的值。例如，<code>*arr</code> 等效于 <code>arr[0]</code>，表示获取数组 <code>arr</code> 的首个元素的值。这样的表达式可以作为左值使用，允许对其进行赋值操作。</p>
</li>
<li><p>为什么不能对数组直接赋值？<br>在C语言中，数组是一组连续存储的元素，其大小在编译时就已经确定。因此，数组在内存中占据了一块固定大小的连续空间。由于数组名被解释为指向数组首元素的常量指针，它本身不是一个可修改的左值。</p>
</li>
</ol>
<p>当我们使用数组名进行赋值操作时，实际上是试图将一个指针（数组名）赋值给另一个指针，这是不允许的。赋值操作需要一个左值作为目标，而数组名并不是一个左值。</p>
<p>例如，以下代码是不合法的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[5];</span><br><span class="line">int arr2[5];</span><br><span class="line">arr = arr2;  // 错误！试图对数组名进行赋值操作</span><br></pre></td></tr></table></figure>

<p>如果我们想要将一个数组的值复制到另一个数组，可以使用循环或者库函数（如<code>memcpy</code>）来逐个复制数组元素。</p>
<ol>
<li>为什么只有在初始化的时候赋值？<br>在C语言中，数组的初始化是在定义数组时将一组初始值赋给数组元素的过程。数组的初始化只能在定义数组时进行，之后就不能再对整个数组进行赋值操作。</li>
</ol>
<p>这是因为数组在定义时需要分配一块内存空间来存储元素，并且在编译时就确定了数组的大小。编译器会根据初始化时提供的初始值来确定数组的元素个数，并在内存中为数组分配足够的空间。</p>
<p>一旦数组初始化完成，数组的大小和元素个数就被固定下来了。因此，无法再通过直接的赋值操作来改变整个数组的值。我们只能通过访问和修改数组的单个元素来改变数组的内容。</p>
<p>例如，以下代码是合法的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[5] = &#123;1, 2, 3, 4, 5&#125;;  // 定义数组并初始化</span><br><span class="line">arr[0] = 10;                   // 修改数组的第一个元素的值</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们可以在定义数组时使用初始化列表来初始化数组的元素。然后，我们可以通过索引访问数组的单个元素，并对其进行赋值操作来修改数组的值。但是无法对整个数组进行直接的赋值操作。</p>
<p>指针与数组的暧昧天系:指针数组与数组指针</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.14 指针与数组的暧昧：下标运算</title>
    <url>/2023/09/08/6-14-%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E6%9A%A7%E6%98%A7%EF%BC%9A%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="14-1-指针和数组之间的主要区别"><a href="#14-1-指针和数组之间的主要区别" class="headerlink" title="14.1 指针和数组之间的主要区别"></a>14.1 指针和数组之间的主要区别</h1><p>指针和数组在C语言中有密切的关系，并且它们之间有一些区别。以下是指针和数组之间的主要区别和关系：</p>
<ol>
<li>指针与数组的暧昧关系：<ul>
<li>在C语言中，数组名可以被视为指向数组第一个元素的指针。因此，数组名可以用作指针来访问数组元素。</li>
<li>例如，如果有一个整数数组<code>int arr[5]</code>，则<code>arr</code>可以被视为指向<code>arr[0]</code>的指针。</li>
</ul>
</li>
<li>数组与指针的区别：<ul>
<li>数组是一组固定长度的相同类型元素的集合，它们在内存中是连续存储的。</li>
<li>指针是一个变量，存储了一个内存地址，它可以指向任意类型的数据。</li>
<li>数组在创建后，其大小是固定的，不可更改；而指针可以根据需要指向不同的内存地址。</li>
</ul>
</li>
<li>间接访问与直接访问：<ul>
<li>通过指针间接访问数据，意味着使用指针来获取或修改指向的内存中的值。通过解引用操作符<code>*</code>来实现间接访问。</li>
<li>通过数组直接访问数据，意味着使用数组名和索引来直接访问数组中的元素。</li>
</ul>
</li>
<li>用途：<ul>
<li>指针通常用于动态内存分配，例如在堆上分配内存，以及在数据结构中使用指针来创建链表、树等数据结构。</li>
<li>数组用于存储一组固定长度的相同类型元素，可以方便地访问和处理这些元素。数组在编程中经常用于存储和处理数据集合，例如存储学生成绩、字母表等。</li>
</ul>
</li>
</ol>
<h1 id="14-2-引用方式"><a href="#14-2-引用方式" class="headerlink" title="14.2 引用方式"></a>14.2 引用方式</h1><p>指针可以使用间接访问（解引用操作符<code>*</code>）来访问数组元素，而数组可以使用索引操作符<code>[]</code>来访问数组元素。下面解释了为什么可以这样做：</p>
<ol>
<li><p>指针使用间接访问访问数组元素：</p>
<ul>
<li>指针是一个变量，存储了一个内存地址。当指针指向数组的首个元素时，可以使用指针进行间接访问来获取或修改数组元素的值。</li>
<li>解引用操作符<code>*</code>用于间接访问指针所指向的内存地址中的值。当将指针与解引用操作符<code>*</code>结合使用时，可以获取或修改指针指向的数组元素的值。</li>
</ul>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[] = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">int *ptr = arr;  // 将指针指向数组的首个元素</span><br><span class="line">int value = *ptr;  // 通过指针间接访问数组元素</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组使用索引访问数组元素：</p>
<ul>
<li>数组是一组连续存储的相同类型元素。数组名代表了数组的首个元素的地址。可以使用索引操作符<code>[]</code>来访问数组中的元素。</li>
<li>索引操作符<code>[]</code>接受一个整数索引，用于指定要访问的数组元素的位置。通过使用数组名和索引，可以直接访问数组元素的值。</li>
</ul>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[] = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">int value = arr[2];  // 直接访问数组元素</span><br><span class="line">```</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="14-3-重要"><a href="#14-3-重要" class="headerlink" title="14.3 重要"></a>14.3 重要</h1><p>在C语言中，表达式<code>E1[E2]</code>等价于<code>*(E1 + E2)</code>。这是因为在C语言中，指针算术运算定义了指针与整数之间的操作。</p>
<p>具体解释如下：</p>
<ol>
<li><code>E1</code>是一个指针，<code>E2</code>是一个整数。</li>
<li><code>E1[E2]</code>表示对指针<code>E1</code>进行偏移，偏移量为<code>E2</code>个元素的大小。</li>
<li>当对指针<code>E1</code>进行偏移时，首先将<code>E1</code>与<code>E2</code>相加，得到一个新的指针，该指针指向<code>E1</code>所指向的内存地址加上<code>E2</code>个元素的大小的位置。</li>
<li>最后，使用解引用操作符<code>*</code>对新的指针进行间接访问，获取该位置上的值。</li>
</ol>
<p>举个例子来说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[] = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">int* ptr = arr;  // 指针指向数组的首个元素</span><br><span class="line"></span><br><span class="line">int value1 = arr[2];      // 直接访问数组元素，等价于 *(arr + 2)</span><br><span class="line">int value2 = 2[arr];      // 使用 E1[E2] 访问数组元素，等价于 *(arr + 2)</span><br><span class="line"></span><br><span class="line">printf(&quot;%d\n&quot;, value1);  // 输出：3</span><br><span class="line">printf(&quot;%d\n&quot;, value2);  // 输出：3</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>arr[2]</code>和<code>2[arr]</code>都是访问数组<code>arr</code>中的第3个元素，它们的结果都是3。这是因为它们等价于<code>*(arr + 2)</code>，即指针<code>arr</code>加上偏移量2，然后通过解引用操作符<code>*</code>来访问对应的内存位置。</p>
<p>这种等价关系允许我们使用<code>E1[E2]</code>的形式来访问数组元素，尽管它的语法看起来有些奇怪，但在逻辑上是等价的，并且在某些特定的情况下可以增加代码的可读性。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.13 指针类型与运算</title>
    <url>/2023/09/08/6-13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="13-1-什么是类型"><a href="#13-1-什么是类型" class="headerlink" title="13.1 什么是类型"></a>13.1 什么是类型</h1><p>类型（Type）是指编程语言中用于定义数据的属性和操作的概念。它描述了数据的特征、存储方式和允许的操作。每个类型都有一组特定的值和相应的操作，用于处理这些值。</p>
<p>在编程中，类型可以分为多种，包括整数类型、浮点数类型、字符类型、布尔类型、指针类型等。每种类型都有其特定的值范围和可用的操作。</p>
<p>以整数类型为例，它可以表示一定范围内的整数值，并支持基本的算术运算（加、减、乘、除）和比较运算（大小比较等）。不同的整数类型可能具有不同的值范围和所占的存储空间。</p>
<p>另外，您提到了字符类型（char）。在许多编程语言中，字符类型表示单个字符，例如字母、数字或特殊字符。对于字符类型，您可以执行类似整数类型的加减乘除运算，以及比较大小等操作。</p>
<p>指针类型是一种特殊的类型，用于存储内存地址。指针可以指向其他数据类型的变量，允许我们通过间接访问来操作和修改存储在内存中的数据。</p>
<h1 id="13-2-指针分类"><a href="#13-2-指针分类" class="headerlink" title="13.2 指针分类"></a>13.2 指针分类</h1><p>指针可以根据指向的内容的类型进行分类。以下是一些常见的指针类型分类：</p>
<ol>
<li>函数指针（Function Pointers）：<ul>
<li>函数指针是指向函数的指针变量。</li>
<li>它们可以用于存储和调用函数的地址。</li>
<li>函数指针的类型与所指向的函数的返回类型和参数类型相匹配。</li>
</ul>
</li>
<li>对象指针（Object Pointers）：<ul>
<li>对象指针是指向对象或数据结构的指针变量。</li>
<li>它们用于访问和操作堆上分配的对象或数据结构。</li>
<li>对象指针的类型与所指向的对象或数据结构的类型相匹配。</li>
</ul>
</li>
<li>基本类型指针（Primitive Type Pointers）：<ul>
<li>基本类型指针是指向基本数据类型（如char、int、long等）的指针变量。</li>
<li>它们用于访问和操作所指向的基本类型的值。</li>
</ul>
</li>
<li>结构体指针（Struct Pointers）：<ul>
<li>结构体指针是指向结构体的指针变量。</li>
<li>它们用于访问和操作所指向结构体的成员。</li>
</ul>
</li>
<li>数组指针（Array Pointers）：<ul>
<li>数组指针是指向数组的指针变量。</li>
<li>它们用于访问和操作所指向的数组的元素。</li>
</ul>
</li>
<li>二级指针（Double Pointers）：<ul>
<li>二级指针是指向指针的指针变量。</li>
<li>它们用于操作和传递指针的地址。</li>
</ul>
</li>
<li>Void指针（Void Pointers）：<ul>
<li>Void指针是一种通用指针，可以指向任意类型的数据。</li>
<li>它们用于在不知道具体类型的情况下操作内存。</li>
</ul>
</li>
</ol>
<h1 id="13-3-指针运算"><a href="#13-3-指针运算" class="headerlink" title="13.3 指针运算"></a>13.3 指针运算</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">short</span> *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> *r = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, q + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, r + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="13-4-指针相减"><a href="#13-4-指针相减" class="headerlink" title="13.4 指针相减"></a>13.4 指针相减</h1><p>指针与指针相减可以用来计算它们在内存中的距离。以下是关于指针相减的一些重要点：</p>
<ol>
<li>类型要一致：在进行指针相减操作时，两个指针必须具有相同的类型。这是因为指针的类型确定了它们在内存中所指向的数据单元的大小。</li>
<li>相减操作：指针相减的结果是一个整数值，表示两个指针之间的偏移量。它表示以数据类型的长度（使用<code>sizeof</code>运算符获取）为单位的距离。</li>
<li>表示内存距离：指针相减的结果表示两个指针之间的内存距离。这个距离的单位取决于所使用的数据类型。通常，它以字节或数组元素为单位，取决于所涉及的具体情况。<ul>
<li>以字节为单位：如果两个指针指向相同类型的单个字节（如<code>char</code>类型），则指针相减的结果表示两个指针之间的字节偏移量。</li>
<li>以数组元素为单位：如果两个指针指向同一数组中的元素（如<code>int</code>类型），则指针相减的结果表示两个元素之间的偏移量。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.12 一些复杂的指针声明</title>
    <url>/2023/09/08/6-12-%E4%B8%80%E4%BA%9B%E5%A4%8D%E6%9D%82%E7%9A%84%E6%8C%87%E9%92%88%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="12-1-与指针相关的运算符和操作"><a href="#12-1-与指针相关的运算符和操作" class="headerlink" title="12.1 与指针相关的运算符和操作"></a>12.1 与指针相关的运算符和操作</h1><ol>
<li><p>指针声明：</p>
<ul>
<li><code>*</code>：用于声明指针变量。例如，<code>int* ptr;</code>声明了一个名为<code>ptr</code>的指向<code>int</code>类型的指针变量。</li>
</ul>
</li>
<li><p>地址运算符：</p>
<ul>
<li><code>&amp;</code>：用于获取变量的地址。例如，<code>int a = 10; int* ptr = &amp;a;</code>将变量<code>a</code>的地址赋给指针<code>ptr</code>。</li>
</ul>
</li>
<li><p>间接访问运算符：</p>
<ul>
<li><code>*</code>：用于访问指针所指向的内存位置的值。也称为解引用操作符。例如，<code>int a = *ptr;</code>将指针<code>ptr</code>所指向的内存位置的值赋给变量<code>a</code>。</li>
</ul>
</li>
<li><p>后置自增自减运算符：</p>
<ul>
<li><code>++</code>：后置自增运算符，将指针的值增加1。</li>
<li><code>--</code>：后置自减运算符，将指针的值减少1。</li>
<li>例如，<code>ptr++;</code>将指针<code>ptr</code>的值增加1。</li>
</ul>
</li>
<li><p>成员选择运算符：</p>
<ul>
<li><code>.</code>：用于访问结构体或联合体类型的成员。例如，<code>struct Person &#123; char name[20]; int age; &#125;; Person p; p.age = 25;</code></li>
<li><code>-&gt;</code>：用于通过指针访问结构体或联合体类型的成员。例如，<code>Person* ptr = &amp;p; ptr-&gt;age = 30;</code></li>
</ul>
<h1 id="12-2-运算符优先级："><a href="#12-2-运算符优先级：" class="headerlink" title="12.2 运算符优先级："></a>12.2 运算符优先级：</h1><ul>
<li><ul>
<li><p>1级（从高到低）：</p>
<ul>
<li><code>(</code>：函数调用、表达式分组</li>
<li><code>.</code>：成员选择运算符</li>
<li><code>-&gt;</code>：成员选择运算符（用于指针）</li>
<li><code>++</code>：后置自增运算符</li>
<li><code>--</code>：后置自减运算符</li>
<li><code>+</code>：一元正号运算符</li>
</ul>
<p>2级（从高到低）：</p>
<ul>
<li><code>++</code>：前置自增运算符</li>
<li><code>--</code>：前置自减运算符</li>
<li><code>*</code>：指针解引用运算符</li>
<li><code>&amp;</code>：地址运算符</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>SHE-&gt;卢星宇</p>
<h1 id="12-3-混淆定义"><a href="#12-3-混淆定义" class="headerlink" title="12.3 混淆定义"></a>12.3 混淆定义</h1><p>以下是与指针相关的一些定义的解释：</p>
<ol>
<li><code>*p++;</code>：<ul>
<li>这是一个表达式，其中<code>p</code>是一个指针变量。</li>
<li><code>*p</code>表示对指针<code>p</code>所指向的内存位置进行解引用，获取该位置的值。</li>
<li><code>p++</code>表示对指针<code>p</code>进行后置自增操作，将指针向后移动到下一个内存位置。</li>
</ul>
</li>
<li><code>&amp;p++;</code>：<ul>
<li>这是一个无效的表达式。</li>
<li><code>&amp;</code>是地址运算符，用于获取变量的地址。</li>
<li>但是，<code>p++</code>是一个指针的后置自增操作，返回的是指针的值而不是地址，所以不能对其应用地址运算符。</li>
</ul>
</li>
<li><code>&amp;stu.a</code>：<ul>
<li>这是一个表达式，其中<code>stu</code>是一个结构体变量，<code>a</code>是结构体<code>stu</code>的成员。</li>
<li><code>&amp;</code>是地址运算符，用于获取变量的地址。</li>
<li><code>&amp;stu.a</code>表示获取结构体<code>stu</code>中成员<code>a</code>的地址。</li>
</ul>
</li>
<li><code>int *a[10];</code>：<ul>
<li>这是一个声明语句，定义了一个数组<code>a</code>，其中每个元素都是指向<code>int</code>类型的指针。</li>
<li><code>int *a[10]</code>声明了一个包含10个元素的指针数组。</li>
</ul>
</li>
<li><code>int (*a)[80];</code>：<ul>
<li>这是一个声明语句，定义了一个指针<code>a</code>，它指向一个包含80个<code>int</code>类型元素的数组。</li>
<li><code>int (*a)[80]</code>声明了一个指针<code>a</code>，它指向一个包含80个<code>int</code>类型元素的数组。</li>
</ul>
</li>
<li><code>int *f(int);</code>：<ul>
<li>这是一个函数声明，定义了一个名为<code>f</code>的函数，该函数接受一个<code>int</code>类型的参数，并返回一个<code>int</code>类型的指针。</li>
</ul>
</li>
<li><code>int (*f)(int);</code>：<ul>
<li>这是一个声明语句，定义了一个指针<code>f</code>，它指向一个接受一个<code>int</code>类型参数并返回<code>int</code>类型的函数。</li>
</ul>
</li>
<li><code>*(*f)(int);</code>：<ul>
<li>这是一个声明语句，定义了一个指针<code>f</code>，它指向一个函数，该函数接受一个<code>int</code>类型的参数，并返回一个指针。</li>
<li><code>*(*f)(int)</code>声明了一个指针<code>f</code>，它指向一个函数，该函数接受一个<code>int</code>类型的参数，并返回一个指针。</li>
</ul>
</li>
<li><code>int *(*(*f)(int))[101];</code>：<ul>
<li>这是一个声明语句，定义了一个指针<code>f</code>，它指向一个函数，该函数接受一个<code>int</code>类型的参数，并返回一个指向指针的指针。</li>
<li><code>int *(*(*f)(int))[101]</code>声明了一个指针<code>f</code>，它指向一个函数，该函数接受一个<code>int</code>类型的参数，并返回一个指向指针的指针。</li>
</ul>
</li>
<li><code>int*(*T)[10];</code>：<ul>
<li>这是一个声明语句，定义了一个指针<code>T</code>，它指向一个包含10个<code>int</code>类型指针的数组。</li>
<li><code>int*(*T)[10]</code>声明了一个指针<code>T</code>，它指向一个包含10个<code>int</code>类型指针的数组。</li>
</ul>
</li>
</ol>
<h1 id="12-4-右左法则"><a href="#12-4-右左法则" class="headerlink" title="12.4 右左法则"></a>12.4 右左法则</h1><p>右左法则（Right-Left Rule）是用于解析复杂声明的方法。根据右左法则，我们从最内层的括号开始阅读声明，并向右移动，然后向左移动。每当遇到括号时，我们需要改变阅读方向。一旦解析完括号内的内容，我们跳出括号，继续解析剩余的声明，直到整个声明解析完毕。</p>
<p>以下是使用右左法则解析声明的示例步骤：</p>
<ol>
<li>从最内层的括号开始：<ul>
<li><code>( )</code>：未定义标识符</li>
</ul>
</li>
<li>向右移动：<ul>
<li><code>*</code>：指针</li>
<li><code>(*f)</code>：<code>f</code>是一个指针</li>
</ul>
</li>
<li>向左移动：<ul>
<li><code>(*f)(int)</code>：<code>f</code>是一个接受一个<code>int</code>参数的函数</li>
</ul>
</li>
<li>继续解析：<ul>
<li><code>int (*f)(int)</code>：<code>f</code>是一个接受一个<code>int</code>参数的函数，返回<code>int</code></li>
</ul>
</li>
</ol>
<p>根据右左法则，我们成功解析了声明<code>int (*f)(int)</code>。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.11 从变量到指针</title>
    <url>/2023/09/08/6-11-%E4%BB%8E%E5%8F%98%E9%87%8F%E5%88%B0%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="11-1-动态存储区静态存储区"><a href="#11-1-动态存储区静态存储区" class="headerlink" title="11.1 动态存储区静态存储区"></a>11.1 动态存储区静态存储区</h1><p>在C和C++中，有两种主要的存储区域：动态存储区（Dynamic Storage Area）和静态存储区（Static Storage Area）。</p>
<ol>
<li>动态存储区：<ul>
<li>动态存储区是在程序运行时动态分配和释放的内存区域。</li>
<li>动态存储区的大小和生命周期由程序员显式地管理。</li>
<li>主要通过动态内存分配函数（如<code>malloc</code>、<code>calloc</code>、<code>realloc</code>）来分配内存。</li>
<li>动态存储区中的内存可在程序的不同部分之间共享，并且可以在运行时进行分配和释放。</li>
<li>如果程序员不释放动态分配的内存，可能会导致内存泄漏。</li>
</ul>
</li>
<li>静态存储区：<ul>
<li>静态存储区是在程序编译阶段分配的内存区域。</li>
<li>静态存储区的大小和生命周期在程序运行期间保持不变。</li>
<li>静态存储区主要用于存储静态变量、全局变量以及静态常量。</li>
<li>静态存储区中的内存在程序的整个执行过程中一直存在，并且可以被程序的任何部分访问。</li>
</ul>
</li>
</ol>
<h1 id="11-2-指针"><a href="#11-2-指针" class="headerlink" title="11.2 指针"></a>11.2 指针</h1><p>指针是一种特殊的变量类型，用于存储内存地址。它可以指向其他变量或数据的内存位置，并通过该地址访问和操作存储在该位置上的数据。</p>
<p>指针的原始用途之一是访问一片匿名的动态内存，也称为动态内存分配。通过动态内存分配函数（如<code>malloc</code>、<code>calloc</code>、<code>realloc</code>），可以在程序运行时动态地分配一块内存，并返回其地址给指针。这样，我们可以通过指针来访问和操作这块匿名的动态内存。</p>
<p>使用动态内存分配可以解决以下场景的需求：</p>
<ul>
<li>需要在程序运行时根据实际需要动态地分配内存空间。</li>
<li>需要处理大量或可变数量的数据，而静态变量或栈上的内存空间受限制。</li>
<li>需要在函数调用之间共享数据，而函数的局部变量在函数调用结束时被释放。</li>
</ul>
<p>通过动态内存分配和指针，我们可以动态地创建、使用和销毁内存块，使程序能够更加灵活地处理内存需求。</p>
<h1 id="11-3-从存储角度看指针"><a href="#11-3-从存储角度看指针" class="headerlink" title="11.3 从存储角度看指针"></a>11.3 从存储角度看指针</h1><p>从存储角度来看，指针在内存中存储的是一个地址值，这个地址指向另一个对象或函数的存储位置。下面是关于指针的存储相关的概念：</p>
<ol>
<li>符号（Symbol）：<ul>
<li>在编程语言中，符号是用来表示变量、函数或其他可识别实体的名称。</li>
<li>当我们定义一个指针时，我们为它选择一个符号作为变量名，以便在代码中引用它。</li>
</ul>
</li>
<li>对象指针（Object Pointer）：<ul>
<li>对象指针存储的是指向某个对象的内存地址。</li>
<li>通过对象指针，我们可以访问和操作指向的对象的数据。</li>
</ul>
</li>
<li>函数指针（Function Pointer）：<ul>
<li>函数指针存储的是指向函数的内存地址。</li>
<li>通过函数指针，我们可以调用指向的函数。</li>
</ul>
</li>
</ol>
<p>在内存中，指针本身也是一个变量，它占据一定的存储空间，通常是根据计算机体系结构的位数来确定大小。指针变量存储的是目标对象或函数的内存地址。</p>
<p>总结：<br>从存储角度来看，指针存储的是一个地址值，用于指向其他对象或函数的存储位置。指针本身是一个变量，占据一定的存储空间。通过指针，我们可以访问和操作指向的对象的数据，或者调用指向的函数。</p>
<h1 id="11-4-指针为什么要有类型"><a href="#11-4-指针为什么要有类型" class="headerlink" title="11.4 指针为什么要有类型"></a>11.4 指针为什么要有类型</h1><p>指针之所以要有类型，主要有两个原因：</p>
<ol>
<li>编译器类型检查：<ul>
<li>类型信息是编译器进行静态类型检查的基础，它能够在编译时检测出类型错误。</li>
<li>指针的类型信息告诉编译器指针所指向的数据的类型，从而确保在编译过程中对指针进行正确的操作。</li>
<li>编译器可以根据指针的类型检查指针的赋值、解引用、指针运算等操作是否符合语法和类型规则。</li>
</ul>
</li>
<li>指定其指向数据的类型：<ul>
<li>指针的类型不仅提供了类型检查的功能，还指定了指针所指向的数据的类型。</li>
<li>通过指针的类型信息，我们可以知道在解引用指针时应该如何解释所指向的内存数据。</li>
<li>指针的类型决定了指针操作的语义，如指针运算的步长以及对指针进行的类型转换。</li>
</ul>
</li>
</ol>
<h1 id="11-5-指针-地址"><a href="#11-5-指针-地址" class="headerlink" title="11.5 指针&#x3D;&#x3D;地址?"></a>11.5 指针&#x3D;&#x3D;地址?</h1><p>指针和地址在概念上是相关的，但它们并不完全相同。</p>
<p>指针是一种变量类型，用于存储内存地址。它可以指向其他变量或数据的内存位置，并通过该地址来访问和操作存储在该位置上的数据。</p>
<p>地址是内存中的位置标识，用来唯一标识存储单元的位置。地址可以是一个数字或其他表示内存位置的值。</p>
<p>可以说，指针存储了一个地址值，指向某个特定的内存位置。指针本身是一个变量，占据一定的存储空间，存储的内容是一个地址。</p>
<p>总结：<br>指针是存储内存地址的变量类型，用于指向其他变量或数据的内存位置。地址是内存中的位置标识，用来唯一标识存储单元的位置。指针存储了一个地址值，指向特定的内存位置。</p>
<h1 id="11-6-普通变量和指针变量"><a href="#11-6-普通变量和指针变量" class="headerlink" title="11.6 普通变量和指针变量"></a>11.6 普通变量和指针变量</h1><ol>
<li><p>值的比较：</p>
<ul>
<li>普通变量之间的比较是直接比较它们的值。例如，<code>a == b</code>会比较变量<code>a</code>和<code>b</code>的值是否相等。</li>
<li>指针变量之间的比较是比较它们所存储的地址值是否相等。例如，<code>p1 == p2</code>会比较指针变量<code>p1</code>和<code>p2</code>存储的地址值是否相等。如果它们指向同一个内存位置，那么它们的比较结果为真。</li>
</ul>
</li>
<li><p>空指针的比较：</p>
<ul>
<li>空指针是指未指向任何有效内存地址的指针。</li>
<li>可以使用特殊值<code>NULL</code>（在C语言中）或<code>nullptr</code>（在C++语言中）表示空指针。</li>
<li>比较指针变量与空指针时，可以使用<code>p == NULL</code>或<code>p == nullptr</code>来判断指针是否为空。</li>
</ul>
</li>
<li><p>指针的解引用和值的比较：</p>
<ul>
<li>解引用指针（如<code>*p</code>）可以获取指针所指向的内存位置的值。</li>
<li>指针的解引用操作返回的是所指向内存位置的值，可以与其他值进行比较。</li>
<li>例如，<code>*p == a</code>会比较指针<code>p</code>所指向的内存位置的值是否与变量<code>a</code>的值相等。</li>
</ul>
<h1 id="11-7-指针的优点"><a href="#11-7-指针的优点" class="headerlink" title="11.7 指针的优点"></a>11.7 指针的优点</h1><ol>
<li>动态内存的匿名访问：<ul>
<li>指针允许我们在运行时动态地分配内存，创建匿名的数据结构，并通过指针对其进行访问。</li>
<li>通过使用指针，我们可以在程序运行时根据需要分配和释放内存，而不需要提前知道数据的大小和数量。</li>
</ul>
</li>
<li>参数传递：<ul>
<li>使用指针作为函数参数可以传递数组、结构体和大块缓冲区等复杂数据类型，而不需要进行大规模的数据复制。</li>
<li>通过传递指针，函数可以直接访问和修改原始数据，而不是对副本进行操作，从而提高效率和节省内存。</li>
</ul>
</li>
<li>动态数据结构的实现：<ul>
<li>实现动态数据结构，如链表、树等，通常需要使用指针。</li>
<li>指针可以用来建立节点之间的连接关系，通过指针的指向来遍历和操作数据结构。</li>
</ul>
</li>
<li>字符串指针：<ul>
<li>字符串通常以字符数组的形式表示，而指针可以用来指向字符串的起始位置。</li>
<li>通过使用字符串指针，我们可以方便地对字符串进行操作、传递和比较。</li>
</ul>
</li>
<li>函数指针：<ul>
<li>函数指针可以存储和调用特定类型的函数。</li>
<li>函数指针的应用包括回调函数、动态函数调用和函数指针数组等。</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.9 变量的本质</title>
    <url>/2023/09/08/6-9-%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="9-1-变量名"><a href="#9-1-变量名" class="headerlink" title="9.1 变量名"></a>9.1 变量名</h1><p>通过数据类型定义变量时，您需要指定变量的名称、数据类型和初始值（可选）。下面是变量定义的一般格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;数据类型&gt; &lt;变量名&gt; = &lt;初始值&gt;;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>&lt;数据类型&gt;</code> 是变量的数据类型，例如 <code>int</code>、<code>float</code>、<code>char</code> 等。</li>
<li><code>&lt;变量名&gt;</code> 是您给变量起的名称，遵循命名规则和约定。</li>
<li><code>&lt;初始值&gt;</code> 是可选项，表示变量的初始值。对于某些数据类型，您可以选择提供初始值。</li>
</ul>
<p>以下是一个示例，定义了不同类型的变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">float f = 3.14;</span><br><span class="line">char c = &#x27;A&#x27;;</span><br></pre></td></tr></table></figure>

<p>在存储方面，变量在内存中占据一定的空间来存储其值。每个变量都有一个唯一的内存地址，用于标识其在内存中的位置。这个地址可以通过取变量的地址运算符 <code>&amp;</code> 来获取。</p>
<p>变量的存储方式可以分为两个方面：</p>
<ol>
<li>变量名：变量名是您在代码中使用的标识符，用于引用变量的值。它在代码中作为变量的别名，可以用于读取和修改变量的值。</li>
<li>地址：变量在内存中的存储位置由其地址确定。变量的地址是一个唯一的标识符，可以使用 <code>&amp;</code> 运算符获取。例如，<code>&amp;i</code> 表示变量 <code>i</code> 的地址。</li>
</ol>
<p>.</p>
<h1 id="9-2-总结"><a href="#9-2-总结" class="headerlink" title="9.2 总结"></a>9.2 总结</h1><ul>
<li>定义变量的目标是为了方便在内存中进行数据的读写操作。</li>
<li>编译器通过变量类型来确定为变量分配合适的存储空间和地址。</li>
<li>变量名本质上是内存中一段存储空间的别名，通过变量名可以对这段内存空间进行读写操作。</li>
<li>变量修饰符可以改变变量的存储方式和作用域。</li>
</ul>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.8 内核中的size_t数据类型</title>
    <url>/2023/09/08/6-8-%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84size-t%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="8-1-内核数据类型"><a href="#8-1-内核数据类型" class="headerlink" title="8.1 内核数据类型"></a>8.1 内核数据类型</h1><p>在内核编程中，有一些特定的数据类型用于表示和操作内核对象和内核级数据。下面是一些常见的内核数据类型分类：</p>
<ol>
<li>C语言基本数据类型：内核编程通常使用C语言作为开发语言，因此使用C语言的基本数据类型来表示内核级数据。这包括：<ul>
<li>整数类型：如int、char、short、long等。</li>
<li>浮点数类型：如float、double等。</li>
<li>指针类型：如void<em>、int</em>、struct*等。</li>
</ul>
</li>
<li>长度确定的数据类型：在内核编程中，为了确保跨平台的兼容性和数据一致性，有时会使用长度确定的数据类型。这些类型的大小和字节对齐是确定的，不会受编译器或平台的影响。例如：<ul>
<li>uint8_t、int8_t：8位有符号和无符号整数类型。</li>
<li>uint16_t、int16_t：16位有符号和无符号整数类型。</li>
<li>uint32_t、int32_t：32位有符号和无符号整数类型。</li>
<li>uint64_t、int64_t：64位有符号和无符号整数类型。</li>
</ul>
</li>
<li>特定内核对象数据类型：内核编程涉及访问和操作内核对象，因此有一些特定的数据类型用于表示内核对象。这些数据类型通常是由内核提供的结构体或指针类型。例如：<ul>
<li>struct task_struct：表示一个进程的内核对象。</li>
<li>struct file：表示一个打开的文件的内核对象。</li>
<li>struct inode：表示一个文件系统节点的内核对象。</li>
<li>struct semaphore：表示一个信号量的内核对象。</li>
</ul>
</li>
</ol>
<h1 id="8-2-size-t"><a href="#8-2-size-t" class="headerlink" title="8.2 size_t"></a>8.2 size_t</h1><p><code>size_t</code> 是一个在 C 和 C++ 中常见的数据类型，用于表示对象的大小或长度。它通常是一个无符号整数类型，并且在不同的平台上具有相同的字节大小。</p>
<p>为了避免与用户定义的标识符冲突，C 标准和 C++ 标准将一些特殊的类型定义为以 <code>_t</code> 结尾的标识符。因此，<code>size_t</code> 是一个以 <code>_t</code> 结尾的类型名。这种命名约定有助于提高代码的可读性和可移植性。</p>
<p><code>size_t</code> 通常用于以下情况：</p>
<ol>
<li>数组索引：它可以用作数组的索引类型，表示数组的大小或长度。例如，<code>size_t index</code> 可以用于迭代数组元素。</li>
<li>数据拷贝长度：在涉及数据拷贝、内存分配和释放等操作时，通常使用 <code>size_t</code> 来表示数据块的大小或长度。例如，<code>size_t length</code> 可以用于指定要拷贝的数据长度。</li>
<li>内存分配：在动态内存分配函数（如 <code>malloc</code>、<code>calloc</code>）中，<code>size_t</code> 通常用于指定要分配的内存块的大小。</li>
<li>文件操作：在处理文件时，<code>size_t</code> 可以用于表示文件的大小或读写操作的字节数。</li>
</ol>
<p>由于 <code>size_t</code> 是无符号整数类型，它适用于表示对象大小或长度，而不涉及正负值。它可以确保不会出现负数情况，并且可以表示较大的对象大小。</p>
<h1 id="8-3-使用size-t的好处"><a href="#8-3-使用size-t的好处" class="headerlink" title="8.3 使用size_t的好处"></a>8.3 使用size_t的好处</h1><p>使用 <code>size_t</code> 的好处有以下几点：</p>
<ol>
<li>数据的可移植性：<code>size_t</code> 的大小是根据平台的特定实现决定的，可以适应不同平台上的不同字节大小。这样可以确保代码在不同的平台上具有相同的行为，并且可以处理不同大小的对象或数据。</li>
<li>最大长度的表示：<code>size_t</code> 的无符号特性使其适合表示数据的最大长度，而不受正负值的限制。它可以表示较大的对象或数据大小，适用于需要处理大型数据或对象的场景。</li>
<li>代码的清晰性和可读性：使用 <code>size_t</code> 明确地表达了代码中涉及大小或长度的概念，使代码更具可读性和清晰性。它可以提供关于数据块大小的明确语义，减少了歧义和误解的可能性。</li>
</ol>
<p>在函数声明或定义中使用 <code>size_t</code> 可以增加代码的可读性和可维护性。例如，您提到的函数 <code>data_copy</code> 的声明中使用了 <code>size_t len</code> 参数，表明该参数表示数据的长度。这使得函数的用途和预期更加清晰，并且在调用函数时，也可以传递相应的 <code>size_t</code> 类型的参数。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.6 数据类型转换</title>
    <url>/2023/09/08/6-6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="6-1-数据类型转换示例"><a href="#6-1-数据类型转换示例" class="headerlink" title="6.1 数据类型转换示例"></a>6.1 数据类型转换示例</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> a = <span class="number">-10</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line">    </span><br><span class="line">    c = a + b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;c &gt; 0\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;c &lt; 0\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">-2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a &lt; b\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a &gt; b\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-2-为什么要类型转换"><a href="#6-2-为什么要类型转换" class="headerlink" title="6.2 为什么要类型转换"></a>6.2 为什么要类型转换</h1><p>类型转换在计算机编程中是常见的操作，它的目的是将一个数据从一种类型转换为另一种类型。下面是一些常见的情况和原因：</p>
<ol>
<li>硬件要求：计算机的CPU在执行运算时有特定的硬件要求，要求操作数的类型、大小和存储方式相同。如果操作数的类型不匹配，就需要进行类型转换以满足硬件要求。</li>
<li>隐式类型转换：在某些情况下，编程语言会自动进行隐式类型转换。例如，当执行不同类型的操作数之间的运算时，编程语言会自动将其中一个操作数转换为另一个操作数的类型，以便执行运算。</li>
<li>强制类型转换：有时，我们需要显式地将一个数据转换为特定的类型。这可以通过强制类型转换操作符来实现。强制类型转换可以用于将一个数据转换为更大或更小的整数类型，或者将一个浮点数类型转换为整数类型等。</li>
</ol>
<p>类型转换的目的是确保数据在运算和操作过程中的一致性和正确性。它可以帮助我们处理不同类型的数据，并使其适应特定的需求和要求。但需要注意的是，类型转换可能会导致数据精度损失或溢出等问题，因此在进行类型转换时需要谨慎处理，确保数据的准确性和安全性。</p>
<h1 id="6-3-转换情况"><a href="#6-3-转换情况" class="headerlink" title="6.3 转换情况"></a>6.3 转换情况</h1><ol>
<li>算术表达式中的自动转换：当进行算术运算时，如果操作数的类型不一致，编程语言会自动将其中一个操作数转换为另一个操作数的类型，以便执行运算。例如，将一个整数和一个浮点数相加，编程语言会将整数自动转换为浮点数，然后执行相加操作。</li>
<li>逻辑表达式中的自动转换：在逻辑运算中，如果操作数的类型不匹配，编程语言会自动进行类型转换以使其类型一致。例如，在一个逻辑表达式中，将一个整数和一个布尔值进行比较，编程语言会将整数自动转换为布尔值的类型，然后执行比较操作。</li>
<li>赋值表达式中的自动转换：当将一个值赋给不同类型的变量时，编程语言会自动进行类型转换以使其类型匹配。例如，将一个整数赋值给一个浮点数类型的变量，编程语言会将整数自动转换为浮点数类型，然后进行赋值操作。</li>
<li>函数形参与实参类型不匹配：当调用函数时，如果函数的形参类型与传递给函数的实参类型不匹配，编程语言会进行自动类型转换。例如，如果函数期望接收一个整数参数，但传递给函数的是一个浮点数，编程语言会将浮点数自动转换为整数类型，然后调用函数。</li>
<li>函数返回值类型与函数类型不匹配：在函数定义时，需要指定函数的返回值类型。如果函数的返回值类型与函数的实际返回值类型不匹配，编程语言会进行自动类型转换。例如，如果函数定义为返回整数类型，但函数内部的计算结果是浮点数，编程语言会将浮点数自动转换为整数类型，然后返回结果。</li>
</ol>
<h1 id="6-4-转换规则"><a href="#6-4-转换规则" class="headerlink" title="6.4 转换规则"></a>6.4 转换规则</h1><ol>
<li>低精度到高精度的隐式转换：当将一个低精度的数据转换为高精度的数据时，通常会发生隐式类型转换。例如，将一个char类型的变量转换为int类型的变量，或将一个float类型的变量转换为double类型的变量。</li>
<li>有符号到无符号的转换：在有符号类型和无符号类型之间进行转换时，编程语言通常会将有符号类型转换为无符号类型。例如，将一个signed int类型的变量转换为unsigned int类型的变量。</li>
<li>整数类型之间的转换：在整数类型之间进行转换时，通常会根据类型的大小和范围进行转换。转换规则是：char -&gt; short -&gt; int -&gt; long -&gt; long long。即，较小的整数类型可以自动转换为较大的整数类型。</li>
<li>浮点类型之间的转换：在浮点类型之间进行转换时，通常会根据类型的精度和范围进行转换。转换规则是：float -&gt; double -&gt; long double。即，较小精度的浮点类型可以自动转换为较大精度的浮点类型。</li>
</ol>
<h1 id="6-5-强制类型转换"><a href="#6-5-强制类型转换" class="headerlink" title="6.5 强制类型转换"></a>6.5 强制类型转换</h1><p>在强制类型转换中，我们可以使用显式的类型转换操作符来将一个类型转换为另一个类型。下面是一些重点关注的强制类型转换情况：</p>
<ol>
<li>char到int的转换：当将一个char类型的值转换为int类型时，值不会改变，但存储格式会发生变化。char类型通常占用一个字节，而int类型通常占用多个字节。将char类型的值转换为int类型时，编程语言会将char的值复制到int类型所占用的字节中，同时进行必要的位扩展来保持符号位的正确性。</li>
<li>int到char的转换：当将一个int类型的值转换为char类型时，可能会发生截断。由于char类型通常只占用一个字节，而int类型占用多个字节，将int类型的值转换为char类型时，编程语言会将int的值截断为char类型所能表示的范围内。如果int的值超出了char类型的表示范围，截断将导致数据的丢失。</li>
<li>signed到unsigned的转换：当将一个有符号类型（如signed int）的值转换为无符号类型（如unsigned int）时，值会发生改变，但存储格式不会发生变化。有符号类型和无符号类型在内存中的存储方式是相同的，只是解释方式不同。将有符号类型的值转换为无符号类型时，编程语言会根据规定的转换规则改变值的解释方式，可能导致符号位的改变和数值的变化。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.5 数据对齐</title>
    <url>/2023/09/08/6-5-%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="6-5-1-什么是数据对齐"><a href="#6-5-1-什么是数据对齐" class="headerlink" title="6.5.1 什么是数据对齐"></a>6.5.1 什么是数据对齐</h1><p>数据对齐是指在内存中分配和存储数据时，按照一定规则将数据放置在内存地址上的对齐位置。对齐是为了优化内存访问效率和处理器的数据访问特性而设计的。数据对齐可以提高程序的性能，并确保数据的正确读取和存储。</p>
<p>数据对齐原则通常包括以下几点：</p>
<ol>
<li>基本类型数据成员按自然边界对齐：基本类型数据（如整数、浮点数）的存储通常要求按照其自然边界进行对齐。例如，一个4字节的整数通常要求在内存中以4字节对齐的方式存储，即其地址是4的倍数。</li>
<li>结构体和类的数据对齐：结构体和类的数据对齐通常要求按照其最大对齐需求的成员进行对齐。结构体或类的对齐需求取决于其成员中对齐需求最高的成员。例如，如果结构体中有一个成员需要8字节对齐，那么整个结构体就要按照8字节对齐。</li>
<li>数据对齐划分：在内存中，数据按照其对齐需求被划分为一系列对齐单元。对齐单元的大小通常是根据系统架构和编译器的规定而定的。对齐单元的大小决定了数据在内存中的对齐位置。</li>
<li>数据未对齐：当数据未按照对齐要求存储时，会导致性能下降或者出现不可预测的行为。例如，当一个8字节的双精度浮点数在内存中以4字节对齐的方式存储时，可能会导致性能损失和访问错误。</li>
</ol>
<h1 id="6-5-2为什么要数据对齐"><a href="#6-5-2为什么要数据对齐" class="headerlink" title="6.5.2为什么要数据对齐?"></a>6.5.2为什么要数据对齐?</h1><p>数据对齐的目的是为了优化内存访问效率和处理器的数据访问特性。以下是一些原因：</p>
<ol>
<li>CPU硬件限制：某些处理器对于数据的访问有特定的要求，例如，某些处理器只能在特定的对齐位置读取或写入数据。如果数据未对齐，处理器可能需要额外的指令或周期来处理这种非对齐的情况，从而导致性能下降。</li>
<li>不同硬件平台对存储空间的管理不同：不同的硬件平台对存储空间的管理可能有不同的要求和规则。数据对齐可以确保程序在不同的硬件平台上具有一致的行为。</li>
<li>简化CPU硬件设计，简化了地址访问：数据对齐可以简化CPU硬件设计和内存访问。当数据按照对齐要求存储时，处理器可以通过简单的地址计算和访问方式来读取或写入数据，而不需要复杂的逻辑或额外的指令。</li>
<li>编译器会根据硬件平台选择合适的对齐方式：编译器可以根据目标硬件平台的要求选择合适的数据对齐方式。编译器可以在编译阶段对数据进行对齐优化，以提高程序的性能和效率。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">short</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;b = %p\n&quot;</span>, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;c = %p\n&quot;</span>, &amp;c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-5-3-结构体对齐"><a href="#6-5-3-结构体对齐" class="headerlink" title="6.5.3 结构体对齐"></a>6.5.3 结构体对齐</h1><p>结构体对齐是指在内存中分配和存储结构体时，按照一定规则将结构体成员放置在内存地址上的对齐位置。结构体对齐的原则包括以下几点：</p>
<ol>
<li>结构体内各成员按各自自然对齐方式：结构体的每个成员都有自己的对齐要求，例如，整型成员通常要求按照其自然边界对齐。对于基本类型的成员，编译器会按照其对齐要求将其放置在合适的内存位置。</li>
<li>结构体整体对齐方式：结构体的整体对齐方式可以按照最大成员的对齐要求进行对齐，或者按照最大成员对齐要求的整数倍进行对齐。这意味着结构体的起始地址和大小都要符合对齐要求。</li>
</ol>
<p>例如，考虑以下的结构体定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct MyStruct &#123;</span><br><span class="line">    char a;</span><br><span class="line">    int b;</span><br><span class="line">    short c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据对齐原则，可以得到以下结构体对齐方式：</p>
<ul>
<li>成员a按照自然边界对齐，占用1字节。</li>
<li>成员b按照4字节对齐，占用4字节。</li>
<li>成员c按照2字节对齐，占用2字节。</li>
</ul>
<p>整体而言，结构体的最大成员是int类型的成员b，它的对齐要求是4字节。因此，整个结构体的对齐方式可以是按照4字节对齐，即结构体的起始地址和大小都是4的整数倍。</p>
<p>结构体对齐的目的是为了优化内存访问效率和处理器的数据访问特性。通过合理对齐结构体的成员，可以减小内存碎片、提高内存访问效率，并确保结构体在不同的硬件平台上具有一致的行为。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">short</span> num;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;stu.sex = %p\n&quot;</span>, &amp;stu.sex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;stu.num = %p\n&quot;</span>, &amp;stu.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;stu.age = %p\n&quot;</span>, &amp;stu.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;struct size: %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> student));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-5-4-联合体（Union）的对齐方式"><a href="#6-5-4-联合体（Union）的对齐方式" class="headerlink" title="6.5.4 联合体（Union）的对齐方式"></a>6.5.4 联合体（Union）的对齐方式</h1><p>联合体（Union）的对齐方式和结构体（Struct）有所不同。联合体的对齐原则包括以下几点：</p>
<ol>
<li>按照最大成员大小分配空间：联合体的内存空间大小取决于最大成员的大小。联合体的大小将足够容纳最大成员。</li>
<li>联合体的对齐：联合体的对齐方式是根据各成员的对齐字节数的最小公倍数来确定。这意味着联合体的起始地址和大小都要满足最小公倍数的要求。</li>
</ol>
<p>以下是一个示例联合体的定义和对齐方式的说明：</p>
<p>c</p>
<p>Copy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union MyUnion &#123;</span><br><span class="line">    char a;</span><br><span class="line">    int b;</span><br><span class="line">    short c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据对齐原则，可以得到以下联合体的对齐方式：</p>
<ul>
<li>成员a的对齐字节数为1字节。</li>
<li>成员b的对齐字节数为4字节。</li>
<li>成员c的对齐字节数为2字节。</li>
</ul>
<p>联合体的最大成员是int类型的成员b，其大小为4字节。因此，联合体的大小将足够容纳最大成员，即4字节。</p>
<p>联合体的对齐方式取决于成员a、b和c的对齐字节数的最小公倍数。在此示例中，最小公倍数为4字节。所以，整个联合体的对齐方式是按照4字节对齐，即联合体的起始地址和大小都是4的整数倍。</p>
<p>需要注意的是，由于联合体的成员共享同一块内存空间，因此在使用联合体时，只能使用一个成员，而不能同时使用多个成员。</p>
<p>联合体的对齐方式的目的是为了确保对齐要求，并提供一致的内存访问规则。它可以在一些特定的场景下提供灵活的数据组织方式和节省内存空间的优势。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.4 数据溢出</title>
    <url>/2023/09/08/6-4-%E6%95%B0%E6%8D%AE%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="6-4-1-数据溢出"><a href="#6-4-1-数据溢出" class="headerlink" title="6.4.1 数据溢出"></a>6.4.1 数据溢出</h1><p>数据溢出指的是当一个变量存储的数据超过了其数据类型所能表示的范围时发生的情况。不同的数据类型具有不同的表示范围，如果存储的数据超过了该范围，就会导致数据溢出。</p>
<p>对于字符型数据类型，包括有符号字符（signed char）和无符号字符（unsigned char）：</p>
<ul>
<li>有符号字符的表示范围是[-128, 127]，其中-128表示最小负数，127表示最大正数。</li>
<li>无符号字符的表示范围是[0, 255]，代表了所有可能的无符号字符值。</li>
</ul>
<p>对于整型数据类型，包括有符号整型（signed int）和无符号整型（unsigned int）：</p>
<ul>
<li>有符号整型的表示范围是[-2,147,483,648, 2,147,483,647]，其中-2,147,483,648表示最小负数，2,147,483,647表示最大正数。</li>
<li>无符号整型的表示范围是[0, 4,294,967,295]，代表了所有可能的无符号整数值。</li>
</ul>
<p>当对一个变量进行赋值或运算时，如果结果超过了该数据类型的表示范围，就会发生数据溢出。数据溢出可能导致结果不正确或不可预料的行为，因为超出范围的值无法正确地表示和处理。在编程中，需要谨慎处理数据范围，避免发生数据溢出的情况。</p>
<h1 id="6-4-2-数据溢出的后果"><a href="#6-4-2-数据溢出的后果" class="headerlink" title="6.4.2 数据溢出的后果"></a>6.4.2 数据溢出的后果</h1><ol>
<li>无符号数的溢出：当无符号数的值超过其表示范围时，会继续从最小值或最大值重新开始，形成一个循环。例如，无符号字符类型的值在范围[0, 255]内循环。例如，如果一个无符号字符变量的值为255，再加1将导致溢出并变为0。</li>
<li>取模运算，继续“轮回”：当对一个数进行取模运算时，如果结果超过了数据类型的表示范围，会继续从最小值或最大值重新开始。例如，对于有符号整型，取模运算会将负数转换为正数。例如，-1 % 5 的结果是4，因为-1被视为是从最大值开始的。</li>
<li>有符号数的溢出：当有符号数的值超过其表示范围时，会发生有符号整数溢出。这种情况下，结果是未定义的，可能会导致不可预料的行为。有符号整数溢出是一种常见的程序错误，需要特别注意。</li>
<li>C语言的宽松性、不作类型安全性检查：C语言在处理数据溢出时比较宽松，不会自动检测和阻止溢出情况。这意味着在进行运算或赋值时，如果结果超过了数据类型的表示范围，C语言不会报错，而是继续计算并使用溢出后的结果。这可能导致程序产生错误的结果，而不会得到警告或报错。</li>
<li>会产生未定义行为：当发生有符号整数溢出或其他未定义行为时，结果是不确定的。这意味着程序的行为可能是不可预测的，可能会导致程序崩溃、产生错误的结果或其他不正常的行为。因此，需要在程序中避免发生数据溢出的情况，以确保程序的正确性和可靠性。</li>
</ol>
<h1 id="6-4-3-如何防范整数溢出"><a href="#6-4-3-如何防范整数溢出" class="headerlink" title="6.4.3 如何防范整数溢出"></a>6.4.3 如何防范整数溢出</h1><ol>
<li>使用适当的数据类型：选择合适的数据类型来存储你的数据，确保数据类型具有足够的范围来容纳可能的值。如果需要处理较大的数值，可以考虑使用长整型（long）或者大整数库（如GMP）来处理。</li>
<li>进行溢出检查：在进行整数运算之前，检查操作数的范围是否适合目标数据类型。可以使用条件语句或断言来检查操作数的范围，确保运算不会导致溢出。</li>
<li>避免无符号数与有符号数混合运算：在进行整数运算时，尽量避免无符号数与有符号数混合运算，因为这可能会导致意外的结果。如果必须进行混合运算，将有符号数转换为无符号数或者进行显示的类型转换，以确保运算结果的正确性。</li>
<li>使用安全的算法和库函数：在进行数值计算时，选择使用已经经过测试和验证的安全算法和库函数。这些算法和库函数通常会考虑整数溢出的问题，并提供了溢出检查和处理机制。</li>
<li>编写健壮的代码：编写健壮的代码意味着要考虑到可能出现的异常情况，并进行适当的错误处理。在进行整数运算时，可以检查运算结果是否超出了目标数据类型的表示范围，并采取相应的措施，如抛出异常、返回错误码或进行截断处理等。</li>
<li>使用语言或工具提供的溢出检查机制：某些编程语言或工具提供了溢出检查机制，可以在编译时或运行时检测并报告整数溢出情况。例如，C语言中可以使用编译选项开启溢出检查，或者使用静态分析工具来检测潜在的溢出问题。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.3 有符号数和无符号数</title>
    <url>/2023/09/08/6-3-%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="6-3-1-有符号数和无符号数"><a href="#6-3-1-有符号数和无符号数" class="headerlink" title="6.3.1 有符号数和无符号数"></a>6.3.1 有符号数和无符号数</h1><p>关键字 “signed” 和 “unsigned” 在C语言中用于声明整数类型的有符号性质。</p>
<ol>
<li>“signed” 关键字：它用于声明有符号整数类型，表示该类型的变量可以表示正数、负数和零。在C语言中，如果没有指定类型的有符号性，默认情况下整数类型是有符号的。例如，<code>int</code> 是有符号整数类型。</li>
<li>“unsigned” 关键字：它用于声明无符号整数类型，表示该类型的变量只能表示非负数（正数和零），不包括负数。使用无符号整数类型可以扩展整数的表示范围。例如，<code>unsigned int</code> 是无符号整数类型。</li>
</ol>
<p>默认情况下，整数类型是有符号的，即省略了 “signed” 关键字，所声明的整数类型都是有符号的。例如，<code>int</code> 和 <code>signed int</code> 是等价的。</p>
<p>在打印数据时，可以使用不同的格式说明符来表示有符号数和无符号数：</p>
<ul>
<li><code>%d</code>：用于打印有符号整数，表示十进制输出。</li>
<li><code>%u</code>：用于打印无符号整数，同样表示十进制输出。</li>
</ul>
<p>对于有符号整数，其范围取决于具体的数据类型。常见的有符号整数类型及其范围如下：</p>
<ul>
<li><code>char</code> 类型（通常为有符号）：范围是 [-128, 127]。</li>
<li><code>signed char</code> 类型：范围是 [-128, 127]。</li>
<li><code>short</code> 类型（也称为 <code>short int</code>）：范围是 [-32,768, 32,767]。</li>
<li><code>int</code> 类型（也称为 <code>signed int</code>）：范围取决于具体的实现，但至少为 [-32,768, 32,767]。</li>
<li><code>long</code> 类型（也称为 <code>long int</code>）：范围取决于具体的实现，但至少为 [-2,147,483,648, 2,147,483,647]。</li>
</ul>
<p>对于无符号整数，其范围为 [0, 最大值]，最大值取决于具体的数据类型。例如，<code>unsigned char</code> 范围为 [0, 255]。</p>
<h1 id="6-3-2-原码、反码和补码"><a href="#6-3-2-原码、反码和补码" class="headerlink" title="6.3.2 原码、反码和补码"></a>6.3.2 原码、反码和补码</h1><p>以有符号8位整数为例，对于数值-3，以下是原码、反码和补码的示例：</p>
<ol>
<li><p>原码（Sign-Magnitude）：将数值的绝对值转换为二进制表示，并在最高位添加符号位。对于-3，其原码表示为：</p>
<p>原码: 1000 0011</p>
<p>最高位的1表示负数，其余位表示数值的绝对值。</p>
</li>
<li><p>反码（Ones’ Complement）：对于负数，反码是将其原码中除符号位外的每一位取反（0变为1，1变为0）。对于-3，其反码表示为：</p>
<p>反码: 1111 1100</p>
<p>原码中除符号位外的每一位取反得到反码。</p>
</li>
<li><p>补码（Two’s Complement）：对于负数，补码是在反码的基础上加1。对于-3，其补码表示为：</p>
<p>补码: 1111 1101</p>
<p>反码加1得到补码。</p>
</li>
</ol>
<p>需要注意的是，原码、反码和补码是用于表示负数的一种编码方式。在计算机中，负数一般以补码的形式存储和运算。补码具有以下特点：对于正数，其原码、反码和补码是相同的；而对于负数，其补码与其绝对值的二进制表示相差1。</p>
<h1 id="6-3-3-数据的存储"><a href="#6-3-3-数据的存储" class="headerlink" title="6.3.3 数据的存储"></a>6.3.3 数据的存储</h1><p>在计算机中，无符号数和有符号数的存储方式有所不同。</p>
<ol>
<li>无符号数的存储：无符号数直接将其真值（即数值的绝对值）转换为二进制表示，没有原码和补码之分。无符号数的存储方式只考虑数值的表示范围，将数值转换为二进制形式存储在相应的数据类型中。例如，对于无符号8位整数类型，数值范围为0到255，直接将数值转换为二进制表示存储即可。</li>
<li>有符号数的存储：有符号数采用补码的形式进行存储。补码是一种表示负数的编码方式，它可以将负数的表示范围扩展到与正数相同的位数上。<ul>
<li>正数的补码：对于正数，补码等于其原码，即正数的补码与其原码相同。这是因为正数的最高位为0，其原码、反码和补码都相同。</li>
<li>负数的补码：对于负数，补码等于其反码加1。反码是将负数的原码中除符号位外的每一位取反得到的结果。</li>
</ul>
</li>
</ol>
<p>使用补码的存储方式有以下优点：</p>
<ul>
<li>补码可以统一处理正数和负数的运算，简化了运算器的设计。</li>
<li>补码中只有一个零表示，避免了正零和负零的区分。</li>
<li>补码的表示范围与无符号数相同，可以利用同样的位数表示更大的数值范围。</li>
</ul>
<p>总结：</p>
<ul>
<li>无符号数直接将数值转换为二进制表示进行存储。</li>
<li>有符号数采用补码的形式进行存储，正数的补码等于其原码，负数的补码等于其反码加1。补码的存储方式统一了正数和负数的表示和运算。</li>
</ul>
<h1 id="6-3-4-为什么使用补码？"><a href="#6-3-4-为什么使用补码？" class="headerlink" title="6.3.4 为什么使用补码？"></a>6.3.4 为什么使用补码？</h1><p>在补码表示中，对于有符号整数类型，存在正零和负零的编码。以下是+0和-0的编码示例，假设使用8位有符号整数类型：</p>
<ul>
<li>+0 的编码：+0 在补码表示中与正数的编码相同，即直接将数值 0 转换为二进制表示即可。<br>+0 的补码表示为：[0000 0000]</li>
<li>-0 的编码：在补码表示中，-0 的补码与最小负数的补码表示相同，即将最小负数的绝对值取反得到 -0 的补码。<br>-0 的补码表示为：[1000 0000]</li>
</ul>
<p>需要注意的是，在实际计算机中，对于有符号整数类型，通常使用补码表示来处理正数、负数和零。正数的补码等于其原码，负数的补码等于其反码加 1。补码的形式可以解决零的编码问题，即只有一个零的表示，同时还可以多保存一个最小值，例如对于有符号的 8 位整数类型 (signed char)，可以多保存一个最小值 -128（补码为 [1000 0000]），而没有原码和反码的表示。</p>
<p>补码的使用有以下好处：</p>
<ul>
<li>统一了正数、负数和零的表示，简化了运算器和逻辑电路的设计。</li>
<li>解决了零的编码问题，只有一个零的表示。</li>
<li>可以多保存一个最小值，扩展了数值范围。</li>
<li>补码的运算规则与无符号数的运算规则相同，简化了运算的实现。</li>
</ul>
<p>计算机使用补码来存储数据有以下原因：</p>
<ol>
<li>解决零的编码问题：使用补码表示可以消除正零和负零的区别，只有一个零的表示。这简化了数值的表示和运算，并且避免了正负零之间的混淆。</li>
<li>简化减法运算：通过使用补码，减法运算可以转换为加法运算，从而省去了硬件上复杂的减法电路。减法可以通过将减数取反并与被减数相加的方式来实现，这使得计算机的运算器只需要具备加法器和求补电路，提高了硬件的简洁性和效率。</li>
<li>统一处理符号位：补码的运算规则与无符号数的运算规则相同，这样可以使符号位也参与运算，并且与其他位一起进行统一处理。当补码表示的数相加时，最高位（符号位）有进位时，进位被舍弃，从而实现了符号位的正确处理。</li>
</ol>
<p>对于示例中的3 + 7，以下是二进制表示和补码运算的示例：</p>
<ol>
<li><p>将3和7转换为二进制表示：</p>
<ul>
<li>3的二进制表示为：0000 0011</li>
<li>7的二进制表示为：0000 0111</li>
</ul>
</li>
<li><p>进行补码加法运算：<br>补码加法：0000 0011 + 0000 0111</p>
<p>asciidoc</p>
<p>Copy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  0000 0011  (3 的补码)</span><br><span class="line">+ 0000 0111  (7 的补码)</span><br><span class="line">------------</span><br><span class="line">  0000 1010  (结果的补码)</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>补码运算结果为0000 1010，表示为有符号整数的补码形式。由于最高位是0，表示正数，其余位表示数值的绝对值。</p>
</li>
<li><p>将补码结果转换为原码表示：</p>
<ul>
<li>补码结果的绝对值部分：0000 1010</li>
<li>最高位为0，表示正数，原码与补码相同：0000 1010</li>
</ul>
</li>
</ol>
<p>因此，3 + 7 的结果为10。</p>
<p>对于示例中的3 - 7，可以转换为 3 + (-7) 的形式，其中-7的补码表示为1111 1001。将其与3的补码 0000 0011 进行补码加法运算，得到补码结果 1111 1100。将补码结果转换为原码表示，得到 -4。因此，3 - 7 的结果为 -4。</p>
<h1 id="6-3-5-补码为什么采用了反码加1的形式"><a href="#6-3-5-补码为什么采用了反码加1的形式" class="headerlink" title="6.3.5 补码为什么采用了反码加1的形式"></a>6.3.5 补码为什么采用了反码加1的形式</h1><p>补码的设计采用了反码加1的形式，主要是为了解决负数的表示和运算中的一些问题，并提供了一种简便的方式来处理负数。</p>
<p>以下是设计补码采用反码加1的原因：</p>
<ol>
<li>统一了正数和负数的表示：使用补码可以将正数和负数的表示方式统一起来，无需额外的规则来区分正数和负数。这简化了数字的表示和运算。</li>
<li>简化了运算器的设计：通过使用补码，减法运算可以转换为加法运算，这避免了在运算器中需要额外的减法电路。运算器只需具备加法器和求补电路，简化了硬件设计。</li>
<li>解决了零的编码问题：使用补码可以解决零的编码问题，只有一个零的表示，而无需区分正零和负零。</li>
<li>实现了符号位的参与运算：补码的设计使符号位（最高位）也能参与运算，并与其他位一起进行统一处理。这样，符号位也可以像其他位一样参与加法和减法运算，简化了运算的处理逻辑。</li>
</ol>
<p>总的来说，补码采用反码加1的设计方式，使得负数可以用与正数相同的方式进行表示和运算，同时解决了零的编码问题。这种设计简化了硬件设计和运算逻辑，并提供了一种统一的方式来处理正数、负数和零。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.2 存储的基本概念</title>
    <url>/2023/09/08/6-2-%E5%AD%98%E5%82%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="6-2-1-存储单元"><a href="#6-2-1-存储单元" class="headerlink" title="6.2.1 存储单元"></a>6.2.1 存储单元</h1><p>存储单元是计算机中用于存储数据的最小单位。以下是几个常见的存储单元：</p>
<ul>
<li>位（Bit）：位是存储单元的最小单位，它只能表示0或1两种状态。计算机中的所有数据都以位的形式存储和处理。</li>
<li>字节（Byte）：字节是计算机中常用的存储单位，它由8个连续的位组成。字节是计算机内存中数据传输和存储的基本单位，通常用于表示字符、整数等数据。</li>
<li>字（Word）：字是开发者常用的存储单位，它表示计算机在一次操作中能够处理的固定大小的数据。字的大小取决于计算机的架构和操作系统，可以是8位、16位、32位或64位等。</li>
</ul>
<h1 id="6-2-2存储模式"><a href="#6-2-2存储模式" class="headerlink" title="6.2.2存储模式"></a>6.2.2存储模式</h1><p>存储模式指的是计算机在内存中存储多字节数据时，字节的顺序排列方式。关于存储模式，有两个相关的概念：位序（Bit Order）和字节序（Byte Order）。</p>
<ol>
<li><p>位序（Bit Order）：位序是指在一个字节（8位）中，比特位（bit）的排列顺序。在计算机中，有两种常见的位序方式：</p>
<ul>
<li>大端序（Big-Endian）：在大端序中，高位字节存储在低位地址，低位字节存储在高位地址。换句话说，数据的高位字节排在内存的低地址处，低位字节排在内存的高地址处。</li>
<li>小端序（Little-Endian）：在小端序中，低位字节存储在低位地址，高位字节存储在高位地址。换句话说，数据的低位字节排在内存的低地址处，高位字节排在内存的高地址处。</li>
</ul>
<p>位序的选择会直接影响多字节数据的存储和解析方式。不同的计算机体系结构和操作系统有不同的位序规定，例如，x86架构和Windows操作系统使用小端序，而PowerPC架构和大多数UNIX系统使用大端序。</p>
</li>
<li><p>字节序（Byte Order）：字节序是指在多字节数据（例如16位、32位或64位）中，字节的排列顺序。与位序类似，字节序也有两种常见的方式：</p>
<ul>
<li>大端序（Big-Endian）：在大端序中，高位字节存储在内存的低地址，低位字节存储在内存的高地址。换句话说，多字节数据的高位字节排在内存的低地址处，低位字节排在内存的高地址处。</li>
<li>小端序（Little-Endian）：在小端序中，低位字节存储在内存的低地址，高位字节存储在内存的高地址。换句话说，多字节数据的低位字节排在内存的低地址处，高位字节排在内存的高地址处。</li>
</ul>
<p>字节序的选择同样会影响多字节数据在不同计算机和操作系统之间的互通性。为了确保数据的正确解析和传输，程序员需要在跨平台的情况下正确处理字节序。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x11223344</span>;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line"></span><br><span class="line">    b = a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0x44</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Little endian!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Big endian!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大小端之分源自于不同的设计和处理方式，主要原因如下：</p>
<ol>
<li>硬件设计：在硬件层面，计算机内存是以字节为单位进行寻址和存储的。对于多字节数据，如整数或浮点数，需要将其存储在内存中的连续字节中。在设计计算机体系结构时，可以选择将多字节数据的最低有效字节存储在最低地址（小端序）或最高地址（大端序）。</li>
<li>处理习惯：小端模式与人类的思维习惯更为一致。我们在书写数字时，通常先写低位，后写高位。小端模式将最低有效字节存储在最低地址，与我们的书写习惯一致。这样可以使得值的表示更加直观和易于理解。</li>
<li>计算机处理习惯：大端模式在某些计算操作中更加方便。在大端模式下，可以直接按照字节顺序从左到右读写多字节数据，不需要考虑字节的对应关系。这对于某些操作，如整数加法、乘法等，可以简化处理逻辑，提高效率。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.1 存储才是C语言的精髓</title>
    <url>/2023/09/08/6-1-%E5%AD%98%E5%82%A8%E6%89%8D%E6%98%AFC%E8%AF%AD%E8%A8%80%E7%9A%84%E7%B2%BE%E9%AB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据存储在计算机中是非常重要的概念，对于理解计算机编程和问题求解至关重要。以下是对您提到的几个相关概念的简要说明：</p>
<ul>
<li>变量：变量是用来存储和表示数据的一种命名方式。通过变量，我们可以在程序中保存和操作数据。变量通常具有特定的数据类型（例如整数、浮点数、字符串等），并且可以在程序中进行赋值和修改。</li>
<li>指针：指针是用来存储内存地址的变量。它们可以指向其他变量或数据结构在内存中的位置。通过指针，我们可以直接访问和操作内存中的数据，而不是通过变量名来访问。</li>
<li>堆栈：堆栈是一种内存结构，用于管理程序的函数调用和局部变量。在函数调用时，相关的信息（例如函数参数、返回地址等）会被压入堆栈中，以便在函数执行完毕后能够返回到正确的位置。局部变量也存储在堆栈中，并在函数执行期间进行分配和释放。</li>
<li>链表：链表是一种数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的指针。链表可以动态地分配内存来存储数据，并且可以在运行时进行插入、删除和修改操作。链表的灵活性使其在许多算法和数据结构中发挥重要作用。</li>
</ul>
<p>关于编译器留给程序员的接口，关键字是编程语言中的特殊单词，具有预定义的含义和用途。编译器根据关键字来解析和理解源代码，并相应地执行特定的操作。程序员可以使用关键字来定义变量、控制程序流程、声明函数等。不同编程语言具有不同的关键字集合，而关键字的选择和用法直接影响着程序的行为和功能。</p>
<p>理解数据存储以及编译器提供的关键字接口，对于开发高效、可靠的软件系统至关重要。这些概念和工具帮助程序员管理和操作数据，解决各种计算机编程中的问题。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>5.24 标号元素</title>
    <url>/2023/09/07/5-24-%E6%A0%87%E5%8F%B7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>标记元素是C语言中用于初始化数组和结构体的特性之一。它允许您以任意顺序指定要初始化的元素，并且可以通过数组索引或结构体的结构域名直接给它们赋值。</p>
<p>使用标记元素可以使初始化代码更加灵活和易读，尤其在需要初始化大型数组或结构体时，可以避免冗长的初始化代码。</p>
<p>以下是使用标记元素进行数组和结构体初始化的示例：</p>
<ol>
<li>数组初始化：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> myArray[<span class="number">5</span>] = &#123; [<span class="number">2</span>] = <span class="number">42</span>, [<span class="number">4</span>] = <span class="number">99</span>, [<span class="number">1</span>] = <span class="number">7</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，通过索引（标记）指定了要初始化的数组元素以及它们的值。数组的长度为5，但只有索引为2、4和1的元素被初始化，其他元素将被默认初始化为0。</p>
<ol>
<li>结构体初始化：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">myPoint</span> =</span> &#123; .y = <span class="number">10</span>, .x = <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，通过结构体的结构域名（标记）指定了要初始化的结构体成员以及它们的值。结构体<code>Point</code>具有<code>x</code>和<code>y</code>两个成员，通过结构域名指定了它们的初始化值。</p>
<p>通过使用标记元素，您可以以更自由的方式初始化数组和结构体，无需按照默认顺序或位置进行初始化。这提供了更大的灵活性，并使代码更易读和维护。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.23 局部标签</title>
    <url>/2023/09/07/5-23-%E5%B1%80%E9%83%A8%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在C和C++编程语言中，局部标签（Local Labels）是指在函数或代码块内部定义的标签。与全局标签（Global Labels）不同，局部标签的作用范围仅限于所在的函数或代码块内部。</p>
<p>局部标签的语法形式为一个冒号（:）后跟标识符，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Code block with local label</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">goto</span> myLabel; <span class="comment">// Jump to local label</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Local label definition</span></span><br><span class="line">    myLabel:</span><br><span class="line">        <span class="comment">// Label code</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>myLabel</code> 是一个局部标签，它被定义在内部代码块中。在代码块中，可以使用 <code>goto</code> 语句跳转到该局部标签处，执行与标签关联的代码。</p>
<p>局部标签主要用于在函数或代码块内部实现一些局部的控制流跳转，例如在某个条件满足时跳转到特定的代码位置。与全局标签相比，局部标签的作用范围较小，更易于控制和理解。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.22 可变参数宏</title>
    <url>/2023/09/07/5-22-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>可变参数宏是一种宏定义的特殊形式，允许在宏中使用可变数量的参数。以下是几个示例定义可变参数宏的示例：</p>
<p>使用 <code>__VA_ARGS__</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define debug(fmt, ...) printf(fmt, __VA_ARGS__)</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>debug</code> 是一个宏，它接受一个格式字符串 <code>fmt</code> 和可变数量的参数。宏展开时，<code>__VA_ARGS__</code> 将被替换为传递给宏的实际参数，然后被传递给 <code>printf</code> 函数。</p>
<p>使用 <code>args...</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define debug2(fmt, args...) printf(fmt, args)</span><br></pre></td></tr></table></figure>

<p>这个示例与第一个示例类似，只是使用了不同的语法。<code>args...</code> 表示可变数量的参数，然后被传递给 <code>printf</code> 函数。</p>
<p>使用 <code>##_VA_ARGS__</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define debug(fmt, ...) printf(fmt, ##__VA_ARGS__)</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>##</code> 是一个预处理运算符，用于处理可变参数为空的情况。如果可变参数为空，<code>##</code> 将删除前面的逗号，以避免编译错误。</p>
<p>这些示例都是定义可变参数宏的常见方式。它们允许在宏中使用不定数量的参数，并将它们传递给其他函数或语句。在实际使用中，可以根据具体需求选择适合的定义方式。需要注意的是，在使用可变参数宏时，应谨慎处理参数的类型和数量，以避免潜在的错误和问题。</p>
<p>ShareLikeDislike</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.21 do{}while(0)</title>
    <url>/2023/09/07/5-21-do-while-0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是一个 do-while 循环的示例，它的语法结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// code;</span></span><br><span class="line">    <span class="comment">// code;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">while</span> (O);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，循环体内的代码会被执行一次，然后根据条件 <code>O</code> 的值判断是否继续执行循环。如果条件为真，则继续执行循环体；如果条件为假，则退出循环。</p>
<p>其中，<code>code</code> 表示需要执行的代码，可以是任意合法的语句或语句块。在循环体内可以包含一条或多条代码，用分号分隔。</p>
<p><code>O</code> 是循环条件，它可以是一个表达式、变量或常量。如果条件为真（非零值），则循环继续执行；如果条件为假（零值），则循环结束。</p>
<p>do-while 循环与 while 循环的区别在于，do-while 循环保证循环体至少执行一次，即使条件初始时就为假。而 while 循环在执行循环体之前先判断条件，如果条件初始时就为假，则循环体不会执行。</p>
<p>这种定义方式可能是为了实现复杂的宏定义，并且在条件语句中使用这些宏定义。</p>
<p>宏定义允许在代码中进行文本替换，可以用来定义函数式宏（function-like macros）和复合语句宏（compound statement macros）。函数式宏可以像函数一样接受参数并返回结果，复合语句宏可以包含多个语句。</p>
<p>使用宏定义可以在编译时进行代码替换，从而在一定程度上提高代码的执行效率。此外，宏定义还可以实现一些编程技巧，如条件编译、代码重用等。</p>
<p>在条件语句中使用复杂的宏定义可以使代码更加简洁和可读。通过将复杂的逻辑封装在宏定义中，可以提高代码的可维护性和可重用性。</p>
<p>另外，使用局部变量可以在宏定义中引入临时变量，以便在宏展开过程中进行计算或临时存储值。这可以增加宏定义的灵活性和功能性。</p>
<p>总的来说，这种定义方式可能是为了实现复杂的宏定义，提高代码的可读性、可维护性和重用性，同时在条件语句中使用这些宏定义可以简化代码结构并提高可读性。然而，需要注意的是，过度复杂的宏定义可能会导致代码难以理解和调试，因此在使用时需要权衡使用宏定义的利弊，并根据实际情况进行选择。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.20 case范围扩展</title>
    <url>/2023/09/07/5-20-case%E8%8C%83%E5%9B%B4%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在使用 <code>case</code> 语句时，值的顺序可以影响程序的性能。以下是一些注意事项：</p>
<ol>
<li>比较链 vs. 树 vs. 跳转表：<code>case</code> 语句可以使用比较链、树或跳转表来实现。比较链是按照 <code>case</code> 值的顺序逐个比较的方式，树是使用二叉树或多路查找树的方式，而跳转表是使用跳转指令进行快速查找。根据具体的编译器和目标平台，编译器可能会选择不同的实现方式。通常情况下，跳转表是最高效的实现方式，而比较链是最低效的实现方式。</li>
<li>大概率值放前面：由于 <code>case</code> 语句是按照顺序逐个比较的，因此将大概率命中的值放在前面可以提高性能。这是因为如果大多数情况下的值在前面，可以减少比较的次数，从而提高执行效率。</li>
<li>使用连续整数：如果 <code>case</code> 语句的值是连续的整数，可以考虑使用更高效的实现方式，如跳转表。这样可以将复杂度从线性降低为常数级别，提高执行效率。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.19 内建函数：__builtin_expect</title>
    <url>/2023/09/07/5-19-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%EF%BC%9A-builtin-expect/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>__builtin_expect</code> 是一个内建函数，用于提示编译器表达式的预期结果。它的使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__builtin_expect (exp, c)</span><br></pre></td></tr></table></figure>

<p>其中，<code>exp</code> 是一个表达式，<code>c</code> 是一个常量。该函数返回 <code>exp</code> 的值，并表示 <code>exp</code> 的结果为 <code>c</code> 的概率很大。</p>
<p>以下是 <code>__builtin_expect</code> 的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int max(int a, int b) &#123;</span><br><span class="line">    return (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int x = 10;</span><br><span class="line">    int y = 5;</span><br><span class="line"></span><br><span class="line">    int result = max(x, y);</span><br><span class="line">    if (__builtin_expect(result == x, 1)) &#123;</span><br><span class="line">        printf(&quot;Result is likely to be x\n&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;Result is likely not to be x\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>__builtin_expect</code> 用于提示编译器 <code>result == x</code> 的结果很可能为真。如果 <code>result == x</code>，将输出 “Result is likely to be x”；否则，将输出 “Result is likely not to be x”。</p>
<p>通过使用 <code>__builtin_expect</code>，可以提供编译器有关表达式预期结果的提示信息。这对于一些性能敏感的代码段，如分支预测优化，可以帮助编译器生成更优化的机器代码。</p>
<p>需要注意的是，<code>__builtin_expect</code> 的提示只是一种提示，具体如何优化由编译器决定。此外，它在实际应用中的效果可能因编译器和目标平台的不同而有所差异。因此，在使用时需要进行测试和验证，并在实际性能分析中评估其效果。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.18 内建函数：__builtin_constant_p</title>
    <url>/2023/09/07/5-18-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%EF%BC%9A-builtin-constant-p/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>__builtin_constant_p</code> 是一个内建函数，用于判断表达式是否为编译时常量。它在编译时进行求值，并返回一个整数常量，表示表达式是否为常量。</p>
<p>以下是 <code>__builtin_constant_p</code> 的使用示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_constant_p(size)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;size is a compile-time constant\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;size is not a compile-time constant\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    foo(<span class="number">10</span>);        <span class="comment">// size is a compile-time constant</span></span><br><span class="line">    foo(MAX_SIZE);  <span class="comment">// size is not a compile-time constant</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    foo(x);         <span class="comment">// size is not a compile-time constant</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>foo</code> 函数使用了 <code>__builtin_constant_p</code> 来判断 <code>size</code> 参数是否为编译时常量。如果 <code>size</code> 是编译时常量，将输出 “size is a compile-time constant”；否则，将输出 “size is not a compile-time constant”。</p>
<p>通过使用 <code>__builtin_constant_p</code>，可以根据表达式是否为编译时常量来进行条件编译或优化。这对于在编译时进行静态优化或决策非常有用。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.17 内建函数</title>
    <url>/2023/09/07/5-17-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>内建函数（Built-in functions）是编译器提供的一组特殊函数，其实现直接内置在编译器中。它们通常具有与普通函数相同的语法和调用方式，但在执行时具有特殊的行为和性能优化。</p>
<p>内建函数的特点如下：</p>
<ol>
<li>编译器内部实现：内建函数是编译器的一部分，其实现直接嵌入在编译器中。这使得编译器可以对这些函数进行特定的优化和内部处理。</li>
<li>直接使用：与关键字类似，内建函数可以直接使用，无需包含头文件或外部库的引用。它们是编译器的一部分，因此可以直接在代码中使用。</li>
<li>命名：内建函数的命名通常以 <code>_builtin</code> 开头，如 <code>_builtin_strlen</code>。这样的命名约定有助于与普通函数进行区分。</li>
<li>主要用于性能优化：内建函数的设计目的通常是为了性能优化。它们可以针对特定的操作或算法提供更高效的实现，以提高程序的执行速度。</li>
<li>部分是 C 标准库函数的内建版本：一些内建函数是对 C 标准库函数的内建版本，提供了更高效的实现。例如，<code>_builtin_strlen</code> 可能是对标准库函数 <code>strlen</code> 的内建优化版本。</li>
<li>没有文档且变动频繁：与标准库函数相比，内建函数通常没有官方文档，并且其行为和实现可能在不同的编译器版本中有所变化。这使得内建函数的使用相对不稳定，一般不建议在通用代码中频繁使用。</li>
</ol>
<p><code>__builtin_return_address(LEVEL)</code> 是一个内建函数，用于返回当前函数或调用者的返回地址。它接受一个整数参数 <code>LEVEL</code>，用于指定返回地址的级别。</p>
<ul>
<li>当 <code>LEVEL</code> 为0时，表示返回当前函数的返回地址。</li>
<li>当 <code>LEVEL</code> 为1时，表示返回当前函数的调用者的返回地址。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span>* return_addr = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Return address of func1: %p\n&quot;</span>, return_addr);</span><br><span class="line">    </span><br><span class="line">    return_addr = __builtin_return_address(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Return address of func1&#x27;s caller: %p\n&quot;</span>, return_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">    func1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    func2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>func1</code> 调用了 <code>__builtin_return_address</code> 来获取返回地址。当 <code>LEVEL</code> 为0时，它返回的是 <code>func1</code> 的返回地址；当 <code>LEVEL</code> 为1时，它返回的是 <code>func1</code> 的调用者（即 <code>func2</code>）的返回地址。</p>
<p>类似地，<code>__builtin_frame_address(LEVEL)</code> 是另一个内建函数，用于返回函数的栈帧地址。它的使用方式类似于 <code>__builtin_return_address</code>，也接受一个整数参数 <code>LEVEL</code>。</p>
<ul>
<li>当 <code>LEVEL</code> 为0时，表示返回当前函数的栈帧地址。</li>
<li>当 <code>LEVEL</code> 为1时，表示返回当前函数的调用者的栈帧地址。</li>
</ul>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.16 属性声明：used &amp; unused</title>
    <url>/2023/09/07/5-16-%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%EF%BC%9Aused-unused/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在给定的示例中，使用了 <code>used</code> 和 <code>unused</code> 属性来声明变量和函数的使用情况。</p>
<ol>
<li><code>.register int reg asm(&quot;r0&quot;) __attribute__((used));</code><br>这个声明将 <code>reg</code> 定义为一个寄存器变量，并使用 <code>used</code> 属性来指示编译器该变量会被使用。这可以防止编译器优化掉该变量，确保其在代码中的存在。</li>
<li><code>static void func(void) __attribute__((used, section(&quot;.text&quot;)));</code><br>这个声明定义了一个静态函数 <code>func</code>，并使用 <code>used</code> 属性来指示编译器该函数会被使用。此外，通过 <code>section(&quot;.text&quot;)</code> 属性，将该函数放置在 <code>.text</code> 段中。</li>
<li><code>static __attribute__((unused)) int a;</code><br>这个声明定义了一个静态变量 <code>a</code>，并使用 <code>unused</code> 属性来指示编识器该变量未被使用。这可以让编译器忽略该变量的存在，避免产生未使用变量的警告。</li>
<li><code>static int func(void) __attribute__((unused));</code><br>这个声明定义了一个静态函数 <code>func</code>，并使用 <code>unused</code> 属性来指示编译器该函数未被使用。类似于上述的静态变量，这可以让编译器忽略该函数的存在。</li>
<li><code>int fun(__attribute__((unused)) int a, int b);</code><br>这个声明定义了一个函数 <code>fun</code>，并使用 <code>unused</code> 属性来指示编译器函数中的参数 <code>a</code> 未被使用。这可以避免产生未使用参数的警告。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.15 属性声明：noreturn</title>
    <url>/2023/09/07/5-15-%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%EF%BC%9Anoreturn/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>属性声明 <code>noreturn</code> 是一个特殊的函数属性，它告诉编译器函数不会返回到调用者。这个属性可以用于告知编译器在函数执行完毕后不会返回到调用点，因此编译器可以进行一些优化，例如消除一些后续的代码或者警告未使用的返回值。</p>
<p>下面是一个使用 <code>noreturn</code> 属性声明的示例：</p>
<p>c</p>
<p>Copy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdnoreturn.h&gt;</span><br><span class="line"></span><br><span class="line">noreturn void exit_program(int exit_code) &#123;</span><br><span class="line">    // 执行一些清理操作</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // 退出程序</span><br><span class="line">    exit(exit_code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>exit_program</code> 函数被声明为 <code>noreturn</code> 类型，它表示该函数在执行完毕后不会返回到调用点。在函数体内，执行了一些清理操作后，调用了 <code>exit</code> 函数来终止程序的执行。</p>
<p>使用 <code>noreturn</code> 属性可以帮助编译器优化代码，并提供更好的代码可读性。它可以用于标记一些特殊函数，如退出程序的函数、抛出异常的函数等。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.14 属性声明：mode</title>
    <url>/2023/09/07/5-14-%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%EF%BC%9Amode/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>属性声明中的 <code>mode</code> 是一个功能强大的GNU C扩展，它用于指定类型的位宽和有符号&#x2F;无符号属性。通过 <code>mode</code> 属性，可以定义自定义的位宽类型，以及相应的有符号和无符号变体。</p>
<p>在给定的示例中，使用了 <code>mode(QI)</code> 属性来声明两个类型别名：</p>
<ol>
<li><code>typedef int s8 __attribute__((mode(QI)));</code><br>这个声明将 <code>s8</code> 定义为一个有符号整数类型，位宽为1字节（8位），即一个字节的宽度。<code>mode(QI)</code> 表示 “QI” 模式，其中 “Q” 表示 “Quad”，表示4个位，而 “I” 表示 “Integer”，表示整数类型。</li>
<li><code>typedef unsigned int us8 __attribute__((mode(QI)));</code><br>这个声明将 <code>us8</code> 定义为一个无符号整数类型，位宽也为1字节（8位）。同样使用了 <code>mode(QI)</code> 属性来指定位宽和有符号&#x2F;无符号属性。</li>
</ol>
<p>通过使用 <code>mode</code> 属性，可以根据需要定义特定位宽的整数类型，并根据需要选择有符号或无符号的变体。这在某些特定的嵌入式系统编程或底层编程中可能会有用，因为它可以更精确地控制数据类型的大小和属性。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.13 属性声明：noinline &amp; always_inline</title>
    <url>/2023/09/07/5-13-%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%EF%BC%9Anoinline-always-inline/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>inline</code>、<code>noinline</code> 和 <code>always_inline</code> 都是函数属性，用于指定函数的内联行为。它们可以通过 <code>__attribute__</code> 语法与函数结合使用。下面是使用示例：</p>
<ol>
<li><p><code>static inline __attribute__((noinline)) int func();</code><br>这个示例定义了一个静态内联函数 <code>func</code>，并使用了 <code>noinline</code> 属性。</p>
<ul>
<li><code>inline</code> 属性用于指定函数可以进行内联展开，即将函数的代码插入调用处，以减少函数调用的开销。</li>
<li><code>static</code> 关键字用于将函数声明为静态函数，限定函数的作用域在当前源文件中。</li>
<li><code>__attribute__((noinline))</code> 用于禁止对函数进行内联展开，即不将函数的代码插入调用处。</li>
</ul>
<p>这意味着 <code>func</code> 函数将被声明为内联函数，但编译器不会强制将其内联展开，而是根据编译器的优化策略决定是否内联展开。</p>
</li>
<li><p><code>static inline __attribute__((always_inline)) int func();</code><br>这个示例定义了一个静态内联函数 <code>func</code>，并使用了 <code>always_inline</code> 属性。</p>
<ul>
<li><code>__attribute__((always_inline))</code> 用于强制编译器始终内联展开函数，不考虑编译器的优化策略。</li>
</ul>
<p>这意味着 <code>func</code> 函数将始终被内联展开，无论编译器如何优化。</p>
</li>
</ol>
<p>使用内联函数可以提高函数调用的效率，减少函数调用带来的开销。然而，过度使用内联函数可能会导致代码膨胀和代码重复，增加可执行文件的大小。</p>
<p>内联函数是一种编译器优化技术，它将函数的代码插入到调用处，而不是通过函数调用的方式进行执行。内联函数的目的是减少函数调用的开销，包括保存当前函数现场、跳转到调用函数执行和恢复当前函数现场的开销。</p>
<p>当一个函数被声明为内联函数时，编译器会尽量将函数的代码直接插入到调用处，类似于宏展开的方式。这样可以避免函数调用的开销，包括压栈保存现场、跳转执行和恢复现场的操作。相比于函数调用，内联函数可以更快地执行，并且可以消除函数调用带来的额外开销。</p>
<p>然而，内联函数的使用应慎重考虑。由于内联函数的代码会被复制到每个调用处，这可能会导致代码膨胀，增加可执行文件的大小。过度使用内联函数可能会导致代码重复，降低可维护性。因此，应在性能和代码大小之间进行权衡，并根据具体情况决定是否使用内联函数。</p>
<p>在 C&#x2F;C++ 中，可以使用 <code>inline</code> 关键字将函数声明为内联函数。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>add</code> 函数被声明为内联函数。当调用 <code>add</code> 函数时，编译器会尝试将其代码直接插入到调用处，而不是进行函数调用。</p>
<p>需要注意的是，将函数声明为内联函数只是对编译器的建议，编译器可以选择是否内联展开函数。此外，内联函数的定义通常应放在头文件中，以便在每个调用处进行展开。</p>
<p>编译器对内联函数的处理可以分为两个阶段：编译阶段和链接阶段。</p>
<p>在编译阶段，当编译器遇到内联函数的调用时，它会尝试将函数的代码插入到调用处，类似于宏展开。这样可以避免函数调用的开销，并提高执行效率。编译器通常会对内联函数进行一些优化，如常量折叠、循环展开等。</p>
<p>在链接阶段，编译器会将每个内联函数的定义保留在目标文件中。当链接器将多个目标文件组合成可执行文件时，它会根据需要选择性地将内联函数的定义插入到调用处。</p>
<p>然而，内联函数也有一些不足之处：</p>
<ol>
<li>增大代码的体积：由于内联函数的代码会被复制到每个调用处，这可能导致代码膨胀，增加可执行文件的大小。特别是当内联函数的代码较长时，代码体积的增大可能会对缓存命中率和指令缓存的效率产生负面影响。</li>
<li>降低缓存命中率和取指效率：内联函数的代码增大可能导致缓存命中率降低，因为较多的代码需要从内存加载到缓存中。此外，取指令时，由于内联函数的代码较多，可能会导致取指令的效率降低，从而影响程序的执行速度。</li>
<li>可能降低执行效率：尽管内联函数可以减少函数调用的开销，但在某些情况下，内联函数的执行效率可能会降低。这是因为内联函数的代码被复制到多个调用处，增加了指令的数量和缓存的压力。此外，如果内联函数的代码较长，可能会导致指令缓存的冲突，从而影响执行速度。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.12 属性声明：constructor &amp; destructor</title>
    <url>/2023/09/07/5-12-%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%EF%BC%9Aconstructor-destructor/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>constructor</code> 和 <code>destructor</code> 是函数属性，用于指定在程序运行时自动执行的初始化函数和清理函数。它们可以通过 <code>__attribute__</code> 语法与 <code>constructor</code> 和 <code>destructor</code> 属性结合使用。具体的使用方法如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__((constructor)) <span class="type">int</span> <span class="title function_">init_func</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">__attribute__((destructor)) <span class="type">int</span> <span class="title function_">exit_func</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>init_func</code> 是一个初始化函数，<code>exit_func</code> 是一个清理函数。</p>
<p>解释如下：</p>
<ul>
<li><code>__attribute__((constructor))</code> 用于指定函数为初始化函数。这意味着在程序启动时，该函数会自动被调用进行初始化操作。</li>
<li><code>__attribute__((destructor))</code> 用于指定函数为清理函数。这意味着在程序退出时，该函数会自动被调用进行清理操作。</li>
</ul>
<p>使用 <code>constructor</code> 和 <code>destructor</code> 属性的函数在程序运行期间的执行顺序是由编译器和链接器决定的。通常情况下，初始化函数会在 <code>main</code> 函数之前被调用，而清理函数会在程序退出时被调用。</p>
<p>这些函数属性可以用于在程序开始和结束时执行一些必要的初始化和清理操作，例如初始化全局变量、打开和关闭文件、申请和释放资源等。</p>
<p>需要注意的是，函数属性的使用方法可能因编译器而异，具体的语法和支持程度可能有所差异。因此，在使用时应查阅相关编译器文档以了解具体的使用方法和限制。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.11 属性声明：weak &amp; alias</title>
    <url>/2023/09/07/5-11-%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%EF%BC%9Aweak-alias/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 C 语言中，符号（Symbol）是指变量、函数、常量等在编译过程中生成的标识符。符号具有不同的属性，其中包括强符号（Strong Symbol）和弱符号（Weak Symbol）。</p>
<ol>
<li>强符号（Strong Symbol）：<ul>
<li>强符号是指在编译过程中具有高优先级的符号。</li>
<li>当存在多个强符号的定义时，链接器会选择其中一个作为最终的定义，并且会忽略其他的定义。</li>
<li>通常情况下，全局变量和初始化的静态变量都被视为强符号。</li>
<li>在不同的源文件中定义同名的强符号会引发链接错误。</li>
</ul>
</li>
<li>弱符号（Weak Symbol）：<ul>
<li>弱符号是指在编译过程中具有低优先级的符号。</li>
<li>当存在多个弱符号的定义时，链接器会选择其中一个作为最终的定义，但如果没有找到强符号的定义，链接器会接受弱符号的定义。</li>
<li>通常情况下，未初始化的静态变量和函数都被视为弱符号。</li>
<li>在不同的源文件中定义同名的弱符号不会引发链接错误。</li>
</ul>
</li>
</ol>
<p>根据您提供的示例代码，可以进行如下解释：</p>
<ul>
<li><code>int a;</code> 和 <code>int b;</code> 是两个未初始化的静态变量，它们被视为弱符号。</li>
<li><code>int a = 1;</code> 是对变量 <code>a</code> 的初始化，它被视为强符号，因为它是一个具有初始值的全局变量。</li>
<li><code>int b = 2;</code> 是对变量 <code>b</code> 的初始化，它也被视为强符号，因为它是一个具有初始值的全局变量。</li>
<li><code>void func()</code> 和 <code>-void func()</code> 是函数 <code>func</code> 的声明和定义，它们都被视为强符号。</li>
</ul>
<p>在链接过程中，如果存在多个对同一符号的定义，链接器将根据符号的强度规则来选择最终的定义。在您的示例中，如果在 <code>main.c</code> 和 <code>func.c</code> 中都包含了同名的变量或函数定义，链接器将会选择其中一个作为最终的定义，并且会忽略其他的定义（对于强符号）或接受其中一个定义（对于弱符号）。</p>
<p>在链接过程中，符号决议（Symbol Resolution）是指解决多个源文件中对同一符号的定义或引用的过程。根据符号的强度和规则，可以发生以下三种场景：</p>
<ol>
<li>强符号与强符号：<ul>
<li>如果存在多个源文件中对同一符号的强符号定义，链接器将发生冲突，并且会报告链接错误。这是因为强符号具有高优先级，只能有一个最终的定义。</li>
</ul>
</li>
<li>强符号与弱符号、弱符号与弱符号：<ul>
<li>如果存在强符号与弱符号或者多个弱符号的定义，根据一般规则，强符号和弱符号可以共存。</li>
<li>在这种情况下，强符号将覆盖弱符号，并成为最终的定义。体积更大的符号通常被视为强符号，因此它将胜出。</li>
</ul>
</li>
</ol>
<p>需要注意的是，具体的符号决议规则和行为可能因编译器、操作系统和链接器的不同而有所差异。上述规则是一般情况下的基本规律，但在特定的环境中可能会有特殊的规则适用。</p>
<p>在实际开发中，为了避免符号冲突和不确定的行为，应遵循以下原则：</p>
<ul>
<li>避免在不同的源文件中定义具有相同名称的强符号。</li>
<li>在需要共享符号的情况下，使用弱符号进行定义，并确保在链接时只有一个强符号的定义。这可以通过将符号定义放在一个源文件中，或者使用特定的链接器选项来实现。</li>
</ul>
<p><code>alias</code> 是一个用于创建符号别名的关键字。在 C 语言中，<code>alias</code> 关键字可以与 <code>__attribute__</code> 结合使用来为函数或变量创建别名。具体使用方法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _f();</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> __<span class="title function_">attribute__</span><span class="params">((weak, alias(<span class="string">&quot;_f&quot;</span>)))</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，通过 <code>alias</code> 关键字，<code>f</code> 函数被创建为 <code>_f</code> 函数的别名。</p>
<p>解释如下：</p>
<ul>
<li><code>void _f();</code> 是 <code>_f</code> 函数的原始声明或定义。</li>
<li><code>void f() __attribute__((weak, alias(&quot;_f&quot;)));</code> 创建了一个名为 <code>f</code> 的函数，它是 <code>_f</code> 函数的别名。使用 <code>weak</code> 属性来指定 <code>f</code> 为弱符号，表示它可以与其他同名函数共存。</li>
</ul>
<p>通过使用 <code>alias</code> 关键字，我们可以在代码中创建函数或变量的别名，使其可以通过不同的名称进行访问。这对于一些特定的编程需求和代码重用非常有用。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.10 属性声明：const</title>
    <url>/2023/09/07/5-10-%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%EF%BC%9Aconst/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>属性声明 <code>const</code> 用于指定函数的返回值为常量（不可修改）。它的使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int func(int a) __attribute__((const));</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>const</code> 属性应用于函数 <code>func</code>，用于指定函数的返回值为常量。</p>
<p>具体来说，<code>const</code> 属性表示函数的返回值不依赖于除了函数参数之外的任何外部状态。也就是说，对于相同的输入，函数始终返回相同的结果，并且不会修改任何全局变量或静态变量。这种属性可以帮助编译器进行一些优化，例如函数结果的缓存或重复计算的消除。</p>
<p>使用 <code>const</code> 属性有助于提高代码的可读性和可靠性，因为它明确了函数的行为，并更容易推断出函数是否会产生副作用。</p>
<p>需要注意的是，使用 <code>const</code> 属性并不会强制确保函数的实现不会产生副作用或修改全局状态。它只是一种提示或约定，应该由开发者遵循。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.9 属性声明：format</title>
    <url>/2023/09/07/5-9-%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%EF%BC%9Aformat/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>属性 <code>format</code> 用于指定函数参数的格式化字符串检查，以帮助编译器检测格式化字符串与实际参数之间的匹配错误。它的使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__attribute__((format(archetype, string-index, first-to-check)))</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>archetype</code> 是一个字符串常量，用于指定格式化字符串的类型。常见的类型有 <code>&quot;printf&quot;</code> 和 <code>&quot;scanf&quot;</code>，分别用于格式化输出和格式化输入。</li>
<li><code>string-index</code> 是一个整数常量，表示格式化字符串在函数参数列表中的索引。索引从 1 开始，0 表示函数本身。</li>
<li><code>first-to-check</code> 是一个整数常量，表示从参数列表的第几个参数开始进行检查。一般情况下，这个值与 <code>string-index</code> 相同。</li>
</ul>
<p>例如，以下示例展示了如何使用 <code>format</code> 属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__attribute__((format(printf, 1, 2)))</span><br><span class="line">void LoG(const char *fmt, ...) &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>format(printf, 1, 2)</code> 属性应用于 <code>LoG</code> 函数。它告诉编译器检查函数的第一个参数（格式化字符串）与后续变参参数的匹配情况，以确保格式化字符串中的占位符与实际参数的类型相符。</p>
<p>这样，在调用 <code>LoG</code> 函数时，如果格式化字符串与实际参数不匹配，编译器会发出警告或错误信息，提醒开发者修正问题。</p>
<p>需要注意的是，<code>format</code> 属性对于编译器来说是一种提示，不会强制执行检查。因此，开发者仍需注意确保格式化字符串与实际参数的正确匹配，以避免潜在的错误。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.8 属性声明：aligned &amp; packed</title>
    <url>/2023/09/07/5-8-%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%EF%BC%9Aaligned-packed/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>属性声明 <code>aligned</code> 和 <code>packed</code> 是用于控制结构体或变量的对齐方式的特殊属性。</p>
<ol>
<li><p><code>aligned</code> 属性：<code>aligned</code> 属性用于指定结构体或变量的对齐方式。对齐方式是指变量在内存中的起始地址必须是某个特定值的倍数。这个特定值称为对齐边界。通过使用 <code>aligned</code> 属性，可以强制指定变量的对齐边界。</p>
<p>例如，以下示例将一个结构体 <code>my_struct</code> 按照 16 字节对齐：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">&#125; __attribute__((aligned(<span class="number">16</span>)));</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">在这个例子中，`aligned(<span class="number">16</span>)` 属性将结构体 `my_struct` 的对齐边界设置为 <span class="number">16</span> 字节。这意味着结构体的起始地址必须是 <span class="number">16</span> 的倍数。</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>packed</code> 属性：<code>packed</code> 属性用于指定结构体或变量的紧凑布局，即取消对齐。默认情况下，结构体的成员按照其自然对齐边界进行对齐，以提高内存访问效率。但有时，我们需要取消对齐，以减小结构体的大小或与其他系统进行数据交互。</p>
<p>例如，以下示例将一个结构体 <code>my_struct</code> 设置为紧凑布局：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">在这个例子中，`packed` 属性将结构体 `my_struct` 设置为紧凑布局，取消了成员的对齐。这意味着结构体的大小可能会减小，但访问成员时可能会带来性能开销。</span><br></pre></td></tr></table></figure></li>
</ol>
<p>需要注意的是，使用 <code>aligned</code> 和 <code>packed</code> 属性可能会对内存访问效率和可移植性产生影响。对齐和紧凑布局的选择应根据具体的需求和平台要求进行权衡。此外，这些属性的语法可能因编译器而异，应查阅相应的文档以确保正确使用。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.7 属性声明：section</title>
    <url>/2023/09/07/5-7-%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%EF%BC%9Asection/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>属性（Attributes）是一种在C语言中使用的特殊语法，用于声明变量或函数的特殊属性，以指导编译器进行特定方面的优化或代码检查。</p>
<p>在C语言中，可以使用 <code>__attribute__</code> 关键字来声明属性。属性可以在变量或函数的声明后面使用，通过 <code>__attribute__((ATTRIBUTE))</code> 的语法进行指定。</p>
<p>例如，假设有以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int global_val __attribute__((section(&quot;.data&quot;)));</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>global_val</code> 是一个整型变量，通过 <code>__attribute__((section(&quot;.data&quot;)))</code> 指定了它的属性。</p>
<p>这里使用的属性是 <code>section</code>，它的作用是将 <code>global_val</code> 变量放置在指定的内存段（section）中。具体地，<code>section(&quot;.data&quot;)</code> 表示将 <code>global_val</code> 放置在名为 “.data” 的内存段中。</p>
<p>属性的主要用途包括但不限于以下几个方面：</p>
<ol>
<li>优化：通过属性，可以告知编译器一些额外的信息，以便进行特定的优化。例如，可以指定变量的对齐方式、内联函数等，以优化程序的执行效率。</li>
<li>警告检查：属性还可以用于启用或禁用编译器的警告检查。通过指定特定的属性，可以控制编译器在编译过程中产生的警告信息。</li>
<li>内存布局：属性可以用于控制变量或函数在内存中的位置。可以指定变量存放在特定的内存段中，或者指定函数使用特定的调用约定。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.6 零长度数组</title>
    <url>/2023/09/07/5-6-%E9%9B%B6%E9%95%BF%E5%BA%A6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这个例子展示了C语言中的零长度数组的用法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> *<span class="title">buf</span>;</span></span><br><span class="line">    buf = (<span class="keyword">struct</span> buffer*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> buffer) + <span class="number">20</span>);</span><br><span class="line">    buf-&gt;len = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size: %d\n&quot;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">strcpy</span>(buf-&gt;a, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(buf-&gt;a);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，定义了一个结构体 <code>buffer</code>，它包含一个整型变量 <code>len</code> 和一个零长度数组 <code>a</code>。</p>
<p>零长度数组是C语言中的一种特殊用法，它的长度为0，也就是没有元素。它通常用于结构体的最后一个成员，用于实现动态大小的数组。</p>
<p>在 <code>main</code> 函数中，首先通过调用 <code>malloc</code> 动态分配了一块内存，大小为 <code>sizeof(struct buffer) + 20</code>。这里的 <code>20</code> 表示额外的数据空间，用于存储字符串 “hello world”。</p>
<p>然后，将分配的内存地址强制转换为 <code>struct buffer*</code> 类型，并将其赋给指针变量 <code>buf</code>。</p>
<p>接下来，通过 <code>buf-&gt;len = 20</code>，将结构体成员 <code>len</code> 的值设置为 <code>20</code>。</p>
<p>然后，通过 <code>printf</code> 打印了指针变量 <code>buf</code> 的大小，即 <code>sizeof(buf)</code>。请注意，这里打印的是指针变量 <code>buf</code> 的大小，而不是结构体 <code>buffer</code> 的大小。因为指针变量的大小在不同的系统上是固定的，一般为 4 或 8 字节，不会随着结构体的大小而变化。</p>
<p>随后，通过 <code>strcpy</code> 将字符串 “hello world” 复制到结构体成员 <code>a</code> 中。</p>
<p>最后，通过 <code>puts</code> 打印结构体成员 <code>a</code> 中的字符串。</p>
<p>最后，通过 <code>free</code> 释放了之前动态分配的内存。</p>
<p>这个例子展示了零长度数组的一种使用方式，它允许在结构体中动态存储变长数据。需要注意的是，零长度数组只是一种技巧，并不是C语言标准中的定义。因此，使用零长度数组时需要注意编译器的兼容性和可移植性。</p>
<p>ShareLikeDislike</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.5 container_of</title>
    <url>/2023/09/07/5-5-container-of/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>container_of</code> 是一个在内核开发中常用的宏，用于根据结构体成员的地址获取整个结构体的首地址。</p>
<p>它的一般语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">container_of(ptr, type, member)</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>ptr</code> 是一个指向结构体成员的指针。</li>
<li><code>type</code> 是结构体的类型。</li>
<li><code>member</code> 是结构体中的成员名称。</li>
</ul>
<p><code>container_of</code> 宏会根据给定的结构体成员的地址 <code>ptr</code>，计算出整个结构体的首地址，并返回该地址。</p>
<p>在您提供的示例中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct student &#123;</span><br><span class="line">    int age;</span><br><span class="line">    int num;</span><br><span class="line">    int math;</span><br><span class="line">&#125; stu;</span><br><span class="line"></span><br><span class="line">p = container_of(&amp;stu.num, struct student, num);</span><br></pre></td></tr></table></figure>

<p>这段代码的目的是根据 <code>stu.num</code> 的地址获取整个 <code>struct student</code> 结构体的首地址，并将该地址赋给变量 <code>p</code>。</p>
<p>假设 <code>stu.num</code> 的地址为 <code>0x1000</code>，那么 <code>container_of</code> 宏会计算出 <code>stu</code> 的首地址为 <code>0x1000 - offset</code>，其中 <code>offset</code> 是 <code>num</code> 成员在 <code>struct student</code> 结构体中的偏移量。然后，将该地址赋给变量 <code>p</code>。</p>
<p>请注意，<code>container_of</code> 宏是在内核开发中使用的，不是标准的C语言库函数。它依赖于结构体成员在结构体中的布局和字节对齐方式。因此，在普通的应用程序开发中，一般不会使用 <code>container_of</code> 宏。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.4 typeof</title>
    <url>/2023/09/07/5-4-typeof/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>typeof</code> 是一个宏，在C语言中用于获取一个表达式或类型的类型。</p>
<p><code>typeof</code> 宏的参数可以是表达式或类型。如果参数是表达式，<code>typeof</code> 宏将返回该表达式的类型。如果参数是类型，<code>typeof</code> 宏将返回该类型。</p>
<p>以下是您提供的使用示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line">typeof(i) j = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>typeof(i)</code> 返回变量 <code>i</code> 的类型，然后将其用于声明变量 <code>j</code>。这意味着 <code>j</code> 的类型与 <code>i</code> 的类型相同，并且被初始化为 <code>20</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typeof(<span class="type">int</span> *) a;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>typeof(int *)</code> 返回 <code>int *</code> 类型。然后，该类型被用于声明变量 <code>a</code>，即 <code>a</code> 是一个指向整数的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">typeof(f()) k;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>typeof(f())</code> 返回函数 <code>f</code> 的返回类型。然后，该类型被用于声明变量 <code>k</code>，即 <code>k</code> 具有与函数 <code>f</code> 的返回类型相同的类型。</p>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><ol>
<li><code>typeof (int*);</code><br>这段代码使用 <code>typeof</code> 获取 <code>int*</code> 的类型，但没有将其用于任何声明或赋值操作。因此，它本身并没有实际意义。</li>
<li><code>typeof (int)*y;</code><br>这段代码将 <code>y</code> 定义为指向 <code>int</code> 类型的指针。由于 <code>typeof (int)</code> 返回 <code>int</code> 类型，因此这行代码等效于 <code>int *y;</code>。</li>
<li><code>typeof(*x) y;</code><br>这段代码将 <code>y</code> 定义为指针 <code>x</code> 指向的数据类型。 <code>typeof(*x)</code> 返回 <code>x</code> 指向的数据类型，因此这行代码等效于 <code>int y;</code>。</li>
<li><code>typeof (int)y[4];</code><br>这段代码定义了一个名为 <code>y</code> 的数组，数组元素的类型是 <code>int</code>，大小为 4。因此，这行代码等效于 <code>int y[4];</code>。</li>
<li><code>typeof (*x) y[4];</code><br>这段代码定义了一个名为 <code>y</code> 的数组，数组元素的类型是指针 <code>x</code> 指向的数据类型。由于 <code>typeof (*x)</code> 返回 <code>x</code> 指向的数据类型，因此这行代码等效于 <code>int *y[4];</code>，即 <code>y</code> 是一个指针数组，其中每个元素都是 <code>int*</code> 类型。</li>
<li><code>typeof (typeof (char *)[4]) y;</code><br>这段代码定义了一个名为 <code>y</code> 的字符指针数组，数组大小为 4。由于 <code>typeof (char*)</code> 返回 <code>char*</code> 类型，因此这行代码等效于 <code>char *y[4];</code>。</li>
<li><code>typeof(int x[4]) y;</code><br>这段代码定义了一个名为 <code>y</code> 的数组，数组元素的类型是 <code>int</code>，大小为 4。因此，这行代码等效于 <code>int y[4];</code>。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.3 语句表达式</title>
    <url>/2023/09/07/5-3-%E8%AF%AD%E5%8F%A5%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>语句表达式是一种特殊的表达式语法，它允许在一个表达式内部执行一系列语句，并返回最后一个表达式的值作为整个语句表达式的结果。</p>
<p>语句表达式的一般语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&#123; statement1; statement2; ...; last_expression; &#125;)</span><br></pre></td></tr></table></figure>

<p>在语句表达式中，可以包含多个语句，每个语句以分号分隔。这些语句可以是局部变量的声明、赋值语句、循环语句、条件语句、跳转语句等。</p>
<p>语句表达式的值是由最后一个表达式的值决定的。当整个语句表达式被求值时，会按照语句的顺序依次执行每个语句，直到达到最后一个表达式。最后一个表达式的值将作为整个语句表达式的结果返回。</p>
<p>以下是一个示例，展示了语句表达式的使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> result = (&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> z = x + y;</span><br><span class="line">    z; <span class="comment">// 最后一个表达式的值作为结果</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，语句表达式内部声明了三个局部变量 <code>x</code>、<code>y</code> 和 <code>z</code>，并计算了它们的和。最后一个表达式 <code>z</code> 的值被作为整个语句表达式的结果，并赋给变量 <code>result</code>。</p>
<p>语句表达式在某些情况下可以提供更灵活的编程方式，特别是在需要在表达式中执行复杂的语句序列时。但是，请注意，语句表达式是一个非标准的C语言扩展，在不同的编译器和平台上可能会有不同的支持程度。因此，在使用语句表达式时应该谨慎考虑可移植性和代码可读性</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.2 C标准发展过程及新增特性</title>
    <url>/2023/09/07/5-2-C%E6%A0%87%E5%87%86%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B%E5%8F%8A%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="5-2-1-预定义标识符"><a href="#5-2-1-预定义标识符" class="headerlink" title="5.2.1 预定义标识符"></a>5.2.1 预定义标识符</h1><ol>
<li><code>__DATE__</code>：该标识符表示当前源文件被编译时的日期，以字符串形式表示，格式为”MMM DD YYYY”。</li>
<li><code>__TIME__</code>：该标识符表示当前源文件被编译时的时间，以字符串形式表示，格式为”HH:MM:SS”。</li>
<li><code>__FILE__</code>：该标识符表示当前源文件的文件名，以字符串形式表示。</li>
<li><code>__func__</code>：该标识符表示当前函数的名称，以字符串形式表示。该标识符在C99标准中引入。</li>
<li><code>__FUNCTION__</code>：与<code>__func__</code>类似，也表示当前函数的名称，但在某些编译器中使用。</li>
<li><code>__LINE__</code>：该标识符表示当前代码行的行号，以整数形式表示。</li>
<li><code>include</code>：这不是一个预定义标识符，而是一个预处理指令，用于包含头文件。</li>
<li><code>define</code>：也是一个预处理指令，用于定义宏。</li>
<li><code>_STDC_</code>：该标识符用于指示编译器是否遵循ANSI C标准。如果编译器遵循ANSI C标准，则该标识符被定义为整数常量1。</li>
<li><code>printf</code>&#x2F;<code>scanf</code>：这些是C语言中的标准库函数，用于格式化输入和输出。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.1 什么是C语言标准？</title>
    <url>/2023/09/07/5-1-%E4%BB%80%E4%B9%88%E6%98%AFC%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="5-1-C语言的标准"><a href="#5-1-C语言的标准" class="headerlink" title="5.1 C语言的标准"></a>5.1 C语言的标准</h1><p>C语言的标准版本主要有以下几个：</p>
<ol>
<li>K&amp;R C：指的是《The C Programming Language》一书中描述的C语言，由Brian Kernighan和Dennis Ritchie编写。这本书是C语言开发的里程碑，但它不是正式的标准。</li>
<li>ANSI C：也称为C89或C90，是由美国国家标准学会（ANSI）于1989年采纳的C语言标准。它是第一个被广泛接受的C语言标准，并且成为后续标准的基础。</li>
<li>C99：它是于1999年采纳的C语言标准，也称为C89的修订版。该标准引入了一些新特性，如新的数据类型（比如布尔类型和复数类型）、变长数组、单行注释等。</li>
<li>C11：于2011年采纳的C语言标准，它是C语言的最新标准。C11引入了一些新特性，如泛型选择表达式、多线程支持、原子操作和_Static_assert等。</li>
</ol>
<h1 id="5-2-C标准和编译器"><a href="#5-2-C标准和编译器" class="headerlink" title="5.2 C标准和编译器"></a>5.2 C标准和编译器</h1><p>不同的编译器对C标准的支持程度可能会有所差异。以下是一些常见的编译器以及它们对C标准的支持情况的概述：</p>
<p>GCC编译器：<br>GCC（GNU Compiler Collection）是一个开源的编译器套件，支持多种编程语言，包括C语言。GCC对C标准的支持相对较好，可以支持多个C标准版本，如C89、C99和C11。您可以使用命令行选项来指定所需的C标准版本，例如使用”-std&#x3D;c89”来编译符合C89标准的代码。</p>
<p>ARM编译器：<br>ARM公司提供了针对ARM架构的编译器套件，其中包括ARM Compiler和GNU ARM Embedded Toolchain。这些编译器通常也支持多个C标准版本，具体取决于所使用的工具链版本和配置。</p>
<p>C51编译器：<br>C51是由Keil Software提供的针对8051系列微控制器的编译器。C51编译器主要支持ANSI C标准，即C89标准，但并不支持后续的C99或C11标准。</p>
<p>VC系列编译器：<br>VC（Visual C++）系列编译器是Microsoft Visual Studio提供的编译器套件。VC编译器对C标准的支持程度在不同版本中可能有所差异。早期版本的VC编译器主要支持C89标准，而较新的版本逐渐增加了对C99和部分C11特性的支持。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>4-16-实战&amp;作业：实现自己的堆管理器</title>
    <url>/2023/09/07/4-16-%E5%AE%9E%E6%88%98-%E4%BD%9C%E4%B8%9A%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-15-常见内存错误及检测</title>
    <url>/2023/09/07/4-15-%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF%E5%8F%8A%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-14-内存泄露与防范</title>
    <url>/2023/09/07/4-14-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B8%8E%E9%98%B2%E8%8C%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-13-Linux堆内存管理(3)：内存申请释放示例</title>
    <url>/2023/09/07/4-13-Linux%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-3-%EF%BC%9A%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E9%87%8A%E6%94%BE%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-12-linux堆内存管理(2)：内存申请与释放</title>
    <url>/2023/09/07/4-12-linux%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-2-%EF%BC%9A%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E4%B8%8E%E9%87%8A%E6%94%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-11-Linux堆内存管理(1)：内存分配器</title>
    <url>/2023/09/07/4-11-Linux%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-1-%EF%BC%9A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="4-11-1-Linux系统的堆"><a href="#4-11-1-Linux系统的堆" class="headerlink" title="4.11.1 Linux系统的堆"></a>4.11.1 Linux系统的堆</h1><p>在Linux系统中，堆地址空间通常位于用户空间，其大小受到多种因素的影响。以下是一些相关概念和信息：</p>
<ol>
<li>堆的空间分配：<ul>
<li>在Linux 2.4及之前的版本中，堆的起始地址通常是0x40000000。共享库被分配在该地址空间中，程序会被加载到这个地址空间中。</li>
<li>在Linux 2.6及之后的版本中，共享库的地址被移动到栈的附近（大约是0xBFxxxxxx附近），而堆的大小则有更多的灵活性。</li>
</ul>
</li>
<li>理论上的堆空间大小：<ul>
<li>在Linux系统中，用户空间的虚拟地址空间大小通常是2.9GB。这意味着理论上堆可以占据整个用户空间的一部分。</li>
</ul>
</li>
<li>brk和堆顶（SP）：<ul>
<li>在Linux系统中，使用<code>brk</code>系统调用来扩展或收缩堆的大小。<code>brk</code>系统调用将堆的顶部（堆顶）移动到指定的地址处。</li>
<li>堆顶（SP）是指当前堆的顶部地址，它指示了堆的结束位置。</li>
</ul>
</li>
<li>内核空间和用户空间：<ul>
<li>在Linux系统中，虚拟地址空间被分为内核空间和用户空间。内核空间是操作系统内核的专用区域，用户空间是供用户程序执行的区域。</li>
<li>堆地址空间位于用户空间，而内核空间用于操作系统内核和驱动程序。</li>
</ul>
</li>
</ol>
<h1 id="4-11-2-堆管理策略"><a href="#4-11-2-堆管理策略" class="headerlink" title="4.11.2 堆管理策略"></a>4.11.2 堆管理策略</h1><p>在堆的管理策略方面，以下是一些常见的方法：</p>
<ol>
<li>系统调用：<ul>
<li>在Linux系统中，内核负责管理整个虚拟地址空间的权限和地址转换。malloc和free等内存管理函数的底层实现通常通过系统调用来向内核申请和释放内存。</li>
<li>当程序调用malloc时，底层实现会使用系统调用（如brk或mmap）向内核请求一块适当大小的内存块。类似地，当调用free时，底层实现会通过系统调用将内存块返回给内核。</li>
</ul>
</li>
<li>内存管理器：<ul>
<li>内存管理器是一个软件模块，负责在应用程序中管理动态分配的内存。它可以包含一系列算法和数据结构，用于分配、回收和管理内存块。</li>
<li>内存管理器可以实现不同的策略，如内存池、分配器、垃圾回收等。这些策略可以根据应用程序的需求来优化内存使用效率和性能。</li>
</ul>
</li>
</ol>
<p>在具体实现中，系统调用和内存管理器可以结合使用。系统调用提供了与内核交互的底层接口，而内存管理器则在应用程序层面上提供更高级的内存管理功能。</p>
<p>关于地址空间布局，您提到的堆、栈和内核空间的位置是一种典型的布局。堆通常处于低地址空间，栈位于高地址空间，而内核空间则是供操作系统内核和驱动程序使用的区域。具体的地址空间布局可能会因操作系统和配置而有所差异。</p>
<h1 id="4-11-3-Glibc堆内存管理"><a href="#4-11-3-Glibc堆内存管理" class="headerlink" title="4.11.3 Glibc堆内存管理"></a>4.11.3 Glibc堆内存管理</h1><p>在Glibc中，使用ptmalloc2作为默认的堆内存分配器，用于管理动态分配的内存。下面是关于Glibc堆内存管理的一些要点：</p>
<ol>
<li>内存分配器：<ul>
<li>Glibc使用ptmalloc2作为默认的内存分配器，它是一个基于二叉树的分配器。它负责管理堆内存，并提供malloc、free等API供用户程序使用。</li>
</ul>
</li>
<li>系统调用：<ul>
<li>Glibc通过系统调用（如brk和mmap）向内核请求内存。brk系统调用用于调整堆的大小，mmap系统调用用于在堆外部映射更大的内存块。</li>
<li>brk系统调用可以按需增加或减小堆的大小，而mmap系统调用可以获取更大的内存区域。</li>
</ul>
</li>
<li>内存管理：<ul>
<li>Glibc的内存分配器会管理用户程序释放的空闲内存，以便在以后的内存分配中重用。这有助于减少频繁进行系统调用的开销，提高内存分配的性能。</li>
</ul>
</li>
</ol>
<p>关于地址空间布局，您提到的堆、栈和内核空间的位置是一种典型的布局。堆通常位于低地址空间，栈位于高地址空间，而内核空间则是操作系统内核和驱动程序的使用区域。具体的地址空间布局可能会因操作系统和配置而有所不同。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-10-ucos堆内存管理</title>
    <url>/2023/09/07/4-10-ucos%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在使用uC&#x2F;OS（Microcontroller Operating System）时，可以采用以下基本策略来进行内存管理：</p>
<ol>
<li>将堆内存分成若干区：<ul>
<li>首先，将可用的堆内存划分为若干个区域。每个区域可以有不同的大小和属性，以满足不同的内存需求。</li>
</ul>
</li>
<li>每个区分为若干大小相等的内存块：<ul>
<li>在每个区域内，将可用的内存划分为若干大小相等的内存块。这些内存块具有相同的大小，可以根据需要进行申请和释放。</li>
</ul>
</li>
<li>程序以内存块为单位对内存进行申请&#x2F;释放：<ul>
<li>程序在运行时以内存块为单位来申请和释放内存。通过使用特定的函数（如malloc和free），可以从内存块池中获取一个可用的内存块，并在不再需要时将其释放。</li>
</ul>
</li>
<li>指向下一个内存块：<ul>
<li>在内存块的数据结构中，可以包含一个指针字段，用于指向下一个可用的内存块。这样，在申请内存时，可以遍历内存块链表，找到合适大小的内存块并返回给程序。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-9-堆内存管理：内存申请与释放</title>
    <url>/2023/09/07/4-9-%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E4%B8%8E%E9%87%8A%E6%94%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="4-9-1-什么是堆"><a href="#4-9-1-什么是堆" class="headerlink" title="4.9.1 什么是堆"></a>4.9.1 什么是堆</h1><p>堆是程序运行时动态分配内存的一种区域。下面是对堆的说明：</p>
<ol>
<li>动态分配内存：<ul>
<li>堆是通过使用动态内存分配函数（如malloc、calloc等）从操作系统中获取的内存区域。</li>
<li>程序员可以根据需要在堆上动态分配内存，以存储变量、数据结构、对象等。</li>
<li>堆内存的大小可以根据实际需求进行动态扩展或缩减。</li>
</ul>
</li>
<li>内存管理：<ul>
<li>程序员负责在堆上申请所需的内存空间，并在不再需要时显式地释放内存，以避免内存泄漏。</li>
<li>堆内存的申请和释放通常是通过调用相应的内存管理函数（如malloc和free）来完成的。</li>
</ul>
</li>
</ol>
<p>堆与栈的区别：</p>
<ol>
<li>访问方式：<ul>
<li>堆内存中的内容是匿名的，没有直接的名称或标识符，无法按名字直接访问。程序员通过指针间接访问堆内存中的数据。</li>
<li>栈上的数据和变量可以通过其名称直接访问。</li>
</ul>
</li>
<li>生命周期：<ul>
<li>堆内存的生命周期由程序员自行管理。在动态分配内存后，程序员需要负责在适当的时候显式释放堆内存，以防止内存泄漏。</li>
<li>栈上的数据和变量的生命周期与其所在的函数相关。当函数返回时，栈上的数据会被自动释放，无法继续使用。</li>
</ul>
</li>
</ol>
<p>需要注意的是，如果程序员在堆上分配了内存但没有显式释放，这部分内存会一直存在，直到程序结束才会被操作系统回收。这可能导致内存泄漏，造成系统资源的浪费。</p>
<p>堆的动态分配和释放机制为程序提供了更大的灵活性和动态性，允许动态地管理内存，并根据需要进行内存的分配和释放。然而，这也需要程序员负责正确地管理堆内存，以避免内存泄漏和其他内存相关的问题。</p>
<h1 id="4-9-2-嵌入式裸机环境堆管理"><a href="#4-9-2-嵌入式裸机环境堆管理" class="headerlink" title="4.9.2 嵌入式裸机环境堆管理"></a>4.9.2 嵌入式裸机环境堆管理</h1><p>在嵌入式裸机环境中，堆的管理通常依赖于C库函数和启动文件的设置。以下是一般的嵌入式裸机环境中堆的管理方式：</p>
<ol>
<li>使用C库函数 malloc&#x2F;free：<ul>
<li>嵌入式系统通常会提供C库函数（如stdlib.h中的malloc和free函数），用于动态分配和释放堆内存。</li>
<li>程序员可以使用这些函数来在堆上动态分配所需的内存块，并在不再需要时释放内存。</li>
</ul>
</li>
<li>堆的大小及初始化：<ul>
<li>在嵌入式系统中，堆的大小和初始化通常由启动文件（如start_xx.s）来处理。</li>
<li>启动文件负责初始化系统的各个部分，其中包括堆的初始化。</li>
<li>启动文件会根据设定的堆大小，在适当的位置分配堆空间，并进行必要的初始化。</li>
</ul>
</li>
<li>设置堆的大小：<ul>
<li>堆的大小可以通过在启动文件中的_main函数中使用_user_initial_stackheap来获取堆栈地址。</li>
<li>_user_initial_stackheap函数会返回堆栈地址，在_main函数中可以使用这个地址来设置堆的大小。</li>
</ul>
</li>
<li>堆空间地址设置：<ul>
<li>堆空间的地址可以由编译器默认获取，通常会将堆地址设置在ZI（Zero Initialized）区域的后面。</li>
<li>或者，堆空间的地址可以通过scatter文件进行设置，在汇编启动代码中对这段堆空间进行初始化。</li>
</ul>
</li>
</ol>
<h1 id="4-9-3-内存碎片"><a href="#4-9-3-内存碎片" class="headerlink" title="4.9.3 内存碎片"></a>4.9.3 内存碎片</h1><p>内存碎片是指在内存中存在的一些零散的未被利用的内存空间。以下是关于内存碎片的产生以及相应的编程建议：</p>
<ol>
<li><p>内存碎片的产生：</p>
<ul>
<li>内存碎片通常是由于频繁地申请和释放内存导致的。当程序频繁地进行内存分配和释放操作时，会导致内存中出现大量的零散空闲区域，这些零散的空闲区域无法满足大块内存的需求。</li>
<li>内存碎片的产生也可能是由于内存分配算法的问题，如使用不合理的内存分配策略或算法，导致内存空间被分割成多个不连续的小块。</li>
</ul>
</li>
<li><p>编程建议：</p>
<ul>
<li>在裸机环境中尽量避免频繁使用malloc和free函数进行动态内存分配和释放。由于裸机环境资源有限，内存碎片可能会更加严重，频繁的内存分配和释放操作可能导致系统性能下降、内存耗尽或系统崩溃等问题。</li>
<li>尽量使用静态数组代替频繁的内存分配和释放操作。静态数组在编译时就被分配在固定的内存位置上，避免了动态分配和释放带来的内存碎片问题。</li>
<li>针对需要动态管理数据结构的情况，可以预先分配一块足够大的内存池，并手动管理内存的分配和释放。内存池可以是一个静态数组，程序员可以通过索引或指针来管理内存的使用，避免了频繁的内存分配和释放操作。</li>
</ul>
<h1 id="4-9-4-解决之道"><a href="#4-9-4-解决之道" class="headerlink" title="4.9.4 解决之道"></a>4.9.4 解决之道</h1></li>
</ol>
<p>解决内存碎片问题可以根据需求采取以下方法：</p>
<ol>
<li>内存池：<ul>
<li>内存池是一种固定大小的缓冲区，预先分配一定数量的内存块，然后根据需要从内存池中分配和释放内存。</li>
<li>内存池可以避免内存碎片问题，因为它使用固定大小的内存块，不会产生零散的内存碎片。</li>
<li>程序员可以根据需求，预先分配适当大小的内存池，通过索引或指针来管理内存的分配和释放。</li>
</ul>
</li>
<li>堆分配：<ul>
<li>在一些情况下，需要申请不同大小的内存缓冲区。可以使用堆分配（如malloc和free）来动态地申请和释放内存。</li>
<li>在使用堆分配时，可以考虑使用内存池的方式来管理堆内存，以避免频繁的内存碎片问题。</li>
</ul>
</li>
<li>不同系统平台的解决方案：<ul>
<li>在裸机平台上，没有操作系统的支持，程序员需要自己实现内存管理方案。可以根据需求选择合适的内存管理策略，如内存池或其他自定义的管理方式。</li>
<li>在操作系统平台上，可以让操作系统介入内存管理。操作系统提供了内存管理功能，可以动态分配和释放内存，并且通常有更高级的内存管理算法来优化内存的使用。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-8-实战：栈溢出攻击示例</title>
    <url>/2023/09/07/4-8-%E5%AE%9E%E6%88%98%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-7-栈溢出攻击原理</title>
    <url>/2023/09/07/4-7-%E6%A0%88%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-6-栈与作用域</title>
    <url>/2023/09/07/4-6-%E6%A0%88%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="4-6-1-变量的作用域和生命周期"><a href="#4-6-1-变量的作用域和生命周期" class="headerlink" title="4.6.1 变量的作用域和生命周期"></a>4.6.1 变量的作用域和生命周期</h1><p>变量的作用域和生命周期是关于变量可见性和存在时间的概念。下面是关于全局变量和局部变量的说明：</p>
<ol>
<li>全局变量：<ul>
<li>全局变量是在函数外部定义的变量，可以被整个程序中的函数访问和使用。</li>
<li>全局变量的作用域从其声明处开始，延伸到文件的结尾。这意味着它可以在声明处之后的任何位置使用。</li>
<li>全局变量可以在一个源文件中定义，然后通过在其他源文件中使用 <code>extern</code> 关键字进行声明和引用。</li>
</ul>
</li>
</ol>
<p>示例代码：</p>
<p>c</p>
<p>Copy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// file.c</span><br><span class="line">int a = 10;  // 在文件中定义全局变量</span><br><span class="line"></span><br><span class="line">// file2.c</span><br><span class="line">extern int a;  // 在另一个文件中使用 extern 关键字声明并引用全局变量</span><br><span class="line">printf(&quot;%d&quot;, a);</span><br></pre></td></tr></table></figure>

<ol>
<li>局部变量：<ul>
<li>局部变量是在函数体内部定义的变量，它们的作用域仅限于所在的函数内部。</li>
<li>局部变量只能在定义它们的函数内部使用，无法在函数外部访问。</li>
<li>局部变量的生命周期从函数被调用开始，到函数执行结束为止。每次函数调用时都会创建一个新的局部变量实例。</li>
</ul>
</li>
</ol>
<p>示例代码：</p>
<p>c</p>
<p>Copy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void myFunction() &#123;</span><br><span class="line">  int b = 20;  // 在函数内部定义局部变量</span><br><span class="line">  // 可以在函数内部使用局部变量b</span><br><span class="line">  // 局部变量的生命周期仅限于函数执行期间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局变量和局部变量的选择取决于变量在程序中的使用需求。全局变量具有全局可见性，可以在多个函数中共享，但会增加命名空间的复杂性。而局部变量具有更小的作用域和生命周期，对于只在函数内部使用的临时数据更加合适。</p>
<h1 id="4-6-2-为什么程序不能访问其他函数内的局部变量"><a href="#4-6-2-为什么程序不能访问其他函数内的局部变量" class="headerlink" title="4.6.2 为什么程序不能访问其他函数内的局部变量"></a>4.6.2 为什么程序不能访问其他函数内的局部变量</h1><p>程序不能访问其他函数内的局部变量的原因主要有两点：</p>
<ol>
<li>内存空间的分配：<ul>
<li>局部变量在函数被调用时才会在栈内分配内存空间。</li>
<li>每个函数都有自己的栈帧，用于存储局部变量和其他函数调用所需的信息。</li>
<li>当函数执行完毕，栈帧会被释放，局部变量所占用的内存空间也会被回收。</li>
</ul>
</li>
<li>作用域和生命周期：<ul>
<li>局部变量的作用域仅限于所在的函数内部，无法在函数外部访问。</li>
<li>在函数内部声明的局部变量只在函数运行期间有效，在函数执行完毕后就会被销毁。</li>
<li>其他函数无法直接访问该函数内部的局部变量，因为局部变量的作用域仅限于所在函数。</li>
</ul>
</li>
</ol>
<p>由于局部变量的内存空间是在函数调用时动态分配的，并且作用域和生命周期仅限于函数的执行过程，所以其他函数无法直接访问该函数的局部变量。如果需要在函数之间传递数据或共享变量，可以使用函数参数、全局变量或其他数据传递方式来实现。</p>
<h1 id="4-6-3-编译器栈管理"><a href="#4-6-3-编译器栈管理" class="headerlink" title="4.6.3 编译器栈管理"></a>4.6.3 编译器栈管理</h1><p>编译器通过栈管理来处理函数调用和局部变量的作用域。下面是对编译器栈管理的简要说明：</p>
<ol>
<li>函数调用：<ul>
<li>当一个函数被调用时，编译器会在栈上为该函数分配一个栈帧（也称为活动记录或帧）。</li>
<li>栈帧包含了该函数的局部变量、函数参数、返回地址和其他与函数调用相关的信息。</li>
<li>编译器通过在栈上进行压栈操作将栈帧入栈，以便在函数执行期间使用。</li>
</ul>
</li>
<li>局部变量的作用域：<ul>
<li>编译器通过栈帧的创建和销毁来限定局部变量的作用域。</li>
<li>在函数内部定义的局部变量只在函数执行期间存在，它们的内存空间位于函数的栈帧中。</li>
<li>当函数执行完毕时，编译器通过出栈操作销毁栈帧，同时销毁其中的局部变量，使其作用域终止。</li>
</ul>
</li>
</ol>
<p>编译器根据函数的调用关系和变量的作用域确定栈帧的分配和释放。每个函数的栈帧在栈上按照调用顺序依次入栈和出栈，保证了函数调用的正确执行和局部变量的正确作用域。这种栈管理机制使得函数可以嵌套调用，并且每个函数都有自己独立的局部变量空间，避免了命名冲突和数据混乱的问题。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-5-形参与实参</title>
    <url>/2023/09/07/4-5-%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="4-5-1-形参和实参"><a href="#4-5-1-形参和实参" class="headerlink" title="4.5.1 形参和实参"></a>4.5.1 形参和实参</h1><p>在函数调用过程中，形参（形式参数）和实参（实际参数）是用于传递数据的两个概念。下面是关于形参和实参的一些说明：</p>
<ol>
<li>形参：<ul>
<li>形参是在函数定义时声明的参数，用于在函数内部接收传递给函数的实参的值。</li>
<li>形参在函数内部被视为局部变量，可以在函数中使用和修改。</li>
<li>形参的作用是定义函数的参数类型和名称，以便在函数内对参数进行操作。</li>
</ul>
</li>
<li>实参：<ul>
<li>实参是在函数调用时传递给函数的值，可以是常量、变量、表达式或函数等。</li>
<li>实参的值会被传递给对应的形参，作为函数在执行过程中操作的数据。</li>
<li>实参的值在函数调用时确定，并被传递给形参，不会受到形参的修改影响。</li>
</ul>
</li>
</ol>
<p>形参值的改变并不能改变实参的原因可以从汇编代码的角度来分析。在函数调用过程中，实参的值被复制到栈或寄存器中，供函数内部使用。形参在函数内部作为局部变量存储，其值的改变只会影响函数内部的局部变量，而不会改变实参的值。</p>
<p>具体来说，汇编代码中的函数调用过程通常包括以下步骤：</p>
<ol>
<li>将实参的值通过寄存器或栈传递给函数。</li>
<li>在函数内部，实参的值被复制到函数的局部变量（即形参）中。</li>
<li>函数在执行过程中操作的是形参的值，而不是实参的值。</li>
<li>形参的值的改变只会影响函数内部的局部变量，不会影响实参的值。</li>
</ol>
<h1 id="4-5-2-为什么形参的改变不能改变实参"><a href="#4-5-2-为什么形参的改变不能改变实参" class="headerlink" title="4.5.2 为什么形参的改变不能改变实参?"></a>4.5.2 为什么形参的改变不能改变实参?</h1><p>形参的改变不能直接改变实参的值是因为它们在函数调用时位于不同的内存存储单元，并且实参的值被拷贝到形参的内存空间中。下面是更详细的解释：</p>
<ol>
<li>内存分配和释放：<ul>
<li>形参在函数调用时被创建，并在函数调用结束后被销毁。它们的内存分配和释放是自动进行的。</li>
<li>实参是在函数调用之前已经存在的变量或值，它们的内存分配和释放与函数调用无关。</li>
</ul>
</li>
<li>内存空间的分离：<ul>
<li>形参和实参通常位于不同的内存存储单元中。当函数被调用时，实参的值会被拷贝到形参的内存空间中。</li>
<li>形参在函数内部作为局部变量使用，并在函数执行期间修改它们的值。这些修改只会影响形参的值，而不会影响实参的值。</li>
</ul>
</li>
<li>值传递：<ul>
<li>在函数调用时，通过将实参的值拷贝到形参的内存空间中，实参和形参变成了两个相互独立的变量。</li>
<li>任何对形参的修改都只会影响形参本身，不会对实参产生任何影响。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-4-栈的管理：参数传递</title>
    <url>/2023/09/07/4-4-%E6%A0%88%E7%9A%84%E7%AE%A1%E7%90%86%EF%BC%9A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="4-4-1-参数传递和栈管理的常见规则"><a href="#4-4-1-参数传递和栈管理的常见规则" class="headerlink" title="4.4.1 参数传递和栈管理的常见规则"></a>4.4.1 参数传递和栈管理的常见规则</h1><p>对于栈的管理和参数传递，ARM架构遵循了ATPCS（ARM调用惯例）规则。以下是一些关于参数传递和栈管理的常见规则：</p>
<ol>
<li>参数传递：<ul>
<li>小于4个参数：使用寄存器RO~R3传递参数。参数依次存储在RO、R1、R2和R3寄存器中。</li>
<li>大于4个参数：剩余的参数按照从右到左的顺序压入栈中。首先将第5个参数压栈，然后是第6个参数，依此类推。</li>
</ul>
</li>
<li>返回值：<ul>
<li>函数的返回值通常存储在RO寄存器中。如果返回值是64位的，那么RO和R1两个寄存器一起存储返回值。</li>
</ul>
</li>
<li>函数参数入栈：<ul>
<li>被调用函数将寄存器RO~R3传递来的参数压栈保存。这样做是为了在被调用函数内部能够正确访问函数参数。</li>
</ul>
</li>
</ol>
<p>这些规则确保了参数的正确传递和函数调用的一致性。小于4个参数的情况下，参数直接传递到寄存器中，避免了频繁的内存访问。而大于4个参数的情况下，额外的参数通过栈进行传递。被调用函数将寄存器中的参数入栈保存，以便在函数内部能够访问和使用这些参数。</p>
<h1 id="4-4-2-调用惯例"><a href="#4-4-2-调用惯例" class="headerlink" title="4.4.2 调用惯例"></a>4.4.2 调用惯例</h1><p>函数调用的约定是编程语言或操作系统规定的一种规则，用于定义函数调用时参数传递、返回值处理以及栈的清理方式。下面是一般情况下的函数调用约定：</p>
<ol>
<li>函数调用双方的约定：<ul>
<li>函数调用者（caller）：调用函数的代码。</li>
<li>函数被调用者（callee）：被调用的函数。</li>
</ul>
</li>
<li>参数压栈方式：<ul>
<li>参数通常按照从右至左的顺序依次压入栈中，即最右边的参数先被压入栈。</li>
</ul>
</li>
<li>栈清理：<ul>
<li>调用者负责清理栈上的参数。这意味着在函数调用完成后，调用者会从栈上移除传递给被调用函数的参数。</li>
</ul>
</li>
<li>默认的调用惯例：<ul>
<li>在C语言中，默认的调用惯例是 cdecl（C declaration），也被称为标准调用约定。</li>
<li>参数传递：按照从右至左的顺序将参数压入栈中。</li>
<li>栈清理：由调用者负责清理栈上的参数。</li>
<li>返回值：通常通过寄存器进行返回，如整数类型的返回值使用 EAX 寄存器，浮点类型的返回值使用 ST0 寄存器。</li>
</ul>
</li>
</ol>
<p>好处：</p>
<ul>
<li>预先知道参数和返回值的大小，可以在函数调用前提前分配好栈空间或寄存器。</li>
<li>支持变参函数的调用，例如 <code>printf</code> 函数，它可以接受不定数量的参数。</li>
</ul>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-3-栈的管理：函数调用</title>
    <url>/2023/09/07/4-3-%E6%A0%88%E7%9A%84%E7%AE%A1%E7%90%86%EF%BC%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="4-3-1-栈的作用"><a href="#4-3-1-栈的作用" class="headerlink" title="4.3.1 栈的作用"></a>4.3.1 栈的作用</h1><ol>
<li>保存函数上下文：<br>当一个函数被调用时，当前函数的执行状态需要保存下来，以便在函数执行完毕后能够正确返回到调用者处继续执行。栈用于保存函数的上下文信息，包括调用者栈帧地址（Frame Pointer，FP）和返回地址（Link Register，LR）。FP指向调用者函数的栈帧，而LR保存了函数返回后应继续执行的地址。</li>
<li>保存局部变量：<br>函数中声明的局部变量通常存储在栈中。每当一个函数被调用时，栈会为该函数分配一块新的栈帧空间，用于存储函数的局部变量。这样可以确保每个函数都有自己独立的内存空间来保存局部变量，避免不同函数之间的变量冲突。</li>
<li>传递函数的参数：<br>函数调用时，参数值会被传递给被调用函数。在栈的帮助下，这些参数可以被正确地传递给被调用函数并被保存在适当的位置。通常，函数参数通过栈中的一定偏移量来进行传递和访问。</li>
<li>保存函数的参数：<br>在函数调用时，除了传递参数给被调用函数外，栈还负责保存函数的参数。这是因为函数的参数通常需要在函数执行过程中被访问和使用。栈的帮助下，函数可以在需要时方便地访问到其参数。</li>
</ol>
<h1 id="4-3-2-栈帧"><a href="#4-3-2-栈帧" class="headerlink" title="4.3.2 栈帧"></a>4.3.2 栈帧</h1><p>栈帧（Stack Frame）是在函数调用期间在栈上分配的一块连续内存区域，用于存储函数的局部变量、函数参数、返回地址等信息。每个函数调用都会创建一个新的栈帧，形成多个栈帧构成的调用栈。</p>
<p>栈帧由以下几个主要部分组成：</p>
<ol>
<li>Frame Pointer（FP）：也称为帧指针，是一个特殊的寄存器（在某些体系结构中为R11），用于指向上一层函数的栈帧的栈底。通过FP，可以在函数执行过程中轻松地访问上一级函数的局部变量和函数参数。</li>
<li>局部变量：栈帧中的一部分用于存储函数的局部变量。这些局部变量是在函数内部声明的变量，在函数执行期间可以被访问和修改。</li>
<li>函数参数：函数调用时传递给函数的参数值也存储在栈帧中。这些参数值通过栈帧进行传递和访问。</li>
<li>返回地址：在函数调用过程中，当函数执行完毕后需要返回到调用者处继续执行。返回地址用于保存函数返回后应继续执行的地址，通常保存在栈帧中。</li>
<li>临时存储区：栈帧还可以包含其他临时存储区，用于保存临时数据、寄存器的备份等。</li>
</ol>
<p>通过多个栈帧的连接，构成了某个进程的调用栈。每次函数调用时，当前函数的栈帧被创建并添加到调用栈的顶部，函数执行完毕后，栈帧被销毁，控制权返回到上一层函数。</p>
<p>栈帧的存在使得函数调用和返回过程能够正确执行，并且提供了函数内部数据的存储和访问机制，保证了函数的独立性和数据的正确性。</p>
<h1 id="4-3-3-ARM汇编指令"><a href="#4-3-3-ARM汇编指令" class="headerlink" title="4.3.3 ARM汇编指令"></a>4.3.3 ARM汇编指令</h1><ol>
<li>寄存器间接寻址：<ul>
<li><code>LDR RO, [R1,#4]</code>：将存储在地址<code>R1+4</code>处的数据加载到寄存器RO中。</li>
<li><code>LDR RO, [R1,#4]!</code>：将存储在地址<code>R1+4</code>处的数据加载到寄存器RO中，并将<code>R1</code>的值增加4。</li>
<li><code>LDR RO, [R1], #4</code>：将存储在地址<code>R1</code>处的数据加载到寄存器RO中，并将<code>R1</code>的值增加4。</li>
<li><code>LDR RO, [R1,R2]</code>：将存储在地址<code>R1+R2</code>处的数据加载到寄存器RO中。</li>
</ul>
</li>
<li>入栈出栈：<ul>
<li><code>PUSH &#123;FP,LR&#125;</code>：将FP（帧指针）和LR（链接寄存器）的值压入栈中。这通常用于保存函数的上下文信息。</li>
<li><code>POP &#123;FP,PC&#125;</code>：从栈中弹出值，将其赋给FP（帧指针）和PC（程序计数器）。这通常用于恢复函数的上下文信息并返回到调用者处。</li>
</ul>
</li>
</ol>
<p>在这些示例中，R1、R2、RO、FP和LR是ARM架构中的寄存器，SP代表栈指针。这些指令用于实现寄存器间接寻址和栈操作，以便在汇编语言中实现数据的加载和存储，以及函数的调用和返回。请注意，这只是一些常见的示例，ARM汇编指令非常丰富，具体的使用和语法可能因特定的应用场景和编译器而有所不同。</p>
<h1 id="4-3-4-栈举例-函数调用"><a href="#4-3-4-栈举例-函数调用" class="headerlink" title="4.3.4 栈举例:函数调用"></a>4.3.4 栈举例:函数调用</h1><p>以下是一个简单的函数调用的示例，展示了在函数调用过程中栈的使用情况：</p>
<p>假设有两个函数，函数A调用函数B。</p>
<ol>
<li>函数A的栈帧：<ul>
<li>FP（帧指针）指向上一层函数的栈帧的栈底。</li>
<li>LR（返回地址）保存着函数A调用完函数B后应继续执行的地址。</li>
<li>局部变量和函数参数存储在栈帧中。</li>
<li>临时存储区用于保存临时数据。</li>
</ul>
</li>
<li>函数B的栈帧：<ul>
<li>FP指向函数A的栈帧的栈底。</li>
<li>LR保存着函数B调用完后应继续执行的地址。</li>
<li>局部变量和函数参数存储在栈帧中。</li>
<li>临时存储区用于保存临时数据。</li>
</ul>
</li>
</ol>
<p>函数调用过程示例：</p>
<ol>
<li>函数A开始执行：<ul>
<li>函数A的栈帧被创建并压入栈中，包括FP、LR、局部变量和函数参数。</li>
<li>函数A执行过程中可能对局部变量进行读写操作。</li>
</ul>
</li>
<li>函数A调用函数B：<ul>
<li>函数A将函数参数传递给函数B，参数存储在函数B的栈帧中。</li>
<li>函数A将LR的值设置为调用函数B后应继续执行的地址。</li>
<li>函数A跳转到函数B的入口地址开始执行。</li>
</ul>
</li>
<li>函数B开始执行：<ul>
<li>函数B的栈帧被创建并压入栈中，包括FP、LR、局部变量和函数参数。</li>
<li>函数B执行过程中可能对局部变量进行读写操作。</li>
</ul>
</li>
<li>函数B执行完毕：<ul>
<li>函数B将返回值存储在指定的寄存器中（例如R0）。</li>
<li>函数B将LR的值设置为返回地址，即函数A调用函数B的下一条指令地址。</li>
<li>函数B将栈帧释放，即出栈。</li>
</ul>
</li>
<li>函数A继续执行：<ul>
<li>函数A根据函数B的返回值进行下一步操作。</li>
<li>函数A将栈帧释放，即出栈。</li>
</ul>
</li>
</ol>
<p>在函数调用过程中，栈的使用和管理确保了函数的正确执行、局部变量的隔离和数据的传递。栈帧的创建和释放，以及栈指针的维护，保证了函数调用的顺序和返回的正确性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">30</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">40</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">4</span>;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-2-栈的初始化及大小</title>
    <url>/2023/09/07/4-2-%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="4-2-1-什么是栈"><a href="#4-2-1-什么是栈" class="headerlink" title="4.2.1 什么是栈"></a>4.2.1 什么是栈</h1><p>栈（Stack）是一种常见的数据结构，它遵循先进后出（FILO，First In Last Out）的原则。栈可以通过两个基本操作来操作元素：入栈（Push）和出栈（Pop）。</p>
<ol>
<li><p>入栈（Push）操作：</p>
<ul>
<li>入栈将一个元素添加到栈的顶部（也称为栈顶）。</li>
<li>入栈操作会将元素压入栈中，栈的大小增加。</li>
<li>入栈的元素成为新的栈顶。</li>
</ul>
</li>
<li><p>出栈（Pop）操作：</p>
<ul>
<li><p>出栈将栈顶的元素移除，并返回该元素。</p>
</li>
<li><p>出栈操作会将栈顶元素弹出，栈的大小减少。</p>
</li>
<li><p>出栈的元素是最近入栈的元素，即最后一个添加到栈中的元素。</p>
</li>
</ul>
<p>栈的操作可以用以下伪代码表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Push(<span class="built_in">stack</span>, element):</span><br><span class="line">    将元素添加到栈的顶部</span><br><span class="line">    栈的大小增加</span><br><span class="line">    新的栈顶指向添加的元素</span><br><span class="line"></span><br><span class="line">Pop(<span class="built_in">stack</span>):</span><br><span class="line">    如果栈为空，则抛出异常或返回特定值（取决于实现）</span><br><span class="line">    保存栈顶元素的值</span><br><span class="line">    将栈顶元素移除</span><br><span class="line">    栈的大小减少</span><br><span class="line">    返回保存的栈顶元素的值</span><br></pre></td></tr></table></figure>

<p>栈在计算机科学中有广泛的应用，例如函数调用栈、表达式求值、深度优先搜索等。由于栈的先进后出的特性，它可以提供简单有效的数据存储和访问方式。</p>
</li>
</ol>
<h1 id="4-2-2-线的作用"><a href="#4-2-2-线的作用" class="headerlink" title="4.2.2 线的作用"></a>4.2.2 线的作用</h1><ol>
<li><h2 id="函数调用："><a href="#函数调用：" class="headerlink" title="函数调用："></a>函数调用：</h2><ul>
<li>栈被广泛用于函数调用过程中的参数传递、局部变量和函数返回值的存储。</li>
<li>当一个函数被调用时，函数的参数会被压入栈中，然后函数的局部变量也会被分配在栈上。</li>
<li>函数执行完毕后，栈会按照相反的顺序弹出参数和局部变量，返回值也会通过栈传递回调用函数。</li>
</ul>
</li>
<li><h2 id="编译器生成的临时变量："><a href="#编译器生成的临时变量：" class="headerlink" title="编译器生成的临时变量："></a>编译器生成的临时变量：</h2><ul>
<li>编译器在编译过程中会生成一些临时变量，用于存储中间计算结果或其他需要临时存储的数据。</li>
<li>这些临时变量通常会被存储在栈上，随着程序的执行进入和离开作用域而动态地压入和弹出栈。</li>
</ul>
</li>
<li><h2 id="内存管理："><a href="#内存管理：" class="headerlink" title="内存管理："></a>内存管理：</h2><ul>
<li>栈的一部分常用于存储程序的调用栈，用于跟踪函数调用和返回的地址。</li>
<li>操作系统还使用栈来管理进程的堆栈空间，为每个线程和进程分配一块私有的栈空间。</li>
</ul>
</li>
<li><h2 id="表达式求值："><a href="#表达式求值：" class="headerlink" title="表达式求值："></a>表达式求值：</h2><ul>
<li>在编译器或解释器中，栈常用于表达式求值的过程中，用于存储运算符和操作数。</li>
<li>通过栈的先进后出的特性，可以按照正确的优先级和顺序对表达式进行求值。</li>
</ul>
</li>
</ol>
<h1 id="4-2-3-栈初始化"><a href="#4-2-3-栈初始化" class="headerlink" title="4.2.3 栈初始化"></a>4.2.3 栈初始化</h1><p>栈的初始化是在程序执行之前进行的，它涉及到栈指针的设置和栈空间的分配。具体的栈初始化过程可能因处理器架构和操作系统而有所差异。</p>
<p>下面是一些常见的栈初始化方式和相关的寄存器：</p>
<ol>
<li>ARM 架构：<ul>
<li>栈指针寄存器（Stack Pointer Register）：ARM 架构中的栈指针寄存器是 SP（R13）。</li>
<li>初始化栈指针：在启动时，操作系统或引导加载程序会设置 SP 寄存器的值，指向栈的初始位置。</li>
<li>帧指针寄存器（Frame Pointer Register）：ARM 架构中的帧指针寄存器是 FP（R11），用于访问函数的局部变量和参数。</li>
<li>在函数调用过程中，栈指针 SP 会动态地进行调整，而帧指针 FP 则用于指向当前函数的栈帧。</li>
</ul>
</li>
<li>x86 架构：<ul>
<li>栈指针寄存器（Stack Pointer Register）：x86 架构中的栈指针寄存器是 ESP（栈顶指针）和 EBP（栈底指针）。</li>
<li>初始化栈指针：在启动时，操作系统或引导加载程序会设置 ESP 寄存器的值，指向栈的初始位置。</li>
<li>在函数调用过程中，ESP 会动态地进行调整，用于栈帧的分配和释放。</li>
<li>基址指针寄存器（Base Pointer Register）：x86 架构中的基址指针寄存器是 EBP，用于在函数中访问局部变量和参数。</li>
</ul>
</li>
</ol>
<h1 id="4-2-4-栈的起始地址"><a href="#4-2-4-栈的起始地址" class="headerlink" title="4.2.4 栈的起始地址"></a>4.2.4 栈的起始地址</h1><p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309070809175.png" alt="image-20230907080956110"></p>
<p>栈的起始地址是根据操作系统和编译器的实现而定的。栈通常位于内存的高地址区域，并在程序执行前被初始化。</p>
<p>下面是一些常见的栈起始地址情况：</p>
<ol>
<li>用户空间：<ul>
<li>在用户空间的程序中，栈通常从高地址向低地址增长。</li>
<li>栈的起始地址可以是固定的，也可以在每次程序执行时动态分配。</li>
<li>在某些操作系统中，栈的起始地址可以通过随机偏移（Random Offset）来增加安全性，防止缓冲区溢出攻击。</li>
</ul>
</li>
<li>内核空间：<ul>
<li>在内核空间中，栈的起始地址通常是固定的，由操作系统内核决定。</li>
<li>内核栈用于处理中断、异常和系统调用等内核级别的任务。</li>
<li>内核栈的起始地址可能与用户空间的栈起始地址不同，且通常位于内核空间的高地址区域。</li>
</ul>
</li>
</ol>
<p>在一些特殊情况下，也可能使用其他内存区域作为栈的起始地址，例如堆（heap）或通过内存映射（mmap）分配的内存区域。但是，栈通常独立于堆和内存映射区域。</p>
<p>栈的英文是stack</p>
<h1 id="4-2-5-栈的大小"><a href="#4-2-5-栈的大小" class="headerlink" title="4.2.5 栈的大小"></a>4.2.5 栈的大小</h1><p>栈的大小是指栈所占用的内存空间大小。栈的大小在不同的操作系统和编译器中有所不同。</p>
<p>对于 Linux 操作系统的进程栈大小，可以使用 ulimit 命令来查看和设置。下面是相关命令的说明：</p>
<ul>
<li>查看堆栈大小：使用命令 <code>ulimit -s</code> 可以查看当前进程的堆栈大小限制。</li>
<li>设置堆栈大小：使用命令 <code>ulimit -s size</code> 可以设置当前进程的堆栈大小限制，其中 size 是以 KB 为单位的大小值。</li>
</ul>
<p>需要注意的是，增加堆栈容量会增加内存开销和启动时间。因此，需要合理配置堆栈大小，以满足程序的需求，同时避免浪费资源。</p>
<p>栈溢出（Stack Overflow）是指当栈空间不足以容纳新的栈帧时，导致栈指针超出了栈的边界。这通常发生在递归函数调用层次过深或者局部变量占用过多栈空间的情况下。当发生栈溢出时，会导致段错误（Segmentation Fault）或程序异常退出。</p>
<p>在最大堆栈大小的限制内，栈可以动态增长，即在需要时自动分配更多的栈空间。但是，若超过了最大堆栈大小限制，就会发生栈溢出。</p>
<p>栈溢出的实例可以是一个递归函数调用层次过深，或者一个函数中声明了大量的局部变量导致栈空间不足的情况。当栈溢出发生时，程序无法正确地管理栈帧，导致异常行为或崩溃。</p>
<p>为了避免栈溢出，应该合理控制递归深度、减少局部变量的使用或者使用动态内存管理（如堆）来存储大量数据。</p>
<p>总结：栈的大小在不同的操作系统和编译器中有所不同。在 Linux 操作系统中，可以使用 ulimit 命令来查看和设置进程的堆栈大小。增加堆栈容量会增加内存开销和启动时间，而栈溢出会导致段错误或程序异常退出。栈在最大堆栈大小内可以动态增长，但超过最大值会导致栈溢出。为了避免栈溢出，应合理控制递归深度、减少局部变量的使用或使用动态内存管理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>main</code>函数中声明了一个名为<code>a</code>的字符数组，其大小为8MB（8<em>1024</em>1024字节）。然后，你使用<code>printf</code>函数打印了一条”hello world!”的消息，并通过<code>return 0</code>语句结束了<code>main</code>函数。</p>
<p>需要注意的是，你在栈上声明了一个非常大的数组（8MB），这可能会导致栈溢出。栈的大小是有限的，并且在不同的操作系统和编译器中有所不同。默认情况下，大多数操作系统都有一个较小的栈大小限制。因此，声明过大的局部数组可能会导致栈溢出，导致程序崩溃。</p>
<p>如果你需要使用大量内存，建议使用堆分配（例如使用<code>malloc</code>函数）来动态分配内存空间，而不是在栈上声明大型数组。这样可以避免栈溢出的风险。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-1-程序与内存的关系</title>
    <url>/2023/09/07/4-1-%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%86%85%E5%AD%98%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="4-1-1-虚拟地址空间"><a href="#4-1-1-虚拟地址空间" class="headerlink" title="4.1.1 虚拟地址空间"></a>4.1.1 虚拟地址空间</h1><p>Linux进程的内存映像包括虚拟地址空间、可执行文件的不同部分加载到内存的方式、内存管理以及内核空间。</p>
<ol>
<li>虚拟地址空间：每个Linux进程都有自己的虚拟地址空间，它是一个由连续虚拟地址组成的范围。虚拟地址空间将进程的内存分为不同的区域，包括代码段、数据段、堆、栈和映射区等。</li>
<li>所有程序的编译链接起始地址相同：在Linux中，所有程序的编译链接起始地址通常是相同的，默认为0x08048000。这是由于可执行文件的加载器将可执行文件的代码段加载到这个地址开始的内存区域。</li>
<li>可执行文件中的不同的section加载到读写权限不同的内存：可执行文件通常包含不同的部分，如代码段、数据段、BSS段等。这些不同的段在加载到内存时可能具有不同的读写权限。例如，代码段通常被设置为只读，数据段和BSS段可以被写入。</li>
<li>Linux通过MMU和页表来管理内存：Linux使用内存管理单元（Memory Management Unit，MMU）和页表来实现虚拟地址到物理地址的映射以及内存权限的管理。MMU将进程的虚拟地址转换为物理地址，并根据页表中的权限信息来管理内存的读写和执行权限。</li>
<li>内核空间：除了每个进程的虚拟地址空间之外，Linux还有一个特殊的内核空间，用于操作系统内核及其相关数据结构。内核空间的地址范围通常是高于用户进程的地址范围，进程无法直接访问或修改内核空间的内容，需要通过系统调用来与内核进行交互。</li>
</ol>
<h1 id="4-1-2-内核空间与用户空间"><a href="#4-1-2-内核空间与用户空间" class="headerlink" title="4.1.2 内核空间与用户空间"></a>4.1.2 内核空间与用户空间</h1><p>内核空间和用户空间是计算机操作系统中的两个重要概念，用于区分操作系统内核和用户应用程序的内存空间。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309070753828.png" alt="image-20230907075313755"></p>
<ol>
<li>内核空间：<ul>
<li>所有进程的内核空间都映射到相同的物理内存区域。</li>
<li>内核空间包含操作系统内核及其相关数据结构，例如设备驱动程序、调度器、文件系统等。</li>
<li>进程无法直接访问或修改内核空间的内容，需要通过系统调用接口与内核进行交互。</li>
<li>内核空间通常位于高地址范围，例如在x86架构中，内核空间通常从0x80000000开始。</li>
</ul>
</li>
<li>用户空间：<ul>
<li>每个进程都有自己独立的用户空间，与其他进程的用户空间相互隔离。</li>
<li>每个用户空间分别映射到不同的物理内存区域。</li>
<li>用户空间包含应用程序的代码、数据、堆、栈等。</li>
<li>用户空间的应用程序可以直接访问和操作其自身的用户空间内存。</li>
</ul>
</li>
</ol>
<p>应用程序访问内核空间的方式主要有两种：</p>
<ol>
<li>系统调用：应用程序通过系统调用接口向内核发出请求，请求执行特权操作或获取内核提供的服务。系统调用将应用程序的执行切换到内核空间，内核在接收到系统调用请求后执行相应的操作，并将结果返回给应用程序。</li>
<li>中断：应用程序可以通过触发中断事件来请求内核的处理。例如，硬件设备发生中断时，会引发中断请求，内核会在中断处理程序中对中断进行处理，并执行相应的操作。</li>
</ol>
<h1 id="4-1-3-地址映射"><a href="#4-1-3-地址映射" class="headerlink" title="4.1.3 地址映射"></a>4.1.3 地址映射</h1><p>地址映射是指将进程的虚拟地址映射到物理内存的过程。在操作系统中，地址映射是通过页表（Page Table）或者快速缓存翻译（Translation Lookaside Buffer，TLB）来实现的。</p>
<ol>
<li>虚拟地址通过页表&#x2F;TLB映射到物理内存：<ul>
<li>当进程访问虚拟地址时，操作系统将通过页表或者TLB进行地址转换，将虚拟地址映射到物理内存地址。</li>
<li>页表是操作系统维护的数据结构，记录了虚拟地址到物理地址的映射关系。每个进程都有自己的页表。</li>
<li>TLB是一个高速缓存，存储最近使用的页表项，以提高地址转换的速度。TLB中的页表项是虚拟地址到物理地址的映射。</li>
</ul>
</li>
<li>页表由操作系统维护，记录虚拟地址到物理地址的映射关系：<ul>
<li>操作系统负责创建和管理页表，其中包括建立和更新页表项。</li>
<li>当进程切换时，操作系统会切换对应的页表，以确保不同进程之间的地址映射独立和安全。</li>
</ul>
</li>
<li>通过页表还设置内存权限：读、写、可执行：<ul>
<li>页表不仅用于地址映射，还可以设置内存的访问权限。每个页表项可以指定对应虚拟页的读、写、执行权限。</li>
<li>当进程访问虚拟地址时，操作系统会检查页表项中设置的权限，以确定是否允许对物理内存的读取、写入或执行操作。</li>
</ul>
</li>
</ol>
<h1 id="4-1-4-为什么使用虚拟内存"><a href="#4-1-4-为什么使用虚拟内存" class="headerlink" title="4.1.4 为什么使用虚拟内存"></a>4.1.4 为什么使用虚拟内存</h1><p>使用虚拟内存的目的是为了解决物理内存的限制并提供更好的内存管理和系统安全性。以下是一些使用虚拟内存的主要原因：</p>
<ol>
<li>避免使用物理内存带来的弊端：<ul>
<li>物理内存是有限的资源，虚拟内存允许操作系统将物理内存和磁盘空间组合使用，从而扩展可用的内存空间。</li>
<li>虚拟内存允许将不常用的数据从物理内存转移到磁盘上的交换空间，以释放物理内存供其他进程使用。</li>
</ul>
</li>
<li>为每个进程提供一个独立的、私有的地址空间：<ul>
<li>每个进程都拥有自己独立的虚拟地址空间，使得进程之间的内存地址互相隔离，每个进程都可以认为自己在独占整个内存空间。</li>
<li>这样可以使得每个进程在运行时无需关心其他进程的内存布局和地址冲突问题，简化了进程间的通信和协作。</li>
</ul>
</li>
<li>保护每个进程的空间不被其他进程破坏：<ul>
<li>虚拟内存通过地址隔离，防止一个进程访问或修改其他进程的内存数据，提供了进程间的安全隔离。</li>
<li>如果一个进程尝试访问其它进程的地址空间，操作系统会通过内存保护机制触发异常，并终止非法操作，从而保护系统的稳定性和安全性。</li>
</ul>
</li>
<li>内存读写权限管理，保障系统的安全运行：<ul>
<li>虚拟内存管理机制允许操作系统对每个进程的内存区域设置读、写、执行等权限，以实现细粒度的内存保护。</li>
<li>操作系统可以通过页表或者段表等数据结构，对虚拟地址与物理地址的映射进行权限控制，防止恶意进程修改或访问非法内存区域。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>1-70-参考文档:设备树bindings</title>
    <url>/2023/09/05/1-70-%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3-%E8%AE%BE%E5%A4%87%E6%A0%91bindings/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第70章-参考文档：设备树bindings"><a href="#第70章-参考文档：设备树bindings" class="headerlink" title="第70章 参考文档：设备树bindings"></a>第70章 参考文档：设备树bindings</h1><p>在前面的章节中，我们已经介绍了许多设备树编写相关的知识，当然上面我们讲解的都是标准属性，但当我们遇到非标准属性或无法理解的属性时，要如何处理呢？这时候就不得不提到bindings文档了。</p>
<p>Documentation&#x2F;devicetree&#x2F;bindings目录是Linux内核源码中的一个重要目录，用于存储设备树（Device Tree）的bindings文档。设备树是一种描述硬件平台和设备配置的数据结构，它以一种可移植和独立于具体硬件的方式描述了设备的属性、寄存器配置、中断信息等。</p>
<p>bindings目录中的文档提供了有关设备树的各种设备和驱动程序的详细说明和用法示例。这些文档对于开发人员来说非常重要，因为它们提供了在设备树中描述硬件和配置驱动程序所需的属性和约定。bindings目录截图如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025637.jpeg" alt="img"> </p>
<p>接下来对Documentation&#x2F;devicetree&#x2F;bindings目录的一些常见子目录和其内容的概述：</p>
<p>arm：包含与ARM体系结构相关的设备和驱动程序的bindings文档。</p>
<p>clock：包含与时钟设备和时钟控制器相关的bindings文档。</p>
<p>dma：包含与直接内存访问（DMA）控制器和设备相关的bindings文档。</p>
<p>gpio：包含与通用输入输出（GPIO）控制器和设备相关的bindings文档。</p>
<p>i2c：包含与I2C总线和设备相关的bindings文档。</p>
<p>interrupt-controller：包含与中断控制器相关的bindings文档。</p>
<p>media：包含与多媒体设备和驱动程序相关的bindings文档。</p>
<p>mfd：包含与多功能设备（MFD）子系统和设备相关的bindings文档。</p>
<p>networking：包含与网络设备和驱动程序相关的bindings文档。</p>
<p>power：包含与电源管理子系统和设备相关的bindings文档。</p>
<p>spi：包含与SPI总线和设备相关的bindings文档。</p>
<p>usb：包含与USB控制器和设备相关的bindings文档。</p>
<p>video：包含与视频设备和驱动程序相关的bindings文档。</p>
<p>每个子目录中的文档通常以.txt或.yaml的扩展名保存，使用文本或YAML格式编写。这些文档提供了有关设备树中属性的详细说明、属性的语法、可选值和用法示例。它们还描述了设备树的约定和最佳实践，以帮助开发人员正确地配置和描述硬件设备和驱动程序。</p>
<p>通过阅读Documentation&#x2F;devicetree&#x2F;bindings目录中的文档，开发人员可以了解各种设备和驱动程序的设备树属性的含义和用法，以便正确地配置和描述硬件平台和设备。这有助于实现硬件与软件之间的正确匹配和交互，使系统能够正确识别和使用硬件设备。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-69-of操作函数实验:获取中断资源</title>
    <url>/2023/09/05/1-69-of%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E5%AE%9E%E9%AA%8C-%E8%8E%B7%E5%8F%96%E4%B8%AD%E6%96%AD%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第69章-of操作函数实验：获取中断资源"><a href="#第69章-of操作函数实验：获取中断资源" class="headerlink" title="第69章 of操作函数实验：获取中断资源"></a>第69章 of操作函数实验：获取中断资源</h1><h2 id="69-1-of操作：获取中断资源"><a href="#69-1-of操作：获取中断资源" class="headerlink" title="69.1 of操作：获取中断资源"></a>69.1 of操作：获取中断资源</h2><h3 id="69-1-1-irq-of-parse-and-map"><a href="#69-1-1-irq-of-parse-and-map" class="headerlink" title="69.1.1 irq_of_parse_and_map"></a>69.1.1 irq_of_parse_and_map</h3><p>该函数的主要功能是解析设备节点的”interrupts”属性，并将对应的中断号映射到系统的中断号。”interrupts”属性通常以一种特定的格式表示，可以包含一个或多个中断号。通过提供索引号，可以获取对应的中断号。</p>
<p><strong>函数原型：</strong></p>
<p>​	unsigned int irq_of_parse_and_map(struct device_node *dev, int index);</p>
<p><strong>头文件：</strong></p>
<p>\	#include &lt;linux&#x2F;of_irq.h&gt;</p>
<p><strong>函数作用：</strong><br>        从设备节点的”interrupts”属性中解析和映射对应的中断号</p>
<p><strong>参数说明：</strong></p>
<p>​	dev：设备节点，表示要解析的设备节点。</p>
<p>​	index：索引号，表示从”interrupts”属性中获取第几个中断号。</p>
<p><strong>返回值：</strong></p>
<p>​	是一个无符号整数，表示成功解析和映射的中断号。</p>
<h3 id="69-1-2-irq-get-trigger-type"><a href="#69-1-2-irq-get-trigger-type" class="headerlink" title="69.1.2 irq_get_trigger_type"></a>69.1.2 irq_get_trigger_type</h3><p>该函数的主要功能是从给定的中断数据结构中提取中断触发类型。中断触发类型描述了中断信号的触发条件，例如边沿触发（edge-triggered）或电平触发（level-triggered）等。</p>
<p><strong>函数原型：</strong></p>
<p>​	u32 irqd_get_trigger_type(struct irq_data *d);</p>
<p><strong>头文件：</strong></p>
<p>\	#include &lt;linux&#x2F;irq.h&gt;</p>
<p><strong>函数作用：</strong></p>
<p>​	从中断数据结构（irq_data）中获取对应的中断触发类型。</p>
<p><strong>参数说明</strong>：</p>
<p>​	d：中断数据结构（irq_data），表示要获取中断触发类型的中断。</p>
<p><strong>返回值：</strong></p>
<p>​	是一个无符号32位整数，表示成功获取的中断触发类型。</p>
<h3 id="69-1-3-irq-get-irq-data"><a href="#69-1-3-irq-get-irq-data" class="headerlink" title="69.1.3 irq_get_irq_data"></a>69.1.3 irq_get_irq_data</h3><p>函数irq_get_irq_data的作用是根据中断号获取对应的中断数据结构（irq_data）。</p>
<p><strong>函数原型：</strong></p>
<p>​	struct irq_data *irq_get_irq_data(unsigned int irq);</p>
<p><strong>头文件：</strong><br>    #include &lt;linux&#x2F;irq.h&gt;</p>
<p><strong>函数作用：</strong><br>    根据中断号获取对应的中断数据结构。</p>
<p><strong>参数说明：</strong></p>
<p>​	irq：中断号，表示要获取中断数据结构的中断号。</p>
<p><strong>返回值</strong>：</p>
<p>​	指向irq_data结构体的指针，表示成功获取的中断数据结构。</p>
<h3 id="69-1-4-gpio-to-irq"><a href="#69-1-4-gpio-to-irq" class="headerlink" title="69.1.4 gpio_to_irq"></a>69.1.4 gpio_to_irq</h3><p>该函数的主要功能是将给定的GPIO编号转换为对应的中断号。在某些系统中，GPIO可以配置为中断引脚，当特定事件发生时触发中断。通过该函数，可以根据GPIO编号获取与之关联的中断号，以便进行中断处理等操作。</p>
<p><strong>函数原型：</strong></p>
<p>​	int gpio_to_irq(unsigned int gpio);</p>
<p><strong>头文件：</strong><br>        #include &lt;linux&#x2F;gpio.h&gt;</p>
<p><strong>函数作用：</strong></p>
<p>​	根据GPIO编号获取对应的中断号。</p>
<p><strong>参数说明：</strong></p>
<p>​	gpio：GPIO编号，表示要获取中断号的GPIO。</p>
<p><strong>返回值：</strong></p>
<p>​	是一个整数，表示成功获取的中断号。</p>
<h3 id="69-1-5-of-irq-get"><a href="#69-1-5-of-irq-get" class="headerlink" title="69.1.5 of_irq_get"></a>69.1.5 of_irq_get</h3><p>该函数的主要功能是从给定的设备节点的”interrupts”属性中解析并获取对应的中断号。”interrupts”属性通常以一种特定的格式表示，可以包含一个或多个中断号。通过提供索引号，可以获取对应的中断号</p>
<p><strong>函数原型：</strong></p>
<p>​	int of_irq_get(struct device_node *dev, int index);</p>
<p><strong>头文件：</strong><br>    #include &lt;linux&#x2F;of_irq.h&gt;</p>
<p><strong>函数作用：</strong></p>
<p>​	是从设备节点的”interrupts”属性中获取对应的中断号。</p>
<p><strong>参数说明：</strong></p>
<p>​	dev：设备节点，表示要获取中断号的设备节点。</p>
<p>​	index：索引号，表示从”interrupts”属性中获取第几个中断号。</p>
<p>返回值：</p>
<p>​	是一个整数，表示成功获取的中断号。</p>
<h3 id="69-1-6-irq-of-parse-and-map"><a href="#69-1-6-irq-of-parse-and-map" class="headerlink" title="69.1.6 irq_of_parse_and_map"></a>69.1.6 irq_of_parse_and_map</h3><p>irq_of_parse_and_map函数的主要功能是根据给定的平台设备和索引号获取对应的中断号。平台设备是指与特定硬件平台相关的设备。在某些情况下，平台设备可能具有多个中断号，通过提供索引号，可以获取对应的中断号。</p>
<p><strong>函数原型：</strong></p>
<p>​	int platform_get_irq(struct platform_device *dev, unsigned int num);</p>
<p><strong>函数作用：</strong><br>    根据平台设备和索引号获取对应的中断号。</p>
<p><strong>头文件：</strong><br>    linux&#x2F;platform_device.h</p>
<p><strong>参数说明</strong>：</p>
<p>​	dev：平台设备，表示要获取中断号的平台设备。</p>
<p>​	num：索引号，表示从中获取第几个中断号。</p>
<p><strong>返回值：</strong></p>
<p>​	是一个整数，表示成功获取的中断号。</p>
<h2 id="69-2-实验程序编写"><a href="#69-2-实验程序编写" class="headerlink" title="69.2 实验程序编写"></a>69.2 实验程序编写</h2><h3 id="69-2-1-设备树的修改"><a href="#69-2-1-设备树的修改" class="headerlink" title="69.2.1 设备树的修改"></a>69.2.1 设备树的修改</h3><p>本实验修改完成的设备树和编译完成的boot.img对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\57_of_03\dts。</p>
<p>由于本章节要获取的是中断相关的资源，所以需要在设备树中添加有关中断的设备节点，在第57章节的学习中，我们已经对中断实例进行了讲解，所以这里直接对rk3568-evb1-ddr4-v10-linux.dts设备树进行中断节点的添加，添加的内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myirq &#123;</span><br><span class="line">	compatible = &quot;my_devicetree_irq&quot;;</span><br><span class="line">	interrupt-parent = &lt;&amp;gpio3&gt;;</span><br><span class="line">	interrupts = &lt;RK_PA5 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>添加完成如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025704.jpeg" alt="img"> </p>
<p>保存退出之后，重新编译内核源码，得到boot.img内核镜像之后烧写到开发板即可。</p>
<h3 id="69-2-2-实验程序的编写"><a href="#69-2-2-实验程序的编写" class="headerlink" title="69.2.2 实验程序的编写"></a>69.2.2 实验程序的编写</h3><p>本实验驱动对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\57_of_03。</p>
<p>本小节驱动程序是由65章驱动程序修改而来，由于本章节获取中断属性的函数需要在查找到设备树节点的前提下使用，所以在下面的程序中，先在probe函数中查找设备树节点，然后添加了本章节学习的of操作相关代码和其他一些相关的函数，用来获取设备树节点中断资源。</p>
<p>编写完成的platform_driver.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mod_devicetable.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">int</span> irq;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> *<span class="title">my_irq_data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">mydevice_node</span>;</span></span><br><span class="line">u32 trigger_type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_probe: Probing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找设备节点</span></span><br><span class="line">    mydevice_node = of_find_node_by_name(<span class="literal">NULL</span>, <span class="string">&quot;myirq&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析和映射中断</span></span><br><span class="line">    irq = irq_of_parse_and_map(mydevice_node, <span class="number">0</span>);</span><br><span class="line">    printk(<span class="string">&quot;irq is %d\n&quot;</span>, irq);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取中断数据结构</span></span><br><span class="line">    my_irq_data = irq_get_irq_data(irq);</span><br><span class="line">    <span class="comment">// 获取中断触发类型</span></span><br><span class="line">    trigger_type = irqd_get_trigger_type(my_irq_data);</span><br><span class="line">    printk(<span class="string">&quot;trigger type is 0x%x\n&quot;</span>, trigger_type);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将GPIO转换为中断号</span></span><br><span class="line">    irq = gpio_to_irq(<span class="number">101</span>);</span><br><span class="line">    printk(<span class="string">&quot;irq is %d\n&quot;</span>, irq);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从设备节点获取中断号</span></span><br><span class="line">    irq = of_irq_get(mydevice_node, <span class="number">0</span>);</span><br><span class="line">    printk(<span class="string">&quot;irq is %d\n&quot;</span>, irq);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取平台设备的中断号</span></span><br><span class="line">    irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">    printk(<span class="string">&quot;irq is %d\n&quot;</span>, irq);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Removing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table_id</span>[]  =</span> &#123;</span><br><span class="line">	&#123;.compatible=<span class="string">&quot;my_devicetree_irq&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">		.of_match_table =  of_match_table_id,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="69-3-运行测试"><a href="#69-3-运行测试" class="headerlink" title="69.3 运行测试"></a>69.3 运行测试</h2><h3 id="69-3-1-编译驱动程序"><a href="#69-3-1-编译驱动程序" class="headerlink" title="69.3.1 编译驱动程序"></a>69.3.1 编译驱动程序</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_driver.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_driver.c和Makefile文件目录下，如下图（图69-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025721.jpeg" alt="img"> </p>
<p>图 69-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图69-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025678.jpeg" alt="img"> </p>
<p>图 69-2</p>
<p>编译完生成platform_driver.ko目标文件，如下图（图69-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025669.jpeg" alt="img"> </p>
<p>图 69-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="69-3-2-运行测试"><a href="#69-3-2-运行测试" class="headerlink" title="69.3.2 运行测试"></a>69.3.2 运行测试</h3><p>在进行实验之前，首先要确保开发板烧写的是我们在69.2.1小节中编译出来的boot.img，开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图69-4）所示：</p>
<p>insmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025673.jpeg" alt="img"> </p>
<p>图 69-4</p>
<p>可以看到总共有5个打印，第1、3、4、5个打印都是获取的中断号为113，第2个打印的是中断的类型，即IRQ_TYPE_LEVEL_LOW，该触发类型的宏定义在内核源码“include&#x2F;dt-bindings&#x2F;interrupt-controller&#x2F;irq.h”目录下，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_NONE           0   <span class="comment">// 无中断触发类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_RISING    1   <span class="comment">// 上升沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_FALLING   2   <span class="comment">// 下降沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_BOTH    (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING)<span class="comment">// 双边沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_LEVEL_HIGH     4   <span class="comment">// 高电平触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_LEVEL_LOW      8   <span class="comment">// 低电平触发</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到IRQ_TYPE_LEVEL_LOW的宏定义为8，证明上面的打印正确。</p>
<p>然后使用以下命令进行驱动模块的卸载，如下图（图69-5）所示：</p>
<p>rmmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025753.png" alt="img"></p>
<p>图 69-5</p>
<p>至此，使用of操作函数获取中断资源实验就完成了。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-68-ranges属性实验</title>
    <url>/2023/09/05/1-68-ranges%E5%B1%9E%E6%80%A7%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第68章-ranges属性实验"><a href="#第68章-ranges属性实验" class="headerlink" title="第68章 ranges属性实验"></a>第68章 ranges属性实验</h1><h1 id="68-1-platform-get-resource获取设备树资源"><a href="#68-1-platform-get-resource获取设备树资源" class="headerlink" title="68.1 platform_get_resource获取设备树资源"></a>68.1 platform_get_resource获取设备树资源</h1><p>在上个章节中讲解了使用of操作函数来获取设备树的属性，由于设备树在系统启动的时候都会转化为platform设备，那我们能不能直接在驱动中使用在53.1小节中讲解的platform_get_resource函数直接获取platform_device资源呢？</p>
<h3 id="68-1-1-驱动程序编写"><a href="#68-1-1-驱动程序编写" class="headerlink" title="68.1.1 驱动程序编写"></a>68.1.1 驱动程序编写</h3><p>带着疑惑我们这里仍旧以65章的驱动程序为原型，在probe函数中加入使用platform_get_resource函数获取reg资源的函数，添加完成的驱动程序内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mod_devicetable.h&gt;</span></span></span><br><span class="line"><span class="comment">// 平台设备的初始化函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">myresources</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_probe: Probing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取平台设备的资源</span></span><br><span class="line">    myresources = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (myresources == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果获取资源失败，打印value_compatible的值</span></span><br><span class="line">        printk(<span class="string">&quot;platform_get_resource is error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">&quot;reg valus is %llx\n&quot;</span> , myresources-&gt;start); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Removing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table_id</span>[]  =</span> &#123;</span><br><span class="line">	&#123;.compatible=<span class="string">&quot;my devicetree&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">		.of_match_table =  of_match_table_id,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>编译成模块之后，放到开发板上进行加载，打印信息如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025476.jpeg" alt="img"> </p>
<p>可以看到使用platform_get_resource函数获取reg资源的函数失败了，在下一个小节中将分析获取资源失败的原因。</p>
<h3 id="68-1-2-分析获取资源失败"><a href="#68-1-2-分析获取资源失败" class="headerlink" title="68.1.2 分析获取资源失败"></a>68.1.2 分析获取资源失败</h3><p>platform_get_resource定义在内核源码目录下的”&#x2F;drivers&#x2F;base&#x2F;platform.c”目录下，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *dev,</span></span><br><span class="line"><span class="params">				       <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dev-&gt;num_resources; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">r</span> =</span> &amp;dev-&gt;resource[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (type == resource_type(r) &amp;&amp; num-- == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数返回NULL符合第一小节中的情况，返回NULL的情况有两种可能性，一种是没进入上面的for循环直接返回了NULL，另外一种是进入了for循环，但是类型匹配不正确，跳出for循环之后再返回NULL。这里的类型一定是匹配的，所以我们就来寻找为什么没有进入for循环，这里只有一种可能，也就是dev-&gt;num_resources为0。</p>
<p>所以现在的目标来到了寻找dev-&gt;num_resources是在哪里进行的赋值，前面已经讲解过了由设备树转换为platform的过程，而且在系统启动后，在对应目录下也有了相应的节点： <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025423.png"></p>
<p>​	证明转换是没问题的，所以继续寻找中间转换过程中有关资源数量的相关函数，定位到了of_platform_device_create_pdata函数，该函数定义在内核源码目录下的“drivers&#x2F;of&#x2F;platform.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> platform_device *<span class="title function_">of_platform_device_create_pdata</span><span class="params">(</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">					<span class="type">const</span> <span class="type">char</span> *bus_id,</span></span><br><span class="line"><span class="params">					<span class="type">void</span> *platform_data,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> device *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查设备节点是否可用或已填充 */</span></span><br><span class="line">	<span class="keyword">if</span> (!of_device_is_available(np) ||</span><br><span class="line">	    of_node_test_and_set_flag(np, OF_POPULATED))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 分配平台设备结构体 */</span></span><br><span class="line">	dev = of_device_alloc(np, bus_id, parent);</span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">goto</span> err_clear_flag;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置平台设备的一些属性 */</span></span><br><span class="line">	dev-&gt;dev.coherent_dma_mask = DMA_BIT_MASK(<span class="number">32</span>);</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;dev.dma_mask)</span><br><span class="line">		dev-&gt;dev.dma_mask = &amp;dev-&gt;dev.coherent_dma_mask;</span><br><span class="line">	dev-&gt;dev.bus = &amp;platform_bus_type;</span><br><span class="line">	dev-&gt;dev.platform_data = platform_data;</span><br><span class="line">	of_msi_configure(&amp;dev-&gt;dev, dev-&gt;dev.of_node);</span><br><span class="line">	of_reserved_mem_device_init_by_idx(&amp;dev-&gt;dev, dev-&gt;dev.of_node, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将平台设备添加到设备模型中 */</span></span><br><span class="line">	<span class="keyword">if</span> (of_device_add(dev) != <span class="number">0</span>) &#123;</span><br><span class="line">		platform_device_put(dev);</span><br><span class="line">		<span class="keyword">goto</span> err_clear_flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev;</span><br><span class="line"></span><br><span class="line">err_clear_flag:</span><br><span class="line">	<span class="comment">/* 清除设备节点的已填充标志 */</span></span><br><span class="line">	of_node_clear_flag(np, OF_POPULATED);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>​	第15行：函数调用 of_device_alloc 分配一个平台设备结构体，并将设备节点指针、设备标识符和父设备指针传递给它，正是该函数决定的resource.num,然后找到该函数的定义，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> platform_device *<span class="title function_">of_device_alloc</span><span class="params">(<span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">				  <span class="type">const</span> <span class="type">char</span> *bus_id,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> device *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">int</span> rc, i, num_reg = <span class="number">0</span>, num_irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>, <span class="title">temp_res</span>;</span></span><br><span class="line"></span><br><span class="line">	dev = platform_device_alloc(<span class="string">&quot;&quot;</span>, PLATFORM_DEVID_NONE);</span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* count the io and irq resources */</span></span><br><span class="line">	<span class="keyword">while</span> (of_address_to_resource(np, num_reg, &amp;temp_res) == <span class="number">0</span>)</span><br><span class="line">		num_reg++;</span><br><span class="line">	num_irq = of_irq_count(np);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Populate the resource table */</span></span><br><span class="line">	<span class="keyword">if</span> (num_irq || num_reg) &#123;</span><br><span class="line">		res = kcalloc(num_irq + num_reg, <span class="keyword">sizeof</span>(*res), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!res) &#123;</span><br><span class="line">			platform_device_put(dev);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		dev-&gt;num_resources = num_reg + num_irq;</span><br><span class="line">		dev-&gt;resource = res;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_reg; i++, res++) &#123;</span><br><span class="line">			rc = of_address_to_resource(np, i, res);</span><br><span class="line">			WARN_ON(rc);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (of_irq_to_resource_table(np, res, num_irq) != num_irq)</span><br><span class="line">			pr_debug(<span class="string">&quot;not all legacy IRQ resources mapped for %pOFn\n&quot;</span>,</span><br><span class="line">				 np);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev-&gt;dev.of_node = of_node_get(np);</span><br><span class="line">	dev-&gt;dev.fwnode = &amp;np-&gt;fwnode;</span><br><span class="line">	dev-&gt;dev.parent = parent ? : &amp;platform_bus;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bus_id)</span><br><span class="line">		dev_set_name(&amp;dev-&gt;dev, <span class="string">&quot;%s&quot;</span>, bus_id);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		of_device_make_bus_id(&amp;dev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第26行出现了for循环的dev-&gt;num_resources &#x3D; num_reg + num_irq;reg的number和irq的number，由于在设备树中并没有添加中断相关的属性num_irq为0，那这里的num_reg是哪里确定的呢。</p>
<p>我们向上找到14、15行，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (of_address_to_resource(np, num_reg, &amp;temp_res) == 0)</span><br><span class="line">	num_reg++;</span><br></pre></td></tr></table></figure>

<p>然后跳转到while循环中的of_address_to_resource函数，该函数定义在内核源码目录的drivers&#x2F;of&#x2F;address.c文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_address_to_resource</span><span class="params">(<span class="keyword">struct</span> device_node *dev, <span class="type">int</span> index,</span></span><br><span class="line"><span class="params">			   <span class="keyword">struct</span> resource *r)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> __be32	*addrp;</span><br><span class="line">	u64		size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	flags;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>	*name = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	addrp = of_get_address(dev, index, &amp;size, &amp;flags);</span><br><span class="line">	<span class="keyword">if</span> (addrp == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get optional &quot;reg-names&quot; property to add a name to a resource */</span></span><br><span class="line">	of_property_read_string_index(dev, <span class="string">&quot;reg-names&quot;</span>,	index, &amp;name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __of_address_to_resource(dev, addrp, size, flags, name, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	第9行，获取reg属性的地址、大小和类型，在设备树中reg属性已经存在了，所以这里会正确返回。</p>
<p>第14行，读取reg-names属性，由于设备树中没有定义这个属性，所以该函数不会有影响。</p>
<p>最后具有决定性作用的函数就是返回的__of_address_to_resource函数了，跳转到该函数的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __of_address_to_resource(<span class="keyword">struct</span> device_node *dev,</span><br><span class="line">		<span class="type">const</span> __be32 *addrp, u64 size, <span class="type">unsigned</span> <span class="type">int</span> flags,</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> resource *r)</span><br><span class="line">&#123;</span><br><span class="line">	u64 taddr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; IORESOURCE_MEM)</span><br><span class="line">		taddr = of_translate_address(dev, addrp);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; IORESOURCE_IO)</span><br><span class="line">		taddr = of_translate_ioport(dev, addrp, size);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (taddr == OF_BAD_ADDR)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="built_in">memset</span>(r, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> resource));</span><br><span class="line"></span><br><span class="line">	r-&gt;start = taddr;</span><br><span class="line">	r-&gt;end = taddr + size - <span class="number">1</span>;</span><br><span class="line">	r-&gt;flags = flags;</span><br><span class="line">	r-&gt;name = name ? name : dev-&gt;full_name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	reg属性的flags为IORESOURCE_MEM，所以又会执行第9行的of_translate_address函数，跳转到该函数，该函数的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u64 <span class="title function_">of_translate_address</span><span class="params">(<span class="keyword">struct</span> device_node *dev, <span class="type">const</span> __be32 *in_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">host</span>;</span></span><br><span class="line">	u64 ret;</span><br><span class="line"></span><br><span class="line">	ret = __of_translate_address(dev, in_addr, <span class="string">&quot;ranges&quot;</span>, &amp;host);</span><br><span class="line">	<span class="keyword">if</span> (host) &#123;</span><br><span class="line">		of_node_put(host);</span><br><span class="line">		<span class="keyword">return</span> OF_BAD_ADDR;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	该函数的重点在第6行，上述函数实际上是__of_translate_address函数的封装，其中传入的第三个参数“ranges”是我们要关注的重点，继续跳转到该函数的定义，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> u64 __of_translate_address(<span class="keyword">struct</span> device_node *dev,</span><br><span class="line">				  <span class="type">const</span> __be32 *in_addr, <span class="type">const</span> <span class="type">char</span> *rprop,</span><br><span class="line">				  <span class="keyword">struct</span> device_node **host)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">of_bus</span> *<span class="title">bus</span>, *<span class="title">pbus</span>;</span></span><br><span class="line">	__be32 addr[OF_MAX_ADDR_CELLS];</span><br><span class="line">	<span class="type">int</span> na, ns, pna, pns;</span><br><span class="line">	u64 result = OF_BAD_ADDR;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;** translation for device %pOF **\n&quot;</span>, dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Increase refcount at current level */</span></span><br><span class="line">	of_node_get(dev);</span><br><span class="line"></span><br><span class="line">	*host = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/* Get parent &amp; match bus type */</span></span><br><span class="line">	parent = of_get_parent(dev);</span><br><span class="line">	<span class="keyword">if</span> (parent == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> bail;</span><br><span class="line">	bus = of_match_bus(parent);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Count address cells &amp; copy address locally */</span></span><br><span class="line">	bus-&gt;count_cells(dev, &amp;na, &amp;ns);</span><br><span class="line">	<span class="keyword">if</span> (!OF_CHECK_COUNTS(na, ns)) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;Bad cell count for %pOF\n&quot;</span>, dev);</span><br><span class="line">		<span class="keyword">goto</span> bail;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(addr, in_addr, na * <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;bus is %s (na=%d, ns=%d) on %pOF\n&quot;</span>,</span><br><span class="line">	    bus-&gt;name, na, ns, parent);</span><br><span class="line">	of_dump_addr(<span class="string">&quot;translating address:&quot;</span>, addr, na);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Translate */</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">logic_pio_hwaddr</span> *<span class="title">iorange</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Switch to parent bus */</span></span><br><span class="line">		of_node_put(dev);</span><br><span class="line">		dev = parent;</span><br><span class="line">		parent = of_get_parent(dev);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If root, we have finished */</span></span><br><span class="line">		<span class="keyword">if</span> (parent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			pr_debug(<span class="string">&quot;reached root node\n&quot;</span>);</span><br><span class="line">			result = of_read_number(addr, na);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * For indirectIO device which has no ranges property, get</span></span><br><span class="line"><span class="comment">		 * the address from reg directly.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		iorange = find_io_range_by_fwnode(&amp;dev-&gt;fwnode);</span><br><span class="line">		<span class="keyword">if</span> (iorange &amp;&amp; (iorange-&gt;flags != LOGIC_PIO_CPU_MMIO)) &#123;</span><br><span class="line">			result = of_read_number(addr + <span class="number">1</span>, na - <span class="number">1</span>);</span><br><span class="line">			pr_debug(<span class="string">&quot;indirectIO matched(%pOF) 0x%llx\n&quot;</span>,</span><br><span class="line">				 dev, result);</span><br><span class="line">			*host = of_node_get(dev);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Get new parent bus and counts */</span></span><br><span class="line">		pbus = of_match_bus(parent);</span><br><span class="line">		pbus-&gt;count_cells(dev, &amp;pna, &amp;pns);</span><br><span class="line">		<span class="keyword">if</span> (!OF_CHECK_COUNTS(pna, pns)) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;Bad cell count for %pOF\n&quot;</span>, dev);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pr_debug(<span class="string">&quot;parent bus is %s (na=%d, ns=%d) on %pOF\n&quot;</span>,</span><br><span class="line">		    pbus-&gt;name, pna, pns, parent);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Apply bus translation */</span></span><br><span class="line">		<span class="keyword">if</span> (of_translate_one(dev, bus, pbus, addr, na, ns, pna, rprop))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Complete the move up one level */</span></span><br><span class="line">		na = pna;</span><br><span class="line">		ns = pns;</span><br><span class="line">		bus = pbus;</span><br><span class="line"></span><br><span class="line">		of_dump_addr(<span class="string">&quot;one level translation:&quot;</span>, addr, na);</span><br><span class="line">	&#125;</span><br><span class="line"> bail:</span><br><span class="line">	of_node_put(parent);</span><br><span class="line">	of_node_put(dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	第18行，获取父节点和匹配的总线类型</p>
<p>第24行，获取address-cell和size-cells</p>
<p>然后是一个for循环，在76行使用of_translate_one函数进行转换，其中rprop参数表示要转换的资源属性，该参数的值为传入的“ranges”，然后我们继续跳转到该函数，该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">of_translate_one</span><span class="params">(<span class="keyword">struct</span> device_node *parent, <span class="keyword">struct</span> of_bus *bus,</span></span><br><span class="line"><span class="params">			    <span class="keyword">struct</span> of_bus *pbus, __be32 *addr,</span></span><br><span class="line"><span class="params">			    <span class="type">int</span> na, <span class="type">int</span> ns, <span class="type">int</span> pna, <span class="type">const</span> <span class="type">char</span> *rprop)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> __be32 *ranges;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> rlen;</span><br><span class="line">	<span class="type">int</span> rone;</span><br><span class="line">	u64 offset = OF_BAD_ADDR;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Normally, an absence of a &quot;ranges&quot; property means we are</span></span><br><span class="line"><span class="comment">	 * crossing a non-translatable boundary, and thus the addresses</span></span><br><span class="line"><span class="comment">	 * below the current cannot be converted to CPU physical ones.</span></span><br><span class="line"><span class="comment">	 * Unfortunately, while this is very clear in the spec, it&#x27;s not</span></span><br><span class="line"><span class="comment">	 * what Apple understood, and they do have things like /uni-n or</span></span><br><span class="line"><span class="comment">	 * /ht nodes with no &quot;ranges&quot; property and a lot of perfectly</span></span><br><span class="line"><span class="comment">	 * useable mapped devices below them. Thus we treat the absence of</span></span><br><span class="line"><span class="comment">	 * &quot;ranges&quot; as equivalent to an empty &quot;ranges&quot; property which means</span></span><br><span class="line"><span class="comment">	 * a 1:1 translation at that level. It&#x27;s up to the caller not to try</span></span><br><span class="line"><span class="comment">	 * to translate addresses that aren&#x27;t supposed to be translated in</span></span><br><span class="line"><span class="comment">	 * the first place. --BenH.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * As far as we know, this damage only exists on Apple machines, so</span></span><br><span class="line"><span class="comment">	 * This code is only enabled on powerpc. --gcl</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ranges = of_get_property(parent, rprop, &amp;rlen);</span><br><span class="line">	<span class="keyword">if</span> (ranges == <span class="literal">NULL</span> &amp;&amp; !of_empty_ranges_quirk(parent)) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;no ranges; cannot translate\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ranges == <span class="literal">NULL</span> || rlen == <span class="number">0</span>) &#123;</span><br><span class="line">		offset = of_read_number(addr, na);</span><br><span class="line">		<span class="built_in">memset</span>(addr, <span class="number">0</span>, pna * <span class="number">4</span>);</span><br><span class="line">		pr_debug(<span class="string">&quot;empty ranges; 1:1 translation\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> finish;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;walking ranges...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now walk through the ranges */</span></span><br><span class="line">	rlen /= <span class="number">4</span>;</span><br><span class="line">	rone = na + pna + ns;</span><br><span class="line">	<span class="keyword">for</span> (; rlen &gt;= rone; rlen -= rone, ranges += rone) &#123;</span><br><span class="line">		offset = bus-&gt;<span class="built_in">map</span>(addr, ranges, na, ns, pna);</span><br><span class="line">		<span class="keyword">if</span> (offset != OF_BAD_ADDR)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (offset == OF_BAD_ADDR) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;not found !\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(addr, ranges + na, <span class="number">4</span> * pna);</span><br><span class="line"></span><br><span class="line"> finish:</span><br><span class="line">	of_dump_addr(<span class="string">&quot;parent translation for:&quot;</span>, addr, pna);</span><br><span class="line">	pr_debug(<span class="string">&quot;with offset: %llx\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)offset);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Translate it into parent bus space */</span></span><br><span class="line">	<span class="keyword">return</span> pbus-&gt;translate(addr, offset, pna);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该函数的第26行使用of_get_property函数获取“ranges”属性，但由于在我们添加的设备树节点中并没有该属性，所以这里的ranges值就为NULL，第27行的条件判断成立，也就会返回1。</p>
<p>接下来再根据这个返回值继续分析上级函数:</p>
<p>of_translate_one函数返回1之后，上一级的_of_translate_address的返回值就为OF BAD ADDR，再上一级的of_translate_address返回值也是OF BAD <em>ADDR，继续向上查找_of_address_to_resource函数会返回EINVAL，of address</em> to resource 返回EINVAL，所以num_reg 为0;到这里关于为什么platform_get_resource函数获取资源失败的问题就找到了，只是因为在设备树中并没有这个名为ranges这个属性，所以只需要对设备树进行ranges属性的添加即可，要修改的设备树为arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568-evb1-ddr4-v10-linux.dts，修改完成如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025548.jpeg" alt="img"> </p>
<p>然后重新编译内核，将编译生成的boot.img烧写进开发板之后重新加载上面编写的驱动程序，可以看到之前获取失败的打印就消失了，而且成功打印出了reg属性的第一个值，如下图所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025507.jpeg" alt="img"></p>
<p>虽然这里的问题解决了，但引起的思考并没有结束，那我们在这里添加的ranges属性的作用是啥呢，带着疑问，开始下一小节的学习吧。</p>
<h1 id="68-2-ranges-属性"><a href="#68-2-ranges-属性" class="headerlink" title="68.2 ranges 属性"></a>68.2 ranges 属性</h1><h3 id="68-2-1-ranges属性介绍"><a href="#68-2-1-ranges属性介绍" class="headerlink" title="68.2.1 ranges属性介绍"></a>68.2.1 ranges属性介绍</h3><p>ranges 属性是一种用于描述设备之间地址映射关系的属性。它在设备树（Device Tree）中使用，用于描述子设备地址空间如何映射到父设备地址空间。设备树是一种硬件描述语言，用于描述嵌入式系统中的硬件组件和它们之间的连接关系。</p>
<p>设备树中的每个设备节点都可以具有 ranges 属性，其中包含了地址映射的信息。下面是一个常见的格式：</p>
<p>ranges &#x3D; <child-bus-address parent-bus-address length>;</p>
<p>或者</p>
<p>ranges;</p>
<p>然后对上述格式中每个部分进行解释：</p>
<p>child-bus-address：子设备地址空间的起始地址。它指定了子设备在父设备地址空间中的位置。具体的字长由 ranges 所在节点的 #address-cells 属性决定。</p>
<p>parent-bus-address：父设备地址空间的起始地址。它指定了父设备中用于映射子设备的地址范围。具体的字长由 ranges 的父节点的 #address-cells 属性决定。</p>
<p>length：映射的大小。它指定了子设备地址空间在父设备地址空间中的长度。具体的字长由 ranges 的父节点的 #size-cells 属性决定。</p>
<p>当 ranges 属性的值为空时，表示子设备地址空间和父设备地址空间具有完全相同的映射，即1:1映射。这通常用于描述内存区域，其中子设备和父设备具有相同的地址范围。</p>
<p>当 ranges 属性的值不为空时，按照指定的映射规则将子设备地址空间映射到父设备地址空间。具体的映射规则取决于设备树的结构和设备的特定要求。</p>
<p>然后以下面的设备树为例进行ranges属性的讲解，设备树内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">  compatible = <span class="string">&quot;acme,coyotes-revenge&quot;</span>;</span><br><span class="line">  <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">  <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">  ....</span><br><span class="line">  external-bus &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    ranges = &lt;<span class="number">0</span> <span class="number">0</span> <span class="number">0x10100000</span> <span class="number">0x10000</span></span><br><span class="line">              <span class="number">1</span> <span class="number">0</span> <span class="number">0x10160000</span> <span class="number">0x10000</span></span><br><span class="line">              <span class="number">2</span> <span class="number">0</span> <span class="number">0x30000000</span> <span class="number">0x30000000</span>&gt;;</span><br><span class="line">    <span class="comment">// Chipselect 1, Ethernet</span></span><br><span class="line">    <span class="comment">// Chipselect 2, i2c controller</span></span><br><span class="line">    <span class="comment">// Chipselect 3, NOR Flash</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure>

<p>这里以ranges的第一个属性值为例进行具体解释如下：</p>
<p>在 external-bus 节点中#address-cells 属性值为2表示child-bus-address由两个值表示，也就是0和0，父节点的 #address-cells 属性值和#size-cells 属性值为1，表示parent-bus-address和length都由一个表示，也就是0x10100000和0x10000，该ranges值表示将子地址空间（0x0-0xFFFF）映射到父地址空间0x10100000 - 0x1010FFFF，这里的例子为带参数ranges属性映射，不带参数的ranges属性为1：1映射，较为简单，这里不再进行举例。</p>
<p>在嵌入式系统中，不同的设备可能连接到相同的总线或总线控制器上，它们需要在物理地址空间中进行正确的映射，以便进行数据交换和通信。例如，一个设备可能通过总线连接到主处理器或其他设备，而这些设备的物理地址范围可能不同。ranges 属性就是用来描述这种地址映射关系的。</p>
<h3 id="68-2-2设备分类"><a href="#68-2-2设备分类" class="headerlink" title="68.2.2设备分类"></a>68.2.2设备分类</h3><p>根据上面讲解的映射关系可以将设备分为两类：内存映射型设备和非内存映射型设备。</p>
<p><strong>内存映射型设备：</strong><br>    内存映射型设备是指可以通过内存地址进行直接访问的设备。这类设备在物理地址空间中的一部分被映射到系统的内存地址空间中，使得CPU可以通过读写内存地址的方式与设备进行通信和控制。</p>
<p>特点：</p>
<p>（1）直接访问：内存映射型设备可以被CPU直接访问，类似于访问内存中的数据。这种直接访问方式提供了高速的数据传输和低延迟的设备操作。</p>
<p>（2）内存映射：设备的寄存器、缓冲区等资源被映射到系统的内存地址空间中，使用读写内存的方式与设备进行通信。</p>
<p>（3）读写操作：CPU可以通过读取和写入映射的内存地址来与设备进行数据交换和控制操作。</p>
<p>在设备树中，内存映射型设备的设备树举例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">/ &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    ranges;</span><br><span class="line"></span><br><span class="line">    serial@<span class="number">101f</span>0000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;arm,pl011&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x101f0000</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@<span class="number">101f</span>3000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;arm,pl061&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x101f3000</span> <span class="number">0x1000</span></span><br><span class="line">                <span class="number">0x101f4000</span> <span class="number">0x10</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    spi@<span class="number">10115000</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;arm,pl022&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x10115000</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第5行的ranges属性表示该设备树中会进行1：1的地址范围映射。</p>
<p>非内存映射型设备：<br>    非内存映射型设备是指不能通过内存地址直接访问的设备。这类设备可能采用其他方式与CPU进行通信，例如通过I&#x2F;O端口、专用总线或特定的通信协议。</p>
<p>特点：</p>
<p>（1）非内存访问：非内存映射型设备不能像内存映射型设备那样直接通过内存地址进行访问。它们可能使用独立的I&#x2F;O端口或专用总线进行通信。</p>
<p>（2）特定接口：设备通常使用特定的接口和协议与CPU进行通信和控制，例如SPI、I2C、UART等。</p>
<p>（3）驱动程序：非内存映射型设备通常需要特定的设备驱动程序来实现与CPU的通信和控制。</p>
<p>在设备树中，非内存映射型设备的设备树举例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">  compatible = <span class="string">&quot;acme,coyotes-revenge&quot;</span>;</span><br><span class="line">  <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">  <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">  ....</span><br><span class="line">  external-bus &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    ranges = &lt;<span class="number">0</span> <span class="number">0</span> <span class="number">0x10100000</span> <span class="number">0x10000</span></span><br><span class="line">              <span class="number">1</span> <span class="number">0</span> <span class="number">0x10160000</span> <span class="number">0x10000</span></span><br><span class="line">              <span class="number">2</span> <span class="number">0</span> <span class="number">0x30000000</span> <span class="number">0x30000000</span>&gt;;</span><br><span class="line">    <span class="comment">// Chipselect 1, Ethernet</span></span><br><span class="line">    <span class="comment">// Chipselect 2, i2c controller</span></span><br><span class="line">    <span class="comment">// Chipselect 3, NOR Flash</span></span><br><span class="line"></span><br><span class="line">    ethernet@<span class="number">0</span>,<span class="number">0</span> &#123;</span><br><span class="line">      compatible = <span class="string">&quot;smc,smc91c111&quot;</span>;</span><br><span class="line">      reg = &lt;<span class="number">0</span> <span class="number">0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    i2c@<span class="number">1</span>,<span class="number">0</span> &#123;</span><br><span class="line">      compatible = <span class="string">&quot;acme,a1234-i2c-bus&quot;</span>;</span><br><span class="line">      <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">      <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">      reg = &lt;<span class="number">1</span> <span class="number">0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line"></span><br><span class="line">      rtc@<span class="number">58</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;maxim,ds1338&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x58</span>&gt;;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; ;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h3 id="68-2-3-映射地址计算"><a href="#68-2-3-映射地址计算" class="headerlink" title="68.2.3 映射地址计算"></a>68.2.3 映射地址计算</h3><p>接下来以上面列举的非内存映射型设备的设备树中的ethernet@0节点为例，计算该网卡设备的映射地址。</p>
<p>首先，找到ethernet@0所在的节点，并查看其reg属性。在给定的设备树片段中，ethernet@0的reg属性为&lt;0 0 0x1000&gt;。在根节点中，#address-cells的值为1，表示地址由一个单元格组成。</p>
<p>接下来，根据ranges属性进行地址映射计算。在external-bus节点的ranges属性中，有三个映射条目：</p>
<p>第一个映射条目为“0 0 0x10100000 0x10000”，表示外部总线的地址范围为0x10100000到0x1010FFFF。该映射条目的第一个值为0，表示与external-bus节点的第一个子节点（ethernet@0,0）相关联。</p>
<p>第二个映射条目：“1 0 0x10160000 0x10000”，表示外部总线的地址范围为0x10160000到0x1016FFFF。该映射条目的第一个值为1，表示与external-bus节点的第二个子节点（i2c@1,0）相关联。</p>
<p>第三个映射条目：“2 0 0x30000000 0x30000000”，表示外部总线的地址范围为0x30000000到0x5FFFFFFF。该映射条目的第一个值为2，表示与external-bus节点的第三个子节点相关联。</p>
<p>由于ethernet@0与external-bus的第一个子节点相关联，并且它的reg属性为&lt;0 0 0x1000&gt;，我们可以进行以下计算：</p>
<p>ethernet@0的物理地址 &#x3D; 外部总线地址起始值 + ethernet@0的reg属性的第二个值<br>&#x3D; 0x10100000 + 0x1000<br>&#x3D; 0x10101000</p>
<p>因此，ethernet@0的物理起始地址为0x10101000，又根据0x1000的地址范围可以确定ethernet@0的结束起始地址为0x10101FFF，至此，关于映射地址的计算就讲解完成了，大家可以根据同样的方法计算i2c@1的物理地址。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-67-of操作函数实验:获取属性</title>
    <url>/2023/09/05/1-67-of%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E5%AE%9E%E9%AA%8C-%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第67章-of操作函数实验：获取属性"><a href="#第67章-of操作函数实验：获取属性" class="headerlink" title="第67章 of操作函数实验：获取属性"></a>第67章 of操作函数实验：获取属性</h1><h2 id="67-1-of操作：获取属性"><a href="#67-1-of操作：获取属性" class="headerlink" title="67.1 of操作：获取属性"></a>67.1 of操作：获取属性</h2><h3 id="67-1-1-of-find-property"><a href="#67-1-1-of-find-property" class="headerlink" title="67.1.1 of_find_property"></a>67.1.1 of_find_property</h3><p>of_find_property函数用于在设备树中查找节点 下具有指定名称的属性。如果找到了该属性，可以通过返回的属性结构体指针进行进一步的操作，比如获取属性值、属性长度等。</p>
<p><strong>函数原型:</strong></p>
<p>​	struct property *of_find_property(const struct device_node *np, const char *name, int *lenp)</p>
<p><strong>头文件：</strong></p>
<p>​	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用</strong>:</p>
<p>​	该函数用于在节点 np 下查找指定名称 name 的属性。</p>
<p><strong>函数参数</strong>:</p>
<p>​	np: 要查找的节点。</p>
<p>​	name: 要查找的属性的属性名。</p>
<p>​	lenp: 一个指向整数的指针，用于接收属性值的字节数。</p>
<p><strong>返回值</strong>:</p>
<p>​	如果成功找到了指定名称的属性，则返回对应的属性结构体指针 struct property *；如果未找到，则返回 NULL。</p>
<h3 id="67-1-2-of-property-count-elems-of-size"><a href="#67-1-2-of-property-count-elems-of-size" class="headerlink" title="67.1.2 of_property_count_elems_of_size"></a>67.1.2 of_property_count_elems_of_size</h3><p>该函数在设备树中的设备节点下查找指定名称的属性，并获取该属性中元素的数量。调用该函数可以用于获取设备树属性中某个属性的元素数量，比如一个字符串列表的元素数量或一个整数数组的元素数量等。 </p>
<p><strong>函数原型:</strong></p>
<p>​	int of_property_count_elems_of_size(const struct device_node *np, const char *propname, int elem_size)</p>
<p><strong>头文件</strong>：</p>
<p>\	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用</strong></p>
<p>​	该函数用于获取属性中指定元素的数量。</p>
<p><strong>函数参数</strong>:</p>
<p>​	np: 设备节点。</p>
<p>​	propname: 需要获取元素数量的属性名。</p>
<p>​	elem_size: 单个元素的尺寸。</p>
<p><strong>返回值</strong>:</p>
<p>如果成功获取了指定属性中元素的数量，则返回该数量；如果未找到属性或属性中没有元素，则返回 0。</p>
<h3 id="67-1-3-of-property-read-u32-index"><a href="#67-1-3-of-property-read-u32-index" class="headerlink" title="67.1.3 of_property_read_u32_index"></a>67.1.3 of_property_read_u32_index</h3><p>该函数在设备树中的设备节点下查找指定名称的属性，并获取该属性在给定索引位置处的 u32 类型的数据值。</p>
<p>这个函数通常用于从设备树属性中读取特定索引位置的整数值。通过指定属性名和索引，可以获取属性中指定位置的具体数值。</p>
<p><strong>函数原型</strong>:</p>
<p>​	int of_property_read_u32_index(const struct device_node *np, const char *propname, u32 index, u32 *out_value)</p>
<p><strong>头文件</strong>：</p>
<p>\	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用</strong>:</p>
<p>​	该函数用于从指定属性中获取指定索引位置的 u32 类型的数据值。</p>
<p><strong>函数参数</strong>:</p>
<p>​	np: 设备节点。</p>
<p>​	propname: 要读取的属性名。</p>
<p>​	index: 要读取的属性值在属性中的索引，索引从 0 开始。</p>
<p>​	out_value: 用于存储读取到的值的指针。</p>
<p><strong>返回值</strong>: </p>
<p>​	如果成功读取到了指定属性指定索引位置的 u32 类型的数据值，则返回 0；如果未找到属性或读取失败，则返回相应的错误码。</p>
<h3 id="67-1-4-of-property-read-u64-index"><a href="#67-1-4-of-property-read-u64-index" class="headerlink" title="67.1.4 of_property_read_u64_index"></a>67.1.4 of_property_read_u64_index</h3><p>该函数在设备树中的设备节点下查找指定名称的属性，并获取该属性在给定索引位置处的 u64 类型的数据值。</p>
<p>这个函数通常用于从设备树属性中读取特定索引位置的 64 位整数值。通过指定属性名和索引，可以获取属性中指定位置的具体数值。</p>
<p><strong>函数原型</strong>: </p>
<p>​	static inline int of_property_read_u64_index(const struct device_node *np, const char *propname, u32 index, u64 *out_value)</p>
<p><strong>头文件</strong>：</p>
<p>\	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用</strong>:</p>
<p>​	该函数用于从指定属性中获取指定索引位置的 u64 类型的数据值。</p>
<p><strong>函数参数和返回值</strong>:</p>
<p>​	np: 设备节点。</p>
<p>​	propname: 要读取的属性名。</p>
<p>​	index: 要读取的属性值在属性中的索引，索引从 0 开始。</p>
<p>​	out_value: 用于存储读取到的值的指针。</p>
<p><strong>返回值</strong>:</p>
<p>​	如果成功读取到了指定属性指定索引位置的 u64 类型的数据值，则返回 0；如果未找到属性或读取失败，则返回相应的错误码。</p>
<h3 id="67-1-5-of-property-read-variable-u32-array"><a href="#67-1-5-of-property-read-variable-u32-array" class="headerlink" title="67.1.5 of_property_read_variable_u32_array"></a>67.1.5 of_property_read_variable_u32_array</h3><p>该函数用于从设备树中读取指定属性名的变长数组。通过提供设备节点、属性名和输出数组的指针，可以将设备树中的数组数据读取到指定的内存区域中。同时，还需要指定数组的最小大小和最大大小，以确保读取到的数组符合预期的大小范围。</p>
<p><strong>函数原型</strong>：</p>
<p>​	int of_property_read_variable_u32_array(const struct device_node *np, const char *propname, u32 *out_values, size_t SZ_min, size_t SZ_max)</p>
<p><strong>函数作用</strong>: </p>
<p>​	从指定属性中读取变长的 u32 数组。</p>
<p><strong>函数参数</strong>:</p>
<p>​	np: 设备节点。</p>
<p>​	propname: 要读取的属性名。</p>
<p>​	out_values: 用于存储读取到的 u8 数组的指针。</p>
<p>​	SZ_min: 数组的最小大小。</p>
<p>​	SZ_max: 数组的最大大小。</p>
<p><strong>返回值</strong>：</p>
<p>如果成功读取到了指定属性的 u8 数组，则返回数组的大小。如果未找到属性或读取失败，则返回相应的错误码。</p>
<p>上面介绍的函数用于从指定属性中读取变长的 u32 数组，下面是另外三个读取其他数组大小的函数：</p>
<p>这里给出了四个函数，用于从设备树中读取数组类型的属性值：</p>
<p>从指定属性中读取变长的 u8 数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int of_property_read_variable_u8_array(const struct device_node *np, const char *propname, u8 *out_values, size_t SZ_min, size_t SZ_max)</span><br></pre></td></tr></table></figure>

<p>从指定属性中读取变长的 u16 数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int of_property_read_variable_u16_array(const struct device_node *np, const char *propname, u16 *out_values, size_t SZ_min, size_t SZ_max)</span><br></pre></td></tr></table></figure>

<p>从指定属性中读取变长的 u64 数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int of_property_read_variable_u64_array(const struct device_node *np, const char *propname, u64 *out_values, size_t SZ_min, size_t SZ_max)</span><br></pre></td></tr></table></figure>

<h3 id="67-1-6-of-property-read-string"><a href="#67-1-6-of-property-read-string" class="headerlink" title="67.1.6 of_property_read_string"></a>67.1.6 of_property_read_string</h3><p>该函数在设备树中的设备节点下查找指定名称的属性，并获取该属性的字符串值，最后返回读取到的字符串的指针，通常用于从设备树属性中读取字符串值。通过指定属性名，可以获取属性中的字符串数据。</p>
<p><strong>函数原型</strong>:</p>
<p>​	static inline int of_property_read_string(const struct device_node *np, const char *propname, const char **out_string)</p>
<p><strong>头文件</strong>：</p>
<p>\	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用</strong>:</p>
<p>​	该函数用于从指定属性中读取字符串。</p>
<p><strong>函数参数</strong>:</p>
<p>​	np: 设备节点。</p>
<p>​	propname: 要读取的属性名。</p>
<p>​	out_string: 用于存储读取到的字符串的指针。</p>
<p><strong>返回值</strong>:</p>
<p>​	如果成功读取到了指定属性的字符串，则返回 0；如果未找到属性或读取失败，则返回相应的错误码。</p>
<h2 id="67-2-实验程序编写"><a href="#67-2-实验程序编写" class="headerlink" title="67.2 实验程序编写"></a>67.2 实验程序编写</h2><p>本实验驱动对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\56_of_02。</p>
<p>本小节驱动程序是由65章驱动程序修改而来，由于本章节获取设备树属性的函数需要在查找到设备树节点的前提下使用，所以在下面的程序中，先在probe函数中添加查获取设备树节点，然后添加了本章节学习的of操作相关代码，用来获取设备树节点相关属性。</p>
<p>编写完成的platform_driver.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mod_devicetable.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">mydevice_node</span>;</span>      </span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">u32 value_u32;</span><br><span class="line">u64 value_u64;</span><br><span class="line">u32 out_value[<span class="number">2</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *value_compatible;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">my_property</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的探测函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_probe: Probing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过节点名称查找设备树节点</span></span><br><span class="line">    mydevice_node = of_find_node_by_name(<span class="literal">NULL</span>, <span class="string">&quot;myLed&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;mydevice node is %s\n&quot;</span>, mydevice_node-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找compatible属性</span></span><br><span class="line">    my_property = of_find_property(mydevice_node, <span class="string">&quot;compatible&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    printk(<span class="string">&quot;my_property name is %s\n&quot;</span>, my_property-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取reg属性的元素数量</span></span><br><span class="line">    num = of_property_count_elems_of_size(mydevice_node, <span class="string">&quot;reg&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    printk(<span class="string">&quot;reg num is %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取reg属性的值</span></span><br><span class="line">    of_property_read_u32_index(mydevice_node, <span class="string">&quot;reg&quot;</span>, <span class="number">0</span>, &amp;value_u32);</span><br><span class="line">    of_property_read_u64_index(mydevice_node, <span class="string">&quot;reg&quot;</span>, <span class="number">0</span>, &amp;value_u64);</span><br><span class="line">    printk(<span class="string">&quot;value u32 is 0x%X\n&quot;</span>, value_u32);</span><br><span class="line">    printk(<span class="string">&quot;value u64 is 0x%llx\n&quot;</span>, value_u64);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取reg属性的变长数组</span></span><br><span class="line">    of_property_read_variable_u32_array(mydevice_node, <span class="string">&quot;reg&quot;</span>, out_value, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    printk(<span class="string">&quot;out_value[0] is 0x%X\n&quot;</span>, out_value[<span class="number">0</span>]);</span><br><span class="line">    printk(<span class="string">&quot;out_value[1] is 0x%X\n&quot;</span>, out_value[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取compatible属性的字符串值</span></span><br><span class="line">    of_property_read_string(mydevice_node, <span class="string">&quot;compatible&quot;</span>, &amp;value_compatible);</span><br><span class="line">    printk(<span class="string">&quot;compatible value is %s\n&quot;</span>, value_compatible);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Removing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table_id</span>[]  =</span> &#123;</span><br><span class="line">	&#123;.compatible=<span class="string">&quot;my devicetree&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">		.of_match_table =  of_match_table_id,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="67-3-运行测试"><a href="#67-3-运行测试" class="headerlink" title="67.3 运行测试"></a>67.3 运行测试</h2><h3 id="67-3-1-编译驱动程序"><a href="#67-3-1-编译驱动程序" class="headerlink" title="67.3.1 编译驱动程序"></a>67.3.1 编译驱动程序</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_driver.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_driver.c和Makefile文件目录下，如下图（图67-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024437.png" alt="img"></p>
<p>图 67-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图67-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024375.jpeg" alt="img"></p>
<p>图 67-2</p>
<p>编译完生成platform_driver.ko目标文件，如下图（图67-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024393.jpeg" alt="img"> </p>
<p>图 67-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="67-3-2-运行测试"><a href="#67-3-2-运行测试" class="headerlink" title="67.3.2 运行测试"></a>67.3.2 运行测试</h3><p>在进行实验之前，首先要确保开发板烧写的是我们在65.2.1小节中编译出来的boot.img，开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图67-4）所示：</p>
<p>insmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024402.jpeg" alt="img"> </p>
<p>图 67-4</p>
<p>可以看到总共有8个打印，第一个打印表示查找到的节点为myLed,接下来的打印都是使用该节点进行的属性查找。第二个打印表示查找的属性名为“compatible”，第三个打印表示查找的reg属性数量为2，第四个和第五个分别表示读取到的32位和64位的reg属性值，第6个和第7个打印表示reg的第一个属性值和第二个属性值，第8个打印表示compatite属性值为“my devicetree”。</p>
<p>然后使用以下命令进行驱动模块的卸载，如下图（图66-5）所示：</p>
<p>rmmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024444.png" alt="img"></p>
<p>图 67-5</p>
<p>至此，使用of操作函数获取设备树节点实验就完成了。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-62-dtb文件格式讲解</title>
    <url>/2023/09/05/1-66-of%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E5%AE%9E%E9%AA%8C-%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87%E6%A0%91%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第66章of操作函数实验：获取设备树节点"><a href="#第66章of操作函数实验：获取设备树节点" class="headerlink" title="第66章of操作函数实验：获取设备树节点"></a>第66章of操作函数实验：获取设备树节点</h1><p>在上一章节的学习中，我们学习了设备树下platform_device和platform_driver匹配，现在也只是让他们匹配在了一起，但这样显然是不够的，为了完成一些和硬件相关的需求，我们还需要获取到在设备树中编写的一些属性，那驱动是如何获取设备树中的属性呢，让我们一起进入后续章节的学习吧。</p>
<h2 id="66-1-of操作：获取设备树节点"><a href="#66-1-of操作：获取设备树节点" class="headerlink" title="66.1 of操作：获取设备树节点"></a>66.1 of操作：获取设备树节点</h2><h3 id="66-1-1-of-find-node-by-name函数"><a href="#66-1-1-of-find-node-by-name函数" class="headerlink" title="66.1.1 of_find_node_by_name函数"></a>66.1.1 of_find_node_by_name函数</h3><p>of_find_node_by_name 是Linux内核中用于通过节点名称查找设备树节点的函数。下面是对of_find_node_by_name 函数的详细介绍：</p>
<p><strong>函数原型：</strong></p>
<p>​	struct device_node *of_find_node_by_name(struct device_node *from, const char *name);</p>
<p><strong>头文件：</strong></p>
<p>​	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用：</strong><br>        该函数通过指定的节点名称在设备树中进行查找，返回匹配的节点的 struct device_node 指针。</p>
<p><strong>参数含义：</strong></p>
<p>​	from：指定起始节点，表示从哪个节点开始查找。如果 from 参数为 NULL，则从设备树的根节点开始查找。</p>
<p>​	name：要查找的节点名称。</p>
<p><strong>返回值：</strong></p>
<p>​	如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>​	如果未找到匹配的节点，则返回 NULL。</p>
<p>会在接下来的实验小节中，对该函数进行实际演示。</p>
<h3 id="66-1-2-of-find-node-by-path函数"><a href="#66-1-2-of-find-node-by-path函数" class="headerlink" title="66.1.2 of_find_node_by_path函数"></a>66.1.2 of_find_node_by_path函数</h3><p>of_find_node_by_path 是Linux内核中用于通过节点路径查找设备树节点的函数。下面是对of_find_node_by_path函数的详细介绍：</p>
<p><strong>函数原型：</strong></p>
<p>​	struct device_node *of_find_node_by_path(const char *path);</p>
<p><strong>头文件：</strong></p>
<p>​	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用：</strong><br>    该函数根据节点路径在设备树中进行查找，返回匹配的节点的 struct device_node 指针。</p>
<p><strong>参数含义：</strong></p>
<p>​	path：节点的路径，以斜杠分隔的字符串表示。路径格式为设备树节点的绝对路径，例如 &#x2F;topeet&#x2F;myLed。</p>
<p><strong>返回值：</strong></p>
<p>​	如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>​	如果未找到匹配的节点，则返回 NULL。</p>
<p>​	of_find_node_by_path 函数通过节点路径在设备树中进行查找。路径是设备树节点从根节点到目标节点的完整路径。可以通过指定正确的路径来准确地访问设备树中的特定节点。</p>
<p>​	使用 of_find_node_by_path 函数时，可以直接传递节点的完整路径作为 path 参数，函数会在设备树中查找匹配的节点。这对于已知节点路径的情况非常有用。</p>
<h3 id="66-1-3-of-get-parent函数"><a href="#66-1-3-of-get-parent函数" class="headerlink" title="66.1.3 of_get_parent函数"></a>66.1.3 of_get_parent函数</h3><p>在Linux内核中，of_get_parent 函数用于获取设备树节点的父节点。下面是对of_get_parent函数的详细介绍：</p>
<p><strong>函数原型：</strong></p>
<p>​	struct device_node *of_get_parent(const struct device_node *node);</p>
<p><strong>头文件：</strong></p>
<p>​	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用：</strong><br>    该函数接收一个指向设备树节点的指针 node，并返回该节点的父节点的指针。</p>
<p><strong>参数含义：</strong></p>
<p>​	node：要获取父节点的设备树节点指针。</p>
<p><strong>返回值：</strong></p>
<p>​	如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>​	如果未找到匹配的节点，则返回 NULL。</p>
<p>​	使用 of_get_parent 函数时，可以将特定的设备树节点作为参数传递给函数，然后它将返回该节点的父节点。这对于在设备树中导航和访问节点之间的层次关系非常有用。</p>
<p>​	父节点在设备树中表示了节点之间的层次结构关系。通过获取父节点，你可以访问上一级节点的属性和配置信息，从而更好地理解设备树中的节点之间的关系。</p>
<h3 id="66-1-4-of-get-next-child函数"><a href="#66-1-4-of-get-next-child函数" class="headerlink" title="66.1.4 of_get_next_child函数"></a>66.1.4 of_get_next_child函数</h3><p>在Linux内核中，of_get_next_child 函数用于获取设备树节点的下一个子节点。下面是对of_get_next_child 函数的详细介绍：</p>
<p><strong>函数原型：</strong></p>
<p>​	struct device_node *of_get_next_child(const struct device_node *node, struct device_node *prev);</p>
<p><strong>头文件：</strong></p>
<p>​	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用：</strong><br>    该函数接收两个参数：node 是当前节点，prev 是上一个子节点。它返回下一个子节点的指针。</p>
<p><strong>参数含义：</strong></p>
<p>​	node：当前节点，用于指定要获取子节点的起始节点。</p>
<p>​	prev：上一个子节点，用于指定从哪个子节点开始获取下一个子节点。如果为 NULL，则从起始节点的第一个子节点开始。</p>
<p><strong>返回值：</strong></p>
<p>​	如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>​	如果未找到匹配的节点，则返回 NULL。</p>
<p>​	使用 of_get_next_child 函数时，可以传递当前节点以及上一个子节点作为参数。函数将从上一个子节点的下一个节点开始，查找并返回下一个子节点。</p>
<p>​	设备树中的子节点表示了节点之间的层次关系。通过获取子节点，你可以遍历和访问当前节点的所有子节点，以便进一步处理它们的属性和配置信息。</p>
<h3 id="64-1-5-of-find-compatible-node函数"><a href="#64-1-5-of-find-compatible-node函数" class="headerlink" title="64.1.5 of_ find_ compatible_ node函数"></a>64.1.5 of_ find_ compatible_ node函数</h3><p>当设备树中存在多个设备节点，需要根据设备的兼容性字符串进行匹配时，可以使用 of_find_compatible_node 函数。该函数用于在设备树中查找与指定兼容性字符串匹配的节点。</p>
<p><strong>函数原型：</strong></p>
<p>​	struct device_node *of_find_compatible_node(struct device_node *from, const char *type, const char *compatible);</p>
<p><strong>头文件：</strong></p>
<p>​	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用：</strong><br>    在设备树中查找与指定兼容性字符串匹配的节点。</p>
<p><strong>参数含义：</strong></p>
<p>​	from：指定起始节点，表示从哪个节点开始查找。如果 from 参数为 NULL，则从设备树的根节点开始查找。</p>
<p>​	type：要匹配的设备类型字符串，通常是 compatible 属性中的一部分。</p>
<p>​	compatible：要匹配的兼容性字符串，通常是设备树节点的 compatible 属性中的值。</p>
<p><strong>返回值：</strong></p>
<p>​	如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>​	如果未找到匹配的节点，则返回 NULL。</p>
<p>​	使用 of_find_compatible_node 函数时，可以指定起始节点和需要匹配的设备类型字符串以及兼容性字符串。函数会从起始节点开始遍历设备树，查找与指定兼容性字符串匹配的节点，并返回匹配节点的指针。</p>
<h3 id="64-1-6-of-find-matching-node-and-match函数"><a href="#64-1-6-of-find-matching-node-and-match函数" class="headerlink" title="64.1.6 of_ find matching node_ and_ match函数"></a>64.1.6 of_ find matching node_ and_ match函数</h3><p>在Linux内核中，of_ find matching node_ and_ match函数用于根据给定的of_device_id匹配表在设备树中查找匹配的节点。</p>
<p><strong>函数原型：</strong></p>
<p>​	struct device_node *of_find_matching_node_and_match(struct device_node *from,const struct of_device_id *matches, const struct of_device_id **match);</p>
<p><strong>头文件：</strong></p>
<p>#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用：</strong><br>    根据给定的of_device_id匹配表在设备树中查找匹配的节点。</p>
<p><strong>参数含义：</strong></p>
<p>​	from：表示从哪个节点开始搜索。通常将上一次调用该函数返回的节点作为参数传递给from，以便从上一次的下一个节点开始搜索。如果要从设备树的根节点开始搜索，可以将from参数设置为NULL。</p>
<p>​	matches：指向一个of_device_id类型的匹配表，该表包含要搜索的匹配项。</p>
<p>​	match：用于输出匹配到的of_device_id条目的指针。</p>
<p><strong>返回值：</strong></p>
<p>​	如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>​	如果未找到匹配的节点，则返回 NULL。</p>
<p>of_find_matching_node_and_match函数在设备树中遍历节点，对每个节点使用__of_match_node函数进行匹配。如果找到匹配的节点，将返回该节点的指针，并将match指针更新为匹配到的of_device_id条目，函数会自动增加匹配节点的引用计数。以下是使用of_find_matching_node_and_match函数的示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">my_match_table</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;vendor,device&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">match</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从根节点开始查找匹配的节点</span></span><br><span class="line">np = of_find_matching_node_and_match(<span class="literal">NULL</span>, my_match_table, &amp;match);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个of_device_id匹配表my_match_table，其中包含了一个兼容性字符串为”vendor,device”的匹配项。然后，我们使用of_find_matching_node_and_match函数从根节点开始查找匹配的节点。</p>
<h2 id="66-2实验程序编写"><a href="#66-2实验程序编写" class="headerlink" title="66.2实验程序编写"></a>66.2实验程序编写</h2><p>本实验驱动对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\55_of_01。</p>
<p>本小节驱动程序是由上一章程序修改而来，相较于源程序只是在probe函数中添加了本章节学习的of操作相关代码，用来获取设备树节点。</p>
<p>编写完成的platform_driver.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mod_devicetable.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">mydevice_node</span>;</span>      </span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">mynode_match</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">mynode_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123;.compatible=<span class="string">&quot;my devicetree&quot;</span>&#125;,</span><br><span class="line">	&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_probe: Probing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过节点名称查找设备树节点</span></span><br><span class="line">    mydevice_node = of_find_node_by_name(<span class="literal">NULL</span>, <span class="string">&quot;myLed&quot;</span>);</span><br><span class="line">	printk(<span class="string">&quot;mydevice node is %s\n&quot;</span>, mydevice_node-&gt;name);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 通过节点路径查找设备树节点</span></span><br><span class="line">    mydevice_node = of_find_node_by_path(<span class="string">&quot;/topeet/myLed&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;mydevice node is %s\n&quot;</span>, mydevice_node-&gt;name);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 获取父节点</span></span><br><span class="line">    mydevice_node = of_get_parent(mydevice_node);</span><br><span class="line">    printk(<span class="string">&quot;myled&#x27;s parent node is %s\n&quot;</span>, mydevice_node-&gt;name);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 获取子节点</span></span><br><span class="line">    mydevice_node = of_get_next_child(mydevice_node, <span class="literal">NULL</span>);</span><br><span class="line">    printk(<span class="string">&quot;myled&#x27;s sibling node is %s\n&quot;</span>, mydevice_node-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用compatible值查找节点</span></span><br><span class="line">	mydevice_node=of_find_compatible_node(<span class="literal">NULL</span> ,<span class="literal">NULL</span>, <span class="string">&quot;my devicetree&quot;</span>);</span><br><span class="line">	printk(<span class="string">&quot;mydevice node is %s\n&quot;</span> , mydevice_node-&gt;name);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//根据给定的of_device_id匹配表在设备树中查找匹配的节点</span></span><br><span class="line">	mydevice_node=of_find_matching_node_and_match(<span class="literal">NULL</span> , mynode_of_match, &amp;mynode_match);</span><br><span class="line">	printk(<span class="string">&quot;mydevice node is %s\n&quot;</span> ,mydevice_node-&gt;name);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Removing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table_id</span>[]  =</span> &#123;</span><br><span class="line">	&#123;.compatible=<span class="string">&quot;my devicetree&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">		.of_match_table =  of_match_table_id,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="66-3-运行测试"><a href="#66-3-运行测试" class="headerlink" title="66.3 运行测试"></a>66.3 运行测试</h2><h3 id="66-3-1-编译驱动程序"><a href="#66-3-1-编译驱动程序" class="headerlink" title="66.3.1 编译驱动程序"></a>66.3.1 编译驱动程序</h3><p>在上一小节中的platform_driver.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_driver.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_driver.c和Makefile文件目录下，如下图（图66-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024273.jpeg" alt="img"> </p>
<p>图 66-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图66-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024325.jpeg" alt="img"> </p>
<p>图 66-2</p>
<p>编译完生成platform_driver.ko目标文件，如下图（图66-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024321.jpeg" alt="img"> </p>
<p>图 66-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="66-3-2-运行测试"><a href="#66-3-2-运行测试" class="headerlink" title="66.3.2 运行测试"></a>66.3.2 运行测试</h3><p>在进行实验之前，首先要确保开发板烧写的是我们在65.2.1小节中编译出来的boot.img，开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图66-4）所示：</p>
<p>insmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024311.jpeg" alt="img"> </p>
<p>图 66-4</p>
<p>可以看到总共有4个打印，前两个打印都是查找的myLed节点，第三个打印是查找的myLed的父节点，也就是topeet节点，第四个打印是查找的topeet的子节点，也就又回到了myLed节点。第5个打印是通过compatible属性查找到的myLed节点，第6个打印是通过of_device_id匹配表查找到的myLed节点.</p>
<p>然后使用以下命令进行驱动模块的卸载，如下图（图66-5）所示：</p>
<p>rmmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024287.jpeg" alt="img"> </p>
<p>图 66-5</p>
<p>至此，使用of操作函数获取设备树节点实验就完成了。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-62-dtb文件格式讲解</title>
    <url>/2023/09/05/1-65-%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B8%8Bplatform-device%E5%92%8Cplatform-driver%E5%8C%B9%E9%85%8D%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第65章-设备树下platform-device和platform-driver匹配实验"><a href="#第65章-设备树下platform-device和platform-driver匹配实验" class="headerlink" title="第65章 设备树下platform_device和platform_driver匹配实验"></a>第65章 设备树下platform_device和platform_driver匹配实验</h1><p>在上一章节中我们学习了从device_node到platform_device的转换流程，转换完成之后操作系统才能够识别和管理设备，从而与platform_driver进行匹配，在本章将将会对设备树下platform_device和platform_driver的匹配进行讲解。</p>
<h2 id="65-1-of-match-table"><a href="#65-1-of-match-table" class="headerlink" title="65.1 of_match_table"></a>65.1 of_match_table</h2><p>在前面平台总线相关章节的学习中，了解到只有platform_device结构体中的name 属性与platform_driver结构体中嵌套的driver结构体name属性或者id_table相同才能加载probe初始化函数。</p>
<p>而为了使设备树能够与驱动程序进行匹配，需要在platform_driver驱动程序中添加driver结构体的of_match_table 属性。这个属性是一个指向 const struct of_device_id 结构的指针，用于描述设备树节点和驱动程序之间的匹配规则。of_device_id 结构体定义在内核源码的“&#x2F;include&#x2F;linux&#x2F;mod_devicetable.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>	name[<span class="number">32</span>];</span><br><span class="line">	<span class="type">char</span>	type[<span class="number">32</span>];</span><br><span class="line">	<span class="type">char</span>	compatible[<span class="number">128</span>];</span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct of_device_id 结构体通常作为一个数组在驱动程序中定义，用于描述设备树节点和驱动程序之间的匹配规则。数组的最后一个元素必须是一个空的结构体，以标记数组的结束。</p>
<p>以下是一个示例，展示了如何在驱动程序中使用 struct of_device_id 进行设备树匹配</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">my_driver_match</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;vendor,device-1&quot;</span> &#125;,</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;vendor,device-2&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，my_driver_match 是一个 struct of_device_id 结构体数组。每个数组元素都包含了一个 compatible 字段，用于指定设备树节点的兼容性字符串。驱动程序将根据这些兼容性字符串与设备树中的节点进行匹配。</p>
<h2 id="65-2实验程序编写"><a href="#65-2实验程序编写" class="headerlink" title="65.2实验程序编写"></a>65.2实验程序编写</h2><p>本次实验的要求使用设备树描述下面的内存资源：<br><strong>内存资源：</strong></p>
<p>起始地址：0xFDD60000</p>
<p>结束地址：0xFDD60004</p>
<p>然后编写对应的platform_driver驱动程序，要求跟上述内存资源所创建的节点进行匹配，从而验证 上一小节讲解的of_match_table 属性。</p>
<h3 id="65-2-1-设备树的编写"><a href="#65-2-1-设备树的编写" class="headerlink" title="65.2.1 设备树的编写"></a>65.2.1 设备树的编写</h3><p>​	修改完成的dts文件和编译完成的boot.img镜像对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\54_devicetree_probe\dts。</p>
<p>首先来对rk3568的设备树结构进行以下介绍，根据sdk源码目录下的“device&#x2F;rockchip&#x2F;rk356x&#x2F;BoardConfig-rk3568-evb1-ddr4-v10.mk”默认配置文件可以了解到编译的设备树为rk3568-evb1-ddr4-v10-linux.dts,设备树之间的包含关系如下表所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024599.png" alt="image-20230906172158251"></p>
<p>rk3568-evb1-ddr4-v10-linux.dts是顶层设备树，为了便于理解我们之后在该设备树下进行节点的添加（当然这里也可以修改其他设备树），进入该设备树文件之后如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024627.jpeg" alt="img"> </p>
<p>然后将根据需求编写的设备树节点添加到rk3568-evb1-ddr4-v10-linux.dts中，要添加的内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">    topeet&#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        compatible = <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line"></span><br><span class="line">        myLed&#123;</span><br><span class="line">            compatible = <span class="string">&quot;my devicetree&quot;</span>;</span><br><span class="line">            reg = &lt;<span class="number">0xFDD60000</span> <span class="number">0x00000004</span>&gt;;</span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;;      </span><br></pre></td></tr></table></figure>

<p>为了避免#address-cells &#x3D; &lt;1&gt;; 和 #size-cells &#x3D; &lt;1&gt;;这两个属性改变根节点其他的节点的属性，所以在这里创建了一个topeet节点。在这个示例中，#address-cells 设置为 1表示地址使用一个32位的单元，#size-cells 也设置为 1 表示大小使用一个32位的单元。</p>
<p>第5行：将compatible属性设置为”simple-bus”用于表示 topeet 节点的兼容性，指明它是一个简单总线设备，在转换platform_device的过程中，会继续查找该节点的子节点。</p>
<p>第8行：myLed 节点下的compatible属性为”my devicetree”，表明该节点将会被转换为platform_device。</p>
<p>第9行：这个属性用于描述 myLed 节点的寄存器信息。reg 属性的值 &lt;0xFDD60000 0x00000004&gt; 表示 myLed 设备的寄存器起始地址为 0xFDD60000，大小为 0x00000004。</p>
<p>添加完成如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024665.jpeg" alt="img"> </p>
<p>保存退出之后，重新编译内核源码，编译完成之后将生成的boot.img烧写到开发板即可。</p>
<h3 id="66-2-2-驱动程序的编写"><a href="#66-2-2-驱动程序的编写" class="headerlink" title="66.2.2 驱动程序的编写"></a>66.2.2 驱动程序的编写</h3><p>本实验驱动对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\54_devicetree_probe\module。</p>
<p>本小节驱动程序是由“第52章 注册platform驱动实验”程序修改而来，相较于源程序只是添加了of_match_table相关代码，用来与设备树节点进行匹配。</p>
<p>编写完成的platform_driver.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mod_devicetable.h&gt;</span></span></span><br><span class="line"><span class="comment">// 平台设备的初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_probe: Probing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Removing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table_id</span>[]  =</span> &#123;</span><br><span class="line">	&#123;.compatible=<span class="string">&quot;my devicetree&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">		.of_match_table =  of_match_table_id,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="65-3-运行测试"><a href="#65-3-运行测试" class="headerlink" title="65.3 运行测试"></a>65.3 运行测试</h2><p>在上一小节中的platform_driver.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_driver.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<h3 id="65-3-1-编译驱动程序"><a href="#65-3-1-编译驱动程序" class="headerlink" title="65.3.1 编译驱动程序"></a>65.3.1 编译驱动程序</h3><p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_driver.c和Makefile文件目录下，如下图（图65-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024622.jpeg" alt="img"> </p>
<p>图 65-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图65-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024694.jpeg" alt="img"> </p>
<p>图 65-2</p>
<p>编译完生成platform_driver.ko目标文件，如下图（图65-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024642.jpeg" alt="img"> </p>
<p>图 65-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="65-3-2-运行测试"><a href="#65-3-2-运行测试" class="headerlink" title="65.3.2 运行测试"></a>65.3.2 运行测试</h3><p>在进行实验之前，首先要确保开发板烧写的是我们在65.2.1小节中编译出来的boot.img。开发板启动之后，首先进入到“&#x2F;proc&#x2F;device-tree”目录下，查看是否已经存在了topeet目录，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024040.jpeg" alt="img"> </p>
<p>只有在设备树节点编写正确的前提下，这里才会生成topeet目录，如果没有出现topeet目录就要回头检查看看了。</p>
<p>然后使用以下命令进行驱动模块的加载，如下图（图65-4）所示：</p>
<p>insmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024018.jpeg" alt="img"> </p>
<p>图 65-4</p>
<p>可以看到成功打印了在probe函数中的打印，证明我们添加的设备树节点和platform_driver驱动匹配成功了。</p>
<p>然后使用以下命令进行驱动模块的卸载，如下图（图65-5）所示：</p>
<p>rmmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024031.jpeg" alt="img"> </p>
<p>图 65-5</p>
<p>至此，设备树下platform_device和platform_driver匹配实验就完成了。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-62-dtb文件格式讲解</title>
    <url>/2023/09/05/1-64-device-node%E8%BD%AC%E6%8D%A2%E6%88%90platform-device%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第64章-device-node转换成platform-device实验"><a href="#第64章-device-node转换成platform-device实验" class="headerlink" title="第64章 device_node转换成platform_device实验"></a>第64章 device_node转换成platform_device实验</h1><p>在上一章中，我们学习了dtb二进制文件展开成device_node的具体流程，而device_node这时候还并不能跟内核中的platform_driver进行对接，而为了让操作系统能够识别和管理设备，需要将设备节点转换为平台设备。</p>
<h2 id="64-1-转换规格"><a href="#64-1-转换规格" class="headerlink" title="64.1 转换规格"></a>64.1 转换规格</h2><p>在之前学习的平台总线模型中，device部分是用platform_device结构体来描述硬件资源的，所以内核最终会将内核认识的device_node树转换platform_ device，但是并不是所有的device_node都会被转换成platform_ device，只有满足要求的才会转换成platform_ device,转换成platform_device的节点可以在&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;devices下查看，那device_node节点要满足什么要求才会被转换成platform_device呢? </p>
<p>根据规则1，首先遍历根节点下包含 compatible 属性的子节点，对于每个子节点，创建一个对应的 platform_device。</p>
<p>根据规则2，遍历包含 compatible 属性为 “simple-bus”、”simple-mfd” 或 “isa” 的节点以及它们的子节点。如果子节点包含 compatible 属性值则会创建一个对应的platform_device。</p>
<p>根据规则3，检查节点的 compatible 属性是否包含 “arm” 或 “primecell”。如果是，则不将该节点转换为 platform_device，而是将其识别为 AMBA 设备。</p>
<p>接下来将通过几个设备树示例对上述规则进行实践。</p>
<p><strong>举例1：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = <span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0, 115200&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a35&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x1</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    aliases &#123;</span><br><span class="line">        led1 = <span class="string">&quot;/gpio@22020101&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node1 &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">        gpio@<span class="number">22020102</span> &#123;</span><br><span class="line">            reg = &lt;<span class="number">0x20220102</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node2 &#123;</span><br><span class="line">        node1-child &#123;</span><br><span class="line">            pinnum = &lt;<span class="number">01234</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@<span class="number">22020101</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;led&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x20220101</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的设备树中，总共有chosen、cpu1: cpu@1、aliases、node1、node2、gpio@22020101</p>
<p>这六个节点，其中前五个节点都没有compatible属性，所以并不会被转换为platform_device，而最后一个gpio@22020101节点符合规则一，在根节点下，且有compatible属性，所以最后会转换为platform_device。</p>
<p><strong>举例2：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = <span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0, 115200&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a35&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x1</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    aliases &#123;</span><br><span class="line">        led1 = <span class="string">&quot;/gpio@22020101&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node1 &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">		    compatible = <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line">        gpio@<span class="number">22020102</span> &#123;</span><br><span class="line">            reg = &lt;<span class="number">0x20220102</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node2 &#123;</span><br><span class="line">        node1-child &#123;</span><br><span class="line">            pinnum = &lt;<span class="number">01234</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@<span class="number">22020101</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;led&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x20220101</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相较于示例1的设备树，这里在node1节点中添加了 compatible 属性，但是这个compatible属性值为simple-bus，我们需要继续看他的子节点，子节点 gpio@22020102 并没有compatible属性值，所以这里的node1节点不会被转换。</p>
<p><strong>举例3：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = <span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0, 115200&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a35&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x1</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    aliases &#123;</span><br><span class="line">        led1 = <span class="string">&quot;/gpio@22020101&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node1 &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">		    compatible = <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line">        gpio@<span class="number">22020102</span> &#123;</span><br><span class="line">			compatible = <span class="string">&quot;gpio&quot;</span>;</span><br><span class="line">            reg = &lt;<span class="number">0x20220102</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node2 &#123;</span><br><span class="line">        node1-child &#123;</span><br><span class="line">            pinnum = &lt;<span class="number">01234</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@<span class="number">22020101</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;led&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x20220101</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相较于示例2的设备树，这里在node1节点的子节点 gpio@22020102 中添加了 compatible 属性，node1节点的compatible属性值为simple-bus，然后需要继续看他的子节点，子节点 gpio@22020102 的compatible属性值为gpio，所以这里的gpio@22020102节点会被转换成platform_device。</p>
<p>示例4：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = <span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0,115200&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpul: cpu@<span class="number">1</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a35&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x1</span>&gt;;</span><br><span class="line"></span><br><span class="line">        amba &#123;</span><br><span class="line">            compatible = <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line">            <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">            <span class="meta">#size-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">            ranges;</span><br><span class="line"></span><br><span class="line">            dmac_peri: dma-controller@ff250000 &#123;</span><br><span class="line">                compatible = <span class="string">&quot;arm,p1330&quot;</span>, <span class="string">&quot;arm,primecell&quot;</span>;</span><br><span class="line">                reg = &lt;<span class="number">0x0</span> <span class="number">0xff250000</span> <span class="number">0x0</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">                interrupts = &lt;GIC_SPI <span class="number">2</span> IRQ_TYPE_LEVEL_HIGH&gt;,</span><br><span class="line">                             &lt;GIC_SPI <span class="number">3</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">                <span class="meta">#dma-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">                arm,pl330-broken-no-flushp;</span><br><span class="line">                arm,p1330-periph-burst;</span><br><span class="line">                clocks = &lt;&amp;cru ACLK DMAC_PERI&gt;;</span><br><span class="line">                clock-names = <span class="string">&quot;apb_pclk&quot;</span>;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            dmac_bus: dma-controller@ff600000 &#123;</span><br><span class="line">                compatible = <span class="string">&quot;arm,p1330&quot;</span>, <span class="string">&quot;arm,primecell&quot;</span>;</span><br><span class="line">                reg = &lt;<span class="number">0x0</span> <span class="number">0xff600000</span> <span class="number">0x0</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">                interrupts = &lt;GIC_SPI <span class="number">0</span> IRQ_TYPE_LEVEL_HIGH&gt;,</span><br><span class="line">                             &lt;GIC_SPI <span class="number">1</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">                <span class="meta">#dma-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">                arm,pl330-broken-no-flushp;</span><br><span class="line">                arm,pl330-periph-burst;</span><br><span class="line">                clocks = &lt;&amp;cru ACLK_DMAC_BUS&gt;;</span><br><span class="line">                clock-names = <span class="string">&quot;apb_pclk&quot;</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>amba 节点的compatible值为simple-bus，不会被转换为 platform_device，而是作为父节点用于组织其他设备，所以需要来查看他的子节点。</p>
<p>dmac_peri: dma-controller@ff250000 节点: 该节点的 compatible 属性包含 “arm,p1330” 和 “arm,primecell”，根据规则3，该节点不会被转换为 platform_device，而是被识别为 AMBA 设备。</p>
<p>dmac_bus: dma-controller@ff600000 节点: 该节点的 compatible 属性包含 “arm,p1330” 和 “arm,primecell”，根据规则3，该节点不会被转换为 platform_device，而是被识别为 AMBA 设备。</p>
<h2 id="64-2-转换流程源码分析"><a href="#64-2-转换流程源码分析" class="headerlink" title="64.2 转换流程源码分析"></a>64.2 转换流程源码分析</h2><p>首先进入到内核源码目录下的“drivers&#x2F;of&#x2F;platform.c”文件中，找到第555行，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arch_initcall_sync(of_platform_default_populate_init);</span><br></pre></td></tr></table></figure>

<p>arch_initcall_sync 是 Linux 内核中的一个函数，用于在内核初始化过程中执行架构相关的初始化函数。它属于内核的初始化调用机制，用于确保在系统启动过程中适时地调用特定架构的初始化函数。</p>
<p>在Linux内核的初始化过程中，各个子系统和架构会注册自己的初始化函数。这些初始化函数负责完成特定子系统或架构相关的初始化工作，例如初始化硬件设备、注册中断处理程序、设置内存映射等。而 arch_initcall_sync 函数则用于调用与当前架构相关的初始化函数。</p>
<p>当内核启动时，调用 rest_init() 函数来启动初始化过程。在初始化过程中，arch_initcall_sync 函数会被调用，以确保所有与当前架构相关的初始化函数按照正确的顺序执行。这样可以保证在启动过程中，特定架构相关的初始化工作得到正确地完成。</p>
<p>而of_platform_default_populate_init函数的作用是在内核初始化过程中自动解析设备树，并根据设备树中的设备节点创建对应的 platform_device 结构。它会遍历设备树中的设备节点，并为每个设备节点创建一个对应的 platform_device 结构，然后将其注册到内核中，使得设备驱动程序能够识别和操作这些设备。该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">of_platform_default_populate_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂停设备链接供应商同步状态</span></span><br><span class="line">    device_links_supplier_sync_state_pause();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设备树尚未填充，则返回错误码</span></span><br><span class="line">    <span class="keyword">if</span> (!of_have_populated_dt())</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 显式处理某些兼容性，因为我们不想为/reserved-memory中的每个具有“compatible”的节点创建platform_device。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    for_each_matching_node(node, reserved_mem_matches)</span><br><span class="line">        of_platform_device_create(node, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找节点 &quot;/firmware&quot;</span></span><br><span class="line">    node = of_find_node_by_path(<span class="string">&quot;/firmware&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="comment">// 使用该节点进行设备树平台设备的填充</span></span><br><span class="line">        of_platform_populate(node, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        of_node_put(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充其他设备</span></span><br><span class="line">    fw_devlink_pause();</span><br><span class="line">    of_platform_default_populate(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    fw_devlink_resume();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第6行：暂停设备链接供应商的同步状态，确保设备链接的状态不会在此过程中被改变。</p>
<p>第9行：检查设备树是否已经被填充。如果设备树尚未填充，则返回错误码 -ENODEV。</p>
<p>第16行：遍历设备树中与 reserved_mem_matches 匹配的节点。这些节点是 &#x2F;reserved-memory 中具有 “compatible” 属性的节点。</p>
<p>第17行：为 &#x2F;reserved-memory 中匹配的节点创建 platform_device 结构。这些节点不会为每个节点都创建 platform_device，而是根据需要进行显式处理。</p>
<p>第20行：在设备树中查找路径为 “&#x2F;firmware” 的节点。</p>
<p>第23行：使用找到的节点填充设备树中的平台设备。这些节点可能包含与固件相关的设备。</p>
<p>第28行：暂停固件设备链接，确保在填充其他设备时链接状态不会改变。</p>
<p>第29行：填充设备树中的其他设备。</p>
<p>第30行：恢复固件设备链接。</p>
<p>上诉内容中我们要着重关注的是第29行的of_platform_default_populate(NULL, NULL, NULL)函数，找到该函数的定义之后如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_platform_default_populate</span><span class="params">(<span class="keyword">struct</span> device_node *root,</span></span><br><span class="line"><span class="params">				 <span class="type">const</span> <span class="keyword">struct</span> of_dev_auxdata *lookup,</span></span><br><span class="line"><span class="params">				 <span class="keyword">struct</span> device *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> of_platform_populate(root, of_default_bus_match_table, lookup,</span><br><span class="line">				    parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的作用是调用 of_platform_populate 函数来填充设备树中的平台设备，并使用默认的设备匹配表 of_default_bus_match_table，设备匹配表内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_default_bus_match_table</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;simple-bus&quot;</span>, &#125;,</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;simple-mfd&quot;</span>, &#125;,</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;isa&quot;</span>, &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM_AMBA</span></span><br><span class="line">	&#123; .compatible = <span class="string">&quot;arm,amba-bus&quot;</span>, &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_ARM_AMBA */</span></span></span><br><span class="line">	&#123;&#125; <span class="comment">/* Empty terminated list */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述的设备匹配表就是我们在第一小节中第2条规则，，函数将自动根据设备树节点的属性匹配相应的设备驱动程序，并填充内核的平台设备列表。接下来找到of_platform_populate函数的定义，该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_platform_populate</span><span class="params">(<span class="keyword">struct</span> device_node *root,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> of_device_id *matches,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> of_dev_auxdata *lookup,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> device *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span></span><br><span class="line">	<span class="type">int</span> rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 root 不为空，则增加 root 节点的引用计数；否则，在设备树中根据路径查找 root 节点</span></span><br><span class="line">	root = root ? of_node_get(root) : of_find_node_by_path(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!root)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;%s()\n&quot;</span>, __func__);</span><br><span class="line">	pr_debug(<span class="string">&quot; starting at: %pOF\n&quot;</span>, root);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 暂停设备链接供应商同步状态</span></span><br><span class="line">	device_links_supplier_sync_state_pause();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历 root 节点的所有子节点</span></span><br><span class="line">	for_each_child_of_node(root, child) &#123;</span><br><span class="line">		<span class="comment">// 创建平台设备并添加到设备树总线</span></span><br><span class="line">		rc = of_platform_bus_create(child, matches, lookup, parent, <span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">if</span> (rc) &#123;</span><br><span class="line">			of_node_put(child);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 恢复设备链接供应商同步状态</span></span><br><span class="line">	device_links_supplier_sync_state_resume();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置 root 节点的 OF_POPULATED_BUS 标志</span></span><br><span class="line">	of_node_set_flag(root, OF_POPULATED_BUS);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放 root 节点的引用计数</span></span><br><span class="line">	of_node_put(root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的具体执行步骤如下：</p>
<p>第10行：检查给定的设备树节点 node 是否为有效节点。如果节点为空，函数将立即返回。</p>
<p>第21行：遍历设备树节点的子节点，查找与平台设备相关的节点。这些节点通常具有 compatible 属性，用于匹配设备驱动程序。</p>
<p>第23行：对于每个找到的平台设备节点，创建一个 platform_device 结构，并根据设备树节点的属性设置该结构的各个字段。</p>
<p>第25行：将创建的 platform_device 添加到内核的平台设备列表中，以便设备驱动程序能够识别和操作这些设备。</p>
<p>接下来对该函数的第23行核心代码of_platform_bus_create(child, matches, lookup, parent, true)函数进行讲解，该函数的具体定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">of_platform_bus_create</span><span class="params">(<span class="keyword">struct</span> device_node *bus,</span></span><br><span class="line"><span class="params">				  <span class="type">const</span> <span class="keyword">struct</span> of_device_id *matches,</span></span><br><span class="line"><span class="params">				  <span class="type">const</span> <span class="keyword">struct</span> of_dev_auxdata *lookup,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> device *parent, <span class="type">bool</span> strict)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_dev_auxdata</span> *<span class="title">auxdata</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *bus_id = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">void</span> *platform_data = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 确保设备节点具有 compatible 属性 */</span></span><br><span class="line">	<span class="keyword">if</span> (strict &amp;&amp; (!of_get_property(bus, <span class="string">&quot;compatible&quot;</span>, <span class="literal">NULL</span>))) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;%s() - skipping %pOF, no compatible prop\n&quot;</span>,</span><br><span class="line">			 __func__, bus);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 跳过不想创建设备的节点 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(of_match_node(of_skipped_node_table, bus))) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;%s() - skipping %pOF node\n&quot;</span>, __func__, bus);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (of_node_check_flag(bus, OF_POPULATED_BUS)) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;%s() - skipping %pOF, already populated\n&quot;</span>,</span><br><span class="line">			__func__, bus);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	auxdata = of_dev_lookup(lookup, bus);</span><br><span class="line">	<span class="keyword">if</span> (auxdata) &#123;</span><br><span class="line">		bus_id = auxdata-&gt;name;</span><br><span class="line">		platform_data = auxdata-&gt;platform_data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (of_device_is_compatible(bus, <span class="string">&quot;arm,primecell&quot;</span>)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 在此处不返回错误以保持与旧设备树文件的兼容性。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		of_amba_device_create(bus, bus_id, platform_data, parent);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent);</span><br><span class="line">	<span class="keyword">if</span> (!dev || !of_match_node(matches, bus))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	for_each_child_of_node(bus, child) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;   create child: %pOF\n&quot;</span>, child);</span><br><span class="line">		rc = of_platform_bus_create(child, matches, lookup, &amp;dev-&gt;dev, strict);</span><br><span class="line">		<span class="keyword">if</span> (rc) &#123;</span><br><span class="line">			of_node_put(child);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	of_node_set_flag(bus, OF_POPULATED_BUS);</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第14行：如果 strict 为真且设备节点 bus 没有兼容性属性，则输出调试信息并返回 0。这个条件判断确保设备节点具有 compatible 属性，因为 compatible 属性用于匹配设备驱动程序，对应我们在上一小节的第1条规则。</p>
<p>第21行：如果设备节点 bus 在被跳过的节点表中，则输出调试信息并返回 0。这个条件判断用于跳过不想创建设备的节点。</p>
<p>第27行：如果设备节点 bus 的 OF_POPULATED_BUS 标志已经设置，则输出调试信息并返回 0。这个条件判断用于避免重复创建已经填充的设备节点。</p>
<p>第34行：使用 lookup 辅助数据结构查找设备节点 bus 的特定配置信息，并将其赋值给变量 bus_id 和 platform_data。这个步骤用于获取设备节点的特定配置信息，以便在创建平台设备时使用，由于这里传入的参数为NULL，所以下面的条件判断并不会被执行。</p>
<p>第39行：如果设备节点 bus 兼容于 “arm,primecell”，则调用 of_amba_device_create 函数创建 AMBA 设备，并返回 0，对应我们在上一小节学习的第3条规则。</p>
<p>第47行：调用 of_platform_device_create_pdata函数创建平台设备，并将其赋值给变量 dev。然后，检查设备节点 bus是否与给定的匹配表 <code>matches</code> 匹配。如果平台设备创建失败或者设备节点不匹配，那么返回 0。</p>
<p>第51行-第58行：遍历设备节点 bus 的每个子节点 child，并递归调用 of_platform_bus_create 函数来创建子节点的平台设备。</p>
<p>接下来对该函数的第47行 of_platform_device_create_pdata函数进行讲解，该函数的具体定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> platform_device *<span class="title function_">of_platform_device_create_pdata</span><span class="params">(</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">					<span class="type">const</span> <span class="type">char</span> *bus_id,</span></span><br><span class="line"><span class="params">					<span class="type">void</span> *platform_data,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> device *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查设备节点是否可用或已填充 */</span></span><br><span class="line">	<span class="keyword">if</span> (!of_device_is_available(np) ||</span><br><span class="line">	    of_node_test_and_set_flag(np, OF_POPULATED))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 分配平台设备结构体 */</span></span><br><span class="line">	dev = of_device_alloc(np, bus_id, parent);</span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">goto</span> err_clear_flag;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置平台设备的一些属性 */</span></span><br><span class="line">	dev-&gt;dev.coherent_dma_mask = DMA_BIT_MASK(<span class="number">32</span>);</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;dev.dma_mask)</span><br><span class="line">		dev-&gt;dev.dma_mask = &amp;dev-&gt;dev.coherent_dma_mask;</span><br><span class="line">	dev-&gt;dev.bus = &amp;platform_bus_type;</span><br><span class="line">	dev-&gt;dev.platform_data = platform_data;</span><br><span class="line">	of_msi_configure(&amp;dev-&gt;dev, dev-&gt;dev.of_node);</span><br><span class="line">	of_reserved_mem_device_init_by_idx(&amp;dev-&gt;dev, dev-&gt;dev.of_node, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将平台设备添加到设备模型中 */</span></span><br><span class="line">	<span class="keyword">if</span> (of_device_add(dev) != <span class="number">0</span>) &#123;</span><br><span class="line">		platform_device_put(dev);</span><br><span class="line">		<span class="keyword">goto</span> err_clear_flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev;</span><br><span class="line"></span><br><span class="line">err_clear_flag:</span><br><span class="line">	<span class="comment">/* 清除设备节点的已填充标志 */</span></span><br><span class="line">	of_node_clear_flag(np, OF_POPULATED);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>第10行：函数会检查设备节点的可用性，即检查设备树对应节点的status属性。如果设备节点不可用或已经被填充，则直接返回 NULL。</p>
<p>第15行：函数调用 of_device_alloc 分配一个平台设备结构体，并将设备节点指针、设备标识符和父设备指针传递给它。如果分配失败，则跳转到 err_clear_flag 标签处进行错误处理。</p>
<p>第19行，函数设置平台设备的一些属性。它将 coherent_dma_mask 属性设置为 32 位的 DMA 位掩码，并检查 dma_mask 属性是否为 NULL。如果 dma_mask 为 NULL，则将其指向 coherent_dma_mask。然后，函数设置平台设备的总线类型为 platform_bus_type，并将平台数据指针存储在 platform_data 属性中。接着，函数调用 of_msi_configure 和 of_reserved_mem_device_init_by_idx 来配置设备的 MSI 和保留内存信息。</p>
<p>第29行：函数调用 of_device_add 将平台设备添加到设备模型中。如果添加失败，则释放已分配的平台设备，并跳转到 err_clear_flag 标签处进行错误处理。</p>
<p>至此，关于device_node转换成platform_device的具体流程就分析完成了，函数调用流程图如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024870.jpeg" alt="img"></p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-62-dtb文件格式讲解</title>
    <url>/2023/09/05/1-63-dtb%E5%B1%95%E5%BC%80%E6%88%90device-node%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第63章-dtb展开成device-node实验"><a href="#第63章-dtb展开成device-node实验" class="headerlink" title="第63章 dtb展开成device_node实验"></a>第63章 dtb展开成device_node实验</h1><p>在上个小节中我们讲解了设备树deb的文件格式，那deb文件是怎样传递给内核的呢，那就进入到本小节的学习吧。</p>
<h2 id="63-1-dtb展开流程"><a href="#63-1-dtb展开流程" class="headerlink" title="63.1 dtb展开流程"></a>63.1 dtb展开流程</h2><p>dtb展开流程图如下所示：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\ksohtml13380\wps224.jpg" alt="img"> </p>
<p>接下来将会根据上图对deb的展开流程进行详细的讲解：</p>
<p><strong>（1）设备树源文件编写：</strong>根据之前的章节中讲解的设备树的基本语法和相关知识编写符合规范的设备树。</p>
<p><strong>（2）设备树编译：</strong>设备树源文件经过设备树编译器（dtc）进行编译，生成设备树二进制文件（.dtb）。设备树编译器会检查源文件的语法和语义，并将其转换为二进制格式，以便内核能够解析和使用。</p>
<p><strong>（3）boot.img</strong>镜像生成：boot.img是一个包含内核镜像、设备树二进制文件和其他一些资源文件的镜像文件（目前只是适用于瑞芯微的soc上，其他厂商的soc需要具体问题具体分析）。在生成boot.img时，通常会将内核镜像、设备树二进制文件和其他一些资源文件打包在一起。这个过程可以使用特定的工具或脚本完成。</p>
<p>（<strong>4）U-Boot加载：</strong>U-Boot（Universal Bootloader）是一种常用的开源引导加载程序，用于引导嵌入式系统。在系统启动过程中，U-Boot会将boot.img中的内核和设备树的二进制文件加载到系统内存的特定地址。</p>
<p><strong>（5）内核初始化：</strong>U-Boot将内核和设备树的二进制文件加载到系统内存的特定地址后，控制权会转交给内核。在内核初始化的过程中，会解析设备树二进制文件，将其展开为内核可以识别的数据结构，以便内核能够正确地初始化和管理硬件资源。</p>
<p><strong>（6）设备树展开：</strong>设备树展开是指将设备树二进制文件解析成内核中的设备节点（device_node）的过程。内核会读取设备树二进制文件的内容，并根据设备树的描述信息，构建设备树数据结构，例如设备节点、中断控制器、寄存器、时钟等。这些设备树数据结构将在内核运行时用于管理和配置硬件资源。</p>
<p>而本章节要讲解的重点就在上面的第6步“设备树的展开”，最终设备树二进制文件会被解析成device_node，device_node结构体定义在内核源码的“&#x2F;include&#x2F;linux&#x2F;of.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;                <span class="comment">// 设备节点的名称</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *type;                <span class="comment">// 设备节点的类型</span></span><br><span class="line">	phandle phandle;                  <span class="comment">// 设备节点的句柄</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *full_name;           <span class="comment">// 设备节点的完整名称</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> <span class="title">fwnode</span>;</span>     <span class="comment">// 设备节点的固件节点句柄</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">properties</span>;</span>     <span class="comment">// 设备节点的属性列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">deadprops</span>;</span>      <span class="comment">// 已删除的属性列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">parent</span>;</span>      <span class="comment">// 父设备节点指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span>       <span class="comment">// 子设备节点指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">sibling</span>;</span>     <span class="comment">// 兄弟设备节点指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_KOBJ)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>             <span class="comment">// 内核对象（用于 sysfs）</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> _flags;            <span class="comment">// 设备节点的标志位</span></span><br><span class="line">	<span class="type">void</span> *data;                      <span class="comment">// 与设备节点相关的数据指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SPARC)</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *path_component_name; <span class="comment">// 设备节点的路径组件名称</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> unique_id;          <span class="comment">// 设备节点的唯一标识</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">of_irq_controller</span> *<span class="title">irq_trans</span>;</span> <span class="comment">// 设备节点的中断控制器</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后对该结构体的重要参数进行讲解：</p>
<p>（1）name：name 字段表示设备节点的名称。设备节点的名称是在设备树中唯一标识该节点的字符串。它通常用于在设备树中引用设备节点。</p>
<p>（2）type：type 字段表示设备节点的类型。设备节点的类型提供了关于设备节点功能和所属设备类别的信息。它可以用于识别设备节点的用途和特性。</p>
<p>（3）properties：properties 字段是指向设备节点属性列表的指针。设备节点的属性包含了与设备节点相关联的配置和参数信息。属性以键值对的形式存在，可以提供设备的特定属性、寄存器地址、中断信息等。property字段同样定义在内核源码的“&#x2F;include&#x2F;linux&#x2F;of.h”文件中，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct property &#123;</span><br><span class="line">	char *name;                    // 属性的名称</span><br><span class="line">	int length;                    // 属性值的长度（字节数）</span><br><span class="line">	void *value;                   // 属性值的指针</span><br><span class="line">	struct property *next;         // 下一个属性节点指针</span><br><span class="line">#if defined(CONFIG_OF_DYNAMIC) || defined(CONFIG_SPARC)</span><br><span class="line">	unsigned long _flags;          // 属性的标志位</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_OF_PROMTREE)</span><br><span class="line">	unsigned int unique_id;        // 属性的唯一标识</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_OF_KOBJ)</span><br><span class="line">	struct bin_attribute attr;     // 内核对象二进制属性</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（4）parent：parent 字段指向父设备节点。设备树中的设备节点按照层次结构组织，父设备节点是当前设备节点的直接上级。通过 parent 字段，可以在设备树中遍历设备节点的父子关系。</p>
<p>（5）child：child 字段指向子设备节点。在设备树中，一个设备节点可以拥有多个子设备节点。通过 child 字段，可以遍历设备节点的所有子设备节点。</p>
<p>（6）sibling：sibling 字段指向兄弟设备节点。在设备树中，同一级别的兄弟设备节点共享相同的父设备节点。通过 sibling 字段，可以在同级设备节点之间进行遍历。</p>
<p>至此，关于device_node的结构体讲解就完成了，虽然我们现在知道了，dtb文件最终会展开成device_node这一可以让内核识别的格式，那更具体的实现流程是怎样的呢，让我们进入下一小节的学习吧。</p>
<h2 id="63-2-dtb解析过程源码分析"><a href="#63-2-dtb解析过程源码分析" class="headerlink" title="63.2 dtb解析过程源码分析"></a>63.2 dtb解析过程源码分析</h2><p>首先来到源码目录下的“&#x2F;init&#x2F;main.c”文件，找到其中的start_kernel 函数，start_kernel 函数是 Linux 内核启动的入口点，它是Linux内核的核心函数之一，负责完成内核的初始化和启动过程，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __init <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *command_line;</span><br><span class="line">    <span class="type">char</span> *after_dashes;</span><br><span class="line"></span><br><span class="line">    set_task_stack_end_magic(&amp;init_task);    <span class="comment">// 设置任务栈的魔数</span></span><br><span class="line">    smp_setup_processor_id();    <span class="comment">// 设置处理器ID</span></span><br><span class="line">    debug_objects_early_init();    <span class="comment">// 初始化调试对象</span></span><br><span class="line">    cgroup_init_early();    <span class="comment">// 初始化cgroup（控制组）</span></span><br><span class="line"></span><br><span class="line">    local_irq_disable();    <span class="comment">// 禁用本地中断</span></span><br><span class="line">    early_boot_irqs_disabled = <span class="literal">true</span>;     <span class="comment">// 标记早期引导期间中断已禁用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 中断仍然被禁用。进行必要的设置，然后启用它们。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    boot_cpu_init();    <span class="comment">// 初始化引导CPU</span></span><br><span class="line">    page_address_init();    <span class="comment">// 设置页地址</span></span><br><span class="line">    pr_notice(<span class="string">&quot;%s&quot;</span>, linux_banner);    <span class="comment">// 打印Linux内核版本信息</span></span><br><span class="line">    setup_arch(&amp;command_line);    <span class="comment">// 架构相关的初始化</span></span><br><span class="line">    mm_init_cpumask(&amp;init_mm);    <span class="comment">// 初始化内存管理的cpumask（CPU掩码）</span></span><br><span class="line">    setup_command_line(command_line);    <span class="comment">// 设置命令行参数</span></span><br><span class="line">    setup_nr_cpu_ids();    <span class="comment">// 设置CPU个数</span></span><br><span class="line">    setup_per_cpu_areas();    <span class="comment">// 设置每个CPU的区域</span></span><br><span class="line">    smp_prepare_boot_cpu();    <span class="comment">// 准备启动CPU（架构特定的启动CPU钩子）</span></span><br><span class="line">    boot_cpu_hotplug_init();    <span class="comment">// 初始化热插拔的引导CPU</span></span><br><span class="line"></span><br><span class="line">    build_all_zonelists(<span class="literal">NULL</span>);    <span class="comment">// 构建所有内存区域列表</span></span><br><span class="line">    page_alloc_init();    <span class="comment">// 初始化页面分配器</span></span><br><span class="line">	........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中跟设备树相关的函数为第20行的 setup_arch**(&amp;<strong>command_line</strong>);**该函数定义在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;setup.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">setup_arch</span><span class="params">(<span class="type">char</span> **cmdline_p)</span></span><br><span class="line">&#123;</span><br><span class="line">	init_mm.start_code = (<span class="type">unsigned</span> <span class="type">long</span>) _text;</span><br><span class="line">	init_mm.end_code   = (<span class="type">unsigned</span> <span class="type">long</span>) _etext;</span><br><span class="line">	init_mm.end_data   = (<span class="type">unsigned</span> <span class="type">long</span>) _edata;</span><br><span class="line">	init_mm.brk	   = (<span class="type">unsigned</span> <span class="type">long</span>) _end;</span><br><span class="line"></span><br><span class="line">	*cmdline_p = boot_command_line;</span><br><span class="line"></span><br><span class="line">	early_fixmap_init();    <span class="comment">// 初始化 early fixmap</span></span><br><span class="line">	early_ioremap_init();    <span class="comment">// 初始化 early ioremap</span></span><br><span class="line"></span><br><span class="line">	setup_machine_fdt(__fdt_pointer);    <span class="comment">// 设置机器的 FDT（平台设备树）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化静态密钥，早期可能会被 cpufeature 代码和早期参数启用</span></span><br><span class="line">	jump_label_init();</span><br><span class="line">	parse_early_param();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在启动可能的早期控制台后，解除屏蔽异步中断和 FIQ（一旦我们可以报告发生的系统错误）</span></span><br><span class="line">	local_daif_restore(DAIF_PROCCTX_NOIRQ);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在这个阶段，TTBR0仅用于身份映射。将其指向零页面，以避免做出猜测性的新条目获取。</span></span><br><span class="line">	cpu_uninstall_idmap();</span><br><span class="line"></span><br><span class="line">	xen_early_init();    <span class="comment">// Xen 平台的早期初始化</span></span><br><span class="line">	efi_init();    <span class="comment">// EFI 平台的初始化</span></span><br><span class="line">	arm64_memblock_init();    <span class="comment">// ARM64 内存块的初始化</span></span><br><span class="line"></span><br><span class="line">	paging_init();    <span class="comment">// 分页初始化</span></span><br><span class="line"></span><br><span class="line">	acpi_table_upgrade();    <span class="comment">// ACPI 表的升级</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析 ACPI 表以进行可能的引导时配置</span></span><br><span class="line">	acpi_boot_table_init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (acpi_disabled)</span><br><span class="line">		unflatten_device_tree();    <span class="comment">// 展开设备树</span></span><br><span class="line"></span><br><span class="line">	bootmem_init();    <span class="comment">// 引导内存的初始化</span></span><br><span class="line">	............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在setup_arch函数中与设备树相关的函数分别为第13行的setup_machine_fdt(__fdt_pointer)和第37行的unflatten_device_tree()，接下来将对上述两个函数进行详细的介绍。</p>
<h3 id="63-2-1-setup-machine-fdt-fdt-pointer"><a href="#63-2-1-setup-machine-fdt-fdt-pointer" class="headerlink" title="63.2.1 setup_machine_fdt(__fdt_pointer)"></a>63.2.1 setup_machine_fdt(__fdt_pointer)</h3><p>setup_machine_fdt(__fdt_pointer)中的__fdt_pointer是dtb二进制文件加载到内存的地址，该地址由bootloader启动kernel时透过x0寄存器传递过来的，具体的汇编代码在内核源码目录下的“&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;head.S”文件中，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">preserve_boot_args:</span><br><span class="line">	mov	x21, x0				// x21=FDT</span><br><span class="line"></span><br><span class="line">__primary_switched:</span><br><span class="line">	str_l	x21, __fdt_pointer, x5		// Save FDT pointer</span><br></pre></td></tr></table></figure>

<p>第2行: 将寄存器 x0 的值复制到寄存器 x21。x0 寄存器中保存了一个指针，该指针指向设备树（Device Tree）。</p>
<p>第4行: 将寄存器 x21 的值存储到内存地址 __fdt_pointer 中。</p>
<p>然后来看setup_machine_fdt函数，该函数定义在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;setup.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化设置机器的设备树</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">setup_machine_fdt</span><span class="params">(<span class="type">phys_addr_t</span> dt_phys)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 将设备树物理地址映射到内核虚拟地址空间</span></span><br><span class="line">    <span class="type">void</span> *dt_virt = fixmap_remap_fdt(dt_phys, &amp;size, PAGE_KERNEL);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果映射成功</span></span><br><span class="line">    <span class="keyword">if</span> (dt_virt) &#123;</span><br><span class="line">        <span class="comment">// 保留设备树占用的内存区域</span></span><br><span class="line">        memblock_reserve(dt_phys, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设备树映射失败或者设备树解析失败</span></span><br><span class="line">    <span class="keyword">if</span> (!dt_virt || !early_init_dt_scan(dt_virt)) &#123;</span><br><span class="line">        <span class="comment">// 输出错误信息</span></span><br><span class="line">		pr_crit(<span class="string">&quot;\n&quot;</span></span><br><span class="line">			<span class="string">&quot;Error: invalid device tree blob at physical address %pa (virtual address 0x%p)\n&quot;</span></span><br><span class="line">			<span class="string">&quot;The dtb must be 8-byte aligned and must not exceed 2 MB in size\n&quot;</span></span><br><span class="line">			<span class="string">&quot;\nPlease check your bootloader.&quot;</span>,</span><br><span class="line">			&amp;dt_phys, dt_virt);</span><br><span class="line">        <span class="comment">// 无限循环，等待系统崩溃</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            cpu_relax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 早期修复完成，将设备树映射为只读模式</span></span><br><span class="line">    fixmap_remap_fdt(dt_phys, &amp;size, PAGE_KERNEL_RO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取设备树的机器名</span></span><br><span class="line">    name = of_flat_dt_get_machine_name();</span><br><span class="line">    <span class="comment">// 如果设备树没有机器名，则返回</span></span><br><span class="line">    <span class="keyword">if</span> (!name)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	    pr_info(<span class="string">&quot;Machine model: %s\n&quot;</span>, name); <span class="comment">// 输出机器型号信息</span></span><br><span class="line">    dump_stack_set_arch_desc(<span class="string">&quot;%s (DT)&quot;</span>, name); <span class="comment">// 设置栈转储的架构描述为机器型号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数用于在内核启动过程中设置机器的设备树。在此函数中，将执行以下步骤： </p>
<p>1.使用 fixmap_remap_fdt() 将设备树映射到内核虚拟地址空间中的 fixmap 区域。 </p>
<p>2.如果映射成功，则使用 memblock_reserve() 保留设备树占用的物理内存区域。 </p>
<p>3.检查设备树的有效性和完整性，通过调用early_init_dt_scan()进行早期扫描。 如果设备树无效或扫描失败，则会输出错误信息并进入死循环。 </p>
<p>4.早期修复已完成，现在将设备树映射为只读，通过调用 fixmap_remap_fdt() 实现。</p>
<p>5.获取设备树中的机器模型名称，通过调用 of_flat_dt_get_machine_name()。</p>
<p>6.如果机器模型名称存在，则输出机器模型的信息，并通过 dump_stack_set_arch_desc() 设置堆栈描述信息。</p>
<p>其中上面的第3步调用的early_init_dt_scan() 需要详细的讲解一下，该函数定义在内核源码的“drivers&#x2F;of&#x2F;fdt.c”目录下，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> __init <span class="title function_">early_init_dt_scan</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证设备树的兼容性和完整性</span></span><br><span class="line">    status = early_init_dt_verify(params);</span><br><span class="line">    <span class="keyword">if</span> (!status)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描设备树节点</span></span><br><span class="line">    early_init_dt_scan_nodes();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，调用 early_init_dt_verify() 函数对设备树进行兼容性和完整性验证。该函数可能会检查设备树中的一致性标记、版本信息以及必需的节点和属性是否存在。如果验证失败，函数会返回 false。该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> __init <span class="title function_">early_init_dt_verify</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 验证传入的参数是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!params)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查设备树头部的有效性</span></span><br><span class="line">    <span class="comment">// 如果设备树头部无效，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (fdt_check_header(params))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置指向设备树的指针为传入的参数</span></span><br><span class="line">    initial_boot_params = params;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算设备树的 CRC32 校验值</span></span><br><span class="line">    <span class="comment">// 并将结果保存在全局变量 of_fdt_crc32 中</span></span><br><span class="line">    of_fdt_crc32 = crc32_be(~<span class="number">0</span>, initial_boot_params, fdt_totalsize(initial_boot_params));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 true，表示设备树验证和初始化成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第4行：该进行参数的有效性检查，如果 params 为空，则直接返回 false，表示参数无效。</p>
<p>第9行：检查设备树头部的有效性。fdt_check_header 是一个用于检查设备树头部的函数，如果设备树头部无效，则返回 false，表示设备树不合法。</p>
<p>第13行：如果设备树头部有效，程序继续执行，将传入的 params 赋值给全局变量 initial_boot_params，用来保存设备树的指针。</p>
<p>第17行，使用 crc32_be 函数计算设备树的 CRC32 校验值，其中 crc32_be 是一个用于计算 CRC32 校验值的函数，~0 表示初始值为全1的位模式。计算完成后，将结果保存在全局变量 of_fdt_crc32 中。</p>
<p>然后继续回到early_init_dt_scan() 函数中，如果设备树验证成功（即 status 为真），则调用 early_init_dt_scan_nodes() 函数。这个函数的作用是扫描设备树的节点并进行相应的处理，该函数的具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void __init early_init_dt_scan_nodes(void)</span><br><span class="line">&#123;</span><br><span class="line">	/* 从 /chosen 节点中检索各种信息 */</span><br><span class="line">	of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);</span><br><span class="line"></span><br><span class="line">	/* 初始化 &#123;size,address&#125;-cells 信息 */</span><br><span class="line">	of_scan_flat_dt(early_init_dt_scan_root, NULL);</span><br><span class="line"></span><br><span class="line">	/* 设置内存信息，调用 early_init_dt_add_memory_arch 函数 */</span><br><span class="line">	of_scan_flat_dt(early_init_dt_scan_memory, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数early_init_dt_scan_nodes被声明为__init，这表示它是在内核初始化阶段被调用，并且在初始化完成后不再需要。该函数的目的是在早期阶段扫描设备树节点，并执行一些初始化操作。</p>
<p>函数中主要调用了of_scan_flat_dt函数，该函数用于扫描平面设备树（flat device tree）。平面设备树是一种将设备树以紧凑形式表示的数据结构，它不使用树状结构，而是使用线性结构，以节省内存空间。</p>
<p>具体来看，early_init_dt_scan_nodes函数的执行步骤如下：</p>
<p>（1）of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line)：从设备树的&#x2F;chosen节点中检索各种信息。&#x2F;chosen节点通常包含了一些系统的全局配置参数，比如命令行参数。early_init_dt_scan_chosen是一个回调函数，用于处理&#x2F;chosen节点的信息。boot_command_line是一个参数，表示内核启动时的命令行参数。</p>
<p>（2）of_scan_flat_dt(early_init_dt_scan_root, NULL)：初始化{size,address}-cells信息。{size,address}-cells描述了设备节点中地址和大小的编码方式。early_init_dt_scan_root是一个回调函数，用于处理设备树的根节点。</p>
<p>（3）of_scan_flat_dt(early_init_dt_scan_memory, NULL)：设置内存信息，并调用early_init_dt_add_memory_arch函数。这个步骤主要用于在设备树中获取内存的相关信息，并将其传递给内核的内存管理模块。early_init_dt_scan_memory是一个回调函数，用于处理内存信息。</p>
<p>至此，关于setup_machine_fdt(__fdt_pointer)代码的分析就完成了。</p>
<h3 id="63-2-2-unflatten-device-tree"><a href="#63-2-2-unflatten-device-tree" class="headerlink" title="63.2.2 unflatten_device_tree"></a>63.2.2 unflatten_device_tree</h3><p>该函数用于解析设备树，将紧凑的设备树数据结构转换为树状结构的设备树，该函数定义在内核源码目录下的“&#x2F;drivers&#x2F;of&#x2F;fdt.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">unflatten_device_tree</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 解析设备树 */</span></span><br><span class="line">    __unflatten_device_tree(initial_boot_params, <span class="literal">NULL</span>, &amp;of_root,</span><br><span class="line">                            early_init_dt_alloc_memory_arch, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取指向 &quot;/chosen&quot; 和 &quot;/aliases&quot; 节点的指针，以供全局使用 */</span></span><br><span class="line">    of_alias_scan(early_init_dt_alloc_memory_arch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 运行设备树的单元测试 */</span></span><br><span class="line">    unittest_unflatten_overlay_base();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数主要用于解析设备树，并将解析后的设备树存储在全局变量of_root中。</p>
<p>函数首先调用__unflatten_device_tree函数来执行设备树的解析操作。解析后的设备树将使用of_root指针进行存储。</p>
<p>接下来，函数调用of_alias_scan函数。这个函数用于扫描设备树中的&#x2F;chosen和&#x2F;aliases节点，并为它们分配内存。这样，其他部分的代码可以通过全局变量访问这些节点。</p>
<p>最后，函数调用unittest_unflatten_overlay_base函数，用于运行设备树的单元测试。</p>
<p>然后对__unflatten_device_tree这一设备树的解析函数进行详细的介绍，该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *__unflatten_device_tree(<span class="type">const</span> <span class="type">void</span> *blob,</span><br><span class="line">		      <span class="keyword">struct</span> device_node *dad,</span><br><span class="line">			      <span class="keyword">struct</span> device_node **mynodes,</span><br><span class="line">			      <span class="type">void</span> *(*dt_alloc)(u64 size, u64 align),</span><br><span class="line">			      <span class="type">bool</span> detached)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	<span class="type">void</span> *mem;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot; -&gt; unflatten_device_tree()\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!blob) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;No device tree pointer\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;Unflattening device tree:\n&quot;</span>);</span><br><span class="line">	pr_debug(<span class="string">&quot;magic: %08x\n&quot;</span>, fdt_magic(blob));</span><br><span class="line">	pr_debug(<span class="string">&quot;size: %08x\n&quot;</span>, fdt_totalsize(blob));</span><br><span class="line">	pr_debug(<span class="string">&quot;version: %08x\n&quot;</span>, fdt_version(blob));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fdt_check_header(blob)) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;Invalid device tree blob header\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 第一遍扫描，计算大小 */</span></span><br><span class="line">	size = unflatten_dt_nodes(blob, <span class="literal">NULL</span>, dad, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (size &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	size = ALIGN(size, <span class="number">4</span>);</span><br><span class="line">	pr_debug(<span class="string">&quot;  大小为 %d，正在分配内存...\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 为展开的设备树分配内存 */</span></span><br><span class="line">	mem = dt_alloc(size + <span class="number">4</span>, <span class="keyword">alignof</span>(<span class="keyword">struct</span> device_node));</span><br><span class="line">	<span class="keyword">if</span> (!mem)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(mem, <span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line">	*(__be32 *)(mem + size) = cpu_to_be32(<span class="number">0xdeadbeef</span>);</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;  正在展开 %p...\n&quot;</span>, mem);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 第二遍扫描，实际展开设备树 */</span></span><br><span class="line">	unflatten_dt_nodes(blob, mem, dad, mynodes);</span><br><span class="line">	<span class="keyword">if</span> (be32_to_cpup(mem + size) != <span class="number">0xdeadbeef</span>)</span><br><span class="line">		pr_warning(<span class="string">&quot;End of tree marker overwritten: %08x\n&quot;</span>,</span><br><span class="line">			   be32_to_cpup(mem + size));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (detached &amp;&amp; mynodes) &#123;</span><br><span class="line">		of_node_set_flag(*mynodes, OF_DETACHED);</span><br><span class="line">		pr_debug(<span class="string">&quot;unflattened tree is detached\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot; &lt;- unflatten_device_tree()\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的重点在两次设备树的扫描上，第一遍扫描的目的是计算展开设备树所需的内存大小。</p>
<p>第29行：unflatten_dt_nodes函数的作用是递归地遍历设备树数据块，并计算展开设备树所需的内存大小。它接受四个参数：blob（设备树数据块指针）、start（当前节点的起始地址，初始为NULL）、dad（父节点指针）和mynodes（用于存储节点指针数组的指针，初始为NULL）。</p>
<p>第一遍扫描完成后，unflatten_dt_nodes函数会返回展开设备树所需的内存大小，然后在对大小进行对齐操作，并为展开的设备树分配内存。</p>
<p>第二遍扫描的目的是实际展开设备树，并填充设备节点的名称、类型和属性等信息。</p>
<p>第49行：再次调用了unflatten_dt_nodes函数进行第二遍扫描。通过这样的过程，第二遍扫描会将设备树数据块中的节点展开为真正的设备节点，并填充节点的名称、类型和属性等信息。这样就完成了设备树的展开过程。</p>
<p>最后我们来对unflatten_dt_nodes函数内容进行一下深究，unflatten_dt_nodes函数具体定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">unflatten_dt_nodes</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *blob,</span></span><br><span class="line"><span class="params">			      <span class="type">void</span> *mem,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> device_node *dad,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> device_node **nodepp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">root</span>;</span>  <span class="comment">// 根节点</span></span><br><span class="line">	<span class="type">int</span> offset = <span class="number">0</span>, depth = <span class="number">0</span>, initial_depth = <span class="number">0</span>;  <span class="comment">// 偏移量、深度和初始深度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_MAX_DEPTH	64  <span class="comment">// 最大深度</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nps</span>[<span class="title">FDT_MAX_DEPTH</span>];</span>  <span class="comment">// 设备节点数组</span></span><br><span class="line">	<span class="type">void</span> *base = mem;  <span class="comment">// 基地址，用于计算偏移量</span></span><br><span class="line">	<span class="type">bool</span> dryrun = !base;  <span class="comment">// 是否只是模拟运行，不实际处理</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nodepp)</span><br><span class="line">		*nodepp = <span class="literal">NULL</span>;  <span class="comment">// 如果指针不为空，将其置为空指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果 @dad 有效，则表示正在展开设备子树。</span></span><br><span class="line"><span class="comment">	 * 在第一层深度可能有多个节点。</span></span><br><span class="line"><span class="comment">	 * 将 @depth 设置为 1，以使 fdt_next_node() 正常工作。</span></span><br><span class="line"><span class="comment">	 * 当发现负的 @depth 时，该函数会立即退出。</span></span><br><span class="line"><span class="comment">	 * 否则，除第一个节点外的设备节点将无法成功展开。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dad)</span><br><span class="line">		depth = initial_depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	root = dad;  <span class="comment">// 根节点为 @dad</span></span><br><span class="line">	nps[depth] = dad;  <span class="comment">// 将根节点放入设备节点数组</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (offset = <span class="number">0</span>;</span><br><span class="line">	     offset &gt;= <span class="number">0</span> &amp;&amp; depth &gt;= initial_depth;</span><br><span class="line">	     offset = fdt_next_node(blob, offset, &amp;depth)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(depth &gt;= FDT_MAX_DEPTH))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果未启用 CONFIG_OF_KOBJ 并且节点不可用，则跳过该节点</span></span><br><span class="line">		<span class="keyword">if</span> (!IS_ENABLED(CONFIG_OF_KOBJ) &amp;&amp;</span><br><span class="line">		    !of_fdt_device_is_available(blob, offset))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 填充节点信息，并将子节点添加到设备节点数组</span></span><br><span class="line">		<span class="keyword">if</span> (!populate_node(blob, offset, &amp;mem, nps[depth],</span><br><span class="line">				   &amp;nps[depth+<span class="number">1</span>], dryrun))</span><br><span class="line">			<span class="keyword">return</span> mem - base;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!dryrun &amp;&amp; nodepp &amp;&amp; !*nodepp)</span><br><span class="line">			*nodepp = nps[depth+<span class="number">1</span>];  <span class="comment">// 将子节点指针赋值给 @nodepp</span></span><br><span class="line">		<span class="keyword">if</span> (!dryrun &amp;&amp; !root)</span><br><span class="line">			root = nps[depth+<span class="number">1</span>];  <span class="comment">// 如果根节点为空，则将子节点设置为根节点</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset &lt; <span class="number">0</span> &amp;&amp; offset != -FDT_ERR_NOTFOUND) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;Error %d processing FDT\n&quot;</span>, offset);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 反转子节点列表。一些驱动程序假设节点顺序与 .dts 文件中的节点顺序一致</span></span><br><span class="line">	<span class="keyword">if</span> (!dryrun)</span><br><span class="line">		reverse_nodes(root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mem - base;  <span class="comment">// 返回处理的字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unflatten_dt_nodes 函数的作用我们在上面已经讲解过了，这里重点介绍第31行的 fdt_next_node()函数和第41行的populate_node函数。</p>
<p>fdt_next_node() 函数用来遍历设备树的节点。从偏移量为 0 开始，只要偏移量大于等于 0 且深度大于等于初始深度，就执行循环。循环中的每次迭代都会处理一个设备树节点。</p>
<p>在每次迭代中，首先检查深度是否超过了最大深度 FDT_MAX_DEPTH，如果超过了，则跳过该节点。</p>
<p>如果未启用 CONFIG_OF_KOBJ 并且节点不可用（通过 of_fdt_device_is_available() 函数判断），则跳过该节点。</p>
<p>随后调用 populate_node() 函数填充节点信息，并将子节点添加到设备节点数组 nps 中。 populate_node() 函数定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static bool populate_node(const void *blob,</span><br><span class="line">			  int offset,</span><br><span class="line">			  void **mem,</span><br><span class="line">			  struct device_node *dad,</span><br><span class="line">			  struct device_node **pnp,</span><br><span class="line">			  bool dryrun)</span><br><span class="line">&#123;</span><br><span class="line">	struct device_node *np;  // 设备节点指针</span><br><span class="line">	const char *pathp;  // 节点路径字符串指针</span><br><span class="line">	unsigned int l, allocl;  // 路径字符串长度和分配的内存大小</span><br><span class="line"></span><br><span class="line">	pathp = fdt_get_name(blob, offset, &amp;l);  // 获取节点路径和长度</span><br><span class="line">	if (!pathp) &#123;</span><br><span class="line">		*pnp = NULL;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	allocl = ++l;  // 分配内存大小为路径长度加一，用于存储节点路径字符串</span><br><span class="line"></span><br><span class="line">	np = unflatten_dt_alloc(mem, sizeof(struct device_node) + allocl,</span><br><span class="line">				__alignof__(struct device_node));  // 分配设备节点内存</span><br><span class="line">	if (!dryrun) &#123;</span><br><span class="line">		char *fn;</span><br><span class="line">		of_node_init(np);  // 初始化设备节点</span><br><span class="line">		np-&gt;full_name = fn = ((char *)np) + sizeof(*np);  // 设置设备节点的完整路径名</span><br><span class="line"></span><br><span class="line">		memcpy(fn, pathp, l);  // 将节点路径字符串复制到设备节点的完整路径名中</span><br><span class="line"></span><br><span class="line">		if (dad != NULL) &#123;</span><br><span class="line">			np-&gt;parent = dad;  // 设置设备节点的父节点</span><br><span class="line">			np-&gt;sibling = dad-&gt;child;  // 设置设备节点的兄弟节点</span><br><span class="line">			dad-&gt;child = np;  // 将设备节点添加为父节点的子节点</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	populate_properties(blob, offset, mem, np, pathp, dryrun);  // 填充设备节点的属性信息</span><br><span class="line">	if (!dryrun) &#123;</span><br><span class="line">		np-&gt;name = of_get_property(np, &quot;name&quot;, NULL);  // 获取设备节点的名称属性</span><br><span class="line">		np-&gt;type = of_get_property(np, &quot;device_type&quot;, NULL);  // 获取设备节点的设备类型属性</span><br><span class="line"></span><br><span class="line">		if (!np-&gt;name)</span><br><span class="line">			np-&gt;name = &quot;&lt;NULL&gt;&quot;;  // 如果设备节点没有名称属性，则设置为&quot;&lt;NULL&gt;&quot;</span><br><span class="line">		if (!np-&gt;type)</span><br><span class="line">			np-&gt;type = &quot;&lt;NULL&gt;&quot;;  // 如果设备节点没有设备类型属性，则设置为&quot;&lt;NULL&gt;&quot;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*pnp = np;  // 将设备节点指针赋值给*pnp</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在populate_node 函数中首先会调用第18行的 unflatten_dt_alloc 函数分配设备节点内存。分配的内存大小为 sizeof(struct device_node) + allocl 字节，并使用 <strong>alignof</strong>(struct device_node) 对齐。然后调用 populate_properties 函数填充设备节点的属性信息。该函数会解析设备节点的属性，并根据需要分配内存来存储属性值。</p>
<p>至此，关于dtb二进制文件的解析过程就讲解完成了，完整的源码分析流程图如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024648.jpeg" alt="img"></p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-62-dtb文件格式讲解</title>
    <url>/2023/09/05/1-62-dtb%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第62章-dtb文件格式讲解"><a href="#第62章-dtb文件格式讲解" class="headerlink" title="第62章 dtb文件格式讲解"></a>第62章 dtb文件格式讲解</h1><p>设备树 Blob (DTB) 格式是设备树数据的平面二进制编码。它用于在软件程序之间交换设备树数据。例如，在启动操作系统时，固件会将 DTB 传递给操作系统内核。</p>
<p>DTB 格式在单个、线性、无指针数据结构中对设备树数据进行编码。它由一个小头部和三个可变大小的部分组成：内存保留块、结构块和字符串块。这些应该以该顺序出现在展平的设备树中。因此，设备树结构作为一个整体，当加载到内存地址时，将类似于下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022286.jpeg" alt="img"> </p>
<p>本节课将以下面的设备树为例对设备树的二进制文件格式进行讲解：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = <span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0, 115200&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a35&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x1</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    aliases &#123;</span><br><span class="line">        led1 = <span class="string">&quot;/gpio@22020101&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node1 &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">        gpio@<span class="number">22020102</span> &#123;</span><br><span class="line">            reg = &lt;<span class="number">0x20220102</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node2 &#123;</span><br><span class="line">        node1-child &#123;</span><br><span class="line">            pinnum = &lt;<span class="number">01234</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@<span class="number">22020101</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;led&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x20220101</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而我们之后要分析的是二进制的dtb文件，所以需要使用dtc工具将上面的dts文件编译成dtb文件，具体命令如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022423.jpeg" alt="img"> </p>
<p>为了方便用户学习，已经将本章节要讲解的设备树dts文件和dtb文件放在了对应的网盘路径下，同时也将pxBinaryViewerSetup二进制分析软件放在了同一目录下，iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\49_dt_format，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022265.jpeg" alt="img"> </p>
<p>使用二进制分析软件打开deb文件并设置大端模式之后如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022400.jpeg" alt="img"></p>
<p>在接下来的小节中将会对读取出的设备树二进制内容进行讲解。</p>
<h2 id="62-1-Header"><a href="#62-1-Header" class="headerlink" title="62.1 Header"></a>62.1 Header</h2><p>devicetree 的头布局由以下 C 结构定义。所有的头字段都是 32 位整数，以大端格式存储。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct fdt_header &#123;</span><br><span class="line">    uint32_t magic;                 // 设备树头部的魔数</span><br><span class="line">    uint32_t totalsize;             // 设备树文件的总大小</span><br><span class="line">    uint32_t off_dt_struct;         // 设备树结构体（节点数据）相对于文件开头的偏移量</span><br><span class="line">    uint32_t off_dt_strings;        // 设备树字符串表相对于文件开头的偏移量</span><br><span class="line">    uint32_t off_mem_rsvmap;        // 内存保留映射表相对于文件开头的偏移量</span><br><span class="line">    uint32_t version;               // 设备树版本号</span><br><span class="line">    uint32_t last_comp_version;     // 最后一个兼容版本号</span><br><span class="line">    uint32_t boot_cpuid_phys;       // 启动 CPU 的物理 ID</span><br><span class="line">    uint32_t size_dt_strings;       // 设备树字符串表的大小</span><br><span class="line">    uint32_t size_dt_struct;        // 设备树结构体（节点数据）的大小</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个字段的描述如下所示：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>magic</td>
<td>该字段为固定值 0xd00dfeed（大端）。</td>
</tr>
<tr>
<td>totalsize</td>
<td>该字段包含设备树数据结构的总大小（以字节为单位）。此大小应包含结构的所有部分：标题、内存保留块、结构块和字符串块，以及块之间或最后一个块之后的任何空闲空间间隙。</td>
</tr>
<tr>
<td>off_dt_struct</td>
<td>该字段包含结构块从头开始的以字节为单位的偏移量。</td>
</tr>
<tr>
<td>off_dt_strings</td>
<td>该字段包含字符串块从头开始的以字节为单位的偏移量。</td>
</tr>
<tr>
<td>off_mem_rsvmap</td>
<td>该字段包含从头开始的内存保留块的字节偏移量。</td>
</tr>
<tr>
<td>version</td>
<td>该字段包含设备树数据结构的版本。</td>
</tr>
<tr>
<td>last_comp_version</td>
<td>向后兼容的设备树数据结构的最低版本。</td>
</tr>
<tr>
<td>boot_cpuid_phys</td>
<td>与设备树CPU 节点的reg属性对应</td>
</tr>
<tr>
<td>size_dt_strings</td>
<td>设备树字符串块部分的字节长度。</td>
</tr>
<tr>
<td>size_dt_struct</td>
<td>设备树结构块部分的字节长度。</td>
</tr>
</tbody></table>
<p>然后来查看二进制文件，其中4个字节表示一个单位，前十个单位分别代表上述的十个字段如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022323.jpeg" alt="img"> </p>
<table>
<thead>
<tr>
<th>字段</th>
<th>十六进制数值</th>
<th>代表含义</th>
</tr>
</thead>
<tbody><tr>
<td>magic</td>
<td>D00DFEED</td>
<td>固定值</td>
</tr>
<tr>
<td>totalsize</td>
<td>000002A4</td>
<td>转换为十进制之后为676，表示该文件大小为676字节</td>
</tr>
<tr>
<td>off_dt_struct</td>
<td>00000038</td>
<td>表示结构块从00000038这个地址开始，和后面的size_dt_struct结构块大小参数一起可以确定结构块的存储范围</td>
</tr>
<tr>
<td>off_dt_strings</td>
<td>0000024C</td>
<td>表示字符串块从0000024C这个地址开始，和后面的size_dt_strings字符串块大小参数一起可以确定字符串块的存储范围</td>
</tr>
<tr>
<td>off_mem_rsvmap</td>
<td>00000028</td>
<td>表示内存保留块的偏移为00000028， header之后结构快之前都是属于内存保留块。</td>
</tr>
<tr>
<td>version</td>
<td>00000011</td>
<td>11转换为十进制之后为17，表示当前设备树结构版本为17</td>
</tr>
<tr>
<td>last_comp_version</td>
<td>00000010</td>
<td>10转换为十进制之后为16，表示向前兼容的设备树结构版本为16</td>
</tr>
<tr>
<td>boot_cpuid_phys</td>
<td>00000000</td>
<td>表示设备树的teg属性为0</td>
</tr>
<tr>
<td>size_dt_strings</td>
<td>00000058</td>
<td>表示字符串块的大小为00000058 ，和前面的off_dt_strings字符串块偏移值一起可以确定字符串块的范围</td>
</tr>
<tr>
<td>size_dt_struct</td>
<td>00000214</td>
<td>表示结构块的大小为00000214，和前面的off_dt_struct结构块偏移值一起可以确定结构块的范围</td>
</tr>
</tbody></table>
<p>在接下来的小节中将会对header提到的内存保留块、结构块和字符串块进行更详细的讲解。</p>
<h2 id="62-2-内存保留块"><a href="#62-2-内存保留块" class="headerlink" title="62.2 内存保留块"></a>62.2 内存保留块</h2><p>内存保留块（Memory Reserved Block）是用于客户端程序的保护和保留物理内存区域的列表。这些保留区域不应被用于一般的内存分配，而是用于保护重要数据结构，以防止客户端程序覆盖这些数据。内存保留块的目的是确保特定的内存区域在客户端程序运行时不被修改或使用。由于在示例设备树中没有设置内存保留块，所以相应的区域都为0，如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022259.jpeg" alt="img"> </p>
<p><strong>保留区域列表：</strong> 内存保留块是一个由一组 64 位大端整数对构成的列表。每对整数对应一个保留内存区域，其中包含物理地址和区域的大小（以字节为单位）。这些保留区域应该彼此不重叠。</p>
<p><strong>保留区域的用途：</strong>客户端程序不应访问内存保留块中的保留区域，除非引导程序提供的其他信息明确指示可以访问。引导程序可以使用特定的方式来指示客户端程序可以访问保留内存的部分内容。引导程序可能会在文档、可选的扩展或特定于平台的文档中说明保留内存的特定用途。</p>
<p><strong>格式：</strong>内存保留块中的每个保留区域由一个64位大端整数对表示。每对由以下 C 结构表示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct fdt_reserve_entry &#123; </span><br><span class="line">	uint64_t address; </span><br><span class="line">	uint64_t size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的第一个整数表示保留区域的物理地址，第二个整数表示保留区域的大小（以字节为单位）。每个整数都以 64 位的形式表示，即使在32位架构上也是如此。在32位CPU上，整数的高 32 位将被忽略。</p>
<p>内存保留块为设备树提供了保护和保留物理内存区域的功能。它确保了特定的内存区域在客户端程序运行时不被修改或使用。这样可以确保引导程序和其他关键组件在需要的情况下能够访问保留内存的特定部分，并保护关键数据结构免受意外修改。</p>
<h2 id="62-3-结构快"><a href="#62-3-结构快" class="headerlink" title="62.3 结构快"></a>62.3 结构快</h2><p>结构块是设备树中描述设备树本身结构和内容的部分。它由一系列带有数据的令牌序列组成，这些令牌按照线性树结构进行组织。</p>
<p><strong>（1）令牌类型</strong></p>
<p> 结构块中的令牌分为五种类型，每种类型用于不同的目的。</p>
<p>a. FDT_BEGIN_NODE (0x00000001): FDT_BEGIN_NODE 标记表示一个节点的开始。它后面跟着节点的单元名称作为额外数据。节点名称以以空字符结尾的字符串形式存储，并且可以包括单元地址。节点名称后可能需要填充零字节以对齐，然后是下一个标记，可以是除了 FDT_END 之外的任何标记。</p>
<p>b. FDT_END_NODE (0x00000002): FDT_END_NODE 标记表示一个节点的结束。该标记没有额外的数据，紧随其后的是下一个标记，可以是除了 FDT_PROP 之外的任何标记。</p>
<p>c. FDT_PROP (0x00000003): FDT_PROP 标记表示设备树中属性的开始。它后面跟着描述属性的额外数据，该数据首先由属性的长度和名称组成，表示为以下 C 结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">	uint32_t len; </span><br><span class="line">	uint32_t nameoff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>长度表示属性值的字节长度，名称偏移量指向字符串块中存储属性名称的位置。在这个结构之后，属性的值作为字节字符串给出。属性值后可能需要填充零字节以对齐，然后是下一个令牌，可以是除了 FDT_END 之外的任何标记。</p>
<p>d. FDT_NOP (0x00000004): FDT_NOP 令牌可以被解析设备树的程序忽略。该令牌没有额外的数据，紧随其后的是下一个令牌，可以是任何有效的令牌。使用 FDT_NOP 令牌可以覆盖树中的属性或节点定义，从而将其从树中删除，而无需移动设备树 blob 中的其他部分。</p>
<p>e. FDT_END (0x00000009): FDT_END 标记表示结构块的结束。应该只有一个 FDT_END 标记，并且应该是结构块中的最后一个标记。该标记没有额外的数据，紧随其后的字节应该位于结构块的开头偏移处，该偏移等于设备树 blob 标头中的 size_dt_struct 字段的值。</p>
<p><strong>（2）树状结构：</strong></p>
<p>设备树的结构以线性树的形式表示。每个节点由 FDT_BEGIN_NODE 标记开始，由 FDT_END_NODE 标记结束。节点的属性和子节点在 FDT_END_NODE 之前表示，因此子节点的 FDT_BEGIN_NODE 和 FDT_END_NODE 令牌嵌套在父节点的令牌中。</p>
<p><strong>（3）结构块的结束</strong></p>
<p>结构块以单个 FDT_END 标记结束。该标记没有额外的数据，它位于结构块的末尾，并且是结构块中的最后一个标记。FDT_END 标记之后的字节应位于结构块的开头偏移处，该偏移等于设备树 blob 标头中的 size_dt_struct 字段的值。</p>
<p>最后对结构块开头的部分内容进行讲解，具体内容如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022678.jpeg" alt="img"> </p>
<table>
<thead>
<tr>
<th>十六进制数值</th>
<th>代表含义</th>
</tr>
</thead>
<tbody><tr>
<td>00000001</td>
<td>根节点的开始</td>
</tr>
<tr>
<td>00000000</td>
<td>根节点没有节点名，所以这里名字为0</td>
</tr>
<tr>
<td>00000003</td>
<td>设备树中属性的开始</td>
</tr>
<tr>
<td>00000017</td>
<td>代表该属性的大小，换算成十进制为23，也就是”This is my devicetree!”这一字符串的长度</td>
</tr>
<tr>
<td>00000000</td>
<td>代表该属性在字符串块的偏移量，这里为0，表示无偏移</td>
</tr>
<tr>
<td>54686973-65210000</td>
<td>model的具体值</td>
</tr>
</tbody></table>
<p>通过使用结构块，设备树可以以一种层次化的方式组织和描述系统中的设备和资源。每个节点可以包含属性和子节点，从而实现更加灵活和可扩展的设备树表示。</p>
<h2 id="62-4-字符串块"><a href="#62-4-字符串块" class="headerlink" title="62.4 字符串块"></a>62.4 字符串块</h2><p>字符串块用于存储设备树中使用的所有属性名称。它由一系列以空字符结尾的字符串组成，这些字符串在字符串块中简单地连接在一起，具体示例如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022711.jpeg" alt="img"> </p>
<p><strong>（1）字符串连接：</strong></p>
<p> 字符串块中的字符串以空字符（\0）作为终止符来连接。这意味着每个字符串都以空字符结尾，并且下一个字符串紧跟在上一个字符串的末尾。这种连接方式使得字符串块中的所有字符串形成一个连续的字符序列。</p>
<p><strong>（2）偏移量引用：</strong></p>
<p>在结构块中，属性的名称是通过偏移量来引用字符串块中的相应字符串的。偏移量是一个无符号整数值，它表示字符串在字符串块中的位置。通过使用偏移量引用，设备树可以节省空间，并且在属性名称发生变化时也更加灵活，因为只需要更新偏移量，而不需要修改结构块中的属性引用。</p>
<p><strong>（3）对齐约束：</strong></p>
<p>字符串块没有对齐约束，这意味着它可以出现在设备树 blob 的任何偏移处。这使得字符串块的位置在设备树 blob 中是灵活的，并且可以根据需要进行调整，而不会对设备树的解析和处理造成影响。</p>
<p>字符串块是设备树中用于存储属性名称的部分。它由字符串连接而成，并通过偏移量在结构块中进行引用。字符串块的灵活位置使得设备树的表示更加紧凑和可扩展。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-61-实例分析: pinctrl</title>
    <url>/2023/09/05/1-61-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-pinctrl/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第61章-实例分析：pinctrl"><a href="#第61章-实例分析：pinctrl" class="headerlink" title="第61章 实例分析：pinctrl"></a>第61章 实例分析：pinctrl</h1><h2 id="61-1-pinmux-介绍"><a href="#61-1-pinmux-介绍" class="headerlink" title="61.1 pinmux 介绍"></a>61.1 pinmux 介绍</h2><p>Pinmux（引脚复用）是指在系统中配置和管理引脚功能的过程。在许多现代集成电路中，单个引脚可以具有多个功能，例如作为 GPIO、UART、SPI 或 I2C 等。通过使用引脚复用功能，可以在这些不同的功能之间切换。</p>
<p>引脚复用通过硬件和软件的方式实现。硬件层面，芯片设计会为每个引脚提供多个功能的选择。这些功能通常由芯片厂商在芯片规格文档中定义。通过编程设置寄存器或开关，可以选择某个功能来连接引脚。这种硬件层面的配置通常是由引脚控制器（Pin Controller）或引脚复用控制器（Pin Mux Controller）负责管理。</p>
<p>软件层面，操作系统或设备驱动程序需要了解和配置引脚的功能。它们使用设备树（Device Tree）或设备树绑定（Device Tree Bindings）来描述和配置引脚的功能。在设备树中，可以指定引脚的复用功能，将其连接到特定的硬件接口或功能。操作系统或设备驱动程序在启动过程中解析设备树，并根据配置对引脚进行初始化和设置。</p>
<p>那我们要怎样知晓每一个管脚都可以复用成什么功能呢，一般在核心板原理图都会标注出每个管脚的复用功能，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022792.jpeg" alt="img"> </p>
<p>从上图可以看到UART4_RX_M1对应的引脚可以复用为以下6个功能LCDC_D16、VOP_BT1120_D7、GMAC1_RXD0_M0、UART4_RX_M1、PWM8_M0、GPIO3_B1_d，对应的BGA引脚标号为AG1,那这里的AG1是如何定位的呢。</p>
<p>在 BGA（Ball Grid Array，球栅阵列）封装中，引脚标号是用于唯一标识每个引脚的标识符。这些标号通常由芯片制造商定义，并在芯片的规格文档或数据手册中提供。</p>
<p>BGA 芯片的引脚标号通常由字母和数字的组合构成。它们用于在芯片的封装底部的焊盘上进行标记。每个引脚标号都与芯片内部的功能或信号相对应，以便正确连接到印刷电路板（PCB）上的目标位置。RK3568的引脚标号图如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022868.jpeg" alt="img"> </p>
<p>可以看到纵向为A-AH的28个字母类型标号，横向为1-28的28个字母类型标号，瑞芯微也在对应的3568数据手册中加入了根据BGA位置制作的复用功能图，部分内容如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022855.jpeg" alt="img"> </p>
<p>其中黑色框代表被保留的引脚，其他有颜色的框一般为电源和地，白色的框代表有具体复用功能的引脚。</p>
<p>脚复用提高了芯片的灵活性和可重用性，通过允许同一个引脚在不同的功能之间切换，可以减少硬件设计的复杂性和成本。此外，引脚复用还使得在使用相同芯片的不同应用中可以更加灵活地配置和定制引脚功能。</p>
<p>会在下一个小节中讲解如何使用pinctrl在设备树中配置引脚的复用。</p>
<h2 id="61-2-使用pinctrl设置复用关系"><a href="#61-2-使用pinctrl设置复用关系" class="headerlink" title="61.2 使用pinctrl设置复用关系"></a>61.2 使用pinctrl设置复用关系</h2><p>pinctrl（引脚控制）用于描述和配置硬件设备上的引脚功能和连接方式。它是设备树的一部分，用于在启动过程中传递引脚配置信息给操作系统和设备驱动程序，以便正确地初始化和控制引脚。</p>
<p>在设备树中，pinctrl（引脚控制）使用了客户端和服务端的概念来描述引脚控制的关系和配置。</p>
<h3 id="61-2-1-客户端-Client"><a href="#61-2-1-客户端-Client" class="headerlink" title="61.2.1 客户端(Client)"></a>61.2.1 客户端(Client)</h3><p>接下来将使用三个例子对客户端要用到的属性进行讲解。</p>
<p>例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node &#123;</span><br><span class="line">    pinctrl-names = &quot;default&quot;;</span><br><span class="line">    pinctrl-0 = &lt;&amp;pinctrl_hog_1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在例1中，pinctrl-names 属性定义了一个状态名称：default。</p>
<p>pinctrl-0 属性指定了第一个状态 default 对应的引脚配置。</p>
<p>&lt;&amp;pinctrl_hog_1&gt; 是一个引脚描述符，它引用了一个名为 pinctrl_hog_1 的引脚控制器节点。这表示在 default 状态下，设备的引脚配置将使用 pinctrl_hog_1 节点中定义的配置。</p>
<p>例2：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">node &#123;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>, <span class="string">&quot;wake up&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_hog_1&gt;;</span><br><span class="line">    pinctrl<span class="number">-1</span> = &lt;&amp;pinctrl_hog_2&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在例2中，pinctrl-names 属性定义了两个状态名称：default 和 wake up。</p>
<p>pinctrl-0 属性指定了第一个状态 default 对应的引脚配置，引用了 pinctrl_hog_1 节点。</p>
<p>pinctrl-1 属性指定了第二个状态 wake up 对应的引脚配置，引用了 pinctrl_hog_2 节点。</p>
<p>这意味着设备可以处于两个不同的状态之一，每个状态分别使用不同的引脚配置。</p>
<p>例3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node &#123;</span><br><span class="line">    pinctrl-names = &quot;default&quot;;</span><br><span class="line">    pinctrl-0 = &lt;&amp;pinctrl_hog_1 &amp;pinctrl_hog_2&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，pinctrl-names 属性仍然定义了一个状态名称：default。</p>
<p>pinctrl-0 属性指定了第一个状态 default 对应的引脚配置，但与之前的例子不同的是，它引用了两个引脚描述符：pinctrl_hog_1 和 pinctrl_hog_2。</p>
<p>这表示在 default 状态下，设备的引脚配置将使用 pinctrl_hog_1 和 pinctrl_hog_2 两个节点中定义的配置。这种方式可以将多个引脚控制器的配置组合在一起，以满足特定状态下的引脚需求。</p>
<p>至此关于客户端的内容就讲解完成了，低于客户端的内容，不同厂家的编写格式是相同的，而服务端每个厂家就有区别了，在下一个小节将以rk3568的pinctrl服务端为例进行讲解。</p>
<h3 id="61-2-2-服务端-Server"><a href="#61-2-2-服务端-Server" class="headerlink" title="61.2.2 服务端(Server)"></a>61.2.2 服务端(Server)</h3><p>服务端是设备树中定义引脚配置的部分。它包含引脚组和引脚描述符，为客户端提供引脚配置选择。服务端在设备树中定义了 pinctrl 节点，其中包含引脚组和引脚描述符的定义。</p>
<p>这里以瑞芯微的RK3568为例进行pinctrl服务端的讲解，瑞芯微原厂BSP工程师为了方便用户通过pinctrl设置管脚的复用关系，将包含所有复用关系的配置写在了内核目录下的“arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568-pinctrl.dtsi”设备树中，具体内容如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022825.jpeg" alt="img"> </p>
<p>在pinctrl节点中就是每个节点的复用功能，然后我们以uart4的引脚复用为例进行讲解，uart4的pinctrl服务端内容如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022736.jpeg" alt="img"> </p>
<p>其中&lt;3 RK_PB1 4 &amp;pcfg_pull_up&gt;和&lt;3 RK_PB2 4 &amp;pcfg_pull_up&gt;分别表示将GPIO3的PB1引脚设置为功能4，将GPIO3的PB2也设置为功能4，且电器属性都会设置为上拉。通过查找原理图可以得到两个引脚在BGA封装位置分别为AG1和AF2，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022803.jpeg" alt="img"> </p>
<p>然后在rk3568的数据手册中找到引脚复用表对应的位置，具体内容如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022099.jpeg" alt="img"><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022123.jpeg" alt="img"> </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022214.jpeg" alt="img"> </p>
<p>可以看到功能4对应串口4的发送端和接收端，pinctrl服务端的配置和数据手册中的引脚复用功能是一一对应，那如果要将RK_PB1和RK_PB2设置为GPIO功能要如何设置呢，从上图可以看到GPIO对应功能0，所以可以通过以下pinctrl内容将设置RK_PB1和RK_PB2设置为GPIO功能（事实上如果不对该管脚进行功能复用该引脚默认就会设置为GPIO功能）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;<span class="number">3</span> RK_PB1 <span class="number">0</span> &amp;pcfg_pull_up&gt;,                                                                                                                                                                                           </span><br><span class="line">&lt;<span class="number">3</span> RK_PB2 <span class="number">0</span> &amp;pcfg_pull_up&gt;;</span><br></pre></td></tr></table></figure>

<p>最后来看客户端对uart4服务端的引用，具体内容在内核源码目录“arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568-evb1-ddr4-v10-linux.dts”：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022165.jpeg" alt="img"> </p>
<p>通过在客户端中引用服务端的引脚描述符，设备树可以将客户端和服务端的引脚配置关联起来。这样，在设备树被解析和处理时，操作系统和设备驱动程序可以根据客户端的需求，查找并应用适当的引脚配置。</p>
<h2 id="61-3-pinctrl实例编写"><a href="#61-3-pinctrl实例编写" class="headerlink" title="61.3 pinctrl实例编写"></a>61.3 pinctrl实例编写</h2><p>本小节将通过上面学到的pinctrl相关知识，将led的控制引脚复用为GPIO模式。</p>
<p>首先来对rk3568的设备树结构进行以下介绍，根据sdk源码目录下的“device&#x2F;rockchip&#x2F;rk356x&#x2F;BoardConfig-rk3568-evb1-ddr4-v10.mk”默认配置文件可以了解到编译的设备树为rk3568-evb1-ddr4-v10-linux.dts,整理好的设备树之间包含关系列表如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022266.png" alt="image-20230906164406935"></p>
<p>Led在rk3568-evb.dtsi设备树中已经被正常配置了，如下图所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022394.jpeg" alt="img"></p>
<p>这时候可能大家就有问题了，这里也并没有配置pinctrl呀，那为什么led最后能正常使用呢，这个原因在上节课中其实我们已经提到了，当一个引脚没有被复用为任何功能时，默认就是GPIO功能，所以这里没有pinctrl led功能也可以正常使用。</p>
<p>但这里我们仍旧使用pinctrl对led进行配置，从而熟练pinctrl，首先注释掉leds节点，注释完成如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022446.jpeg" alt="img"> </p>
<p>保存退出之后，然后进入到rk3568-evb1-ddr4-v10.dtsi设备树中，找到rk_485_ctl节点，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022525.jpeg" alt="img"> </p>
<p>这是根节点的最后一个节点，而且也是用来控制一个GPIO的，我们完全可以仿照该节点，在该节点下方编写led控制节点，仿写完成的设备树内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_led: led &#123;</span><br><span class="line">   compatible = <span class="string">&quot;topeet,led&quot;</span>;</span><br><span class="line">   gpios = &lt;&amp;gpio0 RK_PB7 GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">   pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">   pinctrl<span class="number">-0</span> = &lt;&amp;rk_led_gpio&gt;;</span><br><span class="line">   &#125;;  </span><br></pre></td></tr></table></figure>

<p>第1行：节点名称为 led，标签名为my_led。</p>
<p>第2行：compatible 属性指定了设备的兼容性标识，即设备与驱动程序之间的匹配规则。在这里，设备标识为 “topeet,led”，表示该 LED 设备与名为 “topeet,led” 的驱动程序兼容。</p>
<p>第3行：gpios 属性指定了与LED相关的GPIO（通用输入&#x2F;输出）引脚配置。</p>
<p>第4行：pinctrl-names 属性指定了与引脚控制相关的命名。default表示状态 0</p>
<p>第5行：pinctrl-0 属性指定了与 pinctrl-names 属性中命名的引脚控制相关联的实际引脚控制器配置。&lt;&amp;rk_led_gpio&gt; 表示引用了名为 rk_led_gpio 的引脚控制器配置。</p>
<p>添加完成如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022540.jpeg" alt="img"> </p>
<p>然后继续找到在同一设备树文件的485 pinctrl服务端节点，具体内容如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022591.jpeg" alt="img"> </p>
<p>然后在该节点下方仿写led控制引脚pinctrl服务端节点，仿写完成的节点内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rk_led&#123;</span><br><span class="line">		rk_led_gpio:rk-led-gpio &#123;</span><br><span class="line">			rockchip,pins = &lt;0 RK_PB7 RK_FUNC_GPIO &amp;pcfg_pull_none&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p>添加完成之后如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022594.jpeg" alt="img"> </p>
<p>至此，led的控制引脚就通过pinctrl被复用为了GPIO功能，保存退出之后，重新编译内核，没有报错就证明我们的实验完成了。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-60-实例分析:GPIO</title>
    <url>/2023/09/05/1-60-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-GPIO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第60章-实例分析：GPIO"><a href="#第60章-实例分析：GPIO" class="headerlink" title="第60章 实例分析：GPIO"></a>第60章 实例分析：GPIO</h1><h2 id="60-1-GPIO相关属性"><a href="#60-1-GPIO相关属性" class="headerlink" title="60.1 GPIO相关属性"></a>60.1 GPIO相关属性</h2><h3 id="60-1-1-RK-ft5x06设备树节点"><a href="#60-1-1-RK-ft5x06设备树节点" class="headerlink" title="60.1.1 RK ft5x06设备树节点"></a>60.1.1 RK ft5x06设备树节点</h3><p>下面展示的是iTOP-RK3568开发板SDK源码中的ft5x06设备树，其中蓝色字体部分就是关于gpio相关的描述，包括了interrupts、 interrupt-controller、#interrupt-cells、interrupt-parent四种常见属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio0: gpio@fdd60000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;rockchip,gpio-bank&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0</span> <span class="number">0xfdd60000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">33</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    clocks = &lt;&amp;pmucru PCLK_GPI00&gt;, &lt;&amp;pmucru DBCLK_GPI00&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    gpio-ranges = &lt;&amp;pinctrl <span class="number">0</span> <span class="number">0</span> <span class="number">32</span>&gt;;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06@<span class="number">38</span> &#123; </span><br><span class="line">    status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    compatible = <span class="string">&quot;edt,edt-ft5306&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">    touch-gpio = &lt;&amp;gpio0 RK_PB5 IRQ_TYPE_EDGE_RISING&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio0&gt;;</span><br><span class="line">    interrupts = &lt;RK_PB5 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">    reset-gpios = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    touchscreen-size-x = &lt;<span class="number">800</span>&gt;;</span><br><span class="line">    touchscreen-size-y = &lt;<span class="number">1280</span>&gt;;</span><br><span class="line">    touch_type = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中gpio0节点是在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568.dtsi”设备树的3549-3560行定义的，而ft5x06: ft5x06@38触摸芯片节点是在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;topeet_rk3568_lcds.dtsi”设备树的301-313行定义的。接下来将会对设备树常见的四个gpio属性进行介绍。</p>
<h3 id="60-1-2-gpio-controller"><a href="#60-1-2-gpio-controller" class="headerlink" title="60.1.2 gpio-controller"></a>60.1.2 gpio-controller</h3><p>gpio-controller属性用于标识一个设备节点作为GPIO控制器。GPIO控制器是负责管理和控制GPIO引脚的硬件模块或驱动程序。</p>
<p>gpio-controller属性通常作为设备节点的一个属性出现，位于设备节点的属性列表中。</p>
<p>当一个设备节点被标识为GPIO控制器时，它通常会定义一组GPIO引脚，并提供相关的GPIO控制和配置功能。其他设备节点可以使用该GPIO控制器来控制和管理其GPIO引脚。</p>
<p>通过使用gpio-controller属性，设备树可以明确标识出GPIO控制器设备节点，使系统可以正确识别和管理GPIO引脚的配置和控制。</p>
<h3 id="60-1-3-gpio-cells"><a href="#60-1-3-gpio-cells" class="headerlink" title="60.1.3 #gpio-cells"></a>60.1.3 #gpio-cells</h3><p>#gpio-cells属性用于指定GPIO引脚描述符的编码方式。GPIO引脚描述符是用于标识和配置GPIO引脚的一组值，例如引脚编号、引脚属性等。</p>
<p>#gpio-cells属性的属性值是一个整数，表示用于编码GPIO引脚描述符的单元数。通常，这个值为2。</p>
<p>在第一小节的示例中有1个gpio引脚描述属性,由于#gpio-cells属性被设置为了2，所以每个引脚描述属性中会有两个整数，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ft5x06: ft5x06@<span class="number">38</span> &#123; </span><br><span class="line">    .....</span><br><span class="line">    reset-gpios = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>RK_PB6、GPIO_ACTIVE_LOW都属于恒定义，会在下面的小节进行讲解。</p>
<p>通过使用#gpio-cells属性，设备树可以指定GPIO引脚描述符的编码方式，使系统能够正确识别和解析GPIO引脚的配置和控制。</p>
<h3 id="60-1-4-gpio-ranges"><a href="#60-1-4-gpio-ranges" class="headerlink" title="60.1.4 gpio-ranges"></a>60.1.4 gpio-ranges</h3><p>gpio-ranges属性是设备树中一个用于描述GPIO范围映射的属性。它通常用于描述具有大量GPIO引脚的GPIO控制器，以简化GPIO引脚的编码和访问。</p>
<p>在设备树中，GPIO控制器的每个引脚都有一个本地编号，用于在控制器内部进行引脚寻址。然而，这些本地编号并不一定与外部引脚的物理编号或其他系统中使用的编号一致。为了解决这个问题，可以使用gpio-ranges属性将本地编号映射到实际的引脚编号。</p>
<p>gpio-ranges属性是一个包含一系列整数值的列表，每个整数值对应于设备树中的一个GPIO控制器。列表中的每个整数值按照特定的顺序提供以下信息：</p>
<p>（1）外部引脚编号的起始值。	</p>
<p>（2）GPIO控制器内部本地编号的起始值。</p>
<p>（3）引脚范围的大小（引脚数量）。</p>
<p>在第一小节的示例中gpio-ranges属性的值为&lt;&amp;pinctrl 0 0 32&gt;，其中&lt;&amp;pinctrl&gt;表示引用了名为pinctrl的引脚控制器节点，0 0 32表示外部引脚从0开始，控制器本地编号从0开始，共映射了32个引脚。</p>
<p>这样，gpio-ranges属性将GPIO控制器的本地编号直接映射到外部引脚编号，使得GPIO引脚的编码和访问更加简洁和直观。</p>
<h3 id="60-1-5-gpio引脚描述属性"><a href="#60-1-5-gpio引脚描述属性" class="headerlink" title="60.1.5 gpio引脚描述属性"></a>60.1.5 gpio引脚描述属性</h3><p>第一小节的设备树中关于gpio引脚描述属性相关内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ft5x06: ft5x06@<span class="number">38</span> &#123; </span><br><span class="line">    .....</span><br><span class="line">    reset-gpios = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>gpio引脚描述属性个数由#gpio-cells所决定，因为gpio0节点中的#gpio-cells属性设置为了2，所以上面设备树gpio引脚描述属性个数也为2。</p>
<p>其中RK_PB6 定义在内核源码目录下的“include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h”头文件中，定义了RK引脚名和gpio编号的宏定义，如下图所示：<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022930.jpeg" alt="img"> </p>
<p>GPIO_ACTIVE_LOW定义在源码目录下的“include&#x2F;dt-bindings&#x2F;gpio&#x2F;gpio.h”中，表示设置为低电平，同理GPIO_ACTIVE_HIGH就表示将这个GPIO设置为高电平，但这里只是对设备的描述，具体的设置还是要跟驱动相匹配。</p>
<h3 id="60-1-6-其他属性"><a href="#60-1-6-其他属性" class="headerlink" title="60.1.6 其他属性"></a>60.1.6 其他属性</h3><p>本小节将根据下面的设备树示例讲解一下gpio的其他重要属性，设备树具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpio-controller@00000000 &#123;</span><br><span class="line">    compatible = &quot;foo&quot;;</span><br><span class="line">    reg = &lt;0x00000000 0x1000&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    #gpio-cells = &lt;2&gt;;</span><br><span class="line">    ngpios = &lt;18&gt;;</span><br><span class="line">    gpio-reserved-ranges = &lt;0 4&gt;, &lt;12 2&gt;;</span><br><span class="line">    gpio-line-names = &quot;MMC-CD&quot;, &quot;MMC-WP&quot;,</span><br><span class="line">                      &quot;voD eth&quot;, &quot;RST eth&quot;, &quot;LED R&quot;,</span><br><span class="line">                      &quot;LED G&quot;, &quot;LED B&quot;, &quot;col A&quot;,</span><br><span class="line">                      &quot;col B&quot;, &quot;col C&quot;, &quot;col D&quot;,</span><br><span class="line">                      &quot;NMI button&quot;, &quot;Row A&quot;, &quot;Row B&quot;,</span><br><span class="line">                      &quot;Row C&quot;, &quot;Row D&quot;, &quot;poweroff&quot;,</span><br><span class="line">                      &quot;reset&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第6行的ngpios 属性指定了 GPIO 控制器所支持的 GPIO 引脚数量。它表示该设备上可用的 GPIO 引脚的总数。在这个例子中，ngpios&#96; 的值为 18，意味着该 GPIO 控制器支持 18 个 GPIO 引脚。</p>
<p>第7行的gpio-reserved-ranges属性定义了保留的GPIO范围。每个范围由两个整数值表示，用尖括号括起来。保留的GPIO范围意味着这些GPIO引脚不可用或已被其他设备或功能保留。在这个例子中，有两个保留范围：&lt;0 4&gt;和&lt;12 2&gt;。&lt;0 4&gt;表示从第0个引脚开始的连续4个引脚被保留，而&lt;12 2&gt;表示从第12个引脚开始的连续2个引脚被保留。<br>    第8行的gpio-line-names 属性定义了GPIO引脚的名称，以逗号分隔。每个名称对应一个 GPIO 引脚。这些名称用于标识和识别每个GPIO引脚的作用或连接的设备。在这个例子中，gpio-line-names属性列出了多个GPIO引脚的名称，如 “MMC-CD”、”MMC-WP”、”voD eth” 等等。通过这些名称，可以清楚地了解每个GPIO引脚的功能或用途。</p>
<h2 id="60-2-中断实例编写"><a href="#60-2-中断实例编写" class="headerlink" title="60.2 中断实例编写"></a>60.2 中断实例编写</h2><p>在上一个小节中对设备树中断要用到的属性进行了讲解，而在本小节将会编写一个在RK3568上LED灯的中断设备树。</p>
<p>首先确定LED的引脚编号，LED原理图如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022878.jpeg" alt="img"> </p>
<p>从上面的原理图可以得到LED灯的引脚网络标号为Working_LEDEN_H_GPIO0_B7，对应的引脚为GPIO0_B7。</p>
<p>然后来查看内核源码目录下的“drivers&#x2F;drivers&#x2F;leds&#x2F;leds-gpio.c”文件，这是led的驱动文件，然后找到compatible匹配值相关的部分，如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022895.jpeg" alt="img"> </p>
<p>可以看到compatible匹配值为gpio-leds。</p>
<p>最后在内核源码目录下的“include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h”头文件中，定义了RK引脚名和gpio编号的宏定义，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022857.jpeg" alt="img"> </p>
<p>在源码目录下的“include&#x2F;dt-bindings&#x2F;gpio&#x2F;gpio.h”文件中定义了引脚极性设置宏定义，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022886.jpeg" alt="img"> </p>
<p>其中GPIO_ACTIVE_HIGH表示将该引脚设置为高电平，GPIO_ACTIVE_LOW表示将该引脚设置为低电平。</p>
<p>至此，我们关于编写LED设备树的前置内容就查找完成了，接下来进行设备树的编写。</p>
<p>  编写完成的设备树如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/pinctrl/rockchip.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/gpio/gpio.h&quot;</span></span></span><br><span class="line">/&#123;</span><br><span class="line">	model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line"></span><br><span class="line">	led led@<span class="number">1</span> &#123;</span><br><span class="line">		compatible = <span class="string">&quot;gpio-leds&quot;</span>;</span><br><span class="line">		gpios = &lt;&amp;gpio0 RK_PB7 GPIO_ACTIVE_HIGH&gt;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第1行: 设备树文件的头部，指定了使用的设备树语法版本。</p>
<p>第3行：用于定义 Rockchip 平台的引脚控制器相关的绑定。</p>
<p>第4行：用于定义中断控制器相关的绑定。</p>
<p>第5行：表示设备树的根节点开始。</p>
<p>第6行：指定了设备树的模型名称，描述为 “This is my devicetree!”。</p>
<p>第9行：指定了设备节点的兼容性字符串，表示该设备与 “gpio-leds” 兼容。</p>
<p>第10行：指定了该 LED 设备所使用的 GPIO 引脚。&amp;gpio0 是引脚控制器的引用，RK_PB7 是引脚的编号或标识，GPIO_ACTIVE_HIGH 表示该 GPIO 引脚的活动电平是高电平。</p>
<p>至此，关于led的设备树就讲解完成了。</p>
<h2 id="60-3-其他SOC设备树对比"><a href="#60-3-其他SOC设备树对比" class="headerlink" title="60.3 其他SOC设备树对比"></a>60.3 其他SOC设备树对比</h2><p>而无论使用的是瑞芯微SOC还是恩智浦、三星的SOC，在设备树关于gpio相关的描述都是类似的，关于在恩智浦和三星源码中的ft5x06设备树如下所示：</p>
<p>恩智浦：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio1: gpio@<span class="number">0209</span>c000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;fsl,inx6ul-gpio&quot;</span>, <span class="string">&quot;fsl,imx35-gpio&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0209c000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">66</span> IRQ_TYPE_LEVEL_HIGH&gt;, &lt;GIC_SPI <span class="number">67</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    edt-ft5x06@<span class="number">38</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;edt,edt-ft5306&quot;</span>, <span class="string">&quot;edt,edt-ft5x06&quot;</span>, <span class="string">&quot;edt,edt-ft5406&quot;</span>;</span><br><span class="line">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        pinctrl<span class="number">-0</span> = &lt;&amp;ts_int_pin &amp;ts_reset_pin&gt;;</span><br><span class="line">        reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">        interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">        interrupts = &lt;<span class="number">9</span> <span class="number">0</span>&gt;;</span><br><span class="line">        reset-gpios = &lt;&amp;gpio5 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">        irq-gpios = &lt;&amp;gpio1 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>三星：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio_c: gpioc &#123;</span><br><span class="line">    compatible = <span class="string">&quot;gpio-controller&quot;</span>;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06038 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;edt,edt-ft5406&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(RGB_1024x600) || defined(RGB_800x480)</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;tsc2007_irq&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio_c&gt;;</span><br><span class="line">    interrupts = &lt;<span class="number">26</span> IRQ_TYPE_EDGE_FALLING&gt;;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(LvDs_800×1280) || defined(LvDS_1024x768)</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;gt911_irq&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio_b&gt;;</span><br><span class="line">    interrupts = &lt;<span class="number">29</span> IRQ_TYPE_EDGE_FALLING&gt;;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> reset-gpios = &lt;&amp;gpio_e <span class="number">30</span> <span class="number">0</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对比之后会发现，不同厂商对于gpio的配置都是类似的，只是里面的参数有些许区别，如果大家在之后遇到了其他平台，只需要稍加区分即可</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-59-实例分析:CPU</title>
    <url>/2023/09/05/1-59-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-CPU/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第59章-实例分析：CPU"><a href="#第59章-实例分析：CPU" class="headerlink" title="第59章 实例分析：CPU"></a>第59章 实例分析：CPU</h1><h2 id="59-1-cpus节点"><a href="#59-1-cpus节点" class="headerlink" title="59.1 cpus节点"></a>59.1 cpus节点</h2><p>设备树的 cpus 节点是用于描述系统中的处理器的一个重要节点。它是处理器拓扑结构的顶层节点，包含了所有处理器相关的信息。下面将详细介绍设备树的 cpus 节点的各个方面。</p>
<p><strong>节点结构：</strong></p>
<p>cpus 节点是一个容器节点，其下包含了系统中每个处理器的子节点。每个子节点的名称通常为 cpu@X，其中 X 是处理器的索引号。每个子节点都包含了与处理器相关的属性，例如时钟频率、缓存大小等。</p>
<p><strong>处理器属性：</strong></p>
<p>cpu@X 子节点中的属性可以包括以下信息：</p>
<p>（1）device_type：指示设备类型为处理器（”cpu”）。</p>
<p>（2）reg：指定处理器的地址范围，通常是物理地址或寄存器地址。</p>
<p>（3）compatible：指定处理器的兼容性信息，用于匹配相应的设备驱动程序。</p>
<p>（4）clock-frequency：指定处理器的时钟频率。</p>
<p>（5）cache-size：指定处理器的缓存大小。</p>
<p><strong>处理器拓扑关系：</strong></p>
<p>除了处理器的基本属性，cpus 节点还可以包含其他用于描述处理器拓扑关系的节点，以提供更详细的处理器拓扑信息。这些节点可以帮助操作系统和软件了解处理器之间的连接关系、组织结构和特性。</p>
<p>cpu-map 节点：描述处理器的映射关系，通常在多核处理器系统中使用。</p>
<p>socket 节点：描述多处理器系统中的物理插槽或芯片组。</p>
<p>cluster 节点：描述处理器集群，即将多个处理器组织在一起形成的逻辑组。</p>
<p>core 节点：描述处理器核心，即一个物理处理器内的独立执行单元。</p>
<p>thread 节点：描述处理器线程，即一个物理处理器核心内的线程。</p>
<p>这些节点的嵌套关系可以在 cpus 节点下形成一个层次结构，反映了处理器的拓扑结构。上述这些节点会在后面的小节进行介绍。一个单核CPU设备树和一个四核CPU设备树示例如下所示：</p>
<p>单核CPU示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    cpu0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a7&quot;</span>;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        <span class="comment">// 其他属性...</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多核CPU示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;0&gt;;</span><br><span class="line"></span><br><span class="line">    cpu0: cpu@0 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a9&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@1 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a9&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu2: cpu@2 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a9&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu3: cpu@3 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a9&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cpus 节点是一个容器节点，包含了 cpu0 子节点。该节点使用了 #address-cells 和 #size-cells 属性来指定地址和大小的单元数量。</p>
<p>cpu0 子节点代表第一个处理器，具有以下属性：</p>
<p>compatible 属性指定了处理器的兼容性信息</p>
<p>device_type 属性指示设备类型为处理器。</p>
<p>你可以在此基础上继续添加其他属性来描述处理器的特性，如时钟频率、缓存大小等。</p>
<h2 id="59-2-cpu-map、socket、cluster节点"><a href="#59-2-cpu-map、socket、cluster节点" class="headerlink" title="59.2 cpu-map、socket、cluster节点"></a>59.2 cpu-map、socket、cluster节点</h2><p>cpu-map 节点是设备树中用于描述大小核架构处理器的映射关系的节点之一。它的父节点必须是 cpus 节点，而子节点可以是一个或多个 cluster 和 socket 节点。通过 cpu-map 节点，可以定义不同核心和集群之间的连接和组织结构。</p>
<p>socket 节点用于描述处理器插槽（socket）之间的映射关系。每个 socket 子节点表示一个处理器插槽，可以使用 cpu-map-mask 属性来指定该插槽使用的核心。通过为每个 socket 子节点指定适当的 cpu-map-mask，可以定义不同插槽中使用的核心。这样，操作系统和软件可以了解到不同插槽之间的核心分配情况。</p>
<p>cluster 节点用于描述核心（cluster）之间的映射关系。每个 cluster 子节点表示一个核心集群，可以使用 cpu-map-mask 属性来指定该集群使用的核心。通过为每个 cluster 子节点指定适当的 cpu-map-mask，可以定义每个集群中使用的核心。这样，操作系统和软件可以了解到不同集群之间的核心分配情况。</p>
<p>通过在 cpu-map 节点中定义 socket 和 cluster 子节点，并为它们指定适当的 cpu-map-mask，可以提供处理器的拓扑结构信息。这对于操作系统和软件来说非常有用，因为它们可以根据这些信息进行任务调度和资源分配的优化，以充分利用大小核架构处理器的性能和能效特性。</p>
<p>一个大小核架构的具体示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">    cpu-<span class="built_in">map</span> &#123;</span><br><span class="line">        cluster0 &#123;</span><br><span class="line">            core0 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_l0&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">            core1 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_l1&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">            core2 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_l2&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">            core3 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_l3&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        cluster1 &#123;</span><br><span class="line">            core0 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_b0&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">            core1 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_b1&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">	cpu_l0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_l1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_l2: cpu@<span class="number">2</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_l3: cpu@<span class="number">3</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_b0: cpu@<span class="number">100</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a72&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_b1: cpu@<span class="number">101</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a72&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个设备树描述了一个具有多个 CPU 核心的系统，包括四个 Cortex-A53 核心和两个 Cortex-A72 核心。下面是对设备树中各个部分的简要介绍：</p>
<p>#address-cells &#x3D; &lt;2&gt;; 和 #size-cells &#x3D; &lt;0&gt;;：这些属性指定了设备树中地址和大小的编码方式。</p>
<p>cpu-map：这个节点定义了 CPU 的映射关系。它包含了两个簇（clusters）：cluster0 和 cluster1。cluster0 包含了四个核心：core0、core1、core2 和 core3，分别对应 cpu_l0、cpu_l1、cpu_l2 和 cpu_l3。cluster1 包含了两个核心：core0 和 core1，分别对应 cpu_b0 和 cpu_b1。</p>
<p>cpu_l0、cpu_l1、cpu_l2 和 cpu_l3：这些节点描述了 Cortex-A53 核心。它们具有相同的设备类型 cpu 和兼容性属性 “arm,cortex-a53”, “arm,armv8”。</p>
<p>cpu_b0 和 cpu_b1：这些节点描述了 Cortex-A72 核心。它们具有相同的设备类型 cpu 和兼容性属性 “arm,cortex-a72”, “arm,armv8”。</p>
<h2 id="59-3-core、thread节点"><a href="#59-3-core、thread节点" class="headerlink" title="59.3 core、thread节点"></a>59.3 core、thread节点</h2><p>“core” 和 “thread” 节点通常用于描述处理器核心和线程的配置。下面是对这两个节点的详细介绍：</p>
<p>Core 节点用于描述处理器的核心。一个处理器通常由多个核心组成，每个核心可以独立执行指令和任务。</p>
<p>Thread 节点用于描述处理器的线程。线程是在处理器核心上执行的基本执行单元，每个核心可以支持多个线程。</p>
<p>通过使用 Core 和 Thread 节点，设备树可以准确描述处理器的核心和线程的配置，例如可以使用设备树来描述一个具有16个核心的CPU，一个物理插槽，每个集群中有两个核心，每个核心有两个线程的设备树示例，具体设备树如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    cpu-<span class="built_in">map</span> &#123;</span><br><span class="line">        socket0 &#123;</span><br><span class="line">            cluster0 &#123;</span><br><span class="line">                core0 &#123;</span><br><span class="line">                    thread0 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU0&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    thread1 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU1&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">                core1 &#123;</span><br><span class="line">                    thread0 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU2&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    thread1 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU3&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            cluster1 &#123;</span><br><span class="line">                core0 &#123;</span><br><span class="line">                    thread0 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU4&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    thread1 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU5&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">                core1 &#123;</span><br><span class="line">                    thread0 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU6&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    thread1 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU7&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        socket1 &#123;</span><br><span class="line">			cluster0 &#123;</span><br><span class="line">				core0 &#123;</span><br><span class="line">					thread0 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU8&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">					thread1 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU9&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;;</span><br><span class="line">				core1 &#123;</span><br><span class="line">					thread0 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU10&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">					thread1 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU11&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">			cluster1 &#123;</span><br><span class="line">				core0 &#123;</span><br><span class="line">					thread0 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU12&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">					thread1 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU13&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;;</span><br><span class="line">				core1 &#123;</span><br><span class="line">					thread0 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU14&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">					thread1 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU15&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-58-实例分析:时钟</title>
    <url>/2023/09/05/1-58-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-%E6%97%B6%E9%92%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第58章-实例分析：时钟"><a href="#第58章-实例分析：时钟" class="headerlink" title="第58章 实例分析：时钟"></a>第58章 实例分析：时钟</h1><p>时钟（Clock）用于描述硬件设备和系统中的时钟源以及时钟相关的配置和连接关系。时钟在计算机系统中起着至关重要的作用，用于同步和定时各种硬件设备的操作。时钟可以分为两个主要角色：时钟生产者（clock provider）和时钟消费者（clock consumer）。</p>
<p><strong>时钟生产者</strong></p>
<p>定义：时钟生产者是负责生成和提供时钟信号的硬件或软件模块。它可以是时钟控制器、PLL、时钟发生器等。</p>
<p>设备树节点：时钟生产者在设备树中以时钟节点的形式表示。</p>
<p>时钟节点属性：</p>
<p><strong>（1）clock-cells：</strong>该属性用于指定时钟编号的位数。它是一个整数值，表示时钟编号的位数。通常情况下，当 clock-cells 为 0 时表示一个时钟，为 1 表示多个时钟。具体示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例<span class="number">1</span>：单个时钟</span><br><span class="line">osc24m: osc24m &#123;</span><br><span class="line">    compatible = <span class="string">&quot;clock&quot;</span>;</span><br><span class="line">    clock-frequency = &lt;<span class="number">24000000</span>&gt;;</span><br><span class="line">    clock-output-names = <span class="string">&quot;osc24m&quot;</span>;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;O&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">示例<span class="number">2</span>：多个时钟</span><br><span class="line">clock: clock &#123;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    clock-output-names = <span class="string">&quot;clock1&quot;</span>, <span class="string">&quot;clock2&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>（2）clock-frequency：</strong>属性是设备树中用于指定时钟频率的属性。它用于描述时钟节点所提供的时钟信号的频率，使用 Hertz (Hz) 作为单位。对于时钟生产者节点，clock-frequency 属性表示该节点生成的时钟信号的频率。它用于描述时钟控制器、晶振、PLL 等产生时钟信号的硬件或软件模块的输出频率，例如指定时钟频率为24000000的具体示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">osc24m: osc24m &#123;</span><br><span class="line">    compatible = <span class="string">&quot;clock&quot;</span>;</span><br><span class="line">    clock-frequency = &lt;<span class="number">24000000</span>&gt;;</span><br><span class="line">    clock-output-names = <span class="string">&quot;osc24m&quot;</span>;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;O&gt;</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>（3）assigned-clocks 和 assigned-clock-rates ：</strong>是设备树中用于描述多路时钟的属性，通常一起使用。</p>
<p>assigned-clocks 属性用于标识时钟消费者节点所使用的时钟源。它是一个整数数组，每个元素对应一个时钟编号。时钟编号是指时钟生产者节点（如时钟控制器）所提供的时钟源的编号。通过在时钟消费者节点中使用 assigned-clocks 属性，可以指定该节点所需的时钟源。</p>
<p>assigned-clock-rates 属性用于指定每个时钟源的时钟频率。它是一个整数数组，每个元素对应一个时钟源的频率。时钟频率以 Hz (赫兹) 为单位表示。assigned-clock-rates 属性的元素数量和顺序应与 assigned-clocks 属性中的时钟编号相对应。</p>
<p>关于assigned-clocks 和 assigned-clock-rates 属性的一个具体示例如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cru: clock-controller@fdd20000 &#123;</span><br><span class="line">    #clock-cells = &lt;1&gt;;</span><br><span class="line">    assigned-clocks = &lt;&amp;pmucru CLK_RTC_32K&gt;, &lt;&amp;cru ACLK_RKVDEC_PRE&gt;;</span><br><span class="line">    assigned-clock-rates = &lt;32768&gt;, &lt;300000000&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>（4）clock-indices：</strong>clock-indices 属性用于指定时钟消费者节点所使用的时钟源的索引值。它是一个整数数组，每个元素对应一个时钟源的索引。</p>
<p>时钟索引是指时钟生产者节点（如时钟控制器）所提供的时钟源的编号。通过在时钟消费者节点中使用 clock-indices 属性，可以明确指定该节点所需的时钟源，并按照特定的顺序进行匹配。一个clock-indices示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">scpi_dvfs: clocks<span class="number">-0</span> &#123;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    clock-indices = &lt;<span class="number">0</span>&gt;, &lt;<span class="number">1</span>&gt;, &lt;<span class="number">2</span>&gt;;</span><br><span class="line">    clock-output-names = <span class="string">&quot;atlclk&quot;</span>, <span class="string">&quot;aplclk&quot;</span>, <span class="string">&quot;gpuclk&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">scpi_clk: clocks<span class="number">-1</span> &#123;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    clock-indices = &lt;<span class="number">3</span>&gt;;</span><br><span class="line">    clock-output-names = <span class="string">&quot;pxlclk&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在第一个节点中”atlclk”, “aplclk”, “gpuclk”三个时钟源的索引就分别被设置为了0、1、2，在第二个节点中”pxlclk”时钟源的索引值被设置为了3.</p>
<p><strong>（5）assigned-clock-parents</strong> 属性用于指定时钟消费者节点所使用的时钟源的父时钟源。它是一个时钟源引用的数组，每个元素对应一个父时钟源的引用。在时钟的层次结构中，某些时钟源可能是其他时钟源的父时钟源，即它们提供时钟信号给其他时钟源作为输入。通过在时钟消费者节点中使用 assigned-clock-parents 属性，可以明确指定该节点所需的父时钟源，并按照特定的顺序进行匹配。一个实际的 assigned-clock-parents 属性例子如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clock: clock &#123;</span><br><span class="line">    assigned-clocks = &lt;&amp;clkcon 0&gt;, &lt;&amp;pll 2&gt;;</span><br><span class="line">    assigned-clock-parents = &lt;&amp;pll 2&gt;;</span><br><span class="line">    assigned-clock-rates = &lt;115200&gt;, &lt;9600&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述设备树表示了一个名为 clock 的时钟消费者节点，具有以下属性：</p>
<p>assigned-clocks 属性指定了该节点使用的时钟源，引用了两个时钟源节点：clkcon 0 和 pll 2。</p>
<p>assigned-clock-parents 属性指定了这些时钟源的父时钟源，引用了 pll 2 时钟源节点。</p>
<p>assigned-clock-rates 属性指定了每个时钟源的时钟频率，分别是 115200 和 9600。</p>
<p><strong>时钟消费者（Clock Consumer）：</strong></p>
<p>定义：时钟消费者是依赖时钟信号的硬件设备或模块。它们通过引用时钟生产者节点提供的时钟源来获取时钟信号。</p>
<p>设备树节点：时钟消费者在设备树中的节点中使用属性来引用时钟生产者的时钟源。</p>
<p>时钟消费者属性：</p>
<p>（1）clocks：该属性用于指定时钟消费者节点所需的时钟源。它是一个整数数组，每个元素是一个时钟编号，表示时钟消费者需要的一个时钟源。</p>
<p>（2）clock-names：可选属性，用于指定时钟消费者节点所需时钟源的名称。它是一个字符串数组，与 clocks 数组一一对应，用于提供时钟源的描述性名称。</p>
<p>一个时钟消费者示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clock: clock &#123;</span><br><span class="line">    clocks = &lt;&amp;cru CLK_VOP&gt;;</span><br><span class="line">    clock-names = <span class="string">&quot;clk_vop&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>clocks 属性指定了该节点使用的时钟源，引用了 cru 节点中的 CLK_VOP 时钟源。</p>
<p>clock-names 属性指定了时钟源的名称，这里是 “clk_vop”。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-57-实例分析:中断</title>
    <url>/2023/09/05/1-57-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第57章-实例分析：中断"><a href="#第57章-实例分析：中断" class="headerlink" title="第57章 实例分析：中断"></a>第57章 实例分析：中断</h1><h2 id="57-1-中断相关属性"><a href="#57-1-中断相关属性" class="headerlink" title="57.1 中断相关属性"></a>57.1 中断相关属性</h2><h3 id="57-1-1-RK-ft5x06设备树节点"><a href="#57-1-1-RK-ft5x06设备树节点" class="headerlink" title="57.1.1 RK ft5x06设备树节点"></a>57.1.1 RK ft5x06设备树节点</h3><p>下面展示的是iTOP-RK3568开发板SDK源码中的ft5x06设备树，包括了interrupts、 interrupt-controller、#interrupt-cells、interrupt-parent四种常见属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio0: gpio@fdd60000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;rockchip,gpio-bank&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0</span> <span class="number">0xfdd60000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">33</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    clocks = &lt;&amp;pmucru PCLK_GPI00&gt;, &lt;&amp;pmucru DBCLK_GPI00&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    gpio-ranges = &lt;&amp;pinctrl <span class="number">0</span> <span class="number">0</span> <span class="number">32</span>&gt;;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06@<span class="number">38</span> &#123; </span><br><span class="line">    status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    compatible = <span class="string">&quot;edt,edt-ft5306&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">    touch-gpio = &lt;&amp;gpio0 RK_PB5 IRQ_TYPE_EDGE_RISING&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio0&gt;;</span><br><span class="line">    interrupts = &lt;RK_PB5 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">    reset-gpios = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    touchscreen-size-x = &lt;<span class="number">800</span>&gt;;</span><br><span class="line">    touchscreen-size-y = &lt;<span class="number">1280</span>&gt;;</span><br><span class="line">    touch_type = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中gpio0节点是在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568.dtsi”设备树的3549-3560行定义的，而ft5x06: ft5x06@38触摸芯片节点是在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;topeet_rk3568_lcds.dtsi”设备树的301-313行定义的。接下来将会对设备树常见的四个中断属性进行介绍。</p>
<h3 id="57-1-2-interrupts"><a href="#57-1-2-interrupts" class="headerlink" title="57.1.2 interrupts"></a>57.1.2 interrupts</h3><p>interrupts 属性用于指定设备的中断相关信息。它描述了中断控制器的类型、中断号以及中断触发类型。下面将对interrupts 属性的各个方面进行介绍。</p>
<p>在第一小节中列举的设备树源码中的gpio0节点和ft5x06节点都涉及到了interrupts 属性，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio0: gpio@fdd60000 &#123;</span><br><span class="line">    ....</span><br><span class="line">interrupts = &lt;GIC_SPI <span class="number">33</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06@<span class="number">38</span> &#123; </span><br><span class="line">    ....</span><br><span class="line">interrupts = &lt;RK_PB5 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>gpio0节点的interrupts具有三个参数，分别表示中断控制器类型、中断号和中断触发类型，每个参数的具体描述如下所示：</p>
<p><strong>（1）中断控制器类型：</strong></p>
<p>interrupts 属性的第一个参数指定了中断控制器的类型。常见的类型包括 GIC (Generic Interrupt Controller)、IRQ (Basic Interrupt Handling) 等。例如，在给定的代码片段中，GIC_SPI 表示中断控制器的类型为 GIC SPI 中断。</p>
<p>中断控制器负责管理系统中的中断信号，它可以是硬件中的专用中断控制器，也可以是处理器内部的中断控制器。</p>
<p><strong>（2）中断号：</strong></p>
<p>interrupts 属性的第二个参数指定了设备所使用的中断号。中断号是一个唯一标识符，用于区分不同的中断信号源。系统使用中断号来识别中断源并进行相应的中断处理。</p>
<p>中断号可以是一个整数值，也可以是一个宏定义或符号引用。在给定的代码片段中，33 表示该设备使用的中断号为 33。</p>
<p><strong>（3）中断触发类型：</strong></p>
<p>interrupts 属性的第三个参数指定了中断的触发类型，即中断信号的触发条件。常见的触发类型包括边沿触发和电平触发。</p>
<p>边沿触发表示中断信号在从低电平到高电平或从高电平到低电平的变化时触发。触发类型可以是上升沿触发、下降沿触发或双边沿触发。电平触发表示中断信号在保持特定电平状态时触发，可以是高电平触发或低电平触发。</p>
<p>在给定的代码片段中，IRQ_TYPE_LEVEL_HIGH 表示中断的触发类型为高电平触发。触发类型的宏定义在内核源码“include&#x2F;dt-bindings&#x2F;interrupt-controller&#x2F;irq.h”目录下，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_NONE           0   <span class="comment">// 无中断触发类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_RISING    1   <span class="comment">// 上升沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_FALLING   2   <span class="comment">// 下降沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_BOTH    (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING)<span class="comment">// 双边沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_LEVEL_HIGH     4   <span class="comment">// 高电平触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_LEVEL_LOW      8   <span class="comment">// 低电平触发</span></span></span><br></pre></td></tr></table></figure>

<p>而在ft5x06节点中只有中断号和中断触发类型两个参数，这是为什么呢，带着疑问我们继续学习下面的几个属性。</p>
<h3 id="57-1-3-interrupt-controller"><a href="#57-1-3-interrupt-controller" class="headerlink" title="57.1.3 interrupt-controller"></a>57.1.3 interrupt-controller</h3><p>interrupt-controller 属性是设备树中用于描述中断控制器的属性之一。它提供了关于中断控制器的相关信息，以便操作系统和其他设备能够正确配置和使用中断系统。<br>    interrupt-controller 属性用于标识当前节点所描述的设备是一个中断控制器。中断控制器是硬件或软件模块，负责管理和分发中断信号。它接收来自各种设备的中断请求，并根据优先级和配置规则分发中断给相应的处理器或设备。<br>    interrupt-controller属性本身没有特定的属性值，只需出现在节点的属性列表中即可。出现该属性的存在即表示该节点描述的设备是中断控制器。</p>
<h3 id="57-1-4-interrupt-parent"><a href="#57-1-4-interrupt-parent" class="headerlink" title="57.1.4 interrupt-parent"></a>57.1.4 interrupt-parent</h3><p>interrupt-parent 属性是设备树中用于建立中断信号源与中断控制器之间关联的属性。它指定了中断信号源所属的中断控制器节点，以确保正确的中断处理和分发。<br>    interrupt-parent属性用于指定中断信号源所属的中断控制器。中断信号源是产生中断的设备或其他中断源节点。通过指定中断控制器，操作系统可以正确地将中断请求传递给相应的中断控制器节点进行处理和分发。<br>    interrupt-parent属性值是一个引用，它指向中断控制器节点的路径或标签。可以使用路径来引用中断控制器节点，如&#x2F;interrupt-controller-node，或使用标签来引用中断控制器节点，如 &amp;interrupt-controller-label，在第一小节例子中的 ft5x06就是通过中断控制器节点和gpio0中断控制器建立了联系，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ft5x06: ft5x06@38 &#123; </span><br><span class="line">    ....</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio0&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	中断信号源节点（例如设备节点或其他中断源节点）中的 interrupt-parent 属性用于指定中断信号源所属的中断控制器节点。这样，中断信号源就可以将中断请求传递给正确的中断控制器进行处理。中断信号源节点的 interrupts 属性中的中断号和其他相关信息将与指定的中断控制器关联起来。<br>​	在某些情况下，中断控制器可以形成多级结构，其中一个中断控制器节点可能是另一个中断控制器的父节点。在这种情况下，interrupt-parent 属性可以用于指定层次结构中的上级中断控制器。</p>
<h3 id="57-1-5-interrupt-cells"><a href="#57-1-5-interrupt-cells" class="headerlink" title="57.1.5 #interrupt-cells"></a>57.1.5 #interrupt-cells</h3><p>#interrupt-cells属性用于描述中断控制器中每个中断信号源的中断编号单元的数量。中断编号单元是指用于表示中断号和其他相关信息的固定大小的单元。通过指定中断编号单元的数量，操作系统可以正确解析和处理中断信息，并将其与中断控制器和中断信号源进行关联。<br>    #interrupt-cells属性的值是一个整数，表示中断编号单元的数量。通常，这个值是一个正整数，例如 1、2 或 3，取决于中断控制器和设备的要求。</p>
<p>在gpio0的中断控制器为gic，在gic节点中#interrupt-cells属性被设置为3，这也就是为什么在gpio0节点中interrupts 属性有三个值，而ft5x06的中断控制器为gpio0，在gpio0节点中#interrupt-cells属性被设置为2，所以ft5x06节点的interrupts 属性只有两个值。</p>
<h2 id="57-2-中断实例编写"><a href="#57-2-中断实例编写" class="headerlink" title="57.2 中断实例编写"></a>57.2 中断实例编写</h2><p>在上一个小节中对设备树中断要用到的属性进行了讲解，而在本小节将会编写一个在RK3568上的ft5x06触摸中断设备树。</p>
<p>首先确定ft5x06的中断引脚号，由于iTOP-RK3568有1.2和1.7两个版本，所以这里展示了两个版本的原理图：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022380.jpeg" alt="img"> </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022342.jpeg" alt="img"> </p>
<p>第一张图为V1.2版本的原理图，触摸引脚网络标号为TP_INT_L_GPIO0_B5，对应的SOC管脚为GPIO0_B5，第二张图为V1.7版本的原理图，触摸引脚网络标号为TP_INT_L_GPIO3_A5，对应的SOC管脚为GPIO3_A5。</p>
<p>然后来查看内核源码目录下的“drivers&#x2F;input&#x2F;touchscreen&#x2F;edt-ft5x06.c”文件，这是ft5x06的驱动文件，找到compatible匹配值相关的部分，如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022325.jpeg" alt="img"> </p>
<p>这里的compatible匹配值都可以选择，作者选择的是edt,edt-ft5206，选择其他compatible也是可以的。</p>
<p>在内核源码目录下的“include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h”头文件中，定义了RK引脚名和gpio编号的宏定义，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022294.jpeg" alt="img"> </p>
<p>可以看到RK已经将GPIO组和引脚编号写成了宏定义的形式，通过宏定义可以减少在编写设备树的过程中换算的时间，并且帮助大家进行理解。</p>
<p>至此，关于编写ft5x06设备树的前置内容就查找完成了，接下来进行设备树的编写。</p>
<p>  编写完成的设备树如下所示：</p>
<p><strong>V1.2：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/pinctrl/rockchip.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/interrupt-controller/irq.h&quot;</span></span></span><br><span class="line">/&#123;</span><br><span class="line">	model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line"></span><br><span class="line">	ft5x06@<span class="number">38</span> &#123;</span><br><span class="line">		compatible = <span class="string">&quot;edt,edt-ft5206&quot;</span>;</span><br><span class="line">		interrupt-parent = &lt;&amp;gpio0&gt;;</span><br><span class="line">		interrupts = &lt;RK_PB5 IRQ_TYPE_EDGE_RISING&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>V1.7：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/pinctrl/rockchip.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/interrupt-controller/irq.h&quot;</span></span></span><br><span class="line">/&#123;</span><br><span class="line">	model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line"></span><br><span class="line">	ft5x06@<span class="number">38</span> &#123;</span><br><span class="line">		compatible = <span class="string">&quot;edt,edt-ft5206&quot;</span>;</span><br><span class="line">		interrupt-parent = &lt;&amp;gpio3&gt;;</span><br><span class="line">		interrupts = &lt;RK_PA5 IRQ_TYPE_EDGE_RISING&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第1行: 设备树文件的头部，指定了使用的设备树语法版本。</p>
<p>第3行：用于定义 Rockchip 平台的引脚控制器相关的绑定。</p>
<p>第4行：用于定义中断控制器相关的绑定。</p>
<p>第5行：表示设备树的根节点开始。</p>
<p>第6行：指定了设备树的模型名称，描述为 “This is my devicetree!”。</p>
<p>第9行：指定了设备节点的兼容性字符串，表示该设备与 “edt,edt-ft5206” 兼容。</p>
<p>第10行：指定了中断的父节点，即中断控制器所在的节点。这里使用了一个引用（&amp;gpio0）来表示父节点。</p>
<p>第11行：指定了中断信号的配置。RK_PB5 表示中断信号的引脚编号，IRQ_TYPE_EDGE_RISING 表示中断类型为上升沿触发。</p>
<p>至此，关于ft5x06的设备树就讲解完成了。</p>
<h2 id="57-3-其他SOC设备树对比"><a href="#57-3-其他SOC设备树对比" class="headerlink" title="57.3 其他SOC设备树对比"></a>57.3 其他SOC设备树对比</h2><p>而无论使用的是瑞芯微SOC还是恩智浦、三星的SOC，在设备树关于中断相关的描述都离不开上面提到的四个属性，关于在恩智浦和三星源码中的ft5x06设备树如下所示：</p>
<p><strong>恩智浦：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio1: gpio@<span class="number">0209</span>c000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;fsl,inx6ul-gpio&quot;</span>, <span class="string">&quot;fsl,imx35-gpio&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0209c000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">66</span> IRQ_TYPE_LEVEL_HIGH&gt;, &lt;GIC_SPI <span class="number">67</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    edt-ft5x06@<span class="number">38</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;edt,edt-ft5306&quot;</span>, <span class="string">&quot;edt,edt-ft5x06&quot;</span>, <span class="string">&quot;edt,edt-ft5406&quot;</span>;</span><br><span class="line">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        pinctrl<span class="number">-0</span> = &lt;&amp;ts_int_pin &amp;ts_reset_pin&gt;;</span><br><span class="line">        reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">        interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">        interrupts = &lt;<span class="number">9</span> <span class="number">0</span>&gt;;</span><br><span class="line">        reset-gpios = &lt;&amp;gpio5 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">        irq-gpios = &lt;&amp;gpio1 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>三星：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio_c: gpioc &#123;</span><br><span class="line">    compatible = <span class="string">&quot;gpio-controller&quot;</span>;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06038 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;edt,edt-ft5406&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(RGB_1024x600) || defined(RGB_800x480)</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;tsc2007_irq&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio_c&gt;;</span><br><span class="line">    interrupts = &lt;<span class="number">26</span> IRQ_TYPE_EDGE_FALLING&gt;;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(LvDs_800×1280) || defined(LvDS_1024x768)</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;gt911_irq&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio_b&gt;;</span><br><span class="line">    interrupts = &lt;<span class="number">29</span> IRQ_TYPE_EDGE_FALLING&gt;;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    reset-gpios = &lt;&amp;gpio_e <span class="number">30</span> <span class="number">0</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对比之后会发现，不同厂商对于中断属性的配置都是类似的，只是里面的参数有些许区别，如果大家在之后遇到了其他平台，只需要稍加区分即可。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-56-设备树基本语法</title>
    <url>/2023/09/05/1-56-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第56章-设备树基本语法"><a href="#第56章-设备树基本语法" class="headerlink" title="第56章 设备树基本语法"></a>第56章 设备树基本语法</h1><h2 id="56-1设备树语法讲解1"><a href="#56-1设备树语法讲解1" class="headerlink" title="56.1设备树语法讲解1"></a>56.1设备树语法讲解1</h2><h3 id="56-1-1-根节点"><a href="#56-1-1-根节点" class="headerlink" title="56.1.1 根节点"></a>56.1.1 根节点</h3><p>设备树使用一种层次结构，其中的根节点（Root Node）是整个设备树的起始点和顶层节点。根节点由一个以&#x2F;开头的标识符来表示，然后使用{}来包含根节点所在的内容，一个最简单的根节点示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;  <span class="comment">// 设备树版本信息</span></span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    <span class="comment">// 根节点开始</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在这里可以添加注释，描述根节点的属性和配置</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中第一行的设备树中的版本信息行 dts-v1 是可选的，可以根据需要选择是否保留。这行注释通常用于指定设备树的语法版本。如果您不需要在设备树中指定版本信息，可以将其删除。</p>
<h3 id="56-1-2-子节点"><a href="#56-1-2-子节点" class="headerlink" title="56.1.2 子节点"></a>56.1.2 子节点</h3><p>设备树中的子节点是根节点的直接子项，用于描述具体的硬件设备或设备集合。子节点采用以下特定的格式来表示:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[label:] node-name@[unit-address] &#123;</span><br><span class="line">	[properties definitions]</span><br><span class="line">	[child nodes]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下是对这些部分的详细介绍：</p>
<p>（1）节点标签（Label）（可选）：节点标签是一个可选的标识符，用于在设备树中引用该节点。标签允许其他节点直接引用此节点，以便在设备树中建立引用关系。</p>
<p>（2）节点名称（Node Name）：节点名称是一个字符串，用于唯一标识该节点在设备树中的位置。节点名称通常是硬件设备的名称，但必须在设备树中是唯一的。</p>
<p>（3）单元地址（Unit Address）（可选）：单元地址用于标识设备的实例。它可以是一个整数、一个十六进制值或一个字符串，具体取决于设备的要求。单元地址的目的是区分相同类型的设备的不同实例，例如在下图中名为 cpu 的节点通过它们的单元地址值 0 和 1 来区分，名称为 ethernet 的节点通过其单元地址值 fe002000 和 fe003000 来区分。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022002.jpeg" alt="img"> </p>
<p>（4）属性定义（Properties Definitions）：属性定义是一组键值对，用于描述设备的配置和特性。属性可以根据设备的需求进行定义，例如寄存器地址、中断号、时钟频率等，关于这些属性会在后面的小节中进行讲解</p>
<p>（5）子节点（Child Nodes）：子节点是当前节点的子项，用于进一步描述硬件设备的子组件或配置。子节点可以包含自己的属性定义和更深层次的子节点，形成设备树的层次结构。</p>
<h3 id="56-1-3-reg属性"><a href="#56-1-3-reg属性" class="headerlink" title="56.1.3 reg属性"></a>56.1.3 reg属性</h3><p>reg 属性用于在设备树中指定设备的寄存器地址和大小，提供了与设备树中的物理设备之间的寄存器映射关系。</p>
<p>reg 属性可以在设备节点中有单个值格式和列表值格式这两种常见格式，接下来将对这两种格式进行介绍：</p>
<p>（1）单个值格式如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">reg = &lt;address size&gt;;</span><br></pre></td></tr></table></figure>

<p>这种格式适用于描述单个寄存器的情况。其中，address 是设备的起始寄存器地址，可以是一个整数或十六进制值。size 表示寄存器的大小，即占用的字节数。</p>
<p>例如，假设有一个设备节点 my_device，使用单个值格式的 reg 属性来描述一个 4 字节寄存器的地址和大小，可以这样定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;vendor,device&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x1000</span> <span class="number">0x4</span>&gt;;</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>my_device</code> 设备节点的 <code>reg</code> 属性值为 <code>&lt;0x1000 0x4&gt;</code>，表示从地址 <code>0x1000</code> 开始的 4 字节寄存器区域。</p>
<p>（2）列表值格式如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">reg = &lt;address1 size1 address2 size2 ...&gt;;</span><br></pre></td></tr></table></figure>

<p>当设备具有多个寄存器区域时，可以使用列表值格式的 reg 属性来描述每个寄存器区域的地址和大小。通过这种方式，可以指定多个寄存器的位置和大小，以描述设备的完整寄存器映射。</p>
<p>例如，考虑一个设备节点 my_device，它具有两个寄存器区域，分别是 8 字节和 4 字节大小的寄存器。可以使用列表值格式的 reg 属性来描述这种情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;vendor,device&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x1000</span> <span class="number">0x8</span> <span class="number">0x2000</span> <span class="number">0x4</span>&gt;;</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，my_device 设备节点的 reg 属性值为 &lt;0x1000 0x8 0x2000 0x4&gt;，表示设备有两个寄存器区域。第一个寄存器区域从地址 0x1000 开始，大小为 8 字节；第二个寄存器区域从地址 0x2000 开始，大小为 4 字节。</p>
<p>通过使用 reg 属性，设备树可以提供有关设备寄存器布局和寄存器访问方式的信息。这对于操作系统的设备驱动程序很重要，因为它们需要了解设备的寄存器映射以正确地与设备进行交互和配置。</p>
<h3 id="56-1-4-address-cell和size-cells"><a href="#56-1-4-address-cell和size-cells" class="headerlink" title="56.1.4 address-cell和size-cells"></a>56.1.4 address-cell和size-cells</h3><p>#address-cells 和 #size-cells 属性用于指定在上个小节中要设置的设备树中地址单元和大小单元的位数。它们提供了设备树解析所需的元数据，以正确解释设备的地址和大小信息。下面对两个属性分别进行介绍：</p>
<p><strong>(1)#address-cells属性</strong></p>
<p>#address-cells 属性是一个位于设备树根节点的特殊属性，它指定了设备树中地址单元的位数。地址单元是设备树中用于表示设备地址的单个单位。它通常是一个整数，可以是十进制或十六进制值。</p>
<p>#address-cells 属性的值告诉解析设备树的软件在解释设备地址时应该使用多少位来表示一个地址单元。</p>
<p>默认情况下，#address-cells 的值为 2，表示使用两个单元来表示一个设备地址。这意味着设备的地址将由两个整数（每个整数使用指定位数的位）组成。</p>
<p>例如，对于一个使用两个 32 位（4字节）整数表示地址的设备，可以在设备树的根节点中设置 #address-cells 属性为 &lt;2&gt;。</p>
<p><strong>(2)#size-cells 属性</strong></p>
<p>#size-cells 属性也是一个位于设备树根节点的特殊属性，它指定了设备树中大小单元的位数。大小单元是设备树中用于表示设备大小的单个单位。它通常是一个整数，可以是十进制或十六进制值。</p>
<p>#size-cells 属性的值告诉解析设备树的软件在解释设备大小时应该使用多少位来表示一个大小单元。</p>
<p>默认情况下，#size-cells 的值为 1，表示使用一个单元来表示一个设备的大小。这意味着设备的大小将由一个整数（使用指定位数的位）表示。</p>
<p>例如，对于一个使用一个 32 位（4 字节）整数表示大小的设备，可以在设备树的根节点中设置 #size-cells 属性为 &lt;1&gt;。</p>
<p>这两个属性的存在是为了使设备树能够灵活地描述各种设备的地址和大小表示方式。通过在设备树的根节点中设置适当的 #address-cells 和 #size-cells 值，设备树解析软件能够正确地解释设备节点中的地址和大小信息。</p>
<p>以下是两个个示例，展示了根节点中 #address-cells 和 #size-cells 属性的使用：</p>
<p><strong>示例1</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">node1 &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    node1-child &#123;</span><br><span class="line">        reg = &lt;<span class="number">0x02200000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">        <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，node1-child 节点的 reg 属性使用了 &lt;0x02200000 0x4000&gt; 表示地址和大小。由于 #address-cells 的值为 &lt;1&gt;，表示使用一个单元来表示地址。#size-cells 的值也为 &lt;1&gt;，表示使用一个单元来表示大小。</p>
<p>解释后的地址和大小值如下：</p>
<p>地址部分：0x02200000 被解释为一个地址单元，地址为 0x02200000。</p>
<p>大小部分：0x4000 被解释为一个大小单元，大小为 0x4000。</p>
<p>示例2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">node1 &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">    node1-child &#123;</span><br><span class="line">        reg = &lt;<span class="number">0x0000</span> <span class="number">0x0001</span>&gt;;</span><br><span class="line">        <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，node1-child 节点的 reg 属性使用了 &lt;0x0000 0x0001&gt; 表示地址。由于 #address-cells 的值为 &lt;2&gt;，表示使用两个单元来表示地址。#size-cells 的值为 &lt;0&gt;，表示不使用单元来表示大小。</p>
<p>解释后的地址值如下：</p>
<p>地址部分：0x0000 0x0001 被解释为两个地址单元，其中第一个地址单元为 0x0000，第二个地址单元为 0x0001。</p>
<p>这种使用 #address-cells 和 #size-cells 属性的方式使得设备树可以适应不同设备的寄存器映射和大小表示方式，并确保设备树解析软件能够正确解释设备的地址和大小信息。</p>
<h3 id="56-1-5-model属性"><a href="#56-1-5-model属性" class="headerlink" title="56.1.5 model属性"></a>56.1.5 model属性</h3><p>在设备树中，model 属性用于描述设备的型号或者名称。它通常作为设备节点的一个属性，用来提供关于设备的标识信息。model 属性是可选的，但在实际应用中经常被使用。</p>
<p>model 属性的值是一个字符串，可以是设备的型号、名称、或者其他标识符，用来识别设备。该值通常由设备的厂商定义，并且在设备树中使用。</p>
<p>以下是一个示例，展示了如何在设备树中使用 model 属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;vendor,device&quot;</span>;</span><br><span class="line">    model = <span class="string">&quot;My Device XYZ&quot;</span>;</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，my_device 节点具有 model 属性，其值为 “My Device XYZ”。这个值描述了设备的型号或名称为 “My Device XYZ”。</p>
<p>model 属性通常用于标识和区分不同的设备，特别是当设备节点的 compatible 属性相同或相似时。通过使用不同的 model 属性值，可以更加准确地确定所使用的设备类型。</p>
<h3 id="56-1-6-status属性"><a href="#56-1-6-status属性" class="headerlink" title="56.1.6 status属性"></a>56.1.6 status属性</h3><p>在设备树中，status 属性用于描述设备或节点的状态。它是设备树中常见的属性之一，用于表示设备或节点的可用性或操作状态。</p>
<p>status 属性的值可以是以下几种：</p>
<p>“okay”：表示设备或节点正常工作，可用。</p>
<p>“disabled”：表示设备或节点被禁用，不可用。</p>
<p>“reserved”：表示设备或节点已被保留，暂时不可用。</p>
<p>“fail”：表示设备或节点初始化或操作失败，不可用。</p>
<p>以下是一个示例，展示了如何在设备树中使用 status 属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;vendor,device&quot;</span>;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，my_device 节点具有 status 属性，其值为 “okay”。这表示设备处于正常工作状态，可用。</p>
<p>通过使用 status 属性，设备树可以动态地控制设备的启用和禁用状态。这对于在系统启动过程中选择性地启用或禁用设备，或者在运行时根据特定条件调整设备状态非常有用。</p>
<h3 id="56-1-7-compatible属性"><a href="#56-1-7-compatible属性" class="headerlink" title="56.1.7 compatible属性"></a>56.1.7 compatible属性</h3><p>在设备树中，compatible 属性用于描述设备的兼容性信息。它是设备树中重要的属性之一，用于识别设备节点与驱动程序之间的匹配关系。</p>
<p>compatible 属性的值是一个字符串或字符串列表，用于指定设备节点与相应的驱动程序或设备描述符兼容的规则。通常，compatible 属性的值由设备的厂商定义，并且在设备树中使用。</p>
<p>以下是一些常见的 compatible 属性值的示例：</p>
<p>（1）单个字符串值：例如 “vendor,device”，用于指定设备节点与特定厂商的特定设备兼容。</p>
<p>（2）字符串列表：例如 [“vendor,device1”, “vendor,device2”]，用于指定设备节点与多个设备兼容，通常用于设备节点具有多种变体或配置。</p>
<p>（3）通配符匹配：例如 “vendor,*”，用于指定设备节点与特定厂商的所有设备兼容，不考虑具体的设备标识。</p>
<p>以下是一个示例，展示了如何在设备树中使用 compatible 属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;vendor,device&quot;</span>;</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，my_device 节点具有 compatible 属性，其值为 “vendor,device”。这个值用于标识设备节点与特定厂商的特定设备兼容。</p>
<p>compatible 属性也可以具有多个匹配值，用于指定设备节点与多个设备或驱动程序的兼容性规则。这种情况下，compatible 属性的值是一个字符串列表，每个字符串表示一个匹配值。</p>
<p>以下是一个示例，展示了具有多个匹配值的 compatible 属性的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = [&quot;vendor,device1&quot;, &quot;vendor,device2&quot;];</span><br><span class="line">    // 其他属性和子节点的定义</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，my_device 节点具有 compatible 属性，其值为 [“vendor,device1”, “vendor,device2”]。这表示设备节点与厂商的 device1 和 device2 兼容。</p>
<p>通过使用 compatible 属性，设备树可以提供设备和驱动程序之间的匹配信息。当设备树被操作系统或设备管理软件解析时，会根据设备节点的 compatible 属性值来选择适合的驱动程序进行设备的初始化和配置。</p>
<h2 id="56-2-设备树语法讲解2"><a href="#56-2-设备树语法讲解2" class="headerlink" title="56.2 设备树语法讲解2"></a>56.2 设备树语法讲解2</h2><h3 id="56-2-1-aliases节点"><a href="#56-2-1-aliases节点" class="headerlink" title="56.2.1 aliases节点"></a>56.2.1 aliases节点</h3><p> aliases 节点是一个特殊的节点，用于定义设备别名。该节点位于设备树的根部，并具有节点路径 &#x2F;aliases。</p>
<p>aliases 节点是一个容器节点，包含一组属性，每个属性都代表一个设备别名。每个属性的名称是别名的标识符，而属性的值是被引用设备节点的路径或设备树中其他节点的路径。</p>
<p>以下是一个示例，演示了如何在设备树中使用 aliases 节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line">    mmc0 = &amp;sdmmc0;</span><br><span class="line">    mmc1 = &amp;sdmmc1;</span><br><span class="line">    mmc2 = &amp;sdhci;</span><br><span class="line">    serial0 = &quot;/simple@fe000000/seria1@11c500&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在给定的例子中，有四个别名的定义：</p>
<p>（1）mmc0 别名与设备树中的 sdmmc0 节点相关联。通过使用别名 mmc0，其他设备节点或客户端程序可以更方便地引用 sdmmc0 节点，而不必直接使用其完整路径。</p>
<p>（2）mmc1 别名与设备树中的 sdmmc1 节点相关联。通过使用别名 mmc1，其他设备节点或客户端程序可以更方便地引用 sdmmc1 节点，而不必直接使用其完整路径。</p>
<p>（3）mmc2 别名与设备树中的 sdhci 节点相关联。通过使用别名 mmc2，其他设备节点或客户端程序可以更方便地引用 sdhci 节点，而不必直接使用其完整路径。</p>
<p>（4）serial0 别名与设备树中的路径 &#x2F;simple@fe000000&#x2F;seria1@11c500 相关联。通过使用别名 serial0，其他设备节点或客户端程序可以更方便地引用该路径，而不必记住整个路径字符串。</p>
<p>在别名的定义中，&amp; 符号用于引用设备树中的节点。别名的目的是提供可读性更高的名称，使设备树更易于理解和维护。通过使用别名，可以简化设备节点之间的关联，并减少重复输入设备节点的路径。</p>
<p>客户端程序可以使用别名属性名称来引用完整的设备路径或部分路径。当客户端程序将别名字符串视为设备路径时，应检测并使用别名。这样，设备树的使用者可以更方便地引用设备节点，而不必记住复杂的路径结构。</p>
<p>需要注意的是，aliases 节点中定义的别名只在设备树内部可见，不能在设备树之外引用。它们主要用于设备树的内部组织和引用，以提高可读性和可维护性。</p>
<h3 id="56-2-2-choose节点"><a href="#56-2-2-choose节点" class="headerlink" title="56.2.2 choose节点"></a>56.2.2 choose节点</h3><p>chosen节点是设备树中的一个特殊节点，用于传递和存储系统引导和配置的相关信息。它位于设备树的根部，并具有路径&#x2F;chosen。</p>
<p>chosen节点通常包含以下子节点和属性：</p>
<p>（1）bootargs：用于存储引导内核时传递的命令行参数。它可以包含诸如内核参数、设备树参数等信息。在引导过程中，操作系统或引导加载程序可以读取该属性来获取启动参数。</p>
<p>（2）stdout-path：用于指定用于标准输出的设备路径。在引导过程中，操作系统可以使用该属性来确定将控制台输出发送到哪个设备，例如串口或显示屏。</p>
<p>（3）firmware-name：用于指定系统固件的名称。它可以用于标识所使用的引导加载程序或固件的类型和版本。</p>
<p>（4）linux,initrd-start和linux,initrd-end：这些属性用于指定Linux内核初始化RAM磁盘（initrd）的起始地址和结束地址。这些信息在引导过程中被引导加载程序使用，以将initrd加载到内存中供内核使用。</p>
<p>（5）其他自定义属性：chosen节点还可以包含其他自定义属性，用于存储特定于系统引导和配置的信息。这些属性的具体含义和用法取决于设备树的使用和上下文。</p>
<p>关于chosen节点的实际例子如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chosen &#123;</span><br><span class="line">    bootargs = &quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0,115200&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，chosen 节点具有一个属性 bootargs，其值为”root&#x3D;&#x2F;dev&#x2F;nfs rw nfsroot&#x3D;192.168.1.1 console&#x3D;ttyS0,115200”。</p>
<p>通过这些命令行参数，操作系统或引导加载程序可以配置内核在引导过程中正确地加载 NFS 根文件系统，并将控制台输出发送到指定的串口设备。</p>
<p>通过使用chosen节点，系统引导过程中的相关信息可以方便地传递给操作系统或引导加载程序。这样，系统引导和配置的各个组件可以共享和访问这些信息，从而实现更灵活和可配置的系统引导流程。chosen节点提供了一种通用的机制，使得不同的设备树和引导系统可以在传递信息方面保持一致性，并且可以根据具体需求扩展和自定义。</p>
<h3 id="56-2-3-device-type节点"><a href="#56-2-3-device-type节点" class="headerlink" title="56.2.3 device_type节点"></a>56.2.3 device_type节点</h3><p>在设备树中，device_type 节点是用于描述设备类型的节点。它通常作为设备节点的一个属性存在。device_type 属性的值是一个字符串，用于标识设备的类型。</p>
<p>device_type 节点的存在有助于操作系统或其他软件识别和处理设备。它提供了设备的基本分类信息，使得驱动程序、设备树解析器或其他系统组件能够根据设备的类型执行相应的操作。</p>
<p>常见的设备类型包括但不限于：</p>
<p>（1）cpu：表示中央处理器。</p>
<p>（2）memory：表示内存设备。</p>
<p>（3）display：表示显示设备，如液晶显示屏。</p>
<p>（4）serial：表示串行通信设备，如串口。</p>
<p>（5）ethernet：表示以太网设备。</p>
<p>（6）usb：表示通用串行总线设备。</p>
<p>（7）i2c：表示使用 I2C (Inter-Integrated Circuit) 总线通信的设备。</p>
<p>（8）spi：表示使用 SPI (Serial Peripheral Interface) 总线通信的设备。</p>
<p>（9）gpio：表示通用输入&#x2F;输出设备。</p>
<p>（10）pwm：表示脉宽调制设备。</p>
<p>这些只是一些常见的设备类型示例，实际上，设备类型可以根据具体的硬件和设备树的使用情况进行自定义和扩展。根据设备类型，操作系统或其他软件可以加载适当的驱动程序、配置设备资源、建立设备之间的连接等。</p>
<h3 id="56-2-4-自定义属性"><a href="#56-2-4-自定义属性" class="headerlink" title="56.2.4 自定义属性"></a>56.2.4 自定义属性</h3><p>设备树中的自定义属性是用户根据特定需求添加的属性。这些属性可以用于提供额外的信息、配置参数或元数据，以满足设备或系统的特定要求。</p>
<p>在设备树中添加自定义属性时，可以在设备节点或其他适当的节点下定义新的属性。自定义属性可以是整数、字符串、布尔值或其他数据类型。它们的命名应遵循设备树的命名约定，并且应该与已有的属性名称避免冲突。</p>
<p>例如可以在设备树中自定义一个管脚标号的属性pinnum，添加好的设备树源码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = &quot;my_device&quot;;</span><br><span class="line">    pinnum = &lt;0 1 2 3 4&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，my_device 是一个自定义设备节点，并添加了一个自定义属性 pinnum。该属性的值 &lt;0 1 2 3 4&gt; 是一个整数数组，表示管脚的标号（PIN number）。</p>
<p>通过这样定义 pinnum 属性，您可以在设备树中为特定设备指定管教标号，以便操作系统、驱动程序或其他软件组件使用。这可以用于在设备初始化或配置过程中对特定管教进行操作或控制。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-55-初识设备树</title>
    <url>/2023/09/05/1-55-%E5%88%9D%E8%AF%86%E8%AE%BE%E5%A4%87%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第55章-初识设备树"><a href="#第55章-初识设备树" class="headerlink" title="第55章 初识设备树"></a>第55章 初识设备树</h1><h2 id="55-1-设备树的由来"><a href="#55-1-设备树的由来" class="headerlink" title="55.1 设备树的由来"></a>55.1 设备树的由来</h2><p>设备树（Device Tree）是一种硬件描述机制，用于在嵌入式系统和操作系统中描述硬件设备的特性、连接关系和配置信息。它提供了一种与平台无关的方式来描述硬件，使得内核与硬件之间的耦合度降低，提高了系统的可移植性和可维护性。</p>
<p>在上一篇平台总线内容的学习中，我们使用platform_device结构体来对硬件设备进行描述，这是一种传统的平台总线设备描述方式。每个platform_device结构表示一个特定的硬件设备，并通过注册到平台总线上来使得内核能够与该设备进行通信和交互。该结构包含设备的名称、资源（如内存地址、中断号等）、设备驱动程序等信息。</p>
<p>然而，随着时间的推移，Linux内核中的ARM部分存在着大量的平台相关配置代码，这些代码通常是杂乱而重复的，导致了维护的困难和工作量的增加。在2011年3月17日，Linux的创始人Linus Torvalds在ARM Linux邮件列表中发表了一封帖子，他表达了对ARM架构配置方式的不满，并宣称”Gaah. Guys, this whole ARM thing is a f*cking pain in the ass”。这引起了广泛的讨论和反思。ARM社区中的开发者们开始认识到，传统的平台相关配置方式已经变得不可持续，需要一种更加先进和可扩展的方法来解决这个问题。</p>
<p>为了应对这一挑战，ARM社区开始探索新的硬件描述机制，并逐渐形成了设备树的概念。设备树提供了一种更加灵活和可移植的描述硬件的机制，将设备的描述信息转移到设备树中。设备树使用一种结构化的数据格式，通过描述设备节点、属性和连接关系等信息，使得硬件的描述与具体的平台无关，同时允许多个平台共享相同的设备树描述。</p>
<p>设备树的引入为ARM架构上的Linux内核带来了革命性的变化。它提供了一种统一的硬件描述方式，使得不同芯片和板级的支持更加简单和灵活。此外，设备树还提供了硬件配置的可视化和可读性，方便开发者理解和调试硬件。</p>
<p>随着时间的推移，设备树逐渐成为了嵌入式系统和Linux内核中描述硬件的标准方式。它不仅在ARM架构上得到了广泛应用，也被扩展到其他架构和平台上。</p>
<h2 id="55-2-设备树基础知识"><a href="#55-2-设备树基础知识" class="headerlink" title="55.2 设备树基础知识"></a>55.2 设备树基础知识</h2><p>当描述设备树（Device Tree）时，通常会涉及到以下几个关键术语：DTS、DTSI、DTB和DTC。下面来对每个术语进行介绍。</p>
<p>DTS（Device Tree Source）：DTS是设备树的源文件，采用一种类似于文本的语法来描述硬件设备的结构、属性和连接关系。DTS文件以.dts为扩展名，通常由开发人员编写。它是人类可读的形式，用于描述设备树的层次结构和属性信息。</p>
<p>DTSI（Device Tree Source Include）：DTSI文件是设备树源文件的包含文件。它扩展了DTS文件的功能，用于定义可重用的设备树片段。DTSI文件以.dtsi为扩展名，可以在多个DTS文件中包含和共享。通过使用DTSI，可以提高设备树的可重用性和可维护性（和C语言中头文件的作用相同）。</p>
<p>DTB（Device Tree Blob）：DTB是设备树的二进制表示形式。DTB文件是通过将DTS或DTSI文件编译而成的二进制文件，以.dtb为扩展名。DTB文件包含了设备树的结构、属性和连接信息，被操作系统加载和解析。在运行时，操作系统使用DTB文件来动态识别和管理硬件设备。</p>
<p>DTC（Device Tree Compiler）：DTC是设备树的编译器。它是一个命令行工具，用于将DTS和DTSI文件编译成DTB文件。DTC将文本格式的设备树源代码转换为二进制的设备树表示形式，以便操作系统能够加载和解析。DTC是设备树开发中一个重要的工具。</p>
<p><strong>DTS、DTSI、DTB和DTC之间的关系：</strong></p>
<p>（1）开发人员使用文本编辑器编写DTS和DTSI文件，描述硬件设备的层次结构、属性和连接关系。</p>
<p>（2）DTSI文件可以在多个DTS文件中包含和共享，以提高设备树的可重用性和可维护性。</p>
<p>（3）使用DTC编译器，开发人员将DTS和DTSI文件编译成二进制的DTB文件，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062021519.jpeg" alt="img"> </p>
<p>操作系统在启动过程中加载和解析DTB文件，以识别和管理硬件设备。</p>
<p>设备树文件存放路径：</p>
<p>ARM体系结构：</p>
<p>ARM体系结构下的设备树源文件通常存放在arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;目录中。该目录是设备树源文件的根目录。如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062021539.jpeg" alt="img"> </p>
<p>ARM64体系结构：</p>
<p>设备树源文件路径：ARM64体系结构下的设备树源文件通常存放在arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;目录及其子目录中。该目录也是设备树源文件的根目录，并包含了针对不同ARM64平台和设备的子目录，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062021441.jpeg" alt="img"> </p>
<p>子目录结构：在ARM64的子目录中，同样会按照硬件平台、设备类型或制造商进行组织和分类。这些子目录的命名可能与特定芯片厂商（如Qualcomm、NVIDIA、Samsung）有关，由于我们本手册使用的soc是瑞芯微的rk3568，所以匹配的设备树目录为arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip。每个子目录中可能包含多个设备树文件，用于描述不同的硬件配置和设备类型，这里以rockchip目录内容如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062021532.jpeg" alt="img"></p>
<h2 id="55-3-设备树的编译"><a href="#55-3-设备树的编译" class="headerlink" title="55.3 设备树的编译"></a>55.3 设备树的编译</h2><p>设备树的编译是将设备树源文件（如上述的.dts文件）转换为二进制的设备树表示形式（.dtb文件）的过程。编译器通常被称为DTC（Device Tree Compiler）。</p>
<p>在Linux内核源码中，DTC（Device Tree Compiler）的源代码和相关工具通常存放在scripts&#x2F;dtc&#x2F;目录中，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062021475.jpeg" alt="img"> </p>
<p>在编译完源码之后dtc设备树编译器会默认生成，如果没有生成相应的dtc可执行文件，可以查看在内核默认配置文件中CONFIG_DTC是否使能。</p>
<p><strong>设备树的编译</strong>：</p>
<p>在Linux环境中，可以使用以下命令将设备树源文件编译为二进制设备树文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dtc -I dts -O dtb -o output.dtb input.dts</span><br></pre></td></tr></table></figure>

<p>其中，<code>input.dts</code>是输入的设备树源文件，<code>output.dtb</code>是编译后的二进制设备树文件。</p>
<p>编译器会验证设备树源文件的语法和语义，生成与硬件描述相对应的设备树表示形式。</p>
<p><strong>设备树的反编译：</strong></p>
<p>​	设备树的反编译是将二进制设备树文件转换回设备树源文件的过程，以便进行查看、编辑或修改。反编译器通常也是DTC。</p>
<p>在Linux环境中，可以使用以下命令将二进制设备树文件反编译为设备树源文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dtc -I dtb -O dts -o output.dts input.dtb</span><br></pre></td></tr></table></figure>

<p>其中，input.dtb是输入的二进制设备树文件，output.dts是反编译后的设备树源文件。</p>
<p>反编译器会将二进制设备树文件解析并还原为文本形式的设备树源文件，使其可读性更好。</p>
<p>下面来进行一下实际的设备树编译和反编译的演示，首先创建一个名为test.dts的设备树文件，文件内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">/ &#123;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建完成如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062021504.jpeg" alt="img"> </p>
<p>这个设备树很简单，只包含了根节点&#x2F;，而根节点中没有任何子节点或属性。这个示例并没有描述任何具体的硬件设备或连接关系，它只是一个最基本的设备树框架，在本小节只是为了测试设备树的编译和反编译。</p>
<p>然后使用以下命令进行设备树的编译，编译完成如下图所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/topeet/Linux/linux_sdk/kernel/scripts/dtc/dtc -I dts -O dtb -o test.dtb test.dts</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062021796.jpeg" alt="img"> </p>
<p>可以看到test.dtb就生成了，然后继续使用以下命令对test.dtb进行反编译，反编译完成如下图所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/topeet/Linux/linux_sdk/kernel/scripts/dtc/dtc -I dtb -O dts -o 1.dts test.dtb </span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062021902.jpeg" alt="img"> </p>
<p>可以看到反编译出的1.dts跟之前的test.dts内容相同。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-54-点亮LED灯实验（平台总线)</title>
    <url>/2023/09/05/1-54-%E7%82%B9%E4%BA%AELED%E7%81%AF%E5%AE%9E%E9%AA%8C%EF%BC%88%E5%B9%B3%E5%8F%B0%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-53-probe函数编写实验</title>
    <url>/2023/09/05/1-53-probe%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-52-注册platform驱动实验</title>
    <url>/2023/09/05/1-52-%E6%B3%A8%E5%86%8Cplatform%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-51-注册platform设备实验</title>
    <url>/2023/09/05/1-51-%E6%B3%A8%E5%86%8Cplatform%E8%AE%BE%E5%A4%87%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-50-平台总线模型介绍</title>
    <url>/2023/09/05/1-50-%E5%B9%B3%E5%8F%B0%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-49-中断线程化实验</title>
    <url>/2023/09/05/1-49-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-48-并发管理工作队列实验</title>
    <url>/2023/09/05/1-48-%E5%B9%B6%E5%8F%91%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-47-工作队列传参实验</title>
    <url>/2023/09/05/1-47-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E4%BC%A0%E5%8F%82%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-46-延迟工作实验</title>
    <url>/2023/09/05/1-46-%E5%BB%B6%E8%BF%9F%E5%B7%A5%E4%BD%9C%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-45-自定义工作队列实验</title>
    <url>/2023/09/05/1-45-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-44-共享工作队列实验</title>
    <url>/2023/09/05/1-44-%E5%85%B1%E4%BA%AB%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-43-特殊的软中断tasklet分析实验</title>
    <url>/2023/09/05/1-43-%E7%89%B9%E6%AE%8A%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%ADtasklet%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-42-软中断实验</title>
    <url>/2023/09/05/1-42-%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-41-中断下文tasklet实验</title>
    <url>/2023/09/05/1-41-%E4%B8%AD%E6%96%AD%E4%B8%8B%E6%96%87tasklet%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-40-中断申请流程</title>
    <url>/2023/09/05/1-40-%E4%B8%AD%E6%96%AD%E7%94%B3%E8%AF%B7%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-39-中断实验</title>
    <url>/2023/09/05/1-39-%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-38-驱动调试方法实验</title>
    <url>/2023/09/05/1-38-%E9%A9%B1%E5%8A%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-37-优化驱动稳定性和效率实验</title>
    <url>/2023/09/05/1-37-%E4%BC%98%E5%8C%96%E9%A9%B1%E5%8A%A8%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%92%8C%E6%95%88%E7%8E%87%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-36-封装驱动API接口实验</title>
    <url>/2023/09/05/1-36-%E5%B0%81%E8%A3%85%E9%A9%B1%E5%8A%A8API%E6%8E%A5%E5%8F%A3%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-35-IOCTL地址传参实验</title>
    <url>/2023/09/05/1-35-IOCTL%E5%9C%B0%E5%9D%80%E4%BC%A0%E5%8F%82%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-34-IOCTL驱动传参实验</title>
    <url>/2023/09/05/1-34-IOCTL%E9%A9%B1%E5%8A%A8%E4%BC%A0%E5%8F%82%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-33-llseek定位设备驱动实验</title>
    <url>/2023/09/05/1-33-llseek%E5%AE%9A%E4%BD%8D%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-31-秒字符设备驱动实验</title>
    <url>/2023/09/05/1-31-%E7%A7%92%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-30-定时器实验</title>
    <url>/2023/09/05/1-30-%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-29-信号驱动IO实验</title>
    <url>/2023/09/05/1-29-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-28-IO多路复用实验</title>
    <url>/2023/09/05/1-28-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-27-非阻塞IO实验</title>
    <url>/2023/09/05/1-27-%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-26-阻塞IO实验</title>
    <url>/2023/09/05/1-26-%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-25-IO模型引入实验</title>
    <url>/2023/09/05/1-25-IO%E6%A8%A1%E5%9E%8B%E5%BC%95%E5%85%A5%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-24-互斥锁实验</title>
    <url>/2023/09/05/1-24-%E4%BA%92%E6%96%A5%E9%94%81%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-23-信号量实验</title>
    <url>/2023/09/05/1-23-%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-22-自旋锁死锁实验</title>
    <url>/2023/09/05/1-22-%E8%87%AA%E6%97%8B%E9%94%81%E6%AD%BB%E9%94%81%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-21-自旋锁实验</title>
    <url>/2023/09/05/1-21-%E8%87%AA%E6%97%8B%E9%94%81%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-20-原子操作实验</title>
    <url>/2023/09/05/1-20-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-19-并发与竞争实验</title>
    <url>/2023/09/05/1-19-%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-1-前言</title>
    <url>/2023/09/05/1-1-%E5%89%8D%E8%A8%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>磨刀不误砍柴工！在学习驱动之前先和同学们交流下学习方法和学习态度。</p>
<h1 id="1-1-学习方法"><a href="#1-1-学习方法" class="headerlink" title="1.1 学习方法"></a>1.1 学习方法</h1><p>在学习驱动的过程中，同学们难免会遇到很多问题，例如编译环境的问题造成内核编译不通过、交叉编译器或者架构类型没有设置导致驱动编译失败、内核版本和驱动版本不统一造成驱动加载不成功等多种问题。</p>
<p>在遇到问题的时候，同学们一定不要灰心，要敢于去尝试用自己的思路去解决问题。机遇与挑战往往是并存的。当同学们解决一个问题以后，自然就会前进一步。水滴石穿，才可以真正掌握linux驱动。</p>
<p> 所以一定要养成独立思考的好习惯！遇到问题之后，同学们可以先自己根据问题的具体表现，来找到问题的源头，仔细分析问题产生的原因和解决的方法，自主思考无果之后可以尝试去谷歌、百度、CSDN等各大检索网站上寻求帮助，Linux已经发展了很多年，前辈们在之前进行了无数的探索，总有许多类似的经验，能解决绝大多数的问题。</p>
<p>并且在学习过程中千万不要好高骛远，比如对于一些有基础的同学来说，学习过相似的知识点就一目十行甚至直接跳过，这种行为是不可取的，学习一遍和学习两遍的知识点，在认知和运用程度上是完全不一样的。读书要从薄到厚,再厚到薄，学习亦是如此。</p>
<p>端正学习态度后还要有一个好的学习方法，迅为公司在多年培训和产品开发中总结出来了一套适合初学者的学习方式，具体含义解释为框架化学习，快速原型。运用到嵌入式Linux驱动学习上就是从一开始先看到Linux驱动知识领域的外貌，然后逐渐深入！以了解北京这座城市为例，如果在胡同里转来转去，可能几年都搞不清楚这个城市是什么情况，但是如果先通过北京地图学习一下，了解天安门在什么地方，鸟巢在什么地方，香山八达岭在哪里，然后到这些地方看一看，可能很快就能掌握这座城市的全貌。所以运用框架学习法，在对不同层次的框架进行学习过程中，逐渐了解和掌握整个系统。 如果不注意方法，每天在胡同里面来回转悠，肯定是事倍功半，很长时间将不得要领。</p>
<p>需要注意的是，即便有了地图，也需要一些基础，比如知道什么是天安门，知道鸟巢的来历，明白八达岭是怎么回事，实际上这些就是基础知识。也就是说在学习系统框架之前要具备一定的基础，否则这张地图也是看不懂的。学习驱动知识也是需要一定的基础的，所以驱动学习是有门槛的！</p>
<p>对于学习方法和学习态度就先说这样多，关于基础方面，下一节会专门讨论。 </p>
<h1 id="1-2-基础准备"><a href="#1-2-基础准备" class="headerlink" title="1.2 基础准备"></a>1.2 基础准备</h1><p>首先，不要脱离硬件。就好比用仿真软件学习51单片机是永远掌握不了单片机的精髓的。所以有一块硬件开发板是学习驱动的前提。</p>
<p>第二，有了开发板之后，要掌握开发板的基本操作。如开发板的启动，烧写镜像等操作。</p>
<p>第三，能够成功编译开发板的系统源码。在驱动的学习过程中，是避免不了的要对内核的某些功能进行使能、修改设备树添加对应的设备，这些操作都需要进行源码编译。</p>
<p>第四，掌握C语言。驱动程序是由C语言编写的，而且内核源码中绝大多数的代码也都是由C语言编写的，在学习驱动的过程中，或多或少的要对源码进行阅读。所以C语言基础是学习驱动的必要条件之一。</p>
<p>第五，掌握Linux环境搭建以及shell命令的使用。</p>
<p>第六，驱动最后必然要落实到相应的硬件上，所以肯定要对底层电路有所了解，以驱动LED灯为例，必然要了解其控制电路，找到相应的控制引脚，要能读懂简单的硬件原理图。</p>
<p>【最新驱动资料（文档+例程）】</p>
<p>链接 <a href="https://pan.baidu.com/s/1M4smUG2vw_hnn0Hye-tkog">https://pan.baidu.com/s/1M4smUG2vw_hnn0Hye-tkog</a></p>
<p>提取码：hbh6</p>
<p>【B 站配套视频】</p>
<p><a href="https://b23.tv/XqYa6Hm">https://b23.tv/XqYa6Hm</a></p>
<p>【RK3568 购买链接】</p>
<p><a href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-2245">https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-2245</a></p>
<p>2452613.11.2fec74a6elWNeA&amp;id&#x3D;669939423234</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-18-点亮LED灯实验</title>
    <url>/2023/09/05/1-18-%E7%82%B9%E4%BA%AELED%E7%81%AF%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-17-Linux错误处理实验</title>
    <url>/2023/09/05/1-17-Linux%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-16-一个驱动兼容不同设备实验</title>
    <url>/2023/09/05/1-16-%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E5%85%BC%E5%AE%B9%E4%B8%8D%E5%90%8C%E8%AE%BE%E5%A4%87%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-15-文件私有数据实验</title>
    <url>/2023/09/05/1-15-%E6%96%87%E4%BB%B6%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-14-内核空间与用户空间数据交互实验</title>
    <url>/2023/09/05/1-14-%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-13-杂项设备驱动实验</title>
    <url>/2023/09/05/1-13-%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-12-字符设备驱动框架实验</title>
    <url>/2023/09/05/1-12-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-11-创建设备节点实验</title>
    <url>/2023/09/05/1-11-%E5%88%9B%E5%BB%BA%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-10-注册字符设备实验</title>
    <url>/2023/09/05/1-10-%E6%B3%A8%E5%86%8C%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-9-申请字符设备号实验</title>
    <url>/2023/09/05/1-9-%E7%94%B3%E8%AF%B7%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%8F%B7%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-8-驱动模块编译进内核实验</title>
    <url>/2023/09/05/1-8-%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E8%BF%9B%E5%86%85%E6%A0%B8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-7-menuconfig图形化配置实验</title>
    <url>/2023/09/05/1-7-menuconfig%E5%9B%BE%E5%BD%A2%E5%8C%96%E9%85%8D%E7%BD%AE%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-6-内核模块符号导出实验</title>
    <url>/2023/09/05/1-6-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%AC%A6%E5%8F%B7%E5%AF%BC%E5%87%BA%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在上一小节中，给大家讲解了驱动模块传参实验，使用insmod命令加载驱动时可以进行参数的传递，但是每一个内核模块之间是相互独立的，那模块间的符号传递要怎样进行呢，让我们带着疑问来进行本章节的学习吧！</p>
<h2 id="6-1-内核模块符号导出简介"><a href="#6-1-内核模块符号导出简介" class="headerlink" title="6.1 内核模块符号导出简介"></a>6.1 内核模块符号导出简介</h2><p>驱动程序编译生成的ko文件是相互独立的，即模块之间变量或者函数在正常情况下无法进行互相访问。而一些复杂的驱动模块需要分层进行设计，这时候就需要用到内核模块符号导出。</p>
<p>内核符号导出指的是在内核模块中导出相应的函数和变量，在加载模块时被记录在公共内核符号表中，以供其他模块调用。符号导出所使用的宏为EXPORT_SYMBOL(sym)和EXPORT_SYMBOL_GPL(sym)。它们定义在 “内核源码&#x2F;include&#x2F;linux&#x2F;export.h”文件中（在module.h文件中已经对export.h进行引用，所以不需要单独引用export.h文件）,详细定义如下（图6-1）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT_SYMBOL(sym)                  \</span></span><br><span class="line"><span class="meta">__EXPORT_SYMBOL(sym, <span class="string">&quot;&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT_SYMBOL_GPL(sym)                  \</span></span><br><span class="line"><span class="meta">    __EXPORT_SYMBOL(sym, <span class="string">&quot;_gpl&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<p>EXPORT_SYMBOL(sym)和EXPORT_SYMBOL_GPL(sym)两个宏使用方法相同，而EXPORT_SYMBOL_GPL(sym)导出的模块只能被 GPL 许可的模块使用，所以绝大多数的情况都使用EXPORT_SYMBOL(sym)进行符号导出。sym为函数的唯一参数，表示要导出的函数或变量名称。</p>
<p>至此，关于内核模块符号导出函数就讲解完成了，在下一小节中将会编写两个驱动代码来进行内核模块符号导出实验。</p>
<h2 id="6-2-实验程序的编写"><a href="#6-2-实验程序的编写" class="headerlink" title="6.2 实验程序的编写"></a>6.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\03。</p>
<p>本章实验将编写Linux下的内核模块符号导出实例代码，总共有两个驱动程序，第一个驱动文件名为mathmodule.c，用来定义参数num和函数add(a,b)，第二个驱动文件名为hello.c,会引用mathmodule.c驱动程序中的参数num和数学函数add(a,b)，并将相应的参数值和函数返回值打印到串口终端上。</p>
<p>编写完成的mathmodule.c代码如下（图6-2）所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;<span class="comment">//定义参数num</span></span><br><span class="line">EXPORT_SYMBOL(num);<span class="comment">//导出参数num</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//定义数学函数add()，用来实现加法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(add);<span class="comment">//导出数学函数add()</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">math_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;math_moudle init\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">math_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;math_module exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(math_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(math_exit);<span class="comment">//注册出口函数</span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);<span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>图6-2</p>
<p>以上代码定义了一个int类型的num变量和add()数学函数，并使用EXPORT_SYMBOL宏进行导出。</p>
<p>编写完成的hello.c代码如下（图6-3）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> num;<span class="comment">//导入int类型变量num</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;<span class="comment">//导入函数add</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> sum;</span><br><span class="line">    printk(<span class="string">&quot;num = %d\n&quot;</span>, num);<span class="comment">//打印num值</span></span><br><span class="line">    sum = add(<span class="number">3</span>, <span class="number">4</span>);<span class="comment">//使用add函数进行3+4的运算                                                                                                                                                                          </span></span><br><span class="line">    printk(<span class="string">&quot;sum = %d\n&quot;</span>, sum);<span class="comment">//打印add函数的运算值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;Goodbye hello module\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(hello_exit);<span class="comment">//注册出口函数</span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);<span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>图6-3</p>
<p>程序导入了int类型的变量num和add()函数，并在驱动入口函数中打印相应了num的参数值并对add()函数进行了调用。</p>
<p>至此两个驱动代码就编写完成了，代码较为简单，实现了内核模块符号的导出和导出符号的使用，具体的驱动加载运行测试会在下个小节进行。</p>
<h2 id="6-3-运行测试"><a href="#6-3-运行测试" class="headerlink" title="6.3 运行测试"></a>6.3 运行测试</h2><h3 id="6-3-1-编译驱动程序"><a href="#6-3-1-编译驱动程序" class="headerlink" title="6.3.1 编译驱动程序"></a>6.3.1 编译驱动程序</h3><p>在mathmodule.c和hello.c的同一目录下创建Makefile文件，Makefile文件内容如下（图6-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m := mathmodule.o</span><br><span class="line">obj-m += hello.o</span><br><span class="line"></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>图6-4</p>
<p>对于Makefile的内容注释已在上图进行添加，这里要注意的是在hello.c代码中使用了mathmodule.c所导出的符号，所以mathmodule.c要在hello.c之前进行编译，即第3行和第4行顺序不能交换。保存退出之后，来到相应的文件目录下，如下图（图6-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072017830.jpeg" alt="img"> </p>
<p>图6-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图6-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072017874.jpeg" alt="img"> </p>
<p>图6-6</p>
<p>编译完后会生成hello.ko和mathmodule.ko目标文件，如下图（图6-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072017866.jpeg" alt="img"> </p>
<p>图6-7</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的加载运行测试。</p>
<h3 id="6-3-2-运行测试"><a href="#6-3-2-运行测试" class="headerlink" title="6.3.2 运行测试"></a>6.3.2 运行测试</h3><p>这里要注意的是，由于 hello.ko依赖于mathmodule.ko，所以mathmodule.ko需要先加载，分别使用以下命令进行模块的加载（加载顺序不能变），如下（图6-8）所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">insmod mathmodule.ko</span><br><span class="line"></span><br><span class="line">insmod  hello.ko</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072017870.jpeg" alt="img"> </p>
<p>图6-8</p>
<p>可以看到 hello.ko驱动加载的时候，mathmodule.ko模块中定义的num参数值和调用sum()函数的后正确的返回值都被打印了出来。至此内核模块符号导出实验就完成了。</p>
<p>最后可以输入以下命令进行驱动的卸载，如下图（图6-9）所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmmod  hello.ko</span><br><span class="line"></span><br><span class="line">rmmod mathmodule.ko</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072017791.jpeg" alt="img"> </p>
<p>图6-9</p>
<p>注意：由于hello.ko文件使用了mathmodule.ko导出的符号，所以要先卸载hello.ko，卸载完成之后再卸载mathmodule.ko。</p>
<p>【最新驱动资料（文档+例程）】</p>
<p>链接 <a href="https://pan.baidu.com/s/1M4smUG2vw_hnn0Hye-tkog">https://pan.baidu.com/s/1M4smUG2vw_hnn0Hye-tkog</a></p>
<p>提取码：hbh6</p>
<p>【B 站配套视频】</p>
<p><a href="https://b23.tv/XqYa6Hm">https://b23.tv/XqYa6Hm</a></p>
<p>【RK3568 购买链接】</p>
<p><a href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-2245">https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-2245</a></p>
<p>2452613.11.2fec74a6elWNeA&amp;id&#x3D;669939423234</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-5-驱动模块传参实验</title>
    <url>/2023/09/05/1-5-%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E4%BC%A0%E5%8F%82%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>经过前两章实验的实战操作，我们已经完成最简单的helloworld驱动实验和模块驱动实验，加载模块可以使用“insmod”函数，使用“insmod”函数进行模块加载时也能进行参数的传递。运用得当可以极大提升内核测试速度。本节就来学习一下如何进行驱动模块的传参。</p>
<h2 id="5-1-驱动模块传参简介"><a href="#5-1-驱动模块传参简介" class="headerlink" title="5.1 驱动模块传参简介"></a>5.1 驱动模块传参简介</h2><p> 驱动模块传参是一种可以随时向内核模块传递、修改参数的方法。例如可以传递串口驱动的波特率、数据位数、校验位、停止位等参数，进行功能的设置，以此节省编译模块的时间，大大提高调试速度。</p>
<p> Linux内核提供了 module_param(name, type, perm)、module_param_array(name, type, nump, perm)宏和module_param_string(name, string, len, perm)宏，分别进行基本类型、数组和字符串参数的传递。它们定义在 “内核源码&#x2F;include&#x2F;linux&#x2F;moduleparam.h”文件中(在module.h文件中已经对export.h进行引用，所以不需要单独引用moduleparam.h文件),详细定义如下（图5-1）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> module_param(name, type, perm)              \</span></span><br><span class="line"><span class="meta">    module_param_named(name, name, type, perm)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_param_array(name, type, nump, perm)      \</span></span><br><span class="line"><span class="meta">module_param_array_named(name, name, type, nump, perm)  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_param_string(name, string, len, perm)            \</span></span><br><span class="line"><span class="meta">    static const struct kparam_string __param_string_##name     \                                                                                                                                                                                           </span></span><br><span class="line">        = &#123; len, <span class="built_in">string</span> &#125;;                  \</span><br><span class="line">    __module_param_call(MODULE_PARAM_PREFIX, name,          \</span><br><span class="line">                &amp;param_ops_string,              \</span><br><span class="line">                .str = &amp;__param_string_#<span class="meta">#name, perm, -1, 0);\</span></span><br><span class="line"><span class="meta">    __MODULE_PARM_TYPE(name, <span class="string">&quot;string&quot;</span>) </span></span><br></pre></td></tr></table></figure>

<p>图5-1</p>
<p>以上宏定义中的 module_param ()函数可以用来进行基本类型参数的传递，传入的三个参数定义如下：</p>
<ul>
<li>name：模块参数的名称</li>
<li>type： 模块参数的数据类型</li>
<li>perm： 模块参数的访问权限</li>
</ul>
<p>参数type可以取以下任意一种情况：</p>
<ul>
<li>bool <strong>:</strong> 布尔型</li>
<li>inbool <strong>:</strong> 布尔反值</li>
<li>charp**:** 字符指针（相当于char *,不超过1024字节的字符串）</li>
<li>short**:** 短整型</li>
<li>ushort <strong>:</strong> 无符号短整型</li>
<li>int <strong>:</strong> 整型</li>
<li>uint <strong>:</strong> 无符号整型</li>
<li>long <strong>:</strong> 长整型</li>
<li>ulong**:** 无符号长整型。</li>
</ul>
<p>参数perm表示该参数在sysfs文件系统中所对应的文件节点的属性，其权限定义在“内核源码&#x2F;include&#x2F;linux&#x2F;stat.h”文件中。可以用宏定义和数字法两种方式来表示。详细宏定义如下（图5-2）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRUSR 00400 <span class="comment">/*文件所有者可读*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWUSR 00200 <span class="comment">/*文件所有者可写*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXUSR 00100 <span class="comment">/*文件所有者可执行*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRGRP 00040 <span class="comment">/*与文件所有者同组的用户可读*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWGRP 00020 <span class="comment">/*与文件所有者同组的用户可写*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXGRP 00010 <span class="comment">/*与文件所有者同组的用户可执行*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IROTH 00004 <span class="comment">/*与文件所有者不同组的用户可读*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWOTH 00002 <span class="comment">/*与文件所有者不同组的用户可写*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXOTH 00001 <span class="comment">/*与文件所有者不同组的用户可可执行*/</span></span></span><br></pre></td></tr></table></figure>

<p>图5-2</p>
<p>如果要传递数组类型参数可以使用 module_param_array ()函数，相较于 module_param ()函数多了n_para参数，用来表示传递参数个数;n_para参数值会根据输入的参数个数而改变,n_para的最终值为传递的数组元素个数。</p>
<p>最后是 module_param_string(name, string, len, perm)函数，用来传递字符串类型的变量，四个参数的定义如下所示：</p>
<ul>
<li>name：外部传入的参数名，即加载模块时的传入值</li>
<li>string:内部的变量名，即程序内定义的参数名</li>
<li>len:以string命名的buffer大小(可以小于buffer的大小，但是没有意义)</li>
<li>perm:模块参数的访问权限</li>
</ul>
<p>至此，关于驱动模块传参所使用的函数就讲解完成了，在下一小节中将编写驱动模块传参函数代码。</p>
<h2 id="5-2-实验程序的编写"><a href="#5-2-实验程序的编写" class="headerlink" title="5.2 实验程序的编写"></a>5.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\02。</p>
<p>本章实验将编写Linux下的驱动传参实例代码，通过“insmod”命令进行参数的传递，并将相应的参数打印到串口终端上。</p>
<p>编写完成的parameter.c代码如下（图5-3）所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> number;<span class="comment">//定义int类型变量number</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *name;<span class="comment">//定义char类型变量name</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> para[<span class="number">8</span>];<span class="comment">//定义int类型的数组</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> str1[<span class="number">10</span>];<span class="comment">//定义char类型字符串str1</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> n_para;<span class="comment">//定义int类型的用来记录module_param_array函数传递数组元素个数的变量n_para</span></span><br><span class="line">module_param(number, <span class="type">int</span>, S_IRUGO);<span class="comment">//传递int类型的参数number，S_IRUGO表示权限为可读</span></span><br><span class="line">module_param(name, charp, S_IRUGO);<span class="comment">//传递char类型变量name</span></span><br><span class="line">module_param_array(para , <span class="type">int</span> , &amp;n_para , S_IRUGO);<span class="comment">//传递int类型的数组变量para</span></span><br><span class="line">module_param_string(str, str1 ,<span class="keyword">sizeof</span>(str1), S_IRUGO);<span class="comment">//传递字符串类型的变量str1</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">parameter_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;%d\n&quot;</span>,number);</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;%s\n&quot;</span>,name);                                                                                                                                                          </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n_para; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_EMERG <span class="string">&quot;para[%d] : %d \n&quot;</span>, i, para[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;%s\n&quot;</span>,str1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">parameter_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;parameter_exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(parameter_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(parameter_exit);<span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>); <span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>图5-3</p>
<p>以上代码将传递int类型参数number、char类型参数name、int类型的数组para和char类型字符串str1，并在驱动入口函数中，对各个参数进行打印。在下一小节会进行驱动加载测试。</p>
<h2 id="5-3-运行测试"><a href="#5-3-运行测试" class="headerlink" title="5.3 运行测试"></a>5.3 运行测试</h2><h3 id="5-3-1-编译驱动程序"><a href="#5-3-1-编译驱动程序" class="headerlink" title="5.3.1 编译驱动程序"></a>5.3.1 编译驱动程序</h3><p>在上一小节中的parameter.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图5-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += parameter.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>图5-4</p>
<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放parameter.c和Makefile文件目录下，如下图（图5-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072017518.jpeg" alt="img"> </p>
<p>图5-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图5-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072017541.jpeg" alt="img"> </p>
<p>图5-6</p>
<p>编译完生成 parameter.ko目标文件，如下图（图5-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072017448.jpeg" alt="img"> </p>
<p>图5-7</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h3 id="5-3-2-运行测试"><a href="#5-3-2-运行测试" class="headerlink" title="5.3.2 运行测试"></a>5.3.2 运行测试</h3><p>在上一章节中已经学习了使用insmod命令加载模块，而驱动模块传参的命令格式为</p>
<p>insmod 对应的模块 参数</p>
<p>parameter.ko 驱动加载可以传递3个参数，分别为int类型的参数number，char类型的参数name和int数组类型的参数para。使用以下命令进行驱动的加载，加载完成之后的打印信息如下图（图5-8）所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">insmod parameter.ko number=100 name=&quot;topeet&quot; para=0,1,2,3,4,5,6,7 str=&quot;itop&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072017522.jpeg" alt="img"> </p>
<p>图5-8</p>
<p>可以看到传递的参数都分别打印了出来。最后可以输入以下命令进行驱动的卸载，如下图（图5-9）所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmmod parameter.ko</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072017515.jpeg" alt="img"> </p>
<p>图5-9</p>
<p>【最新驱动资料（文档+例程）】</p>
<p>链接 <a href="https://pan.baidu.com/s/1M4smUG2vw_hnn0Hye-tkog">https://pan.baidu.com/s/1M4smUG2vw_hnn0Hye-tkog</a></p>
<p>提取码：hbh6</p>
<p>【B 站配套视频】</p>
<p><a href="https://b23.tv/XqYa6Hm">https://b23.tv/XqYa6Hm</a></p>
<p>【RK3568 购买链接】</p>
<p><a href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-2245">https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-2245</a></p>
<p>2452613.11.2fec74a6elWNeA&amp;id&#x3D;669939423234</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-4-内核模块实验</title>
    <url>/2023/09/05/1-4-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在上一章节我们编写了最简单的helloworld驱动程序。有了驱动程序以后，要如何编译并使用驱动呢。编译驱动有俩种方法，分别是将驱动编译成内核和将驱动编译成内核模块。我们先来学习如何将驱动编译成内核模块、</p>
<h1 id="4-1-设置交叉编译器"><a href="#4-1-设置交叉编译器" class="headerlink" title="4.1 设置交叉编译器"></a>4.1 设置交叉编译器</h1><p>1 下载网盘资料下的交叉编译器，网盘路径为：“XXX”，将下载的交叉编译器拷贝到Ubuntu的&#x2F;usr&#x2F;local目录下，如下图（图4-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016495.jpeg" alt="img"></p>
<p>图 4-1</p>
<p>2 输入以下命令，解压交叉编译编译器压缩包，解压完毕会生成“gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu”文件夹，这是实验需要的交叉编译工具，如下图（图4-2）所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -vxf gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016536.jpeg" alt="img"></p>
<p>图 4-2</p>
<p>3 在终端输入“sudo vi &#x2F;etc&#x2F;profile”命令，在文件最后输入以下命令修改环境变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016558.jpeg" alt="img"></p>
<p>图 4-3</p>
<p>4 保存退出，在终端输入“reboot”命令重新启动Ubuntu系统，使交叉编译环境生效。Ubuntu系统重新启动之后，登录到系统后，打开终端，输入命令“aarch64-linux-gnu-gcc -v”，如果终端有如下图（图4-4）所示的打印信息，说明交叉编译环境搭建成功。如果没有出现如下图（图4-4）的打印信息，需要检查上一步骤是否设置正确。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016623.jpeg" alt="img"></p>
<p>图 4-4</p>
<h1 id="4-2-编写Makefile"><a href="#4-2-编写Makefile" class="headerlink" title="4.2 编写Makefile"></a>4.2 编写Makefile</h1><p>编译驱动程序还需要使用Makefile文件。我们为helloworld.c编写一个简单的Makefile，Makefile文件和源文件helloworld.c位于同一级目录，代码如下（图4-5）所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64  </span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-  </span><br><span class="line">obj-m += helloworld.o    <span class="comment">#helloworld.c对应.o文件的名称。名称要保持一致。</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#内核源码所在虚拟机ubuntu的实际路径</span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>图 4-5</p>
<p>代码解释如下：</p>
<ul>
<li>第1行设置ARCH变量为arm64</li>
<li>第2行设置交叉编译器前缀为aarch64-linux-gnu-</li>
<li>第3行obj-m +&#x3D; &lt;文件&gt;：将指定的文件（需要是以.o结尾）设为编译时以模块形式编译</li>
<li>第4行是设备树内核的源码路径，请大家根据实际内核路径进行修改。</li>
<li>第5行是获取当前目录的变量</li>
<li>第7行是编译make操作，会进入内核源码的路径，然后把当前路径下的代码编译成模块。</li>
<li>第9行是清除编译文件</li>
</ul>
<p>编写完成如下图（图4-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016516.jpeg" alt="img"></p>
<p>图 4-6</p>
<p>4.3 编译模块</p>
<p>有了Makefile以后，输入“make”命令就可以编译helloworld驱动模块，如下图（图4-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016524.jpeg" alt="img"></p>
<p>图 4-7</p>
<p>编译完生成helloworld.ko目标文件就是我们需要的内核模块。内核模块是以ko为后缀名，如下图（图4-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016931.jpeg" alt="img"></p>
<p>图 4-8</p>
<p>输入“make clean”命令清除编译文件，如下图（图4-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016990.jpeg" alt="img"></p>
<p>图 4-9</p>
<h1 id="4-4-模块加载与卸载"><a href="#4-4-模块加载与卸载" class="headerlink" title="4.4 模块加载与卸载"></a>4.4 模块加载与卸载</h1><p>有了内核模块以后，我们要如何使用呢？编译驱动有俩种方式，那Linux驱动的运行方式也肯定有俩种。一种就是将驱动编译进内核，这样Linux系统启动后会自动运行程序。第二种就是将驱动编译成模块，在Linux系统启动以后使用“insmod”命令加载驱动模块。</p>
<p>在上个小节中编译了驱动模块helloworld.ko，在RK3568开发板上通过“insmod helloworld.ko”命令可以加载驱动，在加载驱动模块的时候会执行驱动入口的函数，也就是helloworld程序中的helloworld_init函数，所以可以看到打印出来的字符串信息“helloworld_init”。如下图（图4-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016987.jpeg" alt="img"></p>
<p>图 4-10</p>
<p>如果要卸载helloworld内核模块，可以通过“rmmod helloworld”命令来卸载驱动模块，同理在卸载驱动模块的时候会执行驱动出口的函数，所以可以看到驱动出口函数打印出来的字符串信息“helloworld_exit”，如下图（图4-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016982.jpeg" alt="img"></p>
<p>图 4-11</p>
<p>加载驱动模块也可以使用modprobe命令，它比insmod命令更强大，modprobe命令在加载驱动模块的时候，会同时加载该模块依赖的其他模块。比如helloworld.ko依赖before.ko，使用insmod加载的时候，就必须先加载before.ko，然后在加载helloworld.ko才可以加载成功从。但是使用modprobe加载的时候，他会自动分析模块的依赖关系，然后将所有的依赖的模块都加载到内核当中。比较“聪明”。</p>
<p>同样，在卸载驱动模块的时候，如果模块存在依赖关系，如果使用insmod命令，需要手动卸载依赖的内核模块，但是使用modprobe命令可以自动卸载驱动模块所依赖的其他模块。</p>
<p>所以，如果驱动模块是以“modprobe helloworld.ko”命令加载的，卸载的时候使用“modprobe -r helloworld.ko”命令卸载。</p>
<p>但是使用modprobe卸载存在一个问题，如果所依赖的模块被其他模块所使用，比如刚才例子中的before.ko还被其他的模块使用，这时候就不能使用modprobe卸载。所以还是推荐使用rmmod命令来卸载。</p>
<h1 id="4-5查看模块信息"><a href="#4-5查看模块信息" class="headerlink" title="4.5查看模块信息"></a>4.5查看模块信息</h1><p>在驱动模块加载之后，使用“modinfo helloworld.ko”命令可以获得模块的信息，包括模块作者，模块说明，模块支持的参数等等。</p>
<p>lsmod 命令可以列出已经载入Linux内核模块，在helloworld驱动加载之后，查看内核中加载的模块，如下（图4-12）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016996.jpeg" alt="img"></p>
<p>图 4-12</p>
<p>【最新驱动资料（文档+例程）】</p>
<p>链接 <a href="https://pan.baidu.com/s/1M4smUG2vw_hnn0Hye-tkog">https://pan.baidu.com/s/1M4smUG2vw_hnn0Hye-tkog</a></p>
<p>提取码：hbh6</p>
<p>【B 站配套视频】</p>
<p><a href="https://b23.tv/XqYa6Hm">https://b23.tv/XqYa6Hm</a></p>
<p>【RK3568 购买链接】</p>
<p><a href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-2245">https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-2245</a></p>
<p>2452613.11.2fec74a6elWNeA&amp;id&#x3D;669939423234</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-3-helloworld 驱动实验</title>
    <url>/2023/09/05/1-3-helloworld-%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在学习C语言或者其他语言的时候，我们通常是打印一句“helloworld”来开启编程世界的大门。学习驱动程序编程亦可以如此，使用helloworld作为我们的第一个驱动程序。</p>
<p>接下来开始编写第一个驱动程序—helloworld。</p>
<h1 id="3-1-驱动编写"><a href="#3-1-驱动编写" class="headerlink" title="3.1 驱动编写"></a>3.1 驱动编写</h1><p>本小节来编写一个最简单的驱动——helloworld驱动。helloworld.c如下（图3-1）所示代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);<span class="comment">//注意：内核打印用printk而不是printf</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);    <span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(helloworld_exit);    <span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    <span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);    <span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>看似非常简单的helloworld驱动代码，却五脏俱全。一个简单的helloworld驱动包含驱动的基本框架。我们继续往下看。</p>
<h1 id="3-2-驱动的基本框架"><a href="#3-2-驱动的基本框架" class="headerlink" title="3.2 驱动的基本框架"></a>3.2 驱动的基本框架</h1><p>Linux驱动的基本框架主要由模块加载函数，模块卸载函数，模块许可证声明，模块参数，模块导出符号，模块作者信息等几部分组成，其中模块参数，模块导出符号，模块作者信息是可选的部分，也就是可要可不要。剩余部分是必须有的。我们来看一下这几个部分的作用：</p>
<p>1 模块加载函数</p>
<p>​	当使用加载驱动模块时，内核会执行模块加载函数，完成模块加载函数中的初始化工作。</p>
<p>2 模块卸载函数</p>
<p>​	当卸载某模块时，内核会执行模块卸载函数，完成模块卸载函数中的退出工作。</p>
<p>3 模块许可证声明</p>
<p>​	许可证声明描述了内核模块的许可权限，如果不声明模块许可，模块在加载的时候，会收到“内核被污染（kernel tainted）”的警告。可接受的内核模块声明许可包括“GPL”“GPL v2”。</p>
<p>4 模块参数（可选择）</p>
<p>​	模块参数是模块被加载的时候可以传递给它的值。</p>
<p>5 模块导出符号（可选择）</p>
<p>​	内核模块可以导出的符号，如果导出，其他模块可以使用本模块中的变量或函数。</p>
<p>6 模块作者信息等说明（可选择）</p>
<p>上一小节我们说，helloworld驱动麻雀虽小五脏俱全，我们来分析helloworld驱动。通过helloworld代码再来看驱动框架。</p>
<p>（1）模块加载函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">module_init(helloworld_init);    <span class="comment">//注册入口函数</span></span><br></pre></td></tr></table></figure>

<p>（2）模块卸载函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_exit(helloworld_exit);    <span class="comment">//注册出口函数</span></span><br></pre></td></tr></table></figure>

<p>（3）模块许可证声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    <span class="comment">//同意GPL开源协议</span></span><br></pre></td></tr></table></figure>

<p>（4）模块作者信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);    <span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>（5）头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">//模块加载函数和卸载函数需要的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>通过上面的分析，helloworld驱动是不是包含了驱动框架的所有必要的部分呢。因此helloworld驱动我们可以看作是驱动代码的模板。任何一个驱动代码都用它作为基础来编写实现。同学们要将他记忆下来！</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-2-你好内核源码</title>
    <url>/2023/09/05/1-2-%E4%BD%A0%E5%A5%BD%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本章我们来认识Linux内核源码，开始真正进入到驱动的世界里面，不知道各位小伙伴们有没有做好准备呢？</p>
<h1 id="2-1-初识内核源码"><a href="#2-1-初识内核源码" class="headerlink" title="2.1 初识内核源码"></a>2.1 初识内核源码</h1><p>Linux内核源码的官方网站为<a href="https://www.kernel.org/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%AF%A5%E7%BD%91%E7%AB%99%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%9A%84Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E3%80%82%E8%BF%9B%E5%85%A5%E8%AF%A5%E7%BD%91%E7%AB%99%E4%B9%8B%E5%90%8E%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%88%E5%9B%BE2-1%EF%BC%89%E6%89%80%E7%A4%BA%EF%BC%9A">https://www.kernel.org/，可以在该网站下载最新的Linux内核源码。进入该网站之后如下图（图2-1）所示：</a></p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016728.jpeg" alt="img"> </p>
<p>图 2-1</p>
<p>从上图（图1）可以看到多个版本的内核分支，分别为主线版本（mainline）、稳定版本（stable）和长期支持版本（longterm）。以上各个支线和主线是由linus torvalds（Linux之父）所领导。半导体厂商和一些内核爱好者会在官网下载相应版本的内核源码，对该源码进行打补丁等操作。以此让官网的内核源码可以在半导体厂家设计的主控（CPU）上跑起来，所以在开发和学习的过程中，我们并不会直接去Linux内核官网下去下载源码，而且是使用半导体厂家提供的源码包。</p>
<p>但是不论是Linux官网的内核源码还是半导体厂家提供的内核源码不影响我们来看它的庐山真面目！作者下载了Linux官方网站的4.19.262分支源码，下载好的源码存放在“iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\01_Linux内核官方源码”如下图（图2-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016714.jpeg" alt="img"> </p>
<p>图 2-2</p>
<p>将Linux内核官方源码拷贝到虚拟机ubuntu上如下图（图2-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016708.jpeg" alt="img"> </p>
<p>图 2-3</p>
<p>使用以下命令对内核官方源码进行解压，解压完成如下图（图2-4）所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tar -vxf linux-4.19.262.tar.xz </span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016773.jpeg" alt="img"> </p>
<p>图 2-4</p>
<p>解压完成后我们会看到非常多的文件夹，这些文件夹放的就是Linux内核源码，在下一小节中作者来介绍Linux内核源码的结构和每个目录的作用。</p>
<h1 id="2-2-内核源码结构"><a href="#2-2-内核源码结构" class="headerlink" title="2.2 内核源码结构"></a>2.2 内核源码结构</h1><p>上一小节解压的目录下的内核源码目录都是用来做什么的呢？如下图（图2-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016717.jpeg" alt="img"> </p>
<p>图 2-5</p>
<p>目录的内容如下表（表2-6）所示：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>arch</td>
<td>存放不同平台体系相关代码</td>
</tr>
<tr>
<td>block</td>
<td>存放块设备相关代码</td>
</tr>
<tr>
<td>crypto</td>
<td>存放加密、压缩、CRC校验等算法相关代码</td>
</tr>
<tr>
<td>Documentation</td>
<td>存放相关说明文档，很多实用文档，包括驱动编写等</td>
</tr>
<tr>
<td>drivers</td>
<td>存放Linux 内核设备驱动程序源码。该目录包含众多驱动，目录按照设备类别进行分类，如 char、block 、input、i2c、spi、pci、usb等。</td>
</tr>
<tr>
<td>firmware</td>
<td>存放处理器相关的一些特殊固件</td>
</tr>
<tr>
<td>fs</td>
<td>存放虚拟文件系统代码</td>
</tr>
<tr>
<td>include</td>
<td>存放内核所需、与平台无关的头文件</td>
</tr>
<tr>
<td>init</td>
<td>Linux系统启动初始化相关的代码</td>
</tr>
<tr>
<td>ipc</td>
<td>存放进程间通信代码</td>
</tr>
<tr>
<td>kernel</td>
<td>Linux内核的核心代码，包含了进程调度子系统，以及和进程调度相关的模块。</td>
</tr>
<tr>
<td>lib</td>
<td>库文件代码， 实现需要在内核中使用的库函数，例如CRC、FIFO、list、MD5等。</td>
</tr>
<tr>
<td>mm</td>
<td>实现存放内存管理代码</td>
</tr>
<tr>
<td>net</td>
<td>存放网络相关代码</td>
</tr>
<tr>
<td>samples</td>
<td>存放提供的一些内核编程范例</td>
</tr>
<tr>
<td>scripts</td>
<td>存放一些脚本文件</td>
</tr>
<tr>
<td>security</td>
<td>存放系统安全性相关代码</td>
</tr>
<tr>
<td>sound</td>
<td>存放声音、声卡相关驱动</td>
</tr>
<tr>
<td>tools</td>
<td>一些常用工具，如性能剖析、自测试等</td>
</tr>
<tr>
<td>usr</td>
<td>用于生成initramfs的代码。</td>
</tr>
<tr>
<td>virt</td>
<td>提供虚拟机技术（KVM等）的支持</td>
</tr>
</tbody></table>
<p>表 2-6</p>
<h1 id="2-3-编译内核源码"><a href="#2-3-编译内核源码" class="headerlink" title="2.3 编译内核源码"></a>2.3 编译内核源码</h1><p>本小节使用的内核源码是半导体厂家提供的内核源码，是我们学习和开发要使用的内核源码。在进行驱动学习之前需要将此内核源码编译成功。</p>
<p>内核源码存放路径为“iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\02_Linux_SDK源码”，将对应目录下的内核源码拷贝到虚拟机ubuntu目录下，如下图（图2-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016704.jpeg" alt="img"></p>
<p>图 2-7</p>
<p>注：编译环境使用的是迅为搭建好的编译环境，迅为的环境经过测试在不进行修改的前提下，可以直接将内核源码编译通过。</p>
<p>使用以下命令对内核源码的进行解压，解压完成如下图（图2-8）所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -vxf linux_sdk.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016104.jpeg" alt="img"></p>
<p>图 1-8</p>
<p>使用“cd linux_sdk”命令进入内核源码目录，如下图（图2-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016124.jpeg" alt="img"></p>
<p>图 2-9</p>
<p>使用命令“.&#x2F;build.sh kernel”进行内核源码的编译，编译过程如下图（图2-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016152.jpeg" alt="img"></p>
<p>图 2-10</p>
<p>编译时间和电脑虚拟机配置相关，编译完成如下图（图2-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016179.jpeg" alt="img"></p>
<p>图 2-11</p>
<p>通过对内核源码官网的探索，内核源码的目录结构讲解以及内核源码的编译。我相信大家对Linux内核源码应该有了一个初步的认识了。下一章我们来学习第一个驱动helloworld。</p>
<p>【最新驱动资料（文档+例程）】</p>
<p>链接 <a href="https://pan.baidu.com/s/1M4smUG2vw_hnn0Hye-tkog">https://pan.baidu.com/s/1M4smUG2vw_hnn0Hye-tkog</a></p>
<p>提取码：hbh6</p>
<p>【B 站配套视频】</p>
<p><a href="https://b23.tv/XqYa6Hm">https://b23.tv/XqYa6Hm</a></p>
<p>【RK3568 购买链接】</p>
<p><a href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-2245">https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-2245</a></p>
<p>2452613.11.2fec74a6elWNeA&amp;id&#x3D;669939423234</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>3.22-u-boot重定位分析(下)</title>
    <url>/2023/09/05/3-22-u-boot%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90-%E4%B8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-22-1-U-boot启动前期为什么可以直接在0x0起始地址运行"><a href="#3-22-1-U-boot启动前期为什么可以直接在0x0起始地址运行" class="headerlink" title="3.22.1 U-boot启动前期为什么可以直接在0x0起始地址运行?"></a>3.22.1 U-boot启动前期为什么可以直接在0x0起始地址运行?</h1><p>在某些系统中，U-Boot 可以直接从地址 0x0 处执行的原因是由于处理器的启动过程和内存映射的特殊性。</p>
<p>在处理器上电或复位后，处理器会跳转到一个预定义的启动地址开始执行代码。对于某些处理器架构，例如 ARM 架构中的 Cortex-M 系列处理器，其启动地址通常是固定的，即地址 0x0。</p>
<p>此时，处理器处于特权模式（例如 SVC 模式），并且还没有启用内存管理单元（MMU）和缓存。因此，此阶段的代码执行在物理地址上，可以直接访问系统的内存和外设。</p>
<p>U-Boot 在启动前期的代码中，主要是进行一些基本的初始化工作，例如设置中断向量表、关闭缓存、关闭 MMU、初始化时钟和外设等。这些操作并不依赖于虚拟地址空间或完整的操作系统环境。</p>
<p>在 U-Boot 启动过程的后期，会进行重定位操作，将 U-Boot 的代码从 Flash 或其他存储器中复制到 RAM 中，并更新相关的地址。此时，处理器会启用 MMU，并将代码和数据映射到虚拟地址空间中。</p>
<p>因此，U-Boot 可以在启动前期直接从地址 0x0 处执行，而不会产生内存访问冲突或其他问题。这种设计可以简化启动流程，并避免在启动早期的阶段涉及复杂的内存映射和地址转换操作。</p>
<h1 id="3-22-2-动态链接"><a href="#3-22-2-动态链接" class="headerlink" title="3.22.2 动态链接"></a>3.22.2 动态链接</h1><p>动态链接是一种在程序运行时进行的链接方式，它允许程序在加载和执行时动态地解析和链接外部的共享库（或动态链接库）。在 U-Boot 中采用的动态链接方式可能与传统操作系统中的动态链接有所不同，这取决于具体的实现和目标平台。</p>
<p>以下是一些与 U-Boot 中动态链接相关的概念和技术：</p>
<ol>
<li>位置无关代码（Position Independent Code，PIC）：这是一种编译方式，生成的代码可以在内存中的任意位置加载和执行，而不依赖于固定的地址。位置无关代码通常使用相对寻址方式，以便在重定位时能够适应不同的加载地址。</li>
<li>全局偏移表（Global Offset Table，GOT）：GOT 是一个数据结构，存储了程序中使用的全局符号（如函数或变量）的地址。在 U-Boot 中，GOT 可能放置在数据段中，并使用相对寻址方式进行访问。</li>
<li>文字池（Literal Pool）：文字池是一个存储常量数据的区域，通常包括字符串字面量、常量表达式等。文字池可以用于存储需要重定位的常量数据，并在运行时进行访问。</li>
<li>符号表（Symbol Table）和重定位符号表（Relocation Symbol Table）：这些表记录了程序中使用的符号和对应的重定位信息。在动态链接过程中，符号表和重定位符号表被用于解析和重定位外部共享库中的符号。</li>
<li>基址重置（R_ARM_RELATIVE）：基址重置是一种重定位方式，用于将位置无关代码中的相对地址转换为绝对地址。在 U-Boot 中，基址重置可能是一种常见的重定位方式，用于修正位置无关代码中的相对地址。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.21-u-boot重定位分析(上)</title>
    <url>/2023/09/05/3-21-u-boot%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90-%E4%B8%8A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-20-1-U-Boot-启动方式"><a href="#3-20-1-U-Boot-启动方式" class="headerlink" title="3.20.1 U-Boot 启动方式"></a>3.20.1 U-Boot 启动方式</h1><p>下面是关于 U-Boot 启动方式的解释：</p>
<p>U-Boot 是一种开源的引导加载程序，用于在嵌入式系统上启动操作系统。它具有广泛的硬件支持和灵活的配置选项。U-Boot 可以从多种存储介质启动，包括 NAND、NOR、SD 卡和 SDRAM。</p>
<ol>
<li>NAND 启动：<br>NAND 闪存是一种非易失性存储介质，常用于嵌入式系统中。当 U-Boot 从 NAND 启动时，它会从 NAND 闪存芯片读取引导程序（bootloader）并执行。</li>
<li>NOR 启动：<br>NOR 闪存是另一种常见的非易失性存储介质，通常用于存储 U-Boot。在 NOR 启动方式下，U-Boot 位于 NOR 闪存中，并且系统会直接从 NOR 闪存中加载和执行 U-Boot。</li>
<li>SD 卡启动：<br>SD 卡是一种可移动存储介质，常用于嵌入式系统中。当 U-Boot 从 SD 卡启动时，它会从 SD 卡中读取引导程序并执行。</li>
<li>SDRAM 启动：<br>SDRAM 是系统内存，U-Boot 可以从 SDRAM 启动。在 SDRAM 启动方式下，U-Boot 首先加载到 SDRAM 中，然后执行。</li>
</ol>
<p>在启动过程中，U-Boot 需要知道引导程序的存储位置和大小。根据您提供的信息，我理解以下是相关的地址范围和存储介质：</p>
<ul>
<li>NAND：存储介质为 NAND 闪存。</li>
<li>NOR：存储介质为 NOR 闪存。</li>
<li>SD 卡：存储介质为 SD 卡。</li>
<li>SDRAM：存储介质为系统内存。</li>
</ul>
<h1 id="3-20-2-U-Boot生成文件的一般过程："><a href="#3-20-2-U-Boot生成文件的一般过程：" class="headerlink" title="3.20.2 U-Boot生成文件的一般过程："></a>3.20.2 U-Boot生成文件的一般过程：</h1><p>在 U-Boot 的编译过程中，会生成不同的文件，其中包括以下常见的文件格式：</p>
<ul>
<li>ELF 格式：U-Boot 的主要可执行文件通常以 ELF（Executable and Linkable Format）格式存储。ELF 文件包含了可执行代码、数据和符号表等信息，可用于调试和符号解析。</li>
<li>BIN 格式：U-Boot 还可以使用 objcopy 工具将 ELF 格式的可执行文件转换为 BIN（Binary）格式。BIN 格式是一种简化的二进制文件格式，它只包含可执行代码，没有调试信息和符号表。</li>
<li>Symbol 文件：U-Boot 生成的符号文件（例如 u-boot.sym）包含了代码中定义的符号信息，这对于调试和符号解析非常有用。符号文件通常与 ELF 格式文件一起使用。</li>
<li>System.map 文件：U-Boot 在编译过程中还会生成 System.map 文件，它包含了 U-Boot 的符号表和地址映射信息。</li>
</ul>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309070727839.png" alt="image-20230907072726729"></p>
<h1 id="3-20-3-uboot镜像依赖关系"><a href="#3-20-3-uboot镜像依赖关系" class="headerlink" title="3.20.3 uboot镜像依赖关系"></a>3.20.3 uboot镜像依赖关系</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u-boot-init -&gt; start.o -&gt; u-boot-main -&gt; built-in.o -&gt; u-boot.lds</span><br></pre></td></tr></table></figure>

<p>解释如下：</p>
<ol>
<li><code>u-boot-init</code>：这是一个初始文件或函数，可能包含一些启动代码或初始化代码。</li>
<li><code>start.o</code>：这是一个目标文件，位于 <code>arch/arm/cpul/armv7</code> 目录中。它可能包含与 ARMv7 架构相关的启动代码。</li>
<li><code>u-boot-main</code>：这是一个主要的 U-Boot 文件或函数，可能包含 U-Boot 的核心功能。</li>
<li><code>built-in.o</code>：这是一个目标文件，位于 <code>xx/xxx</code> 目录中。它可能包含 U-Boot 中的一些功能模块或驱动程序。</li>
<li><code>u-boot.lds</code>：这是 U-Boot 的链接脚本文件，用于指定链接器如何将目标文件组合成最终的可执行镜像。</li>
</ol>
<h1 id="3-20-4-uboot启动流程"><a href="#3-20-4-uboot启动流程" class="headerlink" title="3.20.4 uboot启动流程"></a>3.20.4 uboot启动流程</h1><p>U-Boot 的启动流程可以大致描述如下：</p>
<ol>
<li>硬件上电或复位后，处理器会跳转到预定义的启动地址，通常是 SoC 内部的 ROM 或 Flash 存储器中的特定位置。</li>
<li>启动地址处的代码通常是一段汇编代码，用于设置处理器的初始状态和寄存器，然后跳转到 U-Boot 的入口点。</li>
<li>在 U-Boot 的入口点，首先执行的是 <code>arch/arm/lib/vectors.S</code> 文件中的 <code>reset</code> 函数。该函数主要完成一些处理器和中断控制器的初始化工作。</li>
<li><code>reset</code> 函数会调用 <code>arch/arm/cpu/armv7/start.S</code> 文件中的 <code>mair_init</code> 函数。<code>mair_init</code> 主要用于设置内存访问控制和缓存配置等相关设置。</li>
<li>接下来，<code>mair_init</code> 函数会调用 <code>arch/arm/lib/crt0.S</code> 文件中的 <code>relocate_code</code> 函数。<code>relocate_code</code> 函数负责将 U-Boot 的代码从其加载地址（通常是 Flash 存储器）复制到 RAM 中，并更新相关的地址。</li>
<li>在 <code>relocate_code</code> 函数执行完毕后，控制权将转移到 U-Boot 的入口函数（通常是 <code>board_init_f</code> 或 <code>main_loop</code> 函数），从而开始执行 U-Boot 的主要功能。</li>
</ol>
<h1 id="3-20-5-重定位之前准备工作"><a href="#3-20-5-重定位之前准备工作" class="headerlink" title="3.20.5 重定位之前准备工作"></a>3.20.5 重定位之前准备工作</h1><p>在 U-Boot 的重定位之前，通常会进行一些准备工作。根据您提供的信息，这些准备工作可能包括以下内容：</p>
<p>在 <code>start.S</code> 文件中：</p>
<ul>
<li>设置 CPU 为 SVC（Supervisor）模式。</li>
<li>关闭缓存和关闭 MMU（Memory Management Unit）。</li>
<li>设置关门狗（Watchdog）、屏蔽中断、设置时钟等初始化操作。</li>
<li>初始化 SDRAM（同步动态随机存取存储器）。</li>
</ul>
<p>在 <code>crt0.S</code> 文件中：</p>
<ul>
<li>初始化 C 语言运行环境，包括堆栈设置等。</li>
<li>进行板级各种初始化操作，例如初始化 NAND、SDRAM 等外设。</li>
<li>初始化全局结构体变量 GD（Global Data），并在 GD 中保存 U-Boot 的实际加载地址。</li>
<li>调用 <code>relocate_code</code> 函数，将 U-Boot 镜像从 Flash 拷贝到内存中。</li>
<li>从 Flash 跳转到 RAM 空间，继续执行 U-Boot 程序。</li>
<li>清零 BSS 段（未初始化的全局变量）、进行板级初始化操作。</li>
<li>最后进入 <code>bootcmd</code> 或 <code>main_loop</code> 循环，执行 U-Boot 的主要功能。</li>
</ul>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.20-linux内核加载实验</title>
    <url>/2023/09/05/3-20-linux%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BD%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-20-1-Linux内核启动"><a href="#3-20-1-Linux内核启动" class="headerlink" title="3.20.1 Linux内核启动"></a>3.20.1 Linux内核启动</h1><p>U-Boot（Universal Bootloader）是一种常用的开源引导加载程序，用于启动嵌入式系统。它提供了多种启动方式和引导镜像格式支持。下面是关于U-Boot启动过程的一些说明：</p>
<ol>
<li>Linux内核启动：<br>U-Boot负责加载和启动Linux内核。它可以通过不同的启动方式加载内核，包括TFTP（通过网络下载）、NAND（闪存）、NOR（闪存）、SD卡等。具体的启动方式取决于硬件平台和配置。</li>
<li>U-Boot使用bootm引导uImage：<br>U-Boot通常使用bootm命令来引导uImage格式的内核镜像。uImage是一种特定的内核镜像格式，它包含了内核映像以及内核启动参数（如命令行参数、设备树等）。</li>
<li>使用bootz引导zImage：<br>另一种常见的内核镜像格式是zImage。与uImage不同，zImage是一种压缩的内核镜像格式。U-Boot可以使用bootz命令来引导zImage格式的内核镜像。bootz命令会在引导之前对zImage进行解压缩，并提供内核启动参数。</li>
</ol>
<p>总结来说，U-Boot作为引导加载程序，负责启动嵌入式系统。它支持多种启动方式（如TFTP、NAND、NOR、SD卡）和不同的内核镜像格式（如uImage、zImage），以适应不同的硬件平台和需求。在启动过程中，U-Boot加载内核镜像并提供必要的参数，然后将控制权转交给Linux内核，完成系统的启动。</p>
<h1 id="3-20-2-内核镜像编译"><a href="#3-20-2-内核镜像编译" class="headerlink" title="3.20.2 内核镜像编译"></a>3.20.2 内核镜像编译</h1><p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062209558.png" alt="image-20230906220939457"></p>
<p>编译内核镜像的过程通常包括以下步骤：</p>
<ol>
<li><p>ELF文件（vmlinux）：<br>内核源代码编译生成的主要输出是一个名为vmlinux的ELF文件。这个文件包含了内核的所有代码和符号，并且链接地址通常设置为0x80008000。</p>
</li>
<li><p>objcopy：<br>使用objcopy工具，可以将vmlinux文件转换为其他格式的镜像。在这个过程中，可以使用参数-l指定链接地址（load address），例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objcopy -O binary -R .note -R .comment -S vmlinux vmlinux.bin</span></span><br><span class="line">```</span><br><span class="line">这个命令将vmlinux文件转换为原始的二进制内核镜像（vmlinux.bin），同时删除了.note和.comment节（section）。</span><br></pre></td></tr></table></figure>
</li>
<li><p>gzip压缩：<br>为了减小内核镜像的大小，通常会对二进制内核镜像进行压缩。使用gzip工具可以对vmlinux.bin进行压缩，生成压缩的二进制内核镜像。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gzip -9 -c vmlinux.bin &gt; vmlinux.gz</span></span><br><span class="line">```</span><br><span class="line">这个命令将vmlinux.bin压缩为vmlinux.gz。</span><br></pre></td></tr></table></figure>
</li>
<li><p>自解压运行：<br>压缩的二进制内核镜像（vmlinux.gz）需要进行自解压运行。这涉及到一些特定的代码和链接过程。</p>
<ul>
<li><p>head.o、misc.o、decompress.o和piggz.gzip.o是与自解压相关的一些目标文件，它们包含了自解压运行所需的代码。</p>
</li>
<li><p>链接过程将这些目标文件与原始的vmlinux文件链接在一起，生成一个新的ELF文件（vmlinux）。</p>
</li>
<li><p>使用objcopy工具，将这个新的vmlinux文件转换为raw binary格式的镜像。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ objcopy -O binary -R .note -R .comment -S vmlinux vmlinux.raw</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>mkimage：<br>使用mkimage工具，可以将raw binary格式的镜像（vmlinux.raw）转换为uImage格式的镜像（uImage）。这个过程包括添加头部信息、校验和等操作。具体使用方法可以根据所使用的工具和平台进行调整。</p>
</li>
</ol>
<p>总结来说，内核镜像的编译过程包括将ELF文件转换为原始二进制内核镜像，压缩内核镜像，进行自解压运行的链接和处理，最后生成uImage格式的镜像。这样的过程可以根据具体的平台和需求进行调整和扩展。</p>
<h1 id="3-20-3-内核编译的几个关键地址"><a href="#3-20-3-内核编译的几个关键地址" class="headerlink" title="3.20.3 内核编译的几个关键地址"></a>3.20.3 内核编译的几个关键地址</h1><ol>
<li>LOADADDR（ulmage指定加载地址）：<br>LOADADDR是用于指定uImage格式的内核镜像在内存RAM中的加载地址。在U-Boot中，uImage会被加载到指定的LOADADDR地址处。</li>
<li>PHYS_OFFSET（RAM物理内存起始地址）：<br>PHYS_OFFSET是指内核在物理内存中的起始地址。它表示RAM的物理内存的起始位置。</li>
<li>PAGE_OFFSET（内核虚拟内存空间起始地址）：<br>PAGE_OFFSET是指内核在虚拟内存中的起始地址。它决定了内核虚拟地址空间的起始位置。通常情况下，它被设置为0xC0000000（3GB用户空间+1GB内核空间）。在某些平台（如vexpress开发板）上，PAGE_OFFSET可能被设置为0x80000000。</li>
<li>TEXT_OFFSET（内核起始地址相对于RAM地址的偏移）：<br>TEXT_OFFSET是指内核代码在RAM地址中的偏移量。它表示内核代码相对于物理内存的偏移。在arm架构中，一般将TEXT_OFFSET设置为0x8000。这个值在arch&#x2F;arm&#x2F;Makefile中定义。</li>
<li>TEXTADDR（内核镜像启动的虚拟地址）：<br>TEXTADDR是内核编译时使用的链接地址。在运行时，内核镜像会被加载到PAGE_OFFSET+TEXT_OFFSET的地址处执行。</li>
<li>ZRELADDR（内核镜像启动的物理地址）：<br>ZRELADDR是指zImage格式的内核镜像的启动物理地址。zImage启动时，真正的内核代码会被解压到ZRELADDR地址，并从该地址处开始执行。</li>
<li>ZTEXTADDR（zImage运行物理地址）：<br>ZTEXTADDR是指zImage格式的内核镜像运行的物理地址。如果LOADADDR没有定义，U-Boot会将uImage加载到ZTEXTADDR地址处。这个地址空间可以是RAM或NOR FLASH的地址空间。</li>
</ol>
<h1 id="3-20-4-ulmage制作"><a href="#3-20-4-ulmage制作" class="headerlink" title="3.20.4 ulmage制作"></a>3.20.4 ulmage制作</h1><p>制作ulmage（uImage格式的内核镜像）可以使用mkimage工具，该工具位于U-Boot源码的tools目录下。下面是使用mkimage命令制作ulmage的示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mkimage -A arm -O linux -T kernel -C none -a 0x60003000 -e 0x60003000 -d zlmage ulmage</span></span><br></pre></td></tr></table></figure>

<p>这个命令的参数说明如下：</p>
<ul>
<li><code>-A arm</code>：指定CPU类型为ARM，根据实际情况选择正确的CPU类型。</li>
<li><code>-O linux</code>：指定操作系统为Linux。</li>
<li><code>-T kernel</code>：指定镜像类型为内核。</li>
<li><code>-C none</code>：指定压缩方式为无压缩。</li>
<li><code>-a 0x60003000</code>：指定内核加载地址（LOADADDR）。</li>
<li><code>-e 0x60003000</code>：指定内核入口地址（ENTRYADDR）。</li>
<li><code>-d zlmage</code>：指定输入的zImage格式的内核镜像文件。</li>
<li><code>ulmage</code>：指定输出的uImage格式的内核镜像文件。</li>
</ul>
<p>这样，mkimage工具会在当前目录下生成ulmage文件，该文件是uImage格式的内核镜像，包含了一个40字节的数据头记录了加载地址、入口地址、文件大小、CPU架构等信息。</p>
<h1 id="3-20-5-运行zlmage"><a href="#3-20-5-运行zlmage" class="headerlink" title="3.20.5 运行zlmage"></a>3.20.5 运行zlmage</h1><p>要运行zlmage（zImage格式的内核镜像），需要以下目标文件的支持：piggz.gzip.o、decompress.o、misc.o和head.o。</p>
<p>这些目标文件涉及到自解压过程，其中piggz.gzip.o用于gzip解压算法，decompress.o用于通用的解压算法，misc.o和head.o包含了与自解压相关的代码。</p>
<p>在运行zlmage之前，需要将这些目标文件与zlmage链接在一起，生成一个新的ELF文件。然后，将这个新的ELF文件转换为raw binary格式的镜像，以便在运行时执行。</p>
<p>具体的步骤如下：</p>
<ol>
<li><p>将zlmage与目标文件链接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ld -Ttext 0x80008000 -o vmlinux.elf zlmage piggz.gzip.o decompress.o misc.o head.o</span></span><br><span class="line">```</span><br><span class="line">这个命令将zlmage与目标文件链接在一起，生成一个名为vmlinux.elf的新的ELF文件。</span><br></pre></td></tr></table></figure>
</li>
<li><p>将vmlinux.elf转换为raw binary格式的镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objcopy -O binary -R .note -R .comment -S vmlinux.elf vmlinux.raw</span></span><br><span class="line">```</span><br><span class="line">这个命令将vmlinux.elf转换为raw binary格式的镜像，即vmlinux.raw。</span><br></pre></td></tr></table></figure>
</li>
<li><p>将vmlinux.raw加载到合适的地址并执行：<br>将vmlinux.raw加载到目标平台的合适地址（如ZRELADDR）处，并跳转到该地址开始执行内核代码。</p>
</li>
</ol>
<p>需要注意的是，具体的地址和步骤可能因平台和配置而有所不同。请根据实际情况进行相应的调整和适配。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.19-binutils工具集</title>
    <url>/2023/09/05/3-19-binutils%E5%B7%A5%E5%85%B7%E9%9B%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-19-1-编译器和binutils"><a href="#3-19-1-编译器和binutils" class="headerlink" title="3.19.1 编译器和binutils"></a>3.19.1 编译器和binutils</h1><p>编译器和binutils是GNU工具集（GNU Toolchain）中的两个重要组成部分。</p>
<p>GNU编译器（GCC）是GNU工具集中的一个核心组件，它是一款开源的编译器套件，支持多种编程语言（如C、C++、Objective-C、Fortran等）。GCC能够将源代码编译成可执行文件或库文件，它提供了词法分析、语法分析、优化、代码生成等功能，以及针对不同处理器架构的代码生成选项。</p>
<p>Binutils是GNU工具集中的另一个重要组件，它是一组用于二进制文件处理的工具集合。这些工具包括链接器（ld）、汇编器（as）、目标文件转换器（objcopy、objdump等）以及符号表处理工具（nm、readelf等）。Binutils提供了处理不同文件格式（如ELF、COFF等）的能力，可以将目标文件、可执行文件和库文件进行链接、转换和调试等操作。</p>
<p>GCC和Binutils通常一同使用，它们共同构成了GNU工具集，提供了完整的软件开发工具链。在编译过程中，GCC会生成中间代码或汇编代码，然后通过binutils工具集中的链接器将多个目标文件链接成最终的可执行文件或库文件。此外，binutils还提供了对生成的可执行文件进行调试和分析的工具，如objdump和readelf。</p>
<h1 id="3-19-2-常用的binutils工具"><a href="#3-19-2-常用的binutils工具" class="headerlink" title="3.19.2 常用的binutils工具"></a>3.19.2 常用的binutils工具</h1><p>以下是常用的binutils工具及其用途：</p>
<ol>
<li>as：汇编器，将汇编文件汇编为目标文件。</li>
<li>ld：链接器，将多个目标文件和库文件组合成一个可执行文件或共享库。</li>
<li>nm：列出目标文件中的符号（函数、变量等），包括其地址和类型。</li>
<li>size：列出目标文件的各个段（如代码段、数据段）的大小以及总大小。</li>
<li>strip：移除目标文件中的符号信息，可以用于减小文件大小和保护代码的机密性。</li>
<li>gprof：性能分析工具，用于生成程序的调用图表和性能统计数据。</li>
<li>ar：创建、修改和提取归档文件（静态库），用于将多个目标文件打包成一个库文件。</li>
<li>addr2line：将程序地址翻译成源文件名和行号，用于调试时定位代码中特定地址对应的源代码位置。</li>
<li>objcopy：用于将一种目标文件格式转换为另一种格式，比如将二进制文件转换为ELF格式。</li>
<li>objdump：显示目标文件的信息，包括可执行文件或库文件的反汇编代码、符号表、节表等。</li>
<li>readelf：显示有关ELF（Executable and Linkable Format）文件的详细信息，包括节表、符号表、动态链接信息等。</li>
<li>ranlib：用于创建一个归档文件（静态库）的索引，索引列出了归档文件中可重定位目标文件的所有符号。</li>
<li>strings：用于从给定的文件中输出不短于指定长度的所有可打印字符序列，对于目标文件，默认只打印初始化和加载部分的字符串。</li>
<li>libopcodes：一个库，用于处理处理器指令的可读文本版本（opcodes），可以用于解析和处理处理器指令。</li>
</ol>
<h1 id="3-19-3-readelf命令"><a href="#3-19-3-readelf命令" class="headerlink" title="3.19.3 readelf命令"></a>3.19.3 readelf命令</h1><p>readelf是一个常用的binutils工具，用于显示和分析ELF（Executable and Linkable Format）文件的信息。下面是readelf命令的一些常用参数及其说明：</p>
<ul>
<li>-a：显示完整的ELF文件头信息，包括ELF版本、目标体系结构、入口点地址等。</li>
<li>-h：读取并显示ELF文件头信息，包括ELF文件类型、目标体系结构、节头表偏移量等。</li>
<li>-S：读取并显示节头表（Section Headers）的信息，包括节的名称、类型、大小、偏移量等。</li>
<li>-s：显示符号表（Symbol Table）的内容，包括函数、变量、局部符号等。可以看到符号的名称、地址、大小等信息。</li>
<li>-e：显示目标文件的所有头信息，包括ELF文件头、程序头表（Program Headers）、节头表等。</li>
<li>-n：显示note段的信息，note段是用于存储与程序执行无关的附加信息的一种特殊节。</li>
<li>-d：显示dynamic section（动态节）的信息，包括动态链接器相关的信息，如动态链接库的依赖关系、符号重定位等。</li>
<li>-g：显示section group（节组）的信息，节组是一种特殊的ELF节，用于组织和管理其他节。</li>
</ul>
<h1 id="3-19-4-objdump用法"><a href="#3-19-4-objdump用法" class="headerlink" title="3.19.4 objdump用法"></a>3.19.4 objdump用法</h1><p>objdump是一个binutils工具，用于显示和分析目标文件的信息和反汇编代码。下面是objdump命令的一些常用参数及其说明：</p>
<ul>
<li>-X：输出目标文件的所有header信息，包括文件头、程序头表、节头表等。</li>
<li>-t：输出目标文件的符号表，显示函数、变量等符号的地址和大小。</li>
<li>-h：输出目标文件的节头表信息，包括节的名称、类型、大小、偏移量等。</li>
<li>-j section：仅反汇编指定的节（section），可以指定要反汇编的具体节的名称。</li>
<li>-s：将代码段反汇编，同时将反汇编代码和源码交替显示，方便对比源代码和反汇编结果。</li>
<li>-D：对二进制文件进行全局反汇编，反汇编所有的节（section）。</li>
<li>-d：反汇编代码段，仅反汇编目标文件的代码段。</li>
<li>-f：显示目标文件的文件头信息，包括ELF版本、目标体系结构、入口点地址等。</li>
<li>-S：显示目标文件的全部header信息，以及它们对应的16进制文件代码。</li>
</ul>
<h1 id="3-19-5-objcopy用法"><a href="#3-19-5-objcopy用法" class="headerlink" title="3.19.5 objcopy用法"></a>3.19.5 objcopy用法</h1><p>objcopy是一个binutils工具，主要用于拷贝目标文件的内容到另一个目标文件中，以及进行目标文件格式的转换。下面是objcopy命令的一些常用参数及其说明：</p>
<ul>
<li>-R name：从文件中删除所有名为name的段（section）。</li>
<li>-s：不拷贝源文件的重定位和符号信息到输出目标文件，只拷贝纯粹的代码和数据。</li>
<li>-g：不拷贝源文件的调试符号到输出目标文件，可以用于生成剥离调试信息的可执行文件。</li>
<li>-j section：只拷贝指定的节（section）到输出文件，可以指定要拷贝的具体节的名称。</li>
<li>-K symbol：从源文件拷贝名为symbol的符号，其他符号不进行拷贝。</li>
<li>-N symbol：不从源文件拷贝名为symbol的符号。</li>
<li>-L symbol：将符号symbol标记为文件内局部化，使其在外部不可见。</li>
<li>-W symbol：将符号symbol标记为弱符号，使其在链接时可以被覆盖。</li>
</ul>
<p>下面是一些使用示例，展示如何使用objcopy进行文件格式转换和瘦身操作：</p>
<ol>
<li><p>将ELF文件转换为BIN文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objcopy -O binary -R.comment -S uboot uboot.bin</span></span><br><span class="line">```</span><br><span class="line">这个命令将uboot.uboot.bin文件转换为原始的二进制文件uboot.bin。使用参数`-O binary`指定输出格式为二进制，`-R.comment`删除不需要的.comment节，`-S`指定不输出重定位和符号信息到目标文件。</span><br></pre></td></tr></table></figure>
</li>
<li><p>将BIN文件转换为HEX文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objcopy -I binary -O ihex uboot.bin uboot.hex</span></span><br><span class="line">```</span><br><span class="line">这个命令将uboot.bin文件转换为Intel Hex格式的uboot.hex文件。使用参数`-I binary`指定输入格式为二进制，`-O ihex`指定输出格式为Intel Hex。</span><br></pre></td></tr></table></figure>
</li>
<li><p>瘦身操作 - 去除不需要的信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objcopy -R .comment a.out slim_a.out</span></span><br><span class="line">```</span><br><span class="line">这个命令将目标文件a.out中的.comment节删除，生成瘦身后的目标文件slim_a.out。使用参数`-R .comment`指定删除.comment节。</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些示例展示了如何使用objcopy进行文件格式转换，从ELF到BIN、BIN到HEX，并且展示了如何使用objcopy进行瘦身操作，去除不需要的信息。根据具体需求，可以根据这些示例进行参数调整和使用。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.18-内核模块加载机制</title>
    <url>/2023/09/05/3-18-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-18-1-内核的加载"><a href="#3-18-1-内核的加载" class="headerlink" title="3.18.1 内核的加载"></a><strong>3.18.1 内核的加载</strong></h1><p>在Linux内核中，动态加载和初始化模块是通过系统调用<code>init_module</code>来完成的。这个系统调用位于<code>kernel/module.c</code>文件中。</p>
<p>下面是<code>init_module</code>系统调用的主要步骤：</p>
<ol>
<li>拷贝到内核（copy_module_from_user）：首先，内核从用户空间复制模块的代码和数据到内核空间。这样做是为了确保模块在内核中的存储是可访问和可执行的。</li>
<li>地址空间分配（layout_and_allocate）：内核为模块分配内存空间，并为模块的代码、数据和符号表等分配适当的地址空间。</li>
<li>符号解析（simplify_symbols）：内核对模块的符号进行解析，将符号与对应的地址进行关联。这包括模块内部的符号以及与其他模块或内核的符号之间的关联。</li>
<li>重定位（apply_relocations）：内核对模块进行重定位，将模块中的绝对地址修正为正确的运行时地址。这是为了确保模块可以正确地在内核中执行。</li>
<li>执行（complete_formation）：最后，模块的初始化过程完成，模块的入口点函数被调用，开始执行模块的功能。</li>
</ol>
<p>通过这些步骤，内核可以将模块加载到内核空间，并使其在内核中可用。加载和初始化模块使得内核能够动态地添加新的功能、驱动程序或文件系统，而无需重新编译整个内核。这提供了更大的灵活性和可扩展性，使得系统可以根据需要加载和卸载模块。</p>
<h1 id="3-18-2-内核模块和插件的异同"><a href="#3-18-2-内核模块和插件的异同" class="headerlink" title="3.18.2 内核模块和插件的异同"></a>3.18.2 内核模块和插件的异同</h1><p>内核模块和插件具有一些相同点，同时也有一些异同点。</p>
<p>相同点：</p>
<ol>
<li>动态链接：内核模块和插件都采用动态链接的方式，可以在运行时加载到内存中。这使得它们能够以模块化的方式扩展软件功能，而无需重新编译整个软件或内核。</li>
<li>空间分配、符号解析、重定位：内核模块和插件都需要进行空间分配、符号解析和重定位等步骤，以确保代码、数据和符号在加载后能够正确地运行和访问。</li>
</ol>
<p>异同点：</p>
<ol>
<li>运行环境：内核模块运行在内核空间，而插件运行在用户空间。内核空间是操作系统核心的一部分，具有更高的特权级别和更多的系统资源访问权限。用户空间是应用程序运行的环境。</li>
<li>依赖关系：内核模块不依赖于C库（如libc），因此在链接和重定位过程中，它们需要自行处理相关的操作。而应用程序的插件通常会依赖于C库，并通过C标准库的ld链接器来完成动态库的链接和重定位。</li>
<li>访问权限：内核模块可以直接访问和操作内核的数据结构和功能，因为它们运行在内核空间。而插件运行在用户空间，对于一些受限的系统资源和特权操作可能没有直接访问权限。</li>
</ol>
<p>总体而言，内核模块和插件都是利用动态链接的机制来扩展软件的功能。它们在加载、符号解析和重定位等方面有类似的工作原理，但由于运行环境和依赖关系的不同，它们在实现和使用上存在一些区别。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.17-开发一个插件</title>
    <url>/2023/09/05/3-17-%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="7-17-1-插件的工作原理"><a href="#7-17-1-插件的工作原理" class="headerlink" title="7.17.1 插件的工作原理"></a>7.17.1 插件的工作原理</h1><p>插件是一种用于软件扩展的机制，允许在不修改主程序逻辑框架的情况下，通过加载外部的动态链接库（共享库）来添加新的功能或增强软件的功能。</p>
<p>插件的本质就是共享库，它们以一种特定的组装形式存在，以便主程序能够动态加载和使用它们。一旦插件被加载，主程序可以通过调用插件中定义的函数或使用插件提供的接口来访问插件的功能。</p>
<p>插件的工作原理如下：</p>
<ol>
<li>主程序框架引用外部模块符号：主程序在编译时会引用插件可能提供的函数、接口或符号。这些符号在主程序中作为占位符存在，实际的实现在插件中。</li>
<li>动态加载和重定位：主程序在运行时使用系统调用（例如在Linux中使用dlopen函数）来显式加载插件的动态链接库。加载过程中，操作系统会进行动态链接和重定位，将插件的代码和数据映射到主程序的内存空间中。</li>
<li>访问插件功能：一旦插件被加载，主程序就可以通过调用插件中的函数或使用插件提供的接口来访问插件的功能。主程序可以根据需要动态加载、卸载或替换插件，从而实现软件的灵活扩展和功能更新。</li>
</ol>
<p>通过插件机制，软件的功能可以以模块化的方式组织和管理，实现更高的可扩展性和灵活性。同时，插件的使用也可以使软件的功能增值更加便捷，而无需重新编译和发布整个软件。</p>
<h1 id="7-17-2-显式加载动态库"><a href="#7-17-2-显式加载动态库" class="headerlink" title="7.17.2 显式加载动态库"></a>7.17.2 显式加载动态库</h1><p>在显式加载动态库时，可以使用dlopen函数打开动态链接库，该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flag)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>filename</code>参数是动态库文件的路径，可以是相对路径或绝对路径。</li>
<li>flag参数指定了加载动态库的行为和属性。常用的标志包括：<ul>
<li><code>RTLD_LAZY</code>：表示在解析动态库时，遇到未定义的符号不会导致程序退出，而是继续进行使用。</li>
<li><code>RTLD_NOW</code>：表示在解析动态库时，如果遇到未定义的符号，会立即退出。</li>
<li><code>RTLD_GLOBAL</code>：表示允许导出的符号可以被其他动态库引用。</li>
</ul>
</li>
</ul>
<p>dlopen函数返回一个操作句柄（<code>void *Handle</code>），可以用于后续对动态库的操作。</p>
<p>要获取动态对象（函数或变量）的地址，可以使用dlsym函数，该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">dlsym</span><span class="params">(<span class="type">void</span> *handle, <span class="type">const</span> <span class="type">char</span> *symbol)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>handle</code>参数是通过dlopen函数返回的动态库句柄。</li>
<li><code>symbol</code>参数是要获取地址的符号名称。</li>
</ul>
<p>dlsym函数会根据动态库句柄和符号名称返回符号对应的地址。一般情况下，我们需要定义一个符号类型的指针，将dlsym函数返回的地址赋值给该指针，以便后续使用。</p>
<p>以下是一个示例代码片段，演示了显式加载动态库并获取函数地址的过程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开动态链接库</span></span><br><span class="line"><span class="type">void</span> *Handle = dlopen(<span class="string">&quot;./libct.so&quot;</span>, RTLD_LAZY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取动态对象地址</span></span><br><span class="line"><span class="type">void</span> (*funcp)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">funcp = (<span class="type">void</span> (*)(<span class="type">int</span>, <span class="type">int</span>))dlsym(Handle, <span class="string">&quot;myfunc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，假设libct.so是动态库文件，myfunc是动态库中的函数名。通过dlopen函数打开动态库，然后使用dlsym函数获取myfunc函数的地址，并将其赋值给funcp指针，以便后续调用该函数。</p>
<p>需要注意的是，示例中的类型转换是为了将dlsym返回的地址转换为函数指针类型，以便正确调用函数。根据实际情况，类型转换的方式可能会有所不同。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.16-动态链接(3)-共享库</title>
    <url>/2023/09/05/3-16-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5-3-%E5%85%B1%E4%BA%AB%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-15-1-共享库的命名"><a href="#3-15-1-共享库的命名" class="headerlink" title="3.15.1 共享库的命名"></a>3.15.1 共享库的命名</h1><p>在Linux环境下，共享库的命名方式通常遵循以下格式：libname.so.X.Z。</p>
<ul>
<li>libname：表示库的名称，通常由开发者指定。</li>
<li>X：主版本号，表示库的重大升级。当主版本号发生变化时，表示库的接口发生了不兼容的变化，可能需要重新编译依赖该库的程序才能正常运行。</li>
<li>Z：发布版本号，表示库的发布版本。当发布版本号发生变化时，通常表示进行了错误修正、性能改进等，但没有增加新的接口，原有接口保持不变。</li>
</ul>
<p>例如，假设有一个名为libexample.so的共享库，其版本号为1.2.3，则库文件的命名可能是libexample.so.1.2.3。</p>
<p>次版本号（Y）在库的命名中没有直接体现，它通常用于表示库的增量升级，即增加一些新的接口符号，而原有的接口符号保持不变。次版本号的变化通常不会破坏与之前版本的兼容性，因此使用高版本的库通常可以向后兼容低版本的库。</p>
<h1 id="3-15-2-共享库软链接"><a href="#3-15-2-共享库软链接" class="headerlink" title="3.15.2 共享库软链接"></a>3.15.2 共享库软链接</h1><p>软链接（Symbolic link）是一个特殊类型的文件，它是一个指向另一个文件或目录的引用。在Linux系统中，软链接可以用来记录共享库的依赖关系，并且通常用于共享库的SO-NAME命名机制。</p>
<p>SO-NAME是共享库的一个命名约定，用于标识共享库的接口。它通常通过去除共享库文件名中的次版本号和发布版本号来得到。例如，如果一个共享库文件的名称是libexample.so.1.2.3，那么它的SO-NAME可能是libexample.so.1。</p>
<p>系统会在共享库文件所在的目录下创建一个与SO-NAME同名的软链接，该软链接指向具有相同主版本号的共享库文件中最新的次版本号和发布版本号。这样，依赖某个共享库的模块可以使用SO-NAME来引用该共享库，而不需要指定具体的版本号。这种方式有助于系统升级，因为只要保证新版本的共享库兼容旧版本的接口，依赖该库的模块就可以继续正常工作，无需修改代码。</p>
<p>使用SO-NAME和软链接的好处是，它提供了一种稳定的共享库接口，并简化了依赖管理。通过使用SO-NAME作为共享库的标识，系统可以方便地管理共享库的版本，并且可以在不破坏接口兼容性的情况下进行升级和替换。同时，依赖该共享库的模块可以通过引用SO-NAME来保持与共享库的连接，而不需要关注具体的版本号，从而提高了系统的灵活性和可维护性。</p>
<h1 id="3-15-3-共享库的路径"><a href="#3-15-3-共享库的路径" class="headerlink" title="3.15.3 共享库的路径"></a>3.15.3 共享库的路径</h1><p>在Linux系统中，共享库通常存放在以下三个主要路径：</p>
<ol>
<li>&#x2F;lib：该目录存放系统最关键和基础的共享库，例如动态链接器、C库、数学库等。这些库主要是用于&#x2F;bin、&#x2F;sbin下的程序运行以及系统启动所需要的库。这些共享库对于系统的正常运行非常重要。</li>
<li>&#x2F;usr&#x2F;lib：该目录存放非系统运行所需要的关键性共享库。这些库通常是开发过程中使用的一些共享库，包括开发工具链、编译器等。这些库一般不会被用户的程序或者Shell脚本直接使用，而是被开发工具链和编译器等系统工具所使用。</li>
<li>&#x2F;usr&#x2F;local&#x2F;lib：该目录主要存放第三方应用程序所需要的一些库。当用户安装自己编译或安装的软件时，这些软件通常会将其依赖的共享库安装到&#x2F;usr&#x2F;local&#x2F;lib目录下。这样做的好处是，可以将用户自定义的库与系统自带的库分开管理，避免冲突。</li>
</ol>
<h1 id="3-15-4-库的查找过程"><a href="#3-15-4-库的查找过程" class="headerlink" title="3.15.4 库的查找过程"></a>3.15.4 库的查找过程</h1><p>在Linux系统中，库的查找过程由动态链接器（dynamic linker）负责。以下是库的查找过程的基本步骤：</p>
<ol>
<li><p>ELF文件加载：当一个可执行的ELF文件被执行时，动态链接器（一般是&#x2F;lib&#x2F;ld-linux.so.x）会被加载并启动。</p>
</li>
<li><p>依赖关系查找：动态链接器会解析ELF文件的.dynamic段，查找该文件所依赖的共享库。</p>
</li>
<li><p>路径解析：根据共享库的路径信息，动态链接器会按照一定的顺序进行路径解析，以找到共享库文件。解析顺序如下：</p>
<ul>
<li>若路径是绝对路径，则直接到该绝对路径下查找共享库文件。</li>
<li>若路径是相对路径，则按照一定的顺序在以下目录中查找共享库文件：<ul>
<li>&#x2F;lib</li>
<li>&#x2F;usr&#x2F;lib</li>
<li>根据&#x2F;etc&#x2F;ld.so.conf配置文件中指定的目录</li>
</ul>
</li>
</ul>
<p>库目录缓存：为了加快库的查找速度，避免每次都进行路径解析，系统可以使用ldconfig命令生成一个缓存文件&#x2F;etc&#x2F;ld.so.cache。该缓存文件记录了系统中可用的共享库路径及其对应的共享库文件。动态链接器在查找库时会首先检查该缓存文件，并根据其中的路径信息进行查找。</p>
<ul>
<li>当新增、删除或更新共享库路径时，需要更新缓存文件，可以使用ldconfig命令进行更新。</li>
</ul>
</li>
</ol>
<h1 id="3-15-5-LD-LIBRARY-PATH"><a href="#3-15-5-LD-LIBRARY-PATH" class="headerlink" title="3.15.5 LD_LIBRARY_PATH"></a>3.15.5 LD_LIBRARY_PATH</h1><p>LD_LIBRARY_PATH是一个环境变量，它由若干个路径组成，每个路径之间用冒号”:”进行分隔。该环境变量用于临时改变程序运行时的共享库查找路径。</p>
<p>当一个程序在运行过程中需要加载共享库时，系统会按照一定的规则进行共享库的查找。这些规则包括默认的系统库路径、配置文件中指定的路径等。然而，通过设置LD_LIBRARY_PATH环境变量，可以临时修改共享库的查找路径，优先使用LD_LIBRARY_PATH中指定的路径。</p>
<p>当LD_LIBRARY_PATH环境变量被设置后，程序在加载共享库时会首先在LD_LIBRARY_PATH指定的路径中查找共享库文件，而不是按照默认的规则进行查找。如果找到了匹配的共享库文件，程序会使用该路径下的共享库进行链接和加载。</p>
<p>这个特性可以用于临时改变程序依赖的共享库查找路径，而不影响系统中的其他应用程序。一旦程序运行结束或者LD_LIBRARY_PATH环境变量被重置，系统将恢复到默认的共享库查找路径。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.15-动态链接(2)-全局符号表GOT</title>
    <url>/2023/09/05/3-15-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5-2-%E5%85%A8%E5%B1%80%E7%AC%A6%E5%8F%B7%E8%A1%A8GOT/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-15-1-表和结构"><a href="#3-15-1-表和结构" class="headerlink" title="3.15.1 表和结构"></a>3.15.1 表和结构</h1><p>下面是这些表和结构的简要介绍：</p>
<ol>
<li>.dynamic段：.dynamic段是一个特殊的段，它包含了动态链接器所需的信息。这些信息包括动态链接库的依赖关系、重定位表的位置、初始化函数等。动态链接器在加载可执行文件时会解析.dynamic段以获取这些信息。</li>
<li>动态符号表 (.dynsym)：动态符号表是一个表格，它记录了可执行文件或共享库中定义的所有动态符号。每个动态符号都有一个唯一的符号索引，可以用来在运行时进行符号解析和链接。动态符号表中的每个条目包含了符号名称、符号类型和符号值等信息。</li>
<li>动态链接重定位表 (PLT)：动态链接重定位表是一个重要的数据结构，用于处理在运行时动态链接的符号重定位。它包含了跳转指令和符号解析逻辑，用于在首次调用某个符号时进行符号解析和重定位。PLT中的每个条目包含了一个跳转指令和一个GOT表项的索引。</li>
<li>全局偏移表 (GOT)：全局偏移表是一个表格，用于存储全局符号的地址。GOT表的每个条目对应一个全局符号，它可以被动态链接器用来解析外部模块中的符号地址。GOT表的条目可能最初包含一个间接跳转指令，当符号地址被解析后，会被更新为具体的地址。</li>
</ol>
<h1 id="3-15-2-动态链接器"><a href="#3-15-2-动态链接器" class="headerlink" title="3.15.2 动态链接器"></a>3.15.2 动态链接器</h1><p>.interp：.interp是一个特殊的段，它包含了动态链接器的路径。当可执行文件被加载时，操作系统会使用.interp段中指定的路径来找到并加载动态链接器。这样可执行文件就能够正确地进行动态链接。</p>
<p>动态链接器是负责在程序运行时加载和链接共享库的系统组件。它负责解析程序的依赖关系，加载所需的共享库，并将其链接到程序的地址空间中。</p>
<p>.interp段是可执行文件中的一个特殊段，用于存放动态链接器的路径。该段中存储了一个字符串，指明了动态链接器的路径。当可执行文件被加载时，操作系统会根据.interp段中指定的路径找到并加载相应的动态链接器。</p>
<p>要查看.interp段的内容，可以使用命令 <code>readelf -p .interp a.out</code>（其中 <code>a.out</code> 是可执行文件的名称）。该命令会显示.interp段的内容，即动态链接器的路径。</p>
<p>动态链接器本质上也是一个共享库，它在程序运行之前首先需要进行自举（bootstrap），即对自身进行重定位。动态链接器通常由操作系统提供，并且在C标准库中实现，是GNU C库（Glibc）的一部分。Glibc是一个常用的C标准库实现，它包含了对动态链接器的实现。</p>
<p>通过动态链接器的工作，程序能够在运行时动态地加载和链接共享库，实现了模块化、可扩展和灵活的程序设计。动态链接器的存在使得共享库的使用更加方便，并提供了许多动态链接相关的功能，如符号解析、重定位和依赖管理。</p>
<h1 id="3-15-3-dynamic段"><a href="#3-15-3-dynamic段" class="headerlink" title="3.15.3 dynamic段"></a>3.15.3 dynamic段</h1><p>.dynamic段是可执行文件或共享库中的一个特殊段，它保存了动态链接器在加载和链接时所需的基本信息。这些信息包括：</p>
<ul>
<li>依赖的共享库：.dynamic段记录了程序或共享库所依赖的其他共享库的名称，使得动态链接器可以在加载时确定这些依赖关系，并加载相应的共享库。</li>
<li>动态链接符号表位置：.dynamic段指示了动态链接符号表的位置，该符号表包含了程序或共享库中定义的所有动态符号。动态链接器在加载时使用这个符号表来进行符号解析和链接。</li>
<li>动态链接字符串表的位置：.dynamic段也记录了动态链接字符串表的位置，这个字符串表包含了与动态链接相关的字符串，例如符号名称、共享库名称等。动态链接器使用这个字符串表来解析和处理动态链接相关的字符串。</li>
<li>动态链接重定位表位置：.dynamic段指定了动态链接重定位表的位置，这个重定位表用于在运行时进行动态链接的符号重定位。它包含了需要进行重定位的符号及其相关信息，使得动态链接器可以在加载时进行符号重定位操作。</li>
<li>共享库初始化代码位置：.dynamic段还包含了共享库初始化代码的位置信息，这些代码在共享库加载时被执行，用于执行一些初始化操作。</li>
</ul>
<p>.dynamic段的内容由多个结构体组成，这些结构体的定义可以在 <code>/usr/include/elf.h</code> 中找到。通过使用命令 <code>readelf -d xx.so</code>（其中 <code>xx.so</code> 是共享库文件的名称），可以查看.dynamic段的内容。这个命令会显示.dynamic段中的结构体信息，包括依赖的共享库、符号表位置、字符串表位置、重定位表位置等相关信息。</p>
<h1 id="3-15-4-动态链接符号表"><a href="#3-15-4-动态链接符号表" class="headerlink" title="3.15.4 动态链接符号表"></a>3.15.4 动态链接符号表</h1><p>动态链接符号表是在动态链接过程中使用的符号表，它与静态链接符号表有一些区别。下面是关于动态链接符号表的一些说明：</p>
<ul>
<li>动态链接符号表（.dynsym）：动态链接符号表是一个特殊的符号表，它只保存了与动态链接相关的符号信息，而不保存所有的符号定义和引用。它包含了程序或共享库中定义的所有动态符号，如函数、变量等。每个符号表条目包含了符号的名称、地址、大小、绑定属性等信息。</li>
<li>动态链接字符串表（.dynstr）：动态链接字符串表是动态链接符号表的辅助表，用于存储符号的名称。静态链接的符号表中的符号名称通常直接存储在符号表本身，但动态链接符号表中的符号名称存储在动态链接字符串表中。符号表（.dynsym）中的每个条目通过索引与字符串表（.dynstr）中的对应字符串关联起来。</li>
<li>符号哈希表：符号哈希表是动态链接文件中的一个段，用于提高程序在运行时查找符号的速度。它通过哈希算法将符号的名称映射到符号表中的条目，从而加快符号查找的效率。符号哈希表在动态链接过程中起到加速符号解析和查找的作用。</li>
</ul>
<p>要查看动态链接符号表和字符串表的内容，可以使用命令 <code>readelf -s a.out</code>（对于可执行文件）或 <code>readelf -sD xx.so</code>（对于共享库）来查看。这些命令会显示符号表中的条目，包括符号的名称、地址、大小、绑定属性等信息。通过对比符号表（.dynsym）和字符串表（.dynstr）中的索引，可以关联符号的名称和其他属性。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.14-动态链接(1)-与位置无关的代码</title>
    <url>/2023/09/05/3-14-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5-1-%E4%B8%8E%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-14-1-静态链接的缺点"><a href="#3-14-1-静态链接的缺点" class="headerlink" title="3.14.1 静态链接的缺点"></a>3.14.1 静态链接的缺点</h1><p>静态链接的确存在一些缺点，包括：</p>
<ol>
<li>可执行文件体积较大：由于静态链接将所有需要的代码和库函数都包含在可执行文件中，导致可执行文件的体积较大。如果多个程序都使用相同的静态库，会造成冗余的存储空间浪费。</li>
<li>内存占用较大：静态链接的可执行文件在运行时需要将所有的代码和数据加载到内存中。这意味着即使程序只用到了部分功能，也需要将整个程序加载到内存中，增加了内存占用的开销。</li>
<li>内存配置限制：对于内存配置较小的系统，静态链接的可执行文件可能会占用过多的内存，导致无法正常加载和运行。这是由于静态链接将所有代码和数据都打包在可执行文件中，无法根据系统的实际内存情况进行动态调整。</li>
<li>更新困难：当静态库或依赖的库发生更新时，需要重新编译和链接整个程序才能应用更新。这增加了更新和维护的复杂性，特别是在大型项目或多个项目共享同一静态库时。</li>
</ol>
<p>考虑到上述缺点，有些情况下可以选择使用动态链接库（共享库）。动态链接库在运行时被动态加载，可多个程序共享，减小了可执行文件的体积和内存占用。动态链接库的更新和维护也更加灵活，可以在不重新编译和链接整个程序的情况下进行库的更新。</p>
<h1 id="3-14-2-动态链接"><a href="#3-14-2-动态链接" class="headerlink" title="3.14.2 动态链接"></a>3.14.2 动态链接</h1><p>动态链接与静态链接不同，它推迟到程序运行时进行，而不是在链接过程中完成。在动态链接中，目标文件被编译成动态链接库（也称为共享库），而不是静态库。这些动态链接库在程序运行时被加载到内存中，并进行重定位。</p>
<p>动态链接的好处包括：</p>
<ol>
<li>节省内存：由于动态链接库是在运行时加载的，多个程序可以共享同一个动态链接库，避免了静态链接中的代码冗余和存储空间浪费。这样可以节省内存，并允许运行更大规模的程序。</li>
<li>简化升级：由于动态链接库是独立于可执行文件的，当库需要升级时，只需替换动态链接库文件，而不需要重新编译和链接整个程序。这使得库的升级更加方便和灵活，减少了对程序的影响。</li>
<li>提供更好的可维护性：动态链接库可以被多个程序共享，这意味着库的更新和维护只需在一个地方进行。这样有助于提高代码的可维护性，减少了重复的工作和潜在的错误。</li>
</ol>
<h1 id="3-14-3-程序执行过程"><a href="#3-14-3-程序执行过程" class="headerlink" title="3.14.3 程序执行过程"></a>3.14.3 程序执行过程</h1><p>在Linux命令行下运行一个程序的基本过程如下：</p>
<ol>
<li>操作系统给程序开启一个进程：当您在命令行中执行程序时，操作系统会为该程序创建一个新的进程，该进程将作为程序的执行环境。</li>
<li>动态链接器被映射到程序地址空间：动态链接器（通常是ld.so或ld-linux.so）是负责动态链接的系统组件。在程序启动时，操作系统将动态链接器映射到程序的地址空间中。</li>
<li>操作系统将控制权交给动态链接器：操作系统将控制权传递给动态链接器，使其可以开始执行动态链接的任务。</li>
<li>动态链接器解析未确定符号和动态库链接：动态链接器首先会解析可执行文件中的未确定符号，这些符号是指在编译时无法确定其地址的符号（如函数或变量）。动态链接器会查找并加载包含这些符号定义的动态库。</li>
<li>加载动态库并进行重定位：动态链接器会加载需要链接的动态库，并对这些库进行重定位操作。重定位是将动态库中的符号引用与实际的符号定义进行匹配，以确保程序能够正确地访问所需的函数和数据。</li>
<li>动态链接器将控制权交给可执行程序：一旦动态链接器完成了解析和重定位的工作，它将控制权交还给可执行程序。此时，可执行程序中的所有符号引用都已经解析完毕，并且程序可以开始运行。</li>
<li>可执行程序开始执行：控制权回到可执行程序，它会按照程序的逻辑开始执行，调用所需的函数和访问数据。</li>
</ol>
<p>在静态编译的情况下，可执行文件中包含了所有需要的代码和库函数，因此它是独立的、自包含的。以下是关于静态编译可执行文件和动态链接库的一些说明：</p>
<ol>
<li>可执行文件的加载和运行地址：<ul>
<li>静态编译的可执行文件在加载到进程地址空间时，通常会被加载到一个固定的运行地址。这是因为在编译和链接时，所有的符号引用已经被解析并确定了其最终的地址。</li>
<li>链接地址和运行地址是相同的，因此可执行文件在运行时可以直接通过固定的地址访问到所需的函数和数据。</li>
</ul>
</li>
<li>动态链接库的加载和运行地址：<ul>
<li>动态链接库（共享库）在加载到内存中时，其加载地址是由操作系统动态分配的。加载器根据当前进程的地址空间空闲情况，选择一个适当的地址来加载动态库。</li>
<li>动态库被装载到内存中的地址可以是任意的，并不需要与其他库或可执行文件的地址相同。这是因为动态库的地址信息会被动态链接器处理和重定位，以确保库中的符号引用与实际的符号定义相匹配。</li>
</ul>
</li>
</ol>
<p>动态链接库被装载到内存中的地址可变的主要原因是为了避免不同进程之间的冲突。由于多个进程可以同时运行，每个进程都有自己的地址空间，因此需要动态分配适当的地址来加载动态库，以避免地址冲突和重复使用相同的地址。</p>
<h1 id="3-14-4-装载时重定位"><a href="#3-14-4-装载时重定位" class="headerlink" title="3.14.4 装载时重定位"></a>3.14.4 装载时重定位</h1><p>装载时重定位是动态链接过程中的一项关键任务，它的基本思想是将对绝对地址的引用推迟到运行时进行解析和重定位。以下是装载时重定位的基本原理：</p>
<ol>
<li>推迟地址解析和重定位：在可执行文件中，对于动态库中的函数或变量的引用通常是使用绝对地址进行表示的。而在静态链接时，这些绝对地址是无法确定的，因为动态库的加载地址是在运行时动态分配的。因此，装载时重定位的基本思想是将对绝对地址的引用推迟到运行时去解析和重定位。</li>
<li>动态库加载和地址确定：当动态库被加载到内存中时，操作系统会为其分配一段合适的地址空间，并将库中的函数和变量映射到该地址空间中。此时，动态库中的每个符号都有了确定的地址。</li>
<li>可执行文件的重定位操作：一旦动态库的地址确定，装载时重定位会将可执行文件中对动态库中函数或变量的绝对地址引用进行重定位操作。具体而言，它会将绝对地址替换为实际的动态库中的地址，以确保可执行文件能够正确地访问所需的函数和变量。</li>
</ol>
<p>实现装载时重定位的方法有多种，编译器如GCC在生成共享动态链接库时可以使用<code>--shared</code>参数。这样生成的库在运行时会由动态链接器进行加载，并进行相应的地址解析和重定位操作。</p>
<p>通过推迟地址解析和重定位到运行时，装载时重定位实现了动态链接的灵活性和可扩展性。它允许不同的进程在加载同一个动态库时，根据其实际地址空间的情况进行地址分配和重定位，确保了符号的正确链接和访问。</p>
<h1 id="3-14-5-命令"><a href="#3-14-5-命令" class="headerlink" title="3.14.5 命令"></a>3.14.5 命令</h1><p>使用ldd命令可以查看一个可执行文件所需要的动态链接库</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309060823892.png" alt="image-20230906082331845"></p>
<h1 id="3-14-6-与地址无关的代码"><a href="#3-14-6-与地址无关的代码" class="headerlink" title="3.14.6 与地址无关的代码"></a>3.14.6 与地址无关的代码</h1><p>地址无关代码（Position-Independent Code，PIC）是一种技术，它使得代码可以在不进行重定位的情况下在不同的地址空间中执行。以下是地址无关代码的一些特点和实现方式：</p>
<p>特点：</p>
<ol>
<li>可以在任意地址加载和执行：地址无关代码可以在内存中的任意地址加载，并且无需进行重定位操作，就可以正确地执行。</li>
<li>与地址无关的指令：地址无关代码将需要修改的部分指令与数据分离，数据可以与需要修改的指令放在一起，而其余指令则不依赖于具体的地址，实现了与地址无关的特性。</li>
<li>被多个进程共享：地址无关代码可以被多个进程共享，每个进程都有自己的数据和需要修改的指令的副本，互不影响。</li>
</ol>
<p>实现方式：</p>
<ol>
<li>编译时生成位置无关代码：在编译阶段，可以使用编译器的参数来生成位置无关代码。对于GCC编译器，可以使用<code>-fPIC</code>参数来生成位置无关代码的目标文件。例如，使用命令<code>gcc -fPIC -c main.c</code>可以生成一个位置无关的目标文件。</li>
<li>使用相对寻址和间接寻址：地址无关代码使用相对寻址和间接寻址来访问数据和需要修改的指令。相对寻址是指使用相对于当前指令的偏移量来访问数据，而不是使用绝对地址。间接寻址则是通过间接引用来访问数据，而不是直接使用数据的地址。</li>
</ol>
<p>通过以上的实现方式，地址无关代码可以实现在不同的地址空间中加载和执行，而无需进行重定位操作。这使得地址无关代码可以被多个进程共享，并且具有较高的灵活性和可移植性。</p>
<h1 id="3-14-5-模块内部相对寻址"><a href="#3-14-5-模块内部相对寻址" class="headerlink" title="3.14.5 模块内部相对寻址"></a>3.14.5 模块内部相对寻址</h1><p>ARM相对寻址是一种使用PC作为基址，并将指令中的地址码段作为偏移量的寻址方式。通过将PC和偏移量相加，可以得到操作数的有效地址。这种寻址方式常见于ARM汇编语言中的B&#x2F;BL和ADR&#x2F;ADRL指令。</p>
<p>例如，考虑以下示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B LOOP</span><br><span class="line">.LOOP MOV R0, #1</span><br><span class="line">MOV R1, R0</span><br></pre></td></tr></table></figure>

<p>在这个例子中，B LOOP指令会跳转到标签LOOP处执行。相当于使用相对寻址方式进行跳转。</p>
<p>相对寻址的等效手动指令是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD PC, PC, #OFFSET</span><br></pre></td></tr></table></figure>

<p>其中OFFSET是B LOOP指令地址与LOOP标签地址之间的偏移量。B指令的前后跳转范围是[0, 32M]。</p>
<p>通过这种相对寻址方式，可以将跳转目标限制在指令附近的相对范围内，而不是使用绝对地址。这样可以增加代码的灵活性和可移植性。</p>
<h1 id="3-14-6-模块外部GOT表"><a href="#3-14-6-模块外部GOT表" class="headerlink" title="3.14.6 模块外部GOT表"></a>3.14.6 模块外部GOT表</h1><p>动态链接的核心GOT表问题是如何处理引用外部模块的符号地址无关。当一个模块需要引用其他模块中定义的符号（函数、变量等）时，如何确保在运行时能够正确找到这些符号的地址是一个关键问题。</p>
<p>动态链接的核心思想是使用全局偏移表（Global Offset Table，GOT）来解决这个问题。在链接时，被引用的外部模块的符号地址被存储在GOT中。</p>
<p>具体而言，当一个模块需要引用外部模块的符号时，它并不直接使用符号的地址，而是通过查找GOT表来间接获取符号的地址。GOT表中的每个表项对应一个被引用的符号，存储了该符号的地址或者加载该符号地址的指令。</p>
<p>在链接时，GOT表的位置已经确定，因此在运行时可以通过GOT表来获取外部符号的地址，而不需要硬编码具体的地址。</p>
<p>使用GOT表的好处是，它使得模块间的符号引用变得独立于具体的内存布局，从而增加了模块的可移植性和灵活性。当外部模块的地址发生变化时，只需要更新GOT表中对应的表项即可，而不需要修改引用该符号的模</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.13-链接静态库</title>
    <url>/2023/09/05/3-13-%E9%93%BE%E6%8E%A5%E9%9D%99%E6%80%81%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-13-1-静态库"><a href="#3-13-1-静态库" class="headerlink" title="3.13.1 静态库"></a>3.13.1 静态库</h1><p>静态库是一种包含预编译目标文件的归档文件，它可以被多个程序共享和链接。归档文件通常具有<code>.a</code>的文件扩展名，例如<code>libtest.a</code>。</p>
<h1 id="3-13-2-静态库制作的步骤"><a href="#3-13-2-静态库制作的步骤" class="headerlink" title="3.13.2 静态库制作的步骤"></a>3.13.2 静态库制作的步骤</h1><p>制作静态库的步骤如下：</p>
<ol>
<li>编译源代码生成目标文件：首先，将源代码编译成目标文件（<code>.o</code>文件）。例如，<code>x.c</code>和<code>xx.c</code>分别编译成<code>x.o</code>和<code>xx.o</code>。</li>
<li>创建归档文件：使用<code>ar</code>工具创建归档文件。命令格式为<code>ar rcs &lt;库文件名&gt; &lt;目标文件1&gt; &lt;目标文件2&gt; ...</code>。例如，使用命令<code>ar rcs libtest.a x.o xx.o</code>将<code>x.o</code>和<code>xx.o</code>归档到<code>libtest.a</code>文件中。</li>
</ol>
<h1 id="3-13-3-静态库链接的步骤"><a href="#3-13-3-静态库链接的步骤" class="headerlink" title="3.13.3 静态库链接的步骤"></a>3.13.3 静态库链接的步骤</h1><p>链接静态库的步骤如下：</p>
<ol>
<li>编写主程序：创建一个包含主程序逻辑的源文件，例如<code>main.c</code>。</li>
<li>指定头文件路径和库文件路径：使用编译器选项指定头文件和库文件的搜索路径。例如，使用选项<code>-I./include</code>指定头文件搜索路径为<code>./include</code>，使用选项<code>-L./lib</code>指定库文件搜索路径为<code>./lib</code>。</li>
<li>链接静态库：使用编译器选项<code>-l&lt;库名&gt;</code>指定要链接的静态库。例如，使用选项<code>-ltest</code>将<code>libtest.a</code>静态库链接到主程序中。</li>
</ol>
<p>完整的链接命令为<code>gcc main.c -I./include -L./lib -ltest</code>。该命令会将<code>main.c</code>编译成目标文件，并链接<code>libtest.a</code>静态库生成可执行文件。</p>
<p>通过制作和链接静态库，可以将常用的函数和模块封装为可重用的代码库，提高代码的复用性和可维护性。</p>
<h1 id="3-13-4-静态库的问题"><a href="#3-13-4-静态库的问题" class="headerlink" title="3.13.4 静态库的问题"></a>3.13.4 静态库的问题</h1><p>链接静态库可能会带来以下问题：</p>
<ol>
<li>可执行体积增大：当链接静态库时，所有库中的函数都会被组装到最终的可执行文件中，无论是否使用到这些函数。这会导致可执行文件的体积增大，尤其是当静态库包含大量函数时。</li>
<li>冗余代码：由于静态库中的所有函数都会被链接到可执行文件中，可能会包含一些未使用的函数，从而造成代码的冗余。这会增加可执行文件的大小，并且在一些资源受限的环境中可能会浪费存储空间。</li>
<li>更新困难：如果静态库中的函数发生变化，需要重新编译和链接整个程序才能更新。这会增加代码维护的复杂性，并且在多个项目中使用同一静态库时，每个项目都需要进行重新编译和链接。</li>
</ol>
<p>解决上述问题的一种方法是将每个函数的实现放在单独的源文件中，然后将这些源文件编译成对应的目标文件，最后将所有的目标文件归档到静态库中。这样做可以避免将未使用的函数链接到最终的可执行文件中，减小可执行文件的体积并提高代码的可维护性。</p>
<p>这种方法的基本原理是，编译器的基本单位是文件，而链接器的基本单位是目标文件。当引用一个目标文件中的符号时，链接器会将整个目标文件进行链接，将引用的符号和相关的代码组装到最终的可执行文件中。</p>
<p>举例来说，假设有以下几个源文件：</p>
<ul>
<li><code>func1.c</code>：包含函数<code>func1</code>的实现</li>
<li><code>func2.c</code>：包含函数<code>func2</code>的实现</li>
<li><code>main.c</code>：包含程序的主函数</li>
</ul>
<p>首先，分别将<code>func1.c</code>、<code>func2.c</code>和<code>main.c</code>编译成对应的目标文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -c func1.c -o func1.o</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -c func2.c -o func2.o</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -c main.c -o main.o</span></span><br></pre></td></tr></table></figure>

<p>然后，将这些目标文件归档到静态库中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ar rcs libtest.a func1.o func2.o</span></span><br></pre></td></tr></table></figure>

<p>最后，链接主程序并使用静态库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.o -L. -ltest -o executable</span></span><br></pre></td></tr></table></figure>

<p>这样，只有主程序中实际引用的函数会被链接到最终的可执行文件中，减小了可执行文件的体积。</p>
<p>Glibc（GNU C Library）就是使用类似的方法实现的。它将每个函数的实现放在单独的源文件中，然后将这些源文件编译成对应的目标文件，并将目标文件归档到一个静态库中。这样，在链接时只会将程序实际使用的函数链接到最终的可执行文件中，提高了程序的效率和可维护性。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.12-main函数入口分析</title>
    <url>/2023/09/05/3-12-main%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="7-12-1-main函数入口"><a href="#7-12-1-main函数入口" class="headerlink" title="7.12.1 main函数入口"></a>7.12.1 main函数入口</h1><p>编译器对程序入口有以下规定：</p>
<ol>
<li>缺省程序入口：编译器默认的程序入口是<code>_start</code>符号，而不是<code>main</code>函数。<code>_start</code>符号是由编译器生成的一个特殊符号，它标识程序的入口点。在程序启动时，操作系统会将控制权转移到<code>_start</code>符号所代表的代码位置。</li>
<li><code>main</code>函数作为入口点：<code>main</code>函数是一个被C标准库调用的符号，用来告诉编译器在一个项目中哪里是程序的入口点。程序员需要遵守这个约定，将程序的逻辑代码放在<code>main</code>函数中，在执行<code>main</code>函数之前进行一些准备工作。</li>
</ol>
<p>在程序启动时，编译器会进行以下操作：</p>
<ul>
<li>设置堆栈指针：编译器会设置栈指针，以确保函数调用和局部变量的正确处理。</li>
<li>初始化静态变量和全局变量：编译器会初始化静态变量和全局变量，即将它们所占用的数据段（data segment）中的内容赋初值。</li>
<li>BSS段赋初值：BSS段中的变量会被初始化为默认值。例如，<code>int</code>类型的变量会被初始化为0，<code>bool</code>类型会被初始化为<code>FALSE</code>，指针会被初始化为<code>NULL</code>。</li>
<li>传递参数给<code>main</code>函数：编译器会将命令行参数（<code>argc</code>、<code>argv</code>等）传递给<code>main</code>函数，并开始执行<code>main</code>函数中的代码。</li>
</ul>
<h1 id="7-12-2-CRT运行库"><a href="#7-12-2-CRT运行库" class="headerlink" title="7.12.2 CRT运行库"></a>7.12.2 CRT运行库</h1><p>CRT是C Runtime（运行时）的缩写，也称为C运行库。它是一组库函数和运行时环境，用于支持和管理C语言程序的执行。</p>
<p>CRT的主要功能包括：</p>
<ol>
<li>实现C标准库函数：CRT实现了C标准库中定义的各种函数，例如输入输出函数（如printf、scanf）、字符串处理函数（如strcpy、strlen）、内存管理函数（如malloc、free）等。这些函数提供了常用的操作和功能，方便程序员开发C语言程序。</li>
<li>执行初始化操作：CRT负责在程序执行之前进行一系列的初始化操作。这包括设置基本的堆栈环境和进程环境，准备动态库的加载和释放，进行动态库的初始化和清理等工作。</li>
<li>调用main函数：CRT负责给main函数传递参数，并调用main函数开始执行程序的主要逻辑。它将命令行参数（如argc、argv）传递给main函数，以便程序可以根据需要进行处理。</li>
<li>处理程序退出：在main函数执行完成后，CRT会调用exit函数，用于处理程序的退出。exit函数会执行一些清理操作，例如关闭文件、释放资源等，并将控制权返回给操作系统。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.11-BSS段的处理</title>
    <url>/2023/09/05/3-11-BSS%E6%AE%B5%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-11-1-bss段"><a href="#3-11-1-bss段" class="headerlink" title="3.11.1 bss段"></a>3.11.1 bss段</h1><p>BSS（Block Started by Symbol）段是可执行文件或目标文件中的一个段（section），用于存储未初始化的全局变量和静态局部变量。BSS段具有以下特点：</p>
<ol>
<li>存储未初始化的变量：BSS段用于存储未显式初始化的全局变量和静态局部变量。这些变量在编译时没有赋予初始值，因此它们的存储空间可以在程序运行时动态地分配和初始化。</li>
<li>不占目标文件空间：在目标文件中，BSS段不占用实际的空间。这是因为BSS段中的变量在编译时并没有实际的数值，所以在目标文件中只需记录BSS段的大小和位置信息。</li>
<li>运行时分配空间：当可执行文件被加载到内存中运行时，操作系统会为BSS段分配实际的内存空间。这时，BSS段中的变量将被初始化为默认值（通常是0），以确保它们的初始状态是可预测的。</li>
<li>节省存储资源：BSS段的设计初衷是为了节省存储资源。在早期计算机系统中，存储资源非常昂贵，因此将未初始化的变量放在BSS段中可以减少目标文件的大小，节省磁盘空间。</li>
<li>记录BSS段信息：BSS段的总大小通常会在节头表（Section Header Table）中进行记录。节头表是目标文件格式中的一部分，它包含了关于各个段的信息，包括大小、位置等。此外，在符号表（Symbol Table）中也会记录每个变量的大小和地址等信息。</li>
</ol>
<h1 id="3-11-2-数据段和BSS段"><a href="#3-11-2-数据段和BSS段" class="headerlink" title="3.11.2 数据段和BSS段"></a>3.11.2 数据段和BSS段</h1><p>数据段和BSS段是可执行文件或目标文件中用于存储变量数据的段。它们在编译系统中的处理流程是相同的，但有一些差异。</p>
<p>数据段用于存储已经初始化的全局变量和静态局部变量，这些变量在编译时已经赋予了初始值。数据段在可执行文件中占据实际的存储空间，并在程序运行时保持其初始值。</p>
<p>BSS段设计的初衷是为了减少文件体积和节省磁盘资源。它用于存储未初始化的全局变量和静态局部变量，这些变量在编译时没有初始值。在目标文件中，BSS段不占用实际的存储空间，只记录其大小和位置信息。当可执行文件被加载到内存中运行时，操作系统会为BSS段分配实际的存储空间，并将其中的变量初始化为默认值。</p>
<p>总的来说，数据段和BSS段都是用于存储变量数据的段。数据段存储已初始化的变量，占据实际的存储空间，而BSS段存储未初始化的变量，不占用实际的存储空间。它们在编译系统中的处理流程相同，但在可执行文件中的表现有所不同。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.10-程序的运行</title>
    <url>/2023/09/05/3-10-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-10-1-程序的运行"><a href="#3-10-1-程序的运行" class="headerlink" title="3.10.1 程序的运行"></a>3.10.1 程序的运行</h1><p>在操作系统环境下，可执行文件通常是以ELF（Executable and Linkable Format）格式存储的。ELF文件是一种可执行文件格式，包含了程序的机器代码、数据、符号表以及其他与程序执行相关的信息。运行可执行ELF文件需要依赖操作系统提供的执行环境和系统调用。</p>
<p>在裸机环境下，即没有操作系统的情况下，常见的可执行文件格式是BIN（Binary）或HEX（Intel Hexadecimal）文件。这些文件包含了程序的机器代码，通常是一系列的二进制指令。</p>
<p>运行BIN或HEX文件需要将其加载到裸机环境中执行，这通常涉及以下步骤：</p>
<ol>
<li>将BIN&#x2F;HEX文件加载到目标设备：<ul>
<li>将BIN文件直接复制到目标设备的存储介质上，或者通过特定的通信方式将HEX文件发送到目标设备。</li>
</ul>
</li>
<li>配置目标设备的执行环境：<ul>
<li>在裸机环境中，没有操作系统提供的运行时环境，因此需要手动配置目标设备的执行环境。</li>
<li>这包括设置适当的启动地址、堆栈地址、中断向量表等。</li>
</ul>
</li>
<li>执行加载的程序：<ul>
<li>在裸机环境中，程序的执行通常是从特定的启动地址开始。</li>
<li>目标设备会按照启动地址开始执行加载的程序，即执行BIN&#x2F;HEX文件中的机器代码指令。</li>
</ul>
</li>
</ol>
<h2 id="3-10-2-可执行ELF文件"><a href="#3-10-2-可执行ELF文件" class="headerlink" title="3.10.2 可执行ELF文件"></a>3.10.2 可执行ELF文件</h2><p>可执行的ELF文件在操作系统环境下执行时，会经过加载器的处理。加载器负责将可执行文件加载到内存中，并进行相关的操作，最后跳转到程序入口处运行该程序。</p>
<p>以下是与可执行ELF文件加载相关的一些概念和信息：</p>
<ol>
<li>镜像加载地址：<ul>
<li>可执行ELF文件在内存中的加载地址，也称为镜像加载地址或基址。</li>
<li>加载器将可执行文件的代码段、数据段等内容加载到内存时，会指定一个合适的地址作为加载地址，将文件映射到该地址开始的内存空间。</li>
</ul>
</li>
<li>程序头表：<ul>
<li>可执行ELF文件中包含一个程序头表（Program Header Table），记录了不同段的信息和在内存中的加载位置。</li>
<li>程序头表指定了可执行文件镜像加载到内存中的地址。</li>
<li>每个程序头表项描述了一个段（如代码段、数据段等），包括段的类型、文件偏移、在文件中的大小、在内存中的虚拟地址等信息。</li>
</ul>
</li>
<li>ELF文件头基本信息：<ul>
<li>ELF文件的开头是一个ELF文件头（ELF Header），包含了关于该可执行文件的基本信息。</li>
<li>ELF文件头中的一些重要字段包括文件类型、运行平台（操作系统和处理器架构）、程序入口地址等。</li>
<li>文件类型字段指示该文件是可执行文件、共享库还是目标文件。</li>
<li>运行平台字段标识了目标操作系统和处理器架构。</li>
<li>程序入口地址指示了程序在执行时的起始执行点，加载器会跳转到该地址开始执行程序。</li>
</ul>
</li>
</ol>
<h1 id="3-10-3-Linux内存映像"><a href="#3-10-3-Linux内存映像" class="headerlink" title="3.10.3 Linux内存映像"></a>3.10.3 Linux内存映像</h1><p>在Linux环境下，运行可执行文件涉及到创建进程和建立虚拟地址空间与可执行文件的映射关系。下面是在Linux环境下运行可执行文件的主要步骤：</p>
<ol>
<li>创建一个独立的虚拟地址空间：<ul>
<li>当调用<code>execve</code>函数启动加载器时，操作系统会为新进程创建一个独立的虚拟地址空间。</li>
<li>虚拟地址空间是进程独立使用的内存空间，包括代码段、数据段、堆、栈等区域。</li>
</ul>
</li>
<li>读取可执行文件头，建立映射关系：<ul>
<li>加载器会读取可执行文件的文件头，其中包含了关于该文件的一些基本信息，例如入口地址、段的大小等。</li>
<li>加载器将可执行文件的不同段（如代码段、数据段）映射到进程的虚拟地址空间中的相应区域。</li>
<li>这样，进程的虚拟地址空间中的某些区域就与可执行文件的对应部分建立了映射关系。</li>
</ul>
</li>
<li>设置PC指针为可执行文件的入口地址，启动运行：<ul>
<li>在建立好虚拟地址空间与可执行文件的映射关系之后，加载器会将程序计数器（PC）指针设置为可执行文件的入口地址。</li>
<li>入口地址指示了程序在执行时的起始执行点。</li>
<li>加载器启动运行，让进程从可执行文件的入口地址开始执行。</li>
</ul>
</li>
</ol>
<h1 id="3-10-4-MMU"><a href="#3-10-4-MMU" class="headerlink" title="3.10.4 MMU"></a>3.10.4 MMU</h1><p>MMU（Memory Management Unit，内存管理单元）是计算机系统中的一个硬件组件，负责虚拟地址与物理地址之间的转换。它是操作系统实现虚拟内存的关键部分。</p>
<p>在CPU管脚的地址信号中，传递的是物理地址，即直接对应到计算机系统中的物理内存地址。但当启用MMU后，操作系统运行在虚拟地址空间上，这就涉及到虚拟地址与物理地址的转换。</p>
<p>MMU的主要用途包括：</p>
<ol>
<li>虚拟内存：MMU负责将进程使用的虚拟地址映射到物理内存中的实际地址。通过虚拟内存技术，操作系统可以将部分进程的数据和代码存储在辅助存储设备（如硬盘）上，只在需要时加载到物理内存中。这样，操作系统可以运行比实际物理内存大的程序，提高系统的可用性和性能。</li>
<li>内存保护：MMU允许操作系统为不同的内存块设置不同的读写权限。通过在虚拟地址空间和物理地址空间之间建立映射关系，并设置相应的访问权限，可以实现对内存的保护，防止进程越界访问或修改其他进程的内存数据。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.9-链接过程(3)-重定位</title>
    <url>/2023/09/05/3-9-%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B-3-%E9%87%8D%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-9-1-重定位"><a href="#3-9-1-重定位" class="headerlink" title="3.9.1 重定位"></a>3.9.1 重定位</h1><p>重定位是链接过程中的核心步骤之一，它的主要目的是修正指令中的符号地址，使得程序可以正确地访问和调用其他模块或库中的函数和变量。</p>
<p>在链接过程中，重定位完成以下任务：</p>
<ol>
<li>地址空间分配：<ul>
<li>在链接过程中，编译器和链接器会为程序分配地址空间，包括代码段、数据段、堆、栈等。</li>
<li>重定位阶段负责将各个模块的代码段和数据段中的地址修正为最终的实际地址，确保模块之间的地址空间不发生冲突。</li>
</ul>
</li>
<li>符号解析：<ul>
<li>在链接过程中，各个模块之间可能存在对函数和变量的引用或调用。</li>
<li>重定位阶段负责解析这些引用，找到对应的函数或变量的实际地址，并将其填充到引用的位置，以便程序在执行时可以正确访问和调用。</li>
</ul>
</li>
</ol>
<h1 id="3-9-2-重定位过程1"><a href="#3-9-2-重定位过程1" class="headerlink" title="3.9.2 重定位过程1"></a>3.9.2 重定位过程1</h1><p>重定位过程是在链接过程中完成的，它涉及多个步骤和数据结构：</p>
<ol>
<li>汇编阶段：<ul>
<li>在汇编阶段，汇编器会将源代码转换为机器代码，并生成目标模块。</li>
<li>当汇编器遇到未定义的符号（外部定义的函数、变量、库函数引用等），它会认为这些符号在其他地方定义，不会报错。</li>
<li>汇编器会收集这些未定义符号，并生成一个重定位表（relocation table），用于告诉链接器这些符号不在当前模块中定义，可能在其他文件或库中定义，需要在链接时进行解析。</li>
</ul>
</li>
<li>段与重定位表：<ul>
<li>目标模块通常被划分为多个段，如代码段、数据段等。</li>
<li>在每个段中，可能存在对其他文件或库中定义的函数或变量的引用。</li>
<li>汇编器会为每个段生成相应的重定位表，记录需要重定位的符号及其对应的位置信息。</li>
</ul>
</li>
<li>重定位表的生成：<ul>
<li>重定位表是一个数据结构，用于记录需要进行重定位的各种符号。</li>
<li>对于每个需要重定位的符号，重定位表会记录符号的类型（函数或变量）、位置信息（段偏移量或地址）等。</li>
<li>链接器在链接过程中会根据重定位表的信息，解析和修正这些符号的地址，使得它们指向正确的位置。</li>
</ul>
</li>
</ol>
<h1 id="3-9-3-重定位过程2"><a href="#3-9-3-重定位过程2" class="headerlink" title="3.9.3 重定位过程2"></a>3.9.3 重定位过程2</h1><p>重定位表是在ELF文件中用于记录需要进行重定位的符号及其相关信息的数据结构。在一个可重定位的ELF文件中，每个需要重定位的段都会有一个对应的重定位表，例如<code>.rel.text</code>和<code>.rel.data</code>。</p>
<p>重定位表本身也是一个段，因此也被称为重定位段。通过查看重定位表，我们可以了解在链接过程中需要进行重定位的符号以及它们在代码中的偏移位置。</p>
<p>重定位表的构成如下所示（对于32位ELF文件）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf32_Rel</span> &#123;</span></span><br><span class="line">    Elf32_Addr r_offset;  <span class="comment">// 需要重定位的项在代码中的偏移位置</span></span><br><span class="line">    Elf32_Word r_info;    <span class="comment">// 重定位类型和符号索引</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，<code>r_offset</code>字段指定了需要重定位的项在代码中的偏移位置，<code>r_info</code>字段包含了重定位类型和符号索引。</p>
<p>通过解析重定位表中的信息，链接器可以根据符号索引找到对应的符号表项，并根据重定位类型进行相应的修正，使得符号的地址指向正确的位置。</p>
<p>要查看一个ELF文件的重定位表，可以使用工具如<code>arm-linux-gnueabi-objdump</code>或<code>arm-linux-gnueabi-readelf</code>，并指定相应的选项来打印出重定位表的内容和相关信息。</p>
<h1 id="3-9-4-重定位过程3"><a href="#3-9-4-重定位过程3" class="headerlink" title="3.9.4 重定位过程3"></a>3.9.4 重定位过程3</h1><p>在链接过程中，重定位过程涉及修改符号地址，通过读取各个目标文件中的重定位信息（重定位表）来进行符号重定位，即修改指令中的符号地址。</p>
<p>具体步骤如下：</p>
<ol>
<li>读取重定位信息：<ul>
<li>链接器会读取每个目标文件中的各个段的重定位信息，通常是通过读取重定位表来获取这些信息。</li>
<li>重定位表记录了需要进行重定位的符号在代码中的位置以及相关的重定位类型和符号索引。</li>
</ul>
</li>
<li>符号重定位：<ul>
<li>链接器根据重定位表中的信息，确定各个重定位符号的新地址。</li>
<li>这些新地址的计算通常涉及到基址的概念，即新的段基址加上段内的偏移量来得到重定位地址。</li>
<li>重定位地址计算公式为：重定位地址 &#x3D; 新段基址 + 段内偏移。</li>
</ul>
</li>
<li>修改指令中的符号地址：<ul>
<li>链接器对目标文件中的指令进行扫描，在指令中定位到需要进行重定位的符号地址的位置。</li>
<li>然后，链接器会将指令中的符号地址修改为相应的重定位地址，以完成符号的重定位。</li>
</ul>
</li>
<li>形成新的符号表：<ul>
<li>在重定位过程中，链接器会根据符号索引和重定位信息，确定每个重定位符号的新地址。</li>
<li>链接器会将这些新地址形成一个新的符号表，用于在最终的可执行文件或共享库中进行符号解析和访问。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.8-链接过程(2)-符号解析-强符号与弱符号</title>
    <url>/2023/09/05/3-8-%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B-2-%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90-%E5%BC%BA%E7%AC%A6%E5%8F%B7%E4%B8%8E%E5%BC%B1%E7%AC%A6%E5%8F%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-8-1-编译器对符号的处理规则"><a href="#3-8-1-编译器对符号的处理规则" class="headerlink" title="3.8.1 编译器对符号的处理规则"></a>3.8.1 编译器对符号的处理规则</h1><p>符号（Symbol）是在程序中引用或定义的标识符，通常是函数名、全局变量名或其他标识符。符号具有以下几种不同的概念：</p>
<ul>
<li><p>强符号（Strong Symbol）：强符号是指在程序中只有一个定义的符号。当多个目标文件中存在同名的强符号时，链接器会产生冲突并报错。通常，全局变量</p>
<p>和初始化的全局变量是强符号。每个强符号在整个程序中只能有一个定义。</p>
</li>
</ul>
<p>函数名：函数名是程序中表示函数的符号。函数名通常是强符号，因为每个函数在整个程序中只能有一个定义。</p>
<p>初始化的全局变量：初始化的全局变量是指在程序中定义并显式初始化的全局变量。它们通常是强符号，因为每个初始化的全局变量在整个程序中只能有一个定义。</p>
<ul>
<li><p>弱符号（Weak Symbol）：弱符号是指在程序中可以存在多个定义的符号。当多个目标文件中存在同名的弱符号时，链接器通常会选择其中一个定义，而其他</p>
<p>的定义会被忽略。弱符号通常用于具有默认实现或可选实现的函数或变量。未初始化的全局变量也是弱符号</p>
</li>
</ul>
<p>​	未初始化的全局变量：未初始化的全局变量是指在程序中定义但没有显式初始化的全局变量。它们通常是弱符号，因为多个目标文件中可以存在同名的未初始化全局变量，链接器会在运行时将它们合并为一个共享的内存区域。</p>
<p>编译器对符号的处理规则如下：</p>
<ol>
<li>强符号：<ul>
<li>强符号不允许多次定义，每个强符号在整个程序中只能有一个定义。</li>
<li>强符号和弱符号可以共存，即在程序中可以同时存在强符号和弱符号。</li>
<li>当强符号和弱符号共存时，强符号会覆盖弱符号。在链接时，如果存在多个同名符号，链接器会选择强符号作为最终的定义。</li>
</ul>
</li>
<li>弱符号：<ul>
<li>编译器允许多个弱符号在程序中存在。</li>
<li>在编译期间，编译器并不知道弱符号所占用的空间大小。为了解决这个问题，编译器会使用一个未定义的COMMON符号来代替弱符号的定义。COMMON符号表示一个未初始化的全局变量或未分配内存的占位符。</li>
<li>在链接期间，链接器会比较多个文件中的弱符号，并选择占用空间最大的弱符号作为最终的定义。这意味着在多个目标文件中存在同名弱符号时，链接器会选择占用空间最大的弱符号来作为最终的定义。</li>
</ul>
</li>
</ol>
<h1 id="3-8-2-弱符号与BSS段"><a href="#3-8-2-弱符号与BSS段" class="headerlink" title="3.8.2 弱符号与BSS段"></a>3.8.2 弱符号与BSS段</h1><p>弱符号和BSS段在编译和链接过程中的关系如下：</p>
<ol>
<li>不同目标文件中的BSS段：<ul>
<li>BSS段是用于存储未初始化的全局变量和静态变量的内存段。</li>
<li>在编译阶段，编译器将未初始化的全局变量和静态变量标记为BSS段，并分配了对应的空间。但是，BSS段中的变量并没有实际的初始化值。</li>
<li>在链接阶段，多个目标文件中的BSS段会被合并到一个统一的BSS段中，以便在最终的可执行文件中分配内存。</li>
</ul>
</li>
<li>可重定位目标文件的链接：<ul>
<li>在可重定位目标文件的链接过程中，链接器不会确定弱符号的最终定义。因此，未初始化的全局变量和弱符号不会放在BSS段中，而是放在临时的COMMON块中。</li>
<li>COMMON块是一个临时的内存区域，用于存放未初始化的全局变量和弱符号。在链接器最终确定了弱符号的定义后，它们将被分配到最终的BSS段中。</li>
</ul>
</li>
<li>可执行目标文件的链接：<ul>
<li>在可执行目标文件的链接过程中，链接器已经确定了弱符号的最终定义。</li>
<li>弱符号被分配了一个最大的空间，并放置在BSS段中。这是因为在链接过程中，链接器选择了占用空间最大的弱符号作为最终的定义，并为其分配了足够的内存空间。</li>
</ul>
</li>
</ol>
<h1 id="3-8-3-强引用与弱引用"><a href="#3-8-3-强引用与弱引用" class="headerlink" title="3.8.3 强引用与弱引用"></a>3.8.3 强引用与弱引用</h1><p>强引用和弱引用是指对符号的引用的特性，而符号本身代表一个地址，可以是函数或变量的名称。</p>
<p>在一个文件内，当我们定义一个函数或变量时，其函数名或变量名就是一个符号。在另一个文件中，如果我们通过函数名或变量名来调用该函数或引用该变量，就称为对符号的引用。引用的本质是使用符号的地址。</p>
<p>特点如下：</p>
<ol>
<li>强引用：<ul>
<li>当一个符号引用被标记为强引用时，如果在链接时找不到该符号的定义，链接过程将会报错。</li>
<li>强引用表示对符号的依赖性较高，如果缺少了符号的定义，程序无法正常链接和执行。</li>
</ul>
</li>
<li>弱引用：<ul>
<li>当一个符号引用被标记为弱引用时，如果这个符号没有定义，链接过程不会报错，而是在运行时可能会导致错误。</li>
<li>弱引用表示对符号的依赖性较低，如果缺少了符号的定义，链接过程仍然可以继续，但在运行时可能会遇到未定义符号的错误。</li>
</ul>
</li>
</ol>
<p>根据符号引用是否为0（即空指针或空引用），我们可以在程序中判断是否执行某个函数。如果符号引用为0，表示符号没有定义，可以根据这个判断来避免执行相应的函数。</p>
<h1 id="3-8-4-弱引用的应用"><a href="#3-8-4-弱引用的应用" class="headerlink" title="3.8.4 弱引用的应用"></a>3.8.4 弱引用的应用</h1><p>弱引用在以下场景中常被应用：</p>
<ol>
<li>库：<ul>
<li>在使用库时，可以将库中的函数定义为弱引用。</li>
<li>这样，在链接时，如果存在相同名称的函数定义，链接器会选择强引用的函数定义，但如果找不到强引用的函数定义，就会选择弱引用的函数定义。</li>
<li>这使得我们可以自定义函数来覆盖库中的函数，使用自定义版本的库函数。</li>
</ul>
</li>
<li>扩展功能模块：<ul>
<li>当程序依赖于某些可选的扩展功能模块时，可以将这些模块的引用定义为弱引用。</li>
<li>这样，在链接时，如果这些模块不存在或被删除，程序仍然可以正常链接和运行，因为对这些模块的引用是弱引用，链接器不会报错。</li>
</ul>
</li>
<li>多线程：<ul>
<li>在多线程编程中，有时需要根据运行时环境的不同来决定是否开启多线程模式。</li>
<li>例如，在Linux下，可以将<code>pthread_create</code>函数定义为弱引用。</li>
<li>运行时，程序可以判断链接的是单线程版本的glibc库还是多线程版本的glibc库，从而决定是否启用多线程模式。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.7-链接过程(1)-地址空间分配与链接脚本</title>
    <url>/2023/09/05/3-7-%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B-1-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E4%B8%8E%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-7-1-链接的重要性"><a href="#3-7-1-链接的重要性" class="headerlink" title="3.7.1 链接的重要性"></a>3.7.1 链接的重要性</h1><p>链接（Linking）是将多个可重定位目标文件合并、组装成可执行目标文件或共享库的过程。链接器（Linker）是执行链接操作的工具或程序。</p>
<p>链接的主要目的是解决多个目标文件之间的符号引用和地址重定位问题，使得程序能够正确地执行。</p>
<p>链接过程包括以下主要步骤：</p>
<ol>
<li>地址空间分配：链接器将可执行目标文件加载到内存中的适当地址空间中。这涉及到分配代码段、数据段、堆栈等内存区域，并为每个目标文件分配适当的地址范围。</li>
<li>符号解析：在链接过程中，符号解析是一个重要的步骤。符号解析的目的是解决符号的引用关系，将符号引用与符号定义进行匹配。在符号解析阶段，链接器会根据符号的绑定属性（如全局、局部、弱符号）来确定符号的可见性和重复定义规则。<ul>
<li>强符号（Strong Symbols）：具有全局绑定属性的符号，优先级高于弱符号。如果存在多个强符号同名定义，链接器会报错。</li>
<li>弱符号（Weak Symbols）：具有弱绑定属性的符号，允许在多个目标文件中重复定义。如果存在多个弱符号同名定义，并且没有对应的强符号，链接器会选择其中一个定义。</li>
</ul>
</li>
<li>重定位（Relocation）：重定位是将目标文件中的地址引用转换为最终可执行文件中的实际地址的过程。在链接过程中，由于目标文件中的地址是相对于各自的节（Section）的起始地址的偏移量，因此需要进行重定位操作，将这些相对地址转换为绝对地址。重定位过程涉及到修正目标文件中的跳转、调用和数据访问等指令，使得它们指向正确的地址。</li>
</ol>
<h1 id="3-7-2-地址空间分配"><a href="#3-7-2-地址空间分配" class="headerlink" title="3.7.2 地址空间分配"></a>3.7.2 地址空间分配</h1><p>地址空间分配是链接过程中的一项重要任务，它确定了各个目标文件中不同段（如代码段、数据段、bss段）在最终可执行目标文件中的位置和大小。</p>
<p>以下是地址空间分配的一般步骤：</p>
<ol>
<li>扫描所有目标文件：链接器会逐个扫描所有目标文件，包括主程序文件和库文件。对于每个目标文件，链接器会读取其文件头部和段表等信息。</li>
<li>获取段信息：链接器从各个目标文件的段表中获取各个段的信息，包括段的类型（如代码段、数据段、bss段）、大小和对齐等属性。每个目标文件中的段表记录了该文件中各个段的位置和长度。</li>
<li>确定链接地址：链接器会指定一个链接地址（linkaddr）作为起始地址，用于存放最终可执行目标文件的各个段。</li>
<li>合并同类型段：链接器按照段的类型（代码段、数据段、bss段）顺序，将各个目标文件中相同类型的段进行合并。对于代码段和数据段，链接器会根据链接地址和各个段的偏移量（offset）计算出最终的段地址。</li>
<li>重新计算段长度和位置：合并后，链接器会重新计算各个段的长度和位置。对于代码段和数据段，它们的长度是各个段的长度之和；而对于bss段，它的长度通常为0，因为bss段存放的是未初始化的全局变量和静态变量。</li>
<li>处理库文件：链接器还会处理库文件，将库文件中的目标模块合并到最终的可执行目标文件中。这涉及到符号解析、重定位和符号表的更新等操作。</li>
</ol>
<h1 id="3-7-3-创建全局符号表"><a href="#3-7-3-创建全局符号表" class="headerlink" title="3.7.3 创建全局符号表"></a>3.7.3 创建全局符号表</h1><p>创建全局符号表是链接过程的一项关键任务，它的目的是将各个目标文件中的符号收集起来，并统一保存在一个全局符号表中。</p>
<p>以下是创建全局符号表的一般步骤：</p>
<ol>
<li>扫描所有目标文件：链接器会逐个扫描所有目标文件，包括主程序文件和库文件。对于每个目标文件，链接器会读取其符号表信息。</li>
<li>收集符号：链接器从每个目标文件的符号表中收集符号信息。符号表中包含了各个目标文件中定义和引用的符号的名称、属性和地址等信息。</li>
<li>统一放入全局符号表：链接器将从各个目标文件中收集到的符号统一放入一个全局符号表中。全局符号表是链接器维护的一个数据结构，用于保存所有目标文件中的符号信息。</li>
<li>相对零地址偏移：在创建全局符号表时，符号的地址仍然是相对于零地址的偏移量。这是因为在链接过程的后续阶段，还需要进行重定位操作，将符号的地址转换为最终可执行目标文件中的实际地址。</li>
</ol>
<h1 id="3-7-4-链接脚本"><a href="#3-7-4-链接脚本" class="headerlink" title="3.7.4 链接脚本"></a>3.7.4 链接脚本</h1><p>不同的代码段在链接过程中的组装是由链接脚本（Linker Script）来规定的。链接脚本是一个文本文件，其中包含了链接器的指令和规则，用于指导链接器如何组装各个代码段。</p>
<p>链接脚本通常包含以下信息：</p>
<ol>
<li>组装顺序：链接脚本规定了各个代码段的组装顺序。根据链接脚本的指定顺序，链接器会按照代码段的顺序将它们组装到最终可执行目标文件中。</li>
<li>起始地址：链接脚本指定了各个代码段在最终可执行目标文件中的起始地址。链接器会根据链接脚本中的地址规定，将各个代码段放置到相应的地址位置。</li>
<li>位置对齐：链接脚本还规定了代码段的位置对齐要求。根据链接脚本中指定的对齐规则，链接器会确保代码段在最终可执行目标文件中按照规定的对齐边界进行放置。</li>
<li>输出格式和运行平台：链接脚本可以指定输出可执行文件的格式和运行平台。这些信息对于生成符合特定格式和平台要求的可执行目标文件非常重要。</li>
<li>入口地址：链接脚本可以指定可执行目标文件的入口地址。入口地址是程序执行的起始点，在加载和执行可执行文件时，操作系统会将控制权转移到指定的入口地址处开始执行程序。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">oUTPUT_FORMAT( <span class="string">&quot;elf32-littlearm”</span></span><br><span class="line"><span class="string">&quot;</span>elf32-bigarm”</span><br><span class="line"><span class="string">&quot;elf32-littlearm”)</span></span><br><span class="line"><span class="string">;输出ELF麻件格式</span></span><br><span class="line"><span class="string">OUTPUT_ARCH( “arm”)</span></span><br><span class="line"><span class="string">;输出可执行文件的运行平台为arm</span></span><br><span class="line"><span class="string">ENTRY(_start)</span></span><br><span class="line"><span class="string">;程序入口地址</span></span><br><span class="line"><span class="string">SECTIONS</span></span><br><span class="line"><span class="string">;各段描述</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">.= Ox60000000;</span></span><br><span class="line"><span class="string">;代码段起始地址</span></span><br><span class="line"><span class="string">.text:&#123;*(.text)&#125;</span></span><br><span class="line"><span class="string">;代码段描述:所有.o文件的. text</span></span><br><span class="line"><span class="string">.= Ox60200000;</span></span><br><span class="line"><span class="string">;数据段的起始地址</span></span><br><span class="line"><span class="string">.data: &#123;*(. data)&#125;</span></span><br><span class="line"><span class="string">;数据段描述</span></span><br><span class="line"><span class="string">.bss :&#123;*(. bss)&#125;</span></span><br><span class="line"><span class="string">; BSS段描述</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>在SECTIONS部分，代码段的起始地址为0x60000000，紧接着是代码段的描述；数据段的起始地址为0x60200000，后面是数据段的描述；最后是BSS段的描述。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.6-编译过程(3)-符号表</title>
    <url>/2023/09/05/3-6-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B-3-%E7%AC%A6%E5%8F%B7%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-6-1-符号表"><a href="#3-6-1-符号表" class="headerlink" title="3.6.1 符号表"></a>3.6.1 符号表</h1><p>符号表在编译过程中起到了重要的作用，主要用来保存源程序中各种符号（如变量、函数、类、常量等）的相关信息，如地址值、类型、占用空间的大小等。</p>
<p>符号表的主要作用如下：</p>
<ol>
<li>辅助语义检查：符号表可以用于辅助编译器进行语义检查。编译器通过符号表来验证标识符的合法性、类型匹配等语义规则，以确保源程序的语义正确性。例如，编译器在进行类型检查时可以通过符号表中记录的类型信息来判断赋值操作是否合法。</li>
<li>辅助代码生成：符号表在代码生成阶段发挥重要作用。编译器通过符号表来进行地址和空间的分配，以确定变量和函数在内存中的位置。符号表中记录的地址信息可以用于生成汇编代码或机器代码时的地址计算。例如，编译器可以根据符号表中的地址信息为变量分配栈空间或静态数据区空间。</li>
<li>符号决议：符号表用于解析标识符的引用，即在程序中使用某个标识符时，找到该标识符的定义位置。编译器通过符号表中记录的定义位置信息来处理标识符的引用，以确保标识符在使用前已经被定义。符号决议阶段还包括解决标识符的作用域和命名空间等问题。</li>
<li>重定位：符号表用于链接器进行符号重定位。在多个目标文件进行链接时，链接器需要解析和处理目标文件中的符号引用。链接器通过符号表中记录的地址信息，将符号引用链接到正确的地址上，以确保最终生成的可执行文件能够正确地访问和使用各个目标文件中的符号。</li>
</ol>
<h1 id="3-6-2-elf文件和bin文件"><a href="#3-6-2-elf文件和bin文件" class="headerlink" title="3.6.2 elf文件和bin文件"></a>3.6.2 elf文件和bin文件</h1><p>ELF文件和BIN文件是两种不同的可执行文件格式。</p>
<p>BIN文件是一种纯粹的二进制文件，只包含机器码，没有附加的元数据信息。它通常被称为raw binary文件或镜像文件。BIN文件中的机器码是直接按照内存中的布局排列的，没有分节或分段的概念。常见的BIN文件格式还包括HEX文件，它以十六进制形式表示机器码。</p>
<p>而ELF文件（Executable and Linkable Format）是一种更为复杂的可执行文件格式。除了包含机器码之外，ELF文件还包含了一些额外的元数据信息，用于描述程序的结构、加载地址、运行地址等。ELF文件具有分节（Section）和分段（Segment）的概念，不同的节和段存储了不同的信息，如代码段、数据段、符号表、重定位表等。</p>
<p>ELF文件的结构包括以下几个重要的部分：</p>
<ol>
<li>ELF头（ELF Header）：位于文件的开头，包含了对整个ELF文件的描述信息，如文件类型、目标体系结构、入口地址等。</li>
<li>节表（Section Table）：记录了ELF文件中各个节的信息。每个节存储了特定类型的数据，例如代码、数据、符号表、重定位表等。节表中的每个表项描述了一个节的名称、大小、偏移量等信息。</li>
<li>段表（Segment Table）：记录了ELF文件中各个段的信息。段是逻辑上一组相关的节的集合，用于定义程序的内存布局。段表中的每个表项描述了一个段的类型、虚拟地址、文件偏移量等信息。</li>
<li>符号表（Symbol Table）：记录了程序中定义和引用的符号（如变量、函数、类等）的信息。符号表中的每个表项描述了一个符号的名称、类型、地址等信息。符号表在链接过程中用于解析符号引用和进行符号重定位。</li>
<li>重定位表（Relocation Table）：记录了需要进行符号重定位的位置和相关信息。重定位表在链接过程中用于调整代码和数据的位置，确保程序能够正确访问和使用符号。</li>
</ol>
<h1 id="3-6-3-readelf-s-和readelf-S-的区别"><a href="#3-6-3-readelf-s-和readelf-S-的区别" class="headerlink" title="3.6.3 readelf -s 和readelf -S 的区别"></a>3.6.3 readelf -s 和readelf -S 的区别</h1><p><code>readelf -s</code>和<code>readelf -S</code>是<code>readelf</code>命令的两个不同的选项，它们用于显示ELF文件中的不同部分信息。</p>
<ol>
<li><code>readelf -s</code>：该选项用于显示ELF文件的符号表（Symbol Table）。符号表记录了程序中定义和引用的符号（如变量、函数、类等）的信息。使用<code>readelf -s</code>命令可以列出符号表中的所有符号，包括符号的名称、类型、绑定属性、地址等信息。这对于进行符号分析、调试和动态链接等操作非常有用。</li>
<li><code>readelf -S</code>：该选项用于显示ELF文件的节表（Section Table）。节表记录了ELF文件中各个节的信息，每个节存储了特定类型的数据，如代码、数据、符号表、重定位表等。使用<code>readelf -S</code>命令可以列出节表中的所有节，包括节的名称、类型、大小、偏移量、虚拟地址等信息。这对于了解程序的内存布局、代码和数据段的大小以及节之间的关系非常有帮助。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/home/topeet/demo# readelf -s sub.o </span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 13 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS sub.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    2 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     9: 0000000000000000    24 FUNC    GLOBAL DEFAULT    1 add</span><br><span class="line">    10: 0000000000000018    22 FUNC    GLOBAL DEFAULT    1 sub</span><br><span class="line">    11: 000000000000002e    23 FUNC    GLOBAL DEFAULT    1 mul</span><br><span class="line">    12: 0000000000000045    23 FUNC    GLOBAL DEFAULT    1 div</span><br><span class="line">root@ubuntu:/home/topeet/demo# readelf -S sub.o </span><br><span class="line">There are 12 section headers, starting at offset 0x398:</span><br><span class="line"></span><br><span class="line">节头：</span><br><span class="line">  [号] 名称              类型             地址              偏移量</span><br><span class="line">       大小              全体大小          旗标   链接   信息   对齐</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000005c  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .data             PROGBITS         0000000000000000  0000009c</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 3] .bss              NOBITS           0000000000000000  0000009c</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .comment          PROGBITS         0000000000000000  0000009c</span><br><span class="line">       000000000000002c  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 5] .note.GNU-stack   PROGBITS         0000000000000000  000000c8</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 6] .note.gnu.propert NOTE             0000000000000000  000000c8</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 7] .eh_frame         PROGBITS         0000000000000000  000000e8</span><br><span class="line">       0000000000000098  0000000000000000   A       0     0     8</span><br><span class="line">  [ 8] .rela.eh_frame    RELA             0000000000000000  000002d0</span><br><span class="line">       0000000000000060  0000000000000018   I       9     7     8</span><br><span class="line">  [ 9] .symtab           SYMTAB           0000000000000000  00000180</span><br><span class="line">       0000000000000138  0000000000000018          10     9     8</span><br><span class="line">  [10] .strtab           STRTAB           0000000000000000  000002b8</span><br><span class="line">       0000000000000017  0000000000000000           0     0     1</span><br><span class="line">  [11] .shstrtab         STRTAB           0000000000000000  00000330</span><br><span class="line">       0000000000000067  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br><span class="line">root@ubuntu:/home/topeet/demo# </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3-6-3-符号类型和绑定属性"><a href="#3-6-3-符号类型和绑定属性" class="headerlink" title="3.6.3 符号类型和绑定属性"></a>3.6.3 符号类型和绑定属性</h1><p>符号类型和绑定属性是符号表中的两个重要概念，用于描述符号的特性和可见性。</p>
<ol>
<li>符号类型（Symbol Type）：符号类型描述了符号关联的实体类型，即符号表示的是什么。在符号表中常见的符号类型包括：</li>
</ol>
<ul>
<li>OBJECT（对象）：符号关联的是一个数据对象，如变量、数组或指针。</li>
<li>FUNC（函数）：符号关联到一个函数或过程。</li>
<li>SECTION（节）：符号关联到一个节的名字。</li>
<li>FILE（文件）：符号关联一个文件名。</li>
<li>NOTYPE（未指定类型）：符号的类型未指定，它常用于未定义的引用。</li>
</ul>
<p>2.绑定属性（Binding Attribute）：绑定属性描述了符号的可见性和重复定义的规则。在符号表中常见的绑定属性包括：</p>
<ul>
<li>LOCAL（局部）：局部符号只在目标文件内可见，多个目标文件可以有相同的局部符号名而不会冲突。</li>
<li>GLOBAL（全局）：全局符号在目标文件内部可见，也可以被其他文件引用。全局符号在整个程序中是可见的，但是不同文件中的全局符号名称不能重复。</li>
<li>WEAK（弱）：弱符号是一种特殊的全局符号，它可以在多个文件中重复定义。即使弱符号未定义，链接过程也不会报错，而是将其符号值设置为0。弱符号可以被强符号覆盖。</li>
</ul>
<h1 id="3-6-4-节索引"><a href="#3-6-4-节索引" class="headerlink" title="3.6.4 节索引"></a>3.6.4 节索引</h1><p>节索引（Section Index）是在符号表中使用的一个索引值，用于指示每个符号所在的节（Section）。</p>
<p>在目标文件中，包含了多个节（如代码节、数据节、符号表节等），用于存储不同类型的数据和信息。而符号表（Symbol Table）中保存了所有节的符号信息。</p>
<p>为了确定每个符号所在的具体节，符号表中的每个符号都使用一个节索引来表示其所在的节。节索引是一个非负整数，它对应着目标文件中节头表（Section Header Table）中的表项序号。</p>
<p>节头表是目标文件中的一部分，用于描述每个节的属性和位置等信息。每个节头表的表项都包含了该节的名称、类型、大小、偏移量等信息。通过符号表中的节索引，可以找到符号所属的具体节，并将该符号绑定到该节上。</p>
<p>在符号表中，还有几个特殊的节索引值：</p>
<ul>
<li>ABS：表示符号的绝对值，不需要进行重定位，即该符号的地址是绝对的。</li>
<li>UNDEF：表示未定义符号，即在当前模块中引用了该符号，但在其他地方定义。</li>
<li>COMMON：表示尚未分配位置的未初始化数据，通常用于全局未初始化的变量。</li>
</ul>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.5-编译过程(2)-汇编过程</title>
    <url>/2023/09/05/3-5-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B-2-%E6%B1%87%E7%BC%96%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-5-1-汇编过程"><a href="#3-5-1-汇编过程" class="headerlink" title="3.5.1 汇编过程"></a>3.5.1 汇编过程</h1><p>汇编过程的基本流程如下：</p>
<ol>
<li>词法分析：在这个阶段，汇编器将输入的源文件（通常以.s为后缀，如main.s）进行词法分析。词法分析器将源代码分解为一个个的词法单元，如指令、寄存器、标识符等，并生成词法单元流。</li>
<li>语法分析：在语法分析阶段，汇编器使用词法单元流进行语法分析。语法分析器根据语法规则将词法单元流解析为语法结构，并构建相应的语法树。语法分析过程中还会生成符号表，用于记录和管理标识符、变量和常量等信息。</li>
<li>组装：在组装阶段，汇编器将语法树转换为可执行的目标文件。这个过程包括将汇编指令转换为机器指令、填充符号表、生成重定位表等。组装器的主要任务是将汇编代码转换为机器代码，并生成可执行目标文件。</li>
<li>代码生成：在代码生成阶段，汇编器根据语法树和符号表生成目标文件的指令。这个阶段涉及指令的翻译和生成各种表信息，如重定位表、赋值信息等。指令的翻译过程将汇编指令转化为目标机器的机器指令，生成的表信息用于链接和重定位等操作。</li>
<li>主要工作：汇编过程的主要工作包括词法分析、语法分析、组装、代码生成和生成各种表信息。这些工作协同完成，最终生成可重定位目标文件（通常以.o为后缀，如main.o）。</li>
</ol>
<h1 id="3-5-2-符号表（Symbol-Table）"><a href="#3-5-2-符号表（Symbol-Table）" class="headerlink" title="3.5.2 符号表（Symbol Table）"></a>3.5.2 符号表（Symbol Table）</h1><p>​	符号表（Symbol Table）是编译器和链接器中存储程序中符号信息的数据结构。它记录了源代码中定义和引用的变量、函数、类、常量等标识符的相关信息，如名称、类型、内存地址等。符号表在编译和链接过程中起着重要的作用，用于解析符号引用、符号重定位和符号解析等任务。</p>
<p>符号表通常包含以下信息：</p>
<ol>
<li>符号名称（Symbol Name）：记录标识符的名称，如变量名、函数名等。</li>
<li>符号类型（Symbol Type）：指示标识符的类型，如整型、浮点型、函数等。</li>
<li>符号属性（Symbol Attributes）：记录标识符的属性，如是否为全局变量、局部变量、静态变量等。</li>
<li>内存地址（Memory Address）：记录标识符在内存中的地址或偏移量。</li>
<li>作用域（Scope）：指示标识符的作用域范围，如全局作用域、局部作用域等。</li>
<li>定义位置（Definition Location）：记录标识符的定义位置，用于解析符号引用。</li>
<li>引用位置（Reference Locations）：记录标识符的引用位置，用于解析符号引用。</li>
</ol>
<p>符号表在编译过程中起着重要的作用：</p>
<ol>
<li>语法分析：在语法分析阶段，编译器将标识符添加到符号表中，并记录其名称、类型和定义位置等信息。</li>
<li>符号解析：在编译器的符号解析阶段，通过符号表来解析标识符的引用。编译器会检查符号表，找到标识符的定义位置，并进行类型检查和语义分析。</li>
<li>重复定义检查：符号表可以检查是否存在重复定义的标识符，如重复的变量名或函数名。</li>
<li>作用域管理：符号表中的作用域信息可以帮助编译器正确处理局部变量和全局变量的作用域范围。</li>
<li>符号重定位：在链接过程中，符号表用于解析符号引用和进行符号重定位。链接器会根据符号表中的地址信息，将各个目标文件中的符号引用链接到正确的地址上。</li>
</ol>
<h1 id="3-5-3-重定位表（Relocation-Table）"><a href="#3-5-3-重定位表（Relocation-Table）" class="headerlink" title="3.5.3 重定位表（Relocation Table）"></a>3.5.3 重定位表（Relocation Table）</h1><p>​	重定位表（Relocation Table）是链接器生成的一种表格，用于记录需要进行符号重定位的位置和相关信息。在目标文件中，由于代码和数据的位置是相对于起始地址的偏移量，因此在链接时需要对这些位置进行调整，以确保最终生成的可执行文件能够正确地访问和使用这些代码和数据。</p>
<p>重定位表通常包含以下信息：</p>
<ol>
<li>符号名称（Symbol Name）：记录需要进行重定位的符号的名称。</li>
<li>重定位类型（Relocation Type）：指示需要进行的重定位类型，如绝对重定位、相对重定位等。</li>
<li>位置（Location）：记录需要进行重定位的位置或偏移量。</li>
<li>目标地址（Target Address）：记录需要重定位到的目标地址。</li>
</ol>
<p>重定位表在链接过程中起着重要的作用：</p>
<ol>
<li>符号解析与重定位：链接器通过重定位表中的信息，对目标文件中的符号引用进行解析和重定位。它会根据目标文件的符号表和重定位表，将符号引用链接到正确的地址上。</li>
<li>位置调整：重定位表中记录了需要进行重定位的位置和目标地址，链接器根据这些信息对目标文件中的代码和数据位置进行调整，使其能够正确地访问和使用。</li>
<li>符号冲突解决：如果存在多个目标文件中相同名称的符号，重定位表可以帮助链接器解决符号冲突的问题。通过重定位表中的符号名称和目标地址，链接器可以确定每个符号应该链接到的具体地址，从而避免冲突。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.4-编译过程(1)-从源程序到汇编文件</title>
    <url>/2023/09/05/3-4-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B-1-%E4%BB%8E%E6%BA%90%E7%A8%8B%E5%BA%8F%E5%88%B0%E6%B1%87%E7%BC%96%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-4-1-编译输入输出"><a href="#3-4-1-编译输入输出" class="headerlink" title="3.4.1 编译输入输出"></a>3.4.1 编译输入输出</h1><p>编译过程主要是将高级语言（如C语言）的源代码转换为低级语言（如汇编语言或机器语言），以便计算机可以理解和执行。</p>
<p>在编译过程中，主要的步骤包括：</p>
<ol>
<li>词法分析（Lexical Analysis）：将源代码划分为词法单元（tokens），例如关键字、标识符、运算符和常量等。词法分析器（也称为扫描器）会扫描源代码，并生成词法单元流。</li>
<li>语法分析（Syntax Analysis）：根据语法规则，将词法单元流组织成语法树（Parse Tree）或抽象语法树（Abstract Syntax Tree，AST）。语法分析器（也称为解析器）会检查语法的正确性，并生成语法树或AST。</li>
<li>语义分析（Semantic Analysis）：对语法树或AST进行语义检查，包括类型检查、语义规则验证等。语义分析器会确保程序在语义上是合法的，并生成相应的符号表（Symbol Table）来记录变量、函数等的信息。</li>
<li>中间代码生成（Intermediate Code Generation）：将语法树或AST转换为中间表示形式，通常是一种类似于三地址码的中间代码。中间代码是一种抽象的表示形式，它更接近于底层的机器语言，但仍保留了高级语言的结构特点。</li>
<li>代码优化（Code Optimization）：对中间代码进行优化，以改善程序的性能、减少代码的执行时间或空间占用。代码优化技术包括常量传播、循环展开、公共子表达式消除等，旨在生成更高效的目标代码。</li>
<li>目标代码生成（Code Generation）：将优化后的中间代码转换为目标机器的机器代码或汇编代码。目标代码生成器会根据目标机器的体系结构和指令集生成对应的机器代码或汇编代码。</li>
<li>链接（Linking）：如果程序包含多个源文件或库文件，链接器会将它们合并为一个可执行文件。链接过程包括符号解析、重定位等步骤，以确保程序中引用的函数和变量正确地连接到对应的定义。</li>
</ol>
<h1 id="3-4-2-词法分析"><a href="#3-4-2-词法分析" class="headerlink" title="3.4.2 词法分析"></a>3.4.2 词法分析</h1><p>词法分析是编译过程中的一项关键任务，它将源代码作为输入，并将其划分为一系列记号（tokens）。</p>
<p>在词法分析过程中，主要的步骤包括：</p>
<ol>
<li>从左到右读取源程序：词法分析器按顺序逐个字符地读取源代码，从左到右进行扫描。</li>
<li>扫描和分解记号：词法分析器根据语言的词法规则，将源程序的字符流分解成一系列记号。记号可以是关键字、标识符、字面量（数字、字符串等）、特殊字符（运算符等）和分界符（分号、逗号等）等。</li>
<li>构建记号流：词法分析器将分解出的记号按顺序构建记号流，以便后续的语法分析和语义分析等阶段使用。</li>
<li>符号表：在词法分析过程中，识别到的标识符（如函数名、变量名、标号等）会被记录在符号表中。符号表是编译器维护的一张表格，用于存储标识符的属性信息（如类型、作用域等）。</li>
<li>字符串表：识别到的数字、字符串等字面量会被存放在字符串表中。字符串表是一个存储字符串字面量的表格，编译器可以使用索引来引用字符串表中的内容，以减少内存占用和提高效率。</li>
</ol>
<h1 id="3-4-3-语法分析"><a href="#3-4-3-语法分析" class="headerlink" title="3.4.3 语法分析"></a>3.4.3 语法分析</h1><p>语法分析是编译过程中的一个重要阶段，它根据语法规则检查词法分析器生成的记号流，以确定是否构成一个语法上正确的程序，并将其分解为语法短语（如程序、语句、表达式等）。语法分析器将记号流转化为语法树（Parse Tree），它是一种树形结构，表示了程序的语法结构。</p>
<p>在语法分析过程中，主要的步骤包括：</p>
<ol>
<li>语法规则：语法分析器使用预定义的语法规则来判断记号流是否符合语法要求。语法规则描述了语言的语法结构，包括语句的组成、表达式的形式等。</li>
<li>语法树构建：语法分析器根据语法规则，将记号流转化为语法树。语法树是一种树形结构，它以记号为节点，将程序的语法结构表示为树的分支和叶子节点。</li>
<li>语法分析工具：为了简化语法分析的实现，可以使用专门的语法分析工具，如Yacc（Yet Another Compiler Compiler）。这些工具提供了一种形式化的方式来描述语法规则，并自动生成语法分析器的代码。</li>
<li>通用性：由于语法规则是与编程语言相关的，不同的编程语言具有不同的语法规则。但幸运的是，对于常见的编程语言，不需要为每个编译器编写一个新的语法分析器。相同的语法分析技术和工具可以用于不同的编程语言，只需要提供相应的语法规则。</li>
<li>语法错误：如果记号流不能按照语法规则进行正确的匹配，就会发生语法错误（syntax error）。语法分析器会检测这些错误并生成相应的错误信息，指示程序中存在哪些语法错误以及其位置。</li>
</ol>
<h1 id="3-4-4-语义分析"><a href="#3-4-4-语义分析" class="headerlink" title="3.4.4 语义分析"></a>3.4.4 语义分析</h1><p>语义分析是编译过程中的一个关键阶段，它在语法分析的基础上对语句、程序、表达式等进行进一步检查，以确定其语义是否正确。语义分析器会检查静态语义和动态语义，并对整个语法树的表达式进行类型标注。</p>
<p>在语义分析过程中，主要的任务包括：</p>
<ol>
<li>静态语义：静态语义分析在编译期间进行，它关注的是在编译期能够确定的语义。静态语义包括函数实参与形参的类型匹配和转换、变量的声明和使用、类型检查等。例如，语义分析器会检查函数调用时实参与形参的类型是否匹配，是否存在未声明的变量等。</li>
<li>动态语义：动态语义分析在运行期间进行，它关注的是在运行时才能确定的语义。动态语义包括除数为零、数组越界访问等。例如，语义分析器会检查除法表达式中除数是否为零，以避免发生运行时错误。</li>
<li>类型标注：语义分析器会对整个语法树的表达式进行类型标注，即为每个表达式确定其类型信息。这可以帮助后续的代码生成和优化阶段进行类型检查和优化操作。</li>
<li>语义分析器：语义分析器是执行语义分析的工具或组件。它接收语法分析器生成的语法树作为输入，并根据语义规则进行分析和检查。语义分析器会发现并报告语义错误，如类型不匹配、未声明的变量等。</li>
</ol>
<h1 id="3-4-5-第四阶段"><a href="#3-4-5-第四阶段" class="headerlink" title="3.4.5 第四阶段"></a>3.4.5 第四阶段</h1><p>第四阶段是编译器的中间代码生成阶段。在这个阶段，编译器将语法树转换为中间代码，以便进行后续的优化和目标代码生成。</p>
<p>中间代码是一种抽象的表示形式，它通常比源代码更接近于目标代码，但仍具有较高的可移植性和可理解性。中间代码使得编译器可以对程序进行统一的优化处理，而不受目标机器的限制。</p>
<p>现代编译器的构造通常包括以下三个主要组成部分：</p>
<ol>
<li>前端：前端负责词法分析、语法分析和语义分析等任务。它将源代码转换为中间表示形式（如语法树或中间代码），并进行基本的语法和语义检查。前端确保源代码在语法和语义上是正确的，并为后续的优化和代码生成阶段提供准确的输入。</li>
<li>优化器：优化器是编译器的重要组成部分，它对中间代码进行优化。优化器通过分析和重写中间代码，以提高程序的执行效率、减少代码大小或改进其他性能指标。优化器使用各种技术，如常量传播、循环优化、数据流分析等，来改进程序的质量和性能。</li>
<li>后端：后端负责将优化后的中间代码转换为目标机器的汇编代码或机器代码。后端包括指令选择（将中间代码转换为适合目标机器的指令序列）、寄存器分配（为变量选择寄存器）、代码布局、代码生成等任务。后端将优化后的中间代码转化为目标机器能够执行的代码。</li>
</ol>
<p>中间代码是一维线性序列，更容易生成和处理。它可以在后续的优化和代码生成阶段中进行处理和转换。</p>
<p>生成中间代码的过程通常在语义分析阶段之后，在优化器之前。语义分析器将源代码转换为语法树，然后通过对语法树进行遍历和转换，生成中间代码表示。这个过程包括将每个语法结构转换为相应的中间代码指令，并保留必要的信息来保证后续的优化和代码生成。</p>
<p>中间代码具有一些特点，如：</p>
<ol>
<li>接近目标代码：中间代码的表示形式类似于目标代码，它更接近于实际的机器指令。这使得后续的代码生成阶段更容易进行，因为中间代码已经具有了一定的目标机器相关性。</li>
<li>容易生成和转换：中间代码的生成过程相对简单，通常是基于语法树的遍历和转换。中间代码的线性结构使得对其进行处理和转换更加方便，例如进行优化和目标代码生成。</li>
</ol>
<h1 id="3-4-6-为什么需要中间代码"><a href="#3-4-6-为什么需要中间代码" class="headerlink" title="3.4.6 为什么需要中间代码"></a>3.4.6 为什么需要中间代码</h1><p>使用中间代码有以下几个主要原因：</p>
<ol>
<li>可移植性：中间代码是一种与具体目标机器无关的表示形式。通过生成中间代码，编译器可以将源代码与目标机器解耦，使得编译器更加可移植。中间代码可以在不同的目标平台上进行后续的优化和代码生成，从而实现源代码在不同平台上的跨平台执行。</li>
<li>优化：中间代码提供了一个高层次的表示形式，使得编译器可以在这个层次上进行各种优化操作。编译器可以利用中间代码的结构和语义信息，进行常量传播、死代码消除、循环优化、内联函数等优化操作，以提高程序的执行效率和性能。</li>
<li>简化代码生成：中间代码更接近于目标代码的表示形式，因此在后续的代码生成阶段，可以更轻松地将中间代码转换为目标机器的汇编代码或机器代码。中间代码的生成和转换过程相对简单，可以通过一系列的规则和转换操作来实现。</li>
<li>可读性和可理解性：中间代码通常使用一种高级语言或伪代码的形式表示，相对于目标机器的汇编代码来说，更容易阅读和理解。中间代码使得编译器的工作更加透明和可追踪，同时也有助于开发人员理解编译器的工作过程。</li>
</ol>
<h2 id="3-4-6从中间代码到汇编"><a href="#3-4-6从中间代码到汇编" class="headerlink" title="3.4.6从中间代码到汇编"></a>3.4.6从中间代码到汇编</h2><p>编译器的第五阶段是生成汇编代码，该阶段将中间代码翻译为汇编文件，并最终生成目标文件。这个阶段涉及到指令选择、控制流分析、数据流分析、寄存器分配等过程。</p>
<p>以下是生成汇编代码的一般过程：</p>
<ol>
<li>指令选择：在这个过程中，编译器将中间代码转换为汇编语言指令。指令选择的目标是选择合适的汇编指令，使得它们能够实现中间代码所描述的操作。这个过程通常会根据目标机器的架构和指令集来进行，以生成与目标机器兼容的汇编代码。</li>
<li>控制流分析：控制流分析用于确定程序中的基本块和控制流图。基本块是一段连续的指令序列，没有分支或跳转。控制流图记录了程序中的基本块之间的控制流关系，包括条件分支、循环等。控制流分析是进行优化和寻找代码转换机会的基础。</li>
<li>数据流分析：数据流分析用于分析程序中的数据依赖关系。它可以确定变量的定义和使用位置，以及数据传递和转换的路径。数据流分析对于进行寄存器分配和优化非常重要，因为它提供了变量的生命周期和使用信息。</li>
<li>寄存器分配：寄存器分配是将变量和临时值映射到物理寄存器的过程。寄存器分配可以基于静态或动态策略进行。静态寄存器分配在编译时确定寄存器的分配方案，而动态寄存器分配在运行时根据需要进行寄存器分配。寄存器分配的目标是最大程度地利用寄存器，减少内存访问。</li>
<li>汇编语言生成：在这个过程中，编译器将经过指令选择、控制流分析、数据流分析和寄存器分配的中间代码转换为汇编语言。汇编语言是一种与目标机器相关的低级表示形式，它使用特定的汇编指令和寄存器来描述程序的操作和数据。生成的汇编代码将被进一步处理以生成目标文件。</li>
<li>汇编器：汇编器是一个独立工具，它将汇编语言代码转换为可执行的目标文件。汇编器接受汇编语言作为输入，根据目标机器的指令集和格式，将汇编语言翻译为机器代码，并生成目标文件。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.3-预处理过程</title>
    <url>/2023/09/05/3-3-%E9%A2%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-3-1-预处理的过程"><a href="#3-3-1-预处理的过程" class="headerlink" title="3.3.1 预处理的过程"></a>3.3.1 预处理的过程</h1><p>预处理是编译过程中的第一步，它对源代码进行一系列的处理，包括头文件展开、宏展开、条件编译、删除注释、添加行号和文件名标识等。下面是预处理过程的主要步骤：</p>
<ol>
<li>头文件展开：将所有<code>#include</code>指令包含的文件插入到指令所在的位置。这样可以将头文件的内容插入到源代码中，使得源代码中可以使用头文件中定义的函数、变量和宏等。</li>
<li>宏展开：对所有的宏定义进行展开，并删除<code>#define</code>指令。预处理器会查找源代码中使用的宏，并将其替换为宏定义中的内容。这样可以将宏定义的代码在预处理阶段进行替换，减少了函数调用的开销。</li>
<li>条件编译：处理所有的条件预编译指令，例如<code>#if</code>、<code>#ifdef</code>、<code>#else</code>等。根据条件的真假，选择性地编译或排除部分代码。这样可以根据不同的条件编译选项，编译不同的代码分支。</li>
<li>删除注释：去除源代码中的注释部分。注释对于程序的理解和阅读很重要，但在编译过程中并不需要注释，因此预处理阶段会将注释删除，减少后续编译的工作量。</li>
<li>添加行号和文件名标识：为了方便编译调试和错误定位，预处理阶段会为每一行源代码添加行号和文件名标识。这样在编译出错时，可以准确地定位错误所在的行和文件。</li>
<li>保留#pragma命令：预处理阶段会保留<code>#pragma</code>指令。<code>#pragma</code>指令是编译器提供的一些特定功能的扩展，用于控制编译器的行为或实现特定的功能。</li>
<li>宏命令展开和文本替换：预处理阶段最后一步是对源代码进行宏命令展开和文本替换。在宏展开过程中，预处理器会查找源代码中使用的宏，并将其展开为宏定义中的内容。同时，还会进行一些文本替换的操作，例如替换宏参数、替换宏函数调用等。</li>
</ol>
<h1 id="3-3-2-为什么要进行预处理"><a href="#3-3-2-为什么要进行预处理" class="headerlink" title="3.3.2 为什么要进行预处理"></a>3.3.2 为什么要进行预处理</h1><p>预处理过程在编译过程中起着重要的作用，原因如下：</p>
<ol>
<li>宏定义：预处理阶段允许使用宏定义，宏可以将一段代码或表达式替换为预定义的文本。通过使用宏定义，可以简化代码编写，提高代码的可读性和可维护性。</li>
<li>方便条件编译：条件编译指令（如<code>#if</code>、<code>#ifdef</code>、<code>#else</code>）允许根据不同的编译条件选择性地编译或排除代码块。这对于实现跨平台兼容性或针对不同的编译配置进行调试和优化非常有用。</li>
<li>兼容各个平台和处理器架构：预处理过程可以根据不同的平台和处理器架构进行编译选项的设置。通过使用条件编译指令，可以编写适用于不同平台和处理器的代码，提高代码的可移植性和兼容性。</li>
<li>最大程度复用公用代码：通过使用头文件，可以将公用的函数、结构体和宏等定义保存在独立的文件中，并在需要的地方进行引用。这样可以实现代码的模块化和复用，减少代码的冗余和重复编写。</li>
<li>头文件包含：预处理过程中的头文件展开允许将其他文件中的代码插入到源文件中。这样可以将相关的代码组织在一起，提高代码的可读性和可维护性，并减少代码中的重复内容。</li>
<li>模块化编程：预处理过程可以通过定义和使用宏来实现模块化编程。模块化编程将代码划分为独立的功能模块，使代码更易于理解、测试和维护。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>预处理过程</title>
    <url>/2023/09/05/%E9%A2%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>3.2 GCC命令参数</title>
    <url>/2023/09/05/3-2-GCC%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-2-1-什么是GCC"><a href="#3-2-1-什么是GCC" class="headerlink" title="3.2.1 什么是GCC ?"></a>3.2.1 什么是GCC ?</h1><p>GCC指的是GNU编译器套件（GNU Compiler Collection），它是一个开源的编译器集合。GCC包括预处理器、编译器、汇编器和链接器等工具，它能够将源代码转换为可执行文件。GCC支持多种编程语言，如C、C++、Objective-C、Fortran、Ada等，并且可在多个操作系统上使用，包括Linux、Unix、Windows等。</p>
<p>除了编译器本身，GCC还提供了一些文件处理工具，如objdump、objcopy、nm、readelf和strip等，用于处理目标文件、库文件和可执行文件。此外，GCC也提供了一套标准的库文件和头文件，供开发者在编译程序时使用。</p>
<h1 id="3-2-2-gcc-参数"><a href="#3-2-2-gcc-参数" class="headerlink" title="3.2.2 gcc 参数"></a>3.2.2 gcc 参数</h1><p>通过在GCC命令行中使用不同的参数，可以调用GCC工具集中的不同工具。以下是一些常用的参数和对应的工具：</p>
<ul>
<li><code>-E</code>：预处理，调用cpp预处理器，将源代码中的宏定义展开、包含头文件等操作。</li>
<li><code>-S</code>：生成汇编文件，GCC将合并预处理后的代码，并将其转换为汇编语言。</li>
<li><code>-c</code>：生成目标文件，调用汇编器as，将汇编代码转换为机器代码，但不进行链接操作。</li>
<li><code>-o &lt;output&gt;</code>：指定输出文件的名称，可以用于指定生成的目标文件或可执行文件的名称。</li>
<li><code>--verbose</code>：显示详细的编译信息，包括调用的工具和执行的步骤。</li>
</ul>
<p>gcc -E main.c<br>该命令会直接将预处理的内容打印到终端并不会生成一个文件，所以需要指定一下输出文件，重定向，如下所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309050822386.png" alt="image-20230905082213343"></p>
<p>同样的gcc -S main.c 也是如此</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309050822178.png" alt="image-20230905082250151"></p>
<p>更多参数的详细介绍</p>
<ol>
<li><p><strong>控制编译过程的参数</strong>：</p>
<ul>
<li><code>-c</code>：只编译源文件，生成目标文件而不进行链接。</li>
<li><code>-S</code>：生成汇编代码文件，不进行编译和链接。</li>
<li><code>-E</code>：只进行预处理，生成预处理后的源代码。</li>
<li><code>-o &lt;output&gt;</code>：指定输出文件的名称。</li>
<li><code>-I &lt;dir&gt;</code>：指定头文件搜索路径。</li>
<li><code>-L &lt;dir&gt;</code>：指定库文件搜索路径。</li>
<li><code>-M</code>：生成文件依赖关系。使用该选项时，GCC会分析源文件中的<code>#include</code>指令，输出每个源文件及其所包含的头文件之间的依赖关系。输出结果通常以makefile规则的格式呈现。</li>
<li><code>-MD</code>：与<code>-M</code>相同，但是将输出导入到<code>.d</code>文件中。生成的<code>.d</code>文件通常包含了源文件及其所包含的头文件之间的依赖关系，可以在makefile中引用这些<code>.d</code>文件来自动化编译过程。</li>
<li><code>-MM</code>：与<code>-M</code>相似，但忽略<code>#include &lt;file.h&gt;</code>产生的依赖关系。这意味着只生成自定义头文件（使用双引号<code>#include &quot;file.h&quot;</code>）的依赖关系，而不包括系统头文件（使用尖括号<code>#include &lt;file.h&gt;</code>）。</li>
<li></li>
</ul>
</li>
<li><p><strong>编译选项的设置</strong>：</p>
<ul>
<li><p><code>-std=&lt;standard&gt;</code>：指定使用的语言标准，如<code>-std=c11</code>表示使用C11标准。</p>
</li>
<li><p><code>-Wall</code>：开启所有警告信息。</p>
</li>
<li><p><code>-Werror</code>：将警告视为错误，编译过程中遇到警告将中止。</p>
</li>
<li><p><code>-Wextra</code>：开启额外的警告选项。</p>
</li>
<li><p><code>-pedantic</code>：严格遵循语言标准，显示更多警告信息。</p>
</li>
<li><p><code>-g</code>：在编译过程中生成调试信息，用于调试程序。这些调试信息可以被调试器（如GDB）使用。</p>
</li>
<li><p><code>-static</code>：禁止使用动态库，强制链接静态库。这意味着编译后的可执行文件将不依赖于系统上已安装的动态库，而是包含了所有必要的库的副本。</p>
</li>
<li><p><code>-shared</code>：生成共享目标文件，也称为共享库或动态库。共享库可以在运行时被不同的程序加载和使用。</p>
</li>
<li><p><code>-L&lt;dir&gt;</code>：指定库搜索路径。使用该选项可以告诉编译器在指定的目录中搜索库文件。</p>
</li>
<li><p><code>-l&lt;libname&gt;</code>：指定编译时使用的库。例如，<code>-lmath</code>将链接数学库。编译器会在标准库搜索路径和使用<code>-L</code>选项指定的路径中查找库文件。</p>
</li>
<li><p><code>-I&lt;dir&gt;</code>：指定头文件搜索路径。使用该选项可以告诉编译器在指定的目录中搜索头文件。</p>
</li>
<li><p><code>-w</code>：禁止生成任何警告信息。编译器将不会显示任何警告。</p>
</li>
<li><p><code>-std=c99</code>：指定使用C99标准进行编译。GCC默认采用GNU C标准。</p>
</li>
</ul>
</li>
<li><p><strong>编译器优化选项</strong>：</p>
<ul>
<li><code>-O0</code>、<code>-O1</code>、<code>-O2</code>、<code>-O3</code>：控制编译器的优化级别，从无优化到高级优化。</li>
<li><code>-Os</code>：优化代码大小。</li>
<li><code>-Ofast</code>：最大程度地优化代码执行速度，可能牺牲一些标准的符合性。</li>
<li><code>-march=&lt;arch&gt;</code>：指定目标处理器架构，优化代码以适应特定处理器。</li>
</ul>
</li>
</ol>
<h1 id="3-2-3-交叉编译"><a href="#3-2-3-交叉编译" class="headerlink" title="3.2.3 交叉编译"></a>3.2.3 交叉编译</h1><p>交叉编译是指在一种平台上进行编译，生成能够在另一种不同平台上运行的可执行文件或镜像。在交叉编译中，编译器和工具链被配置为目标平台的编译器和工具，以便生成与目标平台兼容的代码和可执行文件。</p>
<p>例如，如果你正在运行的是 x86 架构的电脑，但你想要编译一个在 ARM 架构的嵌入式设备上运行的程序，就需要进行交叉编译。在这种情况下，你需要使用针对 ARM 架构的交叉编译器和工具链，例如 <code>arm-linux-gnueabi-gcc</code>。</p>
<p>安装交叉编译器和工具链时，你可以使用适合你的发行版的包管理器。在这个例子中，你可以使用 <code>apt</code> 包管理器来安装 ARM 架构的交叉编译器和工具链，命令如下：</p>
<p>Copy</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install gcc-arm-linux-gnueabi</span><br></pre></td></tr></table></figure>

<p>安装完成后，你就可以使用 <code>arm-linux-gnueabi-gcc</code> 命令来进行 ARM 架构的交叉编译了。这样你就能够生成适用于 ARM 架构设备的可执行文件或镜像。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>程序的编译与可执行文件</title>
    <url>/2023/09/04/3-1-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-1-程序的编译与可执行文件"><a href="#3-1-程序的编译与可执行文件" class="headerlink" title="3.1 程序的编译与可执行文件"></a>3.1 程序的编译与可执行文件</h1><h2 id="3-1-1-可执行文件的组装"><a href="#3-1-1-可执行文件的组装" class="headerlink" title="3.1.1 可执行文件的组装"></a>3.1.1 可执行文件的组装</h2><p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042146452.png" alt="image-20230904214608380"></p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042146097.png" alt="image-20230904214623995"></p>
<p>编译过程的特点可以总结如下：</p>
<p>非一步到位：编译过程不是一次性完成的，而是分为多个阶段逐步完成的。</p>
<p>环环相扣：每个阶段的输出作为下一个阶段的输入，各个阶段之间有着紧密的联系和依赖关系。</p>
<p>分为预编译、编译、汇编、链接阶段：编译过程可以划分为预处理、编译、汇编和链接几个主要阶段。</p>
<p>调用不同的工具：每个阶段都调用不同的工具或编译器来完成特定的任务。</p>
<ul>
<li><p>预处理：在预处理阶段，预处理器将源文件进行处理，如宏展开、头文件包含等，生成处理后的源文件。</p>
</li>
<li><p>编译：在编译阶段，编译器将处理后的源文件转换为汇编语言代码，进行语法分析、语义分析、优化等操作。</p>
</li>
<li><p>汇编：在汇编阶段，汇编器将生成的汇编语言代码转换为机器语言指令，并生成目标文件。</p>
</li>
<li><p>链接：在链接阶段，链接器将多个目标文件和库文件进行链接，解析符号引用，生成可执行目标文件（如ELF格式）。</p>
</li>
</ul>
<p>生成可执行文件是编译过程中的最终目标，但为什么编译过程中不直接生成可执行文件，而是分为多个阶段呢？</p>
<p>首先是GNU的思想，即”一个工具只干一件事情”。GNU工具链以及许多其他编译工具都遵循这个原则。将编译过程分为多个阶段，每个阶段有专门的工具来处理，可以使得每个工具更加专注于自己的任务。例如，预处理器负责处理宏展开、头文件包含等，编译器负责将源代码转换为汇编代码，汇编器负责将汇编代码转换为机器代码，链接器负责将目标文件链接为可执行文件。这样的分工可以简化每个工具的实现和复杂度，使得工具更加可靠、可维护，并提高了工具的复用性。</p>
<p>其次是计算机工业思维中的标准接口和分层原则。将编译过程分为多个阶段，每个阶段的输入和输出都有明确定义的接口，使得每个阶段都可以独立进行开发和优化。这样的分层结构可以适配更多的平台、CPU架构和指令集，使得编译器可以在不同的系统上使用相同的前端和中间表示，通过后端进行特定平台的代码生成。这种模块化和分层的设计使得编译器更加灵活、可扩展，并能够适应不断变化的计算机体系结构和需求。</p>
<h2 id="3-1-2-从源程序到可执行文件"><a href="#3-1-2-从源程序到可执行文件" class="headerlink" title="3.1.2 从源程序到可执行文件"></a>3.1.2 从源程序到可执行文件</h2><p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042152389.png" alt="image-20230904215208244"></p>
<ol>
<li>预处理：源程序中的 <code>#include&lt;stdio.h&gt;</code> 被预处理器处理，将对应的头文件内容插入到源程序中，生成处理后的源程序。</li>
<li>编译：编译器将处理后的源程序进行语法分析、语义分析、优化等操作，生成目标文件。在目标文件中，包括以下部分：<ul>
<li>ELF header：ELF（可执行与可链接格式）头部，包含关于文件格式的信息。</li>
<li>Program header table：程序头表，描述程序的段（段包含代码、数据等）。</li>
<li>.text 段：包含程序的机器代码。</li>
<li>.rodata 段：包含只读数据，如字符串常量。</li>
<li>.data 段：包含已初始化的全局和静态变量。</li>
<li>.bss 段：包含未初始化的全局和静态变量。</li>
</ul>
</li>
<li>链接：链接器将目标文件进行链接，生成可执行文件。在可执行文件中，包括以下部分：<ul>
<li>ELF header：与目标文件相同，包含关于文件格式的信息。</li>
<li>Program header table：与目标文件相同，描述程序的段。</li>
<li>.text 段：与目标文件相同，包含程序的机器代码。</li>
<li>.rodata 段：与目标文件相同，包含只读数据。</li>
<li>.data 段：与目标文件相同，包含已初始化的全局和静态变量。</li>
<li>.bss 段：与目标文件相同，包含未初始化的全局和静态变量。</li>
<li>符号表（.symtab）：包含程序中定义的全局和静态符号的信息。</li>
<li>字符串表（.strtab）：保存符号表中的字符串。</li>
<li>调试信息（.debug）：包含调试器使用的信息。</li>
<li>行号信息（.line）：包含源代码的行号信息。</li>
</ul>
</li>
</ol>
<p>最终生成的可执行文件包含了程序的机器代码、数据、符号表等信息，可以在计算机上执行。编译过程中的中间文件和信息都嵌入到最终的可执行文件中，以便在运行时进行处理和调试。</p>
<h2 id="3-1-3-目标文件"><a href="#3-1-3-目标文件" class="headerlink" title="3.1.3 目标文件"></a>3.1.3 目标文件</h2><p>目标文件（Object file）是编译器生成的中间文件，它包含了编译后的机器代码、数据和符号信息，用于最终生成可执行文件或共享目标文件。目标文件的类型可以通过命令 <code>file</code> 进行查看。</p>
<p>常见的目标文件类型包括：</p>
<ul>
<li>可重定位目标文件（Relocatable files）：这种类型的目标文件包含了编译后的机器代码、数据和符号信息，但是它们的内部地址是相对于起始地址的偏移量，还没有进行最终的地址分配和链接。可重定位目标文件可以作为其他可重定位目标文件或可执行目标文件的输入，用于生成最终的可执行文件或共享目标文件。</li>
<li>可执行目标文件（Executable files）：这种类型的目标文件是经过链接的最终可执行文件，包含了所有的机器代码、数据和符号信息，可以直接在操作系统上执行。</li>
<li>可被共享目标文件（Shared object file）：也被称为动态链接库（Dynamic Linking Library）或共享库（Shared Library）。这种类型的目标文件包含了可被多个可执行文件或其他共享库共享使用的代码和数据，可以在运行时动态加载到内存中，并与其他程序共享使用。</li>
<li>可执行文件（ELF，Executable and Linkable Format）：这是一种可执行文件的格式，广泛用于类UNIX系统。可执行文件可以直接在操作系统上执行，包含了机器代码、数据和符号信息，以及其他与执行相关的信息（如程序入口点等）。</li>
</ul>
<h2 id="3-1-4-ELF可执行文件的结构"><a href="#3-1-4-ELF可执行文件的结构" class="headerlink" title="3.1.4 ELF可执行文件的结构"></a>3.1.4 ELF可执行文件的结构</h2><ol>
<li>ELF header（ELF 头）：包含了关于文件格式的信息，如文件类型、目标体系结构、入口点地址等。</li>
<li>Program header table（程序头表）：描述了可执行文件的段（segment）信息，每个段对应一个或多个节（section），包括代码段、只读数据段、可读写数据段等。程序头表记录了每个段的起始地址、大小、访问权限等信息。</li>
<li>.init 段：包含了可执行文件在加载到内存后需要执行的初始化代码，如全局变量的初始化和动态链接器的初始化等。</li>
<li>.text、.rodata、.data、.bss 等段：这些段包含了实际的代码和数据。<ul>
<li>.text 段：包含了可执行代码的机器指令，也就是程序的代码段。</li>
<li>.rodata 段：包含了只读数据，如字符串常量等。</li>
<li>.data 段：包含了已初始化的全局和静态变量。</li>
<li>.bss 段：包含了未初始化的全局和静态变量，这些变量在运行时会被初始化为 0。</li>
</ul>
</li>
<li>符号表（.symtab）：记录了程序中定义和引用的全局和静态符号的信息，如函数和变量。符号表中包含了符号的名称、类型、大小、地址等信息。</li>
<li>调试信息（.debug）：包含了调试器使用的信息，如源代码的行号信息、变量和函数的调试信息等。</li>
<li>行号信息（.line）：包含了源代码的行号信息，用于将机器代码映射回源代码的行号。</li>
<li>字符串表（.strtab）：保存了符号表和调试信息中使用的字符串。</li>
<li>Section header table（节头表）：描述了各个节的信息，包括名称、类型、偏移量、大小等。</li>
</ol>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_val = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> uninit_val;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> local_val = <span class="number">2</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> uninit_local_val;</span><br><span class="line">    </span><br><span class="line">    a = add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    b = sub(<span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sub.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用以下命令编译成目标文件，但是不进行链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c main.c sub.c</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042209197.png" alt="image-20230904220907171"></p>
<p>使用以下命令读取ELF header</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf -h main.o</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042211626.png" alt="image-20230904221103590"></p>
<p>然后使用以下命令查看节头表（section heads）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf -S main.o</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042213386.png" alt="image-20230904221310333"></p>
<p>最后使用以下命令进行链接,生成可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main.o sub.o</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042215351.png" alt="image-20230904221504326"></p>
<p>重新读取elf头和section heads</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">topeet@ubuntu:~/demo$ readelf -h a.out </span><br><span class="line">ELF 头：</span><br><span class="line">  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  类别:                              ELF64</span><br><span class="line">  数据:                              2 补码，小端序 (little endian)</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          0</span><br><span class="line">  类型:                              DYN (共享目标文件)</span><br><span class="line">  系统架构:                          Advanced Micro Devices X86-64</span><br><span class="line">  版本:                              0x1</span><br><span class="line">  入口点地址：               0x1060</span><br><span class="line">  程序头起点：          64 (bytes into file)</span><br><span class="line">  Start of section headers:          15016 (bytes into file)</span><br><span class="line">  标志：             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         13</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         31</span><br><span class="line">  Section header string table index: 30</span><br><span class="line">topeet@ubuntu:~/demo$ read</span><br><span class="line">read         readarray    readelf      readlink     readonly     readprofile  </span><br><span class="line">topeet@ubuntu:~/demo$ readelf -S a.out </span><br><span class="line">There are 31 section headers, starting at offset 0x3aa8:</span><br><span class="line"></span><br><span class="line">节头：</span><br><span class="line">  [号] 名称              类型             地址              偏移量</span><br><span class="line">       大小              全体大小          旗标   链接   信息   对齐</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .interp           PROGBITS         0000000000000318  00000318</span><br><span class="line">       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">  [ 2] .note.gnu.propert NOTE             0000000000000338  00000338</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE             0000000000000358  00000358</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .note.ABI-tag     NOTE             000000000000037c  0000037c</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 5] .gnu.hash         GNU_HASH         00000000000003a0  000003a0</span><br><span class="line">       0000000000000028  0000000000000000   A       6     0     8</span><br><span class="line">  [ 6] .dynsym           DYNSYM           00000000000003c8  000003c8</span><br><span class="line">       00000000000000c0  0000000000000018   A       7     1     8</span><br><span class="line">  [ 7] .dynstr           STRTAB           0000000000000488  00000488</span><br><span class="line">       0000000000000088  0000000000000000   A       0     0     1</span><br><span class="line">  [ 8] .gnu.version      VERSYM           0000000000000510  00000510</span><br><span class="line">       0000000000000010  0000000000000002   A       6     0     2</span><br><span class="line">  [ 9] .gnu.version_r    VERNEED          0000000000000520  00000520</span><br><span class="line">       0000000000000020  0000000000000000   A       7     1     8</span><br><span class="line">  [10] .rela.dyn         RELA             0000000000000540  00000540</span><br><span class="line">       00000000000000c0  0000000000000018   A       6     0     8</span><br><span class="line">  [11] .rela.plt         RELA             0000000000000600  00000600</span><br><span class="line">       0000000000000018  0000000000000018  AI       6    24     8</span><br><span class="line">  [12] .init             PROGBITS         0000000000001000  00001000</span><br><span class="line">       000000000000001b  0000000000000000  AX       0     0     4</span><br><span class="line">  [13] .plt              PROGBITS         0000000000001020  00001020</span><br><span class="line">       0000000000000020  0000000000000010  AX       0     0     16</span><br><span class="line">  [14] .plt.got          PROGBITS         0000000000001040  00001040</span><br><span class="line">       0000000000000010  0000000000000010  AX       0     0     16</span><br><span class="line">  [15] .plt.sec          PROGBITS         0000000000001050  00001050</span><br><span class="line">       0000000000000010  0000000000000010  AX       0     0     16</span><br><span class="line">  [16] .text             PROGBITS         0000000000001060  00001060</span><br><span class="line">       0000000000000225  0000000000000000  AX       0     0     16</span><br><span class="line">  [17] .fini             PROGBITS         0000000000001288  00001288</span><br><span class="line">       000000000000000d  0000000000000000  AX       0     0     4</span><br><span class="line">  [18] .rodata           PROGBITS         0000000000002000  00002000</span><br><span class="line">       0000000000000014  0000000000000000   A       0     0     4</span><br><span class="line">  [19] .eh_frame_hdr     PROGBITS         0000000000002014  00002014</span><br><span class="line">       0000000000000064  0000000000000000   A       0     0     4</span><br><span class="line">  [20] .eh_frame         PROGBITS         0000000000002078  00002078</span><br><span class="line">       0000000000000188  0000000000000000   A       0     0     8</span><br><span class="line">  [21] .init_array       INIT_ARRAY       0000000000003db8  00002db8</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [22] .fini_array       FINI_ARRAY       0000000000003dc0  00002dc0</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [23] .dynamic          DYNAMIC          0000000000003dc8  00002dc8</span><br><span class="line">       00000000000001f0  0000000000000010  WA       7     0     8</span><br><span class="line">  [24] .got              PROGBITS         0000000000003fb8  00002fb8</span><br><span class="line">       0000000000000048  0000000000000008  WA       0     0     8</span><br><span class="line">  [25] .data             PROGBITS         0000000000004000  00003000</span><br><span class="line">       0000000000000018  0000000000000000  WA       0     0     8</span><br><span class="line">  [26] .bss              NOBITS           0000000000004018  00003018</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     4</span><br><span class="line">  [27] .comment          PROGBITS         0000000000000000  00003018</span><br><span class="line">       000000000000002b  0000000000000001  MS       0     0     1</span><br><span class="line">  [28] .symtab           SYMTAB           0000000000000000  00003048</span><br><span class="line">       00000000000006f0  0000000000000018          29    49     8</span><br><span class="line">  [29] .strtab           STRTAB           0000000000000000  00003738</span><br><span class="line">       0000000000000255  0000000000000000           0     0     1</span><br><span class="line">  [30] .shstrtab         STRTAB           0000000000000000  0000398d</span><br><span class="line">       000000000000011a  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br><span class="line">topeet@ubuntu:~/demo$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-1-5-动态库和静态库的生成"><a href="#3-1-5-动态库和静态库的生成" class="headerlink" title="3.1.5 动态库和静态库的生成"></a>3.1.5 动态库和静态库的生成</h2><p>使用以下命令可以生成静态库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ar rcs libsub.a sub.o</span><br></pre></td></tr></table></figure>

<p>其中库的名字必须以lib开头，使用readelf重新读取以下该库的elf头，如下所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042226316.png" alt="image-20230904222640273"></p>
<p>使用以下命令生成动态库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -shared -fPIC -o libsub.so sub.c</span><br></pre></td></tr></table></figure>

<p>然后使用readelf 读取elf头如下所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042227936.png" alt="image-20230904222725900"></p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake 基础课</title>
    <url>/2023/09/03/cmake-%E5%9F%BA%E7%A1%80%E8%AF%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、准备知识"><a href="#一、准备知识" class="headerlink" title="一、准备知识"></a>一、准备知识</h1><h2 id="1-1-C-的编译过程"><a href="#1-1-C-的编译过程" class="headerlink" title="1.1 C++的编译过程"></a>1.1 C++的编译过程</h2><ul>
<li>-E 仅预处理；不编译、汇编或链接。</li>
<li>-S 仅编译；不汇编或链接。</li>
<li>-c 编译和汇编，但不链接。</li>
<li>-o <file> 将输出放入<file>中。</li>
</ul>
<p><strong>C++源代码的编译过程</strong></p>
<ol>
<li><p><strong>预处理</strong>：在预处理阶段，C++源代码中的预处理指令会被处理，包括宏展开和条件编译等。在此阶段，需要添加所有头文件的引用路径。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将xx.cpp源文件预处理为xx.i文件（文本文件）</span></span><br><span class="line">g++ -E main.cpp -o main.i</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编译</strong>：编译阶段会对预处理后的代码进行语法检查和编译，将代码翻译为汇编语言文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将xx.i文件编译为xx.s的汇编文件（文本文件）</span></span><br><span class="line">g++ -S main.i -o main.s</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>汇编</strong>：汇编阶段将汇编语言文件转换为二进制格式的目标文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将xx.s文件汇编为xx.o的二进制目标文件</span></span><br><span class="line">g++ -c main.s -o main.o</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>链接</strong>：链接阶段将目标文件与所依赖的库文件进行关联或组装，生成可执行文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将目标文件进行链接，生成可执行程序</span></span><br><span class="line">g++ main.o -o main</span><br><span class="line">```</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="1-2-静态链接库和动态链接库"><a href="#1-2-静态链接库和动态链接库" class="headerlink" title="1.2 静态链接库和动态链接库"></a>1.2 静态链接库和动态链接库</h2><p>静态链接库和动态链接库的区别在于链接的阶段不同。</p>
<p><strong>静态链接库</strong>的名称通常以<code>.a</code>结尾（表示archive library），它在编译阶段进行链接。如果一个工程依赖于静态链接库，那么生成的可执行文件或库会将静态链接库<code>.a</code>打包到输出文件中，因此生成的文件比较大。在运行时，不再需要单独的库文件。</p>
<p><strong>动态链接库</strong>的链接发生在程序的执行过程中，它在编译阶段仅进行链接检查，而不进行真正的链接过程。动态链接库的后缀名通常为<code>.so</code>（表示shared object，在Linux上）或<code>.dylib</code>（在macOS上）。动态链接库在加载后，在内存中只保存一份拷贝。多个程序依赖于它时，不会重复加载和拷贝，节省了内存空间。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/image-20230903175645024.png" alt="image-20230903175645024"></p>
<h2 id="1-3-为什么需要CMake"><a href="#1-3-为什么需要CMake" class="headerlink" title="1.3 为什么需要CMake"></a>1.3 为什么需要CMake</h2><h3 id="1-3-1-g-命令行编译"><a href="#1-3-1-g-命令行编译" class="headerlink" title="1.3.1 g++命令行编译"></a>1.3.1 g++命令行编译</h3><p>当编译hello_world.cpp&#96;文件时，可以使用以下命令进行编译和运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -o main</span><br></pre></td></tr></table></figure>

<p>如果需要引入外部库可以使用以下方法进行编译：</p>
<p>方法一：使用<code>-lgflags</code>参数进行链接**</p>
<p>首先，需要安装<code>gflags</code>库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libgflags-dev libgflags2.2</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">然后，使用以下命令进行编译：</span><br><span class="line"></span><br><span class="line">````bash</span><br><span class="line">g++ main.cpp -lgflags -o main</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>方法二：使用<code>pkg-config</code>进行库文件和头文件路径查找**</p>
<p>首先，需要安装<code>pkg-config</code>工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install pkg-config</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">然后，使用以下命令进行编译：</span><br><span class="line"></span><br><span class="line">````bash</span><br><span class="line">g++ main.cpp `pkg-config --cflags --libs gflags` -o main</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">这里，`pkg-config --cflags --libs gflags`命令用于查找`gflags`库的头文件和库文件路径。</span><br></pre></td></tr></table></figure>

<p>编译完成后，可以使用以下命令运行可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./main --age 31 --name alice</span><br></pre></td></tr></table></figure>

<p>有时候，在编译时不需要手动添加头文件或链接库路径，因为<code>g++</code>可以在默认的查询路径中找到这些库。然而，当项目文件和引入的外部库变得较多时，使用命令行编译会变得冗长且不便于调试和编辑。通常，在测试单个文件时可以使用命令行编译，但不推荐在实际项目中使用命令行编译方式。</p>
<h3 id="1-3-2-CMake简介"><a href="#1-3-2-CMake简介" class="headerlink" title="1.3.2 CMake简介"></a>1.3.2 CMake简介</h3><p>在实际工作中，推荐使用CMake来构建C++项目。CMake是一个开源的跨平台工具，用于构建、测试和软件打包。</p>
<p>CMake具有以下特性：</p>
<ul>
<li><strong>自动搜索依赖项</strong>：CMake具有自动搜索可能需要的程序、库和头文件的能力，可以简化依赖项的配置过程。</li>
<li><strong>独立的构建目录</strong>：CMake支持使用独立的构建目录（例如<code>build</code>目录），这样可以安全地清理构建产生的中间文件和输出文件，不会污染源代码目录。</li>
<li><strong>自定义命令</strong>：CMake支持定义复杂的自定义命令，例如下载文件、生成各种文件等，可以满足项目构建过程中的特定需求。</li>
<li><strong>自定义配置</strong>：CMake支持根据需求进行自定义配置，可以选择性地启用或禁用特定的组件或功能。</li>
<li><strong>文本文件生成工作区和项目</strong>：CMake使用简单的文本文件（<code>CMakeLists.txt</code>）来描述项目的配置和构建规则，可以根据这些文件自动生成工作区和项目。</li>
<li><strong>文件依赖项自动生成和并行构建</strong>：CMake可以在主流平台上自动生成文件之间的依赖关系，从而使构建过程更高效。同时，CMake支持并行构建，可以加快构建速度。</li>
<li><strong>支持多种IDE</strong>：CMake几乎支持所有主流的集成开发环境（IDE），包括Visual Studio、Xcode、Eclipse等，可以方便地在不同的开发环境中进行项目开发和调试。</li>
</ul>
<h1 id="二、CMake基础知识"><a href="#二、CMake基础知识" class="headerlink" title="二、CMake基础知识"></a>二、CMake基础知识</h1><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h2><p>在Ubuntu上安装CMake可以使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install cmake -y</span><br></pre></td></tr></table></figure>

<p>这将使用apt包管理器自动安装CMake。</p>
<p>如果你想编译安装特定版本的CMake，可以按照以下步骤操作：</p>
<p>克隆CMake的源代码库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b v3.25.1 https://github.com/Kitware/CMake.git</span><br><span class="line">cd CMake</span><br><span class="line"></span><br><span class="line">这里以安装版本3.25.1为例，你可以将`v3.25.1`替换为你想要安装的特定版本。</span><br></pre></td></tr></table></figure>

<p>配置和编译CMake：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bootstrap --prefix=&lt;安装路径&gt;</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">你可以使用`--prefix`选项来指定安装路径，或者省略`--prefix`以安装到默认路径。</span><br></pre></td></tr></table></figure>

<p>安装CMake：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">这将以管理员权限安装CMake到系统中。</span><br></pre></td></tr></table></figure>

<p>安装完成后，你可以验证CMake的安装版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure>

<p>该命令将显示CMake的版本信息，确认安装成功与否。</p>
<h2 id="2-2-第一个CMake例子"><a href="#2-2-第一个CMake例子" class="headerlink" title="2.2 第一个CMake例子"></a>2.2 第一个CMake例子</h2><p><strong>配置：</strong> 使用<code>cmake</code>命令进行配置，其中<code>-S</code>选项指定源码目录，<code>-B</code>选项指定构建目录。在终端中执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake -S . -B build</span><br><span class="line"></span><br><span class="line">这将在当前目录下执行CMake配置，并将生成的构建系统文件放在名为`build`的目录中。</span><br></pre></td></tr></table></figure>

<p><strong>生成：</strong> 使用<code>cmake --build</code>命令进行生成，其中<code>--build</code>选项指定构建目录。在终端中执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake --build build</span><br><span class="line"></span><br><span class="line">这将在`build`目录中执行构建步骤，生成可执行文件。</span><br></pre></td></tr></table></figure>

<p><strong>运行：</strong> 使用以下命令运行生成的可执行文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./build/first_cmake</span><br><span class="line"></span><br><span class="line">这将执行生成的可执行文件。</span><br></pre></td></tr></table></figure>

<h2 id="2-3-语法基础"><a href="#2-3-语法基础" class="headerlink" title="2.3 语法基础"></a>2.3 语法基础</h2><h3 id="2-3-1-指定版本"><a href="#2-3-1-指定版本" class="headerlink" title="2.3.1 指定版本"></a>2.3.1 指定版本</h3><p>在CMake中，可以使用<code>cmake_minimum_required</code>命令指定当前项目所需的最低CMake版本。它的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION &lt;version_number&gt;)</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;version_number&gt;</code>是所需的最低CMake版本号。在这个命令之后，CMake将会检查系统中安装的CMake版本是否满足这个要求，如果不满足则会产生错误。</p>
<p>例如，如果要指定最低的CMake版本为3.10，可以在CMakeLists.txt文件中添加以下命令：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br></pre></td></tr></table></figure>

<p>这样，CMake将会检查系统中的CMake版本是否大于等于3.10。</p>
<p>除了<code>cmake_minimum_required</code>命令，CMake中还有其他类似的命令，它们不区分大小写，并且有许多关键字来引导命令的参数输入，类似于函数的参数传递。这些命令使用的关键字在CMake中是不区分大小写的。</p>
<h3 id="2-3-2-设置项目"><a href="#2-3-2-设置项目" class="headerlink" title="2.3.2 设置项目"></a>2.3.2 设置项目</h3><p>在CMakeLists.txt文件的开头，通常会使用<code>project</code>命令来指定项目的名称、版本、描述和所使用的语言。<code>project</code>命令的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">project</span>(ProjectName</span><br><span class="line">    [VERSION &lt;version_number&gt;]</span><br><span class="line">    [DESCRIPTION <span class="string">&quot;project_description&quot;</span>]</span><br><span class="line">    [LANGUAGES &lt;language&gt;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>其中，<code>ProjectName</code>是项目的名称，在例子中使用的是”first_cmake”。<code>VERSION</code>关键字后面是项目的版本号，可以是任意格式的版本号，例如”1.0.0”。<code>DESCRIPTION</code>关键字后面是项目的描述，可以是一个字符串。<code>LANGUAGES</code>关键字后面是项目所使用的语言，这里使用的是”Cxx”，表示C++。</p>
<p>示例中的<code>project</code>命令：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">project</span>(first_cmake</span><br><span class="line">    VERSION <span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line">    DESCRIPTION <span class="string">&quot;项目描述&quot;</span></span><br><span class="line">    LANGUAGES Cxx</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这样，通过<code>project</code>命令，可以在CMakeLists.txt中指定项目的基本信息，方便管理和描述项目。</p>
<h3 id="2-3-3-添加可执行文件目标"><a href="#2-3-3-添加可执行文件目标" class="headerlink" title="2.3.3 添加可执行文件目标"></a>2.3.3 添加可执行文件目标</h3><p>使用了<code>add_executable</code>命令来定义一个可执行文件。该命令的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(&lt;target_name&gt; &lt;source_files&gt;)</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;target_name&gt;</code>是最终生成的可执行文件名，也是在CMake中定义的目标（Target）名。<code>&lt;source_files&gt;</code>是编译目标所使用的源文件。</p>
<p>在你提供的例子中，使用了<code>add_executable</code>命令来定义一个名为<code>first_cmake</code>的目标，并指定了一个源文件<code>main.cpp</code>。这意味着在编译时，会将<code>main.cpp</code>编译为一个可执行文件，该文件的名称将是<code>first_cmake</code>。</p>
<p>示例中的<code>add_executable</code>命令：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(first_cmake main.cpp)</span><br></pre></td></tr></table></figure>

<p>通过<code>add_executable</code>命令，可以在CMakeLists.txt中定义编译目标，并指定相应的源文件。这样，CMake将会根据这些定义生成相应的构建规则和编译指令。</p>
<h3 id="2-3-4-生成静态库并链接"><a href="#2-3-4-生成静态库并链接" class="headerlink" title="2.3.4 生成静态库并链接"></a>2.3.4 生成静态库并链接</h3><p>A. 生成静态库：</p>
<p>在<code>account_dir/CMakeLists.txt</code>中，使用<code>add_library</code>命令来生成静态库。该命令的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_library(&lt;library_name&gt; &lt;library_type&gt; &lt;source_files&gt;)</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;library_name&gt;</code>是最终生成的库文件名，例如在Linux下会生成<code>libAccount.a</code>。</p>
<p><code>&lt;library_type&gt;</code>用于指定链接库的类型，可以是动态链接库（<code>SHARED</code>）或静态链接库（<code>STATIC</code>）。</p>
<p><code>&lt;source_files&gt;</code>是需要用到的源文件。</p>
<p>例如，在<code>account_dir/CMakeLists.txt</code>中，使用<code>add_library</code>命令生成一个名为<code>Account</code>的静态库，其包含了<code>Account.cpp</code>和<code>Account.h</code>两个源文件。示例命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Account STATIC Account.cpp Account.h)</span><br></pre></td></tr></table></figure>

<p>这将生成一个静态库文件<code>libAccount.a</code>。</p>
<p>B. 链接：</p>
<p>在<code>test_account/CMakeLists.txt</code>中，可以通过<code>target_link_libraries</code>命令将生成的静态库链接到目标可执行文件中。该命令的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(&lt;target_name&gt; &lt;library_name&gt;)</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;target_name&gt;</code>是目标可执行文件的名称，<code>&lt;library_name&gt;</code>是要链接的库文件名。</p>
<p>例如，在<code>test_account/CMakeLists.txt</code>中，假设有一个目标可执行文件名为<code>test_account</code>，需要链接生成的静态库<code>Account</code>。示例命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(test_account Account)</span><br></pre></td></tr></table></figure>

<p>这样，生成的可执行文件<code>test_account</code>将会链接静态库<code>Account</code>。</p>
<h3 id="2-3-5-生成动态库并连接"><a href="#2-3-5-生成动态库并连接" class="headerlink" title="2.3.5 生成动态库并连接"></a>2.3.5 生成动态库并连接</h3><p>A. 生成动态库：</p>
<p>在<code>account_dir/CMakeLists.txt</code>中，使用<code>add_library</code>命令来生成动态库。与生成静态库不同的是，需要将<code>&lt;library_type&gt;</code>参数设置为<code>SHARED</code>，表示生成动态链接库。</p>
<p>示例命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Account SHARED Account.cpp Account.h)</span><br></pre></td></tr></table></figure>

<p>这将生成一个动态库文件<code>libAccount.so</code>。</p>
<p>B. 链接：</p>
<p>链接过程与生成静态库时的操作相同，使用<code>target_link_libraries</code>命令将动态库链接到目标可执行文件中。</p>
<p>示例命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(test_account Account)</span><br></pre></td></tr></table></figure>

<p>这样，生成的可执行文件<code>test_account</code>将会链接动态库<code>Account</code>。</p>
<h3 id="2-3-6-CMake中的PUBLIC、PRIVATE、INTERFACE"><a href="#2-3-6-CMake中的PUBLIC、PRIVATE、INTERFACE" class="headerlink" title="2.3.6 CMake中的PUBLIC、PRIVATE、INTERFACE"></a>2.3.6 CMake中的PUBLIC、PRIVATE、INTERFACE</h3><p>在CMake中，可以使用<code>target_...()</code>系列命令来操作目标（Target）。这些命令通常支持通过<code>PUBLIC</code>、<code>PRIVATE</code>、<code>INTERFACE</code>关键字来控制属性的传播。</p>
<p>以<code>target_link_libraries(A B)</code>为例，下面是对这些关键字的理解：</p>
<ul>
<li><code>PRIVATE</code>：依赖项B仅链接到目标A。如果有目标C链接了目标A，目标C不会链接目标B。</li>
<li><code>INTERFACE</code>：依赖项B并不链接到目标A。如果有目标C链接了目标A，目标C会链接目标B。</li>
<li><code>PUBLIC</code>：依赖项B链接到目标A。如果有目标C链接了目标A，目标C也会链接目标B。</li>
</ul>
<p>可以将其类比为一个散烟的比方：</p>
<ul>
<li><code>PRIVATE</code>：就是自己抽烟，不给别人抽。</li>
<li><code>INTERFACE</code>：就是自己不抽烟，给别人抽。</li>
<li><code>PUBLIC</code>：就是自己抽烟，也给别人抽。</li>
</ul>
<p>从使用的角度来看，假设有目标C链接了目标A：</p>
<ul>
<li>如果目标B仅用于目标A的实现，并且不在头文件中提供给目标C使用，可以使用<code>PRIVATE</code>。</li>
<li>如果目标B不用于目标A的实现，仅在头文件中作为接口给目标C使用，可以使用<code>INTERFACE</code>。</li>
<li>如果目标B既用于目标A的实现，也在头文件中提供给目标C使用，可以使用<code>PUBLIC</code>。</li>
</ul>
<p>以下是一个示例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建库</span></span><br><span class="line"><span class="keyword">add_library</span>(c c.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(D d.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(B b.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用target_link_libraries命令进行链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(A PRIVATE B)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(A INTERFACE C)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(A PUBLIC D)</span><br></pre></td></tr></table></figure>

<p>在上述示例中，目标<code>A</code>通过<code>target_link_libraries</code>命令链接了目标<code>B</code>、<code>C</code>和<code>D</code>，使用了不同的传播属性。具体属性的选择取决于目标之间的关系和使用需求。</p>
<h3 id="2-3-7-变量"><a href="#2-3-7-变量" class="headerlink" title="2.3.7 变量"></a>2.3.7 变量</h3><p>在CMake中，你可以使用<code>message</code>命令输出消息并进行变量的操作和设置。</p>
<p>以下是一些常见的用法：</p>
<p>1.输出消息：使用<code>message</code>命令可以输出消息到CMake的输出。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;输出消息&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>2.消息拼接：使用<code>message</code>命令可以将多个消息进行拼接输出。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;输出1&quot;</span> <span class="string">&quot;输出2&quot;</span> <span class="string">&quot;输出3&quot;</span>)  <span class="comment"># 会进行拼接输出</span></span><br></pre></td></tr></table></figure>

<p>3.设置变量：使用<code>set</code>命令可以设置变量的值。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(VAR1 <span class="string">&quot;变量1&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;VAR1=&quot;</span> <span class="variable">$&#123;VAR1&#125;</span>)  <span class="comment"># 外部访问</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;输出变量VAR1:$&#123;VAR1&#125;&quot;</span>)  <span class="comment"># 内部拼接</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;\$&#123;VAR1&#125;=$&#123;VAR1&#125;&quot;</span>)  <span class="comment"># 使用\转义</span></span><br></pre></td></tr></table></figure>

<p>4.删除变量：使用<code>unset</code>命令可以删除变量。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unset</span>(VAR1)  <span class="comment"># 删除变量</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;\$&#123;VAR1&#125;=$&#123;VAR1&#125;&quot;</span>)  <span class="comment"># 删除变量后，输出为空</span></span><br></pre></td></tr></table></figure>

<p>5.设置变量缓存：使用<code>set</code>命令的<code>CACHE</code>选项可以设置一个变量的缓存，可以通过命令行的<code>-D</code>参数来修改该变量的值。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CACHE_VARIABLE_TEST <span class="string">&quot;原始值&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;变量缓存的描述&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;变量缓存的值:$&#123;CACHE_VARIABLE_TEST&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>6.常见的内置变量：CMake提供了一些内置的变量，用于获取构建系统的信息和配置</p>
<p>第一类: 提供信息的变量</p>
<ul>
<li><code>PROJECT_NAME</code>：项目名称，表示当前CMake项目的名称。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;PROJECT_NAME&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMAKE_SOURCE_DIR</code>：源码目录，表示当前CMake项目的根源码目录。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMAKE_BINARY_DIR</code>：编译目录，表示当前CMake项目的编译输出目录。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMAKE_CURRENT_LIST_FILE</code>：当前CMakeLists.txt文件路径，表示当前正在处理的CMakeLists.txt文件的完整路径。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_FILE&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这些变量提供了与项目、目录结构和文件相关的信息。</p>
<hr>
<p>第二类: 控制CMake运行的变量</p>
<p>CMake中的变量通常是根据构建选项进行命名的，例如<code>BUILD_SHARED_LIBS</code>。这些变量用于控制CMake的运行和构建过程。</p>
<hr>
<p>第三类: 描述系统的变量</p>
<ul>
<li><code>WIN32</code>：表示当前操作系统是否为Windows。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;是否是Windows系统: $&#123;WIN32&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>UNIX</code>：表示当前操作系统是否为类Unix（包括Linux、macOS等）。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;是否是Unix系统: $&#123;UNIX&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMAKE_SYSTEM_NAME</code>：系统名称，表示当前操作系统的名称。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;系统名称: $&#123;CMAKE_SYSTEM_NAME&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这些变量用于描述当前操作系统的一些信息，以便在构建过程中进行条件判断和配置。</p>
<h3 id="2-3-8-include引入其他代码"><a href="#2-3-8-include引入其他代码" class="headerlink" title="2.3.8 include引入其他代码"></a>2.3.8 include引入其他代码</h3><h3 id="2-3-9-条件控制"><a href="#2-3-9-条件控制" class="headerlink" title="2.3.9 条件控制"></a>2.3.9 条件控制</h3><p>CMake提供了条件控制的语法和关键词，使得你可以根据条件来控制构建过程中的行为。以下是一些常用的条件控制关键词和语法：</p>
<ul>
<li><code>if (variable)</code>：当变量的值为真时，执行相应的代码块。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE为真时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>else()</code>：在if条件为假时执行的代码块。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE为真时执行的代码块</span></span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE为假时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>真值常量：<code>ON</code>、<code>YES</code>、<code>TRUE</code>、<code>Y</code>、<code>1</code>、非零数字等。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE <span class="keyword">STREQUAL</span> <span class="string">&quot;ON&quot;</span>)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE的值为真时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>假值常量：<code>OFF</code>、<code>NO</code>、<code>FALSE</code>、<code>N</code>、<code>0</code>、空字符串、<code>NOTFOUND</code>等。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE <span class="keyword">STREQUAL</span> <span class="string">&quot;OFF&quot;</span>)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE的值为假时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>关键词：<code>NOT</code>、<code>TARGET</code>、<code>EXISTS (file)</code>、<code>DEFINED</code>等，可以与条件一起使用。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> <span class="keyword">TARGET</span> MyTarget)</span><br><span class="line">    <span class="comment"># 当MyTarget不存在时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>逻辑运算符：<code>AND</code>、<code>OR</code>用于组合多个条件。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (CONDITION1 <span class="keyword">AND</span> CONDITION2)</span><br><span class="line">    <span class="comment"># 当CONDITION1和CONDITION2同时为真时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CONDITION1 <span class="keyword">OR</span> CONDITION2)</span><br><span class="line">    <span class="comment"># 当CONDITION1或CONDITION2至少一个为真时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>MATCHES (regular expression)</code>：使用正则表达式进行匹配。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE <span class="keyword">MATCHES</span> <span class="string">&quot;^prefix.*&quot;</span>)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE以&quot;prefix&quot;开头时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>VERSION LESS</code>、<code>VERSION LESS_EQUAL</code>：用于比较版本号。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VERSION VERSION <span class="keyword">LESS</span> <span class="number">2.0</span>)</span><br><span class="line">    <span class="comment"># 当MY_VERSION小于2.0时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>通过这些条件控制关键词和语法，你可以根据不同的条件来执行不同的代码块，从而实现更灵活和可配置的构建过程。你可以根据具体的需求选择适当的条件控制方式，并结合变量、关键词和运算符来编写CMake脚本。</p>
<h3 id="2-3-10-CMake分步编译"><a href="#2-3-10-CMake分步编译" class="headerlink" title="2.3.10 CMake分步编译"></a>2.3.10 CMake分步编译</h3><p>首先，你使用以下命令查看所有的目标：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --build . --target help</span><br></pre></td></tr></table></figure>

<p>这将列出项目中可用的目标列表，包括默认目标”all”、”clean”、”depend”、”rebuild_cache”、”edit_cache”以及其他一些目标。</p>
<p>接下来，你执行以下命令进行预处理：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --build . --target main.i</span><br></pre></td></tr></table></figure>

<p>这将对”main.cpp”源文件进行预处理，并将预处理结果保存在”CMakeFiles&#x2F;steps_demo.dir&#x2F;main.cpp.i”文件中。</p>
<p>然后，你执行以下命令进行编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --build . --target main.sI</span><br></pre></td></tr></table></figure>

<p>这将将”main.cpp”源文件编译为汇编代码，并将汇编代码保存在”CMakeFiles&#x2F;steps_demo.dir&#x2F;main.cpp.s”文件中。</p>
<p>接着，你执行以下命令进行汇编：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --build . --target main.o</span><br></pre></td></tr></table></figure>

<p>这将将汇编代码编译为目标文件，并将目标文件保存为”CMakeFiles&#x2F;steps_demo.dir&#x2F;main.cpp.o”。</p>
<p>最后，你执行以下命令进行链接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --build .</span><br></pre></td></tr></table></figure>

<p>这将扫描依赖项并链接生成最终的可执行文件”steps_demo”。</p>
<p>最后，你执行以下命令运行可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./steps_demo</span><br></pre></td></tr></table></figure>

<p>这将运行生成的可执行文件。</p>
<h3 id="2-3-11-生成器表达式"><a href="#2-3-11-生成器表达式" class="headerlink" title="2.3.11 生成器表达式"></a>2.3.11 生成器表达式</h3><p>生成器表达式是CMake中一种用于在生成构建系统时根据不同配置动态生成特定内容的表达式。它可以让代码更加精简和灵活。下面是几种常用的生成器表达式类型：</p>
<p>条件表达式：<code>$&lt;condition:true_string&gt;</code>。当条件为真时，返回<code>true_string</code>，否则返回空字符串。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">$&lt;<span class="number">0</span>:<span class="keyword">TEST</span>&gt;           <span class="comment"># 返回空字符串</span></span><br><span class="line">$&lt;<span class="number">1</span>:<span class="keyword">TEST</span>&gt;           <span class="comment"># 返回&quot;TEST&quot;</span></span><br><span class="line">$&lt;$&lt;BOOL:<span class="keyword">TRUE</span>&gt;:<span class="keyword">TEST</span>&gt;  <span class="comment"># 返回&quot;TEST&quot;</span></span><br></pre></td></tr></table></figure>

<p>变量查询（Variable-Query）：通过查询变量来获取动态的值。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">$&lt;TARGET_EXISTS:<span class="keyword">target</span>&gt;             <span class="comment"># 判断目标是否存在</span></span><br><span class="line">$&lt;CONFIG:Debug&gt;                     <span class="comment"># 判断当前构建类型是否为Debug</span></span><br></pre></td></tr></table></figure>

<p>目标查询（Target-Query）：通过查询目标来获取相关的信息。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">$&lt;TARGET_FILE:<span class="keyword">target</span>&gt;               <span class="comment"># 获取目标的文件路径</span></span><br><span class="line">$&lt;TARGET_FILE_NAME:<span class="keyword">target</span>&gt;          <span class="comment"># 获取目标的文件名</span></span><br></pre></td></tr></table></figure>

<p>输出相关表达式：用于在不同的构建环节使用不同的参数。比如，在<code>install</code>和<code>build</code>阶段使用不同的参数。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Foo ...)</span><br><span class="line"><span class="keyword">target_include_directories</span>(Foo</span><br><span class="line">    PUBLIC</span><br><span class="line">        $&lt;$&lt;CONFIG:Debug&gt;:<span class="variable">$&#123;DEBUG_INCLUDES&#125;</span>&gt;</span><br><span class="line">        $&lt;$&lt;CONFIG:Release&gt;:<span class="variable">$&#123;RELEASE_INCLUDES&#125;</span>&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在上述示例中，根据不同的构建配置（Debug或Release），生成器表达式选择性地包含不同的头文件路径。</p>
<p>需要注意的是，生成器表达式在生成构建系统时被展开，因此无法通过<code>message</code>命令直接打印。你可以使用类似<code>file(GENERATE OUTPUT &quot;./generator_test.txt&quot; CONTENT &quot;$&lt;$&lt;BOOL:TRUE&gt;:TEST&gt;&quot;)</code>的方式将生成器表达式的结果写入文件，以间接测试生成器表达式的值。</p>
<h3 id="2-3-12-函数和宏"><a href="#2-3-12-函数和宏" class="headerlink" title="2.3.12 函数和宏"></a>2.3.12 函数和宏</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个宏</span></span><br><span class="line"><span class="keyword">macro</span>(my_macro)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;宏内部的信息&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(macro_var <span class="string">&quot;宏内部变量test&quot;</span>)</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数</span></span><br><span class="line"><span class="keyword">function</span>(second_func arg1 arg2)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;第一个参数: $&#123;arg1&#125;，第二个参数: $&#123;arg2&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>my_macro</code>是一个没有参数的宏，它在宏内部输出一条信息，并设置了一个变量<code>macro_var</code>的值。</p>
<p><code>second_func</code>是一个函数，它有两个参数<code>arg1</code>和<code>arg2</code>。在函数内部，它输出了两个参数的值。</p>
<p>你可以在CMakeLists.txt文件中使用这些宏和函数，例如：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用宏</span></span><br><span class="line">my_macro()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">second_func(<span class="string">&quot;Hello&quot;</span> <span class="string">&quot;World&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当你运行CMake生成构建系统时，你将看到宏内部的信息输出，并且可以访问在宏或函数内部定义的变量。函数将输出参数的值。</p>
<p>请注意，宏和函数的定义需要在CMakeLists.txt文件的适当位置进行，并且在调用它们之前必须先定义它们。</p>
<h3 id="2-3-13-设置安装"><a href="#2-3-13-设置安装" class="headerlink" title="2.3.13 设置安装"></a>2.3.13 设置安装</h3><p><code>install</code>命令用于设置安装规则，将目标文件和文件夹安装到指定的位置。下面是你提供的代码的解释：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS instal_demo slib dlib</span><br><span class="line">    RUNTIME DESTINATION bin     <span class="comment"># 可执行文件安装路径</span></span><br><span class="line">    LIBRARY DESTINATION lib     <span class="comment"># 动态库安装路径</span></span><br><span class="line">    ARCHIVE DESTINATION lib     <span class="comment"># 静态库安装路径</span></span><br><span class="line">    PUBLIC_HEADER DESTINATION <span class="keyword">include</span>   <span class="comment"># 公共头文件安装路径</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>install</code>命令指定了要安装的目标文件列表，其中包括<code>instal_demo</code>、<code>slib</code>和<code>dlib</code>。</p>
<p>接下来，通过指定不同的<code>DESTINATION</code>参数，定义了目标文件在安装过程中的安装路径：</p>
<ul>
<li><code>RUNTIME DESTINATION bin</code>：指定可执行文件的安装路径为<code>bin</code>目录。</li>
<li><code>LIBRARY DESTINATION lib</code>：指定动态库的安装路径为<code>lib</code>目录。</li>
<li><code>ARCHIVE DESTINATION lib</code>：指定静态库的安装路径为<code>lib</code>目录。</li>
<li><code>PUBLIC_HEADER DESTINATION include</code>：指定公共头文件的安装路径为<code>include</code>目录。</li>
</ul>
<p>根据你的需求，这些目标文件将被安装到指定的目录中。</p>
<p>请注意，安装路径是相对于安装目录的，因此你需要确保安装目录在运行<code>make install</code>时正确设置。</p>
<p>要解决在安装后无法找到动态库的问题，可以使用<code>set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)</code>和<code>set(CMAKE_INSTALL_RPATH &quot;$&#123;CMAKE_INSTALL_PREFIX&#125;/lib&quot;)</code>来设置RPATH。</p>
<p>下面是相应的代码：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_WITH_INSTALL_RPATH <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_RPATH <span class="string">&quot;$&#123;CMAKE_INSTALL_PREFIX&#125;/lib&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)</code>指示在构建过程中使用与安装RPATH相同的RPATH。这样，在构建时就可以正确地查找和链接动态库。</p>
<p><code>set(CMAKE_INSTALL_RPATH &quot;$&#123;CMAKE_INSTALL_PREFIX&#125;/lib&quot;)</code>将安装RPATH设置为<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/lib</code>，其中<code>$&#123;CMAKE_INSTALL_PREFIX&#125;</code>是安装目录的路径。这将导致在安装时设置RPATH，使得安装后的可执行文件可以在<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/lib</code>目录中正确地查找和加载动态库。</p>
<p>通过使用这两个设置，你可以解决在安装后无法找到动态库的问题。确保将其放置在CMakeLists.txt文件中的合适位置，并根据实际情况调整<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/lib</code>路径，以匹配你的安装目录结构。</p>
<h3 id="2-3-14-寻找依赖find-package"><a href="#2-3-14-寻找依赖find-package" class="headerlink" title="2.3.14 寻找依赖find_package"></a>2.3.14 寻找依赖find_package</h3><p>对于大多数支持CMake的项目来说，可以使用<code>find_package</code>命令来查找对应的依赖库。通常情况下，如果找到了库，会设置以下变量（这些变量由库的作者设置）：</p>
<ul>
<li><code>&lt;LibaryName&gt;_FOUND</code>：表示是否找到库。</li>
<li><code>&lt;LibaryName&gt;_INCLUDE_DIR</code>：表示库的头文件目录。</li>
<li><code>&lt;LibaryName&gt;_LIBRARIES</code>：表示库的库文件目录。</li>
</ul>
<p>如果你编写了一个新的函数库，并希望其他项目可以通过<code>find_package</code>引用它，你可以使用以下两种方法：</p>
<ol>
<li><p>编写一个<code>Find&lt;LibraryName&gt;.cmake</code>文件：适用于导入非CMake安装的项目。</p>
<p>你可以编写一个名为<code>Find&lt;LibraryName&gt;.cmake</code>的文件，并将其放置在CMake的<code>Modules</code>目录或项目的特定目录中。该文件应包含查找和设置相关变量的逻辑。其他项目可以通过<code>find_package</code>命令来引用这个自定义的查找文件，从而找到并使用你的库。</p>
<p>附件: 15.custom_find</p>
</li>
<li><p>使用<code>install</code>安装并生成<code>&lt;LibraryName&gt;Config.cmake</code>文件：适用于导入你自己开发的CMake项目。</p>
<p>在你的库项目中，可以使用<code>install</code>命令将库文件安装到指定位置，并生成<code>&lt;LibraryName&gt;Config.cmake</code>文件。该文件应包含设置变量和导出目标的逻辑。其他项目可以通过<code>find_package</code>命令找到并使用你的库。</p>
</li>
</ol>
<p>&#x3D;&#x3D;现在只是简单的写了一下学习的内容，但是对于很多内容还并不是很熟悉，一切都要等到最后实战的时候&#x3D;&#x3D;</p>
]]></content>
      <categories>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>c++进阶语法 oop 智能指针 STL</title>
    <url>/2023/09/03/c-%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95-oop-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-STL/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-OOP面向对象开发"><a href="#1-OOP面向对象开发" class="headerlink" title="1 OOP面向对象开发"></a>1 OOP面向对象开发</h1><h2 id="1-1-类-class-和对象-objects"><a href="#1-1-类-class-和对象-objects" class="headerlink" title="1.1 类(class)和对象(objects)"></a>1.1 类(class)和对象(objects)</h2><pre><code>类(classes)和对象(objects)
</code></pre>
<p>C++类(classes)</p>
<ul>
<li>创建对象用的蓝图(blueprint)</li>
<li>用户自定义的数据类型</li>
<li>有成员属性(data)和成员方法(methods)</li>
<li>可以隐藏属性和方法(private)</li>
<li>可以提供公共接口(public)</li>
<li>示例:Account,Student,std:vector, std:string</li>
</ul>
<p>C++对象(objects)</p>
<ul>
<li>由类创建而来</li>
<li>表示类的一个具体的实例(lnstance)</li>
<li>可以有很多个实例，每个都有独立的身份·每个对象都可以使用类中定义的方法</li>
</ul>
<p>Account对象示例</p>
<ul>
<li>Jobs、Alice的apunt是Account类的实例</li>
<li>每个实例都有它的余额、可以提现、存钱</li>
</ul>
<p>声明一个类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span></span>; <span class="comment">// 存款</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span></span>; <span class="comment">// 取款</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建类的对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Account jobs_account;</span><br><span class="line">Account alice_account;</span><br><span class="line">Account* mary_account = <span class="keyword">new</span> <span class="built_in">Account</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> mary_account;</span><br></pre></td></tr></table></figure>



<p>示例1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> </span><br><span class="line">&#123;</span><br><span class="line">    string name &#123;<span class="string">&quot;None&quot;</span>&#125;;</span><br><span class="line">    <span class="type">double</span> balance &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Account a;</span><br><span class="line">    Account b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>获取类的属性或者方法</p>
<p>使用点操作符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Account jobs_account;</span><br><span class="line">jobs_account.balance;</span><br><span class="line">jobs_account.<span class="built_in">deposit</span>( <span class="number">10.00</span>);</span><br></pre></td></tr></table></figure>

<p>如果是一个指向对象的指针，可以解引用或者使用箭头操作符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Account* alice_account = <span class="keyword">new</span> <span class="built_in">Account</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解引用指针并访问成员</span></span><br><span class="line">(*alice_account).balance; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指针访问成员</span></span><br><span class="line">alice_account-&gt;<span class="built_in">deposit</span>(<span class="number">100.0</span>);</span><br><span class="line">alice_account-&gt;balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> alice_account;</span><br></pre></td></tr></table></figure>



<h2 id="1-2-public、private、protected访问权限"><a href="#1-2-public、private、protected访问权限" class="headerlink" title="1.2 public、private、protected访问权限"></a>1.2 public、private、protected访问权限</h2><p>public</p>
<p>可以被任何实体访问   </p>
<hr>
<p>private<br>只能被本类的方法访问</p>
<hr>
<p>protected</p>
<p>可以被本类和子类(继承)的方法访问\</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span></span>; <span class="comment">// 存款</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span></span>; <span class="comment">// 取款</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>在类中实现完整的成员方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="type">double</span> balance &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">setBalance</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        balance = amount;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在类外面实现需要特殊定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="type">double</span> balance &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">setBalance</span><span class="params">(<span class="type">double</span> amount)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBalance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Account::setBalance</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">    balance = amount;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Account::getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-3-构造函数-constructor"><a href="#1-3-构造函数-constructor" class="headerlink" title="1.3 构造函数(constructor)"></a>1.3 构造函数(constructor)</h2><ul>
<li>特殊的成员方法</li>
<li>对象创建的时候自动调用</li>
<li>适用于实例参数初始化</li>
<li>函数名和类的名称一致</li>
<li>无需设置返回类型</li>
<li>可以被重载(overload)</li>
</ul>
<h2 id="1-4-析构函数-destructor"><a href="#1-4-析构函数-destructor" class="headerlink" title="1.4 析构函数(destructor)"></a>1.4 析构函数(destructor)</h2><ul>
<li>特殊的成员方法</li>
<li>函数名和类的名称一致，前面跟着一个~波浪符号</li>
<li>对象销毁的时候自动调用</li>
<li>没有参数，没有返回类型</li>
<li>只有一个析构函数(不能重载)</li>
<li>适用于释放内存等资源</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    std::string name&#123;<span class="string">&quot;account&quot;</span>&#125;;</span><br><span class="line">    <span class="type">double</span> balance&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Account</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Account</span>(std::string name);</span><br><span class="line">    <span class="built_in">Account</span>(<span class="type">double</span> balance);</span><br><span class="line">    <span class="built_in">Account</span>(std::string name, <span class="type">double</span> balance);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Account</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​		</p>
<h2 id="1-5-构造函数初始化列表"><a href="#1-5-构造函数初始化列表" class="headerlink" title="1.5 构造函数初始化列表"></a>1.5 构造函数初始化列表</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，使用构造函数内部初始化参数</span></span><br><span class="line">    <span class="built_in">Account</span>(std::string name, <span class="type">double</span> balance) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，使用初始化列表初始化参数</span></span><br><span class="line">    <span class="built_in">Account</span>(std::string name, <span class="type">double</span> balance)</span><br><span class="line">        : name&#123;name&#125;, balance&#123;balance&#125; &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-代理构造函数"><a href="#1-6-代理构造函数" class="headerlink" title="1.6 代理构造函数"></a>1.6 代理构造函数</h2><ul>
<li>重载的构造函数很相似·冗余的代码可能会导致错误</li>
<li>使用代理构造函数</li>
<li>在一个构造函数初始化列表中调用另一个构造函数</li>
</ul>
<h2 id="1-7-拷贝构造函数"><a href="#1-7-拷贝构造函数" class="headerlink" title="1.7 拷贝构造函数"></a>1.7 拷贝构造函数</h2><p>当对象被拷贝时，C++必须从已存在的对象复制出一个新的对象</p>
<p>何时使用拷贝构造函数?</p>
<ul>
<li>以值传递方式传递对象给函数（作参数)</li>
<li>函数以值方式返回对象</li>
<li>使用已存在的对象复制新的对象</li>
</ul>
<p>如果不提供自己写的copy constructor,编译器会自动生成一个(可能不符合要</p>
<h2 id="1-9-浅拷贝和深拷贝"><a href="#1-9-浅拷贝和深拷贝" class="headerlink" title="1.9 浅拷贝和深拷贝"></a>1.9 浅拷贝和深拷贝</h2><p>如果不提供自己写的copy constructor.编译器会生成默认的<br>将目标对象的值逐个拷贝过来;<br>如果是指针，拷贝的是值（指向的地址)，而不是指向的对象（浅拷贝)在析构函数中释放内存时，其他对象中的指针可能还在指向被释放的资源</p>
<h2 id="1-10-在类中使用const"><a href="#1-10-在类中使用const" class="headerlink" title="1.10 在类中使用const"></a>1.10 在类中使用const</h2><p>在类中使用const常函数</p>
<p>函数名称后加const</p>
<ul>
<li>函数体内不可以修改类成员属性。常对象</li>
</ul>
<p>声明对象时前面加const</p>
<ul>
<li>不可以修改常对象的成员属性仅能调用常函数</li>
</ul>
<h2 id="1-11-在类中使用static"><a href="#1-11-在类中使用static" class="headerlink" title="1.11 在类中使用static"></a>1.11 在类中使用static</h2><p>静态成员变量</p>
<ul>
<li><p>所有对象共有同一份数据（数据共享)</p>
</li>
<li><p>在类中声明，类外初始化</p>
</li>
</ul>
<p>静态成员函数</p>
<p>所有对象共享同一个函数</p>
<ul>
<li>只能访问静态成员变量</li>
</ul>
<h2 id="1-12-struct和class区别"><a href="#1-12-struct和class区别" class="headerlink" title="1.12 struct和class区别"></a>1.12 struct和class区别</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    std::string name&#123;<span class="string">&quot;none&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认私有属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    std::string name&#123;<span class="string">&quot;none&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 默认公有属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Account aa;</span><br><span class="line">    <span class="comment">// aa.name = &quot;bob&quot;; // 报错，无法访问私有成员</span></span><br><span class="line"></span><br><span class="line">    Student ss;</span><br><span class="line">    ss.name = <span class="string">&quot;alice&quot;</span>; <span class="comment">// 可以访问公有成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-智能指针"><a href="#2-智能指针" class="headerlink" title="2 智能指针"></a>2 智能指针</h1><p>原始指针(raw pointer)的一些问题</p>
<p>1.c++提供了内存管理的绝对自由度</p>
<ul>
<li><p>分配</p>
</li>
<li><p>释放</p>
</li>
<li><p>声明周期管理</p>
</li>
</ul>
<p>2.一些潜在严重问题</p>
<ul>
<li><p>未初始化的指针(wild pointer)</p>
</li>
<li><p>内存泄漏(memory leak)</p>
</li>
<li><p>悬空指针(dangling pointer</p>
</li>
</ul>
<p>3.所有权(ownership)</p>
<ul>
<li>谁拥有指针?</li>
<li>何时可以删除指针?</li>
</ul>
<p>C++智能指针是一种用来管理动态分配的内存的工具，它们遵循RAII（资源获取即初始化）原则，可以自动释放内存，防止内存泄漏。</p>
<p>以下是几种常见的C++智能指针：</p>
<ol>
<li><code>unique_ptr</code>: <code>unique_ptr</code> 是一种独占所有权的智能指针，它指向堆上分配的对象，并负责在其生命周期结束时自动删除对象。每个 <code>unique_ptr</code> 只能拥有一个对象，并且不能进行拷贝，但可以进行移动。</li>
<li><code>shared_ptr</code>: <code>shared_ptr</code> 是一种共享所有权的智能指针，多个 <code>shared_ptr</code> 可以指向同一个对象。它使用引用计数来跟踪对象的所有者数量，并在最后一个所有者释放内存时删除对象。</li>
<li><code>weak_ptr</code>: <code>weak_ptr</code> 是一种弱引用指针，它可以与 <code>shared_ptr</code> 一起使用。<code>weak_ptr</code> 不会增加对象的引用计数，它允许对被 <code>shared_ptr</code> 管理的对象进行观测，但不拥有所有权。当 <code>shared_ptr</code> 删除对象后，<code>weak_ptr</code> 会自动失效。</li>
<li><code>auto_ptr</code>（已弃用）: <code>auto_ptr</code> 是C++98标准引入的智能指针，它类似于 <code>unique_ptr</code>，但具有一些问题和局限性，已被废弃，不推荐使用。</li>
</ol>
<p><code>unique_ptr&lt;T&gt;</code> 是一种独占所有权的智能指针，用于指向堆上的类型为 <code>T</code> 的对象。它保证在其生命周期结束时自动释放所指向的对象，确保资源的正确释放，避免内存泄漏。</p>
<p><code>unique_ptr</code> 的特点如下：</p>
<ul>
<li>它是唯一（unique）的，即一个 <code>unique_ptr</code> 对象拥有对应对象的唯一所有权。不能有多个 <code>unique_ptr</code> 指向同一个对象，这样可以避免多次释放同一块内存的问题。</li>
<li><code>unique_ptr</code> 不能进行复制或赋值，但可以通过移动语义来转移所有权。这意味着可以将所有权从一个 <code>unique_ptr</code> 转移到另一个 <code>unique_ptr</code>，从而实现对象所有权的转移而不进行内存复制。</li>
<li>当 <code>unique_ptr</code> 使用完毕或超出作用域时，它所指向的对象会自动释放和销毁，无需手动调用 <code>delete</code>。</li>
</ul>
<p>&#x3D;&#x3D;目前还没用过，等真正用过的时候再仔细看吧&#x3D;&#x3D;</p>
<h1 id="3-STL标准模板库"><a href="#3-STL标准模板库" class="headerlink" title="3 STL标准模板库"></a>3 STL标准模板库</h1><h2 id="3-1-STL简介"><a href="#3-1-STL简介" class="headerlink" title="3.1 STL简介"></a>3.1 STL简介</h2><p>一个强大的、可复用的、自适应的泛型类和函数集合</p>
<p>使用C++模板(templates)实现</p>
<p>实现了常见的数据结构(data struuctures)和算法(algorithms)</p>
<p>庞大的类库</p>
<p>俄裔美籍程序员:Alexander Step:anov 1994年开发</p>
<p>容器(containers)</p>
<ul>
<li>各种对象或原始类型的集合. array、vector、deque、stack、set、map等</li>
</ul>
<p>算法(algorithms)</p>
<ul>
<li>处理容器元素序列的各种函数find、max、count、accumulate、sort等</li>
</ul>
<p>迭代器(iterators)</p>
<ul>
<li>从容器中生成元素的序列. forward、reveise、by value、by constant等</li>
</ul>
<h2 id="3-2-STL容器的类别"><a href="#3-2-STL容器的类别" class="headerlink" title="3.2 STL容器的类别"></a>3.2 STL容器的类别</h2><p>序列式容器（Sequence Containers）：</p>
<ol>
<li><code>vector</code>：动态数组，支持快速随机访问，尾部插入和删除元素效率高，但在中间或头部插入和删除元素效率低。</li>
<li><code>list</code>：双向链表，支持在任意位置插入和删除元素，但随机访问效率较低。</li>
<li><code>forward_list</code>：单向链表，与 <code>list</code> 类似，但只支持单向遍历，没有双向遍历的能力。</li>
<li><code>deque</code>：双端队列，支持在头部和尾部高效地插入和删除元素，同时支持随机访问。</li>
</ol>
<p>关联式容器（Associative Containers）：</p>
<ol>
<li><code>set</code>：集合，存储唯一的元素，并按升序排序。</li>
<li><code>multi_set</code>：多重集合，可存储重复的元素，并按升序排序。</li>
<li><code>map</code>：映射，存储键值对，按键的升序排序。</li>
<li><code>multi_map</code>：多重映射，可存储重复的键值对，并按键的升序排序。</li>
</ol>
<p>容器适配器（Container Adapters）：</p>
<ol>
<li><code>stack</code>：栈，以 LIFO（后进先出）的方式存储元素，底层基于序列式容器实现，默认使用 <code>deque</code>。</li>
<li><code>queue</code>：队列，以 FIFO（先进先出）的方式存储元素，底层基于序列式容器实现，默认使用 <code>deque</code>。</li>
<li><code>priority_queue</code>：优先队列，按照优先级存储元素，底层基于序列式容器实现，默认使用 <code>vector</code>。</li>
</ol>
<h2 id="3-3-STL迭代器的类别"><a href="#3-3-STL迭代器的类别" class="headerlink" title="3.3 STL迭代器的类别"></a>3.3 STL迭代器的类别</h2><p>迭代器是一种用于遍历容器中元素的抽象概念，它提供了对容器中元素的访问和操作方式。C++中定义了多种类型的迭代器，每种迭代器具有不同的特性和功能。</p>
<ol>
<li>输入迭代器（Input Iterators）：从容器到程序，对数据进行只读访问。它允许逐个元素地读取容器中的数据，并且只能单向移动，不支持对容器进行修改。</li>
<li>输出迭代器（Output Iterators）：从程序到容器，对数据进行只写访问。它允许逐个元素地向容器中写入数据，并且只能单向移动，不支持读取容器中的数据。</li>
<li>前向迭代器（Forward Iterators）：向前推进迭代器，支持对容器进行读写操作。它具有输入迭代器和输出迭代器的所有功能，并且可以在容器中任意位置插入和删除元素，支持双向移动。</li>
<li>双向迭代器（Bidirectional Iterators）：向前、向后推进迭代器，支持对容器进行读写操作。它具有前向迭代器的所有功能，并且可以反向移动，即向前和向后移动。</li>
<li>随机访问迭代器（Random Access Iterators）：直接获取容器元素，支持对容器进行读写操作。它具有双向迭代器的所有功能，并且支持随机访问，可以通过偏移量直接访问容器中的任意元素。</li>
</ol>
<h2 id="3-4-STL算法的类别"><a href="#3-4-STL算法的类别" class="headerlink" title="3.4 STL算法的类别"></a>3.4 STL算法的类别</h2><p>非质变的算法（Non-modifying Algorithms）：</p>
<ol>
<li><code>std::all_of</code>：判断范围内的所有元素是否满足给定条件。</li>
<li><code>std::any_of</code>：判断范围内是否存在满足给定条件的元素。</li>
<li><code>std::none_of</code>：判断范围内是否所有元素都不满足给定条件。</li>
<li><code>std::for_each</code>：对范围内的每个元素执行指定的操作。</li>
<li><code>std::count</code>：计算范围内满足给定值的元素个数。</li>
<li><code>std::count_if</code>：计算范围内满足给定条件的元素个数。</li>
<li><code>std::find</code>：查找范围内第一个等于给定值的元素。</li>
<li><code>std::find_if</code>：查找范围内第一个满足给定条件的元素。</li>
<li><code>std::find_if_not</code>：查找范围内第一个不满足给定条件的元素。</li>
<li><code>std::find_end</code>：在范围内查找最后一次出现子序列的起始位置。</li>
<li><code>std::find_first_of</code>：在范围内查找第一次出现指定元素之一的位置。</li>
<li><code>std::adjacent_find</code>：在范围内查找第一对相邻重复元素的位置。</li>
<li><code>std::search</code>：在范围内查找第一次出现子序列的起始位置。</li>
<li><code>std::search_n</code>：在范围内查找第一次出现连续多个相等元素的起始位置。</li>
<li><code>std::equal</code>：判断两个范围内的元素是否相等。</li>
<li><code>std::mismatch</code>：找到两个范围内第一次不匹配的位置。</li>
<li><code>std::lexicographical_compare</code>：按字典顺序比较两个范围。</li>
<li><code>std::is_permutation</code>：判断两个范围内的元素是否是排列关系。</li>
<li><code>std::min_element</code>：找到范围内的最小元素的位置。</li>
<li><code>std::max_element</code>：找到范围内的最大元素的位置。</li>
<li><code>std::minmax_element</code>：同时找到范围内的最小和最大元素的位置。</li>
<li><code>std::clamp</code>：将给定值限制在指定范围内。</li>
<li><code>std::is_sorted</code>：判断范围内的元素是否按升序排序。</li>
<li><code>std::is_partitioned</code>：判断范围内的元素是否满足分区条件。</li>
<li><code>std::is_heap</code>：判断范围内的元素是否满足堆的条件。</li>
<li><code>std::is_sorted_until</code>：找到范围内的第一个无序位置。</li>
<li><code>std::is_partitioned_until</code>：找到范围内的第一个不满足分区条件的位置。</li>
<li><code>std::is_heap_until</code>：找到范围内的第一个不满足堆条件的位置。</li>
</ol>
<p>质变的算法（Modifying Algorithms）：</p>
<ol>
<li><code>std::copy</code>：复制范围内的元素到另一个容器。</li>
<li><code>std::copy_if</code>：复制满足给定条件的元素到另一个容器。</li>
<li><code>std::copy_n</code>：复制指定数量的元素到另一个容器。</li>
<li><code>std::copy_backward</code>：反向复制范围内的元素到另一个容器。</li>
<li><code>std::move</code>：将范围内的元素移动到另一个容器。</li>
<li><code>std::move_backward</code>：反向移动范围内的元素到另一个容器。</li>
<li><code>std::fill</code>：用给定值填充容器中的元素。</li>
<li><code>std::fill_n</code>：用给定值填充指定数量的元素。</li>
<li><code>std::generate</code>：使用生成器函数生成范围内的元素。</li>
<li><code>std::generate_n</code>：使用生成器函数生成指定数量的元素。</li>
<li><code>std::transform</code>：对范围内的元素应用指定的操作，并将结果存储到另一个容器。</li>
<li><code>std::replace</code>：将范围内的指定值替换为新值。</li>
<li><code>std::replace_if</code>：根据给定条件将范围内的元素替换为新值。</li>
<li><code>std::replace_copy</code>：将范围内的元素复制到另一个容器，并将指定值替换为新值。</li>
<li><code>std::replace_copy_if</code>：将范围内的元素复制到另一个容器，并根据给定条件替换为新值。</li>
<li><code>std::swap</code>：交换两个对象的值。</li>
<li><code>std::swap_ranges</code>：交换两个范围的元素。</li>
<li><code>std::iter_swap</code>：交换两个迭代器所指向的元素。</li>
<li><code>std::reverse</code>：反转范围内的元素顺序。</li>
<li><code>std::reverse_copy</code>：将范围内的元素反转后复制到另一个容器。</li>
<li><code>std::rotate</code>：将范围内的元素循环右移。</li>
<li><code>std::rotate_copy</code>：将范围内的元素循环右移后复制到另一个容器。</li>
<li><code>std::shuffle</code>：随机重排范围内的元素。</li>
<li><code>std::unique</code>：移除范围内的连续重复元素，只保留一个副本。</li>
<li><code>std::unique_copy</code>：将范围内的连续重复元素复制到另一个容器，只保留一个副本。</li>
<li><code>std::partition</code>：根据给定条件将范围内的元素分为满足条件和不满足条件的两部分。</li>
<li><code>std::stable_partition</code>：根据给定条件将范围内的元素稳定地分为满足条件和不满足条件的两部分。</li>
<li><code>std::sort</code>：对范围内的元素进行排序。</li>
<li><code>std::stable_sort</code>：对范围内的元素进行稳定排序。</li>
<li><code>std::partial_sort</code>：部分排序范围内的元素。</li>
<li><code>std::nth_element</code>：将范围内的第 n 小的元素移动到指定位置。</li>
<li><code>std::inplace_merge</code>：将两个已排序的范围合并为一个已排序的范围。</li>
<li><code>std::transform</code>：对范围内的元素应用指定的操作，并将结果存储到另一个容器。</li>
<li><code>std::generate</code>：使用生成器函数生成范围内的元素。</li>
<li><code>std::generate_n</code>：使用生成器函数生成指定数量的元素。</li>
<li><code>std::random_shuffle</code>：随机重排范围内的元素。</li>
<li><code>std::partition</code>：根据给定条件将范围内的元素分为满足条件和不满足条件的两部分。</li>
<li><code>std::sort</code>：对范围内的元素进行排序。</li>
<li><code>std::stable_sort</code>：对范围内的元素进行稳定排序。</li>
<li><code>std::partial_sort</code>：部分排序范围内的元素。</li>
<li><code>std::nth_element</code>：将范围内的第 n 小的元素移动到指定位置。</li>
<li><code>std::inplace_merge</code>：将两个已排序的范围合并为一个已排序的范围。</li>
<li><code>std::copy_backward</code>：反向复制范围内的元素到另一个容器。</li>
</ol>
<h2 id="3-5泛型编程和宏"><a href="#3-5泛型编程和宏" class="headerlink" title="3.5泛型编程和宏"></a>3.5泛型编程和宏</h2><h2 id="3-6函数模板"><a href="#3-6函数模板" class="headerlink" title="3.6函数模板"></a>3.6函数模板</h2><p>函数模板（Function Template）是C++中的一种特殊函数，用于定义通用的函数，可以适用于不同类型的参数。函数模板通过在函数定义中使用类型参数来实现通用性，这些类型参数可以在函数调用时被具体的类型替代。</p>
<p>以下是两个使用函数模板定义的求最大值函数的示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(a, b) &lt;&lt; std::endl;  <span class="comment">// 调用模板函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-7类模板"><a href="#3-7类模板" class="headerlink" title="3.7类模板"></a>3.7类模板</h2><p>类模板（Class Template）是C++中的一种特殊类，用于定义通用的类，可以适用于不同类型的成员变量和成员函数。类模板通过在类定义中使用类型参数来实现通用性，这些类型参数可以在类实例化时被具体的类型替代。</p>
<p>类模板的使用方式类似于函数模板，通过在类定义前面使用 <code>template&lt;typename T&gt;</code> 或 <code>template&lt;class T&gt;</code> 声明一个模板类，其中 <code>T</code> 是一个模板参数，可以在类内部的成员变量和成员函数中使用。</p>
<p>以下是一个使用类模板定义的通用的容器类的示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Container</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ 进阶 函数和指针</title>
    <url>/2023/09/03/c-%E8%BF%9B%E9%98%B6-%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-掌握C-函数基本概念用法"><a href="#1-掌握C-函数基本概念用法" class="headerlink" title="1.掌握C++函数基本概念用法"></a>1.掌握C++函数基本概念用法</h1><h2 id="1-1-函数定义"><a href="#1-1-函数定义" class="headerlink" title="1.1 函数定义"></a>1.1 函数定义</h2><p>什么是函数(function)</p>
<ul>
<li><p>C++程序</p>
</li>
<li><p>C++标准库(functions和clas;ses)</p>
</li>
<li><p>第三方库(functions和class</p>
</li>
<li><p>自定义的functions和classes</p>
</li>
</ul>
<p>函数让我们的程序更加模块化</p>
<ul>
<li>让代码解耦，分成按业务，</li>
<li>按逻辑的单元提高代码复用性</li>
</ul>
<p>函数名称参数列表</p>
<ul>
<li><p>传给函数的变量</p>
</li>
<li><p>变量类型需声明</p>
</li>
</ul>
<p>返回值类型</p>
<ul>
<li><p>函数体</p>
</li>
<li><p>函数被调用执行的部分，花括号{}内部</p>
<p>示例1：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI &#123;<span class="number">3.1415926</span>&#125;; <span class="comment">// 圆周率</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculate_area</span><span class="params">(<span class="type">double</span> radius)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PI * <span class="built_in">pow</span>(radius, <span class="number">2</span>); <span class="comment">// pow()函数用于计算幂</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">circle_area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入圆的半径：&quot;</span>;</span><br><span class="line">    <span class="type">double</span> radius &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    cin &gt;&gt; radius;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的面积为：&quot;</span> &lt;&lt; <span class="built_in">calculate_area</span>(radius) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">circle_area</span>(); <span class="comment">// 调用计算圆的面积的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="1-2-函数原型-prototype"><a href="#1-2-函数原型-prototype" class="headerlink" title="1.2 函数原型(prototype)"></a>1.2 函数原型(prototype)</h2><p>&#x3D;&#x3D;编译器要求:使用函数前必须“见过”这个函数&#x3D;&#x3D;</p>
<p>先定义函数再调用</p>
<ul>
<li>适用于小型程序，不适用于大型项目</li>
</ul>
<p>使用函数原型</p>
<ul>
<li><p>告诉编译器函数定义必要的信息</p>
</li>
<li><p>也称为前向声明(forward declaration)</p>
</li>
<li><p>放在程序开始的部分</p>
</li>
<li><p>或者放在头文件(header files.h)中</p>
</li>
</ul>
<h2 id="1-3参数"><a href="#1-3参数" class="headerlink" title="1.3参数"></a>1.3参数</h2><ol>
<li>当我们传递数据给函数时，其实用的是值传递(pass by value)</li>
<li>数据的拷贝会传给函数</li>
<li>函数内部的代码不会改变我们传给它的变量</li>
</ol>
<p>形参(formal parameters)与实参(actual parameters)<br>形参(formal parameters)</p>
<ul>
<li>函数定义语句中的参数</li>
</ul>
<p>实参(actual parameters</p>
<ul>
<li>调用函数时传递的参数(arguments)</li>
</ul>
<h2 id="1-4-重载"><a href="#1-4-重载" class="headerlink" title="1.4 重载"></a>1.4 重载</h2><p>一组函数具有相同函数名，不同参数列表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数原型，函数重载</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_numbers</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>; <span class="comment">// 两个 int 类型数字相加</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add_numbers</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>; <span class="comment">// 两个 double 类型数字相加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_numbers</span>(<span class="number">5</span>, <span class="number">10</span>) &lt;&lt; endl; <span class="comment">// int 类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_numbers</span>(<span class="number">1.23</span>, <span class="number">2.45</span>) &lt;&lt; endl; <span class="comment">// double 类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_numbers</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add_numbers</span><span class="params">(<span class="type">double</span> num1, <span class="type">double</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-5-函数传参-数组、引用"><a href="#1-5-函数传参-数组、引用" class="headerlink" title="1.5 函数传参(数组、引用)"></a>1.5 函数传参(数组、引用)</h2><ul>
<li><p>数组元素并没有复制</p>
</li>
<li><p>数组变量名称表示第一个元素在内存中的地址这个地址才被复制了</p>
</li>
<li><p>函数内部无法知道数组大小(数组大小需要额外传参)</p>
<p>·声明参数numbers是常量(只读read-only)</p>
</li>
</ul>
<p>		</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_array</span> <span class="params">(<span class="type">const</span> <span class="type">int</span> numbers[ ], <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_num</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换两个数字</span></span><br><span class="line">    <span class="type">int</span> x &#123;<span class="number">100</span>&#125;, y &#123;<span class="number">200</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y is: &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 100 200</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap_num</span>(x, y);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y is: &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 200 100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的是取地址，上面的函数和下面这个函数的作用相同：</p>
<p>传递地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_num</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换两个数字</span></span><br><span class="line">    <span class="type">int</span> x &#123;<span class="number">100</span>&#125;, y &#123;<span class="number">200</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y is: &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 100 200</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap_num</span>(&amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y is: &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 200 100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&#x3D;&#x3D;注意&#x3D;&#x3D;</p>
<p><code>int&amp;</code> 是 C++ 中的引用类型，它是一种特殊的类型，用于给一个已存在的变量起一个别名。可以将其理解为变量的一个别名或者另一个名称，与原变量共享同一块内存空间。</p>
<p>引用类型与指针类型有所不同。引用在声明时必须初始化，并且一旦初始化后，它就一直引用同一个对象，不能再引用其他对象。而指针可以在声明后重新指向不同的对象。</p>
<p>使用引用类型的主要目的是提供一种更简洁、更直观的方式来操作变量，同时避免了指针操作的一些繁琐性和潜在的错误。</p>
<p>在上述修正后的代码中，<code>int&amp;</code> 用于函数参数的声明，表示传递的参数是一个整数的引用。通过引用参数，可以直接修改原变量的值，而无需通过指针进行解引用。在函数内部，通过引用操作修改了 <code>a</code> 和 <code>b</code> 所指向的变量的值。</p>
<p>其实也就相当于传地址</p>
<h1 id="2-掌握C-指针基本概念、用法"><a href="#2-掌握C-指针基本概念、用法" class="headerlink" title="2.掌握C++指针基本概念、用法"></a>2.掌握C++指针基本概念、用法</h1><h2 id="2-1-什么是指针"><a href="#2-1-什么是指针" class="headerlink" title="2.1 什么是指针"></a>2.1 什么是指针</h2><p>指针是变量<br>变量的值是一个地址<br>指针的值可以存储哪些地址?</p>
<p>另一个变量</p>
<p>函数</p>
<hr>
<p>如果指针指向变量或函数，那么为什么不直接用他们?</p>
<p>可以，但不常用:</p>
<ul>
<li><p>函数内部，指针可以访问函数作用域外的数据</p>
</li>
<li><p>高效操作数组</p>
</li>
<li><p>在堆(heap)上动态分配内存空间</p>
<p>​      这些空间没有变量名称只能通过指针访问</p>
</li>
<li><p>可以获取内存中特殊地址</p>
</li>
</ul>
<p>​              如嵌入式系统、设备驱动等</p>
<hr>
<ul>
<li>&amp;地址操作符</li>
<li>指针也是一个变量(variable)，所以它的值可以改变</li>
<li>指针可以为null</li>
<li>指针可以不初始化</li>
</ul>
<h2 id="2-2-动态内存分配-dynami-allocation"><a href="#2-2-动态内存分配-dynami-allocation" class="headerlink" title="2.2 动态内存分配(dynami allocation)"></a>2.2 动态内存分配(dynami allocation)</h2><p>在堆(heap)上程序员自己分配内存空间;<br>数组(array)</p>
<ul>
<li>使用数组需要知道数组大小，并且数组大小是固定的;</li>
<li>Vector容器大小可以动态调整</li>
</ul>
<p>使用指针获取堆上刚分配的内存空间</p>
<hr>
<p>使用new[]为数组分配内存空间</p>
<p>使用delete[]释放内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* array_ptr &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr_size &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;你需要多少个整数: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; arr_size;</span><br><span class="line"></span><br><span class="line">    array_ptr = <span class="keyword">new</span> <span class="type">int</span>[arr_size]; <span class="comment">// 在堆上分配内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] array_ptr; <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-指针和数组的关系"><a href="#2-3-指针和数组的关系" class="headerlink" title="2.3 指针和数组的关系"></a>2.3 指针和数组的关系</h2><ul>
<li>数组变量名称的值是数组第一个元素的地址;</li>
<li>指针变量的的值是一个地址;</li>
<li>如果指针指向的类型和数组元素的类型一致，那么指针和数组名称几乎是等价的</li>
</ul>
<h2 id="2-4-const和指针一一指针本身和被指向的对象都是常量"><a href="#2-4-const和指针一一指针本身和被指向的对象都是常量" class="headerlink" title="2.4 const和指针一一指针本身和被指向的对象都是常量"></a>2.4 const和指针一一指针本身和被指向的对象都是常量</h2><p>指针可以操作:地址及被指向的对象</p>
<ul>
<li>被指向的对象是常量(povinters to constants)</li>
<li>指针本身是常量(constant pointers)</li>
<li>指针本身和被指向的对象都是常量(constant pointers to constants)</li>
</ul>
<p>示例1</p>
<ul>
<li>被指向的对象是常量，不可以通过指针改动·</li>
<li>指针本身可以改变</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> high_temp &#123;<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="type">int</span> low_temp &#123;<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* temp_ptr &#123;&amp;high_temp&#125;; <span class="comment">// 被指向的数据是常量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// *temp_ptr = 100; // 错误，不能通过解引用修改常量的值</span></span><br><span class="line"></span><br><span class="line">    temp_ptr = &amp;low_temp; <span class="comment">// 正确，可以通过指针修改指向的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例2</p>
<ul>
<li>被指向的对象可以通过指针改动</li>
<li>指针本身不可以改变</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> high_temp &#123;<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="type">int</span> low_temp &#123;<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> temp_ptr &#123;&amp;high_temp&#125;; <span class="comment">// 指针本身是常量，指向 high_temp</span></span><br><span class="line"></span><br><span class="line">    *temp_ptr = <span class="number">100</span>; <span class="comment">// 正确，通过指针解引用修改值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// temp_ptr = &amp;low_temp; // 错误，不能修改指针的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>示例3 </p>
<ul>
<li>被指向的对象不可以改动</li>
<li>指针本身不可以改变</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> high_temp &#123;<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="type">int</span> low_temp &#123;<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> temp_ptr &#123;&amp;high_temp&#125;; <span class="comment">// 指针和被指向对象都是常量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// *temp_ptr = 100; // 错误，不能修改指针指向的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// temp_ptr = &amp;low_temp; // 错误，不能修改指针的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-函数返回指针"><a href="#2-5-函数返回指针" class="headerlink" title="2.5 函数返回指针"></a>2.5 函数返回指针</h2><p>函数可以返回指针:</p>
<p> *function( );</p>
<p>返回哪些指针:</p>
<ul>
<li>函数内部动态分配的内存空间传入的数据</li>
<li>不能返回函数内的局部变量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">create_array</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> initial_value = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* new_storage &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    new_storage = <span class="keyword">new</span> <span class="type">int</span>[size]; <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i&#123;<span class="number">0</span>&#125;; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 初始化值</span></span><br><span class="line">        *(new_storage + i) = initial_value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_storage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> size &#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* array_ptr = <span class="built_in">create_array</span>(size, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数组元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i&#123;<span class="number">0</span>&#125;; i &lt; size; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; *(array_ptr + i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] array_ptr; <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 进阶</title>
    <url>/2023/09/03/hexo-%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-文章的分类和标签"><a href="#1-文章的分类和标签" class="headerlink" title="1 文章的分类和标签"></a>1 文章的分类和标签</h1><p>分类的话就是在最上方的状态栏中加入	categories:  属性即可</p>
<p>标签的话就是在最上方的状态栏中加入	tags:  属性即可</p>
<h1 id="2图床搭建教程"><a href="#2图床搭建教程" class="headerlink" title="2图床搭建教程"></a>2图床搭建教程</h1><p>根据这个教程来即可</p>
<p><a href="https://eryinote.com/post/105">图床</a></p>
<p>踩坑 picgo这个软件双击并不是直接打开，而是到了右下角的小菜单。。。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/image-20230903113402329.png" alt="image-20230903113402329"></p>
<p>然后在typora软件中进行简单的设置即可。如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/image-20230903114440776.png" alt="image-20230903114440776"></p>
<p>至此就搞完了，其他目前也没啥需求，继续学习C++</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>c++基本语法</title>
    <url>/2023/09/02/c-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-C-程序结构"><a href="#1-C-程序结构" class="headerlink" title="1.C++程序结构"></a>1.C++程序结构</h1><h2 id="1-1-C-程序的基本组成部分"><a href="#1-1-C-程序的基本组成部分" class="headerlink" title="1.1 C++程序的基本组成部分"></a>1.1 C++程序的基本组成部分</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> favorites_num;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入0~10中你最喜欢的数字: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; favorites_num;</span><br><span class="line">    std::cout &lt;&lt; favorites_num &lt;&lt; <span class="string">&quot;也是我喜欢的数字！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标识符(identifiers)：</p>
<p>​	main favorites_num  cout cin</p>
<p>操作符(operators)：</p>
<p>​	&lt;&lt;    &gt;&gt; </p>
<p>标点(punctuation：</p>
<p>​	；}</p>
<h2 id="1-2-预处理指令-Preprocessor-Directives"><a href="#1-2-预处理指令-Preprocessor-Directives" class="headerlink" title="1.2 预处理指令(Preprocessor Directives)"></a>1.2 预处理指令(Preprocessor Directives)</h2><ul>
<li>它指示编译器在实际编译开始之前预处理信息·以#开头，不以分号(;)结尾</li>
<li>并不理解C++语法</li>
</ul>
<h2 id="1-3-注释"><a href="#1-3-注释" class="headerlink" title="1.3 注释"></a>1.3 注释</h2><p>​	跟C相同，双斜杠的单行注释和、&#x2F;**&#x2F;多行注释</p>
<h2 id="1-4-main函数"><a href="#1-4-main函数" class="headerlink" title="1.4 main函数"></a>1.4 main函数</h2><p>​	例程1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>#include &lt;iostream&gt;</code>：这是一个预处理指令，用于包含输入输出流库（iostream），以便在程序中使用输入输出功能。</li>
<li><code>using namespace std;</code>：这是一个命名空间的声明，使用了<code>std</code>命名空间。命名空间<code>std</code>包含了C++标准库的函数和对象，使我们可以直接使用其中的成员，而无需在每个标识符前添加<code>std::</code>前缀。</li>
<li><code>int main()</code>：这是程序的主函数，也是程序的入口点。在C++中，每个程序都必须有一个<code>main</code>函数作为程序的起点。</li>
<li><code>&#123;</code> 和 <code>&#125;</code>：这对花括号之间的代码块是<code>main</code>函数的主体，包含了程序要执行的代码。</li>
<li><code>cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;</code>：这是一个输出语句，使用了<code>cout</code>对象，它是标准输出流。<code>&lt;&lt;</code>是输出运算符，用于将字符串常量”hello world”输出到控制台。<code>endl</code>是一个特殊的输出控制符，表示换行。</li>
</ol>
<p>例程2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//argc表示参数数量，argc表示输入的参数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;参数数量&quot;</span> &lt;&lt; argc &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;参数名称&quot;</span> &lt;&lt; argv &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	 </p>
<h2 id="1-5-命名空间namespace"><a href="#1-5-命名空间namespace" class="headerlink" title="1.5 命名空间namespace"></a>1.5 命名空间namespace</h2><p>在C++中，命名空间是一种用来组织程序中的标识符（例如变量名、函数名、类名等）的机制。命名空间可以避免标识符之间的名称冲突，使得不同库、模块或代码段中的标识符可以拥有相同的名称而不会发生冲突。</p>
<p><code>std</code> 是C++标准库中的命名空间，包含了大量的标准函数和类型定义。例如，<code>std::cout</code> 是用于标准输出的对象，<code>std::cin</code> 是用于标准输入的对象，<code>std::string</code> 是用于处理字符串的类，<code>std::vector</code> 是用于动态数组的类等等。这些标准库的功能都封装在 <code>std</code> 命名空间中。</p>
<p>使用 <code>using namespace std;</code> 声明后，就可以在代码中直接使用 <code>std</code> 命名空间中的成员，而无需在每个标识符前添加 <code>std::</code> 前缀。例如，可以直接使用 <code>cout</code> 来表示 <code>std::cout</code>，使用 <code>endl</code> 来表示 <code>std::endl</code>，以及使用 <code>string</code> 来表示 <code>std::string</code> 等等。</p>
<p>需要注意的是，尽管 <code>using namespace std;</code> 可以简化代码，但也可能引发命名冲突问题。如果程序中使用了不同命名空间中具有相同名称的标识符，可能会导致编译错误或意想不到的行为。因此，在大型项目中或与其他库进行交互时，最好明确指定使用的命名空间，而不是使用 <code>using namespace</code> 全局声明。</p>
<h1 id="2-C-变量和常量"><a href="#2-C-变量和常量" class="headerlink" title="2. C++变量和常量"></a>2. C++变量和常量</h1><h2 id="2-1-变量-variable"><a href="#2-1-变量-variable" class="headerlink" title="2.1 变量(variable)"></a>2.1 变量(variable)</h2><p>变量是内存地址的抽象变量有2个重要的属性:<br>Type:变量类型( integer、real nurber、string、Student)<br>Value:变量值(1,3.14,”computer”)</p>
<h2 id="2-2-基本类型-primitive-types"><a href="#2-2-基本类型-primitive-types" class="headerlink" title="2.2 基本类型(primitive types)"></a>2.2 基本类型(primitive types)</h2><p>示例3：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;参数a=&quot;</span> &lt;&lt; a &lt;&lt; endl;	  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	上述示例运行打印为 a&#x3D;0，最好设置初值</p>
<p>示例4：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> width = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入房间宽度&quot;</span>;	  </span><br><span class="line">    cin &gt;&gt; width;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入房间长度&quot;</span>;	  </span><br><span class="line">    cin &gt;&gt; length;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;房间的面积为&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; width * length &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符型-character-char"><a href="#字符型-character-char" class="headerlink" title="字符型(character) : char"></a>字符型(character) : char</h3><p>作用︰用于表示单个字符，如I@’,’a’,’X’<br>只占用1个字节<br>语法:char c &#x3D;(a;<br>&#x3D;&#x3D;注意&#x3D;&#x3D;:<br>需要和字符串区分开，用单引号不是双引号<br>存储的是字符的ASCIl编码，而不是字符本身</p>
<h3 id="整型-integer-short、int、long、long-long"><a href="#整型-integer-short、int、long、long-long" class="headerlink" title="整型(integer) : short、int、long、long long"></a>整型(integer) : short、int、long、long long</h3><h3 id="浮点型-floating-point-float、double"><a href="#浮点型-floating-point-float、double" class="headerlink" title="浮点型(floating point) : float、double"></a>浮点型(floating point) : float、double</h3><h3 id="布尔型-Boolean-bool"><a href="#布尔型-Boolean-bool" class="headerlink" title="布尔型(Boolean) : bool"></a>布尔型(Boolean) : bool</h3><p>示例5</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a = &#123;<span class="string">&#x27;j&#x27;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符型参数a的值=&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符型参数a的ascll=&quot;</span> &lt;&lt; <span class="built_in">int</span>(a) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// short取值范围和溢出</span></span><br><span class="line">    <span class="type">short</span> overflow_num_1 = <span class="number">32768</span>;    <span class="comment">// 不会报错，但是值会溢出</span></span><br><span class="line">    <span class="type">short</span> overflow_num_2 &#123;<span class="number">32768</span>&#125;;    <span class="comment">// 会报错</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;短整型溢出：&quot;</span> &lt;&lt; overflow_num_1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;短整型溢出：&quot;</span> &lt;&lt; overflow_num_2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	&#x3D;&#x3D;注意&#x3D;&#x3D;:一般人们都是使用等于号进行赋值，但是对于一些超出范围的情况，编译器并不会报错，但是使用{}花括号的情况就会报错，所以建议大家之后使用花括号进行赋值.</p>
<h2 id="2-3-sizeof和climits"><a href="#2-3-sizeof和climits" class="headerlink" title="2.3 sizeof和climits"></a>2.3 sizeof和climits</h2><p>sizeof(int), &#x2F;&#x2F;确定int占用空间<br>sizeof(double), &#x2F;&#x2F;确定double占用空间<br>sizeof(变量名), &#x2F;&#x2F;确定具体某个变量占用空间<br>sizeof 变量名, &#x2F;&#x2F;不用括号</p>
<p>示例6：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a = &#123;<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符型变量a的大小为&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;整形变量b的大小为&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-4-常量-constant"><a href="#2-4-常量-constant" class="headerlink" title="2.4 常量(constant)"></a>2.4 常量(constant)</h2><p>作用:记录不可更改的数据，防止变量误修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预处理器定义</span></span><br><span class="line"><span class="comment">// 在老版本的C++中常用，现在不建议使用（预处理器不认识C++代码，不会做类型检查等工作)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pi 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const修饰方法</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> months = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pi = 3.5; 常量不可以再变更值，否则编译器会报错</span></span><br></pre></td></tr></table></figure>

<p>示例7：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> PI &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length &#123;<span class="number">10</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的面积为&quot;</span> &lt;&lt; length * length * PI &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-C-数组和容器"><a href="#3-C-数组和容器" class="headerlink" title="3. C++数组和容器"></a>3. C++数组和容器</h1><h2 id="3-1-数组"><a href="#3-1-数组" class="headerlink" title="3.1 数组"></a>3.1 数组</h2><p>·数组所有元素都是同一个数据类型。每个元素可以单独读取。</p>
<p>数组的特点：</p>
<ul>
<li>长度大小固定，且不可以再修改</li>
<li>所有元素是同一类型</li>
<li>元素在内存中是连续存储的</li>
<li>声明array时，内存中会分配一块区域来存储</li>
<li>可以使用存储的索引位置来获取元素（从0开始，最后一个元素索引为size -1)</li>
<li>不检查是否超出区域（超出长度获取元素可能会报错)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int student_scores[5] = &#123;92, 78, 100, 86, 65&#125;;  // 所有元素初始化</span><br><span class="line">int ages[10] = &#123;19, 23&#125;;                      // 前两个元素初始化对应值，其他元素为0</span><br><span class="line">const int days_in_year = 365;</span><br><span class="line">double hi_temperatures[days_in_year] = &#123;0&#125;;   // 所有元素初始化为0</span><br><span class="line">int another_array[] = &#123;1, 2, 3, 4, 5, 6&#125;;      // 数组大小自动计算</span><br></pre></td></tr></table></figure>

<p>​	数组如果只是定义，他是没有初值的最好在创建的过程中就加入初值。、只有加入一个初值，其他没赋予的值也会有，只是为0 </p>
<p>示例8：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> a[] &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[] &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a数组的第五个值为&quot;</span> &lt;&lt; a[<span class="number">4</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b数组名打印&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-容器"><a href="#3-2-容器" class="headerlink" title="3.2 容器"></a>3.2 容器</h2><p>假设需要存储整个学校所有学生的考试成绩无法知道具体的学生数量<br>解决办法:</p>
<ul>
<li><p>使用数组，数组大小设置的足够大</p>
</li>
<li><p>使用vector动态数组</p>
</li>
</ul>
<p>&#x3D;&#x3D;容器的特点&#x3D;&#x3D;：</p>
<ul>
<li><p>C++标准模板库STL中的容器(container)</p>
</li>
<li><p>长度大小可以随时缩放</p>
</li>
<li><p>和数组类似的语法用法</p>
</li>
<li><p>高性能越界检查</p>
</li>
<li><p>很多有用的函数:sort, reverrse, find等</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">vowels</span><span class="params">(<span class="number">5</span>)</span></span>;             <span class="comment">// 构造函数初始化方法，需要五个位置</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">student_scores</span><span class="params">(<span class="number">10</span>)</span></span>;     <span class="comment">// 大小为10，这10个数字会自动初始化为0</span></span><br></pre></td></tr></table></figure>

<p>赋予初值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">char</span>&gt; vowels &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; student_scores &#123;<span class="number">100</span>, <span class="number">99</span>, <span class="number">98</span>, <span class="number">97</span>, <span class="number">96</span>&#125;;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">hi_temperatures</span><span class="params">(<span class="number">365</span>, <span class="number">37.0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​	这里有些区别，第一个使用的是花括号进行的初值赋予，第二个跟第一个相同，但是第三个使用的是圆括号来进行的，第一个参数为365表示将会有365个元素，第二个参数为初始值，表示这365个元素都会被初始化为37.0</p>
<p>​	.at获取</p>
<p>​	.pushback进行追加</p>
<p>示例 9：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; vowel &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; vowel.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt;endl;</span><br><span class="line">    vowel.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; vowel.<span class="built_in">at</span>(<span class="number">5</span>) &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	需要注意的是上面的vector和&lt;类型&gt;必须连在一起，否则会报错。</p>
<p>​	容器的获取方式跟数组的获取方式相同，但也可以有更多的方式</p>
<h1 id="4-C-程序流程"><a href="#4-C-程序流程" class="headerlink" title="4. C++程序流程"></a>4. C++程序流程</h1><h2 id="4-1-if"><a href="#4-1-if" class="headerlink" title="4.1 if"></a>4.1 if</h2><p>示例 10：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lower_limit &#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> upper_limit &#123;<span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> input_num;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入一个介于&quot;</span> &lt;&lt; lower_limit &lt;&lt; <span class="string">&quot;和&quot;</span> &lt;&lt; upper_limit &lt;&lt; <span class="string">&quot;之间的整数：&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cin &gt;&gt; input_num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (input_num &gt;= lower_limit) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;===条件一满足===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; input_num &lt;&lt; <span class="string">&quot;大于等于&quot;</span> &lt;&lt; lower_limit &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; input_num &lt;&lt; <span class="string">&quot;比&quot;</span> &lt;&lt; lower_limit &lt;&lt; <span class="string">&quot;大&quot;</span> &lt;&lt; (input_num - lower_limit) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (input_num &lt;= upper_limit) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;===条件二满足===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; input_num &lt;&lt; <span class="string">&quot;小于等于&quot;</span> &lt;&lt; upper_limit &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; input_num &lt;&lt; <span class="string">&quot;比&quot;</span> &lt;&lt; upper_limit &lt;&lt; <span class="string">&quot;小&quot;</span> &lt;&lt; (upper_limit - input_num) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (input_num &gt; lower_limit &amp;&amp; input_num &lt; upper_limit) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;===条件三满足===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; input_num &lt;&lt; <span class="string">&quot;介于&quot;</span> &lt;&lt; lower_limit &lt;&lt; <span class="string">&quot;和&quot;</span> &lt;&lt; upper_limit &lt;&lt; <span class="string">&quot;之间&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-switch"><a href="#4-2-switch" class="headerlink" title="4.2 switch"></a>4.2 switch</h2><p>示例 11：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char input_grade = &#x27;0&#x27;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;请输入你的成绩：&quot;;</span><br><span class="line">    std::cin &gt;&gt; input_grade;</span><br><span class="line"></span><br><span class="line">    switch (input_grade)</span><br><span class="line">    &#123;</span><br><span class="line">        case &#x27;a&#x27;:</span><br><span class="line">        case &#x27;A&#x27;:</span><br><span class="line">            std::cout &lt;&lt; &quot;优秀&quot; &lt;&lt; std::endl;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;b&#x27;:</span><br><span class="line">        case &#x27;B&#x27;:</span><br><span class="line">            std::cout &lt;&lt; &quot;良好&quot; &lt;&lt; std::endl;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;c&#x27;:</span><br><span class="line">        case &#x27;C&#x27;:</span><br><span class="line">            std::cout &lt;&lt; &quot;中等&quot; &lt;&lt; std::endl;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-3循环-for、while、do-while"><a href="#4-3循环-for、while、do-while" class="headerlink" title="4.3循环: for、while、do-while"></a>4.3循环: for、while、do-while</h2><p>示例 11：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 简单的 for 循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次 i 增加 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面这种最简单的方式，for也支持基于范围的循环，类似于python：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> scores [ ] &#123;<span class="number">100</span>,<span class="number">99</span>,<span class="number">98</span>&#125; ;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> score: scores)</span><br><span class="line">	cout&lt;&lt; score &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>有时确定范围比较困难，所以可以使用auto这个类型，可以帮我们自动确认类型</p>
<p>while和do while就不重复了，还是很简单的</p>
<h1 id="5-C-字符和字符串"><a href="#5-C-字符和字符串" class="headerlink" title="5. C++字符和字符串"></a>5. C++字符和字符串</h1><h2 id="5-1C风格字符串"><a href="#5-1C风格字符串" class="headerlink" title="5.1C风格字符串"></a>5.1C风格字符串</h2><p>示例 12：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> first_name[<span class="number">20</span>] &#123;&#125;;</span><br><span class="line">    <span class="type">char</span> last_name[<span class="number">20</span>] &#123;&#125;;</span><br><span class="line">    <span class="type">char</span> full_name[<span class="number">50</span>] &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">50</span>] &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入你的姓：&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; first_name;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入你的名：&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; last_name;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;===============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;您的姓：&quot;</span> &lt;&lt; first_name &lt;&lt; <span class="string">&quot;，一共有&quot;</span> &lt;&lt; <span class="built_in">strlen</span>(first_name) &lt;&lt; <span class="string">&quot;个字符&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;您的名：&quot;</span> &lt;&lt; last_name &lt;&lt; <span class="string">&quot;，一共有&quot;</span> &lt;&lt; <span class="built_in">strlen</span>(last_name) &lt;&lt; <span class="string">&quot;个字符&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-2-C-风格字符串"><a href="#5-2-C-风格字符串" class="headerlink" title="5.2 C++风格字符串"></a>5.2 C++风格字符串</h2><ul>
<li><p>STL中一个类</p>
</li>
<li><p>使用前必须要导入#include <string></p>
</li>
<li><p>std namespace</p>
</li>
<li><p>内存中连续，动态大小</p>
</li>
<li><p>可转c-style字符串相互转化</p>
</li>
<li><p>更安全</p>
<p>示例 13：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string sl; <span class="comment">// 全部初始化为空</span></span><br><span class="line">    std::string s2 &#123; <span class="string">&quot;hello&quot;</span> &#125;; <span class="comment">// 初始化为 &quot;hello&quot;</span></span><br><span class="line">    std::string s3 &#123; s2 &#125;; <span class="comment">// 拷贝 s2</span></span><br><span class="line">    std::string s4 &#123; s3, <span class="number">0</span>, <span class="number">4</span> &#125;; <span class="comment">// 拷贝 s3 的前4个字符：&quot;hell&quot;</span></span><br><span class="line">    std::string s5 &#123; <span class="string">&quot;hello&quot;</span>, <span class="number">3</span> &#125;; <span class="comment">// 拷贝 &quot;hello&quot; 的前3个字符：&quot;hel&quot;</span></span><br><span class="line">    <span class="function">std::string <span class="title">s6</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>; <span class="comment">// 5个 &#x27;x&#x27;：&quot;xxxxx&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	c++字符串可以直接赋值，根据他的参数的数量可以划分不同的重定向函数</p>
<p>拼接</p>
<p>示例 14：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string part1 &#123; <span class="string">&quot;C++&quot;</span> &#125;;</span><br><span class="line">    std::string part2 &#123; <span class="string">&quot;是一门强大的&quot;</span> &#125;;</span><br><span class="line">    std::string sentence;</span><br><span class="line"></span><br><span class="line">    sentence = part1 + <span class="string">&quot; &quot;</span> + part2 + <span class="string">&quot;语言&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; sentence &lt;&lt; std::endl; <span class="comment">// 输出: C++ 是一门强大的语言</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sentence = &quot;C+++&quot; 是一门强大的语言&quot;; // 错误，不能将两个C风格字符串字面量相加</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo基本操作命令</title>
    <url>/2023/09/02/hexo%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://so.csdn.net/so/search?q=Hexo&spm=1001.2101.3001.7020">Hexo</a> 约有二十个命令，但普通用户经常使用的大概只有下列几个:</p>
<h2 id="hexo-s"><a href="#hexo-s" class="headerlink" title="hexo s"></a><strong>hexo s</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>启动本地服务器，用于预览主题。默认地址： <a href="http://localhost:4000/">http://localhost:4000/</a></p>
<ul>
<li>hexo s 是 hexo server 的缩写，命令效果一致；</li>
<li>预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；</li>
<li>对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果。</li>
</ul>
<h2 id="hexo-new"><a href="#hexo-new" class="headerlink" title="hexo new"></a><strong>hexo new</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;学习笔记  六&quot;</span><br></pre></td></tr></table></figure>

<p>新建一篇标题为 学习笔记 六 的文章，因为标题里有空格，所以加上了引号。</p>
<ul>
<li>文章标题可以在对应 md 文件里改，新建时标题可以写的简单些。</li>
</ul>
<h2 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a><strong>hexo d</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>自动生成网站静态文件，并部署到设定的仓库。</p>
<ul>
<li>hexo d 是 hexo deploy 的缩写，命令效果一致。</li>
</ul>
<h2 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a><strong>hexo clean</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p>清除缓存文件 db.json 和已生成的静态文件 public 。</p>
<ul>
<li>网站显示异常时可以执行这条命令试试。</li>
</ul>
<h2 id="hexo-g"><a href="#hexo-g" class="headerlink" title="hexo g"></a><strong>hexo g</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>生成网站静态文件到默认设置的 public 文件夹。</p>
<ul>
<li>便于查看网站生成的静态文件或者手动部署网站；</li>
<li>如果使用自动部署，不需要先执行该命令；</li>
<li>hexo g 是 hexo generate 的缩写，命令效果一致。</li>
</ul>
<h2 id="hexo-new-page"><a href="#hexo-new-page" class="headerlink" title="hexo new page"></a><strong>hexo new page</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page aboutme</span><br></pre></td></tr></table></figure>

<p>新建一个标题为 aboutme 的页面，默认链接地址为 主页地址&#x2F;aboutme&#x2F;</p>
<ul>
<li>标题可以为中文，但一般习惯用英文；</li>
<li>页面标题和文章一样可以随意修改；</li>
<li>页面不会出现在首页文章列表和归档中，也不支持设置分类和标签。</li>
</ul>
<p>hexo n “我的博客” 等价于 hexo new “我的博客” 还等价于 hexo new post “我的博客” #新建一篇文章<br>hexo p 等价于 hexo publish<br>hexo g 等价于 hexo generate<br>hexo s等价于 hexo server<br>hexo d 等价于 hexo deploy<br>hexo deploy -g 等价于 hexo deploy –generate<br>hexo generate -d等价于hexo generate –deploy</p>
<p>一般只需要四个命令，</p>
<p>hexo n 创建一个新的博客</p>
<p>hexo s 开启一个新的服务</p>
<p>hexo g 生成一个静态的网页</p>
<p>hexo d 将生成的静态网页推到服务器github</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>ayer 主题熟悉</title>
    <url>/2023/09/02/ayer-%E4%B8%BB%E9%A2%98%E7%86%9F%E6%82%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-整体介绍"><a href="#1-整体介绍" class="headerlink" title="1 整体介绍"></a>1 整体介绍</h1><p><a href="https://github.com/Shen-Yu/hexo-theme-ayer">Ayer</a> 是一个干净且优雅的 Hexo 主题，自带响应式，加载速度很快，该有的功能都有，可配置项很多，非常适合作为你的博客主题，主题内还附送了 6 张精美的高清壁纸。欢迎使用和 Star 支持，如果你在使用过程中有任何疑问或者建议，欢迎联系我！如果你的博客采用了本主题，欢迎在下面评论区留下地址~</p>
<p><a href="https://github.com/Shen-Yu/hexo-theme-ayer">Ayer</a> 在马来语中是“水”的意思，在西班牙语中是“昨天”的意思。</p>
<h1 id="2-特性"><a href="#2-特性" class="headerlink" title="2. 特性"></a>2. 特性</h1><ol>
<li>干净且优雅，文章内容美观易读</li>
<li>首页封面全屏平铺，扁平化设计，简洁又不失高大上</li>
<li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li>
<li>首页封面和文案可以任意更换，主题内附送 6 张精美高清壁纸</li>
<li>时间轴式的归档页</li>
<li>支持 <code>黑夜阅读</code> 模式</li>
<li>侧边栏可以点击显示或隐藏</li>
<li>支持文章置顶和文章打赏</li>
<li>支持文章字数和阅读时长统计</li>
<li>支持网易云音乐播放</li>
<li>支持  <code>MathJax</code> 和 <code>Katex</code> 数学公式</li>
<li>支持 <code>Mermaid</code> 流程图、状态图、时序图、甘特图</li>
<li><code>TOC</code> 目录在文章页悬浮，跳转更方便</li>
<li>集成了博客加密访问的功能</li>
<li>可设置阅读文章时做密码验证<a href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md">hexo-blog-encrypt</a></li>
<li><a href="https://valine.js.org/">Valine</a>和<a href="https://gitalk.github.io/">Gitalk</a>评论模块（推荐配合<code>leancloud</code>使用  <code>Valine</code>）</li>
<li>集成了<a href="http://busuanzi.ibruce.info/">不蒜子</a>、百度统计、Google Analytics、CNZZ 等统计功能</li>
<li>支持 Github Ribbons</li>
</ol>
<h1 id="3-主题配置"><a href="#3-主题配置" class="headerlink" title="3.主题配置"></a>3.主题配置</h1><p>以下是 ayer 主题目录下的 <code>_config.yml</code> 文件配置，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 侧边栏菜单</span><br><span class="line">menu:</span><br><span class="line">  主页: /</span><br><span class="line">  归档: /archives</span><br><span class="line">  分类: /categories</span><br><span class="line">  标签: /tags</span><br><span class="line">  摄影: http://shenyu-vip.lofter.com</span><br><span class="line">  旅行: /tags/旅行/</span><br><span class="line">  关于我: /2019/about</span><br><span class="line"></span><br><span class="line"># 站点次标题和打字动效</span><br><span class="line"># https://github.com/mattboldt/typed.js</span><br><span class="line">subtitle:</span><br><span class="line">  enable: true # 是否开启动效</span><br><span class="line">  text: 面朝大海，春暖花开 # 显示的文字</span><br><span class="line">  text2: 愿你一生努力，一生被爱 # 滚动播放，如果不需要可以留空</span><br><span class="line">  text3: 想要的都拥有，得不到的都释怀 # 最多支持三段文字</span><br><span class="line">  startDelay: 0 # 延迟时间</span><br><span class="line">  typeSpeed: 200 # 打字速度</span><br><span class="line">  loop: true # 是否循环</span><br><span class="line">  backSpeed: 100 # 回退速度</span><br><span class="line">  showCursor: true # 是否显示光标</span><br><span class="line"></span><br><span class="line"># 网站图标和侧边栏logo</span><br><span class="line">favicon: /favicon.ico</span><br><span class="line">logo: /images/ayer-side.svg</span><br><span class="line"></span><br><span class="line"># 封面配置</span><br><span class="line"># enable-是否启用封面；path-封面背景图；logo-封面logo</span><br><span class="line">cover:</span><br><span class="line">  enable: true</span><br><span class="line">  path: /images/cover1.jpg # /source/images目录下附送多张精美壁纸，可任意更换</span><br><span class="line">  logo: /images/ayer.svg # 如果不要直接设置成false</span><br><span class="line"></span><br><span class="line"># 页面顶部进度条</span><br><span class="line">progressBar: true</span><br><span class="line"></span><br><span class="line"># 告示板模块</span><br><span class="line">broadcast:</span><br><span class="line">  enable: true # true开启，false关闭</span><br><span class="line">  type: 2 # 1：自定义输入，2：一言api(https://hitokoto.cn/)</span><br><span class="line">  text: 一个安静优雅的hexo主题，快速且响应式。 # type为1时有效</span><br><span class="line"></span><br><span class="line"># 文章配置</span><br><span class="line"># 文章太长，截断按钮文字(在需要截断的行增加此标记：&lt;!--more--&gt;)</span><br><span class="line">excerpt_link: 阅读更多...</span><br><span class="line"># 如果你嫌每篇文章手动加more标记比较麻烦，又不想在首页全文显示，可以把excerpt_all设置成true，这样首页只会显示文章归档</span><br><span class="line">excerpt_all: false</span><br><span class="line"></span><br><span class="line"># 是否开启代码复制按钮</span><br><span class="line">copy_btn: true</span><br><span class="line"># 是否开启文章分享按钮</span><br><span class="line">share_enable: true</span><br><span class="line"># 国内的社交平台(If you are not in China, maybe you prefer to set:false)</span><br><span class="line">share_china: true</span><br><span class="line"># 文章分享文字</span><br><span class="line">share_text: 分享</span><br><span class="line"></span><br><span class="line"># 分页文字</span><br><span class="line">nav_text:</span><br><span class="line">  page_prev: 上一页</span><br><span class="line">  page_next: 下一页</span><br><span class="line">  post_prev: 上一篇</span><br><span class="line">  post_next: 下一篇</span><br><span class="line"></span><br><span class="line"># 文章页是否显示目录</span><br><span class="line">toc: true</span><br><span class="line"></span><br><span class="line"># 文章中的图片是否支持点击放大</span><br><span class="line">image_viewer: true</span><br><span class="line"></span><br><span class="line"># https://github.com/willin/hexo-wordcount</span><br><span class="line"># 是否开启字数统计(关闭请设置enable为false)</span><br><span class="line"># 也可以单独在md文件里Front-matter设置`no_word_count: true`属性，来自定义关闭字数统计</span><br><span class="line">word_count:</span><br><span class="line">  enable: true</span><br><span class="line">  # 只在文章详情显示(不在首页显示)</span><br><span class="line">  only_article_visit: true</span><br><span class="line"></span><br><span class="line"># 打赏</span><br><span class="line"># 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-默认开启所有文章均有打赏，如果有些文章你不需要，请在文章对应的md文件里设置no_reward:true</span><br><span class="line">reward_type: 2</span><br><span class="line"># 打赏wording</span><br><span class="line">reward_wording: &quot;请我喝杯咖啡吧~&quot;</span><br><span class="line"># 支付宝二维码图片地址，跟你设置logo的方式一样。比如：/images/alipay.jpg</span><br><span class="line">alipay: /images/alipay.jpg</span><br><span class="line"># 微信二维码图片地址</span><br><span class="line">weixin: /images/wechat.jpg</span><br><span class="line"></span><br><span class="line"># 版权声明</span><br><span class="line"># 版权声明type设定：0-关闭版权声明； 1-文章对应的md文件里有copyright: true属性，才有版权声明； 2-所有文章均有版权声明</span><br><span class="line">copyright_type: 2</span><br><span class="line"></span><br><span class="line"># 是否启用搜索</span><br><span class="line">search: true</span><br><span class="line"></span><br><span class="line"># RSS订阅(先安装hexo-generator-feed插件，再去博客根目录config进行配置)</span><br><span class="line"># 不想显示可以直接留空</span><br><span class="line">rss: /atom.xml</span><br><span class="line"></span><br><span class="line"># 是否启用黑夜模式开关</span><br><span class="line">darkmode: true</span><br><span class="line"></span><br><span class="line"># 动态背景效果: 0-关闭，1-动态线条(跟随鼠标)</span><br><span class="line">canvas_bg: 0</span><br><span class="line"></span><br><span class="line"># 自定义鼠标样式，直接替换/images/mouse.cur文件</span><br><span class="line">mouse:</span><br><span class="line">  enable: false</span><br><span class="line">  path: /images/mouse.cur</span><br><span class="line"></span><br><span class="line"># 鼠标点击效果：0-关闭，1-爱心，2-爆炸烟花，3-粒子烟花</span><br><span class="line">click_effect: 0</span><br><span class="line"></span><br><span class="line"># 页面宽度自定义（不建议修改，可能造成布局混乱），article_width文章宽度，sidebar_width侧边栏宽度</span><br><span class="line">layout:</span><br><span class="line">  article_width: 80rem</span><br><span class="line">  sidebar_width: 8rem</span><br><span class="line"></span><br><span class="line"># GitHub Ribbons-封面右上角的forkme，换样式直接在source/images目录下替换forkme图片</span><br><span class="line">github:</span><br><span class="line">  # (关闭请设置为false)</span><br><span class="line">  enable: true</span><br><span class="line">  url: https://github.com/Shen-Yu/hexo-theme-ayer</span><br><span class="line"></span><br><span class="line"># 网易云音乐插件</span><br><span class="line">music:</span><br><span class="line">  enable: false</span><br><span class="line">  # 播放器尺寸类型(1：小尺寸、2：大尺寸)</span><br><span class="line">  type: 1</span><br><span class="line">  id: 22707008 # 网易云分享的音乐ID(更换音乐请更改此配置项)</span><br><span class="line">  autoPlay: true # 是否开启自动播放</span><br><span class="line"></span><br><span class="line"># 访问量统计(不蒜子)</span><br><span class="line">busuanzi:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line"># 友盟cnzz统计(url填js代码src链接)</span><br><span class="line">cnzz:</span><br><span class="line">  enable: true</span><br><span class="line">  url: #</span><br><span class="line"></span><br><span class="line"># Google Analytics</span><br><span class="line">google_analytics: &quot;&quot;</span><br><span class="line"># 百度统计</span><br><span class="line">baidu_analytics: &quot;&quot;</span><br><span class="line"></span><br><span class="line"># Mathjax数学公式</span><br><span class="line">mathjax: true</span><br><span class="line"></span><br><span class="line"># Katex数学公式(allpost设置为false时只有头部设置math:true的文章才开启)</span><br><span class="line"># 需要更换hexo渲染器，npm un hexo-renderer-marked -S &amp;&amp; npm i hexo-renderer-markdown-it-katex -S</span><br><span class="line">katex:</span><br><span class="line">  enable: false # true</span><br><span class="line">  allpost: true</span><br><span class="line">  copy_tex: false</span><br><span class="line"></span><br><span class="line"># mermaid流程图 三个选项缺一不可(https://mermaid-js.github.io/mermaid/#/)</span><br><span class="line">mermaid:</span><br><span class="line">  enable: false</span><br><span class="line">  cdn: https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js</span><br><span class="line">  theme: forest</span><br><span class="line"></span><br><span class="line"># 网站成立年份(默认为 2019，若填入年份小于当前年份，则显示为 2018-2019 类似的格式)</span><br><span class="line">since: 2019</span><br><span class="line"></span><br><span class="line"># ICP备案信息尾部显示</span><br><span class="line">icp:</span><br><span class="line">  enable: false</span><br><span class="line">  url: &quot;http://www.beian.miit.gov.cn/&quot; # 备案链接</span><br><span class="line">  text: &quot;浙ICP备88888888&quot; # 备案信息</span><br><span class="line"># 公安备案信息尾部显示</span><br><span class="line">gongan:</span><br><span class="line">  enable: true</span><br><span class="line">  img: /images/beian.png #公安备案图片</span><br><span class="line">  url: &quot;http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=01234567890123&quot; #公安备案链接</span><br><span class="line">  text: &quot;浙公网安备01234567890123号&quot; #公安备案信息</span><br><span class="line"></span><br><span class="line"># 友情链接</span><br><span class="line">friends_link:</span><br><span class="line">  Ayer主题: #网站名称</span><br><span class="line">    #网站地址</span><br><span class="line">    url: https://github.com/Shen-Yu/hexo-theme-ayer</span><br><span class="line">    #网站图片(可忽略不写)</span><br><span class="line">    img: /images/ayer.png</span><br><span class="line">  GitHub:</span><br><span class="line">    url: https://github.com/Shen-Yu</span><br><span class="line">    img: https://i.loli.net/2020/09/07/indb4PRYDA98EkN.png</span><br><span class="line">  码云:</span><br><span class="line">    url: https://gitee.com/shen-yu</span><br><span class="line">    img: https://i.loli.net/2020/09/07/K3AqO7h6krQFlRX.png</span><br><span class="line">  Hexo官网:</span><br><span class="line">    url: https://hexo.io</span><br><span class="line">    img: https://i.loli.net/2020/09/07/UYGzjo7h68CRWny.png</span><br><span class="line">  Hexo图表插件:</span><br><span class="line">    url: https://github.com/Shen-Yu/hexo-tag-chart</span><br><span class="line">    img: https://i.loli.net/2020/09/07/GIXBYE5SoylhR1r.png</span><br><span class="line"></span><br><span class="line"># 评论：1、Valine(推荐)；2、Gitalk；3、Twikoo; 4.MiniValine</span><br><span class="line"></span><br><span class="line"># 1、Valine[一款快速、简洁且高效的无后端评论系统](https://github.com/xCss/Valine)</span><br><span class="line"># 启用Valine必须先创建leancloud应用， 获取 id|key 填入即可</span><br><span class="line">leancloud:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: #</span><br><span class="line">  app_key: #</span><br><span class="line"># Valine配置</span><br><span class="line">valine:</span><br><span class="line">  enable: true # 是否启用</span><br><span class="line">  avatar: monsterid # 头像样式(https://valine.js.org/avatar.html)</span><br><span class="line">  placeholder: 给我的文章加点评论吧~ # placeholder</span><br><span class="line"></span><br><span class="line"># 2、Gitalk(https://github.com/gitalk/gitalk)</span><br><span class="line">gitalk:</span><br><span class="line">  enable: false # true</span><br><span class="line">  clientID: # GitHub Application Client ID</span><br><span class="line">  clientSecret: # Client Secret</span><br><span class="line">  repo: # Repository name</span><br><span class="line">  owner: # GitHub ID</span><br><span class="line">  admin: # GitHub ID</span><br><span class="line"></span><br><span class="line"># 3、Twikoo(https://github.com/imaegoo/twikoo)</span><br><span class="line">twikoo:</span><br><span class="line">  enable: false</span><br><span class="line">  envId: #</span><br><span class="line"></span><br><span class="line"># 4、MiniValine</span><br><span class="line"># See: https://github.com/MiniValine/MiniValine</span><br><span class="line">minivaline:</span><br><span class="line">  enable: false</span><br><span class="line">  serverURL: https://minivaline.your-domain.com</span><br><span class="line"></span><br><span class="line"># 首页广告配置</span><br><span class="line"># 可以根据需要自行增加ad_3，ad_4...，留空则不显示</span><br><span class="line">ads:</span><br><span class="line">  ad_1:</span><br><span class="line">    title: vultr优惠vps</span><br><span class="line">    img: https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/vultr.png</span><br><span class="line">    url: https://www.vultr.com/?ref=8630075</span><br><span class="line">    width: 300</span><br><span class="line">  ad_2:</span><br><span class="line">    title: 云服务器全球购低至2折</span><br><span class="line">    img: https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/ad_2.jpg</span><br><span class="line">    url: https://curl.qcloud.com/kvO7hb43</span><br><span class="line">    width: 300</span><br><span class="line"></span><br><span class="line"># 网站开启加密访问，密码可设置任何字符</span><br><span class="line">lock:</span><br><span class="line">  enable: false</span><br><span class="line">  password: 123456</span><br></pre></td></tr></table></figure>

<h2 id="4-插件-可选"><a href="#4-插件-可选" class="headerlink" title="4 插件(可选)"></a>4 插件(可选)</h2><ul>
<li><a href="https://github.com/netcan/hexo-generator-index-pin-top">hexo-generator-index-pin-top</a> 用于文章置顶</li>
<li><a href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md">hexo-blog-encrypt</a> 用于文章加密</li>
<li><a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md">hexo-tag-aplayer</a> 用于播放音乐</li>
<li><a href="https://github.com/MoePlayer/hexo-tag-dplayer">hexo-tag-dplayer</a> 用于播放视频</li>
<li><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md">hexo-helper-live2d</a> 二次元看板娘</li>
</ul>
<h2 id="5-分类"><a href="#5-分类" class="headerlink" title="5.分类"></a>5.分类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>然后将以下复制到 &#x2F;source&#x2F;categories&#x2F;index.md 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="6-标签"><a href="#6-标签" class="headerlink" title="6.标签"></a>6.标签</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>配置同分类一样</p>
<h2 id="7-友情链接"><a href="#7-友情链接" class="headerlink" title="7. 友情链接"></a>7. 友情链接</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page friends</span><br></pre></td></tr></table></figure>

<p>然后将以下复制到 &#x2F;source&#x2F;friends&#x2F;index.md 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: friends</span><br><span class="line">type: friends</span><br><span class="line">layout: &quot;friends&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>然后在 ayer 主题目录下的 <code>_config.yml</code> 中自定义 <code>friends_link</code> 配置项即可</p>
<h2 id="8-相册"><a href="#8-相册" class="headerlink" title="8.相册"></a>8.相册</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page photos</span><br></pre></td></tr></table></figure>

<p>然后将以下复制到 &#x2F;source&#x2F;photos&#x2F;index.md 文件，<code>img_url</code> 替换成图片路径，<code>caption</code> 替换成图片名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Gallery</span><br><span class="line"></span><br><span class="line">albums: [[&quot;img_url&quot;, &quot;img_caption&quot;], [&quot;img_url&quot;, &quot;img_caption&quot;]]</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h2><p>用 Tocbot 解析文章标题并生成目录</p>
<ul>
<li>将以下配置复制到你 ayer 主题目录下的 <code>_config.yml</code> 里：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Toc</span><br><span class="line">toc: true</span><br></pre></td></tr></table></figure>

<ul>
<li>当然你可能并不想所有文章都生成悬浮目录，你可以在文章顶部的配置中加一行来进行关闭：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">no_toc: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ 环境搭建</title>
    <url>/2023/09/02/c-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-课程所需运行环境配置"><a href="#1-课程所需运行环境配置" class="headerlink" title="1 课程所需运行环境配置"></a>1 课程所需运行环境配置</h1><p>​		ubuntu + windows双系统 4070ti 13900K 32G </p>
<h1 id="2-VS-Code配置"><a href="#2-VS-Code配置" class="headerlink" title="2 VS Code配置"></a>2 VS Code配置</h1><h2 id="2-1-安装vscode"><a href="#2-1-安装vscode" class="headerlink" title="2.1 安装vscode"></a>2.1 安装vscode</h2><h2 id="2-2-安装插件"><a href="#2-2-安装插件" class="headerlink" title="2.2 安装插件"></a>2.2 安装插件</h2><ol>
<li>chinese</li>
<li>remote ssh</li>
<li>c++</li>
<li>python</li>
<li>tabnine  github.copilot</li>
<li>run</li>
<li>C&#x2F;C++ Extension Pack</li>
</ol>
<h1 id="3-下载MinGw编译器"><a href="#3-下载MinGw编译器" class="headerlink" title="3 下载MinGw编译器"></a>3 下载MinGw编译器</h1><p><a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/">MinGw官网</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/545908287">知乎配置教程</a></p>
<h2 id="4-配置C-C"><a href="#4-配置C-C" class="headerlink" title="4.配置C\C++"></a>4.配置C\C++</h2><p>重启vscode就好了</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown 语法学习</title>
    <url>/2023/09/02/markdown-%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第1节-标题"><a href="#第1节-标题" class="headerlink" title="第1节 标题"></a>第1节 标题</h1><p>markdown 里面总共有六级标题，可以使用#号的多少来来引用，现在使用的是typora也可以直接使用ctrl+1-6的快捷按键来进行设置</p>
<h1 id="第2节-列表"><a href="#第2节-列表" class="headerlink" title="第2节 列表"></a>第2节 列表</h1><h2 id="2-1-有序列表"><a href="#2-1-有序列表" class="headerlink" title="2.1 有序列表"></a>2.1 有序列表</h2><p>​	顾名思义，有序列表就是有小标号的列表，同样也是两种方式英⽂输⼊法下，数字后⾯加⼀点，然后空格即可，或者使用快捷按键ctrl + shift + [即可</p>
<p>1. </p>
<p>1. </p>
<h2 id="2-2-无序列表"><a href="#2-2-无序列表" class="headerlink" title="2.2 无序列表"></a>2.2 无序列表</h2><p>​	跟上面的有序列表相反，无序列表就是没有标号，有四种方法、</p>
<ul>
<li>aaa - aaa</li>
</ul>
<ul>
<li>aaa + aaa</li>
</ul>
<ul>
<li>aaa *aaa</li>
</ul>
<ul>
<li>aaa ctrl+shift+]</li>
</ul>
<h1 id="第3节-字体标记"><a href="#第3节-字体标记" class="headerlink" title="第3节 字体标记"></a>第3节 字体标记</h1><h2 id="3-1-加粗"><a href="#3-1-加粗" class="headerlink" title="3.1 加粗"></a>3.1 加粗</h2><p><strong>加粗</strong> **   内容**在typora中可以使用ctrl+b</p>
<h2 id="3-2-删除"><a href="#3-2-删除" class="headerlink" title="3.2 删除"></a>3.2 删除</h2><p><del>删除</del> ~~ 内容~~</p>
<h2 id="3-3-斜体"><a href="#3-3-斜体" class="headerlink" title="3.3 斜体"></a>3.3 斜体</h2><p><em>斜体</em> * 内容 *</p>
<h2 id="3-4-高亮"><a href="#3-4-高亮" class="headerlink" title="3.4 高亮"></a>3.4 高亮</h2><p>&#x3D;&#x3D;高亮&#x3D;&#x3D; &#x3D;&#x3D;内容  &#x3D;&#x3D;需要打开pytora的高亮功能之后才行</p>
<h1 id="第4节-段落相关"><a href="#第4节-段落相关" class="headerlink" title="第4节 段落相关"></a>第4节 段落相关</h1><h2 id="4-1-引用"><a href="#4-1-引用" class="headerlink" title="4.1 引用"></a>4.1 引用</h2><blockquote>
<p>这是一段引用 &gt; 大于号加内容引用</p>
</blockquote>
<h2 id="4-2-分割线"><a href="#4-2-分割线" class="headerlink" title="4.2 分割线"></a>4.2 分割线</h2><hr>
<p>三个横杠或者更多的横杠表示分割线</p>
<h1 id="第5节-代码"><a href="#第5节-代码" class="headerlink" title="第5节 代码"></a>第5节 代码</h1><h2 id="5-1-行内代码"><a href="#5-1-行内代码" class="headerlink" title="5.1 行内代码"></a>5.1 行内代码</h2><p><code>这是一个行内代码</code> 1旁边那个特殊按键</p>
<h2 id="5-2-代码块"><a href="#5-2-代码块" class="headerlink" title="5.2 代码块"></a>5.2 代码块</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    三个```然后回车即可，然后在右下角的选择框中进行代码的选择</span><br></pre></td></tr></table></figure>



<h1 id="第6节-超链接"><a href="#第6节-超链接" class="headerlink" title="第6节 超链接"></a>第6节 超链接</h1><blockquote>
<p>格式 ：[⽹址标题] [变量01]</p>
</blockquote>
<p><a href="www.baidu.com">百度</a></p>
<ul>
<li><p>在⽂稿起草阶段，还没确定具体⽹址，但可以先给出⽹址标题</p>
</li>
<li><p>同⼀篇⽂章需要重复出现同⼀个⽹址时</p>
</li>
</ul>
<h1 id="第7节-脚注"><a href="#第7节-脚注" class="headerlink" title="第7节 脚注"></a>第7节 脚注</h1><p>这是一个脚注<a href="%E8%BF%99%E4%B8%AA%E6%98%AF%E6%94%BE%E5%9C%A8%E6%96%87%E7%AB%A0%E5%B0%BE%E9%83%A8%E7%9A%84%EF%BC%8C%E7%94%A8%E4%BA%8E%E6%89%BF%E6%8E%A5%E4%B8%8A%E9%9D%A2%E7%9A%84%E8%84%9A%E6%B3%A8">^01</a></p>
<h1 id="第8节-图片"><a href="#第8节-图片" class="headerlink" title="第8节 图片"></a>第8节 图片</h1><p><img src="/"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本格式：![](图⽚链接)</span><br></pre></td></tr></table></figure>

<p><img src="D:\hexo\blog\source_posts\image-20230902075316489.png" alt="image-20230902075316489"></p>
<p>图⽚链接可以是本地链接，也可以是在线链接</p>
<p>但这个图片是本地路径，很有问题，所以你可能需要一个图床，用来无视地点，目前先不学呢，具体链接如下所示：</p>
<p><a href="https://eryinote.com/post/105">图床搭建教程</a></p>
<h1 id="第9节-表格"><a href="#第9节-表格" class="headerlink" title="第9节 表格"></a>第9节 表格</h1><p>在typora中可以使用快捷按键进行表格的创建  ctrl+t</p>
<p>通用的语法为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| 表头 | 表头 |</span><br><span class="line">| ---- | ---- |</span><br><span class="line">| 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>typora简单使用</title>
    <url>/2023/09/01/%E4%BB%80%E4%B9%88%E6%98%AFmarkdown/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>MarkDown是什么<br>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p>
<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>
<p>Markdown 编写的文档后缀为 .md, .markdown。</p>
<h1 id="1-如何自动生成目录"><a href="#1-如何自动生成目录" class="headerlink" title="1.如何自动生成目录"></a>1.如何自动生成目录</h1><p>点击【视图】——【大纲】</p>
<p>说明：但是此步骤生成的目录，并不是折叠的目录，折叠起来会更美观一些</p>
<p>设置折叠目录</p>
<p>点击【文件】——【偏好设置】——【外观】——侧边栏选择打钩，此时已经折叠成功</p>
<h1 id="2-快捷键"><a href="#2-快捷键" class="headerlink" title="2.快捷键"></a>2.快捷键</h1><p> Ctrl+1 ——设置一级标题</p>
<p>Ctrl+2 ——设置二级标题</p>
<p>Ctrl+3 ——设置三级标题</p>
<p>Ctrl+4 ——设置四级标题</p>
<p>Ctrl+5 ——设置五级标题</p>
<p>Ctrl+6 ——设置六级标题</p>
<p>空格 ——引用</p>
<p>回车、shift + tab ——退出引用</p>
<p>Ctrl + Shift + ] ——无序列表</p>
<p>Ctrl + Shift + [ ——有序列</p>
<p>Ctrl + Shift + ] 、tab——子列表</p>
<p>Shift + tab ——返回上一级列表、</p>
<p>Ctrl + B —— 加粗</p>
<p>Ctrl + T —— 表格</p>
<p>~ ~ 要删除的内容 ~ ~ ——删除线</p>
<h1 id="3-创建链接"><a href="#3-创建链接" class="headerlink" title="3.创建链接"></a>3.创建链接</h1><p>格式为[] ()，其中[]内为要展示的内容，()为链接。</p>
<h1 id="4-图片路径管理"><a href="#4-图片路径管理" class="headerlink" title="4.图片路径管理"></a>4.图片路径管理</h1><p>Typora默认将所有文档的图片都放在一起，但是我们更想每一个文档都有属于自己的一个文件夹，文档中的图片也最好可以自动保存在该文件夹内。解决方法如下：</p>
<p>点击【文件】——【偏好设置】——【图像】——将该界面内容设置如下:</p>
<p> 此时，该文档所在文件夹中会自动生成一个img文件，该路径为本文档中的图片路径。</p>
<p><img src="D:\hexo\blog\source_posts\image-20230902072149501.png"></p>
<h1 id="5-划重点–高亮"><a href="#5-划重点–高亮" class="headerlink" title="5.划重点–高亮"></a>5.划重点–高亮</h1><p>高亮</p>
<p>点击【文件】——【偏好设置】——【Markdown】——高亮处打钩</p>
<p>编辑高亮内容格式如下：</p>
<p>&#x3D;&#x3D; 内容&#x3D;&#x3D; —— 高亮</p>
<p>&#x3D;&#x3D; chai&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;cccc&#x3D;&#x3D; </p>
<p>&#x3D;&#x3D; key&#x3D;&#x3D;</p>
<p> &#x3D;&#x3D;内容&#x3D;&#x3D; </p>
<p><strong>cha</strong></p>
<p>重启Typora，此时内容处会变成高亮的效果.</p>
<h1 id="6-导入代码块"><a href="#6-导入代码块" class="headerlink" title="6.导入代码块"></a>6.导入代码块</h1><p><strong>~~~</strong> ——代码块，点击代码框可选择语言</p>
<h1 id="7-不使用自动拼写检查"><a href="#7-不使用自动拼写检查" class="headerlink" title="7.不使用自动拼写检查"></a>7.不使用自动拼写检查</h1><p>点击右下角[【Spell Check】勾选【不使用拼写检查】</p>
<h1 id="8设置自动保存"><a href="#8设置自动保存" class="headerlink" title="8设置自动保存"></a>8设置自动保存</h1><p>其实Typora 对文件修改之后并不能自动保存，解决方法：</p>
<p>点击【文件】——【偏好设置】——【通用】——自动保存处打钩</p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
