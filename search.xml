<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>6.21 指针函数与函数指针</title>
    <url>/2023/09/08/6-21-%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="21-1-函数指针"><a href="#21-1-函数指针" class="headerlink" title="21.1 函数指针"></a>21.1 函数指针</h1><p>函数指针的使用示例可以如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*FuncPtr)</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is function 1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is function 2\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 声明函数指针变量</span></span><br><span class="line">    FuncPtr fp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化函数指针变量</span></span><br><span class="line">    fp = func1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数指针调用函数1</span></span><br><span class="line">    (*fp)(); <span class="comment">// 或者可以简化为 fp();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改函数指针变量的值</span></span><br><span class="line">    fp = func2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数指针调用函数2</span></span><br><span class="line">    (*fp)(); <span class="comment">// 或者可以简化为 fp();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们首先定义了一个函数指针类型 <code>FuncPtr</code>，它可以指向返回类型为 <code>int</code> 的函数。然后，我们定义了两个函数 <code>func1</code> 和 <code>func2</code>，它们都符合函数指针类型 <code>FuncPtr</code> 的定义。</p>
<p>在 <code>main</code> 函数中，我们声明了一个函数指针变量 <code>fp</code>，并将其初始化为指向 <code>func1</code>。然后，我们使用函数指针调用函数1，即 <code>(*fp)();</code> 或者简化为 <code>fp();</code>。接着，我们将函数指针变量 <code>fp</code> 修改为指向 <code>func2</code>，并再次使用函数指针调用函数2。</p>
<p>通过函数指针，我们可以动态地选择、切换和调用不同的函数，以实现更灵活的程序控制和功能。</p>
<h1 id="21-2-函数名本质"><a href="#21-2-函数名本质" class="headerlink" title="21.2 函数名本质"></a>21.2 函数名本质</h1><p>函数名本质上是指向函数的指针，它表示函数的入口地址。</p>
<p>在C语言中，函数名可以被视为函数的指针常量，它存储了函数代码的起始地址。通过函数名，我们可以直接访问和调用函数。</p>
<p>当我们使用函数名时，它会被自动转换为函数指针，指向函数代码的起始地址。因此，我们可以将函数名赋值给函数指针变量，或者直接通过函数名调用函数。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 函数指针变量</span></span><br><span class="line">    <span class="type">void</span> (*functionPtr)();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将函数名赋值给函数指针变量</span></span><br><span class="line">    functionPtr = myFunction;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">    functionPtr();  <span class="comment">// 或者可以简化为 (*functionPtr)();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个函数 <code>myFunction</code>，它不带任何参数，并打印一条消息。在 <code>main</code> 函数中，我们声明了一个函数指针变量 <code>functionPtr</code>，它指向无参数且无返回值的函数。</p>
<p>然后，我们将函数名 <code>myFunction</code> 赋值给函数指针变量 <code>functionPtr</code>。通过函数指针调用函数时，我们可以使用 <code>functionPtr()</code> 或者 <code>(*functionPtr)()</code> 的语法来调用函数。</p>
<p>因此，函数名本质上是指向函数代码起始地址的指针，它提供了一种方便的方式来访问和调用函数。</p>
<p>我们有以下代码段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int func(int a, int b);</span><br><span class="line">int (*fp) = func;</span><br><span class="line">(***fp)(1, 2);</span><br></pre></td></tr></table></figure>

<ol>
<li><code>int func(int a, int b);</code> 定义了一个名为 <code>func</code> 的函数，接受两个 <code>int</code> 类型的参数并返回 <code>int</code> 类型的值。</li>
<li><code>int (*fp) = func;</code> 声明了一个函数指针变量 <code>fp</code>，它指向具有相同参数和返回值类型的函数 <code>func</code>。在这里，<code>func</code> 函数名被隐式转换为函数指针，即 <code>&amp;func</code>，并将其赋值给函数指针变量 <code>fp</code>。</li>
<li><code>(***fp)(1, 2);</code> 使用三次间接访问运算符 <code>*</code>，间接调用了函数 <code>func</code>。这是因为 <code>fp</code> 是一个函数指针，所以我们需要通过解引用运算符来调用它所指向的函数。这里使用三个间接访问运算符是因为 <code>fp</code> 是一个指向函数指针的指针的指针。参数 <code>(1, 2)</code> 传递给函数 <code>func</code>。</li>
<li><code>fp</code> 表示函数指针变量 <code>fp</code>，它可以被用于调用函数或者传递给其他函数进行使用。</li>
</ol>
<h1 id="22-3-指针函数"><a href="#22-3-指针函数" class="headerlink" title="22.3 指针函数"></a>22.3 指针函数</h1><p>指针函数（Pointer to Function）是一个函数，其返回值是一个指针。指针函数可以像普通函数一样执行特定的操作，但其返回值是一个指针类型，指向某个数据类型的内存地址。指针函数的返回值可以用于动态分配内存、返回数组、链表等数据结构。</p>
<p><code>int * func(int a, int b);</code> 是一个指针函数的声明。</p>
<p>该声明表示 <code>func</code> 是一个函数，它接受两个 <code>int</code> 类型的参数 <code>a</code> 和 <code>b</code>，并返回一个 <code>int</code> 类型的指针。</p>
<p>在函数声明中，<code>*</code> 出现在函数名 <code>func</code> 前面，表示函数的返回值是一个指针。在这个例子中，返回值类型是 <code>int *</code>，即指向整型数据的指针。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.19 二级指针：指针数组传参</title>
    <url>/2023/09/08/6-19-%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%EF%BC%9A%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数组作为函数参数时<br>一维数组:数组名隐式转换为首元素地址——一级指针<br>指针数组:首元素地址，即指针的地址———二级指针</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309092019961.png" alt="image-20230909165453909"></p>
<p>对于给定的实参和形参类型，以下是它们之间的匹配关系：</p>
<ol>
<li><p><code>int a[5]</code> 匹配 <code>int a[]</code> 或 <code>int *p</code>：<br>实参是一个具有5个整型元素的数组。在函数调用时，可以匹配形参为可变长度的数组（省略数组大小）或指针类型的形参。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void f(int a[], int len) &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">````c</span><br><span class="line">void f(int *p, int len) &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>int *a[5]</code> 匹配 <code>int **p</code> 或 <code>int *a[]</code>：<br>实参是一个具有5个整型指针元素的数组。在函数调用时，可以匹配形参为指向指针的指针（二级指针）或指针数组类型的形参。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void f(int **p) &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">````c</span><br><span class="line">void f(int *a[]) &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>int (*p)[5]</code> 匹配 <code>int (*p)[5]</code>：<br>实参是一个指向具有5个整型元素的数组的指针。在函数调用时，可以匹配形参为指向具有5个整型元素的数组的指针类型的形参。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void f(int (*p)[5]) &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>int a[4][5]</code> 匹配 <code>int (*p)[5]</code>：<br>实参是一个具有4行5列的二维整型数组。在函数调用时，可以匹配形参为指向具有5个整型元素的数组的指针类型的形参。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void f(int (*p)[5]) &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.18 二级指针：修改指针变量</title>
    <url>/2023/09/08/6-18-%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%EF%BC%9A%E4%BF%AE%E6%94%B9%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="18-1-二级指针示例："><a href="#18-1-二级指针示例：" class="headerlink" title="18.1 二级指针示例："></a>18.1 二级指针示例：</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;a;</span><br><span class="line">    <span class="type">int</span> **pp = &amp;p;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a: %d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p: %d\n&quot;</span>, *p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**pp: %d\n&quot;</span>, **pp);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a: %p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;p: %p\n&quot;</span>, &amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;pp: %p\n&quot;</span>, &amp;pp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p: %p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pp: %p\n&quot;</span>, pp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="18-2-修改指针变量值"><a href="#18-2-修改指针变量值" class="headerlink" title="18.2 修改指针变量值"></a>18.2 修改指针变量值</h1><p>二级指针可以用于修改指针变量的值。通过将一个指针变量的地址传递给二级指针，可以通过二级指针来修改指针变量的值。这在某些情况下可以方便地在函数内部修改指针变量的指向。</p>
<p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void updatePointer(int **ptr) &#123;</span><br><span class="line">    int newValue = 20;</span><br><span class="line">    *ptr = &amp;newValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    int value = 10;</span><br><span class="line">    int *ptr = &amp;value;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Before update: %d\n&quot;, *ptr);</span><br><span class="line">    updatePointer(&amp;ptr);</span><br><span class="line">    printf(&quot;After update: %d\n&quot;, *ptr);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line">在上面的示例中，`updatePointer` 函数接收一个二级指针 `ptr`，并将其指向的一级指针指向一个新的整型变量。在 `main` 函数中，我们将指针变量 `ptr` 的地址传递给 `updatePointer` 函数，并打印了更新后的指针变量的值。</span><br></pre></td></tr></table></figure>

<h1 id="18-3-指针数组传参："><a href="#18-3-指针数组传参：" class="headerlink" title="18.3 指针数组传参："></a>18.3 指针数组传参：</h1><p>二级指针也常用于指针数组（数组中的每个元素都是指针）的传参。通过二级指针，可以传递指针数组的地址，从而在函数内部操作指针数组的元素。</p>
<p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void printStrings(char **arr, int size) &#123;</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    char *strings[] = &#123;&quot;Hello&quot;, &quot;World&quot;, &quot;C&quot;, &quot;Programming&quot;&#125;;</span><br><span class="line">    int size = sizeof(strings) / sizeof(strings[0]);</span><br><span class="line"></span><br><span class="line">    printStrings(strings, size);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line">在上面的示例中，`printStrings` 函数接收一个二级指针 `arr` 和数组的大小，然后在循环中打印指针数组中的字符串。在 `main` 函数中，我们定义了一个指针数组 `strings`，并通过传递数组名和大小来调用 `printStrings` 函数。</span><br></pre></td></tr></table></figure>

<p>二级指针可以提供更高级的灵活性，允许在函数间传递和修改指</p>
<p>二级指针:指针数组</p>
]]></content>
  </entry>
  <entry>
    <title>6.17 指针与结构体</title>
    <url>/2023/09/08/6-17-%E6%8C%87%E9%92%88%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="17-1-指针和结构体之间的相关运算符："><a href="#17-1-指针和结构体之间的相关运算符：" class="headerlink" title="17.1 指针和结构体之间的相关运算符："></a>17.1 指针和结构体之间的相关运算符：</h1><ol>
<li><p>成员访问运算符（<code>.</code>）：<br>成员访问运算符用于从结构体变量中访问其成员。它通过结构体变量名后跟一个点号（<code>.</code>），然后是要访问的成员名。</p>
<p>例如，假设有一个名为 <code>student</code> 的结构体变量，其中包含成员 <code>name</code> 和 <code>age</code>，可以使用成员访问运算符来访问它们：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span></span><br><span class="line"><span class="built_in">strcpy</span>(stu.name, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">stu.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, stu.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Age: %d\n&quot;</span>, stu.age);</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员间接访问运算符（<code>-&gt;</code>）：<br>成员间接访问运算符用于从指向结构体的指针中访问结构体的成员。它通过指针变量名后跟一个箭头符号（<code>-&gt;</code>），然后是要访问的成员名。</p>
<p>例如，假设有一个指向结构体的指针 <code>ptr</code>，其中结构体包含成员 <code>num</code>，可以使用成员间接访问运算符来访问它：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">ptr</span> =</span> &amp;stu;</span><br><span class="line">ptr-&gt;num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Number: %d\n&quot;</span>, ptr-&gt;num);</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体成员取址运算符（<code>&amp;</code>）：<br>结构体成员取址运算符用于获取结构体中特定成员的地址。它通过结构体变量名后跟一个点号（<code>.</code>）和要取址的成员名，然后再加上一个取址运算符（<code>&amp;</code>）。</p>
<p>例如，假设有一个结构体变量 <code>stu</code>，其中包含成员 <code>num</code>，可以使用结构体成员取址运算符来获取 <code>num</code> 的地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span></span><br><span class="line"><span class="type">int</span> *ptr = &amp;stu.num;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体成员自增运算符（<code>++</code>）：<br>结构体成员自增运算符用于递增结构体中的成员的值。它可以作为前缀或后缀运算符使用，即 <code>++stu.num</code> 或 <code>stu.num++</code>。</p>
<p>例如，假设有一个结构体变量 <code>stu</code>，其中包含成员 <code>num</code>，可以使用结构体成员自增运算符来递增 <code>num</code> 的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span></span><br><span class="line">stu.num = <span class="number">10</span>;</span><br><span class="line">++stu.num; <span class="comment">// 或 stu.num++;</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>间接访问运算符（<code>*</code>）：<br>间接访问运算符用于从指针指向的地址中获取存储的值。它通过指针变量前加一个星号（<code>*</code>）来实现。</p>
<p>例如，假设有一个指向结构体的指针 <code>ptr</code>，可以使用间接访问运算符来获取指针指向的结构体变量的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">ptr</span> =</span> &amp;stu;</span><br><span class="line">stu.num = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> value = *ptr; <span class="comment">// 获取指针指向的结构体变量的值</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>示例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> =</span> &#123;<span class="number">1001</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&quot;jim&quot;</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stu.num: %d\n&quot;</span>, stu.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stu.sex: %c\n&quot;</span>, stu.sex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stu.name: %s\n&quot;</span>, stu.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stu.age: %d\n&quot;</span>, stu.age);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">p</span>;</span></span><br><span class="line">    p = &amp;stu;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(*p).num: %d\n&quot;</span>, (*p).num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(*p).sex: %c\n&quot;</span>, (*p).sex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(*p).name: %s\n&quot;</span>, (*p).name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(*p).age: %d\n&quot;</span>, (*p).age);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="17-2-结构体嵌套"><a href="#17-2-结构体嵌套" class="headerlink" title="17.2 结构体嵌套"></a>17.2 结构体嵌套</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> stu_num;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">teacher</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> work_num;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">people</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">stup</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">teacher</span> <span class="title">ter</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> =</span> &#123;<span class="number">1001</span>, <span class="number">99</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">teacher</span> <span class="title">ter</span> =</span> &#123;<span class="number">8001</span>, <span class="number">8000</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">people</span> <span class="title">jim</span> =</span> &#123;<span class="string">&#x27;F&#x27;</span>, <span class="string">&quot;JimGreen&quot;</span>, <span class="number">20</span>, &amp;stu, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">people</span> <span class="title">jack</span> =</span> &#123;<span class="string">&#x27;F&#x27;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="number">50</span>, <span class="literal">NULL</span>, ter&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="17-3-结构体变量作为函数参数"><a href="#17-3-结构体变量作为函数参数" class="headerlink" title="17.3 结构体变量作为函数参数"></a>17.3 结构体变量作为函数参数</h1><p>当结构体变量作为函数参数时，可以通过值传递或指针传递的方式将结构体传递给函数。下面是两种传递结构体变量给函数的方法：</p>
<ol>
<li><p>值传递方式：<br>在值传递方式中，函数接收结构体变量的副本。这意味着函数对结构体的修改不会影响原始的结构体变量。函数的参数类型应该为结构体类型。</p>
<p>示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStudent</span><span class="params">(<span class="keyword">struct</span> student stu)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ID: %d\n&quot;</span>, stu.id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, stu.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> =</span> &#123;<span class="number">1001</span>, <span class="string">&quot;John Doe&quot;</span>&#125;;</span><br><span class="line">    printStudent(stu);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line">在上面的示例中，`printStudent` 函数通过值传递方式接收结构体变量 `stu` 的副本，并打印结构体的成员。</span><br></pre></td></tr></table></figure>
</li>
<li><p>指针传递方式：<br>在指针传递方式中，函数接收指向结构体的指针，可以通过指针直接修改原始的结构体变量。函数的参数类型应该为指向结构体的指针类型。</p>
<p>示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateStudent</span><span class="params">(<span class="keyword">struct</span> student *stu)</span> &#123;</span><br><span class="line">    stu-&gt;id = <span class="number">2001</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(stu-&gt;name, <span class="string">&quot;Jane Smith&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> =</span> &#123;<span class="number">1001</span>, <span class="string">&quot;John Doe&quot;</span>&#125;;</span><br><span class="line">    updateStudent(&amp;stu);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ID: %d\n&quot;</span>, stu.id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, stu.name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line">在上面的示例中，`updateStudent` 函数通过指针传递方式接收指向结构体的指针，并通过指针修改结构体的成员。在 `main` 函数中，我们传递了结构体变量 `stu` 的地址给 `updateStudent` 函数，并打印了更新后的结构体成员。</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.16 指针与数组的暧昧：数值指针与指针数组</title>
    <url>/2023/09/08/6-16-%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E6%9A%A7%E6%98%A7%EF%BC%9A%E6%95%B0%E5%80%BC%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>指针数组 数组指针，他们的重点都是再后面的这个词语里。</p>
<h1 id="16-1-指针数组"><a href="#16-1-指针数组" class="headerlink" title="16.1 指针数组"></a>16.1 指针数组</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *season[<span class="number">4</span>] = &#123;<span class="string">&quot;Spring&quot;</span>, <span class="string">&quot;Summer&quot;</span>, <span class="string">&quot;Autumn&quot;</span>, <span class="string">&quot;Winter&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello %s!\n&quot;</span>, season[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello Spring!</span><br><span class="line">Hello Summer!</span><br><span class="line">Hello Autumn!</span><br><span class="line">Hello Winter!</span><br></pre></td></tr></table></figure>



<p>最基础的main函数使用的就是指针数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="16-2-数组指针"><a href="#16-2-数组指针" class="headerlink" title="16.2 数组指针"></a>16.2 数组指针</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> (*pa)[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    pa = a;</span><br><span class="line">    p = a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pa: %p pa+1: %p\n&quot;</span>, pa, pa + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p: %p p+1: %p\n&quot;</span>, p, p + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pa = &amp;a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pa[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    p = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的功能是打印出数组 <code>a</code> 的一些信息。修正后的代码将按照以下顺序输出内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pa: 0x7ffdd1e2a000 pa+1: 0x7ffdd1e2a010</span><br><span class="line">p: 0x7ffdd1e2a020 p+1: 0x7ffdd1e2a024</span><br><span class="line">4 5 6 7</span><br><span class="line">4 5 6 7</span><br></pre></td></tr></table></figure>

<p>请注意，修正后的代码中已经修复了拼写错误，并且在打印指针时使用了 <code>%p</code> 格式说明符。此外，修正后的代码在循环中正确地使用了数组元素 <code>pa[0][i]</code> 和 <code>p[i]</code> 来输出数组的值。</p>
]]></content>
  </entry>
  <entry>
    <title>6.15 指针与数组的暧昧：数组名</title>
    <url>/2023/09/08/6-15-%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E6%9A%A7%E6%98%A7%EF%BC%9A%E6%95%B0%E7%BB%84%E5%90%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="15-1-数组名是一个常量指针吗"><a href="#15-1-数组名是一个常量指针吗" class="headerlink" title="15.1 数组名是一个常量指针吗?"></a>15.1 数组名是一个常量指针吗?</h1><p>数组名在C语言中被解释为一个常量指针（const pointer）。</p>
<p>具体解释如下：</p>
<ol>
<li>数组名表示数组的首个元素的地址。它是一个指针常量，即指针的值（即内存地址）不能被修改。</li>
<li>数组名的值是一个常量，不允许对其进行赋值操作。</li>
<li>数组名可以进行自增（<code>++</code>）和自减（<code>--</code>）操作，但这实际上是对指针进行操作，将指针移动到下一个或上一个元素的位置。</li>
<li>数组名可以被用于解引用操作符<code>*</code>，例如<code>*arr</code>，它等效于<code>arr[0]</code>，表示获取数组的首个元素的值。</li>
</ol>
<p>需要注意的是，虽然数组名被解释为一个常量指针，但数组中的元素可以被修改。例如，对于<code>int arr[] = &#123;1, 2, 3&#125;;</code>，可以通过<code>arr[0] = 10;</code>来修改数组的元素。</p>
<h1 id="15-2-数组名的隐式转换"><a href="#15-2-数组名的隐式转换" class="headerlink" title="15.2 数组名的隐式转换"></a>15.2 数组名的隐式转换</h1><p>数组名在许多情况下会发生隐式转换，具体取决于上下文。下面是关于数组名的一些常见情况和行为：</p>
<ol>
<li><p>数组类型：数组名表示整个数组的类型。例如，对于声明 <code>int arr[5];</code>，数组名 <code>arr</code> 的类型是 <code>int[5]</code>。</p>
</li>
<li><p>声明：在变量声明中，数组名用于指定变量名并指示其类型为数组类型。例如，<code>int arr[5];</code> 声明了一个名为 <code>arr</code> 的数组变量。</p>
</li>
<li><p>使用 <code>sizeof</code>：对数组名应用 <code>sizeof</code> 运算符将返回整个数组所占用的内存大小。例如，<code>sizeof(arr)</code> 返回整个数组 <code>arr</code> 所占用的字节数。</p>
</li>
<li><p>取址运算符 <code>&amp;</code>：对数组名应用取址运算符 <code>&amp;</code> 将返回数组的首个元素的地址。例如，<code>&amp;arr[0]</code> 或 <code>&amp;arr</code> 都可以获得数组 <code>arr</code> 的首个元素的地址。</p>
</li>
<li><p>右值：在大多数情况下，数组名被视为右值，即它代表了数组的首个元素的地址，而不是可以进行赋值的左值。因此，不能对数组名进行赋值操作。</p>
</li>
<li><p>间接访问运算符 <code>*</code>：通过对数组名应用间接访问运算符 <code>*</code>，可以获取数组的首个元素的值。例如，<code>*arr</code> 等效于 <code>arr[0]</code>，表示获取数组 <code>arr</code> 的首个元素的值。这样的表达式可以作为左值使用，允许对其进行赋值操作。</p>
</li>
<li><p>为什么不能对数组直接赋值？<br>在C语言中，数组是一组连续存储的元素，其大小在编译时就已经确定。因此，数组在内存中占据了一块固定大小的连续空间。由于数组名被解释为指向数组首元素的常量指针，它本身不是一个可修改的左值。</p>
</li>
</ol>
<p>当我们使用数组名进行赋值操作时，实际上是试图将一个指针（数组名）赋值给另一个指针，这是不允许的。赋值操作需要一个左值作为目标，而数组名并不是一个左值。</p>
<p>例如，以下代码是不合法的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[5];</span><br><span class="line">int arr2[5];</span><br><span class="line">arr = arr2;  // 错误！试图对数组名进行赋值操作</span><br></pre></td></tr></table></figure>

<p>如果我们想要将一个数组的值复制到另一个数组，可以使用循环或者库函数（如<code>memcpy</code>）来逐个复制数组元素。</p>
<ol>
<li>为什么只有在初始化的时候赋值？<br>在C语言中，数组的初始化是在定义数组时将一组初始值赋给数组元素的过程。数组的初始化只能在定义数组时进行，之后就不能再对整个数组进行赋值操作。</li>
</ol>
<p>这是因为数组在定义时需要分配一块内存空间来存储元素，并且在编译时就确定了数组的大小。编译器会根据初始化时提供的初始值来确定数组的元素个数，并在内存中为数组分配足够的空间。</p>
<p>一旦数组初始化完成，数组的大小和元素个数就被固定下来了。因此，无法再通过直接的赋值操作来改变整个数组的值。我们只能通过访问和修改数组的单个元素来改变数组的内容。</p>
<p>例如，以下代码是合法的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[5] = &#123;1, 2, 3, 4, 5&#125;;  // 定义数组并初始化</span><br><span class="line">arr[0] = 10;                   // 修改数组的第一个元素的值</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们可以在定义数组时使用初始化列表来初始化数组的元素。然后，我们可以通过索引访问数组的单个元素，并对其进行赋值操作来修改数组的值。但是无法对整个数组进行直接的赋值操作。</p>
<p>指针与数组的暧昧天系:指针数组与数组指针</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.14 指针与数组的暧昧：下标运算</title>
    <url>/2023/09/08/6-14-%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E6%9A%A7%E6%98%A7%EF%BC%9A%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="14-1-指针和数组之间的主要区别"><a href="#14-1-指针和数组之间的主要区别" class="headerlink" title="14.1 指针和数组之间的主要区别"></a>14.1 指针和数组之间的主要区别</h1><p>指针和数组在C语言中有密切的关系，并且它们之间有一些区别。以下是指针和数组之间的主要区别和关系：</p>
<ol>
<li>指针与数组的暧昧关系：<ul>
<li>在C语言中，数组名可以被视为指向数组第一个元素的指针。因此，数组名可以用作指针来访问数组元素。</li>
<li>例如，如果有一个整数数组<code>int arr[5]</code>，则<code>arr</code>可以被视为指向<code>arr[0]</code>的指针。</li>
</ul>
</li>
<li>数组与指针的区别：<ul>
<li>数组是一组固定长度的相同类型元素的集合，它们在内存中是连续存储的。</li>
<li>指针是一个变量，存储了一个内存地址，它可以指向任意类型的数据。</li>
<li>数组在创建后，其大小是固定的，不可更改；而指针可以根据需要指向不同的内存地址。</li>
</ul>
</li>
<li>间接访问与直接访问：<ul>
<li>通过指针间接访问数据，意味着使用指针来获取或修改指向的内存中的值。通过解引用操作符<code>*</code>来实现间接访问。</li>
<li>通过数组直接访问数据，意味着使用数组名和索引来直接访问数组中的元素。</li>
</ul>
</li>
<li>用途：<ul>
<li>指针通常用于动态内存分配，例如在堆上分配内存，以及在数据结构中使用指针来创建链表、树等数据结构。</li>
<li>数组用于存储一组固定长度的相同类型元素，可以方便地访问和处理这些元素。数组在编程中经常用于存储和处理数据集合，例如存储学生成绩、字母表等。</li>
</ul>
</li>
</ol>
<h1 id="14-2-引用方式"><a href="#14-2-引用方式" class="headerlink" title="14.2 引用方式"></a>14.2 引用方式</h1><p>指针可以使用间接访问（解引用操作符<code>*</code>）来访问数组元素，而数组可以使用索引操作符<code>[]</code>来访问数组元素。下面解释了为什么可以这样做：</p>
<ol>
<li><p>指针使用间接访问访问数组元素：</p>
<ul>
<li>指针是一个变量，存储了一个内存地址。当指针指向数组的首个元素时，可以使用指针进行间接访问来获取或修改数组元素的值。</li>
<li>解引用操作符<code>*</code>用于间接访问指针所指向的内存地址中的值。当将指针与解引用操作符<code>*</code>结合使用时，可以获取或修改指针指向的数组元素的值。</li>
</ul>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[] = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">int *ptr = arr;  // 将指针指向数组的首个元素</span><br><span class="line">int value = *ptr;  // 通过指针间接访问数组元素</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组使用索引访问数组元素：</p>
<ul>
<li>数组是一组连续存储的相同类型元素。数组名代表了数组的首个元素的地址。可以使用索引操作符<code>[]</code>来访问数组中的元素。</li>
<li>索引操作符<code>[]</code>接受一个整数索引，用于指定要访问的数组元素的位置。通过使用数组名和索引，可以直接访问数组元素的值。</li>
</ul>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[] = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">int value = arr[2];  // 直接访问数组元素</span><br><span class="line">```</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="14-3-重要"><a href="#14-3-重要" class="headerlink" title="14.3 重要"></a>14.3 重要</h1><p>在C语言中，表达式<code>E1[E2]</code>等价于<code>*(E1 + E2)</code>。这是因为在C语言中，指针算术运算定义了指针与整数之间的操作。</p>
<p>具体解释如下：</p>
<ol>
<li><code>E1</code>是一个指针，<code>E2</code>是一个整数。</li>
<li><code>E1[E2]</code>表示对指针<code>E1</code>进行偏移，偏移量为<code>E2</code>个元素的大小。</li>
<li>当对指针<code>E1</code>进行偏移时，首先将<code>E1</code>与<code>E2</code>相加，得到一个新的指针，该指针指向<code>E1</code>所指向的内存地址加上<code>E2</code>个元素的大小的位置。</li>
<li>最后，使用解引用操作符<code>*</code>对新的指针进行间接访问，获取该位置上的值。</li>
</ol>
<p>举个例子来说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[] = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">int* ptr = arr;  // 指针指向数组的首个元素</span><br><span class="line"></span><br><span class="line">int value1 = arr[2];      // 直接访问数组元素，等价于 *(arr + 2)</span><br><span class="line">int value2 = 2[arr];      // 使用 E1[E2] 访问数组元素，等价于 *(arr + 2)</span><br><span class="line"></span><br><span class="line">printf(&quot;%d\n&quot;, value1);  // 输出：3</span><br><span class="line">printf(&quot;%d\n&quot;, value2);  // 输出：3</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>arr[2]</code>和<code>2[arr]</code>都是访问数组<code>arr</code>中的第3个元素，它们的结果都是3。这是因为它们等价于<code>*(arr + 2)</code>，即指针<code>arr</code>加上偏移量2，然后通过解引用操作符<code>*</code>来访问对应的内存位置。</p>
<p>这种等价关系允许我们使用<code>E1[E2]</code>的形式来访问数组元素，尽管它的语法看起来有些奇怪，但在逻辑上是等价的，并且在某些特定的情况下可以增加代码的可读性。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.13 指针类型与运算</title>
    <url>/2023/09/08/6-13-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="13-1-什么是类型"><a href="#13-1-什么是类型" class="headerlink" title="13.1 什么是类型"></a>13.1 什么是类型</h1><p>类型（Type）是指编程语言中用于定义数据的属性和操作的概念。它描述了数据的特征、存储方式和允许的操作。每个类型都有一组特定的值和相应的操作，用于处理这些值。</p>
<p>在编程中，类型可以分为多种，包括整数类型、浮点数类型、字符类型、布尔类型、指针类型等。每种类型都有其特定的值范围和可用的操作。</p>
<p>以整数类型为例，它可以表示一定范围内的整数值，并支持基本的算术运算（加、减、乘、除）和比较运算（大小比较等）。不同的整数类型可能具有不同的值范围和所占的存储空间。</p>
<p>另外，您提到了字符类型（char）。在许多编程语言中，字符类型表示单个字符，例如字母、数字或特殊字符。对于字符类型，您可以执行类似整数类型的加减乘除运算，以及比较大小等操作。</p>
<p>指针类型是一种特殊的类型，用于存储内存地址。指针可以指向其他数据类型的变量，允许我们通过间接访问来操作和修改存储在内存中的数据。</p>
<h1 id="13-2-指针分类"><a href="#13-2-指针分类" class="headerlink" title="13.2 指针分类"></a>13.2 指针分类</h1><p>指针可以根据指向的内容的类型进行分类。以下是一些常见的指针类型分类：</p>
<ol>
<li>函数指针（Function Pointers）：<ul>
<li>函数指针是指向函数的指针变量。</li>
<li>它们可以用于存储和调用函数的地址。</li>
<li>函数指针的类型与所指向的函数的返回类型和参数类型相匹配。</li>
</ul>
</li>
<li>对象指针（Object Pointers）：<ul>
<li>对象指针是指向对象或数据结构的指针变量。</li>
<li>它们用于访问和操作堆上分配的对象或数据结构。</li>
<li>对象指针的类型与所指向的对象或数据结构的类型相匹配。</li>
</ul>
</li>
<li>基本类型指针（Primitive Type Pointers）：<ul>
<li>基本类型指针是指向基本数据类型（如char、int、long等）的指针变量。</li>
<li>它们用于访问和操作所指向的基本类型的值。</li>
</ul>
</li>
<li>结构体指针（Struct Pointers）：<ul>
<li>结构体指针是指向结构体的指针变量。</li>
<li>它们用于访问和操作所指向结构体的成员。</li>
</ul>
</li>
<li>数组指针（Array Pointers）：<ul>
<li>数组指针是指向数组的指针变量。</li>
<li>它们用于访问和操作所指向的数组的元素。</li>
</ul>
</li>
<li>二级指针（Double Pointers）：<ul>
<li>二级指针是指向指针的指针变量。</li>
<li>它们用于操作和传递指针的地址。</li>
</ul>
</li>
<li>Void指针（Void Pointers）：<ul>
<li>Void指针是一种通用指针，可以指向任意类型的数据。</li>
<li>它们用于在不知道具体类型的情况下操作内存。</li>
</ul>
</li>
</ol>
<h1 id="13-3-指针运算"><a href="#13-3-指针运算" class="headerlink" title="13.3 指针运算"></a>13.3 指针运算</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">short</span> *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> *r = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, q + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, r + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="13-4-指针相减"><a href="#13-4-指针相减" class="headerlink" title="13.4 指针相减"></a>13.4 指针相减</h1><p>指针与指针相减可以用来计算它们在内存中的距离。以下是关于指针相减的一些重要点：</p>
<ol>
<li>类型要一致：在进行指针相减操作时，两个指针必须具有相同的类型。这是因为指针的类型确定了它们在内存中所指向的数据单元的大小。</li>
<li>相减操作：指针相减的结果是一个整数值，表示两个指针之间的偏移量。它表示以数据类型的长度（使用<code>sizeof</code>运算符获取）为单位的距离。</li>
<li>表示内存距离：指针相减的结果表示两个指针之间的内存距离。这个距离的单位取决于所使用的数据类型。通常，它以字节或数组元素为单位，取决于所涉及的具体情况。<ul>
<li>以字节为单位：如果两个指针指向相同类型的单个字节（如<code>char</code>类型），则指针相减的结果表示两个指针之间的字节偏移量。</li>
<li>以数组元素为单位：如果两个指针指向同一数组中的元素（如<code>int</code>类型），则指针相减的结果表示两个元素之间的偏移量。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.12 一些复杂的指针声明</title>
    <url>/2023/09/08/6-12-%E4%B8%80%E4%BA%9B%E5%A4%8D%E6%9D%82%E7%9A%84%E6%8C%87%E9%92%88%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="12-1-与指针相关的运算符和操作"><a href="#12-1-与指针相关的运算符和操作" class="headerlink" title="12.1 与指针相关的运算符和操作"></a>12.1 与指针相关的运算符和操作</h1><ol>
<li><p>指针声明：</p>
<ul>
<li><code>*</code>：用于声明指针变量。例如，<code>int* ptr;</code>声明了一个名为<code>ptr</code>的指向<code>int</code>类型的指针变量。</li>
</ul>
</li>
<li><p>地址运算符：</p>
<ul>
<li><code>&amp;</code>：用于获取变量的地址。例如，<code>int a = 10; int* ptr = &amp;a;</code>将变量<code>a</code>的地址赋给指针<code>ptr</code>。</li>
</ul>
</li>
<li><p>间接访问运算符：</p>
<ul>
<li><code>*</code>：用于访问指针所指向的内存位置的值。也称为解引用操作符。例如，<code>int a = *ptr;</code>将指针<code>ptr</code>所指向的内存位置的值赋给变量<code>a</code>。</li>
</ul>
</li>
<li><p>后置自增自减运算符：</p>
<ul>
<li><code>++</code>：后置自增运算符，将指针的值增加1。</li>
<li><code>--</code>：后置自减运算符，将指针的值减少1。</li>
<li>例如，<code>ptr++;</code>将指针<code>ptr</code>的值增加1。</li>
</ul>
</li>
<li><p>成员选择运算符：</p>
<ul>
<li><code>.</code>：用于访问结构体或联合体类型的成员。例如，<code>struct Person &#123; char name[20]; int age; &#125;; Person p; p.age = 25;</code></li>
<li><code>-&gt;</code>：用于通过指针访问结构体或联合体类型的成员。例如，<code>Person* ptr = &amp;p; ptr-&gt;age = 30;</code></li>
</ul>
<h1 id="12-2-运算符优先级："><a href="#12-2-运算符优先级：" class="headerlink" title="12.2 运算符优先级："></a>12.2 运算符优先级：</h1><ul>
<li><ul>
<li><p>1级（从高到低）：</p>
<ul>
<li><code>(</code>：函数调用、表达式分组</li>
<li><code>.</code>：成员选择运算符</li>
<li><code>-&gt;</code>：成员选择运算符（用于指针）</li>
<li><code>++</code>：后置自增运算符</li>
<li><code>--</code>：后置自减运算符</li>
<li><code>+</code>：一元正号运算符</li>
</ul>
<p>2级（从高到低）：</p>
<ul>
<li><code>++</code>：前置自增运算符</li>
<li><code>--</code>：前置自减运算符</li>
<li><code>*</code>：指针解引用运算符</li>
<li><code>&amp;</code>：地址运算符</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>SHE-&gt;卢星宇</p>
<h1 id="12-3-混淆定义"><a href="#12-3-混淆定义" class="headerlink" title="12.3 混淆定义"></a>12.3 混淆定义</h1><p>以下是与指针相关的一些定义的解释：</p>
<ol>
<li><code>*p++;</code>：<ul>
<li>这是一个表达式，其中<code>p</code>是一个指针变量。</li>
<li><code>*p</code>表示对指针<code>p</code>所指向的内存位置进行解引用，获取该位置的值。</li>
<li><code>p++</code>表示对指针<code>p</code>进行后置自增操作，将指针向后移动到下一个内存位置。</li>
</ul>
</li>
<li><code>&amp;p++;</code>：<ul>
<li>这是一个无效的表达式。</li>
<li><code>&amp;</code>是地址运算符，用于获取变量的地址。</li>
<li>但是，<code>p++</code>是一个指针的后置自增操作，返回的是指针的值而不是地址，所以不能对其应用地址运算符。</li>
</ul>
</li>
<li><code>&amp;stu.a</code>：<ul>
<li>这是一个表达式，其中<code>stu</code>是一个结构体变量，<code>a</code>是结构体<code>stu</code>的成员。</li>
<li><code>&amp;</code>是地址运算符，用于获取变量的地址。</li>
<li><code>&amp;stu.a</code>表示获取结构体<code>stu</code>中成员<code>a</code>的地址。</li>
</ul>
</li>
<li><code>int *a[10];</code>：<ul>
<li>这是一个声明语句，定义了一个数组<code>a</code>，其中每个元素都是指向<code>int</code>类型的指针。</li>
<li><code>int *a[10]</code>声明了一个包含10个元素的指针数组。</li>
</ul>
</li>
<li><code>int (*a)[80];</code>：<ul>
<li>这是一个声明语句，定义了一个指针<code>a</code>，它指向一个包含80个<code>int</code>类型元素的数组。</li>
<li><code>int (*a)[80]</code>声明了一个指针<code>a</code>，它指向一个包含80个<code>int</code>类型元素的数组。</li>
</ul>
</li>
<li><code>int *f(int);</code>：<ul>
<li>这是一个函数声明，定义了一个名为<code>f</code>的函数，该函数接受一个<code>int</code>类型的参数，并返回一个<code>int</code>类型的指针。</li>
</ul>
</li>
<li><code>int (*f)(int);</code>：<ul>
<li>这是一个声明语句，定义了一个指针<code>f</code>，它指向一个接受一个<code>int</code>类型参数并返回<code>int</code>类型的函数。</li>
</ul>
</li>
<li><code>*(*f)(int);</code>：<ul>
<li>这是一个声明语句，定义了一个指针<code>f</code>，它指向一个函数，该函数接受一个<code>int</code>类型的参数，并返回一个指针。</li>
<li><code>*(*f)(int)</code>声明了一个指针<code>f</code>，它指向一个函数，该函数接受一个<code>int</code>类型的参数，并返回一个指针。</li>
</ul>
</li>
<li><code>int *(*(*f)(int))[101];</code>：<ul>
<li>这是一个声明语句，定义了一个指针<code>f</code>，它指向一个函数，该函数接受一个<code>int</code>类型的参数，并返回一个指向指针的指针。</li>
<li><code>int *(*(*f)(int))[101]</code>声明了一个指针<code>f</code>，它指向一个函数，该函数接受一个<code>int</code>类型的参数，并返回一个指向指针的指针。</li>
</ul>
</li>
<li><code>int*(*T)[10];</code>：<ul>
<li>这是一个声明语句，定义了一个指针<code>T</code>，它指向一个包含10个<code>int</code>类型指针的数组。</li>
<li><code>int*(*T)[10]</code>声明了一个指针<code>T</code>，它指向一个包含10个<code>int</code>类型指针的数组。</li>
</ul>
</li>
</ol>
<h1 id="12-4-右左法则"><a href="#12-4-右左法则" class="headerlink" title="12.4 右左法则"></a>12.4 右左法则</h1><p>右左法则（Right-Left Rule）是用于解析复杂声明的方法。根据右左法则，我们从最内层的括号开始阅读声明，并向右移动，然后向左移动。每当遇到括号时，我们需要改变阅读方向。一旦解析完括号内的内容，我们跳出括号，继续解析剩余的声明，直到整个声明解析完毕。</p>
<p>以下是使用右左法则解析声明的示例步骤：</p>
<ol>
<li>从最内层的括号开始：<ul>
<li><code>( )</code>：未定义标识符</li>
</ul>
</li>
<li>向右移动：<ul>
<li><code>*</code>：指针</li>
<li><code>(*f)</code>：<code>f</code>是一个指针</li>
</ul>
</li>
<li>向左移动：<ul>
<li><code>(*f)(int)</code>：<code>f</code>是一个接受一个<code>int</code>参数的函数</li>
</ul>
</li>
<li>继续解析：<ul>
<li><code>int (*f)(int)</code>：<code>f</code>是一个接受一个<code>int</code>参数的函数，返回<code>int</code></li>
</ul>
</li>
</ol>
<p>根据右左法则，我们成功解析了声明<code>int (*f)(int)</code>。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.11 从变量到指针</title>
    <url>/2023/09/08/6-11-%E4%BB%8E%E5%8F%98%E9%87%8F%E5%88%B0%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="11-1-动态存储区静态存储区"><a href="#11-1-动态存储区静态存储区" class="headerlink" title="11.1 动态存储区静态存储区"></a>11.1 动态存储区静态存储区</h1><p>在C和C++中，有两种主要的存储区域：动态存储区（Dynamic Storage Area）和静态存储区（Static Storage Area）。</p>
<ol>
<li>动态存储区：<ul>
<li>动态存储区是在程序运行时动态分配和释放的内存区域。</li>
<li>动态存储区的大小和生命周期由程序员显式地管理。</li>
<li>主要通过动态内存分配函数（如<code>malloc</code>、<code>calloc</code>、<code>realloc</code>）来分配内存。</li>
<li>动态存储区中的内存可在程序的不同部分之间共享，并且可以在运行时进行分配和释放。</li>
<li>如果程序员不释放动态分配的内存，可能会导致内存泄漏。</li>
</ul>
</li>
<li>静态存储区：<ul>
<li>静态存储区是在程序编译阶段分配的内存区域。</li>
<li>静态存储区的大小和生命周期在程序运行期间保持不变。</li>
<li>静态存储区主要用于存储静态变量、全局变量以及静态常量。</li>
<li>静态存储区中的内存在程序的整个执行过程中一直存在，并且可以被程序的任何部分访问。</li>
</ul>
</li>
</ol>
<h1 id="11-2-指针"><a href="#11-2-指针" class="headerlink" title="11.2 指针"></a>11.2 指针</h1><p>指针是一种特殊的变量类型，用于存储内存地址。它可以指向其他变量或数据的内存位置，并通过该地址访问和操作存储在该位置上的数据。</p>
<p>指针的原始用途之一是访问一片匿名的动态内存，也称为动态内存分配。通过动态内存分配函数（如<code>malloc</code>、<code>calloc</code>、<code>realloc</code>），可以在程序运行时动态地分配一块内存，并返回其地址给指针。这样，我们可以通过指针来访问和操作这块匿名的动态内存。</p>
<p>使用动态内存分配可以解决以下场景的需求：</p>
<ul>
<li>需要在程序运行时根据实际需要动态地分配内存空间。</li>
<li>需要处理大量或可变数量的数据，而静态变量或栈上的内存空间受限制。</li>
<li>需要在函数调用之间共享数据，而函数的局部变量在函数调用结束时被释放。</li>
</ul>
<p>通过动态内存分配和指针，我们可以动态地创建、使用和销毁内存块，使程序能够更加灵活地处理内存需求。</p>
<h1 id="11-3-从存储角度看指针"><a href="#11-3-从存储角度看指针" class="headerlink" title="11.3 从存储角度看指针"></a>11.3 从存储角度看指针</h1><p>从存储角度来看，指针在内存中存储的是一个地址值，这个地址指向另一个对象或函数的存储位置。下面是关于指针的存储相关的概念：</p>
<ol>
<li>符号（Symbol）：<ul>
<li>在编程语言中，符号是用来表示变量、函数或其他可识别实体的名称。</li>
<li>当我们定义一个指针时，我们为它选择一个符号作为变量名，以便在代码中引用它。</li>
</ul>
</li>
<li>对象指针（Object Pointer）：<ul>
<li>对象指针存储的是指向某个对象的内存地址。</li>
<li>通过对象指针，我们可以访问和操作指向的对象的数据。</li>
</ul>
</li>
<li>函数指针（Function Pointer）：<ul>
<li>函数指针存储的是指向函数的内存地址。</li>
<li>通过函数指针，我们可以调用指向的函数。</li>
</ul>
</li>
</ol>
<p>在内存中，指针本身也是一个变量，它占据一定的存储空间，通常是根据计算机体系结构的位数来确定大小。指针变量存储的是目标对象或函数的内存地址。</p>
<p>总结：<br>从存储角度来看，指针存储的是一个地址值，用于指向其他对象或函数的存储位置。指针本身是一个变量，占据一定的存储空间。通过指针，我们可以访问和操作指向的对象的数据，或者调用指向的函数。</p>
<h1 id="11-4-指针为什么要有类型"><a href="#11-4-指针为什么要有类型" class="headerlink" title="11.4 指针为什么要有类型"></a>11.4 指针为什么要有类型</h1><p>指针之所以要有类型，主要有两个原因：</p>
<ol>
<li>编译器类型检查：<ul>
<li>类型信息是编译器进行静态类型检查的基础，它能够在编译时检测出类型错误。</li>
<li>指针的类型信息告诉编译器指针所指向的数据的类型，从而确保在编译过程中对指针进行正确的操作。</li>
<li>编译器可以根据指针的类型检查指针的赋值、解引用、指针运算等操作是否符合语法和类型规则。</li>
</ul>
</li>
<li>指定其指向数据的类型：<ul>
<li>指针的类型不仅提供了类型检查的功能，还指定了指针所指向的数据的类型。</li>
<li>通过指针的类型信息，我们可以知道在解引用指针时应该如何解释所指向的内存数据。</li>
<li>指针的类型决定了指针操作的语义，如指针运算的步长以及对指针进行的类型转换。</li>
</ul>
</li>
</ol>
<h1 id="11-5-指针-地址"><a href="#11-5-指针-地址" class="headerlink" title="11.5 指针&#x3D;&#x3D;地址?"></a>11.5 指针&#x3D;&#x3D;地址?</h1><p>指针和地址在概念上是相关的，但它们并不完全相同。</p>
<p>指针是一种变量类型，用于存储内存地址。它可以指向其他变量或数据的内存位置，并通过该地址来访问和操作存储在该位置上的数据。</p>
<p>地址是内存中的位置标识，用来唯一标识存储单元的位置。地址可以是一个数字或其他表示内存位置的值。</p>
<p>可以说，指针存储了一个地址值，指向某个特定的内存位置。指针本身是一个变量，占据一定的存储空间，存储的内容是一个地址。</p>
<p>总结：<br>指针是存储内存地址的变量类型，用于指向其他变量或数据的内存位置。地址是内存中的位置标识，用来唯一标识存储单元的位置。指针存储了一个地址值，指向特定的内存位置。</p>
<h1 id="11-6-普通变量和指针变量"><a href="#11-6-普通变量和指针变量" class="headerlink" title="11.6 普通变量和指针变量"></a>11.6 普通变量和指针变量</h1><ol>
<li><p>值的比较：</p>
<ul>
<li>普通变量之间的比较是直接比较它们的值。例如，<code>a == b</code>会比较变量<code>a</code>和<code>b</code>的值是否相等。</li>
<li>指针变量之间的比较是比较它们所存储的地址值是否相等。例如，<code>p1 == p2</code>会比较指针变量<code>p1</code>和<code>p2</code>存储的地址值是否相等。如果它们指向同一个内存位置，那么它们的比较结果为真。</li>
</ul>
</li>
<li><p>空指针的比较：</p>
<ul>
<li>空指针是指未指向任何有效内存地址的指针。</li>
<li>可以使用特殊值<code>NULL</code>（在C语言中）或<code>nullptr</code>（在C++语言中）表示空指针。</li>
<li>比较指针变量与空指针时，可以使用<code>p == NULL</code>或<code>p == nullptr</code>来判断指针是否为空。</li>
</ul>
</li>
<li><p>指针的解引用和值的比较：</p>
<ul>
<li>解引用指针（如<code>*p</code>）可以获取指针所指向的内存位置的值。</li>
<li>指针的解引用操作返回的是所指向内存位置的值，可以与其他值进行比较。</li>
<li>例如，<code>*p == a</code>会比较指针<code>p</code>所指向的内存位置的值是否与变量<code>a</code>的值相等。</li>
</ul>
<h1 id="11-7-指针的优点"><a href="#11-7-指针的优点" class="headerlink" title="11.7 指针的优点"></a>11.7 指针的优点</h1><ol>
<li>动态内存的匿名访问：<ul>
<li>指针允许我们在运行时动态地分配内存，创建匿名的数据结构，并通过指针对其进行访问。</li>
<li>通过使用指针，我们可以在程序运行时根据需要分配和释放内存，而不需要提前知道数据的大小和数量。</li>
</ul>
</li>
<li>参数传递：<ul>
<li>使用指针作为函数参数可以传递数组、结构体和大块缓冲区等复杂数据类型，而不需要进行大规模的数据复制。</li>
<li>通过传递指针，函数可以直接访问和修改原始数据，而不是对副本进行操作，从而提高效率和节省内存。</li>
</ul>
</li>
<li>动态数据结构的实现：<ul>
<li>实现动态数据结构，如链表、树等，通常需要使用指针。</li>
<li>指针可以用来建立节点之间的连接关系，通过指针的指向来遍历和操作数据结构。</li>
</ul>
</li>
<li>字符串指针：<ul>
<li>字符串通常以字符数组的形式表示，而指针可以用来指向字符串的起始位置。</li>
<li>通过使用字符串指针，我们可以方便地对字符串进行操作、传递和比较。</li>
</ul>
</li>
<li>函数指针：<ul>
<li>函数指针可以存储和调用特定类型的函数。</li>
<li>函数指针的应用包括回调函数、动态函数调用和函数指针数组等。</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.9 变量的本质</title>
    <url>/2023/09/08/6-9-%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="9-1-变量名"><a href="#9-1-变量名" class="headerlink" title="9.1 变量名"></a>9.1 变量名</h1><p>通过数据类型定义变量时，您需要指定变量的名称、数据类型和初始值（可选）。下面是变量定义的一般格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;数据类型&gt; &lt;变量名&gt; = &lt;初始值&gt;;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>&lt;数据类型&gt;</code> 是变量的数据类型，例如 <code>int</code>、<code>float</code>、<code>char</code> 等。</li>
<li><code>&lt;变量名&gt;</code> 是您给变量起的名称，遵循命名规则和约定。</li>
<li><code>&lt;初始值&gt;</code> 是可选项，表示变量的初始值。对于某些数据类型，您可以选择提供初始值。</li>
</ul>
<p>以下是一个示例，定义了不同类型的变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">float f = 3.14;</span><br><span class="line">char c = &#x27;A&#x27;;</span><br></pre></td></tr></table></figure>

<p>在存储方面，变量在内存中占据一定的空间来存储其值。每个变量都有一个唯一的内存地址，用于标识其在内存中的位置。这个地址可以通过取变量的地址运算符 <code>&amp;</code> 来获取。</p>
<p>变量的存储方式可以分为两个方面：</p>
<ol>
<li>变量名：变量名是您在代码中使用的标识符，用于引用变量的值。它在代码中作为变量的别名，可以用于读取和修改变量的值。</li>
<li>地址：变量在内存中的存储位置由其地址确定。变量的地址是一个唯一的标识符，可以使用 <code>&amp;</code> 运算符获取。例如，<code>&amp;i</code> 表示变量 <code>i</code> 的地址。</li>
</ol>
<p>.</p>
<h1 id="9-2-总结"><a href="#9-2-总结" class="headerlink" title="9.2 总结"></a>9.2 总结</h1><ul>
<li>定义变量的目标是为了方便在内存中进行数据的读写操作。</li>
<li>编译器通过变量类型来确定为变量分配合适的存储空间和地址。</li>
<li>变量名本质上是内存中一段存储空间的别名，通过变量名可以对这段内存空间进行读写操作。</li>
<li>变量修饰符可以改变变量的存储方式和作用域。</li>
</ul>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.8 内核中的size_t数据类型</title>
    <url>/2023/09/08/6-8-%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84size-t%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="8-1-内核数据类型"><a href="#8-1-内核数据类型" class="headerlink" title="8.1 内核数据类型"></a>8.1 内核数据类型</h1><p>在内核编程中，有一些特定的数据类型用于表示和操作内核对象和内核级数据。下面是一些常见的内核数据类型分类：</p>
<ol>
<li>C语言基本数据类型：内核编程通常使用C语言作为开发语言，因此使用C语言的基本数据类型来表示内核级数据。这包括：<ul>
<li>整数类型：如int、char、short、long等。</li>
<li>浮点数类型：如float、double等。</li>
<li>指针类型：如void<em>、int</em>、struct*等。</li>
</ul>
</li>
<li>长度确定的数据类型：在内核编程中，为了确保跨平台的兼容性和数据一致性，有时会使用长度确定的数据类型。这些类型的大小和字节对齐是确定的，不会受编译器或平台的影响。例如：<ul>
<li>uint8_t、int8_t：8位有符号和无符号整数类型。</li>
<li>uint16_t、int16_t：16位有符号和无符号整数类型。</li>
<li>uint32_t、int32_t：32位有符号和无符号整数类型。</li>
<li>uint64_t、int64_t：64位有符号和无符号整数类型。</li>
</ul>
</li>
<li>特定内核对象数据类型：内核编程涉及访问和操作内核对象，因此有一些特定的数据类型用于表示内核对象。这些数据类型通常是由内核提供的结构体或指针类型。例如：<ul>
<li>struct task_struct：表示一个进程的内核对象。</li>
<li>struct file：表示一个打开的文件的内核对象。</li>
<li>struct inode：表示一个文件系统节点的内核对象。</li>
<li>struct semaphore：表示一个信号量的内核对象。</li>
</ul>
</li>
</ol>
<h1 id="8-2-size-t"><a href="#8-2-size-t" class="headerlink" title="8.2 size_t"></a>8.2 size_t</h1><p><code>size_t</code> 是一个在 C 和 C++ 中常见的数据类型，用于表示对象的大小或长度。它通常是一个无符号整数类型，并且在不同的平台上具有相同的字节大小。</p>
<p>为了避免与用户定义的标识符冲突，C 标准和 C++ 标准将一些特殊的类型定义为以 <code>_t</code> 结尾的标识符。因此，<code>size_t</code> 是一个以 <code>_t</code> 结尾的类型名。这种命名约定有助于提高代码的可读性和可移植性。</p>
<p><code>size_t</code> 通常用于以下情况：</p>
<ol>
<li>数组索引：它可以用作数组的索引类型，表示数组的大小或长度。例如，<code>size_t index</code> 可以用于迭代数组元素。</li>
<li>数据拷贝长度：在涉及数据拷贝、内存分配和释放等操作时，通常使用 <code>size_t</code> 来表示数据块的大小或长度。例如，<code>size_t length</code> 可以用于指定要拷贝的数据长度。</li>
<li>内存分配：在动态内存分配函数（如 <code>malloc</code>、<code>calloc</code>）中，<code>size_t</code> 通常用于指定要分配的内存块的大小。</li>
<li>文件操作：在处理文件时，<code>size_t</code> 可以用于表示文件的大小或读写操作的字节数。</li>
</ol>
<p>由于 <code>size_t</code> 是无符号整数类型，它适用于表示对象大小或长度，而不涉及正负值。它可以确保不会出现负数情况，并且可以表示较大的对象大小。</p>
<h1 id="8-3-使用size-t的好处"><a href="#8-3-使用size-t的好处" class="headerlink" title="8.3 使用size_t的好处"></a>8.3 使用size_t的好处</h1><p>使用 <code>size_t</code> 的好处有以下几点：</p>
<ol>
<li>数据的可移植性：<code>size_t</code> 的大小是根据平台的特定实现决定的，可以适应不同平台上的不同字节大小。这样可以确保代码在不同的平台上具有相同的行为，并且可以处理不同大小的对象或数据。</li>
<li>最大长度的表示：<code>size_t</code> 的无符号特性使其适合表示数据的最大长度，而不受正负值的限制。它可以表示较大的对象或数据大小，适用于需要处理大型数据或对象的场景。</li>
<li>代码的清晰性和可读性：使用 <code>size_t</code> 明确地表达了代码中涉及大小或长度的概念，使代码更具可读性和清晰性。它可以提供关于数据块大小的明确语义，减少了歧义和误解的可能性。</li>
</ol>
<p>在函数声明或定义中使用 <code>size_t</code> 可以增加代码的可读性和可维护性。例如，您提到的函数 <code>data_copy</code> 的声明中使用了 <code>size_t len</code> 参数，表明该参数表示数据的长度。这使得函数的用途和预期更加清晰，并且在调用函数时，也可以传递相应的 <code>size_t</code> 类型的参数。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.6 数据类型转换</title>
    <url>/2023/09/08/6-6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="6-1-数据类型转换示例"><a href="#6-1-数据类型转换示例" class="headerlink" title="6.1 数据类型转换示例"></a>6.1 数据类型转换示例</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> a = <span class="number">-10</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line">    </span><br><span class="line">    c = a + b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;c &gt; 0\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;c &lt; 0\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">-2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a &lt; b\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a &gt; b\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-2-为什么要类型转换"><a href="#6-2-为什么要类型转换" class="headerlink" title="6.2 为什么要类型转换"></a>6.2 为什么要类型转换</h1><p>类型转换在计算机编程中是常见的操作，它的目的是将一个数据从一种类型转换为另一种类型。下面是一些常见的情况和原因：</p>
<ol>
<li>硬件要求：计算机的CPU在执行运算时有特定的硬件要求，要求操作数的类型、大小和存储方式相同。如果操作数的类型不匹配，就需要进行类型转换以满足硬件要求。</li>
<li>隐式类型转换：在某些情况下，编程语言会自动进行隐式类型转换。例如，当执行不同类型的操作数之间的运算时，编程语言会自动将其中一个操作数转换为另一个操作数的类型，以便执行运算。</li>
<li>强制类型转换：有时，我们需要显式地将一个数据转换为特定的类型。这可以通过强制类型转换操作符来实现。强制类型转换可以用于将一个数据转换为更大或更小的整数类型，或者将一个浮点数类型转换为整数类型等。</li>
</ol>
<p>类型转换的目的是确保数据在运算和操作过程中的一致性和正确性。它可以帮助我们处理不同类型的数据，并使其适应特定的需求和要求。但需要注意的是，类型转换可能会导致数据精度损失或溢出等问题，因此在进行类型转换时需要谨慎处理，确保数据的准确性和安全性。</p>
<h1 id="6-3-转换情况"><a href="#6-3-转换情况" class="headerlink" title="6.3 转换情况"></a>6.3 转换情况</h1><ol>
<li>算术表达式中的自动转换：当进行算术运算时，如果操作数的类型不一致，编程语言会自动将其中一个操作数转换为另一个操作数的类型，以便执行运算。例如，将一个整数和一个浮点数相加，编程语言会将整数自动转换为浮点数，然后执行相加操作。</li>
<li>逻辑表达式中的自动转换：在逻辑运算中，如果操作数的类型不匹配，编程语言会自动进行类型转换以使其类型一致。例如，在一个逻辑表达式中，将一个整数和一个布尔值进行比较，编程语言会将整数自动转换为布尔值的类型，然后执行比较操作。</li>
<li>赋值表达式中的自动转换：当将一个值赋给不同类型的变量时，编程语言会自动进行类型转换以使其类型匹配。例如，将一个整数赋值给一个浮点数类型的变量，编程语言会将整数自动转换为浮点数类型，然后进行赋值操作。</li>
<li>函数形参与实参类型不匹配：当调用函数时，如果函数的形参类型与传递给函数的实参类型不匹配，编程语言会进行自动类型转换。例如，如果函数期望接收一个整数参数，但传递给函数的是一个浮点数，编程语言会将浮点数自动转换为整数类型，然后调用函数。</li>
<li>函数返回值类型与函数类型不匹配：在函数定义时，需要指定函数的返回值类型。如果函数的返回值类型与函数的实际返回值类型不匹配，编程语言会进行自动类型转换。例如，如果函数定义为返回整数类型，但函数内部的计算结果是浮点数，编程语言会将浮点数自动转换为整数类型，然后返回结果。</li>
</ol>
<h1 id="6-4-转换规则"><a href="#6-4-转换规则" class="headerlink" title="6.4 转换规则"></a>6.4 转换规则</h1><ol>
<li>低精度到高精度的隐式转换：当将一个低精度的数据转换为高精度的数据时，通常会发生隐式类型转换。例如，将一个char类型的变量转换为int类型的变量，或将一个float类型的变量转换为double类型的变量。</li>
<li>有符号到无符号的转换：在有符号类型和无符号类型之间进行转换时，编程语言通常会将有符号类型转换为无符号类型。例如，将一个signed int类型的变量转换为unsigned int类型的变量。</li>
<li>整数类型之间的转换：在整数类型之间进行转换时，通常会根据类型的大小和范围进行转换。转换规则是：char -&gt; short -&gt; int -&gt; long -&gt; long long。即，较小的整数类型可以自动转换为较大的整数类型。</li>
<li>浮点类型之间的转换：在浮点类型之间进行转换时，通常会根据类型的精度和范围进行转换。转换规则是：float -&gt; double -&gt; long double。即，较小精度的浮点类型可以自动转换为较大精度的浮点类型。</li>
</ol>
<h1 id="6-5-强制类型转换"><a href="#6-5-强制类型转换" class="headerlink" title="6.5 强制类型转换"></a>6.5 强制类型转换</h1><p>在强制类型转换中，我们可以使用显式的类型转换操作符来将一个类型转换为另一个类型。下面是一些重点关注的强制类型转换情况：</p>
<ol>
<li>char到int的转换：当将一个char类型的值转换为int类型时，值不会改变，但存储格式会发生变化。char类型通常占用一个字节，而int类型通常占用多个字节。将char类型的值转换为int类型时，编程语言会将char的值复制到int类型所占用的字节中，同时进行必要的位扩展来保持符号位的正确性。</li>
<li>int到char的转换：当将一个int类型的值转换为char类型时，可能会发生截断。由于char类型通常只占用一个字节，而int类型占用多个字节，将int类型的值转换为char类型时，编程语言会将int的值截断为char类型所能表示的范围内。如果int的值超出了char类型的表示范围，截断将导致数据的丢失。</li>
<li>signed到unsigned的转换：当将一个有符号类型（如signed int）的值转换为无符号类型（如unsigned int）时，值会发生改变，但存储格式不会发生变化。有符号类型和无符号类型在内存中的存储方式是相同的，只是解释方式不同。将有符号类型的值转换为无符号类型时，编程语言会根据规定的转换规则改变值的解释方式，可能导致符号位的改变和数值的变化。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.5 数据对齐</title>
    <url>/2023/09/08/6-5-%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="6-5-1-什么是数据对齐"><a href="#6-5-1-什么是数据对齐" class="headerlink" title="6.5.1 什么是数据对齐"></a>6.5.1 什么是数据对齐</h1><p>数据对齐是指在内存中分配和存储数据时，按照一定规则将数据放置在内存地址上的对齐位置。对齐是为了优化内存访问效率和处理器的数据访问特性而设计的。数据对齐可以提高程序的性能，并确保数据的正确读取和存储。</p>
<p>数据对齐原则通常包括以下几点：</p>
<ol>
<li>基本类型数据成员按自然边界对齐：基本类型数据（如整数、浮点数）的存储通常要求按照其自然边界进行对齐。例如，一个4字节的整数通常要求在内存中以4字节对齐的方式存储，即其地址是4的倍数。</li>
<li>结构体和类的数据对齐：结构体和类的数据对齐通常要求按照其最大对齐需求的成员进行对齐。结构体或类的对齐需求取决于其成员中对齐需求最高的成员。例如，如果结构体中有一个成员需要8字节对齐，那么整个结构体就要按照8字节对齐。</li>
<li>数据对齐划分：在内存中，数据按照其对齐需求被划分为一系列对齐单元。对齐单元的大小通常是根据系统架构和编译器的规定而定的。对齐单元的大小决定了数据在内存中的对齐位置。</li>
<li>数据未对齐：当数据未按照对齐要求存储时，会导致性能下降或者出现不可预测的行为。例如，当一个8字节的双精度浮点数在内存中以4字节对齐的方式存储时，可能会导致性能损失和访问错误。</li>
</ol>
<h1 id="6-5-2为什么要数据对齐"><a href="#6-5-2为什么要数据对齐" class="headerlink" title="6.5.2为什么要数据对齐?"></a>6.5.2为什么要数据对齐?</h1><p>数据对齐的目的是为了优化内存访问效率和处理器的数据访问特性。以下是一些原因：</p>
<ol>
<li>CPU硬件限制：某些处理器对于数据的访问有特定的要求，例如，某些处理器只能在特定的对齐位置读取或写入数据。如果数据未对齐，处理器可能需要额外的指令或周期来处理这种非对齐的情况，从而导致性能下降。</li>
<li>不同硬件平台对存储空间的管理不同：不同的硬件平台对存储空间的管理可能有不同的要求和规则。数据对齐可以确保程序在不同的硬件平台上具有一致的行为。</li>
<li>简化CPU硬件设计，简化了地址访问：数据对齐可以简化CPU硬件设计和内存访问。当数据按照对齐要求存储时，处理器可以通过简单的地址计算和访问方式来读取或写入数据，而不需要复杂的逻辑或额外的指令。</li>
<li>编译器会根据硬件平台选择合适的对齐方式：编译器可以根据目标硬件平台的要求选择合适的数据对齐方式。编译器可以在编译阶段对数据进行对齐优化，以提高程序的性能和效率。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">short</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;b = %p\n&quot;</span>, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;c = %p\n&quot;</span>, &amp;c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-5-3-结构体对齐"><a href="#6-5-3-结构体对齐" class="headerlink" title="6.5.3 结构体对齐"></a>6.5.3 结构体对齐</h1><p>结构体对齐是指在内存中分配和存储结构体时，按照一定规则将结构体成员放置在内存地址上的对齐位置。结构体对齐的原则包括以下几点：</p>
<ol>
<li>结构体内各成员按各自自然对齐方式：结构体的每个成员都有自己的对齐要求，例如，整型成员通常要求按照其自然边界对齐。对于基本类型的成员，编译器会按照其对齐要求将其放置在合适的内存位置。</li>
<li>结构体整体对齐方式：结构体的整体对齐方式可以按照最大成员的对齐要求进行对齐，或者按照最大成员对齐要求的整数倍进行对齐。这意味着结构体的起始地址和大小都要符合对齐要求。</li>
</ol>
<p>例如，考虑以下的结构体定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct MyStruct &#123;</span><br><span class="line">    char a;</span><br><span class="line">    int b;</span><br><span class="line">    short c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据对齐原则，可以得到以下结构体对齐方式：</p>
<ul>
<li>成员a按照自然边界对齐，占用1字节。</li>
<li>成员b按照4字节对齐，占用4字节。</li>
<li>成员c按照2字节对齐，占用2字节。</li>
</ul>
<p>整体而言，结构体的最大成员是int类型的成员b，它的对齐要求是4字节。因此，整个结构体的对齐方式可以是按照4字节对齐，即结构体的起始地址和大小都是4的整数倍。</p>
<p>结构体对齐的目的是为了优化内存访问效率和处理器的数据访问特性。通过合理对齐结构体的成员，可以减小内存碎片、提高内存访问效率，并确保结构体在不同的硬件平台上具有一致的行为。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">short</span> num;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;stu.sex = %p\n&quot;</span>, &amp;stu.sex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;stu.num = %p\n&quot;</span>, &amp;stu.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;stu.age = %p\n&quot;</span>, &amp;stu.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;struct size: %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> student));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-5-4-联合体（Union）的对齐方式"><a href="#6-5-4-联合体（Union）的对齐方式" class="headerlink" title="6.5.4 联合体（Union）的对齐方式"></a>6.5.4 联合体（Union）的对齐方式</h1><p>联合体（Union）的对齐方式和结构体（Struct）有所不同。联合体的对齐原则包括以下几点：</p>
<ol>
<li>按照最大成员大小分配空间：联合体的内存空间大小取决于最大成员的大小。联合体的大小将足够容纳最大成员。</li>
<li>联合体的对齐：联合体的对齐方式是根据各成员的对齐字节数的最小公倍数来确定。这意味着联合体的起始地址和大小都要满足最小公倍数的要求。</li>
</ol>
<p>以下是一个示例联合体的定义和对齐方式的说明：</p>
<p>c</p>
<p>Copy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union MyUnion &#123;</span><br><span class="line">    char a;</span><br><span class="line">    int b;</span><br><span class="line">    short c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据对齐原则，可以得到以下联合体的对齐方式：</p>
<ul>
<li>成员a的对齐字节数为1字节。</li>
<li>成员b的对齐字节数为4字节。</li>
<li>成员c的对齐字节数为2字节。</li>
</ul>
<p>联合体的最大成员是int类型的成员b，其大小为4字节。因此，联合体的大小将足够容纳最大成员，即4字节。</p>
<p>联合体的对齐方式取决于成员a、b和c的对齐字节数的最小公倍数。在此示例中，最小公倍数为4字节。所以，整个联合体的对齐方式是按照4字节对齐，即联合体的起始地址和大小都是4的整数倍。</p>
<p>需要注意的是，由于联合体的成员共享同一块内存空间，因此在使用联合体时，只能使用一个成员，而不能同时使用多个成员。</p>
<p>联合体的对齐方式的目的是为了确保对齐要求，并提供一致的内存访问规则。它可以在一些特定的场景下提供灵活的数据组织方式和节省内存空间的优势。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.4 数据溢出</title>
    <url>/2023/09/08/6-4-%E6%95%B0%E6%8D%AE%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="6-4-1-数据溢出"><a href="#6-4-1-数据溢出" class="headerlink" title="6.4.1 数据溢出"></a>6.4.1 数据溢出</h1><p>数据溢出指的是当一个变量存储的数据超过了其数据类型所能表示的范围时发生的情况。不同的数据类型具有不同的表示范围，如果存储的数据超过了该范围，就会导致数据溢出。</p>
<p>对于字符型数据类型，包括有符号字符（signed char）和无符号字符（unsigned char）：</p>
<ul>
<li>有符号字符的表示范围是[-128, 127]，其中-128表示最小负数，127表示最大正数。</li>
<li>无符号字符的表示范围是[0, 255]，代表了所有可能的无符号字符值。</li>
</ul>
<p>对于整型数据类型，包括有符号整型（signed int）和无符号整型（unsigned int）：</p>
<ul>
<li>有符号整型的表示范围是[-2,147,483,648, 2,147,483,647]，其中-2,147,483,648表示最小负数，2,147,483,647表示最大正数。</li>
<li>无符号整型的表示范围是[0, 4,294,967,295]，代表了所有可能的无符号整数值。</li>
</ul>
<p>当对一个变量进行赋值或运算时，如果结果超过了该数据类型的表示范围，就会发生数据溢出。数据溢出可能导致结果不正确或不可预料的行为，因为超出范围的值无法正确地表示和处理。在编程中，需要谨慎处理数据范围，避免发生数据溢出的情况。</p>
<h1 id="6-4-2-数据溢出的后果"><a href="#6-4-2-数据溢出的后果" class="headerlink" title="6.4.2 数据溢出的后果"></a>6.4.2 数据溢出的后果</h1><ol>
<li>无符号数的溢出：当无符号数的值超过其表示范围时，会继续从最小值或最大值重新开始，形成一个循环。例如，无符号字符类型的值在范围[0, 255]内循环。例如，如果一个无符号字符变量的值为255，再加1将导致溢出并变为0。</li>
<li>取模运算，继续“轮回”：当对一个数进行取模运算时，如果结果超过了数据类型的表示范围，会继续从最小值或最大值重新开始。例如，对于有符号整型，取模运算会将负数转换为正数。例如，-1 % 5 的结果是4，因为-1被视为是从最大值开始的。</li>
<li>有符号数的溢出：当有符号数的值超过其表示范围时，会发生有符号整数溢出。这种情况下，结果是未定义的，可能会导致不可预料的行为。有符号整数溢出是一种常见的程序错误，需要特别注意。</li>
<li>C语言的宽松性、不作类型安全性检查：C语言在处理数据溢出时比较宽松，不会自动检测和阻止溢出情况。这意味着在进行运算或赋值时，如果结果超过了数据类型的表示范围，C语言不会报错，而是继续计算并使用溢出后的结果。这可能导致程序产生错误的结果，而不会得到警告或报错。</li>
<li>会产生未定义行为：当发生有符号整数溢出或其他未定义行为时，结果是不确定的。这意味着程序的行为可能是不可预测的，可能会导致程序崩溃、产生错误的结果或其他不正常的行为。因此，需要在程序中避免发生数据溢出的情况，以确保程序的正确性和可靠性。</li>
</ol>
<h1 id="6-4-3-如何防范整数溢出"><a href="#6-4-3-如何防范整数溢出" class="headerlink" title="6.4.3 如何防范整数溢出"></a>6.4.3 如何防范整数溢出</h1><ol>
<li>使用适当的数据类型：选择合适的数据类型来存储你的数据，确保数据类型具有足够的范围来容纳可能的值。如果需要处理较大的数值，可以考虑使用长整型（long）或者大整数库（如GMP）来处理。</li>
<li>进行溢出检查：在进行整数运算之前，检查操作数的范围是否适合目标数据类型。可以使用条件语句或断言来检查操作数的范围，确保运算不会导致溢出。</li>
<li>避免无符号数与有符号数混合运算：在进行整数运算时，尽量避免无符号数与有符号数混合运算，因为这可能会导致意外的结果。如果必须进行混合运算，将有符号数转换为无符号数或者进行显示的类型转换，以确保运算结果的正确性。</li>
<li>使用安全的算法和库函数：在进行数值计算时，选择使用已经经过测试和验证的安全算法和库函数。这些算法和库函数通常会考虑整数溢出的问题，并提供了溢出检查和处理机制。</li>
<li>编写健壮的代码：编写健壮的代码意味着要考虑到可能出现的异常情况，并进行适当的错误处理。在进行整数运算时，可以检查运算结果是否超出了目标数据类型的表示范围，并采取相应的措施，如抛出异常、返回错误码或进行截断处理等。</li>
<li>使用语言或工具提供的溢出检查机制：某些编程语言或工具提供了溢出检查机制，可以在编译时或运行时检测并报告整数溢出情况。例如，C语言中可以使用编译选项开启溢出检查，或者使用静态分析工具来检测潜在的溢出问题。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.3 有符号数和无符号数</title>
    <url>/2023/09/08/6-3-%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="6-3-1-有符号数和无符号数"><a href="#6-3-1-有符号数和无符号数" class="headerlink" title="6.3.1 有符号数和无符号数"></a>6.3.1 有符号数和无符号数</h1><p>关键字 “signed” 和 “unsigned” 在C语言中用于声明整数类型的有符号性质。</p>
<ol>
<li>“signed” 关键字：它用于声明有符号整数类型，表示该类型的变量可以表示正数、负数和零。在C语言中，如果没有指定类型的有符号性，默认情况下整数类型是有符号的。例如，<code>int</code> 是有符号整数类型。</li>
<li>“unsigned” 关键字：它用于声明无符号整数类型，表示该类型的变量只能表示非负数（正数和零），不包括负数。使用无符号整数类型可以扩展整数的表示范围。例如，<code>unsigned int</code> 是无符号整数类型。</li>
</ol>
<p>默认情况下，整数类型是有符号的，即省略了 “signed” 关键字，所声明的整数类型都是有符号的。例如，<code>int</code> 和 <code>signed int</code> 是等价的。</p>
<p>在打印数据时，可以使用不同的格式说明符来表示有符号数和无符号数：</p>
<ul>
<li><code>%d</code>：用于打印有符号整数，表示十进制输出。</li>
<li><code>%u</code>：用于打印无符号整数，同样表示十进制输出。</li>
</ul>
<p>对于有符号整数，其范围取决于具体的数据类型。常见的有符号整数类型及其范围如下：</p>
<ul>
<li><code>char</code> 类型（通常为有符号）：范围是 [-128, 127]。</li>
<li><code>signed char</code> 类型：范围是 [-128, 127]。</li>
<li><code>short</code> 类型（也称为 <code>short int</code>）：范围是 [-32,768, 32,767]。</li>
<li><code>int</code> 类型（也称为 <code>signed int</code>）：范围取决于具体的实现，但至少为 [-32,768, 32,767]。</li>
<li><code>long</code> 类型（也称为 <code>long int</code>）：范围取决于具体的实现，但至少为 [-2,147,483,648, 2,147,483,647]。</li>
</ul>
<p>对于无符号整数，其范围为 [0, 最大值]，最大值取决于具体的数据类型。例如，<code>unsigned char</code> 范围为 [0, 255]。</p>
<h1 id="6-3-2-原码、反码和补码"><a href="#6-3-2-原码、反码和补码" class="headerlink" title="6.3.2 原码、反码和补码"></a>6.3.2 原码、反码和补码</h1><p>以有符号8位整数为例，对于数值-3，以下是原码、反码和补码的示例：</p>
<ol>
<li><p>原码（Sign-Magnitude）：将数值的绝对值转换为二进制表示，并在最高位添加符号位。对于-3，其原码表示为：</p>
<p>原码: 1000 0011</p>
<p>最高位的1表示负数，其余位表示数值的绝对值。</p>
</li>
<li><p>反码（Ones’ Complement）：对于负数，反码是将其原码中除符号位外的每一位取反（0变为1，1变为0）。对于-3，其反码表示为：</p>
<p>反码: 1111 1100</p>
<p>原码中除符号位外的每一位取反得到反码。</p>
</li>
<li><p>补码（Two’s Complement）：对于负数，补码是在反码的基础上加1。对于-3，其补码表示为：</p>
<p>补码: 1111 1101</p>
<p>反码加1得到补码。</p>
</li>
</ol>
<p>需要注意的是，原码、反码和补码是用于表示负数的一种编码方式。在计算机中，负数一般以补码的形式存储和运算。补码具有以下特点：对于正数，其原码、反码和补码是相同的；而对于负数，其补码与其绝对值的二进制表示相差1。</p>
<h1 id="6-3-3-数据的存储"><a href="#6-3-3-数据的存储" class="headerlink" title="6.3.3 数据的存储"></a>6.3.3 数据的存储</h1><p>在计算机中，无符号数和有符号数的存储方式有所不同。</p>
<ol>
<li>无符号数的存储：无符号数直接将其真值（即数值的绝对值）转换为二进制表示，没有原码和补码之分。无符号数的存储方式只考虑数值的表示范围，将数值转换为二进制形式存储在相应的数据类型中。例如，对于无符号8位整数类型，数值范围为0到255，直接将数值转换为二进制表示存储即可。</li>
<li>有符号数的存储：有符号数采用补码的形式进行存储。补码是一种表示负数的编码方式，它可以将负数的表示范围扩展到与正数相同的位数上。<ul>
<li>正数的补码：对于正数，补码等于其原码，即正数的补码与其原码相同。这是因为正数的最高位为0，其原码、反码和补码都相同。</li>
<li>负数的补码：对于负数，补码等于其反码加1。反码是将负数的原码中除符号位外的每一位取反得到的结果。</li>
</ul>
</li>
</ol>
<p>使用补码的存储方式有以下优点：</p>
<ul>
<li>补码可以统一处理正数和负数的运算，简化了运算器的设计。</li>
<li>补码中只有一个零表示，避免了正零和负零的区分。</li>
<li>补码的表示范围与无符号数相同，可以利用同样的位数表示更大的数值范围。</li>
</ul>
<p>总结：</p>
<ul>
<li>无符号数直接将数值转换为二进制表示进行存储。</li>
<li>有符号数采用补码的形式进行存储，正数的补码等于其原码，负数的补码等于其反码加1。补码的存储方式统一了正数和负数的表示和运算。</li>
</ul>
<h1 id="6-3-4-为什么使用补码？"><a href="#6-3-4-为什么使用补码？" class="headerlink" title="6.3.4 为什么使用补码？"></a>6.3.4 为什么使用补码？</h1><p>在补码表示中，对于有符号整数类型，存在正零和负零的编码。以下是+0和-0的编码示例，假设使用8位有符号整数类型：</p>
<ul>
<li>+0 的编码：+0 在补码表示中与正数的编码相同，即直接将数值 0 转换为二进制表示即可。<br>+0 的补码表示为：[0000 0000]</li>
<li>-0 的编码：在补码表示中，-0 的补码与最小负数的补码表示相同，即将最小负数的绝对值取反得到 -0 的补码。<br>-0 的补码表示为：[1000 0000]</li>
</ul>
<p>需要注意的是，在实际计算机中，对于有符号整数类型，通常使用补码表示来处理正数、负数和零。正数的补码等于其原码，负数的补码等于其反码加 1。补码的形式可以解决零的编码问题，即只有一个零的表示，同时还可以多保存一个最小值，例如对于有符号的 8 位整数类型 (signed char)，可以多保存一个最小值 -128（补码为 [1000 0000]），而没有原码和反码的表示。</p>
<p>补码的使用有以下好处：</p>
<ul>
<li>统一了正数、负数和零的表示，简化了运算器和逻辑电路的设计。</li>
<li>解决了零的编码问题，只有一个零的表示。</li>
<li>可以多保存一个最小值，扩展了数值范围。</li>
<li>补码的运算规则与无符号数的运算规则相同，简化了运算的实现。</li>
</ul>
<p>计算机使用补码来存储数据有以下原因：</p>
<ol>
<li>解决零的编码问题：使用补码表示可以消除正零和负零的区别，只有一个零的表示。这简化了数值的表示和运算，并且避免了正负零之间的混淆。</li>
<li>简化减法运算：通过使用补码，减法运算可以转换为加法运算，从而省去了硬件上复杂的减法电路。减法可以通过将减数取反并与被减数相加的方式来实现，这使得计算机的运算器只需要具备加法器和求补电路，提高了硬件的简洁性和效率。</li>
<li>统一处理符号位：补码的运算规则与无符号数的运算规则相同，这样可以使符号位也参与运算，并且与其他位一起进行统一处理。当补码表示的数相加时，最高位（符号位）有进位时，进位被舍弃，从而实现了符号位的正确处理。</li>
</ol>
<p>对于示例中的3 + 7，以下是二进制表示和补码运算的示例：</p>
<ol>
<li><p>将3和7转换为二进制表示：</p>
<ul>
<li>3的二进制表示为：0000 0011</li>
<li>7的二进制表示为：0000 0111</li>
</ul>
</li>
<li><p>进行补码加法运算：<br>补码加法：0000 0011 + 0000 0111</p>
<p>asciidoc</p>
<p>Copy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  0000 0011  (3 的补码)</span><br><span class="line">+ 0000 0111  (7 的补码)</span><br><span class="line">------------</span><br><span class="line">  0000 1010  (结果的补码)</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>补码运算结果为0000 1010，表示为有符号整数的补码形式。由于最高位是0，表示正数，其余位表示数值的绝对值。</p>
</li>
<li><p>将补码结果转换为原码表示：</p>
<ul>
<li>补码结果的绝对值部分：0000 1010</li>
<li>最高位为0，表示正数，原码与补码相同：0000 1010</li>
</ul>
</li>
</ol>
<p>因此，3 + 7 的结果为10。</p>
<p>对于示例中的3 - 7，可以转换为 3 + (-7) 的形式，其中-7的补码表示为1111 1001。将其与3的补码 0000 0011 进行补码加法运算，得到补码结果 1111 1100。将补码结果转换为原码表示，得到 -4。因此，3 - 7 的结果为 -4。</p>
<h1 id="6-3-5-补码为什么采用了反码加1的形式"><a href="#6-3-5-补码为什么采用了反码加1的形式" class="headerlink" title="6.3.5 补码为什么采用了反码加1的形式"></a>6.3.5 补码为什么采用了反码加1的形式</h1><p>补码的设计采用了反码加1的形式，主要是为了解决负数的表示和运算中的一些问题，并提供了一种简便的方式来处理负数。</p>
<p>以下是设计补码采用反码加1的原因：</p>
<ol>
<li>统一了正数和负数的表示：使用补码可以将正数和负数的表示方式统一起来，无需额外的规则来区分正数和负数。这简化了数字的表示和运算。</li>
<li>简化了运算器的设计：通过使用补码，减法运算可以转换为加法运算，这避免了在运算器中需要额外的减法电路。运算器只需具备加法器和求补电路，简化了硬件设计。</li>
<li>解决了零的编码问题：使用补码可以解决零的编码问题，只有一个零的表示，而无需区分正零和负零。</li>
<li>实现了符号位的参与运算：补码的设计使符号位（最高位）也能参与运算，并与其他位一起进行统一处理。这样，符号位也可以像其他位一样参与加法和减法运算，简化了运算的处理逻辑。</li>
</ol>
<p>总的来说，补码采用反码加1的设计方式，使得负数可以用与正数相同的方式进行表示和运算，同时解决了零的编码问题。这种设计简化了硬件设计和运算逻辑，并提供了一种统一的方式来处理正数、负数和零。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.2 存储的基本概念</title>
    <url>/2023/09/08/6-2-%E5%AD%98%E5%82%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="6-2-1-存储单元"><a href="#6-2-1-存储单元" class="headerlink" title="6.2.1 存储单元"></a>6.2.1 存储单元</h1><p>存储单元是计算机中用于存储数据的最小单位。以下是几个常见的存储单元：</p>
<ul>
<li>位（Bit）：位是存储单元的最小单位，它只能表示0或1两种状态。计算机中的所有数据都以位的形式存储和处理。</li>
<li>字节（Byte）：字节是计算机中常用的存储单位，它由8个连续的位组成。字节是计算机内存中数据传输和存储的基本单位，通常用于表示字符、整数等数据。</li>
<li>字（Word）：字是开发者常用的存储单位，它表示计算机在一次操作中能够处理的固定大小的数据。字的大小取决于计算机的架构和操作系统，可以是8位、16位、32位或64位等。</li>
</ul>
<h1 id="6-2-2存储模式"><a href="#6-2-2存储模式" class="headerlink" title="6.2.2存储模式"></a>6.2.2存储模式</h1><p>存储模式指的是计算机在内存中存储多字节数据时，字节的顺序排列方式。关于存储模式，有两个相关的概念：位序（Bit Order）和字节序（Byte Order）。</p>
<ol>
<li><p>位序（Bit Order）：位序是指在一个字节（8位）中，比特位（bit）的排列顺序。在计算机中，有两种常见的位序方式：</p>
<ul>
<li>大端序（Big-Endian）：在大端序中，高位字节存储在低位地址，低位字节存储在高位地址。换句话说，数据的高位字节排在内存的低地址处，低位字节排在内存的高地址处。</li>
<li>小端序（Little-Endian）：在小端序中，低位字节存储在低位地址，高位字节存储在高位地址。换句话说，数据的低位字节排在内存的低地址处，高位字节排在内存的高地址处。</li>
</ul>
<p>位序的选择会直接影响多字节数据的存储和解析方式。不同的计算机体系结构和操作系统有不同的位序规定，例如，x86架构和Windows操作系统使用小端序，而PowerPC架构和大多数UNIX系统使用大端序。</p>
</li>
<li><p>字节序（Byte Order）：字节序是指在多字节数据（例如16位、32位或64位）中，字节的排列顺序。与位序类似，字节序也有两种常见的方式：</p>
<ul>
<li>大端序（Big-Endian）：在大端序中，高位字节存储在内存的低地址，低位字节存储在内存的高地址。换句话说，多字节数据的高位字节排在内存的低地址处，低位字节排在内存的高地址处。</li>
<li>小端序（Little-Endian）：在小端序中，低位字节存储在内存的低地址，高位字节存储在内存的高地址。换句话说，多字节数据的低位字节排在内存的低地址处，高位字节排在内存的高地址处。</li>
</ul>
<p>字节序的选择同样会影响多字节数据在不同计算机和操作系统之间的互通性。为了确保数据的正确解析和传输，程序员需要在跨平台的情况下正确处理字节序。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x11223344</span>;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line"></span><br><span class="line">    b = a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0x44</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Little endian!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Big endian!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大小端之分源自于不同的设计和处理方式，主要原因如下：</p>
<ol>
<li>硬件设计：在硬件层面，计算机内存是以字节为单位进行寻址和存储的。对于多字节数据，如整数或浮点数，需要将其存储在内存中的连续字节中。在设计计算机体系结构时，可以选择将多字节数据的最低有效字节存储在最低地址（小端序）或最高地址（大端序）。</li>
<li>处理习惯：小端模式与人类的思维习惯更为一致。我们在书写数字时，通常先写低位，后写高位。小端模式将最低有效字节存储在最低地址，与我们的书写习惯一致。这样可以使得值的表示更加直观和易于理解。</li>
<li>计算机处理习惯：大端模式在某些计算操作中更加方便。在大端模式下，可以直接按照字节顺序从左到右读写多字节数据，不需要考虑字节的对应关系。这对于某些操作，如整数加法、乘法等，可以简化处理逻辑，提高效率。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>6.1 存储才是C语言的精髓</title>
    <url>/2023/09/08/6-1-%E5%AD%98%E5%82%A8%E6%89%8D%E6%98%AFC%E8%AF%AD%E8%A8%80%E7%9A%84%E7%B2%BE%E9%AB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据存储在计算机中是非常重要的概念，对于理解计算机编程和问题求解至关重要。以下是对您提到的几个相关概念的简要说明：</p>
<ul>
<li>变量：变量是用来存储和表示数据的一种命名方式。通过变量，我们可以在程序中保存和操作数据。变量通常具有特定的数据类型（例如整数、浮点数、字符串等），并且可以在程序中进行赋值和修改。</li>
<li>指针：指针是用来存储内存地址的变量。它们可以指向其他变量或数据结构在内存中的位置。通过指针，我们可以直接访问和操作内存中的数据，而不是通过变量名来访问。</li>
<li>堆栈：堆栈是一种内存结构，用于管理程序的函数调用和局部变量。在函数调用时，相关的信息（例如函数参数、返回地址等）会被压入堆栈中，以便在函数执行完毕后能够返回到正确的位置。局部变量也存储在堆栈中，并在函数执行期间进行分配和释放。</li>
<li>链表：链表是一种数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的指针。链表可以动态地分配内存来存储数据，并且可以在运行时进行插入、删除和修改操作。链表的灵活性使其在许多算法和数据结构中发挥重要作用。</li>
</ul>
<p>关于编译器留给程序员的接口，关键字是编程语言中的特殊单词，具有预定义的含义和用途。编译器根据关键字来解析和理解源代码，并相应地执行特定的操作。程序员可以使用关键字来定义变量、控制程序流程、声明函数等。不同编程语言具有不同的关键字集合，而关键字的选择和用法直接影响着程序的行为和功能。</p>
<p>理解数据存储以及编译器提供的关键字接口，对于开发高效、可靠的软件系统至关重要。这些概念和工具帮助程序员管理和操作数据，解决各种计算机编程中的问题。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>数据存储和指针</tag>
      </tags>
  </entry>
  <entry>
    <title>5.24 标号元素</title>
    <url>/2023/09/07/5-24-%E6%A0%87%E5%8F%B7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>标记元素是C语言中用于初始化数组和结构体的特性之一。它允许您以任意顺序指定要初始化的元素，并且可以通过数组索引或结构体的结构域名直接给它们赋值。</p>
<p>使用标记元素可以使初始化代码更加灵活和易读，尤其在需要初始化大型数组或结构体时，可以避免冗长的初始化代码。</p>
<p>以下是使用标记元素进行数组和结构体初始化的示例：</p>
<ol>
<li>数组初始化：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> myArray[<span class="number">5</span>] = &#123; [<span class="number">2</span>] = <span class="number">42</span>, [<span class="number">4</span>] = <span class="number">99</span>, [<span class="number">1</span>] = <span class="number">7</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，通过索引（标记）指定了要初始化的数组元素以及它们的值。数组的长度为5，但只有索引为2、4和1的元素被初始化，其他元素将被默认初始化为0。</p>
<ol>
<li>结构体初始化：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">myPoint</span> =</span> &#123; .y = <span class="number">10</span>, .x = <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，通过结构体的结构域名（标记）指定了要初始化的结构体成员以及它们的值。结构体<code>Point</code>具有<code>x</code>和<code>y</code>两个成员，通过结构域名指定了它们的初始化值。</p>
<p>通过使用标记元素，您可以以更自由的方式初始化数组和结构体，无需按照默认顺序或位置进行初始化。这提供了更大的灵活性，并使代码更易读和维护。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.23 局部标签</title>
    <url>/2023/09/07/5-23-%E5%B1%80%E9%83%A8%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在C和C++编程语言中，局部标签（Local Labels）是指在函数或代码块内部定义的标签。与全局标签（Global Labels）不同，局部标签的作用范围仅限于所在的函数或代码块内部。</p>
<p>局部标签的语法形式为一个冒号（:）后跟标识符，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Code block with local label</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">goto</span> myLabel; <span class="comment">// Jump to local label</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Local label definition</span></span><br><span class="line">    myLabel:</span><br><span class="line">        <span class="comment">// Label code</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>myLabel</code> 是一个局部标签，它被定义在内部代码块中。在代码块中，可以使用 <code>goto</code> 语句跳转到该局部标签处，执行与标签关联的代码。</p>
<p>局部标签主要用于在函数或代码块内部实现一些局部的控制流跳转，例如在某个条件满足时跳转到特定的代码位置。与全局标签相比，局部标签的作用范围较小，更易于控制和理解。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.22 可变参数宏</title>
    <url>/2023/09/07/5-22-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>可变参数宏是一种宏定义的特殊形式，允许在宏中使用可变数量的参数。以下是几个示例定义可变参数宏的示例：</p>
<p>使用 <code>__VA_ARGS__</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define debug(fmt, ...) printf(fmt, __VA_ARGS__)</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>debug</code> 是一个宏，它接受一个格式字符串 <code>fmt</code> 和可变数量的参数。宏展开时，<code>__VA_ARGS__</code> 将被替换为传递给宏的实际参数，然后被传递给 <code>printf</code> 函数。</p>
<p>使用 <code>args...</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define debug2(fmt, args...) printf(fmt, args)</span><br></pre></td></tr></table></figure>

<p>这个示例与第一个示例类似，只是使用了不同的语法。<code>args...</code> 表示可变数量的参数，然后被传递给 <code>printf</code> 函数。</p>
<p>使用 <code>##_VA_ARGS__</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define debug(fmt, ...) printf(fmt, ##__VA_ARGS__)</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>##</code> 是一个预处理运算符，用于处理可变参数为空的情况。如果可变参数为空，<code>##</code> 将删除前面的逗号，以避免编译错误。</p>
<p>这些示例都是定义可变参数宏的常见方式。它们允许在宏中使用不定数量的参数，并将它们传递给其他函数或语句。在实际使用中，可以根据具体需求选择适合的定义方式。需要注意的是，在使用可变参数宏时，应谨慎处理参数的类型和数量，以避免潜在的错误和问题。</p>
<p>ShareLikeDislike</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.21 do{}while(0)</title>
    <url>/2023/09/07/5-21-do-while-0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是一个 do-while 循环的示例，它的语法结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// code;</span></span><br><span class="line">    <span class="comment">// code;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">while</span> (O);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，循环体内的代码会被执行一次，然后根据条件 <code>O</code> 的值判断是否继续执行循环。如果条件为真，则继续执行循环体；如果条件为假，则退出循环。</p>
<p>其中，<code>code</code> 表示需要执行的代码，可以是任意合法的语句或语句块。在循环体内可以包含一条或多条代码，用分号分隔。</p>
<p><code>O</code> 是循环条件，它可以是一个表达式、变量或常量。如果条件为真（非零值），则循环继续执行；如果条件为假（零值），则循环结束。</p>
<p>do-while 循环与 while 循环的区别在于，do-while 循环保证循环体至少执行一次，即使条件初始时就为假。而 while 循环在执行循环体之前先判断条件，如果条件初始时就为假，则循环体不会执行。</p>
<p>这种定义方式可能是为了实现复杂的宏定义，并且在条件语句中使用这些宏定义。</p>
<p>宏定义允许在代码中进行文本替换，可以用来定义函数式宏（function-like macros）和复合语句宏（compound statement macros）。函数式宏可以像函数一样接受参数并返回结果，复合语句宏可以包含多个语句。</p>
<p>使用宏定义可以在编译时进行代码替换，从而在一定程度上提高代码的执行效率。此外，宏定义还可以实现一些编程技巧，如条件编译、代码重用等。</p>
<p>在条件语句中使用复杂的宏定义可以使代码更加简洁和可读。通过将复杂的逻辑封装在宏定义中，可以提高代码的可维护性和可重用性。</p>
<p>另外，使用局部变量可以在宏定义中引入临时变量，以便在宏展开过程中进行计算或临时存储值。这可以增加宏定义的灵活性和功能性。</p>
<p>总的来说，这种定义方式可能是为了实现复杂的宏定义，提高代码的可读性、可维护性和重用性，同时在条件语句中使用这些宏定义可以简化代码结构并提高可读性。然而，需要注意的是，过度复杂的宏定义可能会导致代码难以理解和调试，因此在使用时需要权衡使用宏定义的利弊，并根据实际情况进行选择。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.20 case范围扩展</title>
    <url>/2023/09/07/5-20-case%E8%8C%83%E5%9B%B4%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在使用 <code>case</code> 语句时，值的顺序可以影响程序的性能。以下是一些注意事项：</p>
<ol>
<li>比较链 vs. 树 vs. 跳转表：<code>case</code> 语句可以使用比较链、树或跳转表来实现。比较链是按照 <code>case</code> 值的顺序逐个比较的方式，树是使用二叉树或多路查找树的方式，而跳转表是使用跳转指令进行快速查找。根据具体的编译器和目标平台，编译器可能会选择不同的实现方式。通常情况下，跳转表是最高效的实现方式，而比较链是最低效的实现方式。</li>
<li>大概率值放前面：由于 <code>case</code> 语句是按照顺序逐个比较的，因此将大概率命中的值放在前面可以提高性能。这是因为如果大多数情况下的值在前面，可以减少比较的次数，从而提高执行效率。</li>
<li>使用连续整数：如果 <code>case</code> 语句的值是连续的整数，可以考虑使用更高效的实现方式，如跳转表。这样可以将复杂度从线性降低为常数级别，提高执行效率。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.19 内建函数：__builtin_expect</title>
    <url>/2023/09/07/5-19-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%EF%BC%9A-builtin-expect/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>__builtin_expect</code> 是一个内建函数，用于提示编译器表达式的预期结果。它的使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__builtin_expect (exp, c)</span><br></pre></td></tr></table></figure>

<p>其中，<code>exp</code> 是一个表达式，<code>c</code> 是一个常量。该函数返回 <code>exp</code> 的值，并表示 <code>exp</code> 的结果为 <code>c</code> 的概率很大。</p>
<p>以下是 <code>__builtin_expect</code> 的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int max(int a, int b) &#123;</span><br><span class="line">    return (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int x = 10;</span><br><span class="line">    int y = 5;</span><br><span class="line"></span><br><span class="line">    int result = max(x, y);</span><br><span class="line">    if (__builtin_expect(result == x, 1)) &#123;</span><br><span class="line">        printf(&quot;Result is likely to be x\n&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;Result is likely not to be x\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>__builtin_expect</code> 用于提示编译器 <code>result == x</code> 的结果很可能为真。如果 <code>result == x</code>，将输出 “Result is likely to be x”；否则，将输出 “Result is likely not to be x”。</p>
<p>通过使用 <code>__builtin_expect</code>，可以提供编译器有关表达式预期结果的提示信息。这对于一些性能敏感的代码段，如分支预测优化，可以帮助编译器生成更优化的机器代码。</p>
<p>需要注意的是，<code>__builtin_expect</code> 的提示只是一种提示，具体如何优化由编译器决定。此外，它在实际应用中的效果可能因编译器和目标平台的不同而有所差异。因此，在使用时需要进行测试和验证，并在实际性能分析中评估其效果。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.18 内建函数：__builtin_constant_p</title>
    <url>/2023/09/07/5-18-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%EF%BC%9A-builtin-constant-p/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>__builtin_constant_p</code> 是一个内建函数，用于判断表达式是否为编译时常量。它在编译时进行求值，并返回一个整数常量，表示表达式是否为常量。</p>
<p>以下是 <code>__builtin_constant_p</code> 的使用示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_constant_p(size)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;size is a compile-time constant\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;size is not a compile-time constant\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    foo(<span class="number">10</span>);        <span class="comment">// size is a compile-time constant</span></span><br><span class="line">    foo(MAX_SIZE);  <span class="comment">// size is not a compile-time constant</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    foo(x);         <span class="comment">// size is not a compile-time constant</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>foo</code> 函数使用了 <code>__builtin_constant_p</code> 来判断 <code>size</code> 参数是否为编译时常量。如果 <code>size</code> 是编译时常量，将输出 “size is a compile-time constant”；否则，将输出 “size is not a compile-time constant”。</p>
<p>通过使用 <code>__builtin_constant_p</code>，可以根据表达式是否为编译时常量来进行条件编译或优化。这对于在编译时进行静态优化或决策非常有用。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.17 内建函数</title>
    <url>/2023/09/07/5-17-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>内建函数（Built-in functions）是编译器提供的一组特殊函数，其实现直接内置在编译器中。它们通常具有与普通函数相同的语法和调用方式，但在执行时具有特殊的行为和性能优化。</p>
<p>内建函数的特点如下：</p>
<ol>
<li>编译器内部实现：内建函数是编译器的一部分，其实现直接嵌入在编译器中。这使得编译器可以对这些函数进行特定的优化和内部处理。</li>
<li>直接使用：与关键字类似，内建函数可以直接使用，无需包含头文件或外部库的引用。它们是编译器的一部分，因此可以直接在代码中使用。</li>
<li>命名：内建函数的命名通常以 <code>_builtin</code> 开头，如 <code>_builtin_strlen</code>。这样的命名约定有助于与普通函数进行区分。</li>
<li>主要用于性能优化：内建函数的设计目的通常是为了性能优化。它们可以针对特定的操作或算法提供更高效的实现，以提高程序的执行速度。</li>
<li>部分是 C 标准库函数的内建版本：一些内建函数是对 C 标准库函数的内建版本，提供了更高效的实现。例如，<code>_builtin_strlen</code> 可能是对标准库函数 <code>strlen</code> 的内建优化版本。</li>
<li>没有文档且变动频繁：与标准库函数相比，内建函数通常没有官方文档，并且其行为和实现可能在不同的编译器版本中有所变化。这使得内建函数的使用相对不稳定，一般不建议在通用代码中频繁使用。</li>
</ol>
<p><code>__builtin_return_address(LEVEL)</code> 是一个内建函数，用于返回当前函数或调用者的返回地址。它接受一个整数参数 <code>LEVEL</code>，用于指定返回地址的级别。</p>
<ul>
<li>当 <code>LEVEL</code> 为0时，表示返回当前函数的返回地址。</li>
<li>当 <code>LEVEL</code> 为1时，表示返回当前函数的调用者的返回地址。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span>* return_addr = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Return address of func1: %p\n&quot;</span>, return_addr);</span><br><span class="line">    </span><br><span class="line">    return_addr = __builtin_return_address(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Return address of func1&#x27;s caller: %p\n&quot;</span>, return_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">    func1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    func2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>func1</code> 调用了 <code>__builtin_return_address</code> 来获取返回地址。当 <code>LEVEL</code> 为0时，它返回的是 <code>func1</code> 的返回地址；当 <code>LEVEL</code> 为1时，它返回的是 <code>func1</code> 的调用者（即 <code>func2</code>）的返回地址。</p>
<p>类似地，<code>__builtin_frame_address(LEVEL)</code> 是另一个内建函数，用于返回函数的栈帧地址。它的使用方式类似于 <code>__builtin_return_address</code>，也接受一个整数参数 <code>LEVEL</code>。</p>
<ul>
<li>当 <code>LEVEL</code> 为0时，表示返回当前函数的栈帧地址。</li>
<li>当 <code>LEVEL</code> 为1时，表示返回当前函数的调用者的栈帧地址。</li>
</ul>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.16 属性声明：used &amp; unused</title>
    <url>/2023/09/07/5-16-%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%EF%BC%9Aused-unused/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在给定的示例中，使用了 <code>used</code> 和 <code>unused</code> 属性来声明变量和函数的使用情况。</p>
<ol>
<li><code>.register int reg asm(&quot;r0&quot;) __attribute__((used));</code><br>这个声明将 <code>reg</code> 定义为一个寄存器变量，并使用 <code>used</code> 属性来指示编译器该变量会被使用。这可以防止编译器优化掉该变量，确保其在代码中的存在。</li>
<li><code>static void func(void) __attribute__((used, section(&quot;.text&quot;)));</code><br>这个声明定义了一个静态函数 <code>func</code>，并使用 <code>used</code> 属性来指示编译器该函数会被使用。此外，通过 <code>section(&quot;.text&quot;)</code> 属性，将该函数放置在 <code>.text</code> 段中。</li>
<li><code>static __attribute__((unused)) int a;</code><br>这个声明定义了一个静态变量 <code>a</code>，并使用 <code>unused</code> 属性来指示编识器该变量未被使用。这可以让编译器忽略该变量的存在，避免产生未使用变量的警告。</li>
<li><code>static int func(void) __attribute__((unused));</code><br>这个声明定义了一个静态函数 <code>func</code>，并使用 <code>unused</code> 属性来指示编译器该函数未被使用。类似于上述的静态变量，这可以让编译器忽略该函数的存在。</li>
<li><code>int fun(__attribute__((unused)) int a, int b);</code><br>这个声明定义了一个函数 <code>fun</code>，并使用 <code>unused</code> 属性来指示编译器函数中的参数 <code>a</code> 未被使用。这可以避免产生未使用参数的警告。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.15 属性声明：noreturn</title>
    <url>/2023/09/07/5-15-%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%EF%BC%9Anoreturn/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>属性声明 <code>noreturn</code> 是一个特殊的函数属性，它告诉编译器函数不会返回到调用者。这个属性可以用于告知编译器在函数执行完毕后不会返回到调用点，因此编译器可以进行一些优化，例如消除一些后续的代码或者警告未使用的返回值。</p>
<p>下面是一个使用 <code>noreturn</code> 属性声明的示例：</p>
<p>c</p>
<p>Copy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdnoreturn.h&gt;</span><br><span class="line"></span><br><span class="line">noreturn void exit_program(int exit_code) &#123;</span><br><span class="line">    // 执行一些清理操作</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // 退出程序</span><br><span class="line">    exit(exit_code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>exit_program</code> 函数被声明为 <code>noreturn</code> 类型，它表示该函数在执行完毕后不会返回到调用点。在函数体内，执行了一些清理操作后，调用了 <code>exit</code> 函数来终止程序的执行。</p>
<p>使用 <code>noreturn</code> 属性可以帮助编译器优化代码，并提供更好的代码可读性。它可以用于标记一些特殊函数，如退出程序的函数、抛出异常的函数等。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.14 属性声明：mode</title>
    <url>/2023/09/07/5-14-%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%EF%BC%9Amode/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>属性声明中的 <code>mode</code> 是一个功能强大的GNU C扩展，它用于指定类型的位宽和有符号&#x2F;无符号属性。通过 <code>mode</code> 属性，可以定义自定义的位宽类型，以及相应的有符号和无符号变体。</p>
<p>在给定的示例中，使用了 <code>mode(QI)</code> 属性来声明两个类型别名：</p>
<ol>
<li><code>typedef int s8 __attribute__((mode(QI)));</code><br>这个声明将 <code>s8</code> 定义为一个有符号整数类型，位宽为1字节（8位），即一个字节的宽度。<code>mode(QI)</code> 表示 “QI” 模式，其中 “Q” 表示 “Quad”，表示4个位，而 “I” 表示 “Integer”，表示整数类型。</li>
<li><code>typedef unsigned int us8 __attribute__((mode(QI)));</code><br>这个声明将 <code>us8</code> 定义为一个无符号整数类型，位宽也为1字节（8位）。同样使用了 <code>mode(QI)</code> 属性来指定位宽和有符号&#x2F;无符号属性。</li>
</ol>
<p>通过使用 <code>mode</code> 属性，可以根据需要定义特定位宽的整数类型，并根据需要选择有符号或无符号的变体。这在某些特定的嵌入式系统编程或底层编程中可能会有用，因为它可以更精确地控制数据类型的大小和属性。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.13 属性声明：noinline &amp; always_inline</title>
    <url>/2023/09/07/5-13-%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%EF%BC%9Anoinline-always-inline/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>inline</code>、<code>noinline</code> 和 <code>always_inline</code> 都是函数属性，用于指定函数的内联行为。它们可以通过 <code>__attribute__</code> 语法与函数结合使用。下面是使用示例：</p>
<ol>
<li><p><code>static inline __attribute__((noinline)) int func();</code><br>这个示例定义了一个静态内联函数 <code>func</code>，并使用了 <code>noinline</code> 属性。</p>
<ul>
<li><code>inline</code> 属性用于指定函数可以进行内联展开，即将函数的代码插入调用处，以减少函数调用的开销。</li>
<li><code>static</code> 关键字用于将函数声明为静态函数，限定函数的作用域在当前源文件中。</li>
<li><code>__attribute__((noinline))</code> 用于禁止对函数进行内联展开，即不将函数的代码插入调用处。</li>
</ul>
<p>这意味着 <code>func</code> 函数将被声明为内联函数，但编译器不会强制将其内联展开，而是根据编译器的优化策略决定是否内联展开。</p>
</li>
<li><p><code>static inline __attribute__((always_inline)) int func();</code><br>这个示例定义了一个静态内联函数 <code>func</code>，并使用了 <code>always_inline</code> 属性。</p>
<ul>
<li><code>__attribute__((always_inline))</code> 用于强制编译器始终内联展开函数，不考虑编译器的优化策略。</li>
</ul>
<p>这意味着 <code>func</code> 函数将始终被内联展开，无论编译器如何优化。</p>
</li>
</ol>
<p>使用内联函数可以提高函数调用的效率，减少函数调用带来的开销。然而，过度使用内联函数可能会导致代码膨胀和代码重复，增加可执行文件的大小。</p>
<p>内联函数是一种编译器优化技术，它将函数的代码插入到调用处，而不是通过函数调用的方式进行执行。内联函数的目的是减少函数调用的开销，包括保存当前函数现场、跳转到调用函数执行和恢复当前函数现场的开销。</p>
<p>当一个函数被声明为内联函数时，编译器会尽量将函数的代码直接插入到调用处，类似于宏展开的方式。这样可以避免函数调用的开销，包括压栈保存现场、跳转执行和恢复现场的操作。相比于函数调用，内联函数可以更快地执行，并且可以消除函数调用带来的额外开销。</p>
<p>然而，内联函数的使用应慎重考虑。由于内联函数的代码会被复制到每个调用处，这可能会导致代码膨胀，增加可执行文件的大小。过度使用内联函数可能会导致代码重复，降低可维护性。因此，应在性能和代码大小之间进行权衡，并根据具体情况决定是否使用内联函数。</p>
<p>在 C&#x2F;C++ 中，可以使用 <code>inline</code> 关键字将函数声明为内联函数。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>add</code> 函数被声明为内联函数。当调用 <code>add</code> 函数时，编译器会尝试将其代码直接插入到调用处，而不是进行函数调用。</p>
<p>需要注意的是，将函数声明为内联函数只是对编译器的建议，编译器可以选择是否内联展开函数。此外，内联函数的定义通常应放在头文件中，以便在每个调用处进行展开。</p>
<p>编译器对内联函数的处理可以分为两个阶段：编译阶段和链接阶段。</p>
<p>在编译阶段，当编译器遇到内联函数的调用时，它会尝试将函数的代码插入到调用处，类似于宏展开。这样可以避免函数调用的开销，并提高执行效率。编译器通常会对内联函数进行一些优化，如常量折叠、循环展开等。</p>
<p>在链接阶段，编译器会将每个内联函数的定义保留在目标文件中。当链接器将多个目标文件组合成可执行文件时，它会根据需要选择性地将内联函数的定义插入到调用处。</p>
<p>然而，内联函数也有一些不足之处：</p>
<ol>
<li>增大代码的体积：由于内联函数的代码会被复制到每个调用处，这可能导致代码膨胀，增加可执行文件的大小。特别是当内联函数的代码较长时，代码体积的增大可能会对缓存命中率和指令缓存的效率产生负面影响。</li>
<li>降低缓存命中率和取指效率：内联函数的代码增大可能导致缓存命中率降低，因为较多的代码需要从内存加载到缓存中。此外，取指令时，由于内联函数的代码较多，可能会导致取指令的效率降低，从而影响程序的执行速度。</li>
<li>可能降低执行效率：尽管内联函数可以减少函数调用的开销，但在某些情况下，内联函数的执行效率可能会降低。这是因为内联函数的代码被复制到多个调用处，增加了指令的数量和缓存的压力。此外，如果内联函数的代码较长，可能会导致指令缓存的冲突，从而影响执行速度。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.12 属性声明：constructor &amp; destructor</title>
    <url>/2023/09/07/5-12-%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%EF%BC%9Aconstructor-destructor/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>constructor</code> 和 <code>destructor</code> 是函数属性，用于指定在程序运行时自动执行的初始化函数和清理函数。它们可以通过 <code>__attribute__</code> 语法与 <code>constructor</code> 和 <code>destructor</code> 属性结合使用。具体的使用方法如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__((constructor)) <span class="type">int</span> <span class="title function_">init_func</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">__attribute__((destructor)) <span class="type">int</span> <span class="title function_">exit_func</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>init_func</code> 是一个初始化函数，<code>exit_func</code> 是一个清理函数。</p>
<p>解释如下：</p>
<ul>
<li><code>__attribute__((constructor))</code> 用于指定函数为初始化函数。这意味着在程序启动时，该函数会自动被调用进行初始化操作。</li>
<li><code>__attribute__((destructor))</code> 用于指定函数为清理函数。这意味着在程序退出时，该函数会自动被调用进行清理操作。</li>
</ul>
<p>使用 <code>constructor</code> 和 <code>destructor</code> 属性的函数在程序运行期间的执行顺序是由编译器和链接器决定的。通常情况下，初始化函数会在 <code>main</code> 函数之前被调用，而清理函数会在程序退出时被调用。</p>
<p>这些函数属性可以用于在程序开始和结束时执行一些必要的初始化和清理操作，例如初始化全局变量、打开和关闭文件、申请和释放资源等。</p>
<p>需要注意的是，函数属性的使用方法可能因编译器而异，具体的语法和支持程度可能有所差异。因此，在使用时应查阅相关编译器文档以了解具体的使用方法和限制。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.11 属性声明：weak &amp; alias</title>
    <url>/2023/09/07/5-11-%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%EF%BC%9Aweak-alias/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 C 语言中，符号（Symbol）是指变量、函数、常量等在编译过程中生成的标识符。符号具有不同的属性，其中包括强符号（Strong Symbol）和弱符号（Weak Symbol）。</p>
<ol>
<li>强符号（Strong Symbol）：<ul>
<li>强符号是指在编译过程中具有高优先级的符号。</li>
<li>当存在多个强符号的定义时，链接器会选择其中一个作为最终的定义，并且会忽略其他的定义。</li>
<li>通常情况下，全局变量和初始化的静态变量都被视为强符号。</li>
<li>在不同的源文件中定义同名的强符号会引发链接错误。</li>
</ul>
</li>
<li>弱符号（Weak Symbol）：<ul>
<li>弱符号是指在编译过程中具有低优先级的符号。</li>
<li>当存在多个弱符号的定义时，链接器会选择其中一个作为最终的定义，但如果没有找到强符号的定义，链接器会接受弱符号的定义。</li>
<li>通常情况下，未初始化的静态变量和函数都被视为弱符号。</li>
<li>在不同的源文件中定义同名的弱符号不会引发链接错误。</li>
</ul>
</li>
</ol>
<p>根据您提供的示例代码，可以进行如下解释：</p>
<ul>
<li><code>int a;</code> 和 <code>int b;</code> 是两个未初始化的静态变量，它们被视为弱符号。</li>
<li><code>int a = 1;</code> 是对变量 <code>a</code> 的初始化，它被视为强符号，因为它是一个具有初始值的全局变量。</li>
<li><code>int b = 2;</code> 是对变量 <code>b</code> 的初始化，它也被视为强符号，因为它是一个具有初始值的全局变量。</li>
<li><code>void func()</code> 和 <code>-void func()</code> 是函数 <code>func</code> 的声明和定义，它们都被视为强符号。</li>
</ul>
<p>在链接过程中，如果存在多个对同一符号的定义，链接器将根据符号的强度规则来选择最终的定义。在您的示例中，如果在 <code>main.c</code> 和 <code>func.c</code> 中都包含了同名的变量或函数定义，链接器将会选择其中一个作为最终的定义，并且会忽略其他的定义（对于强符号）或接受其中一个定义（对于弱符号）。</p>
<p>在链接过程中，符号决议（Symbol Resolution）是指解决多个源文件中对同一符号的定义或引用的过程。根据符号的强度和规则，可以发生以下三种场景：</p>
<ol>
<li>强符号与强符号：<ul>
<li>如果存在多个源文件中对同一符号的强符号定义，链接器将发生冲突，并且会报告链接错误。这是因为强符号具有高优先级，只能有一个最终的定义。</li>
</ul>
</li>
<li>强符号与弱符号、弱符号与弱符号：<ul>
<li>如果存在强符号与弱符号或者多个弱符号的定义，根据一般规则，强符号和弱符号可以共存。</li>
<li>在这种情况下，强符号将覆盖弱符号，并成为最终的定义。体积更大的符号通常被视为强符号，因此它将胜出。</li>
</ul>
</li>
</ol>
<p>需要注意的是，具体的符号决议规则和行为可能因编译器、操作系统和链接器的不同而有所差异。上述规则是一般情况下的基本规律，但在特定的环境中可能会有特殊的规则适用。</p>
<p>在实际开发中，为了避免符号冲突和不确定的行为，应遵循以下原则：</p>
<ul>
<li>避免在不同的源文件中定义具有相同名称的强符号。</li>
<li>在需要共享符号的情况下，使用弱符号进行定义，并确保在链接时只有一个强符号的定义。这可以通过将符号定义放在一个源文件中，或者使用特定的链接器选项来实现。</li>
</ul>
<p><code>alias</code> 是一个用于创建符号别名的关键字。在 C 语言中，<code>alias</code> 关键字可以与 <code>__attribute__</code> 结合使用来为函数或变量创建别名。具体使用方法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _f();</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> __<span class="title function_">attribute__</span><span class="params">((weak, alias(<span class="string">&quot;_f&quot;</span>)))</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，通过 <code>alias</code> 关键字，<code>f</code> 函数被创建为 <code>_f</code> 函数的别名。</p>
<p>解释如下：</p>
<ul>
<li><code>void _f();</code> 是 <code>_f</code> 函数的原始声明或定义。</li>
<li><code>void f() __attribute__((weak, alias(&quot;_f&quot;)));</code> 创建了一个名为 <code>f</code> 的函数，它是 <code>_f</code> 函数的别名。使用 <code>weak</code> 属性来指定 <code>f</code> 为弱符号，表示它可以与其他同名函数共存。</li>
</ul>
<p>通过使用 <code>alias</code> 关键字，我们可以在代码中创建函数或变量的别名，使其可以通过不同的名称进行访问。这对于一些特定的编程需求和代码重用非常有用。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.10 属性声明：const</title>
    <url>/2023/09/07/5-10-%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%EF%BC%9Aconst/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>属性声明 <code>const</code> 用于指定函数的返回值为常量（不可修改）。它的使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int func(int a) __attribute__((const));</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>const</code> 属性应用于函数 <code>func</code>，用于指定函数的返回值为常量。</p>
<p>具体来说，<code>const</code> 属性表示函数的返回值不依赖于除了函数参数之外的任何外部状态。也就是说，对于相同的输入，函数始终返回相同的结果，并且不会修改任何全局变量或静态变量。这种属性可以帮助编译器进行一些优化，例如函数结果的缓存或重复计算的消除。</p>
<p>使用 <code>const</code> 属性有助于提高代码的可读性和可靠性，因为它明确了函数的行为，并更容易推断出函数是否会产生副作用。</p>
<p>需要注意的是，使用 <code>const</code> 属性并不会强制确保函数的实现不会产生副作用或修改全局状态。它只是一种提示或约定，应该由开发者遵循。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.9 属性声明：format</title>
    <url>/2023/09/07/5-9-%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%EF%BC%9Aformat/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>属性 <code>format</code> 用于指定函数参数的格式化字符串检查，以帮助编译器检测格式化字符串与实际参数之间的匹配错误。它的使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__attribute__((format(archetype, string-index, first-to-check)))</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>archetype</code> 是一个字符串常量，用于指定格式化字符串的类型。常见的类型有 <code>&quot;printf&quot;</code> 和 <code>&quot;scanf&quot;</code>，分别用于格式化输出和格式化输入。</li>
<li><code>string-index</code> 是一个整数常量，表示格式化字符串在函数参数列表中的索引。索引从 1 开始，0 表示函数本身。</li>
<li><code>first-to-check</code> 是一个整数常量，表示从参数列表的第几个参数开始进行检查。一般情况下，这个值与 <code>string-index</code> 相同。</li>
</ul>
<p>例如，以下示例展示了如何使用 <code>format</code> 属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__attribute__((format(printf, 1, 2)))</span><br><span class="line">void LoG(const char *fmt, ...) &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>format(printf, 1, 2)</code> 属性应用于 <code>LoG</code> 函数。它告诉编译器检查函数的第一个参数（格式化字符串）与后续变参参数的匹配情况，以确保格式化字符串中的占位符与实际参数的类型相符。</p>
<p>这样，在调用 <code>LoG</code> 函数时，如果格式化字符串与实际参数不匹配，编译器会发出警告或错误信息，提醒开发者修正问题。</p>
<p>需要注意的是，<code>format</code> 属性对于编译器来说是一种提示，不会强制执行检查。因此，开发者仍需注意确保格式化字符串与实际参数的正确匹配，以避免潜在的错误。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.8 属性声明：aligned &amp; packed</title>
    <url>/2023/09/07/5-8-%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%EF%BC%9Aaligned-packed/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>属性声明 <code>aligned</code> 和 <code>packed</code> 是用于控制结构体或变量的对齐方式的特殊属性。</p>
<ol>
<li><p><code>aligned</code> 属性：<code>aligned</code> 属性用于指定结构体或变量的对齐方式。对齐方式是指变量在内存中的起始地址必须是某个特定值的倍数。这个特定值称为对齐边界。通过使用 <code>aligned</code> 属性，可以强制指定变量的对齐边界。</p>
<p>例如，以下示例将一个结构体 <code>my_struct</code> 按照 16 字节对齐：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">&#125; __attribute__((aligned(<span class="number">16</span>)));</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">在这个例子中，`aligned(<span class="number">16</span>)` 属性将结构体 `my_struct` 的对齐边界设置为 <span class="number">16</span> 字节。这意味着结构体的起始地址必须是 <span class="number">16</span> 的倍数。</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>packed</code> 属性：<code>packed</code> 属性用于指定结构体或变量的紧凑布局，即取消对齐。默认情况下，结构体的成员按照其自然对齐边界进行对齐，以提高内存访问效率。但有时，我们需要取消对齐，以减小结构体的大小或与其他系统进行数据交互。</p>
<p>例如，以下示例将一个结构体 <code>my_struct</code> 设置为紧凑布局：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">在这个例子中，`packed` 属性将结构体 `my_struct` 设置为紧凑布局，取消了成员的对齐。这意味着结构体的大小可能会减小，但访问成员时可能会带来性能开销。</span><br></pre></td></tr></table></figure></li>
</ol>
<p>需要注意的是，使用 <code>aligned</code> 和 <code>packed</code> 属性可能会对内存访问效率和可移植性产生影响。对齐和紧凑布局的选择应根据具体的需求和平台要求进行权衡。此外，这些属性的语法可能因编译器而异，应查阅相应的文档以确保正确使用。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.7 属性声明：section</title>
    <url>/2023/09/07/5-7-%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%EF%BC%9Asection/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>属性（Attributes）是一种在C语言中使用的特殊语法，用于声明变量或函数的特殊属性，以指导编译器进行特定方面的优化或代码检查。</p>
<p>在C语言中，可以使用 <code>__attribute__</code> 关键字来声明属性。属性可以在变量或函数的声明后面使用，通过 <code>__attribute__((ATTRIBUTE))</code> 的语法进行指定。</p>
<p>例如，假设有以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int global_val __attribute__((section(&quot;.data&quot;)));</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>global_val</code> 是一个整型变量，通过 <code>__attribute__((section(&quot;.data&quot;)))</code> 指定了它的属性。</p>
<p>这里使用的属性是 <code>section</code>，它的作用是将 <code>global_val</code> 变量放置在指定的内存段（section）中。具体地，<code>section(&quot;.data&quot;)</code> 表示将 <code>global_val</code> 放置在名为 “.data” 的内存段中。</p>
<p>属性的主要用途包括但不限于以下几个方面：</p>
<ol>
<li>优化：通过属性，可以告知编译器一些额外的信息，以便进行特定的优化。例如，可以指定变量的对齐方式、内联函数等，以优化程序的执行效率。</li>
<li>警告检查：属性还可以用于启用或禁用编译器的警告检查。通过指定特定的属性，可以控制编译器在编译过程中产生的警告信息。</li>
<li>内存布局：属性可以用于控制变量或函数在内存中的位置。可以指定变量存放在特定的内存段中，或者指定函数使用特定的调用约定。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.6 零长度数组</title>
    <url>/2023/09/07/5-6-%E9%9B%B6%E9%95%BF%E5%BA%A6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这个例子展示了C语言中的零长度数组的用法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> *<span class="title">buf</span>;</span></span><br><span class="line">    buf = (<span class="keyword">struct</span> buffer*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> buffer) + <span class="number">20</span>);</span><br><span class="line">    buf-&gt;len = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size: %d\n&quot;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">strcpy</span>(buf-&gt;a, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(buf-&gt;a);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，定义了一个结构体 <code>buffer</code>，它包含一个整型变量 <code>len</code> 和一个零长度数组 <code>a</code>。</p>
<p>零长度数组是C语言中的一种特殊用法，它的长度为0，也就是没有元素。它通常用于结构体的最后一个成员，用于实现动态大小的数组。</p>
<p>在 <code>main</code> 函数中，首先通过调用 <code>malloc</code> 动态分配了一块内存，大小为 <code>sizeof(struct buffer) + 20</code>。这里的 <code>20</code> 表示额外的数据空间，用于存储字符串 “hello world”。</p>
<p>然后，将分配的内存地址强制转换为 <code>struct buffer*</code> 类型，并将其赋给指针变量 <code>buf</code>。</p>
<p>接下来，通过 <code>buf-&gt;len = 20</code>，将结构体成员 <code>len</code> 的值设置为 <code>20</code>。</p>
<p>然后，通过 <code>printf</code> 打印了指针变量 <code>buf</code> 的大小，即 <code>sizeof(buf)</code>。请注意，这里打印的是指针变量 <code>buf</code> 的大小，而不是结构体 <code>buffer</code> 的大小。因为指针变量的大小在不同的系统上是固定的，一般为 4 或 8 字节，不会随着结构体的大小而变化。</p>
<p>随后，通过 <code>strcpy</code> 将字符串 “hello world” 复制到结构体成员 <code>a</code> 中。</p>
<p>最后，通过 <code>puts</code> 打印结构体成员 <code>a</code> 中的字符串。</p>
<p>最后，通过 <code>free</code> 释放了之前动态分配的内存。</p>
<p>这个例子展示了零长度数组的一种使用方式，它允许在结构体中动态存储变长数据。需要注意的是，零长度数组只是一种技巧，并不是C语言标准中的定义。因此，使用零长度数组时需要注意编译器的兼容性和可移植性。</p>
<p>ShareLikeDislike</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.5 container_of</title>
    <url>/2023/09/07/5-5-container-of/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>container_of</code> 是一个在内核开发中常用的宏，用于根据结构体成员的地址获取整个结构体的首地址。</p>
<p>它的一般语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">container_of(ptr, type, member)</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>ptr</code> 是一个指向结构体成员的指针。</li>
<li><code>type</code> 是结构体的类型。</li>
<li><code>member</code> 是结构体中的成员名称。</li>
</ul>
<p><code>container_of</code> 宏会根据给定的结构体成员的地址 <code>ptr</code>，计算出整个结构体的首地址，并返回该地址。</p>
<p>在您提供的示例中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct student &#123;</span><br><span class="line">    int age;</span><br><span class="line">    int num;</span><br><span class="line">    int math;</span><br><span class="line">&#125; stu;</span><br><span class="line"></span><br><span class="line">p = container_of(&amp;stu.num, struct student, num);</span><br></pre></td></tr></table></figure>

<p>这段代码的目的是根据 <code>stu.num</code> 的地址获取整个 <code>struct student</code> 结构体的首地址，并将该地址赋给变量 <code>p</code>。</p>
<p>假设 <code>stu.num</code> 的地址为 <code>0x1000</code>，那么 <code>container_of</code> 宏会计算出 <code>stu</code> 的首地址为 <code>0x1000 - offset</code>，其中 <code>offset</code> 是 <code>num</code> 成员在 <code>struct student</code> 结构体中的偏移量。然后，将该地址赋给变量 <code>p</code>。</p>
<p>请注意，<code>container_of</code> 宏是在内核开发中使用的，不是标准的C语言库函数。它依赖于结构体成员在结构体中的布局和字节对齐方式。因此，在普通的应用程序开发中，一般不会使用 <code>container_of</code> 宏。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.4 typeof</title>
    <url>/2023/09/07/5-4-typeof/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>typeof</code> 是一个宏，在C语言中用于获取一个表达式或类型的类型。</p>
<p><code>typeof</code> 宏的参数可以是表达式或类型。如果参数是表达式，<code>typeof</code> 宏将返回该表达式的类型。如果参数是类型，<code>typeof</code> 宏将返回该类型。</p>
<p>以下是您提供的使用示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line">typeof(i) j = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>typeof(i)</code> 返回变量 <code>i</code> 的类型，然后将其用于声明变量 <code>j</code>。这意味着 <code>j</code> 的类型与 <code>i</code> 的类型相同，并且被初始化为 <code>20</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typeof(<span class="type">int</span> *) a;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>typeof(int *)</code> 返回 <code>int *</code> 类型。然后，该类型被用于声明变量 <code>a</code>，即 <code>a</code> 是一个指向整数的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">typeof(f()) k;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>typeof(f())</code> 返回函数 <code>f</code> 的返回类型。然后，该类型被用于声明变量 <code>k</code>，即 <code>k</code> 具有与函数 <code>f</code> 的返回类型相同的类型。</p>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><ol>
<li><code>typeof (int*);</code><br>这段代码使用 <code>typeof</code> 获取 <code>int*</code> 的类型，但没有将其用于任何声明或赋值操作。因此，它本身并没有实际意义。</li>
<li><code>typeof (int)*y;</code><br>这段代码将 <code>y</code> 定义为指向 <code>int</code> 类型的指针。由于 <code>typeof (int)</code> 返回 <code>int</code> 类型，因此这行代码等效于 <code>int *y;</code>。</li>
<li><code>typeof(*x) y;</code><br>这段代码将 <code>y</code> 定义为指针 <code>x</code> 指向的数据类型。 <code>typeof(*x)</code> 返回 <code>x</code> 指向的数据类型，因此这行代码等效于 <code>int y;</code>。</li>
<li><code>typeof (int)y[4];</code><br>这段代码定义了一个名为 <code>y</code> 的数组，数组元素的类型是 <code>int</code>，大小为 4。因此，这行代码等效于 <code>int y[4];</code>。</li>
<li><code>typeof (*x) y[4];</code><br>这段代码定义了一个名为 <code>y</code> 的数组，数组元素的类型是指针 <code>x</code> 指向的数据类型。由于 <code>typeof (*x)</code> 返回 <code>x</code> 指向的数据类型，因此这行代码等效于 <code>int *y[4];</code>，即 <code>y</code> 是一个指针数组，其中每个元素都是 <code>int*</code> 类型。</li>
<li><code>typeof (typeof (char *)[4]) y;</code><br>这段代码定义了一个名为 <code>y</code> 的字符指针数组，数组大小为 4。由于 <code>typeof (char*)</code> 返回 <code>char*</code> 类型，因此这行代码等效于 <code>char *y[4];</code>。</li>
<li><code>typeof(int x[4]) y;</code><br>这段代码定义了一个名为 <code>y</code> 的数组，数组元素的类型是 <code>int</code>，大小为 4。因此，这行代码等效于 <code>int y[4];</code>。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.3 语句表达式</title>
    <url>/2023/09/07/5-3-%E8%AF%AD%E5%8F%A5%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>语句表达式是一种特殊的表达式语法，它允许在一个表达式内部执行一系列语句，并返回最后一个表达式的值作为整个语句表达式的结果。</p>
<p>语句表达式的一般语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&#123; statement1; statement2; ...; last_expression; &#125;)</span><br></pre></td></tr></table></figure>

<p>在语句表达式中，可以包含多个语句，每个语句以分号分隔。这些语句可以是局部变量的声明、赋值语句、循环语句、条件语句、跳转语句等。</p>
<p>语句表达式的值是由最后一个表达式的值决定的。当整个语句表达式被求值时，会按照语句的顺序依次执行每个语句，直到达到最后一个表达式。最后一个表达式的值将作为整个语句表达式的结果返回。</p>
<p>以下是一个示例，展示了语句表达式的使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> result = (&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> z = x + y;</span><br><span class="line">    z; <span class="comment">// 最后一个表达式的值作为结果</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，语句表达式内部声明了三个局部变量 <code>x</code>、<code>y</code> 和 <code>z</code>，并计算了它们的和。最后一个表达式 <code>z</code> 的值被作为整个语句表达式的结果，并赋给变量 <code>result</code>。</p>
<p>语句表达式在某些情况下可以提供更灵活的编程方式，特别是在需要在表达式中执行复杂的语句序列时。但是，请注意，语句表达式是一个非标准的C语言扩展，在不同的编译器和平台上可能会有不同的支持程度。因此，在使用语句表达式时应该谨慎考虑可移植性和代码可读性</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.2 C标准发展过程及新增特性</title>
    <url>/2023/09/07/5-2-C%E6%A0%87%E5%87%86%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B%E5%8F%8A%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="5-2-1-预定义标识符"><a href="#5-2-1-预定义标识符" class="headerlink" title="5.2.1 预定义标识符"></a>5.2.1 预定义标识符</h1><ol>
<li><code>__DATE__</code>：该标识符表示当前源文件被编译时的日期，以字符串形式表示，格式为”MMM DD YYYY”。</li>
<li><code>__TIME__</code>：该标识符表示当前源文件被编译时的时间，以字符串形式表示，格式为”HH:MM:SS”。</li>
<li><code>__FILE__</code>：该标识符表示当前源文件的文件名，以字符串形式表示。</li>
<li><code>__func__</code>：该标识符表示当前函数的名称，以字符串形式表示。该标识符在C99标准中引入。</li>
<li><code>__FUNCTION__</code>：与<code>__func__</code>类似，也表示当前函数的名称，但在某些编译器中使用。</li>
<li><code>__LINE__</code>：该标识符表示当前代码行的行号，以整数形式表示。</li>
<li><code>include</code>：这不是一个预定义标识符，而是一个预处理指令，用于包含头文件。</li>
<li><code>define</code>：也是一个预处理指令，用于定义宏。</li>
<li><code>_STDC_</code>：该标识符用于指示编译器是否遵循ANSI C标准。如果编译器遵循ANSI C标准，则该标识符被定义为整数常量1。</li>
<li><code>printf</code>&#x2F;<code>scanf</code>：这些是C语言中的标准库函数，用于格式化输入和输出。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.1 什么是C语言标准？</title>
    <url>/2023/09/07/5-1-%E4%BB%80%E4%B9%88%E6%98%AFC%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="5-1-C语言的标准"><a href="#5-1-C语言的标准" class="headerlink" title="5.1 C语言的标准"></a>5.1 C语言的标准</h1><p>C语言的标准版本主要有以下几个：</p>
<ol>
<li>K&amp;R C：指的是《The C Programming Language》一书中描述的C语言，由Brian Kernighan和Dennis Ritchie编写。这本书是C语言开发的里程碑，但它不是正式的标准。</li>
<li>ANSI C：也称为C89或C90，是由美国国家标准学会（ANSI）于1989年采纳的C语言标准。它是第一个被广泛接受的C语言标准，并且成为后续标准的基础。</li>
<li>C99：它是于1999年采纳的C语言标准，也称为C89的修订版。该标准引入了一些新特性，如新的数据类型（比如布尔类型和复数类型）、变长数组、单行注释等。</li>
<li>C11：于2011年采纳的C语言标准，它是C语言的最新标准。C11引入了一些新特性，如泛型选择表达式、多线程支持、原子操作和_Static_assert等。</li>
</ol>
<h1 id="5-2-C标准和编译器"><a href="#5-2-C标准和编译器" class="headerlink" title="5.2 C标准和编译器"></a>5.2 C标准和编译器</h1><p>不同的编译器对C标准的支持程度可能会有所差异。以下是一些常见的编译器以及它们对C标准的支持情况的概述：</p>
<p>GCC编译器：<br>GCC（GNU Compiler Collection）是一个开源的编译器套件，支持多种编程语言，包括C语言。GCC对C标准的支持相对较好，可以支持多个C标准版本，如C89、C99和C11。您可以使用命令行选项来指定所需的C标准版本，例如使用”-std&#x3D;c89”来编译符合C89标准的代码。</p>
<p>ARM编译器：<br>ARM公司提供了针对ARM架构的编译器套件，其中包括ARM Compiler和GNU ARM Embedded Toolchain。这些编译器通常也支持多个C标准版本，具体取决于所使用的工具链版本和配置。</p>
<p>C51编译器：<br>C51是由Keil Software提供的针对8051系列微控制器的编译器。C51编译器主要支持ANSI C标准，即C89标准，但并不支持后续的C99或C11标准。</p>
<p>VC系列编译器：<br>VC（Visual C++）系列编译器是Microsoft Visual Studio提供的编译器套件。VC编译器对C标准的支持程度在不同版本中可能有所差异。早期版本的VC编译器主要支持C89标准，而较新的版本逐渐增加了对C99和部分C11特性的支持。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>gun扩展语法</tag>
      </tags>
  </entry>
  <entry>
    <title>4-16-实战&amp;作业：实现自己的堆管理器</title>
    <url>/2023/09/07/4-16-%E5%AE%9E%E6%88%98-%E4%BD%9C%E4%B8%9A%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-15-常见内存错误及检测</title>
    <url>/2023/09/07/4-15-%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF%E5%8F%8A%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-14-内存泄露与防范</title>
    <url>/2023/09/07/4-14-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B8%8E%E9%98%B2%E8%8C%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-13-Linux堆内存管理(3)：内存申请释放示例</title>
    <url>/2023/09/07/4-13-Linux%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-3-%EF%BC%9A%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E9%87%8A%E6%94%BE%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-12-linux堆内存管理(2)：内存申请与释放</title>
    <url>/2023/09/07/4-12-linux%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-2-%EF%BC%9A%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E4%B8%8E%E9%87%8A%E6%94%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-11-Linux堆内存管理(1)：内存分配器</title>
    <url>/2023/09/07/4-11-Linux%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-1-%EF%BC%9A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="4-11-1-Linux系统的堆"><a href="#4-11-1-Linux系统的堆" class="headerlink" title="4.11.1 Linux系统的堆"></a>4.11.1 Linux系统的堆</h1><p>在Linux系统中，堆地址空间通常位于用户空间，其大小受到多种因素的影响。以下是一些相关概念和信息：</p>
<ol>
<li>堆的空间分配：<ul>
<li>在Linux 2.4及之前的版本中，堆的起始地址通常是0x40000000。共享库被分配在该地址空间中，程序会被加载到这个地址空间中。</li>
<li>在Linux 2.6及之后的版本中，共享库的地址被移动到栈的附近（大约是0xBFxxxxxx附近），而堆的大小则有更多的灵活性。</li>
</ul>
</li>
<li>理论上的堆空间大小：<ul>
<li>在Linux系统中，用户空间的虚拟地址空间大小通常是2.9GB。这意味着理论上堆可以占据整个用户空间的一部分。</li>
</ul>
</li>
<li>brk和堆顶（SP）：<ul>
<li>在Linux系统中，使用<code>brk</code>系统调用来扩展或收缩堆的大小。<code>brk</code>系统调用将堆的顶部（堆顶）移动到指定的地址处。</li>
<li>堆顶（SP）是指当前堆的顶部地址，它指示了堆的结束位置。</li>
</ul>
</li>
<li>内核空间和用户空间：<ul>
<li>在Linux系统中，虚拟地址空间被分为内核空间和用户空间。内核空间是操作系统内核的专用区域，用户空间是供用户程序执行的区域。</li>
<li>堆地址空间位于用户空间，而内核空间用于操作系统内核和驱动程序。</li>
</ul>
</li>
</ol>
<h1 id="4-11-2-堆管理策略"><a href="#4-11-2-堆管理策略" class="headerlink" title="4.11.2 堆管理策略"></a>4.11.2 堆管理策略</h1><p>在堆的管理策略方面，以下是一些常见的方法：</p>
<ol>
<li>系统调用：<ul>
<li>在Linux系统中，内核负责管理整个虚拟地址空间的权限和地址转换。malloc和free等内存管理函数的底层实现通常通过系统调用来向内核申请和释放内存。</li>
<li>当程序调用malloc时，底层实现会使用系统调用（如brk或mmap）向内核请求一块适当大小的内存块。类似地，当调用free时，底层实现会通过系统调用将内存块返回给内核。</li>
</ul>
</li>
<li>内存管理器：<ul>
<li>内存管理器是一个软件模块，负责在应用程序中管理动态分配的内存。它可以包含一系列算法和数据结构，用于分配、回收和管理内存块。</li>
<li>内存管理器可以实现不同的策略，如内存池、分配器、垃圾回收等。这些策略可以根据应用程序的需求来优化内存使用效率和性能。</li>
</ul>
</li>
</ol>
<p>在具体实现中，系统调用和内存管理器可以结合使用。系统调用提供了与内核交互的底层接口，而内存管理器则在应用程序层面上提供更高级的内存管理功能。</p>
<p>关于地址空间布局，您提到的堆、栈和内核空间的位置是一种典型的布局。堆通常处于低地址空间，栈位于高地址空间，而内核空间则是供操作系统内核和驱动程序使用的区域。具体的地址空间布局可能会因操作系统和配置而有所差异。</p>
<h1 id="4-11-3-Glibc堆内存管理"><a href="#4-11-3-Glibc堆内存管理" class="headerlink" title="4.11.3 Glibc堆内存管理"></a>4.11.3 Glibc堆内存管理</h1><p>在Glibc中，使用ptmalloc2作为默认的堆内存分配器，用于管理动态分配的内存。下面是关于Glibc堆内存管理的一些要点：</p>
<ol>
<li>内存分配器：<ul>
<li>Glibc使用ptmalloc2作为默认的内存分配器，它是一个基于二叉树的分配器。它负责管理堆内存，并提供malloc、free等API供用户程序使用。</li>
</ul>
</li>
<li>系统调用：<ul>
<li>Glibc通过系统调用（如brk和mmap）向内核请求内存。brk系统调用用于调整堆的大小，mmap系统调用用于在堆外部映射更大的内存块。</li>
<li>brk系统调用可以按需增加或减小堆的大小，而mmap系统调用可以获取更大的内存区域。</li>
</ul>
</li>
<li>内存管理：<ul>
<li>Glibc的内存分配器会管理用户程序释放的空闲内存，以便在以后的内存分配中重用。这有助于减少频繁进行系统调用的开销，提高内存分配的性能。</li>
</ul>
</li>
</ol>
<p>关于地址空间布局，您提到的堆、栈和内核空间的位置是一种典型的布局。堆通常位于低地址空间，栈位于高地址空间，而内核空间则是操作系统内核和驱动程序的使用区域。具体的地址空间布局可能会因操作系统和配置而有所不同。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-10-ucos堆内存管理</title>
    <url>/2023/09/07/4-10-ucos%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在使用uC&#x2F;OS（Microcontroller Operating System）时，可以采用以下基本策略来进行内存管理：</p>
<ol>
<li>将堆内存分成若干区：<ul>
<li>首先，将可用的堆内存划分为若干个区域。每个区域可以有不同的大小和属性，以满足不同的内存需求。</li>
</ul>
</li>
<li>每个区分为若干大小相等的内存块：<ul>
<li>在每个区域内，将可用的内存划分为若干大小相等的内存块。这些内存块具有相同的大小，可以根据需要进行申请和释放。</li>
</ul>
</li>
<li>程序以内存块为单位对内存进行申请&#x2F;释放：<ul>
<li>程序在运行时以内存块为单位来申请和释放内存。通过使用特定的函数（如malloc和free），可以从内存块池中获取一个可用的内存块，并在不再需要时将其释放。</li>
</ul>
</li>
<li>指向下一个内存块：<ul>
<li>在内存块的数据结构中，可以包含一个指针字段，用于指向下一个可用的内存块。这样，在申请内存时，可以遍历内存块链表，找到合适大小的内存块并返回给程序。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-9-堆内存管理：内存申请与释放</title>
    <url>/2023/09/07/4-9-%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E4%B8%8E%E9%87%8A%E6%94%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="4-9-1-什么是堆"><a href="#4-9-1-什么是堆" class="headerlink" title="4.9.1 什么是堆"></a>4.9.1 什么是堆</h1><p>堆是程序运行时动态分配内存的一种区域。下面是对堆的说明：</p>
<ol>
<li>动态分配内存：<ul>
<li>堆是通过使用动态内存分配函数（如malloc、calloc等）从操作系统中获取的内存区域。</li>
<li>程序员可以根据需要在堆上动态分配内存，以存储变量、数据结构、对象等。</li>
<li>堆内存的大小可以根据实际需求进行动态扩展或缩减。</li>
</ul>
</li>
<li>内存管理：<ul>
<li>程序员负责在堆上申请所需的内存空间，并在不再需要时显式地释放内存，以避免内存泄漏。</li>
<li>堆内存的申请和释放通常是通过调用相应的内存管理函数（如malloc和free）来完成的。</li>
</ul>
</li>
</ol>
<p>堆与栈的区别：</p>
<ol>
<li>访问方式：<ul>
<li>堆内存中的内容是匿名的，没有直接的名称或标识符，无法按名字直接访问。程序员通过指针间接访问堆内存中的数据。</li>
<li>栈上的数据和变量可以通过其名称直接访问。</li>
</ul>
</li>
<li>生命周期：<ul>
<li>堆内存的生命周期由程序员自行管理。在动态分配内存后，程序员需要负责在适当的时候显式释放堆内存，以防止内存泄漏。</li>
<li>栈上的数据和变量的生命周期与其所在的函数相关。当函数返回时，栈上的数据会被自动释放，无法继续使用。</li>
</ul>
</li>
</ol>
<p>需要注意的是，如果程序员在堆上分配了内存但没有显式释放，这部分内存会一直存在，直到程序结束才会被操作系统回收。这可能导致内存泄漏，造成系统资源的浪费。</p>
<p>堆的动态分配和释放机制为程序提供了更大的灵活性和动态性，允许动态地管理内存，并根据需要进行内存的分配和释放。然而，这也需要程序员负责正确地管理堆内存，以避免内存泄漏和其他内存相关的问题。</p>
<h1 id="4-9-2-嵌入式裸机环境堆管理"><a href="#4-9-2-嵌入式裸机环境堆管理" class="headerlink" title="4.9.2 嵌入式裸机环境堆管理"></a>4.9.2 嵌入式裸机环境堆管理</h1><p>在嵌入式裸机环境中，堆的管理通常依赖于C库函数和启动文件的设置。以下是一般的嵌入式裸机环境中堆的管理方式：</p>
<ol>
<li>使用C库函数 malloc&#x2F;free：<ul>
<li>嵌入式系统通常会提供C库函数（如stdlib.h中的malloc和free函数），用于动态分配和释放堆内存。</li>
<li>程序员可以使用这些函数来在堆上动态分配所需的内存块，并在不再需要时释放内存。</li>
</ul>
</li>
<li>堆的大小及初始化：<ul>
<li>在嵌入式系统中，堆的大小和初始化通常由启动文件（如start_xx.s）来处理。</li>
<li>启动文件负责初始化系统的各个部分，其中包括堆的初始化。</li>
<li>启动文件会根据设定的堆大小，在适当的位置分配堆空间，并进行必要的初始化。</li>
</ul>
</li>
<li>设置堆的大小：<ul>
<li>堆的大小可以通过在启动文件中的_main函数中使用_user_initial_stackheap来获取堆栈地址。</li>
<li>_user_initial_stackheap函数会返回堆栈地址，在_main函数中可以使用这个地址来设置堆的大小。</li>
</ul>
</li>
<li>堆空间地址设置：<ul>
<li>堆空间的地址可以由编译器默认获取，通常会将堆地址设置在ZI（Zero Initialized）区域的后面。</li>
<li>或者，堆空间的地址可以通过scatter文件进行设置，在汇编启动代码中对这段堆空间进行初始化。</li>
</ul>
</li>
</ol>
<h1 id="4-9-3-内存碎片"><a href="#4-9-3-内存碎片" class="headerlink" title="4.9.3 内存碎片"></a>4.9.3 内存碎片</h1><p>内存碎片是指在内存中存在的一些零散的未被利用的内存空间。以下是关于内存碎片的产生以及相应的编程建议：</p>
<ol>
<li><p>内存碎片的产生：</p>
<ul>
<li>内存碎片通常是由于频繁地申请和释放内存导致的。当程序频繁地进行内存分配和释放操作时，会导致内存中出现大量的零散空闲区域，这些零散的空闲区域无法满足大块内存的需求。</li>
<li>内存碎片的产生也可能是由于内存分配算法的问题，如使用不合理的内存分配策略或算法，导致内存空间被分割成多个不连续的小块。</li>
</ul>
</li>
<li><p>编程建议：</p>
<ul>
<li>在裸机环境中尽量避免频繁使用malloc和free函数进行动态内存分配和释放。由于裸机环境资源有限，内存碎片可能会更加严重，频繁的内存分配和释放操作可能导致系统性能下降、内存耗尽或系统崩溃等问题。</li>
<li>尽量使用静态数组代替频繁的内存分配和释放操作。静态数组在编译时就被分配在固定的内存位置上，避免了动态分配和释放带来的内存碎片问题。</li>
<li>针对需要动态管理数据结构的情况，可以预先分配一块足够大的内存池，并手动管理内存的分配和释放。内存池可以是一个静态数组，程序员可以通过索引或指针来管理内存的使用，避免了频繁的内存分配和释放操作。</li>
</ul>
<h1 id="4-9-4-解决之道"><a href="#4-9-4-解决之道" class="headerlink" title="4.9.4 解决之道"></a>4.9.4 解决之道</h1></li>
</ol>
<p>解决内存碎片问题可以根据需求采取以下方法：</p>
<ol>
<li>内存池：<ul>
<li>内存池是一种固定大小的缓冲区，预先分配一定数量的内存块，然后根据需要从内存池中分配和释放内存。</li>
<li>内存池可以避免内存碎片问题，因为它使用固定大小的内存块，不会产生零散的内存碎片。</li>
<li>程序员可以根据需求，预先分配适当大小的内存池，通过索引或指针来管理内存的分配和释放。</li>
</ul>
</li>
<li>堆分配：<ul>
<li>在一些情况下，需要申请不同大小的内存缓冲区。可以使用堆分配（如malloc和free）来动态地申请和释放内存。</li>
<li>在使用堆分配时，可以考虑使用内存池的方式来管理堆内存，以避免频繁的内存碎片问题。</li>
</ul>
</li>
<li>不同系统平台的解决方案：<ul>
<li>在裸机平台上，没有操作系统的支持，程序员需要自己实现内存管理方案。可以根据需求选择合适的内存管理策略，如内存池或其他自定义的管理方式。</li>
<li>在操作系统平台上，可以让操作系统介入内存管理。操作系统提供了内存管理功能，可以动态分配和释放内存，并且通常有更高级的内存管理算法来优化内存的使用。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-8-实战：栈溢出攻击示例</title>
    <url>/2023/09/07/4-8-%E5%AE%9E%E6%88%98%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-7-栈溢出攻击原理</title>
    <url>/2023/09/07/4-7-%E6%A0%88%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-6-栈与作用域</title>
    <url>/2023/09/07/4-6-%E6%A0%88%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="4-6-1-变量的作用域和生命周期"><a href="#4-6-1-变量的作用域和生命周期" class="headerlink" title="4.6.1 变量的作用域和生命周期"></a>4.6.1 变量的作用域和生命周期</h1><p>变量的作用域和生命周期是关于变量可见性和存在时间的概念。下面是关于全局变量和局部变量的说明：</p>
<ol>
<li>全局变量：<ul>
<li>全局变量是在函数外部定义的变量，可以被整个程序中的函数访问和使用。</li>
<li>全局变量的作用域从其声明处开始，延伸到文件的结尾。这意味着它可以在声明处之后的任何位置使用。</li>
<li>全局变量可以在一个源文件中定义，然后通过在其他源文件中使用 <code>extern</code> 关键字进行声明和引用。</li>
</ul>
</li>
</ol>
<p>示例代码：</p>
<p>c</p>
<p>Copy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// file.c</span><br><span class="line">int a = 10;  // 在文件中定义全局变量</span><br><span class="line"></span><br><span class="line">// file2.c</span><br><span class="line">extern int a;  // 在另一个文件中使用 extern 关键字声明并引用全局变量</span><br><span class="line">printf(&quot;%d&quot;, a);</span><br></pre></td></tr></table></figure>

<ol>
<li>局部变量：<ul>
<li>局部变量是在函数体内部定义的变量，它们的作用域仅限于所在的函数内部。</li>
<li>局部变量只能在定义它们的函数内部使用，无法在函数外部访问。</li>
<li>局部变量的生命周期从函数被调用开始，到函数执行结束为止。每次函数调用时都会创建一个新的局部变量实例。</li>
</ul>
</li>
</ol>
<p>示例代码：</p>
<p>c</p>
<p>Copy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void myFunction() &#123;</span><br><span class="line">  int b = 20;  // 在函数内部定义局部变量</span><br><span class="line">  // 可以在函数内部使用局部变量b</span><br><span class="line">  // 局部变量的生命周期仅限于函数执行期间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局变量和局部变量的选择取决于变量在程序中的使用需求。全局变量具有全局可见性，可以在多个函数中共享，但会增加命名空间的复杂性。而局部变量具有更小的作用域和生命周期，对于只在函数内部使用的临时数据更加合适。</p>
<h1 id="4-6-2-为什么程序不能访问其他函数内的局部变量"><a href="#4-6-2-为什么程序不能访问其他函数内的局部变量" class="headerlink" title="4.6.2 为什么程序不能访问其他函数内的局部变量"></a>4.6.2 为什么程序不能访问其他函数内的局部变量</h1><p>程序不能访问其他函数内的局部变量的原因主要有两点：</p>
<ol>
<li>内存空间的分配：<ul>
<li>局部变量在函数被调用时才会在栈内分配内存空间。</li>
<li>每个函数都有自己的栈帧，用于存储局部变量和其他函数调用所需的信息。</li>
<li>当函数执行完毕，栈帧会被释放，局部变量所占用的内存空间也会被回收。</li>
</ul>
</li>
<li>作用域和生命周期：<ul>
<li>局部变量的作用域仅限于所在的函数内部，无法在函数外部访问。</li>
<li>在函数内部声明的局部变量只在函数运行期间有效，在函数执行完毕后就会被销毁。</li>
<li>其他函数无法直接访问该函数内部的局部变量，因为局部变量的作用域仅限于所在函数。</li>
</ul>
</li>
</ol>
<p>由于局部变量的内存空间是在函数调用时动态分配的，并且作用域和生命周期仅限于函数的执行过程，所以其他函数无法直接访问该函数的局部变量。如果需要在函数之间传递数据或共享变量，可以使用函数参数、全局变量或其他数据传递方式来实现。</p>
<h1 id="4-6-3-编译器栈管理"><a href="#4-6-3-编译器栈管理" class="headerlink" title="4.6.3 编译器栈管理"></a>4.6.3 编译器栈管理</h1><p>编译器通过栈管理来处理函数调用和局部变量的作用域。下面是对编译器栈管理的简要说明：</p>
<ol>
<li>函数调用：<ul>
<li>当一个函数被调用时，编译器会在栈上为该函数分配一个栈帧（也称为活动记录或帧）。</li>
<li>栈帧包含了该函数的局部变量、函数参数、返回地址和其他与函数调用相关的信息。</li>
<li>编译器通过在栈上进行压栈操作将栈帧入栈，以便在函数执行期间使用。</li>
</ul>
</li>
<li>局部变量的作用域：<ul>
<li>编译器通过栈帧的创建和销毁来限定局部变量的作用域。</li>
<li>在函数内部定义的局部变量只在函数执行期间存在，它们的内存空间位于函数的栈帧中。</li>
<li>当函数执行完毕时，编译器通过出栈操作销毁栈帧，同时销毁其中的局部变量，使其作用域终止。</li>
</ul>
</li>
</ol>
<p>编译器根据函数的调用关系和变量的作用域确定栈帧的分配和释放。每个函数的栈帧在栈上按照调用顺序依次入栈和出栈，保证了函数调用的正确执行和局部变量的正确作用域。这种栈管理机制使得函数可以嵌套调用，并且每个函数都有自己独立的局部变量空间，避免了命名冲突和数据混乱的问题。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-5-形参与实参</title>
    <url>/2023/09/07/4-5-%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="4-5-1-形参和实参"><a href="#4-5-1-形参和实参" class="headerlink" title="4.5.1 形参和实参"></a>4.5.1 形参和实参</h1><p>在函数调用过程中，形参（形式参数）和实参（实际参数）是用于传递数据的两个概念。下面是关于形参和实参的一些说明：</p>
<ol>
<li>形参：<ul>
<li>形参是在函数定义时声明的参数，用于在函数内部接收传递给函数的实参的值。</li>
<li>形参在函数内部被视为局部变量，可以在函数中使用和修改。</li>
<li>形参的作用是定义函数的参数类型和名称，以便在函数内对参数进行操作。</li>
</ul>
</li>
<li>实参：<ul>
<li>实参是在函数调用时传递给函数的值，可以是常量、变量、表达式或函数等。</li>
<li>实参的值会被传递给对应的形参，作为函数在执行过程中操作的数据。</li>
<li>实参的值在函数调用时确定，并被传递给形参，不会受到形参的修改影响。</li>
</ul>
</li>
</ol>
<p>形参值的改变并不能改变实参的原因可以从汇编代码的角度来分析。在函数调用过程中，实参的值被复制到栈或寄存器中，供函数内部使用。形参在函数内部作为局部变量存储，其值的改变只会影响函数内部的局部变量，而不会改变实参的值。</p>
<p>具体来说，汇编代码中的函数调用过程通常包括以下步骤：</p>
<ol>
<li>将实参的值通过寄存器或栈传递给函数。</li>
<li>在函数内部，实参的值被复制到函数的局部变量（即形参）中。</li>
<li>函数在执行过程中操作的是形参的值，而不是实参的值。</li>
<li>形参的值的改变只会影响函数内部的局部变量，不会影响实参的值。</li>
</ol>
<h1 id="4-5-2-为什么形参的改变不能改变实参"><a href="#4-5-2-为什么形参的改变不能改变实参" class="headerlink" title="4.5.2 为什么形参的改变不能改变实参?"></a>4.5.2 为什么形参的改变不能改变实参?</h1><p>形参的改变不能直接改变实参的值是因为它们在函数调用时位于不同的内存存储单元，并且实参的值被拷贝到形参的内存空间中。下面是更详细的解释：</p>
<ol>
<li>内存分配和释放：<ul>
<li>形参在函数调用时被创建，并在函数调用结束后被销毁。它们的内存分配和释放是自动进行的。</li>
<li>实参是在函数调用之前已经存在的变量或值，它们的内存分配和释放与函数调用无关。</li>
</ul>
</li>
<li>内存空间的分离：<ul>
<li>形参和实参通常位于不同的内存存储单元中。当函数被调用时，实参的值会被拷贝到形参的内存空间中。</li>
<li>形参在函数内部作为局部变量使用，并在函数执行期间修改它们的值。这些修改只会影响形参的值，而不会影响实参的值。</li>
</ul>
</li>
<li>值传递：<ul>
<li>在函数调用时，通过将实参的值拷贝到形参的内存空间中，实参和形参变成了两个相互独立的变量。</li>
<li>任何对形参的修改都只会影响形参本身，不会对实参产生任何影响。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-4-栈的管理：参数传递</title>
    <url>/2023/09/07/4-4-%E6%A0%88%E7%9A%84%E7%AE%A1%E7%90%86%EF%BC%9A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="4-4-1-参数传递和栈管理的常见规则"><a href="#4-4-1-参数传递和栈管理的常见规则" class="headerlink" title="4.4.1 参数传递和栈管理的常见规则"></a>4.4.1 参数传递和栈管理的常见规则</h1><p>对于栈的管理和参数传递，ARM架构遵循了ATPCS（ARM调用惯例）规则。以下是一些关于参数传递和栈管理的常见规则：</p>
<ol>
<li>参数传递：<ul>
<li>小于4个参数：使用寄存器RO~R3传递参数。参数依次存储在RO、R1、R2和R3寄存器中。</li>
<li>大于4个参数：剩余的参数按照从右到左的顺序压入栈中。首先将第5个参数压栈，然后是第6个参数，依此类推。</li>
</ul>
</li>
<li>返回值：<ul>
<li>函数的返回值通常存储在RO寄存器中。如果返回值是64位的，那么RO和R1两个寄存器一起存储返回值。</li>
</ul>
</li>
<li>函数参数入栈：<ul>
<li>被调用函数将寄存器RO~R3传递来的参数压栈保存。这样做是为了在被调用函数内部能够正确访问函数参数。</li>
</ul>
</li>
</ol>
<p>这些规则确保了参数的正确传递和函数调用的一致性。小于4个参数的情况下，参数直接传递到寄存器中，避免了频繁的内存访问。而大于4个参数的情况下，额外的参数通过栈进行传递。被调用函数将寄存器中的参数入栈保存，以便在函数内部能够访问和使用这些参数。</p>
<h1 id="4-4-2-调用惯例"><a href="#4-4-2-调用惯例" class="headerlink" title="4.4.2 调用惯例"></a>4.4.2 调用惯例</h1><p>函数调用的约定是编程语言或操作系统规定的一种规则，用于定义函数调用时参数传递、返回值处理以及栈的清理方式。下面是一般情况下的函数调用约定：</p>
<ol>
<li>函数调用双方的约定：<ul>
<li>函数调用者（caller）：调用函数的代码。</li>
<li>函数被调用者（callee）：被调用的函数。</li>
</ul>
</li>
<li>参数压栈方式：<ul>
<li>参数通常按照从右至左的顺序依次压入栈中，即最右边的参数先被压入栈。</li>
</ul>
</li>
<li>栈清理：<ul>
<li>调用者负责清理栈上的参数。这意味着在函数调用完成后，调用者会从栈上移除传递给被调用函数的参数。</li>
</ul>
</li>
<li>默认的调用惯例：<ul>
<li>在C语言中，默认的调用惯例是 cdecl（C declaration），也被称为标准调用约定。</li>
<li>参数传递：按照从右至左的顺序将参数压入栈中。</li>
<li>栈清理：由调用者负责清理栈上的参数。</li>
<li>返回值：通常通过寄存器进行返回，如整数类型的返回值使用 EAX 寄存器，浮点类型的返回值使用 ST0 寄存器。</li>
</ul>
</li>
</ol>
<p>好处：</p>
<ul>
<li>预先知道参数和返回值的大小，可以在函数调用前提前分配好栈空间或寄存器。</li>
<li>支持变参函数的调用，例如 <code>printf</code> 函数，它可以接受不定数量的参数。</li>
</ul>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-3-栈的管理：函数调用</title>
    <url>/2023/09/07/4-3-%E6%A0%88%E7%9A%84%E7%AE%A1%E7%90%86%EF%BC%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="4-3-1-栈的作用"><a href="#4-3-1-栈的作用" class="headerlink" title="4.3.1 栈的作用"></a>4.3.1 栈的作用</h1><ol>
<li>保存函数上下文：<br>当一个函数被调用时，当前函数的执行状态需要保存下来，以便在函数执行完毕后能够正确返回到调用者处继续执行。栈用于保存函数的上下文信息，包括调用者栈帧地址（Frame Pointer，FP）和返回地址（Link Register，LR）。FP指向调用者函数的栈帧，而LR保存了函数返回后应继续执行的地址。</li>
<li>保存局部变量：<br>函数中声明的局部变量通常存储在栈中。每当一个函数被调用时，栈会为该函数分配一块新的栈帧空间，用于存储函数的局部变量。这样可以确保每个函数都有自己独立的内存空间来保存局部变量，避免不同函数之间的变量冲突。</li>
<li>传递函数的参数：<br>函数调用时，参数值会被传递给被调用函数。在栈的帮助下，这些参数可以被正确地传递给被调用函数并被保存在适当的位置。通常，函数参数通过栈中的一定偏移量来进行传递和访问。</li>
<li>保存函数的参数：<br>在函数调用时，除了传递参数给被调用函数外，栈还负责保存函数的参数。这是因为函数的参数通常需要在函数执行过程中被访问和使用。栈的帮助下，函数可以在需要时方便地访问到其参数。</li>
</ol>
<h1 id="4-3-2-栈帧"><a href="#4-3-2-栈帧" class="headerlink" title="4.3.2 栈帧"></a>4.3.2 栈帧</h1><p>栈帧（Stack Frame）是在函数调用期间在栈上分配的一块连续内存区域，用于存储函数的局部变量、函数参数、返回地址等信息。每个函数调用都会创建一个新的栈帧，形成多个栈帧构成的调用栈。</p>
<p>栈帧由以下几个主要部分组成：</p>
<ol>
<li>Frame Pointer（FP）：也称为帧指针，是一个特殊的寄存器（在某些体系结构中为R11），用于指向上一层函数的栈帧的栈底。通过FP，可以在函数执行过程中轻松地访问上一级函数的局部变量和函数参数。</li>
<li>局部变量：栈帧中的一部分用于存储函数的局部变量。这些局部变量是在函数内部声明的变量，在函数执行期间可以被访问和修改。</li>
<li>函数参数：函数调用时传递给函数的参数值也存储在栈帧中。这些参数值通过栈帧进行传递和访问。</li>
<li>返回地址：在函数调用过程中，当函数执行完毕后需要返回到调用者处继续执行。返回地址用于保存函数返回后应继续执行的地址，通常保存在栈帧中。</li>
<li>临时存储区：栈帧还可以包含其他临时存储区，用于保存临时数据、寄存器的备份等。</li>
</ol>
<p>通过多个栈帧的连接，构成了某个进程的调用栈。每次函数调用时，当前函数的栈帧被创建并添加到调用栈的顶部，函数执行完毕后，栈帧被销毁，控制权返回到上一层函数。</p>
<p>栈帧的存在使得函数调用和返回过程能够正确执行，并且提供了函数内部数据的存储和访问机制，保证了函数的独立性和数据的正确性。</p>
<h1 id="4-3-3-ARM汇编指令"><a href="#4-3-3-ARM汇编指令" class="headerlink" title="4.3.3 ARM汇编指令"></a>4.3.3 ARM汇编指令</h1><ol>
<li>寄存器间接寻址：<ul>
<li><code>LDR RO, [R1,#4]</code>：将存储在地址<code>R1+4</code>处的数据加载到寄存器RO中。</li>
<li><code>LDR RO, [R1,#4]!</code>：将存储在地址<code>R1+4</code>处的数据加载到寄存器RO中，并将<code>R1</code>的值增加4。</li>
<li><code>LDR RO, [R1], #4</code>：将存储在地址<code>R1</code>处的数据加载到寄存器RO中，并将<code>R1</code>的值增加4。</li>
<li><code>LDR RO, [R1,R2]</code>：将存储在地址<code>R1+R2</code>处的数据加载到寄存器RO中。</li>
</ul>
</li>
<li>入栈出栈：<ul>
<li><code>PUSH &#123;FP,LR&#125;</code>：将FP（帧指针）和LR（链接寄存器）的值压入栈中。这通常用于保存函数的上下文信息。</li>
<li><code>POP &#123;FP,PC&#125;</code>：从栈中弹出值，将其赋给FP（帧指针）和PC（程序计数器）。这通常用于恢复函数的上下文信息并返回到调用者处。</li>
</ul>
</li>
</ol>
<p>在这些示例中，R1、R2、RO、FP和LR是ARM架构中的寄存器，SP代表栈指针。这些指令用于实现寄存器间接寻址和栈操作，以便在汇编语言中实现数据的加载和存储，以及函数的调用和返回。请注意，这只是一些常见的示例，ARM汇编指令非常丰富，具体的使用和语法可能因特定的应用场景和编译器而有所不同。</p>
<h1 id="4-3-4-栈举例-函数调用"><a href="#4-3-4-栈举例-函数调用" class="headerlink" title="4.3.4 栈举例:函数调用"></a>4.3.4 栈举例:函数调用</h1><p>以下是一个简单的函数调用的示例，展示了在函数调用过程中栈的使用情况：</p>
<p>假设有两个函数，函数A调用函数B。</p>
<ol>
<li>函数A的栈帧：<ul>
<li>FP（帧指针）指向上一层函数的栈帧的栈底。</li>
<li>LR（返回地址）保存着函数A调用完函数B后应继续执行的地址。</li>
<li>局部变量和函数参数存储在栈帧中。</li>
<li>临时存储区用于保存临时数据。</li>
</ul>
</li>
<li>函数B的栈帧：<ul>
<li>FP指向函数A的栈帧的栈底。</li>
<li>LR保存着函数B调用完后应继续执行的地址。</li>
<li>局部变量和函数参数存储在栈帧中。</li>
<li>临时存储区用于保存临时数据。</li>
</ul>
</li>
</ol>
<p>函数调用过程示例：</p>
<ol>
<li>函数A开始执行：<ul>
<li>函数A的栈帧被创建并压入栈中，包括FP、LR、局部变量和函数参数。</li>
<li>函数A执行过程中可能对局部变量进行读写操作。</li>
</ul>
</li>
<li>函数A调用函数B：<ul>
<li>函数A将函数参数传递给函数B，参数存储在函数B的栈帧中。</li>
<li>函数A将LR的值设置为调用函数B后应继续执行的地址。</li>
<li>函数A跳转到函数B的入口地址开始执行。</li>
</ul>
</li>
<li>函数B开始执行：<ul>
<li>函数B的栈帧被创建并压入栈中，包括FP、LR、局部变量和函数参数。</li>
<li>函数B执行过程中可能对局部变量进行读写操作。</li>
</ul>
</li>
<li>函数B执行完毕：<ul>
<li>函数B将返回值存储在指定的寄存器中（例如R0）。</li>
<li>函数B将LR的值设置为返回地址，即函数A调用函数B的下一条指令地址。</li>
<li>函数B将栈帧释放，即出栈。</li>
</ul>
</li>
<li>函数A继续执行：<ul>
<li>函数A根据函数B的返回值进行下一步操作。</li>
<li>函数A将栈帧释放，即出栈。</li>
</ul>
</li>
</ol>
<p>在函数调用过程中，栈的使用和管理确保了函数的正确执行、局部变量的隔离和数据的传递。栈帧的创建和释放，以及栈指针的维护，保证了函数调用的顺序和返回的正确性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">30</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">40</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">4</span>;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-2-栈的初始化及大小</title>
    <url>/2023/09/07/4-2-%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="4-2-1-什么是栈"><a href="#4-2-1-什么是栈" class="headerlink" title="4.2.1 什么是栈"></a>4.2.1 什么是栈</h1><p>栈（Stack）是一种常见的数据结构，它遵循先进后出（FILO，First In Last Out）的原则。栈可以通过两个基本操作来操作元素：入栈（Push）和出栈（Pop）。</p>
<ol>
<li><p>入栈（Push）操作：</p>
<ul>
<li>入栈将一个元素添加到栈的顶部（也称为栈顶）。</li>
<li>入栈操作会将元素压入栈中，栈的大小增加。</li>
<li>入栈的元素成为新的栈顶。</li>
</ul>
</li>
<li><p>出栈（Pop）操作：</p>
<ul>
<li><p>出栈将栈顶的元素移除，并返回该元素。</p>
</li>
<li><p>出栈操作会将栈顶元素弹出，栈的大小减少。</p>
</li>
<li><p>出栈的元素是最近入栈的元素，即最后一个添加到栈中的元素。</p>
</li>
</ul>
<p>栈的操作可以用以下伪代码表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Push(<span class="built_in">stack</span>, element):</span><br><span class="line">    将元素添加到栈的顶部</span><br><span class="line">    栈的大小增加</span><br><span class="line">    新的栈顶指向添加的元素</span><br><span class="line"></span><br><span class="line">Pop(<span class="built_in">stack</span>):</span><br><span class="line">    如果栈为空，则抛出异常或返回特定值（取决于实现）</span><br><span class="line">    保存栈顶元素的值</span><br><span class="line">    将栈顶元素移除</span><br><span class="line">    栈的大小减少</span><br><span class="line">    返回保存的栈顶元素的值</span><br></pre></td></tr></table></figure>

<p>栈在计算机科学中有广泛的应用，例如函数调用栈、表达式求值、深度优先搜索等。由于栈的先进后出的特性，它可以提供简单有效的数据存储和访问方式。</p>
</li>
</ol>
<h1 id="4-2-2-线的作用"><a href="#4-2-2-线的作用" class="headerlink" title="4.2.2 线的作用"></a>4.2.2 线的作用</h1><ol>
<li><h2 id="函数调用："><a href="#函数调用：" class="headerlink" title="函数调用："></a>函数调用：</h2><ul>
<li>栈被广泛用于函数调用过程中的参数传递、局部变量和函数返回值的存储。</li>
<li>当一个函数被调用时，函数的参数会被压入栈中，然后函数的局部变量也会被分配在栈上。</li>
<li>函数执行完毕后，栈会按照相反的顺序弹出参数和局部变量，返回值也会通过栈传递回调用函数。</li>
</ul>
</li>
<li><h2 id="编译器生成的临时变量："><a href="#编译器生成的临时变量：" class="headerlink" title="编译器生成的临时变量："></a>编译器生成的临时变量：</h2><ul>
<li>编译器在编译过程中会生成一些临时变量，用于存储中间计算结果或其他需要临时存储的数据。</li>
<li>这些临时变量通常会被存储在栈上，随着程序的执行进入和离开作用域而动态地压入和弹出栈。</li>
</ul>
</li>
<li><h2 id="内存管理："><a href="#内存管理：" class="headerlink" title="内存管理："></a>内存管理：</h2><ul>
<li>栈的一部分常用于存储程序的调用栈，用于跟踪函数调用和返回的地址。</li>
<li>操作系统还使用栈来管理进程的堆栈空间，为每个线程和进程分配一块私有的栈空间。</li>
</ul>
</li>
<li><h2 id="表达式求值："><a href="#表达式求值：" class="headerlink" title="表达式求值："></a>表达式求值：</h2><ul>
<li>在编译器或解释器中，栈常用于表达式求值的过程中，用于存储运算符和操作数。</li>
<li>通过栈的先进后出的特性，可以按照正确的优先级和顺序对表达式进行求值。</li>
</ul>
</li>
</ol>
<h1 id="4-2-3-栈初始化"><a href="#4-2-3-栈初始化" class="headerlink" title="4.2.3 栈初始化"></a>4.2.3 栈初始化</h1><p>栈的初始化是在程序执行之前进行的，它涉及到栈指针的设置和栈空间的分配。具体的栈初始化过程可能因处理器架构和操作系统而有所差异。</p>
<p>下面是一些常见的栈初始化方式和相关的寄存器：</p>
<ol>
<li>ARM 架构：<ul>
<li>栈指针寄存器（Stack Pointer Register）：ARM 架构中的栈指针寄存器是 SP（R13）。</li>
<li>初始化栈指针：在启动时，操作系统或引导加载程序会设置 SP 寄存器的值，指向栈的初始位置。</li>
<li>帧指针寄存器（Frame Pointer Register）：ARM 架构中的帧指针寄存器是 FP（R11），用于访问函数的局部变量和参数。</li>
<li>在函数调用过程中，栈指针 SP 会动态地进行调整，而帧指针 FP 则用于指向当前函数的栈帧。</li>
</ul>
</li>
<li>x86 架构：<ul>
<li>栈指针寄存器（Stack Pointer Register）：x86 架构中的栈指针寄存器是 ESP（栈顶指针）和 EBP（栈底指针）。</li>
<li>初始化栈指针：在启动时，操作系统或引导加载程序会设置 ESP 寄存器的值，指向栈的初始位置。</li>
<li>在函数调用过程中，ESP 会动态地进行调整，用于栈帧的分配和释放。</li>
<li>基址指针寄存器（Base Pointer Register）：x86 架构中的基址指针寄存器是 EBP，用于在函数中访问局部变量和参数。</li>
</ul>
</li>
</ol>
<h1 id="4-2-4-栈的起始地址"><a href="#4-2-4-栈的起始地址" class="headerlink" title="4.2.4 栈的起始地址"></a>4.2.4 栈的起始地址</h1><p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309070809175.png" alt="image-20230907080956110"></p>
<p>栈的起始地址是根据操作系统和编译器的实现而定的。栈通常位于内存的高地址区域，并在程序执行前被初始化。</p>
<p>下面是一些常见的栈起始地址情况：</p>
<ol>
<li>用户空间：<ul>
<li>在用户空间的程序中，栈通常从高地址向低地址增长。</li>
<li>栈的起始地址可以是固定的，也可以在每次程序执行时动态分配。</li>
<li>在某些操作系统中，栈的起始地址可以通过随机偏移（Random Offset）来增加安全性，防止缓冲区溢出攻击。</li>
</ul>
</li>
<li>内核空间：<ul>
<li>在内核空间中，栈的起始地址通常是固定的，由操作系统内核决定。</li>
<li>内核栈用于处理中断、异常和系统调用等内核级别的任务。</li>
<li>内核栈的起始地址可能与用户空间的栈起始地址不同，且通常位于内核空间的高地址区域。</li>
</ul>
</li>
</ol>
<p>在一些特殊情况下，也可能使用其他内存区域作为栈的起始地址，例如堆（heap）或通过内存映射（mmap）分配的内存区域。但是，栈通常独立于堆和内存映射区域。</p>
<p>栈的英文是stack</p>
<h1 id="4-2-5-栈的大小"><a href="#4-2-5-栈的大小" class="headerlink" title="4.2.5 栈的大小"></a>4.2.5 栈的大小</h1><p>栈的大小是指栈所占用的内存空间大小。栈的大小在不同的操作系统和编译器中有所不同。</p>
<p>对于 Linux 操作系统的进程栈大小，可以使用 ulimit 命令来查看和设置。下面是相关命令的说明：</p>
<ul>
<li>查看堆栈大小：使用命令 <code>ulimit -s</code> 可以查看当前进程的堆栈大小限制。</li>
<li>设置堆栈大小：使用命令 <code>ulimit -s size</code> 可以设置当前进程的堆栈大小限制，其中 size 是以 KB 为单位的大小值。</li>
</ul>
<p>需要注意的是，增加堆栈容量会增加内存开销和启动时间。因此，需要合理配置堆栈大小，以满足程序的需求，同时避免浪费资源。</p>
<p>栈溢出（Stack Overflow）是指当栈空间不足以容纳新的栈帧时，导致栈指针超出了栈的边界。这通常发生在递归函数调用层次过深或者局部变量占用过多栈空间的情况下。当发生栈溢出时，会导致段错误（Segmentation Fault）或程序异常退出。</p>
<p>在最大堆栈大小的限制内，栈可以动态增长，即在需要时自动分配更多的栈空间。但是，若超过了最大堆栈大小限制，就会发生栈溢出。</p>
<p>栈溢出的实例可以是一个递归函数调用层次过深，或者一个函数中声明了大量的局部变量导致栈空间不足的情况。当栈溢出发生时，程序无法正确地管理栈帧，导致异常行为或崩溃。</p>
<p>为了避免栈溢出，应该合理控制递归深度、减少局部变量的使用或者使用动态内存管理（如堆）来存储大量数据。</p>
<p>总结：栈的大小在不同的操作系统和编译器中有所不同。在 Linux 操作系统中，可以使用 ulimit 命令来查看和设置进程的堆栈大小。增加堆栈容量会增加内存开销和启动时间，而栈溢出会导致段错误或程序异常退出。栈在最大堆栈大小内可以动态增长，但超过最大值会导致栈溢出。为了避免栈溢出，应合理控制递归深度、减少局部变量的使用或使用动态内存管理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>main</code>函数中声明了一个名为<code>a</code>的字符数组，其大小为8MB（8<em>1024</em>1024字节）。然后，你使用<code>printf</code>函数打印了一条”hello world!”的消息，并通过<code>return 0</code>语句结束了<code>main</code>函数。</p>
<p>需要注意的是，你在栈上声明了一个非常大的数组（8MB），这可能会导致栈溢出。栈的大小是有限的，并且在不同的操作系统和编译器中有所不同。默认情况下，大多数操作系统都有一个较小的栈大小限制。因此，声明过大的局部数组可能会导致栈溢出，导致程序崩溃。</p>
<p>如果你需要使用大量内存，建议使用堆分配（例如使用<code>malloc</code>函数）来动态分配内存空间，而不是在栈上声明大型数组。这样可以避免栈溢出的风险。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4-1-程序与内存的关系</title>
    <url>/2023/09/07/4-1-%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%86%85%E5%AD%98%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="4-1-1-虚拟地址空间"><a href="#4-1-1-虚拟地址空间" class="headerlink" title="4.1.1 虚拟地址空间"></a>4.1.1 虚拟地址空间</h1><p>Linux进程的内存映像包括虚拟地址空间、可执行文件的不同部分加载到内存的方式、内存管理以及内核空间。</p>
<ol>
<li>虚拟地址空间：每个Linux进程都有自己的虚拟地址空间，它是一个由连续虚拟地址组成的范围。虚拟地址空间将进程的内存分为不同的区域，包括代码段、数据段、堆、栈和映射区等。</li>
<li>所有程序的编译链接起始地址相同：在Linux中，所有程序的编译链接起始地址通常是相同的，默认为0x08048000。这是由于可执行文件的加载器将可执行文件的代码段加载到这个地址开始的内存区域。</li>
<li>可执行文件中的不同的section加载到读写权限不同的内存：可执行文件通常包含不同的部分，如代码段、数据段、BSS段等。这些不同的段在加载到内存时可能具有不同的读写权限。例如，代码段通常被设置为只读，数据段和BSS段可以被写入。</li>
<li>Linux通过MMU和页表来管理内存：Linux使用内存管理单元（Memory Management Unit，MMU）和页表来实现虚拟地址到物理地址的映射以及内存权限的管理。MMU将进程的虚拟地址转换为物理地址，并根据页表中的权限信息来管理内存的读写和执行权限。</li>
<li>内核空间：除了每个进程的虚拟地址空间之外，Linux还有一个特殊的内核空间，用于操作系统内核及其相关数据结构。内核空间的地址范围通常是高于用户进程的地址范围，进程无法直接访问或修改内核空间的内容，需要通过系统调用来与内核进行交互。</li>
</ol>
<h1 id="4-1-2-内核空间与用户空间"><a href="#4-1-2-内核空间与用户空间" class="headerlink" title="4.1.2 内核空间与用户空间"></a>4.1.2 内核空间与用户空间</h1><p>内核空间和用户空间是计算机操作系统中的两个重要概念，用于区分操作系统内核和用户应用程序的内存空间。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309070753828.png" alt="image-20230907075313755"></p>
<ol>
<li>内核空间：<ul>
<li>所有进程的内核空间都映射到相同的物理内存区域。</li>
<li>内核空间包含操作系统内核及其相关数据结构，例如设备驱动程序、调度器、文件系统等。</li>
<li>进程无法直接访问或修改内核空间的内容，需要通过系统调用接口与内核进行交互。</li>
<li>内核空间通常位于高地址范围，例如在x86架构中，内核空间通常从0x80000000开始。</li>
</ul>
</li>
<li>用户空间：<ul>
<li>每个进程都有自己独立的用户空间，与其他进程的用户空间相互隔离。</li>
<li>每个用户空间分别映射到不同的物理内存区域。</li>
<li>用户空间包含应用程序的代码、数据、堆、栈等。</li>
<li>用户空间的应用程序可以直接访问和操作其自身的用户空间内存。</li>
</ul>
</li>
</ol>
<p>应用程序访问内核空间的方式主要有两种：</p>
<ol>
<li>系统调用：应用程序通过系统调用接口向内核发出请求，请求执行特权操作或获取内核提供的服务。系统调用将应用程序的执行切换到内核空间，内核在接收到系统调用请求后执行相应的操作，并将结果返回给应用程序。</li>
<li>中断：应用程序可以通过触发中断事件来请求内核的处理。例如，硬件设备发生中断时，会引发中断请求，内核会在中断处理程序中对中断进行处理，并执行相应的操作。</li>
</ol>
<h1 id="4-1-3-地址映射"><a href="#4-1-3-地址映射" class="headerlink" title="4.1.3 地址映射"></a>4.1.3 地址映射</h1><p>地址映射是指将进程的虚拟地址映射到物理内存的过程。在操作系统中，地址映射是通过页表（Page Table）或者快速缓存翻译（Translation Lookaside Buffer，TLB）来实现的。</p>
<ol>
<li>虚拟地址通过页表&#x2F;TLB映射到物理内存：<ul>
<li>当进程访问虚拟地址时，操作系统将通过页表或者TLB进行地址转换，将虚拟地址映射到物理内存地址。</li>
<li>页表是操作系统维护的数据结构，记录了虚拟地址到物理地址的映射关系。每个进程都有自己的页表。</li>
<li>TLB是一个高速缓存，存储最近使用的页表项，以提高地址转换的速度。TLB中的页表项是虚拟地址到物理地址的映射。</li>
</ul>
</li>
<li>页表由操作系统维护，记录虚拟地址到物理地址的映射关系：<ul>
<li>操作系统负责创建和管理页表，其中包括建立和更新页表项。</li>
<li>当进程切换时，操作系统会切换对应的页表，以确保不同进程之间的地址映射独立和安全。</li>
</ul>
</li>
<li>通过页表还设置内存权限：读、写、可执行：<ul>
<li>页表不仅用于地址映射，还可以设置内存的访问权限。每个页表项可以指定对应虚拟页的读、写、执行权限。</li>
<li>当进程访问虚拟地址时，操作系统会检查页表项中设置的权限，以确定是否允许对物理内存的读取、写入或执行操作。</li>
</ul>
</li>
</ol>
<h1 id="4-1-4-为什么使用虚拟内存"><a href="#4-1-4-为什么使用虚拟内存" class="headerlink" title="4.1.4 为什么使用虚拟内存"></a>4.1.4 为什么使用虚拟内存</h1><p>使用虚拟内存的目的是为了解决物理内存的限制并提供更好的内存管理和系统安全性。以下是一些使用虚拟内存的主要原因：</p>
<ol>
<li>避免使用物理内存带来的弊端：<ul>
<li>物理内存是有限的资源，虚拟内存允许操作系统将物理内存和磁盘空间组合使用，从而扩展可用的内存空间。</li>
<li>虚拟内存允许将不常用的数据从物理内存转移到磁盘上的交换空间，以释放物理内存供其他进程使用。</li>
</ul>
</li>
<li>为每个进程提供一个独立的、私有的地址空间：<ul>
<li>每个进程都拥有自己独立的虚拟地址空间，使得进程之间的内存地址互相隔离，每个进程都可以认为自己在独占整个内存空间。</li>
<li>这样可以使得每个进程在运行时无需关心其他进程的内存布局和地址冲突问题，简化了进程间的通信和协作。</li>
</ul>
</li>
<li>保护每个进程的空间不被其他进程破坏：<ul>
<li>虚拟内存通过地址隔离，防止一个进程访问或修改其他进程的内存数据，提供了进程间的安全隔离。</li>
<li>如果一个进程尝试访问其它进程的地址空间，操作系统会通过内存保护机制触发异常，并终止非法操作，从而保护系统的稳定性和安全性。</li>
</ul>
</li>
<li>内存读写权限管理，保障系统的安全运行：<ul>
<li>虚拟内存管理机制允许操作系统对每个进程的内存区域设置读、写、执行等权限，以实现细粒度的内存保护。</li>
<li>操作系统可以通过页表或者段表等数据结构，对虚拟地址与物理地址的映射进行权限控制，防止恶意进程修改或访问非法内存区域。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>堆栈内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>1-70-参考文档:设备树bindings</title>
    <url>/2023/09/05/1-70-%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3-%E8%AE%BE%E5%A4%87%E6%A0%91bindings/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第70章-参考文档：设备树bindings"><a href="#第70章-参考文档：设备树bindings" class="headerlink" title="第70章 参考文档：设备树bindings"></a>第70章 参考文档：设备树bindings</h1><p>在前面的章节中，我们已经介绍了许多设备树编写相关的知识，当然上面我们讲解的都是标准属性，但当我们遇到非标准属性或无法理解的属性时，要如何处理呢？这时候就不得不提到bindings文档了。</p>
<p>Documentation&#x2F;devicetree&#x2F;bindings目录是Linux内核源码中的一个重要目录，用于存储设备树（Device Tree）的bindings文档。设备树是一种描述硬件平台和设备配置的数据结构，它以一种可移植和独立于具体硬件的方式描述了设备的属性、寄存器配置、中断信息等。</p>
<p>bindings目录中的文档提供了有关设备树的各种设备和驱动程序的详细说明和用法示例。这些文档对于开发人员来说非常重要，因为它们提供了在设备树中描述硬件和配置驱动程序所需的属性和约定。bindings目录截图如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025637.jpeg" alt="img"> </p>
<p>接下来对Documentation&#x2F;devicetree&#x2F;bindings目录的一些常见子目录和其内容的概述：</p>
<p>arm：包含与ARM体系结构相关的设备和驱动程序的bindings文档。</p>
<p>clock：包含与时钟设备和时钟控制器相关的bindings文档。</p>
<p>dma：包含与直接内存访问（DMA）控制器和设备相关的bindings文档。</p>
<p>gpio：包含与通用输入输出（GPIO）控制器和设备相关的bindings文档。</p>
<p>i2c：包含与I2C总线和设备相关的bindings文档。</p>
<p>interrupt-controller：包含与中断控制器相关的bindings文档。</p>
<p>media：包含与多媒体设备和驱动程序相关的bindings文档。</p>
<p>mfd：包含与多功能设备（MFD）子系统和设备相关的bindings文档。</p>
<p>networking：包含与网络设备和驱动程序相关的bindings文档。</p>
<p>power：包含与电源管理子系统和设备相关的bindings文档。</p>
<p>spi：包含与SPI总线和设备相关的bindings文档。</p>
<p>usb：包含与USB控制器和设备相关的bindings文档。</p>
<p>video：包含与视频设备和驱动程序相关的bindings文档。</p>
<p>每个子目录中的文档通常以.txt或.yaml的扩展名保存，使用文本或YAML格式编写。这些文档提供了有关设备树中属性的详细说明、属性的语法、可选值和用法示例。它们还描述了设备树的约定和最佳实践，以帮助开发人员正确地配置和描述硬件设备和驱动程序。</p>
<p>通过阅读Documentation&#x2F;devicetree&#x2F;bindings目录中的文档，开发人员可以了解各种设备和驱动程序的设备树属性的含义和用法，以便正确地配置和描述硬件平台和设备。这有助于实现硬件与软件之间的正确匹配和交互，使系统能够正确识别和使用硬件设备。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-69-of操作函数实验:获取中断资源</title>
    <url>/2023/09/05/1-69-of%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E5%AE%9E%E9%AA%8C-%E8%8E%B7%E5%8F%96%E4%B8%AD%E6%96%AD%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第69章-of操作函数实验：获取中断资源"><a href="#第69章-of操作函数实验：获取中断资源" class="headerlink" title="第69章 of操作函数实验：获取中断资源"></a>第69章 of操作函数实验：获取中断资源</h1><h2 id="69-1-of操作：获取中断资源"><a href="#69-1-of操作：获取中断资源" class="headerlink" title="69.1 of操作：获取中断资源"></a>69.1 of操作：获取中断资源</h2><h3 id="69-1-1-irq-of-parse-and-map"><a href="#69-1-1-irq-of-parse-and-map" class="headerlink" title="69.1.1 irq_of_parse_and_map"></a>69.1.1 irq_of_parse_and_map</h3><p>该函数的主要功能是解析设备节点的”interrupts”属性，并将对应的中断号映射到系统的中断号。”interrupts”属性通常以一种特定的格式表示，可以包含一个或多个中断号。通过提供索引号，可以获取对应的中断号。</p>
<p><strong>函数原型：</strong></p>
<p>​	unsigned int irq_of_parse_and_map(struct device_node *dev, int index);</p>
<p><strong>头文件：</strong></p>
<p>\	#include &lt;linux&#x2F;of_irq.h&gt;</p>
<p><strong>函数作用：</strong><br>        从设备节点的”interrupts”属性中解析和映射对应的中断号</p>
<p><strong>参数说明：</strong></p>
<p>​	dev：设备节点，表示要解析的设备节点。</p>
<p>​	index：索引号，表示从”interrupts”属性中获取第几个中断号。</p>
<p><strong>返回值：</strong></p>
<p>​	是一个无符号整数，表示成功解析和映射的中断号。</p>
<h3 id="69-1-2-irq-get-trigger-type"><a href="#69-1-2-irq-get-trigger-type" class="headerlink" title="69.1.2 irq_get_trigger_type"></a>69.1.2 irq_get_trigger_type</h3><p>该函数的主要功能是从给定的中断数据结构中提取中断触发类型。中断触发类型描述了中断信号的触发条件，例如边沿触发（edge-triggered）或电平触发（level-triggered）等。</p>
<p><strong>函数原型：</strong></p>
<p>​	u32 irqd_get_trigger_type(struct irq_data *d);</p>
<p><strong>头文件：</strong></p>
<p>\	#include &lt;linux&#x2F;irq.h&gt;</p>
<p><strong>函数作用：</strong></p>
<p>​	从中断数据结构（irq_data）中获取对应的中断触发类型。</p>
<p><strong>参数说明</strong>：</p>
<p>​	d：中断数据结构（irq_data），表示要获取中断触发类型的中断。</p>
<p><strong>返回值：</strong></p>
<p>​	是一个无符号32位整数，表示成功获取的中断触发类型。</p>
<h3 id="69-1-3-irq-get-irq-data"><a href="#69-1-3-irq-get-irq-data" class="headerlink" title="69.1.3 irq_get_irq_data"></a>69.1.3 irq_get_irq_data</h3><p>函数irq_get_irq_data的作用是根据中断号获取对应的中断数据结构（irq_data）。</p>
<p><strong>函数原型：</strong></p>
<p>​	struct irq_data *irq_get_irq_data(unsigned int irq);</p>
<p><strong>头文件：</strong><br>    #include &lt;linux&#x2F;irq.h&gt;</p>
<p><strong>函数作用：</strong><br>    根据中断号获取对应的中断数据结构。</p>
<p><strong>参数说明：</strong></p>
<p>​	irq：中断号，表示要获取中断数据结构的中断号。</p>
<p><strong>返回值</strong>：</p>
<p>​	指向irq_data结构体的指针，表示成功获取的中断数据结构。</p>
<h3 id="69-1-4-gpio-to-irq"><a href="#69-1-4-gpio-to-irq" class="headerlink" title="69.1.4 gpio_to_irq"></a>69.1.4 gpio_to_irq</h3><p>该函数的主要功能是将给定的GPIO编号转换为对应的中断号。在某些系统中，GPIO可以配置为中断引脚，当特定事件发生时触发中断。通过该函数，可以根据GPIO编号获取与之关联的中断号，以便进行中断处理等操作。</p>
<p><strong>函数原型：</strong></p>
<p>​	int gpio_to_irq(unsigned int gpio);</p>
<p><strong>头文件：</strong><br>        #include &lt;linux&#x2F;gpio.h&gt;</p>
<p><strong>函数作用：</strong></p>
<p>​	根据GPIO编号获取对应的中断号。</p>
<p><strong>参数说明：</strong></p>
<p>​	gpio：GPIO编号，表示要获取中断号的GPIO。</p>
<p><strong>返回值：</strong></p>
<p>​	是一个整数，表示成功获取的中断号。</p>
<h3 id="69-1-5-of-irq-get"><a href="#69-1-5-of-irq-get" class="headerlink" title="69.1.5 of_irq_get"></a>69.1.5 of_irq_get</h3><p>该函数的主要功能是从给定的设备节点的”interrupts”属性中解析并获取对应的中断号。”interrupts”属性通常以一种特定的格式表示，可以包含一个或多个中断号。通过提供索引号，可以获取对应的中断号</p>
<p><strong>函数原型：</strong></p>
<p>​	int of_irq_get(struct device_node *dev, int index);</p>
<p><strong>头文件：</strong><br>    #include &lt;linux&#x2F;of_irq.h&gt;</p>
<p><strong>函数作用：</strong></p>
<p>​	是从设备节点的”interrupts”属性中获取对应的中断号。</p>
<p><strong>参数说明：</strong></p>
<p>​	dev：设备节点，表示要获取中断号的设备节点。</p>
<p>​	index：索引号，表示从”interrupts”属性中获取第几个中断号。</p>
<p>返回值：</p>
<p>​	是一个整数，表示成功获取的中断号。</p>
<h3 id="69-1-6-irq-of-parse-and-map"><a href="#69-1-6-irq-of-parse-and-map" class="headerlink" title="69.1.6 irq_of_parse_and_map"></a>69.1.6 irq_of_parse_and_map</h3><p>irq_of_parse_and_map函数的主要功能是根据给定的平台设备和索引号获取对应的中断号。平台设备是指与特定硬件平台相关的设备。在某些情况下，平台设备可能具有多个中断号，通过提供索引号，可以获取对应的中断号。</p>
<p><strong>函数原型：</strong></p>
<p>​	int platform_get_irq(struct platform_device *dev, unsigned int num);</p>
<p><strong>函数作用：</strong><br>    根据平台设备和索引号获取对应的中断号。</p>
<p><strong>头文件：</strong><br>    linux&#x2F;platform_device.h</p>
<p><strong>参数说明</strong>：</p>
<p>​	dev：平台设备，表示要获取中断号的平台设备。</p>
<p>​	num：索引号，表示从中获取第几个中断号。</p>
<p><strong>返回值：</strong></p>
<p>​	是一个整数，表示成功获取的中断号。</p>
<h2 id="69-2-实验程序编写"><a href="#69-2-实验程序编写" class="headerlink" title="69.2 实验程序编写"></a>69.2 实验程序编写</h2><h3 id="69-2-1-设备树的修改"><a href="#69-2-1-设备树的修改" class="headerlink" title="69.2.1 设备树的修改"></a>69.2.1 设备树的修改</h3><p>本实验修改完成的设备树和编译完成的boot.img对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\57_of_03\dts。</p>
<p>由于本章节要获取的是中断相关的资源，所以需要在设备树中添加有关中断的设备节点，在第57章节的学习中，我们已经对中断实例进行了讲解，所以这里直接对rk3568-evb1-ddr4-v10-linux.dts设备树进行中断节点的添加，添加的内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myirq &#123;</span><br><span class="line">	compatible = &quot;my_devicetree_irq&quot;;</span><br><span class="line">	interrupt-parent = &lt;&amp;gpio3&gt;;</span><br><span class="line">	interrupts = &lt;RK_PA5 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>添加完成如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025704.jpeg" alt="img"> </p>
<p>保存退出之后，重新编译内核源码，得到boot.img内核镜像之后烧写到开发板即可。</p>
<h3 id="69-2-2-实验程序的编写"><a href="#69-2-2-实验程序的编写" class="headerlink" title="69.2.2 实验程序的编写"></a>69.2.2 实验程序的编写</h3><p>本实验驱动对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\57_of_03。</p>
<p>本小节驱动程序是由65章驱动程序修改而来，由于本章节获取中断属性的函数需要在查找到设备树节点的前提下使用，所以在下面的程序中，先在probe函数中查找设备树节点，然后添加了本章节学习的of操作相关代码和其他一些相关的函数，用来获取设备树节点中断资源。</p>
<p>编写完成的platform_driver.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mod_devicetable.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">int</span> irq;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> *<span class="title">my_irq_data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">mydevice_node</span>;</span></span><br><span class="line">u32 trigger_type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_probe: Probing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找设备节点</span></span><br><span class="line">    mydevice_node = of_find_node_by_name(<span class="literal">NULL</span>, <span class="string">&quot;myirq&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析和映射中断</span></span><br><span class="line">    irq = irq_of_parse_and_map(mydevice_node, <span class="number">0</span>);</span><br><span class="line">    printk(<span class="string">&quot;irq is %d\n&quot;</span>, irq);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取中断数据结构</span></span><br><span class="line">    my_irq_data = irq_get_irq_data(irq);</span><br><span class="line">    <span class="comment">// 获取中断触发类型</span></span><br><span class="line">    trigger_type = irqd_get_trigger_type(my_irq_data);</span><br><span class="line">    printk(<span class="string">&quot;trigger type is 0x%x\n&quot;</span>, trigger_type);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将GPIO转换为中断号</span></span><br><span class="line">    irq = gpio_to_irq(<span class="number">101</span>);</span><br><span class="line">    printk(<span class="string">&quot;irq is %d\n&quot;</span>, irq);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从设备节点获取中断号</span></span><br><span class="line">    irq = of_irq_get(mydevice_node, <span class="number">0</span>);</span><br><span class="line">    printk(<span class="string">&quot;irq is %d\n&quot;</span>, irq);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取平台设备的中断号</span></span><br><span class="line">    irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">    printk(<span class="string">&quot;irq is %d\n&quot;</span>, irq);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Removing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table_id</span>[]  =</span> &#123;</span><br><span class="line">	&#123;.compatible=<span class="string">&quot;my_devicetree_irq&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">		.of_match_table =  of_match_table_id,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="69-3-运行测试"><a href="#69-3-运行测试" class="headerlink" title="69.3 运行测试"></a>69.3 运行测试</h2><h3 id="69-3-1-编译驱动程序"><a href="#69-3-1-编译驱动程序" class="headerlink" title="69.3.1 编译驱动程序"></a>69.3.1 编译驱动程序</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_driver.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_driver.c和Makefile文件目录下，如下图（图69-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025721.jpeg" alt="img"> </p>
<p>图 69-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图69-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025678.jpeg" alt="img"> </p>
<p>图 69-2</p>
<p>编译完生成platform_driver.ko目标文件，如下图（图69-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025669.jpeg" alt="img"> </p>
<p>图 69-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="69-3-2-运行测试"><a href="#69-3-2-运行测试" class="headerlink" title="69.3.2 运行测试"></a>69.3.2 运行测试</h3><p>在进行实验之前，首先要确保开发板烧写的是我们在69.2.1小节中编译出来的boot.img，开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图69-4）所示：</p>
<p>insmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025673.jpeg" alt="img"> </p>
<p>图 69-4</p>
<p>可以看到总共有5个打印，第1、3、4、5个打印都是获取的中断号为113，第2个打印的是中断的类型，即IRQ_TYPE_LEVEL_LOW，该触发类型的宏定义在内核源码“include&#x2F;dt-bindings&#x2F;interrupt-controller&#x2F;irq.h”目录下，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_NONE           0   <span class="comment">// 无中断触发类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_RISING    1   <span class="comment">// 上升沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_FALLING   2   <span class="comment">// 下降沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_BOTH    (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING)<span class="comment">// 双边沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_LEVEL_HIGH     4   <span class="comment">// 高电平触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_LEVEL_LOW      8   <span class="comment">// 低电平触发</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到IRQ_TYPE_LEVEL_LOW的宏定义为8，证明上面的打印正确。</p>
<p>然后使用以下命令进行驱动模块的卸载，如下图（图69-5）所示：</p>
<p>rmmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025753.png" alt="img"></p>
<p>图 69-5</p>
<p>至此，使用of操作函数获取中断资源实验就完成了。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-68-ranges属性实验</title>
    <url>/2023/09/05/1-68-ranges%E5%B1%9E%E6%80%A7%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第68章-ranges属性实验"><a href="#第68章-ranges属性实验" class="headerlink" title="第68章 ranges属性实验"></a>第68章 ranges属性实验</h1><h1 id="68-1-platform-get-resource获取设备树资源"><a href="#68-1-platform-get-resource获取设备树资源" class="headerlink" title="68.1 platform_get_resource获取设备树资源"></a>68.1 platform_get_resource获取设备树资源</h1><p>在上个章节中讲解了使用of操作函数来获取设备树的属性，由于设备树在系统启动的时候都会转化为platform设备，那我们能不能直接在驱动中使用在53.1小节中讲解的platform_get_resource函数直接获取platform_device资源呢？</p>
<h3 id="68-1-1-驱动程序编写"><a href="#68-1-1-驱动程序编写" class="headerlink" title="68.1.1 驱动程序编写"></a>68.1.1 驱动程序编写</h3><p>带着疑惑我们这里仍旧以65章的驱动程序为原型，在probe函数中加入使用platform_get_resource函数获取reg资源的函数，添加完成的驱动程序内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mod_devicetable.h&gt;</span></span></span><br><span class="line"><span class="comment">// 平台设备的初始化函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">myresources</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_probe: Probing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取平台设备的资源</span></span><br><span class="line">    myresources = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (myresources == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果获取资源失败，打印value_compatible的值</span></span><br><span class="line">        printk(<span class="string">&quot;platform_get_resource is error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">&quot;reg valus is %llx\n&quot;</span> , myresources-&gt;start); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Removing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table_id</span>[]  =</span> &#123;</span><br><span class="line">	&#123;.compatible=<span class="string">&quot;my devicetree&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">		.of_match_table =  of_match_table_id,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>编译成模块之后，放到开发板上进行加载，打印信息如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025476.jpeg" alt="img"> </p>
<p>可以看到使用platform_get_resource函数获取reg资源的函数失败了，在下一个小节中将分析获取资源失败的原因。</p>
<h3 id="68-1-2-分析获取资源失败"><a href="#68-1-2-分析获取资源失败" class="headerlink" title="68.1.2 分析获取资源失败"></a>68.1.2 分析获取资源失败</h3><p>platform_get_resource定义在内核源码目录下的”&#x2F;drivers&#x2F;base&#x2F;platform.c”目录下，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *dev,</span></span><br><span class="line"><span class="params">				       <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dev-&gt;num_resources; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">r</span> =</span> &amp;dev-&gt;resource[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (type == resource_type(r) &amp;&amp; num-- == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数返回NULL符合第一小节中的情况，返回NULL的情况有两种可能性，一种是没进入上面的for循环直接返回了NULL，另外一种是进入了for循环，但是类型匹配不正确，跳出for循环之后再返回NULL。这里的类型一定是匹配的，所以我们就来寻找为什么没有进入for循环，这里只有一种可能，也就是dev-&gt;num_resources为0。</p>
<p>所以现在的目标来到了寻找dev-&gt;num_resources是在哪里进行的赋值，前面已经讲解过了由设备树转换为platform的过程，而且在系统启动后，在对应目录下也有了相应的节点： <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025423.png"></p>
<p>​	证明转换是没问题的，所以继续寻找中间转换过程中有关资源数量的相关函数，定位到了of_platform_device_create_pdata函数，该函数定义在内核源码目录下的“drivers&#x2F;of&#x2F;platform.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> platform_device *<span class="title function_">of_platform_device_create_pdata</span><span class="params">(</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">					<span class="type">const</span> <span class="type">char</span> *bus_id,</span></span><br><span class="line"><span class="params">					<span class="type">void</span> *platform_data,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> device *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查设备节点是否可用或已填充 */</span></span><br><span class="line">	<span class="keyword">if</span> (!of_device_is_available(np) ||</span><br><span class="line">	    of_node_test_and_set_flag(np, OF_POPULATED))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 分配平台设备结构体 */</span></span><br><span class="line">	dev = of_device_alloc(np, bus_id, parent);</span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">goto</span> err_clear_flag;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置平台设备的一些属性 */</span></span><br><span class="line">	dev-&gt;dev.coherent_dma_mask = DMA_BIT_MASK(<span class="number">32</span>);</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;dev.dma_mask)</span><br><span class="line">		dev-&gt;dev.dma_mask = &amp;dev-&gt;dev.coherent_dma_mask;</span><br><span class="line">	dev-&gt;dev.bus = &amp;platform_bus_type;</span><br><span class="line">	dev-&gt;dev.platform_data = platform_data;</span><br><span class="line">	of_msi_configure(&amp;dev-&gt;dev, dev-&gt;dev.of_node);</span><br><span class="line">	of_reserved_mem_device_init_by_idx(&amp;dev-&gt;dev, dev-&gt;dev.of_node, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将平台设备添加到设备模型中 */</span></span><br><span class="line">	<span class="keyword">if</span> (of_device_add(dev) != <span class="number">0</span>) &#123;</span><br><span class="line">		platform_device_put(dev);</span><br><span class="line">		<span class="keyword">goto</span> err_clear_flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev;</span><br><span class="line"></span><br><span class="line">err_clear_flag:</span><br><span class="line">	<span class="comment">/* 清除设备节点的已填充标志 */</span></span><br><span class="line">	of_node_clear_flag(np, OF_POPULATED);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>​	第15行：函数调用 of_device_alloc 分配一个平台设备结构体，并将设备节点指针、设备标识符和父设备指针传递给它，正是该函数决定的resource.num,然后找到该函数的定义，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> platform_device *<span class="title function_">of_device_alloc</span><span class="params">(<span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">				  <span class="type">const</span> <span class="type">char</span> *bus_id,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> device *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">int</span> rc, i, num_reg = <span class="number">0</span>, num_irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>, <span class="title">temp_res</span>;</span></span><br><span class="line"></span><br><span class="line">	dev = platform_device_alloc(<span class="string">&quot;&quot;</span>, PLATFORM_DEVID_NONE);</span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* count the io and irq resources */</span></span><br><span class="line">	<span class="keyword">while</span> (of_address_to_resource(np, num_reg, &amp;temp_res) == <span class="number">0</span>)</span><br><span class="line">		num_reg++;</span><br><span class="line">	num_irq = of_irq_count(np);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Populate the resource table */</span></span><br><span class="line">	<span class="keyword">if</span> (num_irq || num_reg) &#123;</span><br><span class="line">		res = kcalloc(num_irq + num_reg, <span class="keyword">sizeof</span>(*res), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!res) &#123;</span><br><span class="line">			platform_device_put(dev);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		dev-&gt;num_resources = num_reg + num_irq;</span><br><span class="line">		dev-&gt;resource = res;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_reg; i++, res++) &#123;</span><br><span class="line">			rc = of_address_to_resource(np, i, res);</span><br><span class="line">			WARN_ON(rc);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (of_irq_to_resource_table(np, res, num_irq) != num_irq)</span><br><span class="line">			pr_debug(<span class="string">&quot;not all legacy IRQ resources mapped for %pOFn\n&quot;</span>,</span><br><span class="line">				 np);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev-&gt;dev.of_node = of_node_get(np);</span><br><span class="line">	dev-&gt;dev.fwnode = &amp;np-&gt;fwnode;</span><br><span class="line">	dev-&gt;dev.parent = parent ? : &amp;platform_bus;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bus_id)</span><br><span class="line">		dev_set_name(&amp;dev-&gt;dev, <span class="string">&quot;%s&quot;</span>, bus_id);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		of_device_make_bus_id(&amp;dev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第26行出现了for循环的dev-&gt;num_resources &#x3D; num_reg + num_irq;reg的number和irq的number，由于在设备树中并没有添加中断相关的属性num_irq为0，那这里的num_reg是哪里确定的呢。</p>
<p>我们向上找到14、15行，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (of_address_to_resource(np, num_reg, &amp;temp_res) == 0)</span><br><span class="line">	num_reg++;</span><br></pre></td></tr></table></figure>

<p>然后跳转到while循环中的of_address_to_resource函数，该函数定义在内核源码目录的drivers&#x2F;of&#x2F;address.c文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_address_to_resource</span><span class="params">(<span class="keyword">struct</span> device_node *dev, <span class="type">int</span> index,</span></span><br><span class="line"><span class="params">			   <span class="keyword">struct</span> resource *r)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> __be32	*addrp;</span><br><span class="line">	u64		size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	flags;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>	*name = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	addrp = of_get_address(dev, index, &amp;size, &amp;flags);</span><br><span class="line">	<span class="keyword">if</span> (addrp == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get optional &quot;reg-names&quot; property to add a name to a resource */</span></span><br><span class="line">	of_property_read_string_index(dev, <span class="string">&quot;reg-names&quot;</span>,	index, &amp;name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __of_address_to_resource(dev, addrp, size, flags, name, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	第9行，获取reg属性的地址、大小和类型，在设备树中reg属性已经存在了，所以这里会正确返回。</p>
<p>第14行，读取reg-names属性，由于设备树中没有定义这个属性，所以该函数不会有影响。</p>
<p>最后具有决定性作用的函数就是返回的__of_address_to_resource函数了，跳转到该函数的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __of_address_to_resource(<span class="keyword">struct</span> device_node *dev,</span><br><span class="line">		<span class="type">const</span> __be32 *addrp, u64 size, <span class="type">unsigned</span> <span class="type">int</span> flags,</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> resource *r)</span><br><span class="line">&#123;</span><br><span class="line">	u64 taddr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; IORESOURCE_MEM)</span><br><span class="line">		taddr = of_translate_address(dev, addrp);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; IORESOURCE_IO)</span><br><span class="line">		taddr = of_translate_ioport(dev, addrp, size);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (taddr == OF_BAD_ADDR)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="built_in">memset</span>(r, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> resource));</span><br><span class="line"></span><br><span class="line">	r-&gt;start = taddr;</span><br><span class="line">	r-&gt;end = taddr + size - <span class="number">1</span>;</span><br><span class="line">	r-&gt;flags = flags;</span><br><span class="line">	r-&gt;name = name ? name : dev-&gt;full_name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	reg属性的flags为IORESOURCE_MEM，所以又会执行第9行的of_translate_address函数，跳转到该函数，该函数的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u64 <span class="title function_">of_translate_address</span><span class="params">(<span class="keyword">struct</span> device_node *dev, <span class="type">const</span> __be32 *in_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">host</span>;</span></span><br><span class="line">	u64 ret;</span><br><span class="line"></span><br><span class="line">	ret = __of_translate_address(dev, in_addr, <span class="string">&quot;ranges&quot;</span>, &amp;host);</span><br><span class="line">	<span class="keyword">if</span> (host) &#123;</span><br><span class="line">		of_node_put(host);</span><br><span class="line">		<span class="keyword">return</span> OF_BAD_ADDR;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	该函数的重点在第6行，上述函数实际上是__of_translate_address函数的封装，其中传入的第三个参数“ranges”是我们要关注的重点，继续跳转到该函数的定义，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> u64 __of_translate_address(<span class="keyword">struct</span> device_node *dev,</span><br><span class="line">				  <span class="type">const</span> __be32 *in_addr, <span class="type">const</span> <span class="type">char</span> *rprop,</span><br><span class="line">				  <span class="keyword">struct</span> device_node **host)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">of_bus</span> *<span class="title">bus</span>, *<span class="title">pbus</span>;</span></span><br><span class="line">	__be32 addr[OF_MAX_ADDR_CELLS];</span><br><span class="line">	<span class="type">int</span> na, ns, pna, pns;</span><br><span class="line">	u64 result = OF_BAD_ADDR;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;** translation for device %pOF **\n&quot;</span>, dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Increase refcount at current level */</span></span><br><span class="line">	of_node_get(dev);</span><br><span class="line"></span><br><span class="line">	*host = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/* Get parent &amp; match bus type */</span></span><br><span class="line">	parent = of_get_parent(dev);</span><br><span class="line">	<span class="keyword">if</span> (parent == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> bail;</span><br><span class="line">	bus = of_match_bus(parent);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Count address cells &amp; copy address locally */</span></span><br><span class="line">	bus-&gt;count_cells(dev, &amp;na, &amp;ns);</span><br><span class="line">	<span class="keyword">if</span> (!OF_CHECK_COUNTS(na, ns)) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;Bad cell count for %pOF\n&quot;</span>, dev);</span><br><span class="line">		<span class="keyword">goto</span> bail;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(addr, in_addr, na * <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;bus is %s (na=%d, ns=%d) on %pOF\n&quot;</span>,</span><br><span class="line">	    bus-&gt;name, na, ns, parent);</span><br><span class="line">	of_dump_addr(<span class="string">&quot;translating address:&quot;</span>, addr, na);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Translate */</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">logic_pio_hwaddr</span> *<span class="title">iorange</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Switch to parent bus */</span></span><br><span class="line">		of_node_put(dev);</span><br><span class="line">		dev = parent;</span><br><span class="line">		parent = of_get_parent(dev);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If root, we have finished */</span></span><br><span class="line">		<span class="keyword">if</span> (parent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			pr_debug(<span class="string">&quot;reached root node\n&quot;</span>);</span><br><span class="line">			result = of_read_number(addr, na);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * For indirectIO device which has no ranges property, get</span></span><br><span class="line"><span class="comment">		 * the address from reg directly.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		iorange = find_io_range_by_fwnode(&amp;dev-&gt;fwnode);</span><br><span class="line">		<span class="keyword">if</span> (iorange &amp;&amp; (iorange-&gt;flags != LOGIC_PIO_CPU_MMIO)) &#123;</span><br><span class="line">			result = of_read_number(addr + <span class="number">1</span>, na - <span class="number">1</span>);</span><br><span class="line">			pr_debug(<span class="string">&quot;indirectIO matched(%pOF) 0x%llx\n&quot;</span>,</span><br><span class="line">				 dev, result);</span><br><span class="line">			*host = of_node_get(dev);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Get new parent bus and counts */</span></span><br><span class="line">		pbus = of_match_bus(parent);</span><br><span class="line">		pbus-&gt;count_cells(dev, &amp;pna, &amp;pns);</span><br><span class="line">		<span class="keyword">if</span> (!OF_CHECK_COUNTS(pna, pns)) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;Bad cell count for %pOF\n&quot;</span>, dev);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pr_debug(<span class="string">&quot;parent bus is %s (na=%d, ns=%d) on %pOF\n&quot;</span>,</span><br><span class="line">		    pbus-&gt;name, pna, pns, parent);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Apply bus translation */</span></span><br><span class="line">		<span class="keyword">if</span> (of_translate_one(dev, bus, pbus, addr, na, ns, pna, rprop))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Complete the move up one level */</span></span><br><span class="line">		na = pna;</span><br><span class="line">		ns = pns;</span><br><span class="line">		bus = pbus;</span><br><span class="line"></span><br><span class="line">		of_dump_addr(<span class="string">&quot;one level translation:&quot;</span>, addr, na);</span><br><span class="line">	&#125;</span><br><span class="line"> bail:</span><br><span class="line">	of_node_put(parent);</span><br><span class="line">	of_node_put(dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	第18行，获取父节点和匹配的总线类型</p>
<p>第24行，获取address-cell和size-cells</p>
<p>然后是一个for循环，在76行使用of_translate_one函数进行转换，其中rprop参数表示要转换的资源属性，该参数的值为传入的“ranges”，然后我们继续跳转到该函数，该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">of_translate_one</span><span class="params">(<span class="keyword">struct</span> device_node *parent, <span class="keyword">struct</span> of_bus *bus,</span></span><br><span class="line"><span class="params">			    <span class="keyword">struct</span> of_bus *pbus, __be32 *addr,</span></span><br><span class="line"><span class="params">			    <span class="type">int</span> na, <span class="type">int</span> ns, <span class="type">int</span> pna, <span class="type">const</span> <span class="type">char</span> *rprop)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> __be32 *ranges;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> rlen;</span><br><span class="line">	<span class="type">int</span> rone;</span><br><span class="line">	u64 offset = OF_BAD_ADDR;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Normally, an absence of a &quot;ranges&quot; property means we are</span></span><br><span class="line"><span class="comment">	 * crossing a non-translatable boundary, and thus the addresses</span></span><br><span class="line"><span class="comment">	 * below the current cannot be converted to CPU physical ones.</span></span><br><span class="line"><span class="comment">	 * Unfortunately, while this is very clear in the spec, it&#x27;s not</span></span><br><span class="line"><span class="comment">	 * what Apple understood, and they do have things like /uni-n or</span></span><br><span class="line"><span class="comment">	 * /ht nodes with no &quot;ranges&quot; property and a lot of perfectly</span></span><br><span class="line"><span class="comment">	 * useable mapped devices below them. Thus we treat the absence of</span></span><br><span class="line"><span class="comment">	 * &quot;ranges&quot; as equivalent to an empty &quot;ranges&quot; property which means</span></span><br><span class="line"><span class="comment">	 * a 1:1 translation at that level. It&#x27;s up to the caller not to try</span></span><br><span class="line"><span class="comment">	 * to translate addresses that aren&#x27;t supposed to be translated in</span></span><br><span class="line"><span class="comment">	 * the first place. --BenH.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * As far as we know, this damage only exists on Apple machines, so</span></span><br><span class="line"><span class="comment">	 * This code is only enabled on powerpc. --gcl</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ranges = of_get_property(parent, rprop, &amp;rlen);</span><br><span class="line">	<span class="keyword">if</span> (ranges == <span class="literal">NULL</span> &amp;&amp; !of_empty_ranges_quirk(parent)) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;no ranges; cannot translate\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ranges == <span class="literal">NULL</span> || rlen == <span class="number">0</span>) &#123;</span><br><span class="line">		offset = of_read_number(addr, na);</span><br><span class="line">		<span class="built_in">memset</span>(addr, <span class="number">0</span>, pna * <span class="number">4</span>);</span><br><span class="line">		pr_debug(<span class="string">&quot;empty ranges; 1:1 translation\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> finish;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;walking ranges...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now walk through the ranges */</span></span><br><span class="line">	rlen /= <span class="number">4</span>;</span><br><span class="line">	rone = na + pna + ns;</span><br><span class="line">	<span class="keyword">for</span> (; rlen &gt;= rone; rlen -= rone, ranges += rone) &#123;</span><br><span class="line">		offset = bus-&gt;<span class="built_in">map</span>(addr, ranges, na, ns, pna);</span><br><span class="line">		<span class="keyword">if</span> (offset != OF_BAD_ADDR)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (offset == OF_BAD_ADDR) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;not found !\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(addr, ranges + na, <span class="number">4</span> * pna);</span><br><span class="line"></span><br><span class="line"> finish:</span><br><span class="line">	of_dump_addr(<span class="string">&quot;parent translation for:&quot;</span>, addr, pna);</span><br><span class="line">	pr_debug(<span class="string">&quot;with offset: %llx\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)offset);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Translate it into parent bus space */</span></span><br><span class="line">	<span class="keyword">return</span> pbus-&gt;translate(addr, offset, pna);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该函数的第26行使用of_get_property函数获取“ranges”属性，但由于在我们添加的设备树节点中并没有该属性，所以这里的ranges值就为NULL，第27行的条件判断成立，也就会返回1。</p>
<p>接下来再根据这个返回值继续分析上级函数:</p>
<p>of_translate_one函数返回1之后，上一级的_of_translate_address的返回值就为OF BAD ADDR，再上一级的of_translate_address返回值也是OF BAD <em>ADDR，继续向上查找_of_address_to_resource函数会返回EINVAL，of address</em> to resource 返回EINVAL，所以num_reg 为0;到这里关于为什么platform_get_resource函数获取资源失败的问题就找到了，只是因为在设备树中并没有这个名为ranges这个属性，所以只需要对设备树进行ranges属性的添加即可，要修改的设备树为arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568-evb1-ddr4-v10-linux.dts，修改完成如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025548.jpeg" alt="img"> </p>
<p>然后重新编译内核，将编译生成的boot.img烧写进开发板之后重新加载上面编写的驱动程序，可以看到之前获取失败的打印就消失了，而且成功打印出了reg属性的第一个值，如下图所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025507.jpeg" alt="img"></p>
<p>虽然这里的问题解决了，但引起的思考并没有结束，那我们在这里添加的ranges属性的作用是啥呢，带着疑问，开始下一小节的学习吧。</p>
<h1 id="68-2-ranges-属性"><a href="#68-2-ranges-属性" class="headerlink" title="68.2 ranges 属性"></a>68.2 ranges 属性</h1><h3 id="68-2-1-ranges属性介绍"><a href="#68-2-1-ranges属性介绍" class="headerlink" title="68.2.1 ranges属性介绍"></a>68.2.1 ranges属性介绍</h3><p>ranges 属性是一种用于描述设备之间地址映射关系的属性。它在设备树（Device Tree）中使用，用于描述子设备地址空间如何映射到父设备地址空间。设备树是一种硬件描述语言，用于描述嵌入式系统中的硬件组件和它们之间的连接关系。</p>
<p>设备树中的每个设备节点都可以具有 ranges 属性，其中包含了地址映射的信息。下面是一个常见的格式：</p>
<p>ranges &#x3D; <child-bus-address parent-bus-address length>;</p>
<p>或者</p>
<p>ranges;</p>
<p>然后对上述格式中每个部分进行解释：</p>
<p>child-bus-address：子设备地址空间的起始地址。它指定了子设备在父设备地址空间中的位置。具体的字长由 ranges 所在节点的 #address-cells 属性决定。</p>
<p>parent-bus-address：父设备地址空间的起始地址。它指定了父设备中用于映射子设备的地址范围。具体的字长由 ranges 的父节点的 #address-cells 属性决定。</p>
<p>length：映射的大小。它指定了子设备地址空间在父设备地址空间中的长度。具体的字长由 ranges 的父节点的 #size-cells 属性决定。</p>
<p>当 ranges 属性的值为空时，表示子设备地址空间和父设备地址空间具有完全相同的映射，即1:1映射。这通常用于描述内存区域，其中子设备和父设备具有相同的地址范围。</p>
<p>当 ranges 属性的值不为空时，按照指定的映射规则将子设备地址空间映射到父设备地址空间。具体的映射规则取决于设备树的结构和设备的特定要求。</p>
<p>然后以下面的设备树为例进行ranges属性的讲解，设备树内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">  compatible = <span class="string">&quot;acme,coyotes-revenge&quot;</span>;</span><br><span class="line">  <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">  <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">  ....</span><br><span class="line">  external-bus &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    ranges = &lt;<span class="number">0</span> <span class="number">0</span> <span class="number">0x10100000</span> <span class="number">0x10000</span></span><br><span class="line">              <span class="number">1</span> <span class="number">0</span> <span class="number">0x10160000</span> <span class="number">0x10000</span></span><br><span class="line">              <span class="number">2</span> <span class="number">0</span> <span class="number">0x30000000</span> <span class="number">0x30000000</span>&gt;;</span><br><span class="line">    <span class="comment">// Chipselect 1, Ethernet</span></span><br><span class="line">    <span class="comment">// Chipselect 2, i2c controller</span></span><br><span class="line">    <span class="comment">// Chipselect 3, NOR Flash</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure>

<p>这里以ranges的第一个属性值为例进行具体解释如下：</p>
<p>在 external-bus 节点中#address-cells 属性值为2表示child-bus-address由两个值表示，也就是0和0，父节点的 #address-cells 属性值和#size-cells 属性值为1，表示parent-bus-address和length都由一个表示，也就是0x10100000和0x10000，该ranges值表示将子地址空间（0x0-0xFFFF）映射到父地址空间0x10100000 - 0x1010FFFF，这里的例子为带参数ranges属性映射，不带参数的ranges属性为1：1映射，较为简单，这里不再进行举例。</p>
<p>在嵌入式系统中，不同的设备可能连接到相同的总线或总线控制器上，它们需要在物理地址空间中进行正确的映射，以便进行数据交换和通信。例如，一个设备可能通过总线连接到主处理器或其他设备，而这些设备的物理地址范围可能不同。ranges 属性就是用来描述这种地址映射关系的。</p>
<h3 id="68-2-2设备分类"><a href="#68-2-2设备分类" class="headerlink" title="68.2.2设备分类"></a>68.2.2设备分类</h3><p>根据上面讲解的映射关系可以将设备分为两类：内存映射型设备和非内存映射型设备。</p>
<p><strong>内存映射型设备：</strong><br>    内存映射型设备是指可以通过内存地址进行直接访问的设备。这类设备在物理地址空间中的一部分被映射到系统的内存地址空间中，使得CPU可以通过读写内存地址的方式与设备进行通信和控制。</p>
<p>特点：</p>
<p>（1）直接访问：内存映射型设备可以被CPU直接访问，类似于访问内存中的数据。这种直接访问方式提供了高速的数据传输和低延迟的设备操作。</p>
<p>（2）内存映射：设备的寄存器、缓冲区等资源被映射到系统的内存地址空间中，使用读写内存的方式与设备进行通信。</p>
<p>（3）读写操作：CPU可以通过读取和写入映射的内存地址来与设备进行数据交换和控制操作。</p>
<p>在设备树中，内存映射型设备的设备树举例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">/ &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    ranges;</span><br><span class="line"></span><br><span class="line">    serial@<span class="number">101f</span>0000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;arm,pl011&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x101f0000</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@<span class="number">101f</span>3000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;arm,pl061&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x101f3000</span> <span class="number">0x1000</span></span><br><span class="line">                <span class="number">0x101f4000</span> <span class="number">0x10</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    spi@<span class="number">10115000</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;arm,pl022&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x10115000</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第5行的ranges属性表示该设备树中会进行1：1的地址范围映射。</p>
<p>非内存映射型设备：<br>    非内存映射型设备是指不能通过内存地址直接访问的设备。这类设备可能采用其他方式与CPU进行通信，例如通过I&#x2F;O端口、专用总线或特定的通信协议。</p>
<p>特点：</p>
<p>（1）非内存访问：非内存映射型设备不能像内存映射型设备那样直接通过内存地址进行访问。它们可能使用独立的I&#x2F;O端口或专用总线进行通信。</p>
<p>（2）特定接口：设备通常使用特定的接口和协议与CPU进行通信和控制，例如SPI、I2C、UART等。</p>
<p>（3）驱动程序：非内存映射型设备通常需要特定的设备驱动程序来实现与CPU的通信和控制。</p>
<p>在设备树中，非内存映射型设备的设备树举例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">  compatible = <span class="string">&quot;acme,coyotes-revenge&quot;</span>;</span><br><span class="line">  <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">  <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">  ....</span><br><span class="line">  external-bus &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    ranges = &lt;<span class="number">0</span> <span class="number">0</span> <span class="number">0x10100000</span> <span class="number">0x10000</span></span><br><span class="line">              <span class="number">1</span> <span class="number">0</span> <span class="number">0x10160000</span> <span class="number">0x10000</span></span><br><span class="line">              <span class="number">2</span> <span class="number">0</span> <span class="number">0x30000000</span> <span class="number">0x30000000</span>&gt;;</span><br><span class="line">    <span class="comment">// Chipselect 1, Ethernet</span></span><br><span class="line">    <span class="comment">// Chipselect 2, i2c controller</span></span><br><span class="line">    <span class="comment">// Chipselect 3, NOR Flash</span></span><br><span class="line"></span><br><span class="line">    ethernet@<span class="number">0</span>,<span class="number">0</span> &#123;</span><br><span class="line">      compatible = <span class="string">&quot;smc,smc91c111&quot;</span>;</span><br><span class="line">      reg = &lt;<span class="number">0</span> <span class="number">0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    i2c@<span class="number">1</span>,<span class="number">0</span> &#123;</span><br><span class="line">      compatible = <span class="string">&quot;acme,a1234-i2c-bus&quot;</span>;</span><br><span class="line">      <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">      <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">      reg = &lt;<span class="number">1</span> <span class="number">0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line"></span><br><span class="line">      rtc@<span class="number">58</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;maxim,ds1338&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x58</span>&gt;;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; ;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h3 id="68-2-3-映射地址计算"><a href="#68-2-3-映射地址计算" class="headerlink" title="68.2.3 映射地址计算"></a>68.2.3 映射地址计算</h3><p>接下来以上面列举的非内存映射型设备的设备树中的ethernet@0节点为例，计算该网卡设备的映射地址。</p>
<p>首先，找到ethernet@0所在的节点，并查看其reg属性。在给定的设备树片段中，ethernet@0的reg属性为&lt;0 0 0x1000&gt;。在根节点中，#address-cells的值为1，表示地址由一个单元格组成。</p>
<p>接下来，根据ranges属性进行地址映射计算。在external-bus节点的ranges属性中，有三个映射条目：</p>
<p>第一个映射条目为“0 0 0x10100000 0x10000”，表示外部总线的地址范围为0x10100000到0x1010FFFF。该映射条目的第一个值为0，表示与external-bus节点的第一个子节点（ethernet@0,0）相关联。</p>
<p>第二个映射条目：“1 0 0x10160000 0x10000”，表示外部总线的地址范围为0x10160000到0x1016FFFF。该映射条目的第一个值为1，表示与external-bus节点的第二个子节点（i2c@1,0）相关联。</p>
<p>第三个映射条目：“2 0 0x30000000 0x30000000”，表示外部总线的地址范围为0x30000000到0x5FFFFFFF。该映射条目的第一个值为2，表示与external-bus节点的第三个子节点相关联。</p>
<p>由于ethernet@0与external-bus的第一个子节点相关联，并且它的reg属性为&lt;0 0 0x1000&gt;，我们可以进行以下计算：</p>
<p>ethernet@0的物理地址 &#x3D; 外部总线地址起始值 + ethernet@0的reg属性的第二个值<br>&#x3D; 0x10100000 + 0x1000<br>&#x3D; 0x10101000</p>
<p>因此，ethernet@0的物理起始地址为0x10101000，又根据0x1000的地址范围可以确定ethernet@0的结束起始地址为0x10101FFF，至此，关于映射地址的计算就讲解完成了，大家可以根据同样的方法计算i2c@1的物理地址。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-67-of操作函数实验:获取属性</title>
    <url>/2023/09/05/1-67-of%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E5%AE%9E%E9%AA%8C-%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第67章-of操作函数实验：获取属性"><a href="#第67章-of操作函数实验：获取属性" class="headerlink" title="第67章 of操作函数实验：获取属性"></a>第67章 of操作函数实验：获取属性</h1><h2 id="67-1-of操作：获取属性"><a href="#67-1-of操作：获取属性" class="headerlink" title="67.1 of操作：获取属性"></a>67.1 of操作：获取属性</h2><h3 id="67-1-1-of-find-property"><a href="#67-1-1-of-find-property" class="headerlink" title="67.1.1 of_find_property"></a>67.1.1 of_find_property</h3><p>of_find_property函数用于在设备树中查找节点 下具有指定名称的属性。如果找到了该属性，可以通过返回的属性结构体指针进行进一步的操作，比如获取属性值、属性长度等。</p>
<p><strong>函数原型:</strong></p>
<p>​	struct property *of_find_property(const struct device_node *np, const char *name, int *lenp)</p>
<p><strong>头文件：</strong></p>
<p>​	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用</strong>:</p>
<p>​	该函数用于在节点 np 下查找指定名称 name 的属性。</p>
<p><strong>函数参数</strong>:</p>
<p>​	np: 要查找的节点。</p>
<p>​	name: 要查找的属性的属性名。</p>
<p>​	lenp: 一个指向整数的指针，用于接收属性值的字节数。</p>
<p><strong>返回值</strong>:</p>
<p>​	如果成功找到了指定名称的属性，则返回对应的属性结构体指针 struct property *；如果未找到，则返回 NULL。</p>
<h3 id="67-1-2-of-property-count-elems-of-size"><a href="#67-1-2-of-property-count-elems-of-size" class="headerlink" title="67.1.2 of_property_count_elems_of_size"></a>67.1.2 of_property_count_elems_of_size</h3><p>该函数在设备树中的设备节点下查找指定名称的属性，并获取该属性中元素的数量。调用该函数可以用于获取设备树属性中某个属性的元素数量，比如一个字符串列表的元素数量或一个整数数组的元素数量等。 </p>
<p><strong>函数原型:</strong></p>
<p>​	int of_property_count_elems_of_size(const struct device_node *np, const char *propname, int elem_size)</p>
<p><strong>头文件</strong>：</p>
<p>\	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用</strong></p>
<p>​	该函数用于获取属性中指定元素的数量。</p>
<p><strong>函数参数</strong>:</p>
<p>​	np: 设备节点。</p>
<p>​	propname: 需要获取元素数量的属性名。</p>
<p>​	elem_size: 单个元素的尺寸。</p>
<p><strong>返回值</strong>:</p>
<p>如果成功获取了指定属性中元素的数量，则返回该数量；如果未找到属性或属性中没有元素，则返回 0。</p>
<h3 id="67-1-3-of-property-read-u32-index"><a href="#67-1-3-of-property-read-u32-index" class="headerlink" title="67.1.3 of_property_read_u32_index"></a>67.1.3 of_property_read_u32_index</h3><p>该函数在设备树中的设备节点下查找指定名称的属性，并获取该属性在给定索引位置处的 u32 类型的数据值。</p>
<p>这个函数通常用于从设备树属性中读取特定索引位置的整数值。通过指定属性名和索引，可以获取属性中指定位置的具体数值。</p>
<p><strong>函数原型</strong>:</p>
<p>​	int of_property_read_u32_index(const struct device_node *np, const char *propname, u32 index, u32 *out_value)</p>
<p><strong>头文件</strong>：</p>
<p>\	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用</strong>:</p>
<p>​	该函数用于从指定属性中获取指定索引位置的 u32 类型的数据值。</p>
<p><strong>函数参数</strong>:</p>
<p>​	np: 设备节点。</p>
<p>​	propname: 要读取的属性名。</p>
<p>​	index: 要读取的属性值在属性中的索引，索引从 0 开始。</p>
<p>​	out_value: 用于存储读取到的值的指针。</p>
<p><strong>返回值</strong>: </p>
<p>​	如果成功读取到了指定属性指定索引位置的 u32 类型的数据值，则返回 0；如果未找到属性或读取失败，则返回相应的错误码。</p>
<h3 id="67-1-4-of-property-read-u64-index"><a href="#67-1-4-of-property-read-u64-index" class="headerlink" title="67.1.4 of_property_read_u64_index"></a>67.1.4 of_property_read_u64_index</h3><p>该函数在设备树中的设备节点下查找指定名称的属性，并获取该属性在给定索引位置处的 u64 类型的数据值。</p>
<p>这个函数通常用于从设备树属性中读取特定索引位置的 64 位整数值。通过指定属性名和索引，可以获取属性中指定位置的具体数值。</p>
<p><strong>函数原型</strong>: </p>
<p>​	static inline int of_property_read_u64_index(const struct device_node *np, const char *propname, u32 index, u64 *out_value)</p>
<p><strong>头文件</strong>：</p>
<p>\	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用</strong>:</p>
<p>​	该函数用于从指定属性中获取指定索引位置的 u64 类型的数据值。</p>
<p><strong>函数参数和返回值</strong>:</p>
<p>​	np: 设备节点。</p>
<p>​	propname: 要读取的属性名。</p>
<p>​	index: 要读取的属性值在属性中的索引，索引从 0 开始。</p>
<p>​	out_value: 用于存储读取到的值的指针。</p>
<p><strong>返回值</strong>:</p>
<p>​	如果成功读取到了指定属性指定索引位置的 u64 类型的数据值，则返回 0；如果未找到属性或读取失败，则返回相应的错误码。</p>
<h3 id="67-1-5-of-property-read-variable-u32-array"><a href="#67-1-5-of-property-read-variable-u32-array" class="headerlink" title="67.1.5 of_property_read_variable_u32_array"></a>67.1.5 of_property_read_variable_u32_array</h3><p>该函数用于从设备树中读取指定属性名的变长数组。通过提供设备节点、属性名和输出数组的指针，可以将设备树中的数组数据读取到指定的内存区域中。同时，还需要指定数组的最小大小和最大大小，以确保读取到的数组符合预期的大小范围。</p>
<p><strong>函数原型</strong>：</p>
<p>​	int of_property_read_variable_u32_array(const struct device_node *np, const char *propname, u32 *out_values, size_t SZ_min, size_t SZ_max)</p>
<p><strong>函数作用</strong>: </p>
<p>​	从指定属性中读取变长的 u32 数组。</p>
<p><strong>函数参数</strong>:</p>
<p>​	np: 设备节点。</p>
<p>​	propname: 要读取的属性名。</p>
<p>​	out_values: 用于存储读取到的 u8 数组的指针。</p>
<p>​	SZ_min: 数组的最小大小。</p>
<p>​	SZ_max: 数组的最大大小。</p>
<p><strong>返回值</strong>：</p>
<p>如果成功读取到了指定属性的 u8 数组，则返回数组的大小。如果未找到属性或读取失败，则返回相应的错误码。</p>
<p>上面介绍的函数用于从指定属性中读取变长的 u32 数组，下面是另外三个读取其他数组大小的函数：</p>
<p>这里给出了四个函数，用于从设备树中读取数组类型的属性值：</p>
<p>从指定属性中读取变长的 u8 数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int of_property_read_variable_u8_array(const struct device_node *np, const char *propname, u8 *out_values, size_t SZ_min, size_t SZ_max)</span><br></pre></td></tr></table></figure>

<p>从指定属性中读取变长的 u16 数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int of_property_read_variable_u16_array(const struct device_node *np, const char *propname, u16 *out_values, size_t SZ_min, size_t SZ_max)</span><br></pre></td></tr></table></figure>

<p>从指定属性中读取变长的 u64 数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int of_property_read_variable_u64_array(const struct device_node *np, const char *propname, u64 *out_values, size_t SZ_min, size_t SZ_max)</span><br></pre></td></tr></table></figure>

<h3 id="67-1-6-of-property-read-string"><a href="#67-1-6-of-property-read-string" class="headerlink" title="67.1.6 of_property_read_string"></a>67.1.6 of_property_read_string</h3><p>该函数在设备树中的设备节点下查找指定名称的属性，并获取该属性的字符串值，最后返回读取到的字符串的指针，通常用于从设备树属性中读取字符串值。通过指定属性名，可以获取属性中的字符串数据。</p>
<p><strong>函数原型</strong>:</p>
<p>​	static inline int of_property_read_string(const struct device_node *np, const char *propname, const char **out_string)</p>
<p><strong>头文件</strong>：</p>
<p>\	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用</strong>:</p>
<p>​	该函数用于从指定属性中读取字符串。</p>
<p><strong>函数参数</strong>:</p>
<p>​	np: 设备节点。</p>
<p>​	propname: 要读取的属性名。</p>
<p>​	out_string: 用于存储读取到的字符串的指针。</p>
<p><strong>返回值</strong>:</p>
<p>​	如果成功读取到了指定属性的字符串，则返回 0；如果未找到属性或读取失败，则返回相应的错误码。</p>
<h2 id="67-2-实验程序编写"><a href="#67-2-实验程序编写" class="headerlink" title="67.2 实验程序编写"></a>67.2 实验程序编写</h2><p>本实验驱动对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\56_of_02。</p>
<p>本小节驱动程序是由65章驱动程序修改而来，由于本章节获取设备树属性的函数需要在查找到设备树节点的前提下使用，所以在下面的程序中，先在probe函数中添加查获取设备树节点，然后添加了本章节学习的of操作相关代码，用来获取设备树节点相关属性。</p>
<p>编写完成的platform_driver.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mod_devicetable.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">mydevice_node</span>;</span>      </span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">u32 value_u32;</span><br><span class="line">u64 value_u64;</span><br><span class="line">u32 out_value[<span class="number">2</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *value_compatible;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">my_property</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的探测函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_probe: Probing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过节点名称查找设备树节点</span></span><br><span class="line">    mydevice_node = of_find_node_by_name(<span class="literal">NULL</span>, <span class="string">&quot;myLed&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;mydevice node is %s\n&quot;</span>, mydevice_node-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找compatible属性</span></span><br><span class="line">    my_property = of_find_property(mydevice_node, <span class="string">&quot;compatible&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    printk(<span class="string">&quot;my_property name is %s\n&quot;</span>, my_property-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取reg属性的元素数量</span></span><br><span class="line">    num = of_property_count_elems_of_size(mydevice_node, <span class="string">&quot;reg&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    printk(<span class="string">&quot;reg num is %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取reg属性的值</span></span><br><span class="line">    of_property_read_u32_index(mydevice_node, <span class="string">&quot;reg&quot;</span>, <span class="number">0</span>, &amp;value_u32);</span><br><span class="line">    of_property_read_u64_index(mydevice_node, <span class="string">&quot;reg&quot;</span>, <span class="number">0</span>, &amp;value_u64);</span><br><span class="line">    printk(<span class="string">&quot;value u32 is 0x%X\n&quot;</span>, value_u32);</span><br><span class="line">    printk(<span class="string">&quot;value u64 is 0x%llx\n&quot;</span>, value_u64);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取reg属性的变长数组</span></span><br><span class="line">    of_property_read_variable_u32_array(mydevice_node, <span class="string">&quot;reg&quot;</span>, out_value, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    printk(<span class="string">&quot;out_value[0] is 0x%X\n&quot;</span>, out_value[<span class="number">0</span>]);</span><br><span class="line">    printk(<span class="string">&quot;out_value[1] is 0x%X\n&quot;</span>, out_value[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取compatible属性的字符串值</span></span><br><span class="line">    of_property_read_string(mydevice_node, <span class="string">&quot;compatible&quot;</span>, &amp;value_compatible);</span><br><span class="line">    printk(<span class="string">&quot;compatible value is %s\n&quot;</span>, value_compatible);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Removing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table_id</span>[]  =</span> &#123;</span><br><span class="line">	&#123;.compatible=<span class="string">&quot;my devicetree&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">		.of_match_table =  of_match_table_id,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="67-3-运行测试"><a href="#67-3-运行测试" class="headerlink" title="67.3 运行测试"></a>67.3 运行测试</h2><h3 id="67-3-1-编译驱动程序"><a href="#67-3-1-编译驱动程序" class="headerlink" title="67.3.1 编译驱动程序"></a>67.3.1 编译驱动程序</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_driver.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_driver.c和Makefile文件目录下，如下图（图67-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024437.png" alt="img"></p>
<p>图 67-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图67-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024375.jpeg" alt="img"></p>
<p>图 67-2</p>
<p>编译完生成platform_driver.ko目标文件，如下图（图67-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024393.jpeg" alt="img"> </p>
<p>图 67-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="67-3-2-运行测试"><a href="#67-3-2-运行测试" class="headerlink" title="67.3.2 运行测试"></a>67.3.2 运行测试</h3><p>在进行实验之前，首先要确保开发板烧写的是我们在65.2.1小节中编译出来的boot.img，开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图67-4）所示：</p>
<p>insmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024402.jpeg" alt="img"> </p>
<p>图 67-4</p>
<p>可以看到总共有8个打印，第一个打印表示查找到的节点为myLed,接下来的打印都是使用该节点进行的属性查找。第二个打印表示查找的属性名为“compatible”，第三个打印表示查找的reg属性数量为2，第四个和第五个分别表示读取到的32位和64位的reg属性值，第6个和第7个打印表示reg的第一个属性值和第二个属性值，第8个打印表示compatite属性值为“my devicetree”。</p>
<p>然后使用以下命令进行驱动模块的卸载，如下图（图66-5）所示：</p>
<p>rmmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024444.png" alt="img"></p>
<p>图 67-5</p>
<p>至此，使用of操作函数获取设备树节点实验就完成了。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-62-dtb文件格式讲解</title>
    <url>/2023/09/05/1-66-of%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E5%AE%9E%E9%AA%8C-%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87%E6%A0%91%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第66章of操作函数实验：获取设备树节点"><a href="#第66章of操作函数实验：获取设备树节点" class="headerlink" title="第66章of操作函数实验：获取设备树节点"></a>第66章of操作函数实验：获取设备树节点</h1><p>在上一章节的学习中，我们学习了设备树下platform_device和platform_driver匹配，现在也只是让他们匹配在了一起，但这样显然是不够的，为了完成一些和硬件相关的需求，我们还需要获取到在设备树中编写的一些属性，那驱动是如何获取设备树中的属性呢，让我们一起进入后续章节的学习吧。</p>
<h2 id="66-1-of操作：获取设备树节点"><a href="#66-1-of操作：获取设备树节点" class="headerlink" title="66.1 of操作：获取设备树节点"></a>66.1 of操作：获取设备树节点</h2><h3 id="66-1-1-of-find-node-by-name函数"><a href="#66-1-1-of-find-node-by-name函数" class="headerlink" title="66.1.1 of_find_node_by_name函数"></a>66.1.1 of_find_node_by_name函数</h3><p>of_find_node_by_name 是Linux内核中用于通过节点名称查找设备树节点的函数。下面是对of_find_node_by_name 函数的详细介绍：</p>
<p><strong>函数原型：</strong></p>
<p>​	struct device_node *of_find_node_by_name(struct device_node *from, const char *name);</p>
<p><strong>头文件：</strong></p>
<p>​	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用：</strong><br>        该函数通过指定的节点名称在设备树中进行查找，返回匹配的节点的 struct device_node 指针。</p>
<p><strong>参数含义：</strong></p>
<p>​	from：指定起始节点，表示从哪个节点开始查找。如果 from 参数为 NULL，则从设备树的根节点开始查找。</p>
<p>​	name：要查找的节点名称。</p>
<p><strong>返回值：</strong></p>
<p>​	如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>​	如果未找到匹配的节点，则返回 NULL。</p>
<p>会在接下来的实验小节中，对该函数进行实际演示。</p>
<h3 id="66-1-2-of-find-node-by-path函数"><a href="#66-1-2-of-find-node-by-path函数" class="headerlink" title="66.1.2 of_find_node_by_path函数"></a>66.1.2 of_find_node_by_path函数</h3><p>of_find_node_by_path 是Linux内核中用于通过节点路径查找设备树节点的函数。下面是对of_find_node_by_path函数的详细介绍：</p>
<p><strong>函数原型：</strong></p>
<p>​	struct device_node *of_find_node_by_path(const char *path);</p>
<p><strong>头文件：</strong></p>
<p>​	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用：</strong><br>    该函数根据节点路径在设备树中进行查找，返回匹配的节点的 struct device_node 指针。</p>
<p><strong>参数含义：</strong></p>
<p>​	path：节点的路径，以斜杠分隔的字符串表示。路径格式为设备树节点的绝对路径，例如 &#x2F;topeet&#x2F;myLed。</p>
<p><strong>返回值：</strong></p>
<p>​	如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>​	如果未找到匹配的节点，则返回 NULL。</p>
<p>​	of_find_node_by_path 函数通过节点路径在设备树中进行查找。路径是设备树节点从根节点到目标节点的完整路径。可以通过指定正确的路径来准确地访问设备树中的特定节点。</p>
<p>​	使用 of_find_node_by_path 函数时，可以直接传递节点的完整路径作为 path 参数，函数会在设备树中查找匹配的节点。这对于已知节点路径的情况非常有用。</p>
<h3 id="66-1-3-of-get-parent函数"><a href="#66-1-3-of-get-parent函数" class="headerlink" title="66.1.3 of_get_parent函数"></a>66.1.3 of_get_parent函数</h3><p>在Linux内核中，of_get_parent 函数用于获取设备树节点的父节点。下面是对of_get_parent函数的详细介绍：</p>
<p><strong>函数原型：</strong></p>
<p>​	struct device_node *of_get_parent(const struct device_node *node);</p>
<p><strong>头文件：</strong></p>
<p>​	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用：</strong><br>    该函数接收一个指向设备树节点的指针 node，并返回该节点的父节点的指针。</p>
<p><strong>参数含义：</strong></p>
<p>​	node：要获取父节点的设备树节点指针。</p>
<p><strong>返回值：</strong></p>
<p>​	如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>​	如果未找到匹配的节点，则返回 NULL。</p>
<p>​	使用 of_get_parent 函数时，可以将特定的设备树节点作为参数传递给函数，然后它将返回该节点的父节点。这对于在设备树中导航和访问节点之间的层次关系非常有用。</p>
<p>​	父节点在设备树中表示了节点之间的层次结构关系。通过获取父节点，你可以访问上一级节点的属性和配置信息，从而更好地理解设备树中的节点之间的关系。</p>
<h3 id="66-1-4-of-get-next-child函数"><a href="#66-1-4-of-get-next-child函数" class="headerlink" title="66.1.4 of_get_next_child函数"></a>66.1.4 of_get_next_child函数</h3><p>在Linux内核中，of_get_next_child 函数用于获取设备树节点的下一个子节点。下面是对of_get_next_child 函数的详细介绍：</p>
<p><strong>函数原型：</strong></p>
<p>​	struct device_node *of_get_next_child(const struct device_node *node, struct device_node *prev);</p>
<p><strong>头文件：</strong></p>
<p>​	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用：</strong><br>    该函数接收两个参数：node 是当前节点，prev 是上一个子节点。它返回下一个子节点的指针。</p>
<p><strong>参数含义：</strong></p>
<p>​	node：当前节点，用于指定要获取子节点的起始节点。</p>
<p>​	prev：上一个子节点，用于指定从哪个子节点开始获取下一个子节点。如果为 NULL，则从起始节点的第一个子节点开始。</p>
<p><strong>返回值：</strong></p>
<p>​	如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>​	如果未找到匹配的节点，则返回 NULL。</p>
<p>​	使用 of_get_next_child 函数时，可以传递当前节点以及上一个子节点作为参数。函数将从上一个子节点的下一个节点开始，查找并返回下一个子节点。</p>
<p>​	设备树中的子节点表示了节点之间的层次关系。通过获取子节点，你可以遍历和访问当前节点的所有子节点，以便进一步处理它们的属性和配置信息。</p>
<h3 id="64-1-5-of-find-compatible-node函数"><a href="#64-1-5-of-find-compatible-node函数" class="headerlink" title="64.1.5 of_ find_ compatible_ node函数"></a>64.1.5 of_ find_ compatible_ node函数</h3><p>当设备树中存在多个设备节点，需要根据设备的兼容性字符串进行匹配时，可以使用 of_find_compatible_node 函数。该函数用于在设备树中查找与指定兼容性字符串匹配的节点。</p>
<p><strong>函数原型：</strong></p>
<p>​	struct device_node *of_find_compatible_node(struct device_node *from, const char *type, const char *compatible);</p>
<p><strong>头文件：</strong></p>
<p>​	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用：</strong><br>    在设备树中查找与指定兼容性字符串匹配的节点。</p>
<p><strong>参数含义：</strong></p>
<p>​	from：指定起始节点，表示从哪个节点开始查找。如果 from 参数为 NULL，则从设备树的根节点开始查找。</p>
<p>​	type：要匹配的设备类型字符串，通常是 compatible 属性中的一部分。</p>
<p>​	compatible：要匹配的兼容性字符串，通常是设备树节点的 compatible 属性中的值。</p>
<p><strong>返回值：</strong></p>
<p>​	如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>​	如果未找到匹配的节点，则返回 NULL。</p>
<p>​	使用 of_find_compatible_node 函数时，可以指定起始节点和需要匹配的设备类型字符串以及兼容性字符串。函数会从起始节点开始遍历设备树，查找与指定兼容性字符串匹配的节点，并返回匹配节点的指针。</p>
<h3 id="64-1-6-of-find-matching-node-and-match函数"><a href="#64-1-6-of-find-matching-node-and-match函数" class="headerlink" title="64.1.6 of_ find matching node_ and_ match函数"></a>64.1.6 of_ find matching node_ and_ match函数</h3><p>在Linux内核中，of_ find matching node_ and_ match函数用于根据给定的of_device_id匹配表在设备树中查找匹配的节点。</p>
<p><strong>函数原型：</strong></p>
<p>​	struct device_node *of_find_matching_node_and_match(struct device_node *from,const struct of_device_id *matches, const struct of_device_id **match);</p>
<p><strong>头文件：</strong></p>
<p>#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用：</strong><br>    根据给定的of_device_id匹配表在设备树中查找匹配的节点。</p>
<p><strong>参数含义：</strong></p>
<p>​	from：表示从哪个节点开始搜索。通常将上一次调用该函数返回的节点作为参数传递给from，以便从上一次的下一个节点开始搜索。如果要从设备树的根节点开始搜索，可以将from参数设置为NULL。</p>
<p>​	matches：指向一个of_device_id类型的匹配表，该表包含要搜索的匹配项。</p>
<p>​	match：用于输出匹配到的of_device_id条目的指针。</p>
<p><strong>返回值：</strong></p>
<p>​	如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>​	如果未找到匹配的节点，则返回 NULL。</p>
<p>of_find_matching_node_and_match函数在设备树中遍历节点，对每个节点使用__of_match_node函数进行匹配。如果找到匹配的节点，将返回该节点的指针，并将match指针更新为匹配到的of_device_id条目，函数会自动增加匹配节点的引用计数。以下是使用of_find_matching_node_and_match函数的示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">my_match_table</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;vendor,device&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">match</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从根节点开始查找匹配的节点</span></span><br><span class="line">np = of_find_matching_node_and_match(<span class="literal">NULL</span>, my_match_table, &amp;match);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个of_device_id匹配表my_match_table，其中包含了一个兼容性字符串为”vendor,device”的匹配项。然后，我们使用of_find_matching_node_and_match函数从根节点开始查找匹配的节点。</p>
<h2 id="66-2实验程序编写"><a href="#66-2实验程序编写" class="headerlink" title="66.2实验程序编写"></a>66.2实验程序编写</h2><p>本实验驱动对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\55_of_01。</p>
<p>本小节驱动程序是由上一章程序修改而来，相较于源程序只是在probe函数中添加了本章节学习的of操作相关代码，用来获取设备树节点。</p>
<p>编写完成的platform_driver.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mod_devicetable.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">mydevice_node</span>;</span>      </span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">mynode_match</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">mynode_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123;.compatible=<span class="string">&quot;my devicetree&quot;</span>&#125;,</span><br><span class="line">	&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_probe: Probing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过节点名称查找设备树节点</span></span><br><span class="line">    mydevice_node = of_find_node_by_name(<span class="literal">NULL</span>, <span class="string">&quot;myLed&quot;</span>);</span><br><span class="line">	printk(<span class="string">&quot;mydevice node is %s\n&quot;</span>, mydevice_node-&gt;name);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 通过节点路径查找设备树节点</span></span><br><span class="line">    mydevice_node = of_find_node_by_path(<span class="string">&quot;/topeet/myLed&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;mydevice node is %s\n&quot;</span>, mydevice_node-&gt;name);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 获取父节点</span></span><br><span class="line">    mydevice_node = of_get_parent(mydevice_node);</span><br><span class="line">    printk(<span class="string">&quot;myled&#x27;s parent node is %s\n&quot;</span>, mydevice_node-&gt;name);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 获取子节点</span></span><br><span class="line">    mydevice_node = of_get_next_child(mydevice_node, <span class="literal">NULL</span>);</span><br><span class="line">    printk(<span class="string">&quot;myled&#x27;s sibling node is %s\n&quot;</span>, mydevice_node-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用compatible值查找节点</span></span><br><span class="line">	mydevice_node=of_find_compatible_node(<span class="literal">NULL</span> ,<span class="literal">NULL</span>, <span class="string">&quot;my devicetree&quot;</span>);</span><br><span class="line">	printk(<span class="string">&quot;mydevice node is %s\n&quot;</span> , mydevice_node-&gt;name);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//根据给定的of_device_id匹配表在设备树中查找匹配的节点</span></span><br><span class="line">	mydevice_node=of_find_matching_node_and_match(<span class="literal">NULL</span> , mynode_of_match, &amp;mynode_match);</span><br><span class="line">	printk(<span class="string">&quot;mydevice node is %s\n&quot;</span> ,mydevice_node-&gt;name);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Removing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table_id</span>[]  =</span> &#123;</span><br><span class="line">	&#123;.compatible=<span class="string">&quot;my devicetree&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">		.of_match_table =  of_match_table_id,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="66-3-运行测试"><a href="#66-3-运行测试" class="headerlink" title="66.3 运行测试"></a>66.3 运行测试</h2><h3 id="66-3-1-编译驱动程序"><a href="#66-3-1-编译驱动程序" class="headerlink" title="66.3.1 编译驱动程序"></a>66.3.1 编译驱动程序</h3><p>在上一小节中的platform_driver.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_driver.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_driver.c和Makefile文件目录下，如下图（图66-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024273.jpeg" alt="img"> </p>
<p>图 66-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图66-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024325.jpeg" alt="img"> </p>
<p>图 66-2</p>
<p>编译完生成platform_driver.ko目标文件，如下图（图66-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024321.jpeg" alt="img"> </p>
<p>图 66-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="66-3-2-运行测试"><a href="#66-3-2-运行测试" class="headerlink" title="66.3.2 运行测试"></a>66.3.2 运行测试</h3><p>在进行实验之前，首先要确保开发板烧写的是我们在65.2.1小节中编译出来的boot.img，开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图66-4）所示：</p>
<p>insmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024311.jpeg" alt="img"> </p>
<p>图 66-4</p>
<p>可以看到总共有4个打印，前两个打印都是查找的myLed节点，第三个打印是查找的myLed的父节点，也就是topeet节点，第四个打印是查找的topeet的子节点，也就又回到了myLed节点。第5个打印是通过compatible属性查找到的myLed节点，第6个打印是通过of_device_id匹配表查找到的myLed节点.</p>
<p>然后使用以下命令进行驱动模块的卸载，如下图（图66-5）所示：</p>
<p>rmmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024287.jpeg" alt="img"> </p>
<p>图 66-5</p>
<p>至此，使用of操作函数获取设备树节点实验就完成了。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-62-dtb文件格式讲解</title>
    <url>/2023/09/05/1-65-%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B8%8Bplatform-device%E5%92%8Cplatform-driver%E5%8C%B9%E9%85%8D%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第65章-设备树下platform-device和platform-driver匹配实验"><a href="#第65章-设备树下platform-device和platform-driver匹配实验" class="headerlink" title="第65章 设备树下platform_device和platform_driver匹配实验"></a>第65章 设备树下platform_device和platform_driver匹配实验</h1><p>在上一章节中我们学习了从device_node到platform_device的转换流程，转换完成之后操作系统才能够识别和管理设备，从而与platform_driver进行匹配，在本章将将会对设备树下platform_device和platform_driver的匹配进行讲解。</p>
<h2 id="65-1-of-match-table"><a href="#65-1-of-match-table" class="headerlink" title="65.1 of_match_table"></a>65.1 of_match_table</h2><p>在前面平台总线相关章节的学习中，了解到只有platform_device结构体中的name 属性与platform_driver结构体中嵌套的driver结构体name属性或者id_table相同才能加载probe初始化函数。</p>
<p>而为了使设备树能够与驱动程序进行匹配，需要在platform_driver驱动程序中添加driver结构体的of_match_table 属性。这个属性是一个指向 const struct of_device_id 结构的指针，用于描述设备树节点和驱动程序之间的匹配规则。of_device_id 结构体定义在内核源码的“&#x2F;include&#x2F;linux&#x2F;mod_devicetable.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>	name[<span class="number">32</span>];</span><br><span class="line">	<span class="type">char</span>	type[<span class="number">32</span>];</span><br><span class="line">	<span class="type">char</span>	compatible[<span class="number">128</span>];</span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct of_device_id 结构体通常作为一个数组在驱动程序中定义，用于描述设备树节点和驱动程序之间的匹配规则。数组的最后一个元素必须是一个空的结构体，以标记数组的结束。</p>
<p>以下是一个示例，展示了如何在驱动程序中使用 struct of_device_id 进行设备树匹配</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">my_driver_match</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;vendor,device-1&quot;</span> &#125;,</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;vendor,device-2&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，my_driver_match 是一个 struct of_device_id 结构体数组。每个数组元素都包含了一个 compatible 字段，用于指定设备树节点的兼容性字符串。驱动程序将根据这些兼容性字符串与设备树中的节点进行匹配。</p>
<h2 id="65-2实验程序编写"><a href="#65-2实验程序编写" class="headerlink" title="65.2实验程序编写"></a>65.2实验程序编写</h2><p>本次实验的要求使用设备树描述下面的内存资源：<br><strong>内存资源：</strong></p>
<p>起始地址：0xFDD60000</p>
<p>结束地址：0xFDD60004</p>
<p>然后编写对应的platform_driver驱动程序，要求跟上述内存资源所创建的节点进行匹配，从而验证 上一小节讲解的of_match_table 属性。</p>
<h3 id="65-2-1-设备树的编写"><a href="#65-2-1-设备树的编写" class="headerlink" title="65.2.1 设备树的编写"></a>65.2.1 设备树的编写</h3><p>​	修改完成的dts文件和编译完成的boot.img镜像对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\54_devicetree_probe\dts。</p>
<p>首先来对rk3568的设备树结构进行以下介绍，根据sdk源码目录下的“device&#x2F;rockchip&#x2F;rk356x&#x2F;BoardConfig-rk3568-evb1-ddr4-v10.mk”默认配置文件可以了解到编译的设备树为rk3568-evb1-ddr4-v10-linux.dts,设备树之间的包含关系如下表所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024599.png" alt="image-20230906172158251"></p>
<p>rk3568-evb1-ddr4-v10-linux.dts是顶层设备树，为了便于理解我们之后在该设备树下进行节点的添加（当然这里也可以修改其他设备树），进入该设备树文件之后如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024627.jpeg" alt="img"> </p>
<p>然后将根据需求编写的设备树节点添加到rk3568-evb1-ddr4-v10-linux.dts中，要添加的内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">    topeet&#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        compatible = <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line"></span><br><span class="line">        myLed&#123;</span><br><span class="line">            compatible = <span class="string">&quot;my devicetree&quot;</span>;</span><br><span class="line">            reg = &lt;<span class="number">0xFDD60000</span> <span class="number">0x00000004</span>&gt;;</span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;;      </span><br></pre></td></tr></table></figure>

<p>为了避免#address-cells &#x3D; &lt;1&gt;; 和 #size-cells &#x3D; &lt;1&gt;;这两个属性改变根节点其他的节点的属性，所以在这里创建了一个topeet节点。在这个示例中，#address-cells 设置为 1表示地址使用一个32位的单元，#size-cells 也设置为 1 表示大小使用一个32位的单元。</p>
<p>第5行：将compatible属性设置为”simple-bus”用于表示 topeet 节点的兼容性，指明它是一个简单总线设备，在转换platform_device的过程中，会继续查找该节点的子节点。</p>
<p>第8行：myLed 节点下的compatible属性为”my devicetree”，表明该节点将会被转换为platform_device。</p>
<p>第9行：这个属性用于描述 myLed 节点的寄存器信息。reg 属性的值 &lt;0xFDD60000 0x00000004&gt; 表示 myLed 设备的寄存器起始地址为 0xFDD60000，大小为 0x00000004。</p>
<p>添加完成如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024665.jpeg" alt="img"> </p>
<p>保存退出之后，重新编译内核源码，编译完成之后将生成的boot.img烧写到开发板即可。</p>
<h3 id="66-2-2-驱动程序的编写"><a href="#66-2-2-驱动程序的编写" class="headerlink" title="66.2.2 驱动程序的编写"></a>66.2.2 驱动程序的编写</h3><p>本实验驱动对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\54_devicetree_probe\module。</p>
<p>本小节驱动程序是由“第52章 注册platform驱动实验”程序修改而来，相较于源程序只是添加了of_match_table相关代码，用来与设备树节点进行匹配。</p>
<p>编写完成的platform_driver.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mod_devicetable.h&gt;</span></span></span><br><span class="line"><span class="comment">// 平台设备的初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_probe: Probing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Removing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table_id</span>[]  =</span> &#123;</span><br><span class="line">	&#123;.compatible=<span class="string">&quot;my devicetree&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">		.of_match_table =  of_match_table_id,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="65-3-运行测试"><a href="#65-3-运行测试" class="headerlink" title="65.3 运行测试"></a>65.3 运行测试</h2><p>在上一小节中的platform_driver.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_driver.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<h3 id="65-3-1-编译驱动程序"><a href="#65-3-1-编译驱动程序" class="headerlink" title="65.3.1 编译驱动程序"></a>65.3.1 编译驱动程序</h3><p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_driver.c和Makefile文件目录下，如下图（图65-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024622.jpeg" alt="img"> </p>
<p>图 65-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图65-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024694.jpeg" alt="img"> </p>
<p>图 65-2</p>
<p>编译完生成platform_driver.ko目标文件，如下图（图65-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024642.jpeg" alt="img"> </p>
<p>图 65-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="65-3-2-运行测试"><a href="#65-3-2-运行测试" class="headerlink" title="65.3.2 运行测试"></a>65.3.2 运行测试</h3><p>在进行实验之前，首先要确保开发板烧写的是我们在65.2.1小节中编译出来的boot.img。开发板启动之后，首先进入到“&#x2F;proc&#x2F;device-tree”目录下，查看是否已经存在了topeet目录，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024040.jpeg" alt="img"> </p>
<p>只有在设备树节点编写正确的前提下，这里才会生成topeet目录，如果没有出现topeet目录就要回头检查看看了。</p>
<p>然后使用以下命令进行驱动模块的加载，如下图（图65-4）所示：</p>
<p>insmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024018.jpeg" alt="img"> </p>
<p>图 65-4</p>
<p>可以看到成功打印了在probe函数中的打印，证明我们添加的设备树节点和platform_driver驱动匹配成功了。</p>
<p>然后使用以下命令进行驱动模块的卸载，如下图（图65-5）所示：</p>
<p>rmmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024031.jpeg" alt="img"> </p>
<p>图 65-5</p>
<p>至此，设备树下platform_device和platform_driver匹配实验就完成了。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-62-dtb文件格式讲解</title>
    <url>/2023/09/05/1-64-device-node%E8%BD%AC%E6%8D%A2%E6%88%90platform-device%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第64章-device-node转换成platform-device实验"><a href="#第64章-device-node转换成platform-device实验" class="headerlink" title="第64章 device_node转换成platform_device实验"></a>第64章 device_node转换成platform_device实验</h1><p>在上一章中，我们学习了dtb二进制文件展开成device_node的具体流程，而device_node这时候还并不能跟内核中的platform_driver进行对接，而为了让操作系统能够识别和管理设备，需要将设备节点转换为平台设备。</p>
<h2 id="64-1-转换规格"><a href="#64-1-转换规格" class="headerlink" title="64.1 转换规格"></a>64.1 转换规格</h2><p>在之前学习的平台总线模型中，device部分是用platform_device结构体来描述硬件资源的，所以内核最终会将内核认识的device_node树转换platform_ device，但是并不是所有的device_node都会被转换成platform_ device，只有满足要求的才会转换成platform_ device,转换成platform_device的节点可以在&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;devices下查看，那device_node节点要满足什么要求才会被转换成platform_device呢? </p>
<p>根据规则1，首先遍历根节点下包含 compatible 属性的子节点，对于每个子节点，创建一个对应的 platform_device。</p>
<p>根据规则2，遍历包含 compatible 属性为 “simple-bus”、”simple-mfd” 或 “isa” 的节点以及它们的子节点。如果子节点包含 compatible 属性值则会创建一个对应的platform_device。</p>
<p>根据规则3，检查节点的 compatible 属性是否包含 “arm” 或 “primecell”。如果是，则不将该节点转换为 platform_device，而是将其识别为 AMBA 设备。</p>
<p>接下来将通过几个设备树示例对上述规则进行实践。</p>
<p><strong>举例1：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = <span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0, 115200&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a35&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x1</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    aliases &#123;</span><br><span class="line">        led1 = <span class="string">&quot;/gpio@22020101&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node1 &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">        gpio@<span class="number">22020102</span> &#123;</span><br><span class="line">            reg = &lt;<span class="number">0x20220102</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node2 &#123;</span><br><span class="line">        node1-child &#123;</span><br><span class="line">            pinnum = &lt;<span class="number">01234</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@<span class="number">22020101</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;led&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x20220101</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的设备树中，总共有chosen、cpu1: cpu@1、aliases、node1、node2、gpio@22020101</p>
<p>这六个节点，其中前五个节点都没有compatible属性，所以并不会被转换为platform_device，而最后一个gpio@22020101节点符合规则一，在根节点下，且有compatible属性，所以最后会转换为platform_device。</p>
<p><strong>举例2：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = <span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0, 115200&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a35&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x1</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    aliases &#123;</span><br><span class="line">        led1 = <span class="string">&quot;/gpio@22020101&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node1 &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">		    compatible = <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line">        gpio@<span class="number">22020102</span> &#123;</span><br><span class="line">            reg = &lt;<span class="number">0x20220102</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node2 &#123;</span><br><span class="line">        node1-child &#123;</span><br><span class="line">            pinnum = &lt;<span class="number">01234</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@<span class="number">22020101</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;led&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x20220101</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相较于示例1的设备树，这里在node1节点中添加了 compatible 属性，但是这个compatible属性值为simple-bus，我们需要继续看他的子节点，子节点 gpio@22020102 并没有compatible属性值，所以这里的node1节点不会被转换。</p>
<p><strong>举例3：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = <span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0, 115200&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a35&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x1</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    aliases &#123;</span><br><span class="line">        led1 = <span class="string">&quot;/gpio@22020101&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node1 &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">		    compatible = <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line">        gpio@<span class="number">22020102</span> &#123;</span><br><span class="line">			compatible = <span class="string">&quot;gpio&quot;</span>;</span><br><span class="line">            reg = &lt;<span class="number">0x20220102</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node2 &#123;</span><br><span class="line">        node1-child &#123;</span><br><span class="line">            pinnum = &lt;<span class="number">01234</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@<span class="number">22020101</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;led&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x20220101</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相较于示例2的设备树，这里在node1节点的子节点 gpio@22020102 中添加了 compatible 属性，node1节点的compatible属性值为simple-bus，然后需要继续看他的子节点，子节点 gpio@22020102 的compatible属性值为gpio，所以这里的gpio@22020102节点会被转换成platform_device。</p>
<p>示例4：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = <span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0,115200&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpul: cpu@<span class="number">1</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a35&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x1</span>&gt;;</span><br><span class="line"></span><br><span class="line">        amba &#123;</span><br><span class="line">            compatible = <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line">            <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">            <span class="meta">#size-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">            ranges;</span><br><span class="line"></span><br><span class="line">            dmac_peri: dma-controller@ff250000 &#123;</span><br><span class="line">                compatible = <span class="string">&quot;arm,p1330&quot;</span>, <span class="string">&quot;arm,primecell&quot;</span>;</span><br><span class="line">                reg = &lt;<span class="number">0x0</span> <span class="number">0xff250000</span> <span class="number">0x0</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">                interrupts = &lt;GIC_SPI <span class="number">2</span> IRQ_TYPE_LEVEL_HIGH&gt;,</span><br><span class="line">                             &lt;GIC_SPI <span class="number">3</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">                <span class="meta">#dma-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">                arm,pl330-broken-no-flushp;</span><br><span class="line">                arm,p1330-periph-burst;</span><br><span class="line">                clocks = &lt;&amp;cru ACLK DMAC_PERI&gt;;</span><br><span class="line">                clock-names = <span class="string">&quot;apb_pclk&quot;</span>;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            dmac_bus: dma-controller@ff600000 &#123;</span><br><span class="line">                compatible = <span class="string">&quot;arm,p1330&quot;</span>, <span class="string">&quot;arm,primecell&quot;</span>;</span><br><span class="line">                reg = &lt;<span class="number">0x0</span> <span class="number">0xff600000</span> <span class="number">0x0</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">                interrupts = &lt;GIC_SPI <span class="number">0</span> IRQ_TYPE_LEVEL_HIGH&gt;,</span><br><span class="line">                             &lt;GIC_SPI <span class="number">1</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">                <span class="meta">#dma-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">                arm,pl330-broken-no-flushp;</span><br><span class="line">                arm,pl330-periph-burst;</span><br><span class="line">                clocks = &lt;&amp;cru ACLK_DMAC_BUS&gt;;</span><br><span class="line">                clock-names = <span class="string">&quot;apb_pclk&quot;</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>amba 节点的compatible值为simple-bus，不会被转换为 platform_device，而是作为父节点用于组织其他设备，所以需要来查看他的子节点。</p>
<p>dmac_peri: dma-controller@ff250000 节点: 该节点的 compatible 属性包含 “arm,p1330” 和 “arm,primecell”，根据规则3，该节点不会被转换为 platform_device，而是被识别为 AMBA 设备。</p>
<p>dmac_bus: dma-controller@ff600000 节点: 该节点的 compatible 属性包含 “arm,p1330” 和 “arm,primecell”，根据规则3，该节点不会被转换为 platform_device，而是被识别为 AMBA 设备。</p>
<h2 id="64-2-转换流程源码分析"><a href="#64-2-转换流程源码分析" class="headerlink" title="64.2 转换流程源码分析"></a>64.2 转换流程源码分析</h2><p>首先进入到内核源码目录下的“drivers&#x2F;of&#x2F;platform.c”文件中，找到第555行，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arch_initcall_sync(of_platform_default_populate_init);</span><br></pre></td></tr></table></figure>

<p>arch_initcall_sync 是 Linux 内核中的一个函数，用于在内核初始化过程中执行架构相关的初始化函数。它属于内核的初始化调用机制，用于确保在系统启动过程中适时地调用特定架构的初始化函数。</p>
<p>在Linux内核的初始化过程中，各个子系统和架构会注册自己的初始化函数。这些初始化函数负责完成特定子系统或架构相关的初始化工作，例如初始化硬件设备、注册中断处理程序、设置内存映射等。而 arch_initcall_sync 函数则用于调用与当前架构相关的初始化函数。</p>
<p>当内核启动时，调用 rest_init() 函数来启动初始化过程。在初始化过程中，arch_initcall_sync 函数会被调用，以确保所有与当前架构相关的初始化函数按照正确的顺序执行。这样可以保证在启动过程中，特定架构相关的初始化工作得到正确地完成。</p>
<p>而of_platform_default_populate_init函数的作用是在内核初始化过程中自动解析设备树，并根据设备树中的设备节点创建对应的 platform_device 结构。它会遍历设备树中的设备节点，并为每个设备节点创建一个对应的 platform_device 结构，然后将其注册到内核中，使得设备驱动程序能够识别和操作这些设备。该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">of_platform_default_populate_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂停设备链接供应商同步状态</span></span><br><span class="line">    device_links_supplier_sync_state_pause();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设备树尚未填充，则返回错误码</span></span><br><span class="line">    <span class="keyword">if</span> (!of_have_populated_dt())</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 显式处理某些兼容性，因为我们不想为/reserved-memory中的每个具有“compatible”的节点创建platform_device。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    for_each_matching_node(node, reserved_mem_matches)</span><br><span class="line">        of_platform_device_create(node, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找节点 &quot;/firmware&quot;</span></span><br><span class="line">    node = of_find_node_by_path(<span class="string">&quot;/firmware&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="comment">// 使用该节点进行设备树平台设备的填充</span></span><br><span class="line">        of_platform_populate(node, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        of_node_put(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充其他设备</span></span><br><span class="line">    fw_devlink_pause();</span><br><span class="line">    of_platform_default_populate(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    fw_devlink_resume();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第6行：暂停设备链接供应商的同步状态，确保设备链接的状态不会在此过程中被改变。</p>
<p>第9行：检查设备树是否已经被填充。如果设备树尚未填充，则返回错误码 -ENODEV。</p>
<p>第16行：遍历设备树中与 reserved_mem_matches 匹配的节点。这些节点是 &#x2F;reserved-memory 中具有 “compatible” 属性的节点。</p>
<p>第17行：为 &#x2F;reserved-memory 中匹配的节点创建 platform_device 结构。这些节点不会为每个节点都创建 platform_device，而是根据需要进行显式处理。</p>
<p>第20行：在设备树中查找路径为 “&#x2F;firmware” 的节点。</p>
<p>第23行：使用找到的节点填充设备树中的平台设备。这些节点可能包含与固件相关的设备。</p>
<p>第28行：暂停固件设备链接，确保在填充其他设备时链接状态不会改变。</p>
<p>第29行：填充设备树中的其他设备。</p>
<p>第30行：恢复固件设备链接。</p>
<p>上诉内容中我们要着重关注的是第29行的of_platform_default_populate(NULL, NULL, NULL)函数，找到该函数的定义之后如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_platform_default_populate</span><span class="params">(<span class="keyword">struct</span> device_node *root,</span></span><br><span class="line"><span class="params">				 <span class="type">const</span> <span class="keyword">struct</span> of_dev_auxdata *lookup,</span></span><br><span class="line"><span class="params">				 <span class="keyword">struct</span> device *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> of_platform_populate(root, of_default_bus_match_table, lookup,</span><br><span class="line">				    parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的作用是调用 of_platform_populate 函数来填充设备树中的平台设备，并使用默认的设备匹配表 of_default_bus_match_table，设备匹配表内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_default_bus_match_table</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;simple-bus&quot;</span>, &#125;,</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;simple-mfd&quot;</span>, &#125;,</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;isa&quot;</span>, &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM_AMBA</span></span><br><span class="line">	&#123; .compatible = <span class="string">&quot;arm,amba-bus&quot;</span>, &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_ARM_AMBA */</span></span></span><br><span class="line">	&#123;&#125; <span class="comment">/* Empty terminated list */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述的设备匹配表就是我们在第一小节中第2条规则，，函数将自动根据设备树节点的属性匹配相应的设备驱动程序，并填充内核的平台设备列表。接下来找到of_platform_populate函数的定义，该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_platform_populate</span><span class="params">(<span class="keyword">struct</span> device_node *root,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> of_device_id *matches,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> of_dev_auxdata *lookup,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> device *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span></span><br><span class="line">	<span class="type">int</span> rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 root 不为空，则增加 root 节点的引用计数；否则，在设备树中根据路径查找 root 节点</span></span><br><span class="line">	root = root ? of_node_get(root) : of_find_node_by_path(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!root)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;%s()\n&quot;</span>, __func__);</span><br><span class="line">	pr_debug(<span class="string">&quot; starting at: %pOF\n&quot;</span>, root);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 暂停设备链接供应商同步状态</span></span><br><span class="line">	device_links_supplier_sync_state_pause();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历 root 节点的所有子节点</span></span><br><span class="line">	for_each_child_of_node(root, child) &#123;</span><br><span class="line">		<span class="comment">// 创建平台设备并添加到设备树总线</span></span><br><span class="line">		rc = of_platform_bus_create(child, matches, lookup, parent, <span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">if</span> (rc) &#123;</span><br><span class="line">			of_node_put(child);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 恢复设备链接供应商同步状态</span></span><br><span class="line">	device_links_supplier_sync_state_resume();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置 root 节点的 OF_POPULATED_BUS 标志</span></span><br><span class="line">	of_node_set_flag(root, OF_POPULATED_BUS);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放 root 节点的引用计数</span></span><br><span class="line">	of_node_put(root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的具体执行步骤如下：</p>
<p>第10行：检查给定的设备树节点 node 是否为有效节点。如果节点为空，函数将立即返回。</p>
<p>第21行：遍历设备树节点的子节点，查找与平台设备相关的节点。这些节点通常具有 compatible 属性，用于匹配设备驱动程序。</p>
<p>第23行：对于每个找到的平台设备节点，创建一个 platform_device 结构，并根据设备树节点的属性设置该结构的各个字段。</p>
<p>第25行：将创建的 platform_device 添加到内核的平台设备列表中，以便设备驱动程序能够识别和操作这些设备。</p>
<p>接下来对该函数的第23行核心代码of_platform_bus_create(child, matches, lookup, parent, true)函数进行讲解，该函数的具体定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">of_platform_bus_create</span><span class="params">(<span class="keyword">struct</span> device_node *bus,</span></span><br><span class="line"><span class="params">				  <span class="type">const</span> <span class="keyword">struct</span> of_device_id *matches,</span></span><br><span class="line"><span class="params">				  <span class="type">const</span> <span class="keyword">struct</span> of_dev_auxdata *lookup,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> device *parent, <span class="type">bool</span> strict)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_dev_auxdata</span> *<span class="title">auxdata</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *bus_id = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">void</span> *platform_data = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 确保设备节点具有 compatible 属性 */</span></span><br><span class="line">	<span class="keyword">if</span> (strict &amp;&amp; (!of_get_property(bus, <span class="string">&quot;compatible&quot;</span>, <span class="literal">NULL</span>))) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;%s() - skipping %pOF, no compatible prop\n&quot;</span>,</span><br><span class="line">			 __func__, bus);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 跳过不想创建设备的节点 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(of_match_node(of_skipped_node_table, bus))) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;%s() - skipping %pOF node\n&quot;</span>, __func__, bus);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (of_node_check_flag(bus, OF_POPULATED_BUS)) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;%s() - skipping %pOF, already populated\n&quot;</span>,</span><br><span class="line">			__func__, bus);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	auxdata = of_dev_lookup(lookup, bus);</span><br><span class="line">	<span class="keyword">if</span> (auxdata) &#123;</span><br><span class="line">		bus_id = auxdata-&gt;name;</span><br><span class="line">		platform_data = auxdata-&gt;platform_data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (of_device_is_compatible(bus, <span class="string">&quot;arm,primecell&quot;</span>)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 在此处不返回错误以保持与旧设备树文件的兼容性。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		of_amba_device_create(bus, bus_id, platform_data, parent);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent);</span><br><span class="line">	<span class="keyword">if</span> (!dev || !of_match_node(matches, bus))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	for_each_child_of_node(bus, child) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;   create child: %pOF\n&quot;</span>, child);</span><br><span class="line">		rc = of_platform_bus_create(child, matches, lookup, &amp;dev-&gt;dev, strict);</span><br><span class="line">		<span class="keyword">if</span> (rc) &#123;</span><br><span class="line">			of_node_put(child);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	of_node_set_flag(bus, OF_POPULATED_BUS);</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第14行：如果 strict 为真且设备节点 bus 没有兼容性属性，则输出调试信息并返回 0。这个条件判断确保设备节点具有 compatible 属性，因为 compatible 属性用于匹配设备驱动程序，对应我们在上一小节的第1条规则。</p>
<p>第21行：如果设备节点 bus 在被跳过的节点表中，则输出调试信息并返回 0。这个条件判断用于跳过不想创建设备的节点。</p>
<p>第27行：如果设备节点 bus 的 OF_POPULATED_BUS 标志已经设置，则输出调试信息并返回 0。这个条件判断用于避免重复创建已经填充的设备节点。</p>
<p>第34行：使用 lookup 辅助数据结构查找设备节点 bus 的特定配置信息，并将其赋值给变量 bus_id 和 platform_data。这个步骤用于获取设备节点的特定配置信息，以便在创建平台设备时使用，由于这里传入的参数为NULL，所以下面的条件判断并不会被执行。</p>
<p>第39行：如果设备节点 bus 兼容于 “arm,primecell”，则调用 of_amba_device_create 函数创建 AMBA 设备，并返回 0，对应我们在上一小节学习的第3条规则。</p>
<p>第47行：调用 of_platform_device_create_pdata函数创建平台设备，并将其赋值给变量 dev。然后，检查设备节点 bus是否与给定的匹配表 <code>matches</code> 匹配。如果平台设备创建失败或者设备节点不匹配，那么返回 0。</p>
<p>第51行-第58行：遍历设备节点 bus 的每个子节点 child，并递归调用 of_platform_bus_create 函数来创建子节点的平台设备。</p>
<p>接下来对该函数的第47行 of_platform_device_create_pdata函数进行讲解，该函数的具体定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> platform_device *<span class="title function_">of_platform_device_create_pdata</span><span class="params">(</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">					<span class="type">const</span> <span class="type">char</span> *bus_id,</span></span><br><span class="line"><span class="params">					<span class="type">void</span> *platform_data,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> device *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查设备节点是否可用或已填充 */</span></span><br><span class="line">	<span class="keyword">if</span> (!of_device_is_available(np) ||</span><br><span class="line">	    of_node_test_and_set_flag(np, OF_POPULATED))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 分配平台设备结构体 */</span></span><br><span class="line">	dev = of_device_alloc(np, bus_id, parent);</span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">goto</span> err_clear_flag;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置平台设备的一些属性 */</span></span><br><span class="line">	dev-&gt;dev.coherent_dma_mask = DMA_BIT_MASK(<span class="number">32</span>);</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;dev.dma_mask)</span><br><span class="line">		dev-&gt;dev.dma_mask = &amp;dev-&gt;dev.coherent_dma_mask;</span><br><span class="line">	dev-&gt;dev.bus = &amp;platform_bus_type;</span><br><span class="line">	dev-&gt;dev.platform_data = platform_data;</span><br><span class="line">	of_msi_configure(&amp;dev-&gt;dev, dev-&gt;dev.of_node);</span><br><span class="line">	of_reserved_mem_device_init_by_idx(&amp;dev-&gt;dev, dev-&gt;dev.of_node, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将平台设备添加到设备模型中 */</span></span><br><span class="line">	<span class="keyword">if</span> (of_device_add(dev) != <span class="number">0</span>) &#123;</span><br><span class="line">		platform_device_put(dev);</span><br><span class="line">		<span class="keyword">goto</span> err_clear_flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev;</span><br><span class="line"></span><br><span class="line">err_clear_flag:</span><br><span class="line">	<span class="comment">/* 清除设备节点的已填充标志 */</span></span><br><span class="line">	of_node_clear_flag(np, OF_POPULATED);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>第10行：函数会检查设备节点的可用性，即检查设备树对应节点的status属性。如果设备节点不可用或已经被填充，则直接返回 NULL。</p>
<p>第15行：函数调用 of_device_alloc 分配一个平台设备结构体，并将设备节点指针、设备标识符和父设备指针传递给它。如果分配失败，则跳转到 err_clear_flag 标签处进行错误处理。</p>
<p>第19行，函数设置平台设备的一些属性。它将 coherent_dma_mask 属性设置为 32 位的 DMA 位掩码，并检查 dma_mask 属性是否为 NULL。如果 dma_mask 为 NULL，则将其指向 coherent_dma_mask。然后，函数设置平台设备的总线类型为 platform_bus_type，并将平台数据指针存储在 platform_data 属性中。接着，函数调用 of_msi_configure 和 of_reserved_mem_device_init_by_idx 来配置设备的 MSI 和保留内存信息。</p>
<p>第29行：函数调用 of_device_add 将平台设备添加到设备模型中。如果添加失败，则释放已分配的平台设备，并跳转到 err_clear_flag 标签处进行错误处理。</p>
<p>至此，关于device_node转换成platform_device的具体流程就分析完成了，函数调用流程图如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024870.jpeg" alt="img"></p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-62-dtb文件格式讲解</title>
    <url>/2023/09/05/1-63-dtb%E5%B1%95%E5%BC%80%E6%88%90device-node%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第63章-dtb展开成device-node实验"><a href="#第63章-dtb展开成device-node实验" class="headerlink" title="第63章 dtb展开成device_node实验"></a>第63章 dtb展开成device_node实验</h1><p>在上个小节中我们讲解了设备树deb的文件格式，那deb文件是怎样传递给内核的呢，那就进入到本小节的学习吧。</p>
<h2 id="63-1-dtb展开流程"><a href="#63-1-dtb展开流程" class="headerlink" title="63.1 dtb展开流程"></a>63.1 dtb展开流程</h2><p>dtb展开流程图如下所示：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\ksohtml13380\wps224.jpg" alt="img"> </p>
<p>接下来将会根据上图对deb的展开流程进行详细的讲解：</p>
<p><strong>（1）设备树源文件编写：</strong>根据之前的章节中讲解的设备树的基本语法和相关知识编写符合规范的设备树。</p>
<p><strong>（2）设备树编译：</strong>设备树源文件经过设备树编译器（dtc）进行编译，生成设备树二进制文件（.dtb）。设备树编译器会检查源文件的语法和语义，并将其转换为二进制格式，以便内核能够解析和使用。</p>
<p><strong>（3）boot.img</strong>镜像生成：boot.img是一个包含内核镜像、设备树二进制文件和其他一些资源文件的镜像文件（目前只是适用于瑞芯微的soc上，其他厂商的soc需要具体问题具体分析）。在生成boot.img时，通常会将内核镜像、设备树二进制文件和其他一些资源文件打包在一起。这个过程可以使用特定的工具或脚本完成。</p>
<p>（<strong>4）U-Boot加载：</strong>U-Boot（Universal Bootloader）是一种常用的开源引导加载程序，用于引导嵌入式系统。在系统启动过程中，U-Boot会将boot.img中的内核和设备树的二进制文件加载到系统内存的特定地址。</p>
<p><strong>（5）内核初始化：</strong>U-Boot将内核和设备树的二进制文件加载到系统内存的特定地址后，控制权会转交给内核。在内核初始化的过程中，会解析设备树二进制文件，将其展开为内核可以识别的数据结构，以便内核能够正确地初始化和管理硬件资源。</p>
<p><strong>（6）设备树展开：</strong>设备树展开是指将设备树二进制文件解析成内核中的设备节点（device_node）的过程。内核会读取设备树二进制文件的内容，并根据设备树的描述信息，构建设备树数据结构，例如设备节点、中断控制器、寄存器、时钟等。这些设备树数据结构将在内核运行时用于管理和配置硬件资源。</p>
<p>而本章节要讲解的重点就在上面的第6步“设备树的展开”，最终设备树二进制文件会被解析成device_node，device_node结构体定义在内核源码的“&#x2F;include&#x2F;linux&#x2F;of.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;                <span class="comment">// 设备节点的名称</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *type;                <span class="comment">// 设备节点的类型</span></span><br><span class="line">	phandle phandle;                  <span class="comment">// 设备节点的句柄</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *full_name;           <span class="comment">// 设备节点的完整名称</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> <span class="title">fwnode</span>;</span>     <span class="comment">// 设备节点的固件节点句柄</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">properties</span>;</span>     <span class="comment">// 设备节点的属性列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">deadprops</span>;</span>      <span class="comment">// 已删除的属性列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">parent</span>;</span>      <span class="comment">// 父设备节点指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span>       <span class="comment">// 子设备节点指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">sibling</span>;</span>     <span class="comment">// 兄弟设备节点指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_KOBJ)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>             <span class="comment">// 内核对象（用于 sysfs）</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> _flags;            <span class="comment">// 设备节点的标志位</span></span><br><span class="line">	<span class="type">void</span> *data;                      <span class="comment">// 与设备节点相关的数据指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SPARC)</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *path_component_name; <span class="comment">// 设备节点的路径组件名称</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> unique_id;          <span class="comment">// 设备节点的唯一标识</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">of_irq_controller</span> *<span class="title">irq_trans</span>;</span> <span class="comment">// 设备节点的中断控制器</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后对该结构体的重要参数进行讲解：</p>
<p>（1）name：name 字段表示设备节点的名称。设备节点的名称是在设备树中唯一标识该节点的字符串。它通常用于在设备树中引用设备节点。</p>
<p>（2）type：type 字段表示设备节点的类型。设备节点的类型提供了关于设备节点功能和所属设备类别的信息。它可以用于识别设备节点的用途和特性。</p>
<p>（3）properties：properties 字段是指向设备节点属性列表的指针。设备节点的属性包含了与设备节点相关联的配置和参数信息。属性以键值对的形式存在，可以提供设备的特定属性、寄存器地址、中断信息等。property字段同样定义在内核源码的“&#x2F;include&#x2F;linux&#x2F;of.h”文件中，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct property &#123;</span><br><span class="line">	char *name;                    // 属性的名称</span><br><span class="line">	int length;                    // 属性值的长度（字节数）</span><br><span class="line">	void *value;                   // 属性值的指针</span><br><span class="line">	struct property *next;         // 下一个属性节点指针</span><br><span class="line">#if defined(CONFIG_OF_DYNAMIC) || defined(CONFIG_SPARC)</span><br><span class="line">	unsigned long _flags;          // 属性的标志位</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_OF_PROMTREE)</span><br><span class="line">	unsigned int unique_id;        // 属性的唯一标识</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_OF_KOBJ)</span><br><span class="line">	struct bin_attribute attr;     // 内核对象二进制属性</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（4）parent：parent 字段指向父设备节点。设备树中的设备节点按照层次结构组织，父设备节点是当前设备节点的直接上级。通过 parent 字段，可以在设备树中遍历设备节点的父子关系。</p>
<p>（5）child：child 字段指向子设备节点。在设备树中，一个设备节点可以拥有多个子设备节点。通过 child 字段，可以遍历设备节点的所有子设备节点。</p>
<p>（6）sibling：sibling 字段指向兄弟设备节点。在设备树中，同一级别的兄弟设备节点共享相同的父设备节点。通过 sibling 字段，可以在同级设备节点之间进行遍历。</p>
<p>至此，关于device_node的结构体讲解就完成了，虽然我们现在知道了，dtb文件最终会展开成device_node这一可以让内核识别的格式，那更具体的实现流程是怎样的呢，让我们进入下一小节的学习吧。</p>
<h2 id="63-2-dtb解析过程源码分析"><a href="#63-2-dtb解析过程源码分析" class="headerlink" title="63.2 dtb解析过程源码分析"></a>63.2 dtb解析过程源码分析</h2><p>首先来到源码目录下的“&#x2F;init&#x2F;main.c”文件，找到其中的start_kernel 函数，start_kernel 函数是 Linux 内核启动的入口点，它是Linux内核的核心函数之一，负责完成内核的初始化和启动过程，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __init <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *command_line;</span><br><span class="line">    <span class="type">char</span> *after_dashes;</span><br><span class="line"></span><br><span class="line">    set_task_stack_end_magic(&amp;init_task);    <span class="comment">// 设置任务栈的魔数</span></span><br><span class="line">    smp_setup_processor_id();    <span class="comment">// 设置处理器ID</span></span><br><span class="line">    debug_objects_early_init();    <span class="comment">// 初始化调试对象</span></span><br><span class="line">    cgroup_init_early();    <span class="comment">// 初始化cgroup（控制组）</span></span><br><span class="line"></span><br><span class="line">    local_irq_disable();    <span class="comment">// 禁用本地中断</span></span><br><span class="line">    early_boot_irqs_disabled = <span class="literal">true</span>;     <span class="comment">// 标记早期引导期间中断已禁用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 中断仍然被禁用。进行必要的设置，然后启用它们。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    boot_cpu_init();    <span class="comment">// 初始化引导CPU</span></span><br><span class="line">    page_address_init();    <span class="comment">// 设置页地址</span></span><br><span class="line">    pr_notice(<span class="string">&quot;%s&quot;</span>, linux_banner);    <span class="comment">// 打印Linux内核版本信息</span></span><br><span class="line">    setup_arch(&amp;command_line);    <span class="comment">// 架构相关的初始化</span></span><br><span class="line">    mm_init_cpumask(&amp;init_mm);    <span class="comment">// 初始化内存管理的cpumask（CPU掩码）</span></span><br><span class="line">    setup_command_line(command_line);    <span class="comment">// 设置命令行参数</span></span><br><span class="line">    setup_nr_cpu_ids();    <span class="comment">// 设置CPU个数</span></span><br><span class="line">    setup_per_cpu_areas();    <span class="comment">// 设置每个CPU的区域</span></span><br><span class="line">    smp_prepare_boot_cpu();    <span class="comment">// 准备启动CPU（架构特定的启动CPU钩子）</span></span><br><span class="line">    boot_cpu_hotplug_init();    <span class="comment">// 初始化热插拔的引导CPU</span></span><br><span class="line"></span><br><span class="line">    build_all_zonelists(<span class="literal">NULL</span>);    <span class="comment">// 构建所有内存区域列表</span></span><br><span class="line">    page_alloc_init();    <span class="comment">// 初始化页面分配器</span></span><br><span class="line">	........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中跟设备树相关的函数为第20行的 setup_arch**(&amp;<strong>command_line</strong>);**该函数定义在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;setup.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">setup_arch</span><span class="params">(<span class="type">char</span> **cmdline_p)</span></span><br><span class="line">&#123;</span><br><span class="line">	init_mm.start_code = (<span class="type">unsigned</span> <span class="type">long</span>) _text;</span><br><span class="line">	init_mm.end_code   = (<span class="type">unsigned</span> <span class="type">long</span>) _etext;</span><br><span class="line">	init_mm.end_data   = (<span class="type">unsigned</span> <span class="type">long</span>) _edata;</span><br><span class="line">	init_mm.brk	   = (<span class="type">unsigned</span> <span class="type">long</span>) _end;</span><br><span class="line"></span><br><span class="line">	*cmdline_p = boot_command_line;</span><br><span class="line"></span><br><span class="line">	early_fixmap_init();    <span class="comment">// 初始化 early fixmap</span></span><br><span class="line">	early_ioremap_init();    <span class="comment">// 初始化 early ioremap</span></span><br><span class="line"></span><br><span class="line">	setup_machine_fdt(__fdt_pointer);    <span class="comment">// 设置机器的 FDT（平台设备树）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化静态密钥，早期可能会被 cpufeature 代码和早期参数启用</span></span><br><span class="line">	jump_label_init();</span><br><span class="line">	parse_early_param();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在启动可能的早期控制台后，解除屏蔽异步中断和 FIQ（一旦我们可以报告发生的系统错误）</span></span><br><span class="line">	local_daif_restore(DAIF_PROCCTX_NOIRQ);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在这个阶段，TTBR0仅用于身份映射。将其指向零页面，以避免做出猜测性的新条目获取。</span></span><br><span class="line">	cpu_uninstall_idmap();</span><br><span class="line"></span><br><span class="line">	xen_early_init();    <span class="comment">// Xen 平台的早期初始化</span></span><br><span class="line">	efi_init();    <span class="comment">// EFI 平台的初始化</span></span><br><span class="line">	arm64_memblock_init();    <span class="comment">// ARM64 内存块的初始化</span></span><br><span class="line"></span><br><span class="line">	paging_init();    <span class="comment">// 分页初始化</span></span><br><span class="line"></span><br><span class="line">	acpi_table_upgrade();    <span class="comment">// ACPI 表的升级</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析 ACPI 表以进行可能的引导时配置</span></span><br><span class="line">	acpi_boot_table_init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (acpi_disabled)</span><br><span class="line">		unflatten_device_tree();    <span class="comment">// 展开设备树</span></span><br><span class="line"></span><br><span class="line">	bootmem_init();    <span class="comment">// 引导内存的初始化</span></span><br><span class="line">	............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在setup_arch函数中与设备树相关的函数分别为第13行的setup_machine_fdt(__fdt_pointer)和第37行的unflatten_device_tree()，接下来将对上述两个函数进行详细的介绍。</p>
<h3 id="63-2-1-setup-machine-fdt-fdt-pointer"><a href="#63-2-1-setup-machine-fdt-fdt-pointer" class="headerlink" title="63.2.1 setup_machine_fdt(__fdt_pointer)"></a>63.2.1 setup_machine_fdt(__fdt_pointer)</h3><p>setup_machine_fdt(__fdt_pointer)中的__fdt_pointer是dtb二进制文件加载到内存的地址，该地址由bootloader启动kernel时透过x0寄存器传递过来的，具体的汇编代码在内核源码目录下的“&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;head.S”文件中，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">preserve_boot_args:</span><br><span class="line">	mov	x21, x0				// x21=FDT</span><br><span class="line"></span><br><span class="line">__primary_switched:</span><br><span class="line">	str_l	x21, __fdt_pointer, x5		// Save FDT pointer</span><br></pre></td></tr></table></figure>

<p>第2行: 将寄存器 x0 的值复制到寄存器 x21。x0 寄存器中保存了一个指针，该指针指向设备树（Device Tree）。</p>
<p>第4行: 将寄存器 x21 的值存储到内存地址 __fdt_pointer 中。</p>
<p>然后来看setup_machine_fdt函数，该函数定义在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;setup.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化设置机器的设备树</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">setup_machine_fdt</span><span class="params">(<span class="type">phys_addr_t</span> dt_phys)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 将设备树物理地址映射到内核虚拟地址空间</span></span><br><span class="line">    <span class="type">void</span> *dt_virt = fixmap_remap_fdt(dt_phys, &amp;size, PAGE_KERNEL);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果映射成功</span></span><br><span class="line">    <span class="keyword">if</span> (dt_virt) &#123;</span><br><span class="line">        <span class="comment">// 保留设备树占用的内存区域</span></span><br><span class="line">        memblock_reserve(dt_phys, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设备树映射失败或者设备树解析失败</span></span><br><span class="line">    <span class="keyword">if</span> (!dt_virt || !early_init_dt_scan(dt_virt)) &#123;</span><br><span class="line">        <span class="comment">// 输出错误信息</span></span><br><span class="line">		pr_crit(<span class="string">&quot;\n&quot;</span></span><br><span class="line">			<span class="string">&quot;Error: invalid device tree blob at physical address %pa (virtual address 0x%p)\n&quot;</span></span><br><span class="line">			<span class="string">&quot;The dtb must be 8-byte aligned and must not exceed 2 MB in size\n&quot;</span></span><br><span class="line">			<span class="string">&quot;\nPlease check your bootloader.&quot;</span>,</span><br><span class="line">			&amp;dt_phys, dt_virt);</span><br><span class="line">        <span class="comment">// 无限循环，等待系统崩溃</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            cpu_relax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 早期修复完成，将设备树映射为只读模式</span></span><br><span class="line">    fixmap_remap_fdt(dt_phys, &amp;size, PAGE_KERNEL_RO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取设备树的机器名</span></span><br><span class="line">    name = of_flat_dt_get_machine_name();</span><br><span class="line">    <span class="comment">// 如果设备树没有机器名，则返回</span></span><br><span class="line">    <span class="keyword">if</span> (!name)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	    pr_info(<span class="string">&quot;Machine model: %s\n&quot;</span>, name); <span class="comment">// 输出机器型号信息</span></span><br><span class="line">    dump_stack_set_arch_desc(<span class="string">&quot;%s (DT)&quot;</span>, name); <span class="comment">// 设置栈转储的架构描述为机器型号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数用于在内核启动过程中设置机器的设备树。在此函数中，将执行以下步骤： </p>
<p>1.使用 fixmap_remap_fdt() 将设备树映射到内核虚拟地址空间中的 fixmap 区域。 </p>
<p>2.如果映射成功，则使用 memblock_reserve() 保留设备树占用的物理内存区域。 </p>
<p>3.检查设备树的有效性和完整性，通过调用early_init_dt_scan()进行早期扫描。 如果设备树无效或扫描失败，则会输出错误信息并进入死循环。 </p>
<p>4.早期修复已完成，现在将设备树映射为只读，通过调用 fixmap_remap_fdt() 实现。</p>
<p>5.获取设备树中的机器模型名称，通过调用 of_flat_dt_get_machine_name()。</p>
<p>6.如果机器模型名称存在，则输出机器模型的信息，并通过 dump_stack_set_arch_desc() 设置堆栈描述信息。</p>
<p>其中上面的第3步调用的early_init_dt_scan() 需要详细的讲解一下，该函数定义在内核源码的“drivers&#x2F;of&#x2F;fdt.c”目录下，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> __init <span class="title function_">early_init_dt_scan</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证设备树的兼容性和完整性</span></span><br><span class="line">    status = early_init_dt_verify(params);</span><br><span class="line">    <span class="keyword">if</span> (!status)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描设备树节点</span></span><br><span class="line">    early_init_dt_scan_nodes();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，调用 early_init_dt_verify() 函数对设备树进行兼容性和完整性验证。该函数可能会检查设备树中的一致性标记、版本信息以及必需的节点和属性是否存在。如果验证失败，函数会返回 false。该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> __init <span class="title function_">early_init_dt_verify</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 验证传入的参数是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!params)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查设备树头部的有效性</span></span><br><span class="line">    <span class="comment">// 如果设备树头部无效，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (fdt_check_header(params))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置指向设备树的指针为传入的参数</span></span><br><span class="line">    initial_boot_params = params;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算设备树的 CRC32 校验值</span></span><br><span class="line">    <span class="comment">// 并将结果保存在全局变量 of_fdt_crc32 中</span></span><br><span class="line">    of_fdt_crc32 = crc32_be(~<span class="number">0</span>, initial_boot_params, fdt_totalsize(initial_boot_params));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 true，表示设备树验证和初始化成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第4行：该进行参数的有效性检查，如果 params 为空，则直接返回 false，表示参数无效。</p>
<p>第9行：检查设备树头部的有效性。fdt_check_header 是一个用于检查设备树头部的函数，如果设备树头部无效，则返回 false，表示设备树不合法。</p>
<p>第13行：如果设备树头部有效，程序继续执行，将传入的 params 赋值给全局变量 initial_boot_params，用来保存设备树的指针。</p>
<p>第17行，使用 crc32_be 函数计算设备树的 CRC32 校验值，其中 crc32_be 是一个用于计算 CRC32 校验值的函数，~0 表示初始值为全1的位模式。计算完成后，将结果保存在全局变量 of_fdt_crc32 中。</p>
<p>然后继续回到early_init_dt_scan() 函数中，如果设备树验证成功（即 status 为真），则调用 early_init_dt_scan_nodes() 函数。这个函数的作用是扫描设备树的节点并进行相应的处理，该函数的具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void __init early_init_dt_scan_nodes(void)</span><br><span class="line">&#123;</span><br><span class="line">	/* 从 /chosen 节点中检索各种信息 */</span><br><span class="line">	of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);</span><br><span class="line"></span><br><span class="line">	/* 初始化 &#123;size,address&#125;-cells 信息 */</span><br><span class="line">	of_scan_flat_dt(early_init_dt_scan_root, NULL);</span><br><span class="line"></span><br><span class="line">	/* 设置内存信息，调用 early_init_dt_add_memory_arch 函数 */</span><br><span class="line">	of_scan_flat_dt(early_init_dt_scan_memory, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数early_init_dt_scan_nodes被声明为__init，这表示它是在内核初始化阶段被调用，并且在初始化完成后不再需要。该函数的目的是在早期阶段扫描设备树节点，并执行一些初始化操作。</p>
<p>函数中主要调用了of_scan_flat_dt函数，该函数用于扫描平面设备树（flat device tree）。平面设备树是一种将设备树以紧凑形式表示的数据结构，它不使用树状结构，而是使用线性结构，以节省内存空间。</p>
<p>具体来看，early_init_dt_scan_nodes函数的执行步骤如下：</p>
<p>（1）of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line)：从设备树的&#x2F;chosen节点中检索各种信息。&#x2F;chosen节点通常包含了一些系统的全局配置参数，比如命令行参数。early_init_dt_scan_chosen是一个回调函数，用于处理&#x2F;chosen节点的信息。boot_command_line是一个参数，表示内核启动时的命令行参数。</p>
<p>（2）of_scan_flat_dt(early_init_dt_scan_root, NULL)：初始化{size,address}-cells信息。{size,address}-cells描述了设备节点中地址和大小的编码方式。early_init_dt_scan_root是一个回调函数，用于处理设备树的根节点。</p>
<p>（3）of_scan_flat_dt(early_init_dt_scan_memory, NULL)：设置内存信息，并调用early_init_dt_add_memory_arch函数。这个步骤主要用于在设备树中获取内存的相关信息，并将其传递给内核的内存管理模块。early_init_dt_scan_memory是一个回调函数，用于处理内存信息。</p>
<p>至此，关于setup_machine_fdt(__fdt_pointer)代码的分析就完成了。</p>
<h3 id="63-2-2-unflatten-device-tree"><a href="#63-2-2-unflatten-device-tree" class="headerlink" title="63.2.2 unflatten_device_tree"></a>63.2.2 unflatten_device_tree</h3><p>该函数用于解析设备树，将紧凑的设备树数据结构转换为树状结构的设备树，该函数定义在内核源码目录下的“&#x2F;drivers&#x2F;of&#x2F;fdt.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">unflatten_device_tree</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 解析设备树 */</span></span><br><span class="line">    __unflatten_device_tree(initial_boot_params, <span class="literal">NULL</span>, &amp;of_root,</span><br><span class="line">                            early_init_dt_alloc_memory_arch, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取指向 &quot;/chosen&quot; 和 &quot;/aliases&quot; 节点的指针，以供全局使用 */</span></span><br><span class="line">    of_alias_scan(early_init_dt_alloc_memory_arch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 运行设备树的单元测试 */</span></span><br><span class="line">    unittest_unflatten_overlay_base();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数主要用于解析设备树，并将解析后的设备树存储在全局变量of_root中。</p>
<p>函数首先调用__unflatten_device_tree函数来执行设备树的解析操作。解析后的设备树将使用of_root指针进行存储。</p>
<p>接下来，函数调用of_alias_scan函数。这个函数用于扫描设备树中的&#x2F;chosen和&#x2F;aliases节点，并为它们分配内存。这样，其他部分的代码可以通过全局变量访问这些节点。</p>
<p>最后，函数调用unittest_unflatten_overlay_base函数，用于运行设备树的单元测试。</p>
<p>然后对__unflatten_device_tree这一设备树的解析函数进行详细的介绍，该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *__unflatten_device_tree(<span class="type">const</span> <span class="type">void</span> *blob,</span><br><span class="line">		      <span class="keyword">struct</span> device_node *dad,</span><br><span class="line">			      <span class="keyword">struct</span> device_node **mynodes,</span><br><span class="line">			      <span class="type">void</span> *(*dt_alloc)(u64 size, u64 align),</span><br><span class="line">			      <span class="type">bool</span> detached)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	<span class="type">void</span> *mem;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot; -&gt; unflatten_device_tree()\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!blob) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;No device tree pointer\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;Unflattening device tree:\n&quot;</span>);</span><br><span class="line">	pr_debug(<span class="string">&quot;magic: %08x\n&quot;</span>, fdt_magic(blob));</span><br><span class="line">	pr_debug(<span class="string">&quot;size: %08x\n&quot;</span>, fdt_totalsize(blob));</span><br><span class="line">	pr_debug(<span class="string">&quot;version: %08x\n&quot;</span>, fdt_version(blob));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fdt_check_header(blob)) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;Invalid device tree blob header\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 第一遍扫描，计算大小 */</span></span><br><span class="line">	size = unflatten_dt_nodes(blob, <span class="literal">NULL</span>, dad, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (size &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	size = ALIGN(size, <span class="number">4</span>);</span><br><span class="line">	pr_debug(<span class="string">&quot;  大小为 %d，正在分配内存...\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 为展开的设备树分配内存 */</span></span><br><span class="line">	mem = dt_alloc(size + <span class="number">4</span>, <span class="keyword">alignof</span>(<span class="keyword">struct</span> device_node));</span><br><span class="line">	<span class="keyword">if</span> (!mem)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(mem, <span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line">	*(__be32 *)(mem + size) = cpu_to_be32(<span class="number">0xdeadbeef</span>);</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;  正在展开 %p...\n&quot;</span>, mem);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 第二遍扫描，实际展开设备树 */</span></span><br><span class="line">	unflatten_dt_nodes(blob, mem, dad, mynodes);</span><br><span class="line">	<span class="keyword">if</span> (be32_to_cpup(mem + size) != <span class="number">0xdeadbeef</span>)</span><br><span class="line">		pr_warning(<span class="string">&quot;End of tree marker overwritten: %08x\n&quot;</span>,</span><br><span class="line">			   be32_to_cpup(mem + size));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (detached &amp;&amp; mynodes) &#123;</span><br><span class="line">		of_node_set_flag(*mynodes, OF_DETACHED);</span><br><span class="line">		pr_debug(<span class="string">&quot;unflattened tree is detached\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot; &lt;- unflatten_device_tree()\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的重点在两次设备树的扫描上，第一遍扫描的目的是计算展开设备树所需的内存大小。</p>
<p>第29行：unflatten_dt_nodes函数的作用是递归地遍历设备树数据块，并计算展开设备树所需的内存大小。它接受四个参数：blob（设备树数据块指针）、start（当前节点的起始地址，初始为NULL）、dad（父节点指针）和mynodes（用于存储节点指针数组的指针，初始为NULL）。</p>
<p>第一遍扫描完成后，unflatten_dt_nodes函数会返回展开设备树所需的内存大小，然后在对大小进行对齐操作，并为展开的设备树分配内存。</p>
<p>第二遍扫描的目的是实际展开设备树，并填充设备节点的名称、类型和属性等信息。</p>
<p>第49行：再次调用了unflatten_dt_nodes函数进行第二遍扫描。通过这样的过程，第二遍扫描会将设备树数据块中的节点展开为真正的设备节点，并填充节点的名称、类型和属性等信息。这样就完成了设备树的展开过程。</p>
<p>最后我们来对unflatten_dt_nodes函数内容进行一下深究，unflatten_dt_nodes函数具体定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">unflatten_dt_nodes</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *blob,</span></span><br><span class="line"><span class="params">			      <span class="type">void</span> *mem,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> device_node *dad,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> device_node **nodepp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">root</span>;</span>  <span class="comment">// 根节点</span></span><br><span class="line">	<span class="type">int</span> offset = <span class="number">0</span>, depth = <span class="number">0</span>, initial_depth = <span class="number">0</span>;  <span class="comment">// 偏移量、深度和初始深度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_MAX_DEPTH	64  <span class="comment">// 最大深度</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nps</span>[<span class="title">FDT_MAX_DEPTH</span>];</span>  <span class="comment">// 设备节点数组</span></span><br><span class="line">	<span class="type">void</span> *base = mem;  <span class="comment">// 基地址，用于计算偏移量</span></span><br><span class="line">	<span class="type">bool</span> dryrun = !base;  <span class="comment">// 是否只是模拟运行，不实际处理</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nodepp)</span><br><span class="line">		*nodepp = <span class="literal">NULL</span>;  <span class="comment">// 如果指针不为空，将其置为空指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果 @dad 有效，则表示正在展开设备子树。</span></span><br><span class="line"><span class="comment">	 * 在第一层深度可能有多个节点。</span></span><br><span class="line"><span class="comment">	 * 将 @depth 设置为 1，以使 fdt_next_node() 正常工作。</span></span><br><span class="line"><span class="comment">	 * 当发现负的 @depth 时，该函数会立即退出。</span></span><br><span class="line"><span class="comment">	 * 否则，除第一个节点外的设备节点将无法成功展开。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dad)</span><br><span class="line">		depth = initial_depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	root = dad;  <span class="comment">// 根节点为 @dad</span></span><br><span class="line">	nps[depth] = dad;  <span class="comment">// 将根节点放入设备节点数组</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (offset = <span class="number">0</span>;</span><br><span class="line">	     offset &gt;= <span class="number">0</span> &amp;&amp; depth &gt;= initial_depth;</span><br><span class="line">	     offset = fdt_next_node(blob, offset, &amp;depth)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(depth &gt;= FDT_MAX_DEPTH))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果未启用 CONFIG_OF_KOBJ 并且节点不可用，则跳过该节点</span></span><br><span class="line">		<span class="keyword">if</span> (!IS_ENABLED(CONFIG_OF_KOBJ) &amp;&amp;</span><br><span class="line">		    !of_fdt_device_is_available(blob, offset))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 填充节点信息，并将子节点添加到设备节点数组</span></span><br><span class="line">		<span class="keyword">if</span> (!populate_node(blob, offset, &amp;mem, nps[depth],</span><br><span class="line">				   &amp;nps[depth+<span class="number">1</span>], dryrun))</span><br><span class="line">			<span class="keyword">return</span> mem - base;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!dryrun &amp;&amp; nodepp &amp;&amp; !*nodepp)</span><br><span class="line">			*nodepp = nps[depth+<span class="number">1</span>];  <span class="comment">// 将子节点指针赋值给 @nodepp</span></span><br><span class="line">		<span class="keyword">if</span> (!dryrun &amp;&amp; !root)</span><br><span class="line">			root = nps[depth+<span class="number">1</span>];  <span class="comment">// 如果根节点为空，则将子节点设置为根节点</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset &lt; <span class="number">0</span> &amp;&amp; offset != -FDT_ERR_NOTFOUND) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;Error %d processing FDT\n&quot;</span>, offset);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 反转子节点列表。一些驱动程序假设节点顺序与 .dts 文件中的节点顺序一致</span></span><br><span class="line">	<span class="keyword">if</span> (!dryrun)</span><br><span class="line">		reverse_nodes(root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mem - base;  <span class="comment">// 返回处理的字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unflatten_dt_nodes 函数的作用我们在上面已经讲解过了，这里重点介绍第31行的 fdt_next_node()函数和第41行的populate_node函数。</p>
<p>fdt_next_node() 函数用来遍历设备树的节点。从偏移量为 0 开始，只要偏移量大于等于 0 且深度大于等于初始深度，就执行循环。循环中的每次迭代都会处理一个设备树节点。</p>
<p>在每次迭代中，首先检查深度是否超过了最大深度 FDT_MAX_DEPTH，如果超过了，则跳过该节点。</p>
<p>如果未启用 CONFIG_OF_KOBJ 并且节点不可用（通过 of_fdt_device_is_available() 函数判断），则跳过该节点。</p>
<p>随后调用 populate_node() 函数填充节点信息，并将子节点添加到设备节点数组 nps 中。 populate_node() 函数定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static bool populate_node(const void *blob,</span><br><span class="line">			  int offset,</span><br><span class="line">			  void **mem,</span><br><span class="line">			  struct device_node *dad,</span><br><span class="line">			  struct device_node **pnp,</span><br><span class="line">			  bool dryrun)</span><br><span class="line">&#123;</span><br><span class="line">	struct device_node *np;  // 设备节点指针</span><br><span class="line">	const char *pathp;  // 节点路径字符串指针</span><br><span class="line">	unsigned int l, allocl;  // 路径字符串长度和分配的内存大小</span><br><span class="line"></span><br><span class="line">	pathp = fdt_get_name(blob, offset, &amp;l);  // 获取节点路径和长度</span><br><span class="line">	if (!pathp) &#123;</span><br><span class="line">		*pnp = NULL;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	allocl = ++l;  // 分配内存大小为路径长度加一，用于存储节点路径字符串</span><br><span class="line"></span><br><span class="line">	np = unflatten_dt_alloc(mem, sizeof(struct device_node) + allocl,</span><br><span class="line">				__alignof__(struct device_node));  // 分配设备节点内存</span><br><span class="line">	if (!dryrun) &#123;</span><br><span class="line">		char *fn;</span><br><span class="line">		of_node_init(np);  // 初始化设备节点</span><br><span class="line">		np-&gt;full_name = fn = ((char *)np) + sizeof(*np);  // 设置设备节点的完整路径名</span><br><span class="line"></span><br><span class="line">		memcpy(fn, pathp, l);  // 将节点路径字符串复制到设备节点的完整路径名中</span><br><span class="line"></span><br><span class="line">		if (dad != NULL) &#123;</span><br><span class="line">			np-&gt;parent = dad;  // 设置设备节点的父节点</span><br><span class="line">			np-&gt;sibling = dad-&gt;child;  // 设置设备节点的兄弟节点</span><br><span class="line">			dad-&gt;child = np;  // 将设备节点添加为父节点的子节点</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	populate_properties(blob, offset, mem, np, pathp, dryrun);  // 填充设备节点的属性信息</span><br><span class="line">	if (!dryrun) &#123;</span><br><span class="line">		np-&gt;name = of_get_property(np, &quot;name&quot;, NULL);  // 获取设备节点的名称属性</span><br><span class="line">		np-&gt;type = of_get_property(np, &quot;device_type&quot;, NULL);  // 获取设备节点的设备类型属性</span><br><span class="line"></span><br><span class="line">		if (!np-&gt;name)</span><br><span class="line">			np-&gt;name = &quot;&lt;NULL&gt;&quot;;  // 如果设备节点没有名称属性，则设置为&quot;&lt;NULL&gt;&quot;</span><br><span class="line">		if (!np-&gt;type)</span><br><span class="line">			np-&gt;type = &quot;&lt;NULL&gt;&quot;;  // 如果设备节点没有设备类型属性，则设置为&quot;&lt;NULL&gt;&quot;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*pnp = np;  // 将设备节点指针赋值给*pnp</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在populate_node 函数中首先会调用第18行的 unflatten_dt_alloc 函数分配设备节点内存。分配的内存大小为 sizeof(struct device_node) + allocl 字节，并使用 <strong>alignof</strong>(struct device_node) 对齐。然后调用 populate_properties 函数填充设备节点的属性信息。该函数会解析设备节点的属性，并根据需要分配内存来存储属性值。</p>
<p>至此，关于dtb二进制文件的解析过程就讲解完成了，完整的源码分析流程图如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024648.jpeg" alt="img"></p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-62-dtb文件格式讲解</title>
    <url>/2023/09/05/1-62-dtb%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第62章-dtb文件格式讲解"><a href="#第62章-dtb文件格式讲解" class="headerlink" title="第62章 dtb文件格式讲解"></a>第62章 dtb文件格式讲解</h1><p>设备树 Blob (DTB) 格式是设备树数据的平面二进制编码。它用于在软件程序之间交换设备树数据。例如，在启动操作系统时，固件会将 DTB 传递给操作系统内核。</p>
<p>DTB 格式在单个、线性、无指针数据结构中对设备树数据进行编码。它由一个小头部和三个可变大小的部分组成：内存保留块、结构块和字符串块。这些应该以该顺序出现在展平的设备树中。因此，设备树结构作为一个整体，当加载到内存地址时，将类似于下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022286.jpeg" alt="img"> </p>
<p>本节课将以下面的设备树为例对设备树的二进制文件格式进行讲解：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = <span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0, 115200&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a35&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x1</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    aliases &#123;</span><br><span class="line">        led1 = <span class="string">&quot;/gpio@22020101&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node1 &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">        gpio@<span class="number">22020102</span> &#123;</span><br><span class="line">            reg = &lt;<span class="number">0x20220102</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node2 &#123;</span><br><span class="line">        node1-child &#123;</span><br><span class="line">            pinnum = &lt;<span class="number">01234</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@<span class="number">22020101</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;led&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x20220101</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而我们之后要分析的是二进制的dtb文件，所以需要使用dtc工具将上面的dts文件编译成dtb文件，具体命令如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022423.jpeg" alt="img"> </p>
<p>为了方便用户学习，已经将本章节要讲解的设备树dts文件和dtb文件放在了对应的网盘路径下，同时也将pxBinaryViewerSetup二进制分析软件放在了同一目录下，iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\49_dt_format，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022265.jpeg" alt="img"> </p>
<p>使用二进制分析软件打开deb文件并设置大端模式之后如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022400.jpeg" alt="img"></p>
<p>在接下来的小节中将会对读取出的设备树二进制内容进行讲解。</p>
<h2 id="62-1-Header"><a href="#62-1-Header" class="headerlink" title="62.1 Header"></a>62.1 Header</h2><p>devicetree 的头布局由以下 C 结构定义。所有的头字段都是 32 位整数，以大端格式存储。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct fdt_header &#123;</span><br><span class="line">    uint32_t magic;                 // 设备树头部的魔数</span><br><span class="line">    uint32_t totalsize;             // 设备树文件的总大小</span><br><span class="line">    uint32_t off_dt_struct;         // 设备树结构体（节点数据）相对于文件开头的偏移量</span><br><span class="line">    uint32_t off_dt_strings;        // 设备树字符串表相对于文件开头的偏移量</span><br><span class="line">    uint32_t off_mem_rsvmap;        // 内存保留映射表相对于文件开头的偏移量</span><br><span class="line">    uint32_t version;               // 设备树版本号</span><br><span class="line">    uint32_t last_comp_version;     // 最后一个兼容版本号</span><br><span class="line">    uint32_t boot_cpuid_phys;       // 启动 CPU 的物理 ID</span><br><span class="line">    uint32_t size_dt_strings;       // 设备树字符串表的大小</span><br><span class="line">    uint32_t size_dt_struct;        // 设备树结构体（节点数据）的大小</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个字段的描述如下所示：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>magic</td>
<td>该字段为固定值 0xd00dfeed（大端）。</td>
</tr>
<tr>
<td>totalsize</td>
<td>该字段包含设备树数据结构的总大小（以字节为单位）。此大小应包含结构的所有部分：标题、内存保留块、结构块和字符串块，以及块之间或最后一个块之后的任何空闲空间间隙。</td>
</tr>
<tr>
<td>off_dt_struct</td>
<td>该字段包含结构块从头开始的以字节为单位的偏移量。</td>
</tr>
<tr>
<td>off_dt_strings</td>
<td>该字段包含字符串块从头开始的以字节为单位的偏移量。</td>
</tr>
<tr>
<td>off_mem_rsvmap</td>
<td>该字段包含从头开始的内存保留块的字节偏移量。</td>
</tr>
<tr>
<td>version</td>
<td>该字段包含设备树数据结构的版本。</td>
</tr>
<tr>
<td>last_comp_version</td>
<td>向后兼容的设备树数据结构的最低版本。</td>
</tr>
<tr>
<td>boot_cpuid_phys</td>
<td>与设备树CPU 节点的reg属性对应</td>
</tr>
<tr>
<td>size_dt_strings</td>
<td>设备树字符串块部分的字节长度。</td>
</tr>
<tr>
<td>size_dt_struct</td>
<td>设备树结构块部分的字节长度。</td>
</tr>
</tbody></table>
<p>然后来查看二进制文件，其中4个字节表示一个单位，前十个单位分别代表上述的十个字段如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022323.jpeg" alt="img"> </p>
<table>
<thead>
<tr>
<th>字段</th>
<th>十六进制数值</th>
<th>代表含义</th>
</tr>
</thead>
<tbody><tr>
<td>magic</td>
<td>D00DFEED</td>
<td>固定值</td>
</tr>
<tr>
<td>totalsize</td>
<td>000002A4</td>
<td>转换为十进制之后为676，表示该文件大小为676字节</td>
</tr>
<tr>
<td>off_dt_struct</td>
<td>00000038</td>
<td>表示结构块从00000038这个地址开始，和后面的size_dt_struct结构块大小参数一起可以确定结构块的存储范围</td>
</tr>
<tr>
<td>off_dt_strings</td>
<td>0000024C</td>
<td>表示字符串块从0000024C这个地址开始，和后面的size_dt_strings字符串块大小参数一起可以确定字符串块的存储范围</td>
</tr>
<tr>
<td>off_mem_rsvmap</td>
<td>00000028</td>
<td>表示内存保留块的偏移为00000028， header之后结构快之前都是属于内存保留块。</td>
</tr>
<tr>
<td>version</td>
<td>00000011</td>
<td>11转换为十进制之后为17，表示当前设备树结构版本为17</td>
</tr>
<tr>
<td>last_comp_version</td>
<td>00000010</td>
<td>10转换为十进制之后为16，表示向前兼容的设备树结构版本为16</td>
</tr>
<tr>
<td>boot_cpuid_phys</td>
<td>00000000</td>
<td>表示设备树的teg属性为0</td>
</tr>
<tr>
<td>size_dt_strings</td>
<td>00000058</td>
<td>表示字符串块的大小为00000058 ，和前面的off_dt_strings字符串块偏移值一起可以确定字符串块的范围</td>
</tr>
<tr>
<td>size_dt_struct</td>
<td>00000214</td>
<td>表示结构块的大小为00000214，和前面的off_dt_struct结构块偏移值一起可以确定结构块的范围</td>
</tr>
</tbody></table>
<p>在接下来的小节中将会对header提到的内存保留块、结构块和字符串块进行更详细的讲解。</p>
<h2 id="62-2-内存保留块"><a href="#62-2-内存保留块" class="headerlink" title="62.2 内存保留块"></a>62.2 内存保留块</h2><p>内存保留块（Memory Reserved Block）是用于客户端程序的保护和保留物理内存区域的列表。这些保留区域不应被用于一般的内存分配，而是用于保护重要数据结构，以防止客户端程序覆盖这些数据。内存保留块的目的是确保特定的内存区域在客户端程序运行时不被修改或使用。由于在示例设备树中没有设置内存保留块，所以相应的区域都为0，如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022259.jpeg" alt="img"> </p>
<p><strong>保留区域列表：</strong> 内存保留块是一个由一组 64 位大端整数对构成的列表。每对整数对应一个保留内存区域，其中包含物理地址和区域的大小（以字节为单位）。这些保留区域应该彼此不重叠。</p>
<p><strong>保留区域的用途：</strong>客户端程序不应访问内存保留块中的保留区域，除非引导程序提供的其他信息明确指示可以访问。引导程序可以使用特定的方式来指示客户端程序可以访问保留内存的部分内容。引导程序可能会在文档、可选的扩展或特定于平台的文档中说明保留内存的特定用途。</p>
<p><strong>格式：</strong>内存保留块中的每个保留区域由一个64位大端整数对表示。每对由以下 C 结构表示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct fdt_reserve_entry &#123; </span><br><span class="line">	uint64_t address; </span><br><span class="line">	uint64_t size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的第一个整数表示保留区域的物理地址，第二个整数表示保留区域的大小（以字节为单位）。每个整数都以 64 位的形式表示，即使在32位架构上也是如此。在32位CPU上，整数的高 32 位将被忽略。</p>
<p>内存保留块为设备树提供了保护和保留物理内存区域的功能。它确保了特定的内存区域在客户端程序运行时不被修改或使用。这样可以确保引导程序和其他关键组件在需要的情况下能够访问保留内存的特定部分，并保护关键数据结构免受意外修改。</p>
<h2 id="62-3-结构快"><a href="#62-3-结构快" class="headerlink" title="62.3 结构快"></a>62.3 结构快</h2><p>结构块是设备树中描述设备树本身结构和内容的部分。它由一系列带有数据的令牌序列组成，这些令牌按照线性树结构进行组织。</p>
<p><strong>（1）令牌类型</strong></p>
<p> 结构块中的令牌分为五种类型，每种类型用于不同的目的。</p>
<p>a. FDT_BEGIN_NODE (0x00000001): FDT_BEGIN_NODE 标记表示一个节点的开始。它后面跟着节点的单元名称作为额外数据。节点名称以以空字符结尾的字符串形式存储，并且可以包括单元地址。节点名称后可能需要填充零字节以对齐，然后是下一个标记，可以是除了 FDT_END 之外的任何标记。</p>
<p>b. FDT_END_NODE (0x00000002): FDT_END_NODE 标记表示一个节点的结束。该标记没有额外的数据，紧随其后的是下一个标记，可以是除了 FDT_PROP 之外的任何标记。</p>
<p>c. FDT_PROP (0x00000003): FDT_PROP 标记表示设备树中属性的开始。它后面跟着描述属性的额外数据，该数据首先由属性的长度和名称组成，表示为以下 C 结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">	uint32_t len; </span><br><span class="line">	uint32_t nameoff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>长度表示属性值的字节长度，名称偏移量指向字符串块中存储属性名称的位置。在这个结构之后，属性的值作为字节字符串给出。属性值后可能需要填充零字节以对齐，然后是下一个令牌，可以是除了 FDT_END 之外的任何标记。</p>
<p>d. FDT_NOP (0x00000004): FDT_NOP 令牌可以被解析设备树的程序忽略。该令牌没有额外的数据，紧随其后的是下一个令牌，可以是任何有效的令牌。使用 FDT_NOP 令牌可以覆盖树中的属性或节点定义，从而将其从树中删除，而无需移动设备树 blob 中的其他部分。</p>
<p>e. FDT_END (0x00000009): FDT_END 标记表示结构块的结束。应该只有一个 FDT_END 标记，并且应该是结构块中的最后一个标记。该标记没有额外的数据，紧随其后的字节应该位于结构块的开头偏移处，该偏移等于设备树 blob 标头中的 size_dt_struct 字段的值。</p>
<p><strong>（2）树状结构：</strong></p>
<p>设备树的结构以线性树的形式表示。每个节点由 FDT_BEGIN_NODE 标记开始，由 FDT_END_NODE 标记结束。节点的属性和子节点在 FDT_END_NODE 之前表示，因此子节点的 FDT_BEGIN_NODE 和 FDT_END_NODE 令牌嵌套在父节点的令牌中。</p>
<p><strong>（3）结构块的结束</strong></p>
<p>结构块以单个 FDT_END 标记结束。该标记没有额外的数据，它位于结构块的末尾，并且是结构块中的最后一个标记。FDT_END 标记之后的字节应位于结构块的开头偏移处，该偏移等于设备树 blob 标头中的 size_dt_struct 字段的值。</p>
<p>最后对结构块开头的部分内容进行讲解，具体内容如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022678.jpeg" alt="img"> </p>
<table>
<thead>
<tr>
<th>十六进制数值</th>
<th>代表含义</th>
</tr>
</thead>
<tbody><tr>
<td>00000001</td>
<td>根节点的开始</td>
</tr>
<tr>
<td>00000000</td>
<td>根节点没有节点名，所以这里名字为0</td>
</tr>
<tr>
<td>00000003</td>
<td>设备树中属性的开始</td>
</tr>
<tr>
<td>00000017</td>
<td>代表该属性的大小，换算成十进制为23，也就是”This is my devicetree!”这一字符串的长度</td>
</tr>
<tr>
<td>00000000</td>
<td>代表该属性在字符串块的偏移量，这里为0，表示无偏移</td>
</tr>
<tr>
<td>54686973-65210000</td>
<td>model的具体值</td>
</tr>
</tbody></table>
<p>通过使用结构块，设备树可以以一种层次化的方式组织和描述系统中的设备和资源。每个节点可以包含属性和子节点，从而实现更加灵活和可扩展的设备树表示。</p>
<h2 id="62-4-字符串块"><a href="#62-4-字符串块" class="headerlink" title="62.4 字符串块"></a>62.4 字符串块</h2><p>字符串块用于存储设备树中使用的所有属性名称。它由一系列以空字符结尾的字符串组成，这些字符串在字符串块中简单地连接在一起，具体示例如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022711.jpeg" alt="img"> </p>
<p><strong>（1）字符串连接：</strong></p>
<p> 字符串块中的字符串以空字符（\0）作为终止符来连接。这意味着每个字符串都以空字符结尾，并且下一个字符串紧跟在上一个字符串的末尾。这种连接方式使得字符串块中的所有字符串形成一个连续的字符序列。</p>
<p><strong>（2）偏移量引用：</strong></p>
<p>在结构块中，属性的名称是通过偏移量来引用字符串块中的相应字符串的。偏移量是一个无符号整数值，它表示字符串在字符串块中的位置。通过使用偏移量引用，设备树可以节省空间，并且在属性名称发生变化时也更加灵活，因为只需要更新偏移量，而不需要修改结构块中的属性引用。</p>
<p><strong>（3）对齐约束：</strong></p>
<p>字符串块没有对齐约束，这意味着它可以出现在设备树 blob 的任何偏移处。这使得字符串块的位置在设备树 blob 中是灵活的，并且可以根据需要进行调整，而不会对设备树的解析和处理造成影响。</p>
<p>字符串块是设备树中用于存储属性名称的部分。它由字符串连接而成，并通过偏移量在结构块中进行引用。字符串块的灵活位置使得设备树的表示更加紧凑和可扩展。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-61-实例分析: pinctrl</title>
    <url>/2023/09/05/1-61-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-pinctrl/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第61章-实例分析：pinctrl"><a href="#第61章-实例分析：pinctrl" class="headerlink" title="第61章 实例分析：pinctrl"></a>第61章 实例分析：pinctrl</h1><h2 id="61-1-pinmux-介绍"><a href="#61-1-pinmux-介绍" class="headerlink" title="61.1 pinmux 介绍"></a>61.1 pinmux 介绍</h2><p>Pinmux（引脚复用）是指在系统中配置和管理引脚功能的过程。在许多现代集成电路中，单个引脚可以具有多个功能，例如作为 GPIO、UART、SPI 或 I2C 等。通过使用引脚复用功能，可以在这些不同的功能之间切换。</p>
<p>引脚复用通过硬件和软件的方式实现。硬件层面，芯片设计会为每个引脚提供多个功能的选择。这些功能通常由芯片厂商在芯片规格文档中定义。通过编程设置寄存器或开关，可以选择某个功能来连接引脚。这种硬件层面的配置通常是由引脚控制器（Pin Controller）或引脚复用控制器（Pin Mux Controller）负责管理。</p>
<p>软件层面，操作系统或设备驱动程序需要了解和配置引脚的功能。它们使用设备树（Device Tree）或设备树绑定（Device Tree Bindings）来描述和配置引脚的功能。在设备树中，可以指定引脚的复用功能，将其连接到特定的硬件接口或功能。操作系统或设备驱动程序在启动过程中解析设备树，并根据配置对引脚进行初始化和设置。</p>
<p>那我们要怎样知晓每一个管脚都可以复用成什么功能呢，一般在核心板原理图都会标注出每个管脚的复用功能，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022792.jpeg" alt="img"> </p>
<p>从上图可以看到UART4_RX_M1对应的引脚可以复用为以下6个功能LCDC_D16、VOP_BT1120_D7、GMAC1_RXD0_M0、UART4_RX_M1、PWM8_M0、GPIO3_B1_d，对应的BGA引脚标号为AG1,那这里的AG1是如何定位的呢。</p>
<p>在 BGA（Ball Grid Array，球栅阵列）封装中，引脚标号是用于唯一标识每个引脚的标识符。这些标号通常由芯片制造商定义，并在芯片的规格文档或数据手册中提供。</p>
<p>BGA 芯片的引脚标号通常由字母和数字的组合构成。它们用于在芯片的封装底部的焊盘上进行标记。每个引脚标号都与芯片内部的功能或信号相对应，以便正确连接到印刷电路板（PCB）上的目标位置。RK3568的引脚标号图如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022868.jpeg" alt="img"> </p>
<p>可以看到纵向为A-AH的28个字母类型标号，横向为1-28的28个字母类型标号，瑞芯微也在对应的3568数据手册中加入了根据BGA位置制作的复用功能图，部分内容如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022855.jpeg" alt="img"> </p>
<p>其中黑色框代表被保留的引脚，其他有颜色的框一般为电源和地，白色的框代表有具体复用功能的引脚。</p>
<p>脚复用提高了芯片的灵活性和可重用性，通过允许同一个引脚在不同的功能之间切换，可以减少硬件设计的复杂性和成本。此外，引脚复用还使得在使用相同芯片的不同应用中可以更加灵活地配置和定制引脚功能。</p>
<p>会在下一个小节中讲解如何使用pinctrl在设备树中配置引脚的复用。</p>
<h2 id="61-2-使用pinctrl设置复用关系"><a href="#61-2-使用pinctrl设置复用关系" class="headerlink" title="61.2 使用pinctrl设置复用关系"></a>61.2 使用pinctrl设置复用关系</h2><p>pinctrl（引脚控制）用于描述和配置硬件设备上的引脚功能和连接方式。它是设备树的一部分，用于在启动过程中传递引脚配置信息给操作系统和设备驱动程序，以便正确地初始化和控制引脚。</p>
<p>在设备树中，pinctrl（引脚控制）使用了客户端和服务端的概念来描述引脚控制的关系和配置。</p>
<h3 id="61-2-1-客户端-Client"><a href="#61-2-1-客户端-Client" class="headerlink" title="61.2.1 客户端(Client)"></a>61.2.1 客户端(Client)</h3><p>接下来将使用三个例子对客户端要用到的属性进行讲解。</p>
<p>例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node &#123;</span><br><span class="line">    pinctrl-names = &quot;default&quot;;</span><br><span class="line">    pinctrl-0 = &lt;&amp;pinctrl_hog_1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在例1中，pinctrl-names 属性定义了一个状态名称：default。</p>
<p>pinctrl-0 属性指定了第一个状态 default 对应的引脚配置。</p>
<p>&lt;&amp;pinctrl_hog_1&gt; 是一个引脚描述符，它引用了一个名为 pinctrl_hog_1 的引脚控制器节点。这表示在 default 状态下，设备的引脚配置将使用 pinctrl_hog_1 节点中定义的配置。</p>
<p>例2：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">node &#123;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>, <span class="string">&quot;wake up&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_hog_1&gt;;</span><br><span class="line">    pinctrl<span class="number">-1</span> = &lt;&amp;pinctrl_hog_2&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在例2中，pinctrl-names 属性定义了两个状态名称：default 和 wake up。</p>
<p>pinctrl-0 属性指定了第一个状态 default 对应的引脚配置，引用了 pinctrl_hog_1 节点。</p>
<p>pinctrl-1 属性指定了第二个状态 wake up 对应的引脚配置，引用了 pinctrl_hog_2 节点。</p>
<p>这意味着设备可以处于两个不同的状态之一，每个状态分别使用不同的引脚配置。</p>
<p>例3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node &#123;</span><br><span class="line">    pinctrl-names = &quot;default&quot;;</span><br><span class="line">    pinctrl-0 = &lt;&amp;pinctrl_hog_1 &amp;pinctrl_hog_2&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，pinctrl-names 属性仍然定义了一个状态名称：default。</p>
<p>pinctrl-0 属性指定了第一个状态 default 对应的引脚配置，但与之前的例子不同的是，它引用了两个引脚描述符：pinctrl_hog_1 和 pinctrl_hog_2。</p>
<p>这表示在 default 状态下，设备的引脚配置将使用 pinctrl_hog_1 和 pinctrl_hog_2 两个节点中定义的配置。这种方式可以将多个引脚控制器的配置组合在一起，以满足特定状态下的引脚需求。</p>
<p>至此关于客户端的内容就讲解完成了，低于客户端的内容，不同厂家的编写格式是相同的，而服务端每个厂家就有区别了，在下一个小节将以rk3568的pinctrl服务端为例进行讲解。</p>
<h3 id="61-2-2-服务端-Server"><a href="#61-2-2-服务端-Server" class="headerlink" title="61.2.2 服务端(Server)"></a>61.2.2 服务端(Server)</h3><p>服务端是设备树中定义引脚配置的部分。它包含引脚组和引脚描述符，为客户端提供引脚配置选择。服务端在设备树中定义了 pinctrl 节点，其中包含引脚组和引脚描述符的定义。</p>
<p>这里以瑞芯微的RK3568为例进行pinctrl服务端的讲解，瑞芯微原厂BSP工程师为了方便用户通过pinctrl设置管脚的复用关系，将包含所有复用关系的配置写在了内核目录下的“arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568-pinctrl.dtsi”设备树中，具体内容如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022825.jpeg" alt="img"> </p>
<p>在pinctrl节点中就是每个节点的复用功能，然后我们以uart4的引脚复用为例进行讲解，uart4的pinctrl服务端内容如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022736.jpeg" alt="img"> </p>
<p>其中&lt;3 RK_PB1 4 &amp;pcfg_pull_up&gt;和&lt;3 RK_PB2 4 &amp;pcfg_pull_up&gt;分别表示将GPIO3的PB1引脚设置为功能4，将GPIO3的PB2也设置为功能4，且电器属性都会设置为上拉。通过查找原理图可以得到两个引脚在BGA封装位置分别为AG1和AF2，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022803.jpeg" alt="img"> </p>
<p>然后在rk3568的数据手册中找到引脚复用表对应的位置，具体内容如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022099.jpeg" alt="img"><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022123.jpeg" alt="img"> </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022214.jpeg" alt="img"> </p>
<p>可以看到功能4对应串口4的发送端和接收端，pinctrl服务端的配置和数据手册中的引脚复用功能是一一对应，那如果要将RK_PB1和RK_PB2设置为GPIO功能要如何设置呢，从上图可以看到GPIO对应功能0，所以可以通过以下pinctrl内容将设置RK_PB1和RK_PB2设置为GPIO功能（事实上如果不对该管脚进行功能复用该引脚默认就会设置为GPIO功能）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;<span class="number">3</span> RK_PB1 <span class="number">0</span> &amp;pcfg_pull_up&gt;,                                                                                                                                                                                           </span><br><span class="line">&lt;<span class="number">3</span> RK_PB2 <span class="number">0</span> &amp;pcfg_pull_up&gt;;</span><br></pre></td></tr></table></figure>

<p>最后来看客户端对uart4服务端的引用，具体内容在内核源码目录“arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568-evb1-ddr4-v10-linux.dts”：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022165.jpeg" alt="img"> </p>
<p>通过在客户端中引用服务端的引脚描述符，设备树可以将客户端和服务端的引脚配置关联起来。这样，在设备树被解析和处理时，操作系统和设备驱动程序可以根据客户端的需求，查找并应用适当的引脚配置。</p>
<h2 id="61-3-pinctrl实例编写"><a href="#61-3-pinctrl实例编写" class="headerlink" title="61.3 pinctrl实例编写"></a>61.3 pinctrl实例编写</h2><p>本小节将通过上面学到的pinctrl相关知识，将led的控制引脚复用为GPIO模式。</p>
<p>首先来对rk3568的设备树结构进行以下介绍，根据sdk源码目录下的“device&#x2F;rockchip&#x2F;rk356x&#x2F;BoardConfig-rk3568-evb1-ddr4-v10.mk”默认配置文件可以了解到编译的设备树为rk3568-evb1-ddr4-v10-linux.dts,整理好的设备树之间包含关系列表如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022266.png" alt="image-20230906164406935"></p>
<p>Led在rk3568-evb.dtsi设备树中已经被正常配置了，如下图所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022394.jpeg" alt="img"></p>
<p>这时候可能大家就有问题了，这里也并没有配置pinctrl呀，那为什么led最后能正常使用呢，这个原因在上节课中其实我们已经提到了，当一个引脚没有被复用为任何功能时，默认就是GPIO功能，所以这里没有pinctrl led功能也可以正常使用。</p>
<p>但这里我们仍旧使用pinctrl对led进行配置，从而熟练pinctrl，首先注释掉leds节点，注释完成如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022446.jpeg" alt="img"> </p>
<p>保存退出之后，然后进入到rk3568-evb1-ddr4-v10.dtsi设备树中，找到rk_485_ctl节点，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022525.jpeg" alt="img"> </p>
<p>这是根节点的最后一个节点，而且也是用来控制一个GPIO的，我们完全可以仿照该节点，在该节点下方编写led控制节点，仿写完成的设备树内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_led: led &#123;</span><br><span class="line">   compatible = <span class="string">&quot;topeet,led&quot;</span>;</span><br><span class="line">   gpios = &lt;&amp;gpio0 RK_PB7 GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">   pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">   pinctrl<span class="number">-0</span> = &lt;&amp;rk_led_gpio&gt;;</span><br><span class="line">   &#125;;  </span><br></pre></td></tr></table></figure>

<p>第1行：节点名称为 led，标签名为my_led。</p>
<p>第2行：compatible 属性指定了设备的兼容性标识，即设备与驱动程序之间的匹配规则。在这里，设备标识为 “topeet,led”，表示该 LED 设备与名为 “topeet,led” 的驱动程序兼容。</p>
<p>第3行：gpios 属性指定了与LED相关的GPIO（通用输入&#x2F;输出）引脚配置。</p>
<p>第4行：pinctrl-names 属性指定了与引脚控制相关的命名。default表示状态 0</p>
<p>第5行：pinctrl-0 属性指定了与 pinctrl-names 属性中命名的引脚控制相关联的实际引脚控制器配置。&lt;&amp;rk_led_gpio&gt; 表示引用了名为 rk_led_gpio 的引脚控制器配置。</p>
<p>添加完成如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022540.jpeg" alt="img"> </p>
<p>然后继续找到在同一设备树文件的485 pinctrl服务端节点，具体内容如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022591.jpeg" alt="img"> </p>
<p>然后在该节点下方仿写led控制引脚pinctrl服务端节点，仿写完成的节点内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rk_led&#123;</span><br><span class="line">		rk_led_gpio:rk-led-gpio &#123;</span><br><span class="line">			rockchip,pins = &lt;0 RK_PB7 RK_FUNC_GPIO &amp;pcfg_pull_none&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p>添加完成之后如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022594.jpeg" alt="img"> </p>
<p>至此，led的控制引脚就通过pinctrl被复用为了GPIO功能，保存退出之后，重新编译内核，没有报错就证明我们的实验完成了。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-60-实例分析:GPIO</title>
    <url>/2023/09/05/1-60-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-GPIO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第60章-实例分析：GPIO"><a href="#第60章-实例分析：GPIO" class="headerlink" title="第60章 实例分析：GPIO"></a>第60章 实例分析：GPIO</h1><h2 id="60-1-GPIO相关属性"><a href="#60-1-GPIO相关属性" class="headerlink" title="60.1 GPIO相关属性"></a>60.1 GPIO相关属性</h2><h3 id="60-1-1-RK-ft5x06设备树节点"><a href="#60-1-1-RK-ft5x06设备树节点" class="headerlink" title="60.1.1 RK ft5x06设备树节点"></a>60.1.1 RK ft5x06设备树节点</h3><p>下面展示的是iTOP-RK3568开发板SDK源码中的ft5x06设备树，其中蓝色字体部分就是关于gpio相关的描述，包括了interrupts、 interrupt-controller、#interrupt-cells、interrupt-parent四种常见属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio0: gpio@fdd60000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;rockchip,gpio-bank&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0</span> <span class="number">0xfdd60000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">33</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    clocks = &lt;&amp;pmucru PCLK_GPI00&gt;, &lt;&amp;pmucru DBCLK_GPI00&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    gpio-ranges = &lt;&amp;pinctrl <span class="number">0</span> <span class="number">0</span> <span class="number">32</span>&gt;;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06@<span class="number">38</span> &#123; </span><br><span class="line">    status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    compatible = <span class="string">&quot;edt,edt-ft5306&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">    touch-gpio = &lt;&amp;gpio0 RK_PB5 IRQ_TYPE_EDGE_RISING&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio0&gt;;</span><br><span class="line">    interrupts = &lt;RK_PB5 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">    reset-gpios = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    touchscreen-size-x = &lt;<span class="number">800</span>&gt;;</span><br><span class="line">    touchscreen-size-y = &lt;<span class="number">1280</span>&gt;;</span><br><span class="line">    touch_type = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中gpio0节点是在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568.dtsi”设备树的3549-3560行定义的，而ft5x06: ft5x06@38触摸芯片节点是在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;topeet_rk3568_lcds.dtsi”设备树的301-313行定义的。接下来将会对设备树常见的四个gpio属性进行介绍。</p>
<h3 id="60-1-2-gpio-controller"><a href="#60-1-2-gpio-controller" class="headerlink" title="60.1.2 gpio-controller"></a>60.1.2 gpio-controller</h3><p>gpio-controller属性用于标识一个设备节点作为GPIO控制器。GPIO控制器是负责管理和控制GPIO引脚的硬件模块或驱动程序。</p>
<p>gpio-controller属性通常作为设备节点的一个属性出现，位于设备节点的属性列表中。</p>
<p>当一个设备节点被标识为GPIO控制器时，它通常会定义一组GPIO引脚，并提供相关的GPIO控制和配置功能。其他设备节点可以使用该GPIO控制器来控制和管理其GPIO引脚。</p>
<p>通过使用gpio-controller属性，设备树可以明确标识出GPIO控制器设备节点，使系统可以正确识别和管理GPIO引脚的配置和控制。</p>
<h3 id="60-1-3-gpio-cells"><a href="#60-1-3-gpio-cells" class="headerlink" title="60.1.3 #gpio-cells"></a>60.1.3 #gpio-cells</h3><p>#gpio-cells属性用于指定GPIO引脚描述符的编码方式。GPIO引脚描述符是用于标识和配置GPIO引脚的一组值，例如引脚编号、引脚属性等。</p>
<p>#gpio-cells属性的属性值是一个整数，表示用于编码GPIO引脚描述符的单元数。通常，这个值为2。</p>
<p>在第一小节的示例中有1个gpio引脚描述属性,由于#gpio-cells属性被设置为了2，所以每个引脚描述属性中会有两个整数，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ft5x06: ft5x06@<span class="number">38</span> &#123; </span><br><span class="line">    .....</span><br><span class="line">    reset-gpios = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>RK_PB6、GPIO_ACTIVE_LOW都属于恒定义，会在下面的小节进行讲解。</p>
<p>通过使用#gpio-cells属性，设备树可以指定GPIO引脚描述符的编码方式，使系统能够正确识别和解析GPIO引脚的配置和控制。</p>
<h3 id="60-1-4-gpio-ranges"><a href="#60-1-4-gpio-ranges" class="headerlink" title="60.1.4 gpio-ranges"></a>60.1.4 gpio-ranges</h3><p>gpio-ranges属性是设备树中一个用于描述GPIO范围映射的属性。它通常用于描述具有大量GPIO引脚的GPIO控制器，以简化GPIO引脚的编码和访问。</p>
<p>在设备树中，GPIO控制器的每个引脚都有一个本地编号，用于在控制器内部进行引脚寻址。然而，这些本地编号并不一定与外部引脚的物理编号或其他系统中使用的编号一致。为了解决这个问题，可以使用gpio-ranges属性将本地编号映射到实际的引脚编号。</p>
<p>gpio-ranges属性是一个包含一系列整数值的列表，每个整数值对应于设备树中的一个GPIO控制器。列表中的每个整数值按照特定的顺序提供以下信息：</p>
<p>（1）外部引脚编号的起始值。	</p>
<p>（2）GPIO控制器内部本地编号的起始值。</p>
<p>（3）引脚范围的大小（引脚数量）。</p>
<p>在第一小节的示例中gpio-ranges属性的值为&lt;&amp;pinctrl 0 0 32&gt;，其中&lt;&amp;pinctrl&gt;表示引用了名为pinctrl的引脚控制器节点，0 0 32表示外部引脚从0开始，控制器本地编号从0开始，共映射了32个引脚。</p>
<p>这样，gpio-ranges属性将GPIO控制器的本地编号直接映射到外部引脚编号，使得GPIO引脚的编码和访问更加简洁和直观。</p>
<h3 id="60-1-5-gpio引脚描述属性"><a href="#60-1-5-gpio引脚描述属性" class="headerlink" title="60.1.5 gpio引脚描述属性"></a>60.1.5 gpio引脚描述属性</h3><p>第一小节的设备树中关于gpio引脚描述属性相关内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ft5x06: ft5x06@<span class="number">38</span> &#123; </span><br><span class="line">    .....</span><br><span class="line">    reset-gpios = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>gpio引脚描述属性个数由#gpio-cells所决定，因为gpio0节点中的#gpio-cells属性设置为了2，所以上面设备树gpio引脚描述属性个数也为2。</p>
<p>其中RK_PB6 定义在内核源码目录下的“include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h”头文件中，定义了RK引脚名和gpio编号的宏定义，如下图所示：<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022930.jpeg" alt="img"> </p>
<p>GPIO_ACTIVE_LOW定义在源码目录下的“include&#x2F;dt-bindings&#x2F;gpio&#x2F;gpio.h”中，表示设置为低电平，同理GPIO_ACTIVE_HIGH就表示将这个GPIO设置为高电平，但这里只是对设备的描述，具体的设置还是要跟驱动相匹配。</p>
<h3 id="60-1-6-其他属性"><a href="#60-1-6-其他属性" class="headerlink" title="60.1.6 其他属性"></a>60.1.6 其他属性</h3><p>本小节将根据下面的设备树示例讲解一下gpio的其他重要属性，设备树具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpio-controller@00000000 &#123;</span><br><span class="line">    compatible = &quot;foo&quot;;</span><br><span class="line">    reg = &lt;0x00000000 0x1000&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    #gpio-cells = &lt;2&gt;;</span><br><span class="line">    ngpios = &lt;18&gt;;</span><br><span class="line">    gpio-reserved-ranges = &lt;0 4&gt;, &lt;12 2&gt;;</span><br><span class="line">    gpio-line-names = &quot;MMC-CD&quot;, &quot;MMC-WP&quot;,</span><br><span class="line">                      &quot;voD eth&quot;, &quot;RST eth&quot;, &quot;LED R&quot;,</span><br><span class="line">                      &quot;LED G&quot;, &quot;LED B&quot;, &quot;col A&quot;,</span><br><span class="line">                      &quot;col B&quot;, &quot;col C&quot;, &quot;col D&quot;,</span><br><span class="line">                      &quot;NMI button&quot;, &quot;Row A&quot;, &quot;Row B&quot;,</span><br><span class="line">                      &quot;Row C&quot;, &quot;Row D&quot;, &quot;poweroff&quot;,</span><br><span class="line">                      &quot;reset&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第6行的ngpios 属性指定了 GPIO 控制器所支持的 GPIO 引脚数量。它表示该设备上可用的 GPIO 引脚的总数。在这个例子中，ngpios&#96; 的值为 18，意味着该 GPIO 控制器支持 18 个 GPIO 引脚。</p>
<p>第7行的gpio-reserved-ranges属性定义了保留的GPIO范围。每个范围由两个整数值表示，用尖括号括起来。保留的GPIO范围意味着这些GPIO引脚不可用或已被其他设备或功能保留。在这个例子中，有两个保留范围：&lt;0 4&gt;和&lt;12 2&gt;。&lt;0 4&gt;表示从第0个引脚开始的连续4个引脚被保留，而&lt;12 2&gt;表示从第12个引脚开始的连续2个引脚被保留。<br>    第8行的gpio-line-names 属性定义了GPIO引脚的名称，以逗号分隔。每个名称对应一个 GPIO 引脚。这些名称用于标识和识别每个GPIO引脚的作用或连接的设备。在这个例子中，gpio-line-names属性列出了多个GPIO引脚的名称，如 “MMC-CD”、”MMC-WP”、”voD eth” 等等。通过这些名称，可以清楚地了解每个GPIO引脚的功能或用途。</p>
<h2 id="60-2-中断实例编写"><a href="#60-2-中断实例编写" class="headerlink" title="60.2 中断实例编写"></a>60.2 中断实例编写</h2><p>在上一个小节中对设备树中断要用到的属性进行了讲解，而在本小节将会编写一个在RK3568上LED灯的中断设备树。</p>
<p>首先确定LED的引脚编号，LED原理图如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022878.jpeg" alt="img"> </p>
<p>从上面的原理图可以得到LED灯的引脚网络标号为Working_LEDEN_H_GPIO0_B7，对应的引脚为GPIO0_B7。</p>
<p>然后来查看内核源码目录下的“drivers&#x2F;drivers&#x2F;leds&#x2F;leds-gpio.c”文件，这是led的驱动文件，然后找到compatible匹配值相关的部分，如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022895.jpeg" alt="img"> </p>
<p>可以看到compatible匹配值为gpio-leds。</p>
<p>最后在内核源码目录下的“include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h”头文件中，定义了RK引脚名和gpio编号的宏定义，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022857.jpeg" alt="img"> </p>
<p>在源码目录下的“include&#x2F;dt-bindings&#x2F;gpio&#x2F;gpio.h”文件中定义了引脚极性设置宏定义，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022886.jpeg" alt="img"> </p>
<p>其中GPIO_ACTIVE_HIGH表示将该引脚设置为高电平，GPIO_ACTIVE_LOW表示将该引脚设置为低电平。</p>
<p>至此，我们关于编写LED设备树的前置内容就查找完成了，接下来进行设备树的编写。</p>
<p>  编写完成的设备树如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/pinctrl/rockchip.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/gpio/gpio.h&quot;</span></span></span><br><span class="line">/&#123;</span><br><span class="line">	model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line"></span><br><span class="line">	led led@<span class="number">1</span> &#123;</span><br><span class="line">		compatible = <span class="string">&quot;gpio-leds&quot;</span>;</span><br><span class="line">		gpios = &lt;&amp;gpio0 RK_PB7 GPIO_ACTIVE_HIGH&gt;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第1行: 设备树文件的头部，指定了使用的设备树语法版本。</p>
<p>第3行：用于定义 Rockchip 平台的引脚控制器相关的绑定。</p>
<p>第4行：用于定义中断控制器相关的绑定。</p>
<p>第5行：表示设备树的根节点开始。</p>
<p>第6行：指定了设备树的模型名称，描述为 “This is my devicetree!”。</p>
<p>第9行：指定了设备节点的兼容性字符串，表示该设备与 “gpio-leds” 兼容。</p>
<p>第10行：指定了该 LED 设备所使用的 GPIO 引脚。&amp;gpio0 是引脚控制器的引用，RK_PB7 是引脚的编号或标识，GPIO_ACTIVE_HIGH 表示该 GPIO 引脚的活动电平是高电平。</p>
<p>至此，关于led的设备树就讲解完成了。</p>
<h2 id="60-3-其他SOC设备树对比"><a href="#60-3-其他SOC设备树对比" class="headerlink" title="60.3 其他SOC设备树对比"></a>60.3 其他SOC设备树对比</h2><p>而无论使用的是瑞芯微SOC还是恩智浦、三星的SOC，在设备树关于gpio相关的描述都是类似的，关于在恩智浦和三星源码中的ft5x06设备树如下所示：</p>
<p>恩智浦：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio1: gpio@<span class="number">0209</span>c000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;fsl,inx6ul-gpio&quot;</span>, <span class="string">&quot;fsl,imx35-gpio&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0209c000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">66</span> IRQ_TYPE_LEVEL_HIGH&gt;, &lt;GIC_SPI <span class="number">67</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    edt-ft5x06@<span class="number">38</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;edt,edt-ft5306&quot;</span>, <span class="string">&quot;edt,edt-ft5x06&quot;</span>, <span class="string">&quot;edt,edt-ft5406&quot;</span>;</span><br><span class="line">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        pinctrl<span class="number">-0</span> = &lt;&amp;ts_int_pin &amp;ts_reset_pin&gt;;</span><br><span class="line">        reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">        interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">        interrupts = &lt;<span class="number">9</span> <span class="number">0</span>&gt;;</span><br><span class="line">        reset-gpios = &lt;&amp;gpio5 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">        irq-gpios = &lt;&amp;gpio1 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>三星：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio_c: gpioc &#123;</span><br><span class="line">    compatible = <span class="string">&quot;gpio-controller&quot;</span>;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06038 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;edt,edt-ft5406&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(RGB_1024x600) || defined(RGB_800x480)</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;tsc2007_irq&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio_c&gt;;</span><br><span class="line">    interrupts = &lt;<span class="number">26</span> IRQ_TYPE_EDGE_FALLING&gt;;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(LvDs_800×1280) || defined(LvDS_1024x768)</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;gt911_irq&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio_b&gt;;</span><br><span class="line">    interrupts = &lt;<span class="number">29</span> IRQ_TYPE_EDGE_FALLING&gt;;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> reset-gpios = &lt;&amp;gpio_e <span class="number">30</span> <span class="number">0</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对比之后会发现，不同厂商对于gpio的配置都是类似的，只是里面的参数有些许区别，如果大家在之后遇到了其他平台，只需要稍加区分即可</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-59-实例分析:CPU</title>
    <url>/2023/09/05/1-59-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-CPU/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第59章-实例分析：CPU"><a href="#第59章-实例分析：CPU" class="headerlink" title="第59章 实例分析：CPU"></a>第59章 实例分析：CPU</h1><h2 id="59-1-cpus节点"><a href="#59-1-cpus节点" class="headerlink" title="59.1 cpus节点"></a>59.1 cpus节点</h2><p>设备树的 cpus 节点是用于描述系统中的处理器的一个重要节点。它是处理器拓扑结构的顶层节点，包含了所有处理器相关的信息。下面将详细介绍设备树的 cpus 节点的各个方面。</p>
<p><strong>节点结构：</strong></p>
<p>cpus 节点是一个容器节点，其下包含了系统中每个处理器的子节点。每个子节点的名称通常为 cpu@X，其中 X 是处理器的索引号。每个子节点都包含了与处理器相关的属性，例如时钟频率、缓存大小等。</p>
<p><strong>处理器属性：</strong></p>
<p>cpu@X 子节点中的属性可以包括以下信息：</p>
<p>（1）device_type：指示设备类型为处理器（”cpu”）。</p>
<p>（2）reg：指定处理器的地址范围，通常是物理地址或寄存器地址。</p>
<p>（3）compatible：指定处理器的兼容性信息，用于匹配相应的设备驱动程序。</p>
<p>（4）clock-frequency：指定处理器的时钟频率。</p>
<p>（5）cache-size：指定处理器的缓存大小。</p>
<p><strong>处理器拓扑关系：</strong></p>
<p>除了处理器的基本属性，cpus 节点还可以包含其他用于描述处理器拓扑关系的节点，以提供更详细的处理器拓扑信息。这些节点可以帮助操作系统和软件了解处理器之间的连接关系、组织结构和特性。</p>
<p>cpu-map 节点：描述处理器的映射关系，通常在多核处理器系统中使用。</p>
<p>socket 节点：描述多处理器系统中的物理插槽或芯片组。</p>
<p>cluster 节点：描述处理器集群，即将多个处理器组织在一起形成的逻辑组。</p>
<p>core 节点：描述处理器核心，即一个物理处理器内的独立执行单元。</p>
<p>thread 节点：描述处理器线程，即一个物理处理器核心内的线程。</p>
<p>这些节点的嵌套关系可以在 cpus 节点下形成一个层次结构，反映了处理器的拓扑结构。上述这些节点会在后面的小节进行介绍。一个单核CPU设备树和一个四核CPU设备树示例如下所示：</p>
<p>单核CPU示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    cpu0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a7&quot;</span>;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        <span class="comment">// 其他属性...</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多核CPU示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;0&gt;;</span><br><span class="line"></span><br><span class="line">    cpu0: cpu@0 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a9&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@1 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a9&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu2: cpu@2 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a9&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu3: cpu@3 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a9&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cpus 节点是一个容器节点，包含了 cpu0 子节点。该节点使用了 #address-cells 和 #size-cells 属性来指定地址和大小的单元数量。</p>
<p>cpu0 子节点代表第一个处理器，具有以下属性：</p>
<p>compatible 属性指定了处理器的兼容性信息</p>
<p>device_type 属性指示设备类型为处理器。</p>
<p>你可以在此基础上继续添加其他属性来描述处理器的特性，如时钟频率、缓存大小等。</p>
<h2 id="59-2-cpu-map、socket、cluster节点"><a href="#59-2-cpu-map、socket、cluster节点" class="headerlink" title="59.2 cpu-map、socket、cluster节点"></a>59.2 cpu-map、socket、cluster节点</h2><p>cpu-map 节点是设备树中用于描述大小核架构处理器的映射关系的节点之一。它的父节点必须是 cpus 节点，而子节点可以是一个或多个 cluster 和 socket 节点。通过 cpu-map 节点，可以定义不同核心和集群之间的连接和组织结构。</p>
<p>socket 节点用于描述处理器插槽（socket）之间的映射关系。每个 socket 子节点表示一个处理器插槽，可以使用 cpu-map-mask 属性来指定该插槽使用的核心。通过为每个 socket 子节点指定适当的 cpu-map-mask，可以定义不同插槽中使用的核心。这样，操作系统和软件可以了解到不同插槽之间的核心分配情况。</p>
<p>cluster 节点用于描述核心（cluster）之间的映射关系。每个 cluster 子节点表示一个核心集群，可以使用 cpu-map-mask 属性来指定该集群使用的核心。通过为每个 cluster 子节点指定适当的 cpu-map-mask，可以定义每个集群中使用的核心。这样，操作系统和软件可以了解到不同集群之间的核心分配情况。</p>
<p>通过在 cpu-map 节点中定义 socket 和 cluster 子节点，并为它们指定适当的 cpu-map-mask，可以提供处理器的拓扑结构信息。这对于操作系统和软件来说非常有用，因为它们可以根据这些信息进行任务调度和资源分配的优化，以充分利用大小核架构处理器的性能和能效特性。</p>
<p>一个大小核架构的具体示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">    cpu-<span class="built_in">map</span> &#123;</span><br><span class="line">        cluster0 &#123;</span><br><span class="line">            core0 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_l0&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">            core1 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_l1&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">            core2 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_l2&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">            core3 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_l3&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        cluster1 &#123;</span><br><span class="line">            core0 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_b0&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">            core1 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_b1&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">	cpu_l0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_l1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_l2: cpu@<span class="number">2</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_l3: cpu@<span class="number">3</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_b0: cpu@<span class="number">100</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a72&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_b1: cpu@<span class="number">101</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a72&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个设备树描述了一个具有多个 CPU 核心的系统，包括四个 Cortex-A53 核心和两个 Cortex-A72 核心。下面是对设备树中各个部分的简要介绍：</p>
<p>#address-cells &#x3D; &lt;2&gt;; 和 #size-cells &#x3D; &lt;0&gt;;：这些属性指定了设备树中地址和大小的编码方式。</p>
<p>cpu-map：这个节点定义了 CPU 的映射关系。它包含了两个簇（clusters）：cluster0 和 cluster1。cluster0 包含了四个核心：core0、core1、core2 和 core3，分别对应 cpu_l0、cpu_l1、cpu_l2 和 cpu_l3。cluster1 包含了两个核心：core0 和 core1，分别对应 cpu_b0 和 cpu_b1。</p>
<p>cpu_l0、cpu_l1、cpu_l2 和 cpu_l3：这些节点描述了 Cortex-A53 核心。它们具有相同的设备类型 cpu 和兼容性属性 “arm,cortex-a53”, “arm,armv8”。</p>
<p>cpu_b0 和 cpu_b1：这些节点描述了 Cortex-A72 核心。它们具有相同的设备类型 cpu 和兼容性属性 “arm,cortex-a72”, “arm,armv8”。</p>
<h2 id="59-3-core、thread节点"><a href="#59-3-core、thread节点" class="headerlink" title="59.3 core、thread节点"></a>59.3 core、thread节点</h2><p>“core” 和 “thread” 节点通常用于描述处理器核心和线程的配置。下面是对这两个节点的详细介绍：</p>
<p>Core 节点用于描述处理器的核心。一个处理器通常由多个核心组成，每个核心可以独立执行指令和任务。</p>
<p>Thread 节点用于描述处理器的线程。线程是在处理器核心上执行的基本执行单元，每个核心可以支持多个线程。</p>
<p>通过使用 Core 和 Thread 节点，设备树可以准确描述处理器的核心和线程的配置，例如可以使用设备树来描述一个具有16个核心的CPU，一个物理插槽，每个集群中有两个核心，每个核心有两个线程的设备树示例，具体设备树如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    cpu-<span class="built_in">map</span> &#123;</span><br><span class="line">        socket0 &#123;</span><br><span class="line">            cluster0 &#123;</span><br><span class="line">                core0 &#123;</span><br><span class="line">                    thread0 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU0&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    thread1 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU1&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">                core1 &#123;</span><br><span class="line">                    thread0 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU2&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    thread1 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU3&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            cluster1 &#123;</span><br><span class="line">                core0 &#123;</span><br><span class="line">                    thread0 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU4&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    thread1 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU5&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">                core1 &#123;</span><br><span class="line">                    thread0 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU6&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    thread1 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU7&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        socket1 &#123;</span><br><span class="line">			cluster0 &#123;</span><br><span class="line">				core0 &#123;</span><br><span class="line">					thread0 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU8&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">					thread1 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU9&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;;</span><br><span class="line">				core1 &#123;</span><br><span class="line">					thread0 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU10&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">					thread1 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU11&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">			cluster1 &#123;</span><br><span class="line">				core0 &#123;</span><br><span class="line">					thread0 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU12&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">					thread1 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU13&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;;</span><br><span class="line">				core1 &#123;</span><br><span class="line">					thread0 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU14&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">					thread1 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU15&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-58-实例分析:时钟</title>
    <url>/2023/09/05/1-58-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-%E6%97%B6%E9%92%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第58章-实例分析：时钟"><a href="#第58章-实例分析：时钟" class="headerlink" title="第58章 实例分析：时钟"></a>第58章 实例分析：时钟</h1><p>时钟（Clock）用于描述硬件设备和系统中的时钟源以及时钟相关的配置和连接关系。时钟在计算机系统中起着至关重要的作用，用于同步和定时各种硬件设备的操作。时钟可以分为两个主要角色：时钟生产者（clock provider）和时钟消费者（clock consumer）。</p>
<p><strong>时钟生产者</strong></p>
<p>定义：时钟生产者是负责生成和提供时钟信号的硬件或软件模块。它可以是时钟控制器、PLL、时钟发生器等。</p>
<p>设备树节点：时钟生产者在设备树中以时钟节点的形式表示。</p>
<p>时钟节点属性：</p>
<p><strong>（1）clock-cells：</strong>该属性用于指定时钟编号的位数。它是一个整数值，表示时钟编号的位数。通常情况下，当 clock-cells 为 0 时表示一个时钟，为 1 表示多个时钟。具体示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例<span class="number">1</span>：单个时钟</span><br><span class="line">osc24m: osc24m &#123;</span><br><span class="line">    compatible = <span class="string">&quot;clock&quot;</span>;</span><br><span class="line">    clock-frequency = &lt;<span class="number">24000000</span>&gt;;</span><br><span class="line">    clock-output-names = <span class="string">&quot;osc24m&quot;</span>;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;O&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">示例<span class="number">2</span>：多个时钟</span><br><span class="line">clock: clock &#123;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    clock-output-names = <span class="string">&quot;clock1&quot;</span>, <span class="string">&quot;clock2&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>（2）clock-frequency：</strong>属性是设备树中用于指定时钟频率的属性。它用于描述时钟节点所提供的时钟信号的频率，使用 Hertz (Hz) 作为单位。对于时钟生产者节点，clock-frequency 属性表示该节点生成的时钟信号的频率。它用于描述时钟控制器、晶振、PLL 等产生时钟信号的硬件或软件模块的输出频率，例如指定时钟频率为24000000的具体示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">osc24m: osc24m &#123;</span><br><span class="line">    compatible = <span class="string">&quot;clock&quot;</span>;</span><br><span class="line">    clock-frequency = &lt;<span class="number">24000000</span>&gt;;</span><br><span class="line">    clock-output-names = <span class="string">&quot;osc24m&quot;</span>;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;O&gt;</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>（3）assigned-clocks 和 assigned-clock-rates ：</strong>是设备树中用于描述多路时钟的属性，通常一起使用。</p>
<p>assigned-clocks 属性用于标识时钟消费者节点所使用的时钟源。它是一个整数数组，每个元素对应一个时钟编号。时钟编号是指时钟生产者节点（如时钟控制器）所提供的时钟源的编号。通过在时钟消费者节点中使用 assigned-clocks 属性，可以指定该节点所需的时钟源。</p>
<p>assigned-clock-rates 属性用于指定每个时钟源的时钟频率。它是一个整数数组，每个元素对应一个时钟源的频率。时钟频率以 Hz (赫兹) 为单位表示。assigned-clock-rates 属性的元素数量和顺序应与 assigned-clocks 属性中的时钟编号相对应。</p>
<p>关于assigned-clocks 和 assigned-clock-rates 属性的一个具体示例如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cru: clock-controller@fdd20000 &#123;</span><br><span class="line">    #clock-cells = &lt;1&gt;;</span><br><span class="line">    assigned-clocks = &lt;&amp;pmucru CLK_RTC_32K&gt;, &lt;&amp;cru ACLK_RKVDEC_PRE&gt;;</span><br><span class="line">    assigned-clock-rates = &lt;32768&gt;, &lt;300000000&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>（4）clock-indices：</strong>clock-indices 属性用于指定时钟消费者节点所使用的时钟源的索引值。它是一个整数数组，每个元素对应一个时钟源的索引。</p>
<p>时钟索引是指时钟生产者节点（如时钟控制器）所提供的时钟源的编号。通过在时钟消费者节点中使用 clock-indices 属性，可以明确指定该节点所需的时钟源，并按照特定的顺序进行匹配。一个clock-indices示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">scpi_dvfs: clocks<span class="number">-0</span> &#123;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    clock-indices = &lt;<span class="number">0</span>&gt;, &lt;<span class="number">1</span>&gt;, &lt;<span class="number">2</span>&gt;;</span><br><span class="line">    clock-output-names = <span class="string">&quot;atlclk&quot;</span>, <span class="string">&quot;aplclk&quot;</span>, <span class="string">&quot;gpuclk&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">scpi_clk: clocks<span class="number">-1</span> &#123;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    clock-indices = &lt;<span class="number">3</span>&gt;;</span><br><span class="line">    clock-output-names = <span class="string">&quot;pxlclk&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在第一个节点中”atlclk”, “aplclk”, “gpuclk”三个时钟源的索引就分别被设置为了0、1、2，在第二个节点中”pxlclk”时钟源的索引值被设置为了3.</p>
<p><strong>（5）assigned-clock-parents</strong> 属性用于指定时钟消费者节点所使用的时钟源的父时钟源。它是一个时钟源引用的数组，每个元素对应一个父时钟源的引用。在时钟的层次结构中，某些时钟源可能是其他时钟源的父时钟源，即它们提供时钟信号给其他时钟源作为输入。通过在时钟消费者节点中使用 assigned-clock-parents 属性，可以明确指定该节点所需的父时钟源，并按照特定的顺序进行匹配。一个实际的 assigned-clock-parents 属性例子如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clock: clock &#123;</span><br><span class="line">    assigned-clocks = &lt;&amp;clkcon 0&gt;, &lt;&amp;pll 2&gt;;</span><br><span class="line">    assigned-clock-parents = &lt;&amp;pll 2&gt;;</span><br><span class="line">    assigned-clock-rates = &lt;115200&gt;, &lt;9600&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述设备树表示了一个名为 clock 的时钟消费者节点，具有以下属性：</p>
<p>assigned-clocks 属性指定了该节点使用的时钟源，引用了两个时钟源节点：clkcon 0 和 pll 2。</p>
<p>assigned-clock-parents 属性指定了这些时钟源的父时钟源，引用了 pll 2 时钟源节点。</p>
<p>assigned-clock-rates 属性指定了每个时钟源的时钟频率，分别是 115200 和 9600。</p>
<p><strong>时钟消费者（Clock Consumer）：</strong></p>
<p>定义：时钟消费者是依赖时钟信号的硬件设备或模块。它们通过引用时钟生产者节点提供的时钟源来获取时钟信号。</p>
<p>设备树节点：时钟消费者在设备树中的节点中使用属性来引用时钟生产者的时钟源。</p>
<p>时钟消费者属性：</p>
<p>（1）clocks：该属性用于指定时钟消费者节点所需的时钟源。它是一个整数数组，每个元素是一个时钟编号，表示时钟消费者需要的一个时钟源。</p>
<p>（2）clock-names：可选属性，用于指定时钟消费者节点所需时钟源的名称。它是一个字符串数组，与 clocks 数组一一对应，用于提供时钟源的描述性名称。</p>
<p>一个时钟消费者示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clock: clock &#123;</span><br><span class="line">    clocks = &lt;&amp;cru CLK_VOP&gt;;</span><br><span class="line">    clock-names = <span class="string">&quot;clk_vop&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>clocks 属性指定了该节点使用的时钟源，引用了 cru 节点中的 CLK_VOP 时钟源。</p>
<p>clock-names 属性指定了时钟源的名称，这里是 “clk_vop”。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-57-实例分析:中断</title>
    <url>/2023/09/05/1-57-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第57章-实例分析：中断"><a href="#第57章-实例分析：中断" class="headerlink" title="第57章 实例分析：中断"></a>第57章 实例分析：中断</h1><h2 id="57-1-中断相关属性"><a href="#57-1-中断相关属性" class="headerlink" title="57.1 中断相关属性"></a>57.1 中断相关属性</h2><h3 id="57-1-1-RK-ft5x06设备树节点"><a href="#57-1-1-RK-ft5x06设备树节点" class="headerlink" title="57.1.1 RK ft5x06设备树节点"></a>57.1.1 RK ft5x06设备树节点</h3><p>下面展示的是iTOP-RK3568开发板SDK源码中的ft5x06设备树，包括了interrupts、 interrupt-controller、#interrupt-cells、interrupt-parent四种常见属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio0: gpio@fdd60000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;rockchip,gpio-bank&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0</span> <span class="number">0xfdd60000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">33</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    clocks = &lt;&amp;pmucru PCLK_GPI00&gt;, &lt;&amp;pmucru DBCLK_GPI00&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    gpio-ranges = &lt;&amp;pinctrl <span class="number">0</span> <span class="number">0</span> <span class="number">32</span>&gt;;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06@<span class="number">38</span> &#123; </span><br><span class="line">    status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    compatible = <span class="string">&quot;edt,edt-ft5306&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">    touch-gpio = &lt;&amp;gpio0 RK_PB5 IRQ_TYPE_EDGE_RISING&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio0&gt;;</span><br><span class="line">    interrupts = &lt;RK_PB5 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">    reset-gpios = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    touchscreen-size-x = &lt;<span class="number">800</span>&gt;;</span><br><span class="line">    touchscreen-size-y = &lt;<span class="number">1280</span>&gt;;</span><br><span class="line">    touch_type = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中gpio0节点是在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568.dtsi”设备树的3549-3560行定义的，而ft5x06: ft5x06@38触摸芯片节点是在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;topeet_rk3568_lcds.dtsi”设备树的301-313行定义的。接下来将会对设备树常见的四个中断属性进行介绍。</p>
<h3 id="57-1-2-interrupts"><a href="#57-1-2-interrupts" class="headerlink" title="57.1.2 interrupts"></a>57.1.2 interrupts</h3><p>interrupts 属性用于指定设备的中断相关信息。它描述了中断控制器的类型、中断号以及中断触发类型。下面将对interrupts 属性的各个方面进行介绍。</p>
<p>在第一小节中列举的设备树源码中的gpio0节点和ft5x06节点都涉及到了interrupts 属性，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio0: gpio@fdd60000 &#123;</span><br><span class="line">    ....</span><br><span class="line">interrupts = &lt;GIC_SPI <span class="number">33</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06@<span class="number">38</span> &#123; </span><br><span class="line">    ....</span><br><span class="line">interrupts = &lt;RK_PB5 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>gpio0节点的interrupts具有三个参数，分别表示中断控制器类型、中断号和中断触发类型，每个参数的具体描述如下所示：</p>
<p><strong>（1）中断控制器类型：</strong></p>
<p>interrupts 属性的第一个参数指定了中断控制器的类型。常见的类型包括 GIC (Generic Interrupt Controller)、IRQ (Basic Interrupt Handling) 等。例如，在给定的代码片段中，GIC_SPI 表示中断控制器的类型为 GIC SPI 中断。</p>
<p>中断控制器负责管理系统中的中断信号，它可以是硬件中的专用中断控制器，也可以是处理器内部的中断控制器。</p>
<p><strong>（2）中断号：</strong></p>
<p>interrupts 属性的第二个参数指定了设备所使用的中断号。中断号是一个唯一标识符，用于区分不同的中断信号源。系统使用中断号来识别中断源并进行相应的中断处理。</p>
<p>中断号可以是一个整数值，也可以是一个宏定义或符号引用。在给定的代码片段中，33 表示该设备使用的中断号为 33。</p>
<p><strong>（3）中断触发类型：</strong></p>
<p>interrupts 属性的第三个参数指定了中断的触发类型，即中断信号的触发条件。常见的触发类型包括边沿触发和电平触发。</p>
<p>边沿触发表示中断信号在从低电平到高电平或从高电平到低电平的变化时触发。触发类型可以是上升沿触发、下降沿触发或双边沿触发。电平触发表示中断信号在保持特定电平状态时触发，可以是高电平触发或低电平触发。</p>
<p>在给定的代码片段中，IRQ_TYPE_LEVEL_HIGH 表示中断的触发类型为高电平触发。触发类型的宏定义在内核源码“include&#x2F;dt-bindings&#x2F;interrupt-controller&#x2F;irq.h”目录下，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_NONE           0   <span class="comment">// 无中断触发类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_RISING    1   <span class="comment">// 上升沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_FALLING   2   <span class="comment">// 下降沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_BOTH    (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING)<span class="comment">// 双边沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_LEVEL_HIGH     4   <span class="comment">// 高电平触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_LEVEL_LOW      8   <span class="comment">// 低电平触发</span></span></span><br></pre></td></tr></table></figure>

<p>而在ft5x06节点中只有中断号和中断触发类型两个参数，这是为什么呢，带着疑问我们继续学习下面的几个属性。</p>
<h3 id="57-1-3-interrupt-controller"><a href="#57-1-3-interrupt-controller" class="headerlink" title="57.1.3 interrupt-controller"></a>57.1.3 interrupt-controller</h3><p>interrupt-controller 属性是设备树中用于描述中断控制器的属性之一。它提供了关于中断控制器的相关信息，以便操作系统和其他设备能够正确配置和使用中断系统。<br>    interrupt-controller 属性用于标识当前节点所描述的设备是一个中断控制器。中断控制器是硬件或软件模块，负责管理和分发中断信号。它接收来自各种设备的中断请求，并根据优先级和配置规则分发中断给相应的处理器或设备。<br>    interrupt-controller属性本身没有特定的属性值，只需出现在节点的属性列表中即可。出现该属性的存在即表示该节点描述的设备是中断控制器。</p>
<h3 id="57-1-4-interrupt-parent"><a href="#57-1-4-interrupt-parent" class="headerlink" title="57.1.4 interrupt-parent"></a>57.1.4 interrupt-parent</h3><p>interrupt-parent 属性是设备树中用于建立中断信号源与中断控制器之间关联的属性。它指定了中断信号源所属的中断控制器节点，以确保正确的中断处理和分发。<br>    interrupt-parent属性用于指定中断信号源所属的中断控制器。中断信号源是产生中断的设备或其他中断源节点。通过指定中断控制器，操作系统可以正确地将中断请求传递给相应的中断控制器节点进行处理和分发。<br>    interrupt-parent属性值是一个引用，它指向中断控制器节点的路径或标签。可以使用路径来引用中断控制器节点，如&#x2F;interrupt-controller-node，或使用标签来引用中断控制器节点，如 &amp;interrupt-controller-label，在第一小节例子中的 ft5x06就是通过中断控制器节点和gpio0中断控制器建立了联系，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ft5x06: ft5x06@38 &#123; </span><br><span class="line">    ....</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio0&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	中断信号源节点（例如设备节点或其他中断源节点）中的 interrupt-parent 属性用于指定中断信号源所属的中断控制器节点。这样，中断信号源就可以将中断请求传递给正确的中断控制器进行处理。中断信号源节点的 interrupts 属性中的中断号和其他相关信息将与指定的中断控制器关联起来。<br>​	在某些情况下，中断控制器可以形成多级结构，其中一个中断控制器节点可能是另一个中断控制器的父节点。在这种情况下，interrupt-parent 属性可以用于指定层次结构中的上级中断控制器。</p>
<h3 id="57-1-5-interrupt-cells"><a href="#57-1-5-interrupt-cells" class="headerlink" title="57.1.5 #interrupt-cells"></a>57.1.5 #interrupt-cells</h3><p>#interrupt-cells属性用于描述中断控制器中每个中断信号源的中断编号单元的数量。中断编号单元是指用于表示中断号和其他相关信息的固定大小的单元。通过指定中断编号单元的数量，操作系统可以正确解析和处理中断信息，并将其与中断控制器和中断信号源进行关联。<br>    #interrupt-cells属性的值是一个整数，表示中断编号单元的数量。通常，这个值是一个正整数，例如 1、2 或 3，取决于中断控制器和设备的要求。</p>
<p>在gpio0的中断控制器为gic，在gic节点中#interrupt-cells属性被设置为3，这也就是为什么在gpio0节点中interrupts 属性有三个值，而ft5x06的中断控制器为gpio0，在gpio0节点中#interrupt-cells属性被设置为2，所以ft5x06节点的interrupts 属性只有两个值。</p>
<h2 id="57-2-中断实例编写"><a href="#57-2-中断实例编写" class="headerlink" title="57.2 中断实例编写"></a>57.2 中断实例编写</h2><p>在上一个小节中对设备树中断要用到的属性进行了讲解，而在本小节将会编写一个在RK3568上的ft5x06触摸中断设备树。</p>
<p>首先确定ft5x06的中断引脚号，由于iTOP-RK3568有1.2和1.7两个版本，所以这里展示了两个版本的原理图：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022380.jpeg" alt="img"> </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022342.jpeg" alt="img"> </p>
<p>第一张图为V1.2版本的原理图，触摸引脚网络标号为TP_INT_L_GPIO0_B5，对应的SOC管脚为GPIO0_B5，第二张图为V1.7版本的原理图，触摸引脚网络标号为TP_INT_L_GPIO3_A5，对应的SOC管脚为GPIO3_A5。</p>
<p>然后来查看内核源码目录下的“drivers&#x2F;input&#x2F;touchscreen&#x2F;edt-ft5x06.c”文件，这是ft5x06的驱动文件，找到compatible匹配值相关的部分，如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022325.jpeg" alt="img"> </p>
<p>这里的compatible匹配值都可以选择，作者选择的是edt,edt-ft5206，选择其他compatible也是可以的。</p>
<p>在内核源码目录下的“include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h”头文件中，定义了RK引脚名和gpio编号的宏定义，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022294.jpeg" alt="img"> </p>
<p>可以看到RK已经将GPIO组和引脚编号写成了宏定义的形式，通过宏定义可以减少在编写设备树的过程中换算的时间，并且帮助大家进行理解。</p>
<p>至此，关于编写ft5x06设备树的前置内容就查找完成了，接下来进行设备树的编写。</p>
<p>  编写完成的设备树如下所示：</p>
<p><strong>V1.2：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/pinctrl/rockchip.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/interrupt-controller/irq.h&quot;</span></span></span><br><span class="line">/&#123;</span><br><span class="line">	model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line"></span><br><span class="line">	ft5x06@<span class="number">38</span> &#123;</span><br><span class="line">		compatible = <span class="string">&quot;edt,edt-ft5206&quot;</span>;</span><br><span class="line">		interrupt-parent = &lt;&amp;gpio0&gt;;</span><br><span class="line">		interrupts = &lt;RK_PB5 IRQ_TYPE_EDGE_RISING&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>V1.7：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/pinctrl/rockchip.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/interrupt-controller/irq.h&quot;</span></span></span><br><span class="line">/&#123;</span><br><span class="line">	model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line"></span><br><span class="line">	ft5x06@<span class="number">38</span> &#123;</span><br><span class="line">		compatible = <span class="string">&quot;edt,edt-ft5206&quot;</span>;</span><br><span class="line">		interrupt-parent = &lt;&amp;gpio3&gt;;</span><br><span class="line">		interrupts = &lt;RK_PA5 IRQ_TYPE_EDGE_RISING&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第1行: 设备树文件的头部，指定了使用的设备树语法版本。</p>
<p>第3行：用于定义 Rockchip 平台的引脚控制器相关的绑定。</p>
<p>第4行：用于定义中断控制器相关的绑定。</p>
<p>第5行：表示设备树的根节点开始。</p>
<p>第6行：指定了设备树的模型名称，描述为 “This is my devicetree!”。</p>
<p>第9行：指定了设备节点的兼容性字符串，表示该设备与 “edt,edt-ft5206” 兼容。</p>
<p>第10行：指定了中断的父节点，即中断控制器所在的节点。这里使用了一个引用（&amp;gpio0）来表示父节点。</p>
<p>第11行：指定了中断信号的配置。RK_PB5 表示中断信号的引脚编号，IRQ_TYPE_EDGE_RISING 表示中断类型为上升沿触发。</p>
<p>至此，关于ft5x06的设备树就讲解完成了。</p>
<h2 id="57-3-其他SOC设备树对比"><a href="#57-3-其他SOC设备树对比" class="headerlink" title="57.3 其他SOC设备树对比"></a>57.3 其他SOC设备树对比</h2><p>而无论使用的是瑞芯微SOC还是恩智浦、三星的SOC，在设备树关于中断相关的描述都离不开上面提到的四个属性，关于在恩智浦和三星源码中的ft5x06设备树如下所示：</p>
<p><strong>恩智浦：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio1: gpio@<span class="number">0209</span>c000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;fsl,inx6ul-gpio&quot;</span>, <span class="string">&quot;fsl,imx35-gpio&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0209c000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">66</span> IRQ_TYPE_LEVEL_HIGH&gt;, &lt;GIC_SPI <span class="number">67</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    edt-ft5x06@<span class="number">38</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;edt,edt-ft5306&quot;</span>, <span class="string">&quot;edt,edt-ft5x06&quot;</span>, <span class="string">&quot;edt,edt-ft5406&quot;</span>;</span><br><span class="line">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        pinctrl<span class="number">-0</span> = &lt;&amp;ts_int_pin &amp;ts_reset_pin&gt;;</span><br><span class="line">        reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">        interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">        interrupts = &lt;<span class="number">9</span> <span class="number">0</span>&gt;;</span><br><span class="line">        reset-gpios = &lt;&amp;gpio5 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">        irq-gpios = &lt;&amp;gpio1 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>三星：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio_c: gpioc &#123;</span><br><span class="line">    compatible = <span class="string">&quot;gpio-controller&quot;</span>;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06038 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;edt,edt-ft5406&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(RGB_1024x600) || defined(RGB_800x480)</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;tsc2007_irq&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio_c&gt;;</span><br><span class="line">    interrupts = &lt;<span class="number">26</span> IRQ_TYPE_EDGE_FALLING&gt;;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(LvDs_800×1280) || defined(LvDS_1024x768)</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;gt911_irq&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio_b&gt;;</span><br><span class="line">    interrupts = &lt;<span class="number">29</span> IRQ_TYPE_EDGE_FALLING&gt;;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    reset-gpios = &lt;&amp;gpio_e <span class="number">30</span> <span class="number">0</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对比之后会发现，不同厂商对于中断属性的配置都是类似的，只是里面的参数有些许区别，如果大家在之后遇到了其他平台，只需要稍加区分即可。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-56-设备树基本语法</title>
    <url>/2023/09/05/1-56-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第56章-设备树基本语法"><a href="#第56章-设备树基本语法" class="headerlink" title="第56章 设备树基本语法"></a>第56章 设备树基本语法</h1><h2 id="56-1设备树语法讲解1"><a href="#56-1设备树语法讲解1" class="headerlink" title="56.1设备树语法讲解1"></a>56.1设备树语法讲解1</h2><h3 id="56-1-1-根节点"><a href="#56-1-1-根节点" class="headerlink" title="56.1.1 根节点"></a>56.1.1 根节点</h3><p>设备树使用一种层次结构，其中的根节点（Root Node）是整个设备树的起始点和顶层节点。根节点由一个以&#x2F;开头的标识符来表示，然后使用{}来包含根节点所在的内容，一个最简单的根节点示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;  <span class="comment">// 设备树版本信息</span></span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    <span class="comment">// 根节点开始</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在这里可以添加注释，描述根节点的属性和配置</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中第一行的设备树中的版本信息行 dts-v1 是可选的，可以根据需要选择是否保留。这行注释通常用于指定设备树的语法版本。如果您不需要在设备树中指定版本信息，可以将其删除。</p>
<h3 id="56-1-2-子节点"><a href="#56-1-2-子节点" class="headerlink" title="56.1.2 子节点"></a>56.1.2 子节点</h3><p>设备树中的子节点是根节点的直接子项，用于描述具体的硬件设备或设备集合。子节点采用以下特定的格式来表示:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[label:] node-name@[unit-address] &#123;</span><br><span class="line">	[properties definitions]</span><br><span class="line">	[child nodes]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下是对这些部分的详细介绍：</p>
<p>（1）节点标签（Label）（可选）：节点标签是一个可选的标识符，用于在设备树中引用该节点。标签允许其他节点直接引用此节点，以便在设备树中建立引用关系。</p>
<p>（2）节点名称（Node Name）：节点名称是一个字符串，用于唯一标识该节点在设备树中的位置。节点名称通常是硬件设备的名称，但必须在设备树中是唯一的。</p>
<p>（3）单元地址（Unit Address）（可选）：单元地址用于标识设备的实例。它可以是一个整数、一个十六进制值或一个字符串，具体取决于设备的要求。单元地址的目的是区分相同类型的设备的不同实例，例如在下图中名为 cpu 的节点通过它们的单元地址值 0 和 1 来区分，名称为 ethernet 的节点通过其单元地址值 fe002000 和 fe003000 来区分。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022002.jpeg" alt="img"> </p>
<p>（4）属性定义（Properties Definitions）：属性定义是一组键值对，用于描述设备的配置和特性。属性可以根据设备的需求进行定义，例如寄存器地址、中断号、时钟频率等，关于这些属性会在后面的小节中进行讲解</p>
<p>（5）子节点（Child Nodes）：子节点是当前节点的子项，用于进一步描述硬件设备的子组件或配置。子节点可以包含自己的属性定义和更深层次的子节点，形成设备树的层次结构。</p>
<h3 id="56-1-3-reg属性"><a href="#56-1-3-reg属性" class="headerlink" title="56.1.3 reg属性"></a>56.1.3 reg属性</h3><p>reg 属性用于在设备树中指定设备的寄存器地址和大小，提供了与设备树中的物理设备之间的寄存器映射关系。</p>
<p>reg 属性可以在设备节点中有单个值格式和列表值格式这两种常见格式，接下来将对这两种格式进行介绍：</p>
<p>（1）单个值格式如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">reg = &lt;address size&gt;;</span><br></pre></td></tr></table></figure>

<p>这种格式适用于描述单个寄存器的情况。其中，address 是设备的起始寄存器地址，可以是一个整数或十六进制值。size 表示寄存器的大小，即占用的字节数。</p>
<p>例如，假设有一个设备节点 my_device，使用单个值格式的 reg 属性来描述一个 4 字节寄存器的地址和大小，可以这样定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;vendor,device&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x1000</span> <span class="number">0x4</span>&gt;;</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>my_device</code> 设备节点的 <code>reg</code> 属性值为 <code>&lt;0x1000 0x4&gt;</code>，表示从地址 <code>0x1000</code> 开始的 4 字节寄存器区域。</p>
<p>（2）列表值格式如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">reg = &lt;address1 size1 address2 size2 ...&gt;;</span><br></pre></td></tr></table></figure>

<p>当设备具有多个寄存器区域时，可以使用列表值格式的 reg 属性来描述每个寄存器区域的地址和大小。通过这种方式，可以指定多个寄存器的位置和大小，以描述设备的完整寄存器映射。</p>
<p>例如，考虑一个设备节点 my_device，它具有两个寄存器区域，分别是 8 字节和 4 字节大小的寄存器。可以使用列表值格式的 reg 属性来描述这种情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;vendor,device&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x1000</span> <span class="number">0x8</span> <span class="number">0x2000</span> <span class="number">0x4</span>&gt;;</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，my_device 设备节点的 reg 属性值为 &lt;0x1000 0x8 0x2000 0x4&gt;，表示设备有两个寄存器区域。第一个寄存器区域从地址 0x1000 开始，大小为 8 字节；第二个寄存器区域从地址 0x2000 开始，大小为 4 字节。</p>
<p>通过使用 reg 属性，设备树可以提供有关设备寄存器布局和寄存器访问方式的信息。这对于操作系统的设备驱动程序很重要，因为它们需要了解设备的寄存器映射以正确地与设备进行交互和配置。</p>
<h3 id="56-1-4-address-cell和size-cells"><a href="#56-1-4-address-cell和size-cells" class="headerlink" title="56.1.4 address-cell和size-cells"></a>56.1.4 address-cell和size-cells</h3><p>#address-cells 和 #size-cells 属性用于指定在上个小节中要设置的设备树中地址单元和大小单元的位数。它们提供了设备树解析所需的元数据，以正确解释设备的地址和大小信息。下面对两个属性分别进行介绍：</p>
<p><strong>(1)#address-cells属性</strong></p>
<p>#address-cells 属性是一个位于设备树根节点的特殊属性，它指定了设备树中地址单元的位数。地址单元是设备树中用于表示设备地址的单个单位。它通常是一个整数，可以是十进制或十六进制值。</p>
<p>#address-cells 属性的值告诉解析设备树的软件在解释设备地址时应该使用多少位来表示一个地址单元。</p>
<p>默认情况下，#address-cells 的值为 2，表示使用两个单元来表示一个设备地址。这意味着设备的地址将由两个整数（每个整数使用指定位数的位）组成。</p>
<p>例如，对于一个使用两个 32 位（4字节）整数表示地址的设备，可以在设备树的根节点中设置 #address-cells 属性为 &lt;2&gt;。</p>
<p><strong>(2)#size-cells 属性</strong></p>
<p>#size-cells 属性也是一个位于设备树根节点的特殊属性，它指定了设备树中大小单元的位数。大小单元是设备树中用于表示设备大小的单个单位。它通常是一个整数，可以是十进制或十六进制值。</p>
<p>#size-cells 属性的值告诉解析设备树的软件在解释设备大小时应该使用多少位来表示一个大小单元。</p>
<p>默认情况下，#size-cells 的值为 1，表示使用一个单元来表示一个设备的大小。这意味着设备的大小将由一个整数（使用指定位数的位）表示。</p>
<p>例如，对于一个使用一个 32 位（4 字节）整数表示大小的设备，可以在设备树的根节点中设置 #size-cells 属性为 &lt;1&gt;。</p>
<p>这两个属性的存在是为了使设备树能够灵活地描述各种设备的地址和大小表示方式。通过在设备树的根节点中设置适当的 #address-cells 和 #size-cells 值，设备树解析软件能够正确地解释设备节点中的地址和大小信息。</p>
<p>以下是两个个示例，展示了根节点中 #address-cells 和 #size-cells 属性的使用：</p>
<p><strong>示例1</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">node1 &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    node1-child &#123;</span><br><span class="line">        reg = &lt;<span class="number">0x02200000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">        <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，node1-child 节点的 reg 属性使用了 &lt;0x02200000 0x4000&gt; 表示地址和大小。由于 #address-cells 的值为 &lt;1&gt;，表示使用一个单元来表示地址。#size-cells 的值也为 &lt;1&gt;，表示使用一个单元来表示大小。</p>
<p>解释后的地址和大小值如下：</p>
<p>地址部分：0x02200000 被解释为一个地址单元，地址为 0x02200000。</p>
<p>大小部分：0x4000 被解释为一个大小单元，大小为 0x4000。</p>
<p>示例2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">node1 &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">    node1-child &#123;</span><br><span class="line">        reg = &lt;<span class="number">0x0000</span> <span class="number">0x0001</span>&gt;;</span><br><span class="line">        <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，node1-child 节点的 reg 属性使用了 &lt;0x0000 0x0001&gt; 表示地址。由于 #address-cells 的值为 &lt;2&gt;，表示使用两个单元来表示地址。#size-cells 的值为 &lt;0&gt;，表示不使用单元来表示大小。</p>
<p>解释后的地址值如下：</p>
<p>地址部分：0x0000 0x0001 被解释为两个地址单元，其中第一个地址单元为 0x0000，第二个地址单元为 0x0001。</p>
<p>这种使用 #address-cells 和 #size-cells 属性的方式使得设备树可以适应不同设备的寄存器映射和大小表示方式，并确保设备树解析软件能够正确解释设备的地址和大小信息。</p>
<h3 id="56-1-5-model属性"><a href="#56-1-5-model属性" class="headerlink" title="56.1.5 model属性"></a>56.1.5 model属性</h3><p>在设备树中，model 属性用于描述设备的型号或者名称。它通常作为设备节点的一个属性，用来提供关于设备的标识信息。model 属性是可选的，但在实际应用中经常被使用。</p>
<p>model 属性的值是一个字符串，可以是设备的型号、名称、或者其他标识符，用来识别设备。该值通常由设备的厂商定义，并且在设备树中使用。</p>
<p>以下是一个示例，展示了如何在设备树中使用 model 属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;vendor,device&quot;</span>;</span><br><span class="line">    model = <span class="string">&quot;My Device XYZ&quot;</span>;</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，my_device 节点具有 model 属性，其值为 “My Device XYZ”。这个值描述了设备的型号或名称为 “My Device XYZ”。</p>
<p>model 属性通常用于标识和区分不同的设备，特别是当设备节点的 compatible 属性相同或相似时。通过使用不同的 model 属性值，可以更加准确地确定所使用的设备类型。</p>
<h3 id="56-1-6-status属性"><a href="#56-1-6-status属性" class="headerlink" title="56.1.6 status属性"></a>56.1.6 status属性</h3><p>在设备树中，status 属性用于描述设备或节点的状态。它是设备树中常见的属性之一，用于表示设备或节点的可用性或操作状态。</p>
<p>status 属性的值可以是以下几种：</p>
<p>“okay”：表示设备或节点正常工作，可用。</p>
<p>“disabled”：表示设备或节点被禁用，不可用。</p>
<p>“reserved”：表示设备或节点已被保留，暂时不可用。</p>
<p>“fail”：表示设备或节点初始化或操作失败，不可用。</p>
<p>以下是一个示例，展示了如何在设备树中使用 status 属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;vendor,device&quot;</span>;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，my_device 节点具有 status 属性，其值为 “okay”。这表示设备处于正常工作状态，可用。</p>
<p>通过使用 status 属性，设备树可以动态地控制设备的启用和禁用状态。这对于在系统启动过程中选择性地启用或禁用设备，或者在运行时根据特定条件调整设备状态非常有用。</p>
<h3 id="56-1-7-compatible属性"><a href="#56-1-7-compatible属性" class="headerlink" title="56.1.7 compatible属性"></a>56.1.7 compatible属性</h3><p>在设备树中，compatible 属性用于描述设备的兼容性信息。它是设备树中重要的属性之一，用于识别设备节点与驱动程序之间的匹配关系。</p>
<p>compatible 属性的值是一个字符串或字符串列表，用于指定设备节点与相应的驱动程序或设备描述符兼容的规则。通常，compatible 属性的值由设备的厂商定义，并且在设备树中使用。</p>
<p>以下是一些常见的 compatible 属性值的示例：</p>
<p>（1）单个字符串值：例如 “vendor,device”，用于指定设备节点与特定厂商的特定设备兼容。</p>
<p>（2）字符串列表：例如 [“vendor,device1”, “vendor,device2”]，用于指定设备节点与多个设备兼容，通常用于设备节点具有多种变体或配置。</p>
<p>（3）通配符匹配：例如 “vendor,*”，用于指定设备节点与特定厂商的所有设备兼容，不考虑具体的设备标识。</p>
<p>以下是一个示例，展示了如何在设备树中使用 compatible 属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;vendor,device&quot;</span>;</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，my_device 节点具有 compatible 属性，其值为 “vendor,device”。这个值用于标识设备节点与特定厂商的特定设备兼容。</p>
<p>compatible 属性也可以具有多个匹配值，用于指定设备节点与多个设备或驱动程序的兼容性规则。这种情况下，compatible 属性的值是一个字符串列表，每个字符串表示一个匹配值。</p>
<p>以下是一个示例，展示了具有多个匹配值的 compatible 属性的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = [&quot;vendor,device1&quot;, &quot;vendor,device2&quot;];</span><br><span class="line">    // 其他属性和子节点的定义</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，my_device 节点具有 compatible 属性，其值为 [“vendor,device1”, “vendor,device2”]。这表示设备节点与厂商的 device1 和 device2 兼容。</p>
<p>通过使用 compatible 属性，设备树可以提供设备和驱动程序之间的匹配信息。当设备树被操作系统或设备管理软件解析时，会根据设备节点的 compatible 属性值来选择适合的驱动程序进行设备的初始化和配置。</p>
<h2 id="56-2-设备树语法讲解2"><a href="#56-2-设备树语法讲解2" class="headerlink" title="56.2 设备树语法讲解2"></a>56.2 设备树语法讲解2</h2><h3 id="56-2-1-aliases节点"><a href="#56-2-1-aliases节点" class="headerlink" title="56.2.1 aliases节点"></a>56.2.1 aliases节点</h3><p> aliases 节点是一个特殊的节点，用于定义设备别名。该节点位于设备树的根部，并具有节点路径 &#x2F;aliases。</p>
<p>aliases 节点是一个容器节点，包含一组属性，每个属性都代表一个设备别名。每个属性的名称是别名的标识符，而属性的值是被引用设备节点的路径或设备树中其他节点的路径。</p>
<p>以下是一个示例，演示了如何在设备树中使用 aliases 节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line">    mmc0 = &amp;sdmmc0;</span><br><span class="line">    mmc1 = &amp;sdmmc1;</span><br><span class="line">    mmc2 = &amp;sdhci;</span><br><span class="line">    serial0 = &quot;/simple@fe000000/seria1@11c500&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在给定的例子中，有四个别名的定义：</p>
<p>（1）mmc0 别名与设备树中的 sdmmc0 节点相关联。通过使用别名 mmc0，其他设备节点或客户端程序可以更方便地引用 sdmmc0 节点，而不必直接使用其完整路径。</p>
<p>（2）mmc1 别名与设备树中的 sdmmc1 节点相关联。通过使用别名 mmc1，其他设备节点或客户端程序可以更方便地引用 sdmmc1 节点，而不必直接使用其完整路径。</p>
<p>（3）mmc2 别名与设备树中的 sdhci 节点相关联。通过使用别名 mmc2，其他设备节点或客户端程序可以更方便地引用 sdhci 节点，而不必直接使用其完整路径。</p>
<p>（4）serial0 别名与设备树中的路径 &#x2F;simple@fe000000&#x2F;seria1@11c500 相关联。通过使用别名 serial0，其他设备节点或客户端程序可以更方便地引用该路径，而不必记住整个路径字符串。</p>
<p>在别名的定义中，&amp; 符号用于引用设备树中的节点。别名的目的是提供可读性更高的名称，使设备树更易于理解和维护。通过使用别名，可以简化设备节点之间的关联，并减少重复输入设备节点的路径。</p>
<p>客户端程序可以使用别名属性名称来引用完整的设备路径或部分路径。当客户端程序将别名字符串视为设备路径时，应检测并使用别名。这样，设备树的使用者可以更方便地引用设备节点，而不必记住复杂的路径结构。</p>
<p>需要注意的是，aliases 节点中定义的别名只在设备树内部可见，不能在设备树之外引用。它们主要用于设备树的内部组织和引用，以提高可读性和可维护性。</p>
<h3 id="56-2-2-choose节点"><a href="#56-2-2-choose节点" class="headerlink" title="56.2.2 choose节点"></a>56.2.2 choose节点</h3><p>chosen节点是设备树中的一个特殊节点，用于传递和存储系统引导和配置的相关信息。它位于设备树的根部，并具有路径&#x2F;chosen。</p>
<p>chosen节点通常包含以下子节点和属性：</p>
<p>（1）bootargs：用于存储引导内核时传递的命令行参数。它可以包含诸如内核参数、设备树参数等信息。在引导过程中，操作系统或引导加载程序可以读取该属性来获取启动参数。</p>
<p>（2）stdout-path：用于指定用于标准输出的设备路径。在引导过程中，操作系统可以使用该属性来确定将控制台输出发送到哪个设备，例如串口或显示屏。</p>
<p>（3）firmware-name：用于指定系统固件的名称。它可以用于标识所使用的引导加载程序或固件的类型和版本。</p>
<p>（4）linux,initrd-start和linux,initrd-end：这些属性用于指定Linux内核初始化RAM磁盘（initrd）的起始地址和结束地址。这些信息在引导过程中被引导加载程序使用，以将initrd加载到内存中供内核使用。</p>
<p>（5）其他自定义属性：chosen节点还可以包含其他自定义属性，用于存储特定于系统引导和配置的信息。这些属性的具体含义和用法取决于设备树的使用和上下文。</p>
<p>关于chosen节点的实际例子如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chosen &#123;</span><br><span class="line">    bootargs = &quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0,115200&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，chosen 节点具有一个属性 bootargs，其值为”root&#x3D;&#x2F;dev&#x2F;nfs rw nfsroot&#x3D;192.168.1.1 console&#x3D;ttyS0,115200”。</p>
<p>通过这些命令行参数，操作系统或引导加载程序可以配置内核在引导过程中正确地加载 NFS 根文件系统，并将控制台输出发送到指定的串口设备。</p>
<p>通过使用chosen节点，系统引导过程中的相关信息可以方便地传递给操作系统或引导加载程序。这样，系统引导和配置的各个组件可以共享和访问这些信息，从而实现更灵活和可配置的系统引导流程。chosen节点提供了一种通用的机制，使得不同的设备树和引导系统可以在传递信息方面保持一致性，并且可以根据具体需求扩展和自定义。</p>
<h3 id="56-2-3-device-type节点"><a href="#56-2-3-device-type节点" class="headerlink" title="56.2.3 device_type节点"></a>56.2.3 device_type节点</h3><p>在设备树中，device_type 节点是用于描述设备类型的节点。它通常作为设备节点的一个属性存在。device_type 属性的值是一个字符串，用于标识设备的类型。</p>
<p>device_type 节点的存在有助于操作系统或其他软件识别和处理设备。它提供了设备的基本分类信息，使得驱动程序、设备树解析器或其他系统组件能够根据设备的类型执行相应的操作。</p>
<p>常见的设备类型包括但不限于：</p>
<p>（1）cpu：表示中央处理器。</p>
<p>（2）memory：表示内存设备。</p>
<p>（3）display：表示显示设备，如液晶显示屏。</p>
<p>（4）serial：表示串行通信设备，如串口。</p>
<p>（5）ethernet：表示以太网设备。</p>
<p>（6）usb：表示通用串行总线设备。</p>
<p>（7）i2c：表示使用 I2C (Inter-Integrated Circuit) 总线通信的设备。</p>
<p>（8）spi：表示使用 SPI (Serial Peripheral Interface) 总线通信的设备。</p>
<p>（9）gpio：表示通用输入&#x2F;输出设备。</p>
<p>（10）pwm：表示脉宽调制设备。</p>
<p>这些只是一些常见的设备类型示例，实际上，设备类型可以根据具体的硬件和设备树的使用情况进行自定义和扩展。根据设备类型，操作系统或其他软件可以加载适当的驱动程序、配置设备资源、建立设备之间的连接等。</p>
<h3 id="56-2-4-自定义属性"><a href="#56-2-4-自定义属性" class="headerlink" title="56.2.4 自定义属性"></a>56.2.4 自定义属性</h3><p>设备树中的自定义属性是用户根据特定需求添加的属性。这些属性可以用于提供额外的信息、配置参数或元数据，以满足设备或系统的特定要求。</p>
<p>在设备树中添加自定义属性时，可以在设备节点或其他适当的节点下定义新的属性。自定义属性可以是整数、字符串、布尔值或其他数据类型。它们的命名应遵循设备树的命名约定，并且应该与已有的属性名称避免冲突。</p>
<p>例如可以在设备树中自定义一个管脚标号的属性pinnum，添加好的设备树源码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = &quot;my_device&quot;;</span><br><span class="line">    pinnum = &lt;0 1 2 3 4&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，my_device 是一个自定义设备节点，并添加了一个自定义属性 pinnum。该属性的值 &lt;0 1 2 3 4&gt; 是一个整数数组，表示管脚的标号（PIN number）。</p>
<p>通过这样定义 pinnum 属性，您可以在设备树中为特定设备指定管教标号，以便操作系统、驱动程序或其他软件组件使用。这可以用于在设备初始化或配置过程中对特定管教进行操作或控制。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-55-初识设备树</title>
    <url>/2023/09/05/1-55-%E5%88%9D%E8%AF%86%E8%AE%BE%E5%A4%87%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第55章-初识设备树"><a href="#第55章-初识设备树" class="headerlink" title="第55章 初识设备树"></a>第55章 初识设备树</h1><h2 id="55-1-设备树的由来"><a href="#55-1-设备树的由来" class="headerlink" title="55.1 设备树的由来"></a>55.1 设备树的由来</h2><p>设备树（Device Tree）是一种硬件描述机制，用于在嵌入式系统和操作系统中描述硬件设备的特性、连接关系和配置信息。它提供了一种与平台无关的方式来描述硬件，使得内核与硬件之间的耦合度降低，提高了系统的可移植性和可维护性。</p>
<p>在上一篇平台总线内容的学习中，我们使用platform_device结构体来对硬件设备进行描述，这是一种传统的平台总线设备描述方式。每个platform_device结构表示一个特定的硬件设备，并通过注册到平台总线上来使得内核能够与该设备进行通信和交互。该结构包含设备的名称、资源（如内存地址、中断号等）、设备驱动程序等信息。</p>
<p>然而，随着时间的推移，Linux内核中的ARM部分存在着大量的平台相关配置代码，这些代码通常是杂乱而重复的，导致了维护的困难和工作量的增加。在2011年3月17日，Linux的创始人Linus Torvalds在ARM Linux邮件列表中发表了一封帖子，他表达了对ARM架构配置方式的不满，并宣称”Gaah. Guys, this whole ARM thing is a f*cking pain in the ass”。这引起了广泛的讨论和反思。ARM社区中的开发者们开始认识到，传统的平台相关配置方式已经变得不可持续，需要一种更加先进和可扩展的方法来解决这个问题。</p>
<p>为了应对这一挑战，ARM社区开始探索新的硬件描述机制，并逐渐形成了设备树的概念。设备树提供了一种更加灵活和可移植的描述硬件的机制，将设备的描述信息转移到设备树中。设备树使用一种结构化的数据格式，通过描述设备节点、属性和连接关系等信息，使得硬件的描述与具体的平台无关，同时允许多个平台共享相同的设备树描述。</p>
<p>设备树的引入为ARM架构上的Linux内核带来了革命性的变化。它提供了一种统一的硬件描述方式，使得不同芯片和板级的支持更加简单和灵活。此外，设备树还提供了硬件配置的可视化和可读性，方便开发者理解和调试硬件。</p>
<p>随着时间的推移，设备树逐渐成为了嵌入式系统和Linux内核中描述硬件的标准方式。它不仅在ARM架构上得到了广泛应用，也被扩展到其他架构和平台上。</p>
<h2 id="55-2-设备树基础知识"><a href="#55-2-设备树基础知识" class="headerlink" title="55.2 设备树基础知识"></a>55.2 设备树基础知识</h2><p>当描述设备树（Device Tree）时，通常会涉及到以下几个关键术语：DTS、DTSI、DTB和DTC。下面来对每个术语进行介绍。</p>
<p>DTS（Device Tree Source）：DTS是设备树的源文件，采用一种类似于文本的语法来描述硬件设备的结构、属性和连接关系。DTS文件以.dts为扩展名，通常由开发人员编写。它是人类可读的形式，用于描述设备树的层次结构和属性信息。</p>
<p>DTSI（Device Tree Source Include）：DTSI文件是设备树源文件的包含文件。它扩展了DTS文件的功能，用于定义可重用的设备树片段。DTSI文件以.dtsi为扩展名，可以在多个DTS文件中包含和共享。通过使用DTSI，可以提高设备树的可重用性和可维护性（和C语言中头文件的作用相同）。</p>
<p>DTB（Device Tree Blob）：DTB是设备树的二进制表示形式。DTB文件是通过将DTS或DTSI文件编译而成的二进制文件，以.dtb为扩展名。DTB文件包含了设备树的结构、属性和连接信息，被操作系统加载和解析。在运行时，操作系统使用DTB文件来动态识别和管理硬件设备。</p>
<p>DTC（Device Tree Compiler）：DTC是设备树的编译器。它是一个命令行工具，用于将DTS和DTSI文件编译成DTB文件。DTC将文本格式的设备树源代码转换为二进制的设备树表示形式，以便操作系统能够加载和解析。DTC是设备树开发中一个重要的工具。</p>
<p><strong>DTS、DTSI、DTB和DTC之间的关系：</strong></p>
<p>（1）开发人员使用文本编辑器编写DTS和DTSI文件，描述硬件设备的层次结构、属性和连接关系。</p>
<p>（2）DTSI文件可以在多个DTS文件中包含和共享，以提高设备树的可重用性和可维护性。</p>
<p>（3）使用DTC编译器，开发人员将DTS和DTSI文件编译成二进制的DTB文件，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062021519.jpeg" alt="img"> </p>
<p>操作系统在启动过程中加载和解析DTB文件，以识别和管理硬件设备。</p>
<p>设备树文件存放路径：</p>
<p>ARM体系结构：</p>
<p>ARM体系结构下的设备树源文件通常存放在arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;目录中。该目录是设备树源文件的根目录。如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062021539.jpeg" alt="img"> </p>
<p>ARM64体系结构：</p>
<p>设备树源文件路径：ARM64体系结构下的设备树源文件通常存放在arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;目录及其子目录中。该目录也是设备树源文件的根目录，并包含了针对不同ARM64平台和设备的子目录，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062021441.jpeg" alt="img"> </p>
<p>子目录结构：在ARM64的子目录中，同样会按照硬件平台、设备类型或制造商进行组织和分类。这些子目录的命名可能与特定芯片厂商（如Qualcomm、NVIDIA、Samsung）有关，由于我们本手册使用的soc是瑞芯微的rk3568，所以匹配的设备树目录为arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip。每个子目录中可能包含多个设备树文件，用于描述不同的硬件配置和设备类型，这里以rockchip目录内容如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062021532.jpeg" alt="img"></p>
<h2 id="55-3-设备树的编译"><a href="#55-3-设备树的编译" class="headerlink" title="55.3 设备树的编译"></a>55.3 设备树的编译</h2><p>设备树的编译是将设备树源文件（如上述的.dts文件）转换为二进制的设备树表示形式（.dtb文件）的过程。编译器通常被称为DTC（Device Tree Compiler）。</p>
<p>在Linux内核源码中，DTC（Device Tree Compiler）的源代码和相关工具通常存放在scripts&#x2F;dtc&#x2F;目录中，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062021475.jpeg" alt="img"> </p>
<p>在编译完源码之后dtc设备树编译器会默认生成，如果没有生成相应的dtc可执行文件，可以查看在内核默认配置文件中CONFIG_DTC是否使能。</p>
<p><strong>设备树的编译</strong>：</p>
<p>在Linux环境中，可以使用以下命令将设备树源文件编译为二进制设备树文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dtc -I dts -O dtb -o output.dtb input.dts</span><br></pre></td></tr></table></figure>

<p>其中，<code>input.dts</code>是输入的设备树源文件，<code>output.dtb</code>是编译后的二进制设备树文件。</p>
<p>编译器会验证设备树源文件的语法和语义，生成与硬件描述相对应的设备树表示形式。</p>
<p><strong>设备树的反编译：</strong></p>
<p>​	设备树的反编译是将二进制设备树文件转换回设备树源文件的过程，以便进行查看、编辑或修改。反编译器通常也是DTC。</p>
<p>在Linux环境中，可以使用以下命令将二进制设备树文件反编译为设备树源文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dtc -I dtb -O dts -o output.dts input.dtb</span><br></pre></td></tr></table></figure>

<p>其中，input.dtb是输入的二进制设备树文件，output.dts是反编译后的设备树源文件。</p>
<p>反编译器会将二进制设备树文件解析并还原为文本形式的设备树源文件，使其可读性更好。</p>
<p>下面来进行一下实际的设备树编译和反编译的演示，首先创建一个名为test.dts的设备树文件，文件内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">/ &#123;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建完成如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062021504.jpeg" alt="img"> </p>
<p>这个设备树很简单，只包含了根节点&#x2F;，而根节点中没有任何子节点或属性。这个示例并没有描述任何具体的硬件设备或连接关系，它只是一个最基本的设备树框架，在本小节只是为了测试设备树的编译和反编译。</p>
<p>然后使用以下命令进行设备树的编译，编译完成如下图所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/topeet/Linux/linux_sdk/kernel/scripts/dtc/dtc -I dts -O dtb -o test.dtb test.dts</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062021796.jpeg" alt="img"> </p>
<p>可以看到test.dtb就生成了，然后继续使用以下命令对test.dtb进行反编译，反编译完成如下图所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/topeet/Linux/linux_sdk/kernel/scripts/dtc/dtc -I dtb -O dts -o 1.dts test.dtb </span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062021902.jpeg" alt="img"> </p>
<p>可以看到反编译出的1.dts跟之前的test.dts内容相同。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-54-点亮LED灯实验（平台总线)</title>
    <url>/2023/09/05/1-54-%E7%82%B9%E4%BA%AELED%E7%81%AF%E5%AE%9E%E9%AA%8C%EF%BC%88%E5%B9%B3%E5%8F%B0%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-53-probe函数编写实验</title>
    <url>/2023/09/05/1-53-probe%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-52-注册platform驱动实验</title>
    <url>/2023/09/05/1-52-%E6%B3%A8%E5%86%8Cplatform%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-51-注册platform设备实验</title>
    <url>/2023/09/05/1-51-%E6%B3%A8%E5%86%8Cplatform%E8%AE%BE%E5%A4%87%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-50-平台总线模型介绍</title>
    <url>/2023/09/05/1-50-%E5%B9%B3%E5%8F%B0%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-49-中断线程化实验</title>
    <url>/2023/09/05/1-49-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-48-并发管理工作队列实验</title>
    <url>/2023/09/05/1-48-%E5%B9%B6%E5%8F%91%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-47-工作队列传参实验</title>
    <url>/2023/09/05/1-47-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E4%BC%A0%E5%8F%82%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-46-延迟工作实验</title>
    <url>/2023/09/05/1-46-%E5%BB%B6%E8%BF%9F%E5%B7%A5%E4%BD%9C%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-45-自定义工作队列实验</title>
    <url>/2023/09/05/1-45-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-44-共享工作队列实验</title>
    <url>/2023/09/05/1-44-%E5%85%B1%E4%BA%AB%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-43-特殊的软中断tasklet分析实验</title>
    <url>/2023/09/05/1-43-%E7%89%B9%E6%AE%8A%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%ADtasklet%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-42-软中断实验</title>
    <url>/2023/09/05/1-42-%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-41-中断下文tasklet实验</title>
    <url>/2023/09/05/1-41-%E4%B8%AD%E6%96%AD%E4%B8%8B%E6%96%87tasklet%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-40-中断申请流程</title>
    <url>/2023/09/05/1-40-%E4%B8%AD%E6%96%AD%E7%94%B3%E8%AF%B7%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-39-中断实验</title>
    <url>/2023/09/05/1-39-%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-38-驱动调试方法实验</title>
    <url>/2023/09/05/1-38-%E9%A9%B1%E5%8A%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-37-优化驱动稳定性和效率实验</title>
    <url>/2023/09/05/1-37-%E4%BC%98%E5%8C%96%E9%A9%B1%E5%8A%A8%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%92%8C%E6%95%88%E7%8E%87%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-36-封装驱动API接口实验</title>
    <url>/2023/09/05/1-36-%E5%B0%81%E8%A3%85%E9%A9%B1%E5%8A%A8API%E6%8E%A5%E5%8F%A3%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-35-IOCTL地址传参实验</title>
    <url>/2023/09/05/1-35-IOCTL%E5%9C%B0%E5%9D%80%E4%BC%A0%E5%8F%82%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-34-IOCTL驱动传参实验</title>
    <url>/2023/09/05/1-34-IOCTL%E9%A9%B1%E5%8A%A8%E4%BC%A0%E5%8F%82%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-33-llseek定位设备驱动实验</title>
    <url>/2023/09/05/1-33-llseek%E5%AE%9A%E4%BD%8D%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-31-秒字符设备驱动实验</title>
    <url>/2023/09/05/1-31-%E7%A7%92%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-30-定时器实验</title>
    <url>/2023/09/05/1-30-%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-29-信号驱动IO实验</title>
    <url>/2023/09/05/1-29-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-28-IO多路复用实验</title>
    <url>/2023/09/05/1-28-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-27-非阻塞IO实验</title>
    <url>/2023/09/05/1-27-%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-26-阻塞IO实验</title>
    <url>/2023/09/05/1-26-%E9%98%BB%E5%A1%9EIO%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-25-IO模型引入实验</title>
    <url>/2023/09/05/1-25-IO%E6%A8%A1%E5%9E%8B%E5%BC%95%E5%85%A5%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-24-互斥锁实验</title>
    <url>/2023/09/05/1-24-%E4%BA%92%E6%96%A5%E9%94%81%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-23-信号量实验</title>
    <url>/2023/09/05/1-23-%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-22-自旋锁死锁实验</title>
    <url>/2023/09/05/1-22-%E8%87%AA%E6%97%8B%E9%94%81%E6%AD%BB%E9%94%81%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-21-自旋锁实验</title>
    <url>/2023/09/05/1-21-%E8%87%AA%E6%97%8B%E9%94%81%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-20-原子操作实验</title>
    <url>/2023/09/05/1-20-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-19-并发与竞争实验</title>
    <url>/2023/09/05/1-19-%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-1-前言</title>
    <url>/2023/09/05/1-1-%E5%89%8D%E8%A8%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>磨刀不误砍柴工！在学习驱动之前先和同学们交流下学习方法和学习态度。</p>
<h1 id="1-1-学习方法"><a href="#1-1-学习方法" class="headerlink" title="1.1 学习方法"></a>1.1 学习方法</h1><p>在学习驱动的过程中，同学们难免会遇到很多问题，例如编译环境的问题造成内核编译不通过、交叉编译器或者架构类型没有设置导致驱动编译失败、内核版本和驱动版本不统一造成驱动加载不成功等多种问题。</p>
<p>在遇到问题的时候，同学们一定不要灰心，要敢于去尝试用自己的思路去解决问题。机遇与挑战往往是并存的。当同学们解决一个问题以后，自然就会前进一步。水滴石穿，才可以真正掌握linux驱动。</p>
<p> 所以一定要养成独立思考的好习惯！遇到问题之后，同学们可以先自己根据问题的具体表现，来找到问题的源头，仔细分析问题产生的原因和解决的方法，自主思考无果之后可以尝试去谷歌、百度、CSDN等各大检索网站上寻求帮助，Linux已经发展了很多年，前辈们在之前进行了无数的探索，总有许多类似的经验，能解决绝大多数的问题。</p>
<p>并且在学习过程中千万不要好高骛远，比如对于一些有基础的同学来说，学习过相似的知识点就一目十行甚至直接跳过，这种行为是不可取的，学习一遍和学习两遍的知识点，在认知和运用程度上是完全不一样的。读书要从薄到厚,再厚到薄，学习亦是如此。</p>
<p>端正学习态度后还要有一个好的学习方法，迅为公司在多年培训和产品开发中总结出来了一套适合初学者的学习方式，具体含义解释为框架化学习，快速原型。运用到嵌入式Linux驱动学习上就是从一开始先看到Linux驱动知识领域的外貌，然后逐渐深入！以了解北京这座城市为例，如果在胡同里转来转去，可能几年都搞不清楚这个城市是什么情况，但是如果先通过北京地图学习一下，了解天安门在什么地方，鸟巢在什么地方，香山八达岭在哪里，然后到这些地方看一看，可能很快就能掌握这座城市的全貌。所以运用框架学习法，在对不同层次的框架进行学习过程中，逐渐了解和掌握整个系统。 如果不注意方法，每天在胡同里面来回转悠，肯定是事倍功半，很长时间将不得要领。</p>
<p>需要注意的是，即便有了地图，也需要一些基础，比如知道什么是天安门，知道鸟巢的来历，明白八达岭是怎么回事，实际上这些就是基础知识。也就是说在学习系统框架之前要具备一定的基础，否则这张地图也是看不懂的。学习驱动知识也是需要一定的基础的，所以驱动学习是有门槛的！</p>
<p>对于学习方法和学习态度就先说这样多，关于基础方面，下一节会专门讨论。 </p>
<h1 id="1-2-基础准备"><a href="#1-2-基础准备" class="headerlink" title="1.2 基础准备"></a>1.2 基础准备</h1><p>首先，不要脱离硬件。就好比用仿真软件学习51单片机是永远掌握不了单片机的精髓的。所以有一块硬件开发板是学习驱动的前提。</p>
<p>第二，有了开发板之后，要掌握开发板的基本操作。如开发板的启动，烧写镜像等操作。</p>
<p>第三，能够成功编译开发板的系统源码。在驱动的学习过程中，是避免不了的要对内核的某些功能进行使能、修改设备树添加对应的设备，这些操作都需要进行源码编译。</p>
<p>第四，掌握C语言。驱动程序是由C语言编写的，而且内核源码中绝大多数的代码也都是由C语言编写的，在学习驱动的过程中，或多或少的要对源码进行阅读。所以C语言基础是学习驱动的必要条件之一。</p>
<p>第五，掌握Linux环境搭建以及shell命令的使用。</p>
<p>第六，驱动最后必然要落实到相应的硬件上，所以肯定要对底层电路有所了解，以驱动LED灯为例，必然要了解其控制电路，找到相应的控制引脚，要能读懂简单的硬件原理图。</p>
<p>【最新驱动资料（文档+例程）】</p>
<p>链接 <a href="https://pan.baidu.com/s/1M4smUG2vw_hnn0Hye-tkog">https://pan.baidu.com/s/1M4smUG2vw_hnn0Hye-tkog</a></p>
<p>提取码：hbh6</p>
<p>【B 站配套视频】</p>
<p><a href="https://b23.tv/XqYa6Hm">https://b23.tv/XqYa6Hm</a></p>
<p>【RK3568 购买链接】</p>
<p><a href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-2245">https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-2245</a></p>
<p>2452613.11.2fec74a6elWNeA&amp;id&#x3D;669939423234</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-18-点亮LED灯实验</title>
    <url>/2023/09/05/1-18-%E7%82%B9%E4%BA%AELED%E7%81%AF%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-17-Linux错误处理实验</title>
    <url>/2023/09/05/1-17-Linux%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-16-一个驱动兼容不同设备实验</title>
    <url>/2023/09/05/1-16-%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E5%85%BC%E5%AE%B9%E4%B8%8D%E5%90%8C%E8%AE%BE%E5%A4%87%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-15-文件私有数据实验</title>
    <url>/2023/09/05/1-15-%E6%96%87%E4%BB%B6%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-14-内核空间与用户空间数据交互实验</title>
    <url>/2023/09/05/1-14-%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-13-杂项设备驱动实验</title>
    <url>/2023/09/05/1-13-%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-12-字符设备驱动框架实验</title>
    <url>/2023/09/05/1-12-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-11-创建设备节点实验</title>
    <url>/2023/09/05/1-11-%E5%88%9B%E5%BB%BA%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-10-注册字符设备实验</title>
    <url>/2023/09/05/1-10-%E6%B3%A8%E5%86%8C%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-9-申请字符设备号实验</title>
    <url>/2023/09/05/1-9-%E7%94%B3%E8%AF%B7%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%8F%B7%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-8-驱动模块编译进内核实验</title>
    <url>/2023/09/05/1-8-%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E8%BF%9B%E5%86%85%E6%A0%B8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-7-menuconfig图形化配置实验</title>
    <url>/2023/09/05/1-7-menuconfig%E5%9B%BE%E5%BD%A2%E5%8C%96%E9%85%8D%E7%BD%AE%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-6-内核模块符号导出实验</title>
    <url>/2023/09/05/1-6-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%AC%A6%E5%8F%B7%E5%AF%BC%E5%87%BA%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在上一小节中，给大家讲解了驱动模块传参实验，使用insmod命令加载驱动时可以进行参数的传递，但是每一个内核模块之间是相互独立的，那模块间的符号传递要怎样进行呢，让我们带着疑问来进行本章节的学习吧！</p>
<h2 id="6-1-内核模块符号导出简介"><a href="#6-1-内核模块符号导出简介" class="headerlink" title="6.1 内核模块符号导出简介"></a>6.1 内核模块符号导出简介</h2><p>驱动程序编译生成的ko文件是相互独立的，即模块之间变量或者函数在正常情况下无法进行互相访问。而一些复杂的驱动模块需要分层进行设计，这时候就需要用到内核模块符号导出。</p>
<p>内核符号导出指的是在内核模块中导出相应的函数和变量，在加载模块时被记录在公共内核符号表中，以供其他模块调用。符号导出所使用的宏为EXPORT_SYMBOL(sym)和EXPORT_SYMBOL_GPL(sym)。它们定义在 “内核源码&#x2F;include&#x2F;linux&#x2F;export.h”文件中（在module.h文件中已经对export.h进行引用，所以不需要单独引用export.h文件）,详细定义如下（图6-1）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT_SYMBOL(sym)                  \</span></span><br><span class="line"><span class="meta">__EXPORT_SYMBOL(sym, <span class="string">&quot;&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT_SYMBOL_GPL(sym)                  \</span></span><br><span class="line"><span class="meta">    __EXPORT_SYMBOL(sym, <span class="string">&quot;_gpl&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<p>EXPORT_SYMBOL(sym)和EXPORT_SYMBOL_GPL(sym)两个宏使用方法相同，而EXPORT_SYMBOL_GPL(sym)导出的模块只能被 GPL 许可的模块使用，所以绝大多数的情况都使用EXPORT_SYMBOL(sym)进行符号导出。sym为函数的唯一参数，表示要导出的函数或变量名称。</p>
<p>至此，关于内核模块符号导出函数就讲解完成了，在下一小节中将会编写两个驱动代码来进行内核模块符号导出实验。</p>
<h2 id="6-2-实验程序的编写"><a href="#6-2-实验程序的编写" class="headerlink" title="6.2 实验程序的编写"></a>6.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\03。</p>
<p>本章实验将编写Linux下的内核模块符号导出实例代码，总共有两个驱动程序，第一个驱动文件名为mathmodule.c，用来定义参数num和函数add(a,b)，第二个驱动文件名为hello.c,会引用mathmodule.c驱动程序中的参数num和数学函数add(a,b)，并将相应的参数值和函数返回值打印到串口终端上。</p>
<p>编写完成的mathmodule.c代码如下（图6-2）所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;<span class="comment">//定义参数num</span></span><br><span class="line">EXPORT_SYMBOL(num);<span class="comment">//导出参数num</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//定义数学函数add()，用来实现加法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(add);<span class="comment">//导出数学函数add()</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">math_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;math_moudle init\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">math_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;math_module exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(math_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(math_exit);<span class="comment">//注册出口函数</span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);<span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>图6-2</p>
<p>以上代码定义了一个int类型的num变量和add()数学函数，并使用EXPORT_SYMBOL宏进行导出。</p>
<p>编写完成的hello.c代码如下（图6-3）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> num;<span class="comment">//导入int类型变量num</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;<span class="comment">//导入函数add</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> sum;</span><br><span class="line">    printk(<span class="string">&quot;num = %d\n&quot;</span>, num);<span class="comment">//打印num值</span></span><br><span class="line">    sum = add(<span class="number">3</span>, <span class="number">4</span>);<span class="comment">//使用add函数进行3+4的运算                                                                                                                                                                          </span></span><br><span class="line">    printk(<span class="string">&quot;sum = %d\n&quot;</span>, sum);<span class="comment">//打印add函数的运算值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;Goodbye hello module\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(hello_exit);<span class="comment">//注册出口函数</span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);<span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>图6-3</p>
<p>程序导入了int类型的变量num和add()函数，并在驱动入口函数中打印相应了num的参数值并对add()函数进行了调用。</p>
<p>至此两个驱动代码就编写完成了，代码较为简单，实现了内核模块符号的导出和导出符号的使用，具体的驱动加载运行测试会在下个小节进行。</p>
<h2 id="6-3-运行测试"><a href="#6-3-运行测试" class="headerlink" title="6.3 运行测试"></a>6.3 运行测试</h2><h3 id="6-3-1-编译驱动程序"><a href="#6-3-1-编译驱动程序" class="headerlink" title="6.3.1 编译驱动程序"></a>6.3.1 编译驱动程序</h3><p>在mathmodule.c和hello.c的同一目录下创建Makefile文件，Makefile文件内容如下（图6-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m := mathmodule.o</span><br><span class="line">obj-m += hello.o</span><br><span class="line"></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>图6-4</p>
<p>对于Makefile的内容注释已在上图进行添加，这里要注意的是在hello.c代码中使用了mathmodule.c所导出的符号，所以mathmodule.c要在hello.c之前进行编译，即第3行和第4行顺序不能交换。保存退出之后，来到相应的文件目录下，如下图（图6-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072017830.jpeg" alt="img"> </p>
<p>图6-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图6-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072017874.jpeg" alt="img"> </p>
<p>图6-6</p>
<p>编译完后会生成hello.ko和mathmodule.ko目标文件，如下图（图6-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072017866.jpeg" alt="img"> </p>
<p>图6-7</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的加载运行测试。</p>
<h3 id="6-3-2-运行测试"><a href="#6-3-2-运行测试" class="headerlink" title="6.3.2 运行测试"></a>6.3.2 运行测试</h3><p>这里要注意的是，由于 hello.ko依赖于mathmodule.ko，所以mathmodule.ko需要先加载，分别使用以下命令进行模块的加载（加载顺序不能变），如下（图6-8）所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">insmod mathmodule.ko</span><br><span class="line"></span><br><span class="line">insmod  hello.ko</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072017870.jpeg" alt="img"> </p>
<p>图6-8</p>
<p>可以看到 hello.ko驱动加载的时候，mathmodule.ko模块中定义的num参数值和调用sum()函数的后正确的返回值都被打印了出来。至此内核模块符号导出实验就完成了。</p>
<p>最后可以输入以下命令进行驱动的卸载，如下图（图6-9）所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmmod  hello.ko</span><br><span class="line"></span><br><span class="line">rmmod mathmodule.ko</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072017791.jpeg" alt="img"> </p>
<p>图6-9</p>
<p>注意：由于hello.ko文件使用了mathmodule.ko导出的符号，所以要先卸载hello.ko，卸载完成之后再卸载mathmodule.ko。</p>
<p>【最新驱动资料（文档+例程）】</p>
<p>链接 <a href="https://pan.baidu.com/s/1M4smUG2vw_hnn0Hye-tkog">https://pan.baidu.com/s/1M4smUG2vw_hnn0Hye-tkog</a></p>
<p>提取码：hbh6</p>
<p>【B 站配套视频】</p>
<p><a href="https://b23.tv/XqYa6Hm">https://b23.tv/XqYa6Hm</a></p>
<p>【RK3568 购买链接】</p>
<p><a href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-2245">https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-2245</a></p>
<p>2452613.11.2fec74a6elWNeA&amp;id&#x3D;669939423234</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-5-驱动模块传参实验</title>
    <url>/2023/09/05/1-5-%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E4%BC%A0%E5%8F%82%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>经过前两章实验的实战操作，我们已经完成最简单的helloworld驱动实验和模块驱动实验，加载模块可以使用“insmod”函数，使用“insmod”函数进行模块加载时也能进行参数的传递。运用得当可以极大提升内核测试速度。本节就来学习一下如何进行驱动模块的传参。</p>
<h2 id="5-1-驱动模块传参简介"><a href="#5-1-驱动模块传参简介" class="headerlink" title="5.1 驱动模块传参简介"></a>5.1 驱动模块传参简介</h2><p> 驱动模块传参是一种可以随时向内核模块传递、修改参数的方法。例如可以传递串口驱动的波特率、数据位数、校验位、停止位等参数，进行功能的设置，以此节省编译模块的时间，大大提高调试速度。</p>
<p> Linux内核提供了 module_param(name, type, perm)、module_param_array(name, type, nump, perm)宏和module_param_string(name, string, len, perm)宏，分别进行基本类型、数组和字符串参数的传递。它们定义在 “内核源码&#x2F;include&#x2F;linux&#x2F;moduleparam.h”文件中(在module.h文件中已经对export.h进行引用，所以不需要单独引用moduleparam.h文件),详细定义如下（图5-1）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> module_param(name, type, perm)              \</span></span><br><span class="line"><span class="meta">    module_param_named(name, name, type, perm)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_param_array(name, type, nump, perm)      \</span></span><br><span class="line"><span class="meta">module_param_array_named(name, name, type, nump, perm)  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_param_string(name, string, len, perm)            \</span></span><br><span class="line"><span class="meta">    static const struct kparam_string __param_string_##name     \                                                                                                                                                                                           </span></span><br><span class="line">        = &#123; len, <span class="built_in">string</span> &#125;;                  \</span><br><span class="line">    __module_param_call(MODULE_PARAM_PREFIX, name,          \</span><br><span class="line">                &amp;param_ops_string,              \</span><br><span class="line">                .str = &amp;__param_string_#<span class="meta">#name, perm, -1, 0);\</span></span><br><span class="line"><span class="meta">    __MODULE_PARM_TYPE(name, <span class="string">&quot;string&quot;</span>) </span></span><br></pre></td></tr></table></figure>

<p>图5-1</p>
<p>以上宏定义中的 module_param ()函数可以用来进行基本类型参数的传递，传入的三个参数定义如下：</p>
<ul>
<li>name：模块参数的名称</li>
<li>type： 模块参数的数据类型</li>
<li>perm： 模块参数的访问权限</li>
</ul>
<p>参数type可以取以下任意一种情况：</p>
<ul>
<li>bool <strong>:</strong> 布尔型</li>
<li>inbool <strong>:</strong> 布尔反值</li>
<li>charp**:** 字符指针（相当于char *,不超过1024字节的字符串）</li>
<li>short**:** 短整型</li>
<li>ushort <strong>:</strong> 无符号短整型</li>
<li>int <strong>:</strong> 整型</li>
<li>uint <strong>:</strong> 无符号整型</li>
<li>long <strong>:</strong> 长整型</li>
<li>ulong**:** 无符号长整型。</li>
</ul>
<p>参数perm表示该参数在sysfs文件系统中所对应的文件节点的属性，其权限定义在“内核源码&#x2F;include&#x2F;linux&#x2F;stat.h”文件中。可以用宏定义和数字法两种方式来表示。详细宏定义如下（图5-2）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRUSR 00400 <span class="comment">/*文件所有者可读*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWUSR 00200 <span class="comment">/*文件所有者可写*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXUSR 00100 <span class="comment">/*文件所有者可执行*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRGRP 00040 <span class="comment">/*与文件所有者同组的用户可读*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWGRP 00020 <span class="comment">/*与文件所有者同组的用户可写*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXGRP 00010 <span class="comment">/*与文件所有者同组的用户可执行*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IROTH 00004 <span class="comment">/*与文件所有者不同组的用户可读*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWOTH 00002 <span class="comment">/*与文件所有者不同组的用户可写*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXOTH 00001 <span class="comment">/*与文件所有者不同组的用户可可执行*/</span></span></span><br></pre></td></tr></table></figure>

<p>图5-2</p>
<p>如果要传递数组类型参数可以使用 module_param_array ()函数，相较于 module_param ()函数多了n_para参数，用来表示传递参数个数;n_para参数值会根据输入的参数个数而改变,n_para的最终值为传递的数组元素个数。</p>
<p>最后是 module_param_string(name, string, len, perm)函数，用来传递字符串类型的变量，四个参数的定义如下所示：</p>
<ul>
<li>name：外部传入的参数名，即加载模块时的传入值</li>
<li>string:内部的变量名，即程序内定义的参数名</li>
<li>len:以string命名的buffer大小(可以小于buffer的大小，但是没有意义)</li>
<li>perm:模块参数的访问权限</li>
</ul>
<p>至此，关于驱动模块传参所使用的函数就讲解完成了，在下一小节中将编写驱动模块传参函数代码。</p>
<h2 id="5-2-实验程序的编写"><a href="#5-2-实验程序的编写" class="headerlink" title="5.2 实验程序的编写"></a>5.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\02。</p>
<p>本章实验将编写Linux下的驱动传参实例代码，通过“insmod”命令进行参数的传递，并将相应的参数打印到串口终端上。</p>
<p>编写完成的parameter.c代码如下（图5-3）所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> number;<span class="comment">//定义int类型变量number</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *name;<span class="comment">//定义char类型变量name</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> para[<span class="number">8</span>];<span class="comment">//定义int类型的数组</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> str1[<span class="number">10</span>];<span class="comment">//定义char类型字符串str1</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> n_para;<span class="comment">//定义int类型的用来记录module_param_array函数传递数组元素个数的变量n_para</span></span><br><span class="line">module_param(number, <span class="type">int</span>, S_IRUGO);<span class="comment">//传递int类型的参数number，S_IRUGO表示权限为可读</span></span><br><span class="line">module_param(name, charp, S_IRUGO);<span class="comment">//传递char类型变量name</span></span><br><span class="line">module_param_array(para , <span class="type">int</span> , &amp;n_para , S_IRUGO);<span class="comment">//传递int类型的数组变量para</span></span><br><span class="line">module_param_string(str, str1 ,<span class="keyword">sizeof</span>(str1), S_IRUGO);<span class="comment">//传递字符串类型的变量str1</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">parameter_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;%d\n&quot;</span>,number);</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;%s\n&quot;</span>,name);                                                                                                                                                          </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n_para; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_EMERG <span class="string">&quot;para[%d] : %d \n&quot;</span>, i, para[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;%s\n&quot;</span>,str1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">parameter_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;parameter_exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(parameter_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(parameter_exit);<span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>); <span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>图5-3</p>
<p>以上代码将传递int类型参数number、char类型参数name、int类型的数组para和char类型字符串str1，并在驱动入口函数中，对各个参数进行打印。在下一小节会进行驱动加载测试。</p>
<h2 id="5-3-运行测试"><a href="#5-3-运行测试" class="headerlink" title="5.3 运行测试"></a>5.3 运行测试</h2><h3 id="5-3-1-编译驱动程序"><a href="#5-3-1-编译驱动程序" class="headerlink" title="5.3.1 编译驱动程序"></a>5.3.1 编译驱动程序</h3><p>在上一小节中的parameter.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图5-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += parameter.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>图5-4</p>
<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放parameter.c和Makefile文件目录下，如下图（图5-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072017518.jpeg" alt="img"> </p>
<p>图5-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图5-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072017541.jpeg" alt="img"> </p>
<p>图5-6</p>
<p>编译完生成 parameter.ko目标文件，如下图（图5-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072017448.jpeg" alt="img"> </p>
<p>图5-7</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h3 id="5-3-2-运行测试"><a href="#5-3-2-运行测试" class="headerlink" title="5.3.2 运行测试"></a>5.3.2 运行测试</h3><p>在上一章节中已经学习了使用insmod命令加载模块，而驱动模块传参的命令格式为</p>
<p>insmod 对应的模块 参数</p>
<p>parameter.ko 驱动加载可以传递3个参数，分别为int类型的参数number，char类型的参数name和int数组类型的参数para。使用以下命令进行驱动的加载，加载完成之后的打印信息如下图（图5-8）所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">insmod parameter.ko number=100 name=&quot;topeet&quot; para=0,1,2,3,4,5,6,7 str=&quot;itop&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072017522.jpeg" alt="img"> </p>
<p>图5-8</p>
<p>可以看到传递的参数都分别打印了出来。最后可以输入以下命令进行驱动的卸载，如下图（图5-9）所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmmod parameter.ko</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072017515.jpeg" alt="img"> </p>
<p>图5-9</p>
<p>【最新驱动资料（文档+例程）】</p>
<p>链接 <a href="https://pan.baidu.com/s/1M4smUG2vw_hnn0Hye-tkog">https://pan.baidu.com/s/1M4smUG2vw_hnn0Hye-tkog</a></p>
<p>提取码：hbh6</p>
<p>【B 站配套视频】</p>
<p><a href="https://b23.tv/XqYa6Hm">https://b23.tv/XqYa6Hm</a></p>
<p>【RK3568 购买链接】</p>
<p><a href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-2245">https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-2245</a></p>
<p>2452613.11.2fec74a6elWNeA&amp;id&#x3D;669939423234</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-4-内核模块实验</title>
    <url>/2023/09/05/1-4-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在上一章节我们编写了最简单的helloworld驱动程序。有了驱动程序以后，要如何编译并使用驱动呢。编译驱动有俩种方法，分别是将驱动编译成内核和将驱动编译成内核模块。我们先来学习如何将驱动编译成内核模块、</p>
<h1 id="4-1-设置交叉编译器"><a href="#4-1-设置交叉编译器" class="headerlink" title="4.1 设置交叉编译器"></a>4.1 设置交叉编译器</h1><p>1 下载网盘资料下的交叉编译器，网盘路径为：“XXX”，将下载的交叉编译器拷贝到Ubuntu的&#x2F;usr&#x2F;local目录下，如下图（图4-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016495.jpeg" alt="img"></p>
<p>图 4-1</p>
<p>2 输入以下命令，解压交叉编译编译器压缩包，解压完毕会生成“gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu”文件夹，这是实验需要的交叉编译工具，如下图（图4-2）所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -vxf gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016536.jpeg" alt="img"></p>
<p>图 4-2</p>
<p>3 在终端输入“sudo vi &#x2F;etc&#x2F;profile”命令，在文件最后输入以下命令修改环境变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016558.jpeg" alt="img"></p>
<p>图 4-3</p>
<p>4 保存退出，在终端输入“reboot”命令重新启动Ubuntu系统，使交叉编译环境生效。Ubuntu系统重新启动之后，登录到系统后，打开终端，输入命令“aarch64-linux-gnu-gcc -v”，如果终端有如下图（图4-4）所示的打印信息，说明交叉编译环境搭建成功。如果没有出现如下图（图4-4）的打印信息，需要检查上一步骤是否设置正确。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016623.jpeg" alt="img"></p>
<p>图 4-4</p>
<h1 id="4-2-编写Makefile"><a href="#4-2-编写Makefile" class="headerlink" title="4.2 编写Makefile"></a>4.2 编写Makefile</h1><p>编译驱动程序还需要使用Makefile文件。我们为helloworld.c编写一个简单的Makefile，Makefile文件和源文件helloworld.c位于同一级目录，代码如下（图4-5）所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64  </span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-  </span><br><span class="line">obj-m += helloworld.o    <span class="comment">#helloworld.c对应.o文件的名称。名称要保持一致。</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#内核源码所在虚拟机ubuntu的实际路径</span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>图 4-5</p>
<p>代码解释如下：</p>
<ul>
<li>第1行设置ARCH变量为arm64</li>
<li>第2行设置交叉编译器前缀为aarch64-linux-gnu-</li>
<li>第3行obj-m +&#x3D; &lt;文件&gt;：将指定的文件（需要是以.o结尾）设为编译时以模块形式编译</li>
<li>第4行是设备树内核的源码路径，请大家根据实际内核路径进行修改。</li>
<li>第5行是获取当前目录的变量</li>
<li>第7行是编译make操作，会进入内核源码的路径，然后把当前路径下的代码编译成模块。</li>
<li>第9行是清除编译文件</li>
</ul>
<p>编写完成如下图（图4-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016516.jpeg" alt="img"></p>
<p>图 4-6</p>
<p>4.3 编译模块</p>
<p>有了Makefile以后，输入“make”命令就可以编译helloworld驱动模块，如下图（图4-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016524.jpeg" alt="img"></p>
<p>图 4-7</p>
<p>编译完生成helloworld.ko目标文件就是我们需要的内核模块。内核模块是以ko为后缀名，如下图（图4-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016931.jpeg" alt="img"></p>
<p>图 4-8</p>
<p>输入“make clean”命令清除编译文件，如下图（图4-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016990.jpeg" alt="img"></p>
<p>图 4-9</p>
<h1 id="4-4-模块加载与卸载"><a href="#4-4-模块加载与卸载" class="headerlink" title="4.4 模块加载与卸载"></a>4.4 模块加载与卸载</h1><p>有了内核模块以后，我们要如何使用呢？编译驱动有俩种方式，那Linux驱动的运行方式也肯定有俩种。一种就是将驱动编译进内核，这样Linux系统启动后会自动运行程序。第二种就是将驱动编译成模块，在Linux系统启动以后使用“insmod”命令加载驱动模块。</p>
<p>在上个小节中编译了驱动模块helloworld.ko，在RK3568开发板上通过“insmod helloworld.ko”命令可以加载驱动，在加载驱动模块的时候会执行驱动入口的函数，也就是helloworld程序中的helloworld_init函数，所以可以看到打印出来的字符串信息“helloworld_init”。如下图（图4-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016987.jpeg" alt="img"></p>
<p>图 4-10</p>
<p>如果要卸载helloworld内核模块，可以通过“rmmod helloworld”命令来卸载驱动模块，同理在卸载驱动模块的时候会执行驱动出口的函数，所以可以看到驱动出口函数打印出来的字符串信息“helloworld_exit”，如下图（图4-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016982.jpeg" alt="img"></p>
<p>图 4-11</p>
<p>加载驱动模块也可以使用modprobe命令，它比insmod命令更强大，modprobe命令在加载驱动模块的时候，会同时加载该模块依赖的其他模块。比如helloworld.ko依赖before.ko，使用insmod加载的时候，就必须先加载before.ko，然后在加载helloworld.ko才可以加载成功从。但是使用modprobe加载的时候，他会自动分析模块的依赖关系，然后将所有的依赖的模块都加载到内核当中。比较“聪明”。</p>
<p>同样，在卸载驱动模块的时候，如果模块存在依赖关系，如果使用insmod命令，需要手动卸载依赖的内核模块，但是使用modprobe命令可以自动卸载驱动模块所依赖的其他模块。</p>
<p>所以，如果驱动模块是以“modprobe helloworld.ko”命令加载的，卸载的时候使用“modprobe -r helloworld.ko”命令卸载。</p>
<p>但是使用modprobe卸载存在一个问题，如果所依赖的模块被其他模块所使用，比如刚才例子中的before.ko还被其他的模块使用，这时候就不能使用modprobe卸载。所以还是推荐使用rmmod命令来卸载。</p>
<h1 id="4-5查看模块信息"><a href="#4-5查看模块信息" class="headerlink" title="4.5查看模块信息"></a>4.5查看模块信息</h1><p>在驱动模块加载之后，使用“modinfo helloworld.ko”命令可以获得模块的信息，包括模块作者，模块说明，模块支持的参数等等。</p>
<p>lsmod 命令可以列出已经载入Linux内核模块，在helloworld驱动加载之后，查看内核中加载的模块，如下（图4-12）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016996.jpeg" alt="img"></p>
<p>图 4-12</p>
<p>【最新驱动资料（文档+例程）】</p>
<p>链接 <a href="https://pan.baidu.com/s/1M4smUG2vw_hnn0Hye-tkog">https://pan.baidu.com/s/1M4smUG2vw_hnn0Hye-tkog</a></p>
<p>提取码：hbh6</p>
<p>【B 站配套视频】</p>
<p><a href="https://b23.tv/XqYa6Hm">https://b23.tv/XqYa6Hm</a></p>
<p>【RK3568 购买链接】</p>
<p><a href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-2245">https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-2245</a></p>
<p>2452613.11.2fec74a6elWNeA&amp;id&#x3D;669939423234</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-3-helloworld 驱动实验</title>
    <url>/2023/09/05/1-3-helloworld-%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在学习C语言或者其他语言的时候，我们通常是打印一句“helloworld”来开启编程世界的大门。学习驱动程序编程亦可以如此，使用helloworld作为我们的第一个驱动程序。</p>
<p>接下来开始编写第一个驱动程序—helloworld。</p>
<h1 id="3-1-驱动编写"><a href="#3-1-驱动编写" class="headerlink" title="3.1 驱动编写"></a>3.1 驱动编写</h1><p>本小节来编写一个最简单的驱动——helloworld驱动。helloworld.c如下（图3-1）所示代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);<span class="comment">//注意：内核打印用printk而不是printf</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);    <span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(helloworld_exit);    <span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    <span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);    <span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>看似非常简单的helloworld驱动代码，却五脏俱全。一个简单的helloworld驱动包含驱动的基本框架。我们继续往下看。</p>
<h1 id="3-2-驱动的基本框架"><a href="#3-2-驱动的基本框架" class="headerlink" title="3.2 驱动的基本框架"></a>3.2 驱动的基本框架</h1><p>Linux驱动的基本框架主要由模块加载函数，模块卸载函数，模块许可证声明，模块参数，模块导出符号，模块作者信息等几部分组成，其中模块参数，模块导出符号，模块作者信息是可选的部分，也就是可要可不要。剩余部分是必须有的。我们来看一下这几个部分的作用：</p>
<p>1 模块加载函数</p>
<p>​	当使用加载驱动模块时，内核会执行模块加载函数，完成模块加载函数中的初始化工作。</p>
<p>2 模块卸载函数</p>
<p>​	当卸载某模块时，内核会执行模块卸载函数，完成模块卸载函数中的退出工作。</p>
<p>3 模块许可证声明</p>
<p>​	许可证声明描述了内核模块的许可权限，如果不声明模块许可，模块在加载的时候，会收到“内核被污染（kernel tainted）”的警告。可接受的内核模块声明许可包括“GPL”“GPL v2”。</p>
<p>4 模块参数（可选择）</p>
<p>​	模块参数是模块被加载的时候可以传递给它的值。</p>
<p>5 模块导出符号（可选择）</p>
<p>​	内核模块可以导出的符号，如果导出，其他模块可以使用本模块中的变量或函数。</p>
<p>6 模块作者信息等说明（可选择）</p>
<p>上一小节我们说，helloworld驱动麻雀虽小五脏俱全，我们来分析helloworld驱动。通过helloworld代码再来看驱动框架。</p>
<p>（1）模块加载函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">module_init(helloworld_init);    <span class="comment">//注册入口函数</span></span><br></pre></td></tr></table></figure>

<p>（2）模块卸载函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_exit(helloworld_exit);    <span class="comment">//注册出口函数</span></span><br></pre></td></tr></table></figure>

<p>（3）模块许可证声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    <span class="comment">//同意GPL开源协议</span></span><br></pre></td></tr></table></figure>

<p>（4）模块作者信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);    <span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>（5）头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">//模块加载函数和卸载函数需要的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>通过上面的分析，helloworld驱动是不是包含了驱动框架的所有必要的部分呢。因此helloworld驱动我们可以看作是驱动代码的模板。任何一个驱动代码都用它作为基础来编写实现。同学们要将他记忆下来！</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>1-2-你好内核源码</title>
    <url>/2023/09/05/1-2-%E4%BD%A0%E5%A5%BD%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本章我们来认识Linux内核源码，开始真正进入到驱动的世界里面，不知道各位小伙伴们有没有做好准备呢？</p>
<h1 id="2-1-初识内核源码"><a href="#2-1-初识内核源码" class="headerlink" title="2.1 初识内核源码"></a>2.1 初识内核源码</h1><p>Linux内核源码的官方网站为<a href="https://www.kernel.org/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%AF%A5%E7%BD%91%E7%AB%99%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%9A%84Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E3%80%82%E8%BF%9B%E5%85%A5%E8%AF%A5%E7%BD%91%E7%AB%99%E4%B9%8B%E5%90%8E%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%88%E5%9B%BE2-1%EF%BC%89%E6%89%80%E7%A4%BA%EF%BC%9A">https://www.kernel.org/，可以在该网站下载最新的Linux内核源码。进入该网站之后如下图（图2-1）所示：</a></p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016728.jpeg" alt="img"> </p>
<p>图 2-1</p>
<p>从上图（图1）可以看到多个版本的内核分支，分别为主线版本（mainline）、稳定版本（stable）和长期支持版本（longterm）。以上各个支线和主线是由linus torvalds（Linux之父）所领导。半导体厂商和一些内核爱好者会在官网下载相应版本的内核源码，对该源码进行打补丁等操作。以此让官网的内核源码可以在半导体厂家设计的主控（CPU）上跑起来，所以在开发和学习的过程中，我们并不会直接去Linux内核官网下去下载源码，而且是使用半导体厂家提供的源码包。</p>
<p>但是不论是Linux官网的内核源码还是半导体厂家提供的内核源码不影响我们来看它的庐山真面目！作者下载了Linux官方网站的4.19.262分支源码，下载好的源码存放在“iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\01_Linux内核官方源码”如下图（图2-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016714.jpeg" alt="img"> </p>
<p>图 2-2</p>
<p>将Linux内核官方源码拷贝到虚拟机ubuntu上如下图（图2-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016708.jpeg" alt="img"> </p>
<p>图 2-3</p>
<p>使用以下命令对内核官方源码进行解压，解压完成如下图（图2-4）所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tar -vxf linux-4.19.262.tar.xz </span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016773.jpeg" alt="img"> </p>
<p>图 2-4</p>
<p>解压完成后我们会看到非常多的文件夹，这些文件夹放的就是Linux内核源码，在下一小节中作者来介绍Linux内核源码的结构和每个目录的作用。</p>
<h1 id="2-2-内核源码结构"><a href="#2-2-内核源码结构" class="headerlink" title="2.2 内核源码结构"></a>2.2 内核源码结构</h1><p>上一小节解压的目录下的内核源码目录都是用来做什么的呢？如下图（图2-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016717.jpeg" alt="img"> </p>
<p>图 2-5</p>
<p>目录的内容如下表（表2-6）所示：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>arch</td>
<td>存放不同平台体系相关代码</td>
</tr>
<tr>
<td>block</td>
<td>存放块设备相关代码</td>
</tr>
<tr>
<td>crypto</td>
<td>存放加密、压缩、CRC校验等算法相关代码</td>
</tr>
<tr>
<td>Documentation</td>
<td>存放相关说明文档，很多实用文档，包括驱动编写等</td>
</tr>
<tr>
<td>drivers</td>
<td>存放Linux 内核设备驱动程序源码。该目录包含众多驱动，目录按照设备类别进行分类，如 char、block 、input、i2c、spi、pci、usb等。</td>
</tr>
<tr>
<td>firmware</td>
<td>存放处理器相关的一些特殊固件</td>
</tr>
<tr>
<td>fs</td>
<td>存放虚拟文件系统代码</td>
</tr>
<tr>
<td>include</td>
<td>存放内核所需、与平台无关的头文件</td>
</tr>
<tr>
<td>init</td>
<td>Linux系统启动初始化相关的代码</td>
</tr>
<tr>
<td>ipc</td>
<td>存放进程间通信代码</td>
</tr>
<tr>
<td>kernel</td>
<td>Linux内核的核心代码，包含了进程调度子系统，以及和进程调度相关的模块。</td>
</tr>
<tr>
<td>lib</td>
<td>库文件代码， 实现需要在内核中使用的库函数，例如CRC、FIFO、list、MD5等。</td>
</tr>
<tr>
<td>mm</td>
<td>实现存放内存管理代码</td>
</tr>
<tr>
<td>net</td>
<td>存放网络相关代码</td>
</tr>
<tr>
<td>samples</td>
<td>存放提供的一些内核编程范例</td>
</tr>
<tr>
<td>scripts</td>
<td>存放一些脚本文件</td>
</tr>
<tr>
<td>security</td>
<td>存放系统安全性相关代码</td>
</tr>
<tr>
<td>sound</td>
<td>存放声音、声卡相关驱动</td>
</tr>
<tr>
<td>tools</td>
<td>一些常用工具，如性能剖析、自测试等</td>
</tr>
<tr>
<td>usr</td>
<td>用于生成initramfs的代码。</td>
</tr>
<tr>
<td>virt</td>
<td>提供虚拟机技术（KVM等）的支持</td>
</tr>
</tbody></table>
<p>表 2-6</p>
<h1 id="2-3-编译内核源码"><a href="#2-3-编译内核源码" class="headerlink" title="2.3 编译内核源码"></a>2.3 编译内核源码</h1><p>本小节使用的内核源码是半导体厂家提供的内核源码，是我们学习和开发要使用的内核源码。在进行驱动学习之前需要将此内核源码编译成功。</p>
<p>内核源码存放路径为“iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\02_Linux_SDK源码”，将对应目录下的内核源码拷贝到虚拟机ubuntu目录下，如下图（图2-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016704.jpeg" alt="img"></p>
<p>图 2-7</p>
<p>注：编译环境使用的是迅为搭建好的编译环境，迅为的环境经过测试在不进行修改的前提下，可以直接将内核源码编译通过。</p>
<p>使用以下命令对内核源码的进行解压，解压完成如下图（图2-8）所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -vxf linux_sdk.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016104.jpeg" alt="img"></p>
<p>图 1-8</p>
<p>使用“cd linux_sdk”命令进入内核源码目录，如下图（图2-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016124.jpeg" alt="img"></p>
<p>图 2-9</p>
<p>使用命令“.&#x2F;build.sh kernel”进行内核源码的编译，编译过程如下图（图2-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016152.jpeg" alt="img"></p>
<p>图 2-10</p>
<p>编译时间和电脑虚拟机配置相关，编译完成如下图（图2-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309072016179.jpeg" alt="img"></p>
<p>图 2-11</p>
<p>通过对内核源码官网的探索，内核源码的目录结构讲解以及内核源码的编译。我相信大家对Linux内核源码应该有了一个初步的认识了。下一章我们来学习第一个驱动helloworld。</p>
<p>【最新驱动资料（文档+例程）】</p>
<p>链接 <a href="https://pan.baidu.com/s/1M4smUG2vw_hnn0Hye-tkog">https://pan.baidu.com/s/1M4smUG2vw_hnn0Hye-tkog</a></p>
<p>提取码：hbh6</p>
<p>【B 站配套视频】</p>
<p><a href="https://b23.tv/XqYa6Hm">https://b23.tv/XqYa6Hm</a></p>
<p>【RK3568 购买链接】</p>
<p><a href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-2245">https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-2245</a></p>
<p>2452613.11.2fec74a6elWNeA&amp;id&#x3D;669939423234</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>rk3568 驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>3.22-u-boot重定位分析(下)</title>
    <url>/2023/09/05/3-22-u-boot%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90-%E4%B8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-22-1-U-boot启动前期为什么可以直接在0x0起始地址运行"><a href="#3-22-1-U-boot启动前期为什么可以直接在0x0起始地址运行" class="headerlink" title="3.22.1 U-boot启动前期为什么可以直接在0x0起始地址运行?"></a>3.22.1 U-boot启动前期为什么可以直接在0x0起始地址运行?</h1><p>在某些系统中，U-Boot 可以直接从地址 0x0 处执行的原因是由于处理器的启动过程和内存映射的特殊性。</p>
<p>在处理器上电或复位后，处理器会跳转到一个预定义的启动地址开始执行代码。对于某些处理器架构，例如 ARM 架构中的 Cortex-M 系列处理器，其启动地址通常是固定的，即地址 0x0。</p>
<p>此时，处理器处于特权模式（例如 SVC 模式），并且还没有启用内存管理单元（MMU）和缓存。因此，此阶段的代码执行在物理地址上，可以直接访问系统的内存和外设。</p>
<p>U-Boot 在启动前期的代码中，主要是进行一些基本的初始化工作，例如设置中断向量表、关闭缓存、关闭 MMU、初始化时钟和外设等。这些操作并不依赖于虚拟地址空间或完整的操作系统环境。</p>
<p>在 U-Boot 启动过程的后期，会进行重定位操作，将 U-Boot 的代码从 Flash 或其他存储器中复制到 RAM 中，并更新相关的地址。此时，处理器会启用 MMU，并将代码和数据映射到虚拟地址空间中。</p>
<p>因此，U-Boot 可以在启动前期直接从地址 0x0 处执行，而不会产生内存访问冲突或其他问题。这种设计可以简化启动流程，并避免在启动早期的阶段涉及复杂的内存映射和地址转换操作。</p>
<h1 id="3-22-2-动态链接"><a href="#3-22-2-动态链接" class="headerlink" title="3.22.2 动态链接"></a>3.22.2 动态链接</h1><p>动态链接是一种在程序运行时进行的链接方式，它允许程序在加载和执行时动态地解析和链接外部的共享库（或动态链接库）。在 U-Boot 中采用的动态链接方式可能与传统操作系统中的动态链接有所不同，这取决于具体的实现和目标平台。</p>
<p>以下是一些与 U-Boot 中动态链接相关的概念和技术：</p>
<ol>
<li>位置无关代码（Position Independent Code，PIC）：这是一种编译方式，生成的代码可以在内存中的任意位置加载和执行，而不依赖于固定的地址。位置无关代码通常使用相对寻址方式，以便在重定位时能够适应不同的加载地址。</li>
<li>全局偏移表（Global Offset Table，GOT）：GOT 是一个数据结构，存储了程序中使用的全局符号（如函数或变量）的地址。在 U-Boot 中，GOT 可能放置在数据段中，并使用相对寻址方式进行访问。</li>
<li>文字池（Literal Pool）：文字池是一个存储常量数据的区域，通常包括字符串字面量、常量表达式等。文字池可以用于存储需要重定位的常量数据，并在运行时进行访问。</li>
<li>符号表（Symbol Table）和重定位符号表（Relocation Symbol Table）：这些表记录了程序中使用的符号和对应的重定位信息。在动态链接过程中，符号表和重定位符号表被用于解析和重定位外部共享库中的符号。</li>
<li>基址重置（R_ARM_RELATIVE）：基址重置是一种重定位方式，用于将位置无关代码中的相对地址转换为绝对地址。在 U-Boot 中，基址重置可能是一种常见的重定位方式，用于修正位置无关代码中的相对地址。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.21-u-boot重定位分析(上)</title>
    <url>/2023/09/05/3-21-u-boot%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90-%E4%B8%8A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-20-1-U-Boot-启动方式"><a href="#3-20-1-U-Boot-启动方式" class="headerlink" title="3.20.1 U-Boot 启动方式"></a>3.20.1 U-Boot 启动方式</h1><p>下面是关于 U-Boot 启动方式的解释：</p>
<p>U-Boot 是一种开源的引导加载程序，用于在嵌入式系统上启动操作系统。它具有广泛的硬件支持和灵活的配置选项。U-Boot 可以从多种存储介质启动，包括 NAND、NOR、SD 卡和 SDRAM。</p>
<ol>
<li>NAND 启动：<br>NAND 闪存是一种非易失性存储介质，常用于嵌入式系统中。当 U-Boot 从 NAND 启动时，它会从 NAND 闪存芯片读取引导程序（bootloader）并执行。</li>
<li>NOR 启动：<br>NOR 闪存是另一种常见的非易失性存储介质，通常用于存储 U-Boot。在 NOR 启动方式下，U-Boot 位于 NOR 闪存中，并且系统会直接从 NOR 闪存中加载和执行 U-Boot。</li>
<li>SD 卡启动：<br>SD 卡是一种可移动存储介质，常用于嵌入式系统中。当 U-Boot 从 SD 卡启动时，它会从 SD 卡中读取引导程序并执行。</li>
<li>SDRAM 启动：<br>SDRAM 是系统内存，U-Boot 可以从 SDRAM 启动。在 SDRAM 启动方式下，U-Boot 首先加载到 SDRAM 中，然后执行。</li>
</ol>
<p>在启动过程中，U-Boot 需要知道引导程序的存储位置和大小。根据您提供的信息，我理解以下是相关的地址范围和存储介质：</p>
<ul>
<li>NAND：存储介质为 NAND 闪存。</li>
<li>NOR：存储介质为 NOR 闪存。</li>
<li>SD 卡：存储介质为 SD 卡。</li>
<li>SDRAM：存储介质为系统内存。</li>
</ul>
<h1 id="3-20-2-U-Boot生成文件的一般过程："><a href="#3-20-2-U-Boot生成文件的一般过程：" class="headerlink" title="3.20.2 U-Boot生成文件的一般过程："></a>3.20.2 U-Boot生成文件的一般过程：</h1><p>在 U-Boot 的编译过程中，会生成不同的文件，其中包括以下常见的文件格式：</p>
<ul>
<li>ELF 格式：U-Boot 的主要可执行文件通常以 ELF（Executable and Linkable Format）格式存储。ELF 文件包含了可执行代码、数据和符号表等信息，可用于调试和符号解析。</li>
<li>BIN 格式：U-Boot 还可以使用 objcopy 工具将 ELF 格式的可执行文件转换为 BIN（Binary）格式。BIN 格式是一种简化的二进制文件格式，它只包含可执行代码，没有调试信息和符号表。</li>
<li>Symbol 文件：U-Boot 生成的符号文件（例如 u-boot.sym）包含了代码中定义的符号信息，这对于调试和符号解析非常有用。符号文件通常与 ELF 格式文件一起使用。</li>
<li>System.map 文件：U-Boot 在编译过程中还会生成 System.map 文件，它包含了 U-Boot 的符号表和地址映射信息。</li>
</ul>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309070727839.png" alt="image-20230907072726729"></p>
<h1 id="3-20-3-uboot镜像依赖关系"><a href="#3-20-3-uboot镜像依赖关系" class="headerlink" title="3.20.3 uboot镜像依赖关系"></a>3.20.3 uboot镜像依赖关系</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u-boot-init -&gt; start.o -&gt; u-boot-main -&gt; built-in.o -&gt; u-boot.lds</span><br></pre></td></tr></table></figure>

<p>解释如下：</p>
<ol>
<li><code>u-boot-init</code>：这是一个初始文件或函数，可能包含一些启动代码或初始化代码。</li>
<li><code>start.o</code>：这是一个目标文件，位于 <code>arch/arm/cpul/armv7</code> 目录中。它可能包含与 ARMv7 架构相关的启动代码。</li>
<li><code>u-boot-main</code>：这是一个主要的 U-Boot 文件或函数，可能包含 U-Boot 的核心功能。</li>
<li><code>built-in.o</code>：这是一个目标文件，位于 <code>xx/xxx</code> 目录中。它可能包含 U-Boot 中的一些功能模块或驱动程序。</li>
<li><code>u-boot.lds</code>：这是 U-Boot 的链接脚本文件，用于指定链接器如何将目标文件组合成最终的可执行镜像。</li>
</ol>
<h1 id="3-20-4-uboot启动流程"><a href="#3-20-4-uboot启动流程" class="headerlink" title="3.20.4 uboot启动流程"></a>3.20.4 uboot启动流程</h1><p>U-Boot 的启动流程可以大致描述如下：</p>
<ol>
<li>硬件上电或复位后，处理器会跳转到预定义的启动地址，通常是 SoC 内部的 ROM 或 Flash 存储器中的特定位置。</li>
<li>启动地址处的代码通常是一段汇编代码，用于设置处理器的初始状态和寄存器，然后跳转到 U-Boot 的入口点。</li>
<li>在 U-Boot 的入口点，首先执行的是 <code>arch/arm/lib/vectors.S</code> 文件中的 <code>reset</code> 函数。该函数主要完成一些处理器和中断控制器的初始化工作。</li>
<li><code>reset</code> 函数会调用 <code>arch/arm/cpu/armv7/start.S</code> 文件中的 <code>mair_init</code> 函数。<code>mair_init</code> 主要用于设置内存访问控制和缓存配置等相关设置。</li>
<li>接下来，<code>mair_init</code> 函数会调用 <code>arch/arm/lib/crt0.S</code> 文件中的 <code>relocate_code</code> 函数。<code>relocate_code</code> 函数负责将 U-Boot 的代码从其加载地址（通常是 Flash 存储器）复制到 RAM 中，并更新相关的地址。</li>
<li>在 <code>relocate_code</code> 函数执行完毕后，控制权将转移到 U-Boot 的入口函数（通常是 <code>board_init_f</code> 或 <code>main_loop</code> 函数），从而开始执行 U-Boot 的主要功能。</li>
</ol>
<h1 id="3-20-5-重定位之前准备工作"><a href="#3-20-5-重定位之前准备工作" class="headerlink" title="3.20.5 重定位之前准备工作"></a>3.20.5 重定位之前准备工作</h1><p>在 U-Boot 的重定位之前，通常会进行一些准备工作。根据您提供的信息，这些准备工作可能包括以下内容：</p>
<p>在 <code>start.S</code> 文件中：</p>
<ul>
<li>设置 CPU 为 SVC（Supervisor）模式。</li>
<li>关闭缓存和关闭 MMU（Memory Management Unit）。</li>
<li>设置关门狗（Watchdog）、屏蔽中断、设置时钟等初始化操作。</li>
<li>初始化 SDRAM（同步动态随机存取存储器）。</li>
</ul>
<p>在 <code>crt0.S</code> 文件中：</p>
<ul>
<li>初始化 C 语言运行环境，包括堆栈设置等。</li>
<li>进行板级各种初始化操作，例如初始化 NAND、SDRAM 等外设。</li>
<li>初始化全局结构体变量 GD（Global Data），并在 GD 中保存 U-Boot 的实际加载地址。</li>
<li>调用 <code>relocate_code</code> 函数，将 U-Boot 镜像从 Flash 拷贝到内存中。</li>
<li>从 Flash 跳转到 RAM 空间，继续执行 U-Boot 程序。</li>
<li>清零 BSS 段（未初始化的全局变量）、进行板级初始化操作。</li>
<li>最后进入 <code>bootcmd</code> 或 <code>main_loop</code> 循环，执行 U-Boot 的主要功能。</li>
</ul>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.20-linux内核加载实验</title>
    <url>/2023/09/05/3-20-linux%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BD%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-20-1-Linux内核启动"><a href="#3-20-1-Linux内核启动" class="headerlink" title="3.20.1 Linux内核启动"></a>3.20.1 Linux内核启动</h1><p>U-Boot（Universal Bootloader）是一种常用的开源引导加载程序，用于启动嵌入式系统。它提供了多种启动方式和引导镜像格式支持。下面是关于U-Boot启动过程的一些说明：</p>
<ol>
<li>Linux内核启动：<br>U-Boot负责加载和启动Linux内核。它可以通过不同的启动方式加载内核，包括TFTP（通过网络下载）、NAND（闪存）、NOR（闪存）、SD卡等。具体的启动方式取决于硬件平台和配置。</li>
<li>U-Boot使用bootm引导uImage：<br>U-Boot通常使用bootm命令来引导uImage格式的内核镜像。uImage是一种特定的内核镜像格式，它包含了内核映像以及内核启动参数（如命令行参数、设备树等）。</li>
<li>使用bootz引导zImage：<br>另一种常见的内核镜像格式是zImage。与uImage不同，zImage是一种压缩的内核镜像格式。U-Boot可以使用bootz命令来引导zImage格式的内核镜像。bootz命令会在引导之前对zImage进行解压缩，并提供内核启动参数。</li>
</ol>
<p>总结来说，U-Boot作为引导加载程序，负责启动嵌入式系统。它支持多种启动方式（如TFTP、NAND、NOR、SD卡）和不同的内核镜像格式（如uImage、zImage），以适应不同的硬件平台和需求。在启动过程中，U-Boot加载内核镜像并提供必要的参数，然后将控制权转交给Linux内核，完成系统的启动。</p>
<h1 id="3-20-2-内核镜像编译"><a href="#3-20-2-内核镜像编译" class="headerlink" title="3.20.2 内核镜像编译"></a>3.20.2 内核镜像编译</h1><p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062209558.png" alt="image-20230906220939457"></p>
<p>编译内核镜像的过程通常包括以下步骤：</p>
<ol>
<li><p>ELF文件（vmlinux）：<br>内核源代码编译生成的主要输出是一个名为vmlinux的ELF文件。这个文件包含了内核的所有代码和符号，并且链接地址通常设置为0x80008000。</p>
</li>
<li><p>objcopy：<br>使用objcopy工具，可以将vmlinux文件转换为其他格式的镜像。在这个过程中，可以使用参数-l指定链接地址（load address），例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objcopy -O binary -R .note -R .comment -S vmlinux vmlinux.bin</span></span><br><span class="line">```</span><br><span class="line">这个命令将vmlinux文件转换为原始的二进制内核镜像（vmlinux.bin），同时删除了.note和.comment节（section）。</span><br></pre></td></tr></table></figure>
</li>
<li><p>gzip压缩：<br>为了减小内核镜像的大小，通常会对二进制内核镜像进行压缩。使用gzip工具可以对vmlinux.bin进行压缩，生成压缩的二进制内核镜像。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gzip -9 -c vmlinux.bin &gt; vmlinux.gz</span></span><br><span class="line">```</span><br><span class="line">这个命令将vmlinux.bin压缩为vmlinux.gz。</span><br></pre></td></tr></table></figure>
</li>
<li><p>自解压运行：<br>压缩的二进制内核镜像（vmlinux.gz）需要进行自解压运行。这涉及到一些特定的代码和链接过程。</p>
<ul>
<li><p>head.o、misc.o、decompress.o和piggz.gzip.o是与自解压相关的一些目标文件，它们包含了自解压运行所需的代码。</p>
</li>
<li><p>链接过程将这些目标文件与原始的vmlinux文件链接在一起，生成一个新的ELF文件（vmlinux）。</p>
</li>
<li><p>使用objcopy工具，将这个新的vmlinux文件转换为raw binary格式的镜像。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ objcopy -O binary -R .note -R .comment -S vmlinux vmlinux.raw</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>mkimage：<br>使用mkimage工具，可以将raw binary格式的镜像（vmlinux.raw）转换为uImage格式的镜像（uImage）。这个过程包括添加头部信息、校验和等操作。具体使用方法可以根据所使用的工具和平台进行调整。</p>
</li>
</ol>
<p>总结来说，内核镜像的编译过程包括将ELF文件转换为原始二进制内核镜像，压缩内核镜像，进行自解压运行的链接和处理，最后生成uImage格式的镜像。这样的过程可以根据具体的平台和需求进行调整和扩展。</p>
<h1 id="3-20-3-内核编译的几个关键地址"><a href="#3-20-3-内核编译的几个关键地址" class="headerlink" title="3.20.3 内核编译的几个关键地址"></a>3.20.3 内核编译的几个关键地址</h1><ol>
<li>LOADADDR（ulmage指定加载地址）：<br>LOADADDR是用于指定uImage格式的内核镜像在内存RAM中的加载地址。在U-Boot中，uImage会被加载到指定的LOADADDR地址处。</li>
<li>PHYS_OFFSET（RAM物理内存起始地址）：<br>PHYS_OFFSET是指内核在物理内存中的起始地址。它表示RAM的物理内存的起始位置。</li>
<li>PAGE_OFFSET（内核虚拟内存空间起始地址）：<br>PAGE_OFFSET是指内核在虚拟内存中的起始地址。它决定了内核虚拟地址空间的起始位置。通常情况下，它被设置为0xC0000000（3GB用户空间+1GB内核空间）。在某些平台（如vexpress开发板）上，PAGE_OFFSET可能被设置为0x80000000。</li>
<li>TEXT_OFFSET（内核起始地址相对于RAM地址的偏移）：<br>TEXT_OFFSET是指内核代码在RAM地址中的偏移量。它表示内核代码相对于物理内存的偏移。在arm架构中，一般将TEXT_OFFSET设置为0x8000。这个值在arch&#x2F;arm&#x2F;Makefile中定义。</li>
<li>TEXTADDR（内核镜像启动的虚拟地址）：<br>TEXTADDR是内核编译时使用的链接地址。在运行时，内核镜像会被加载到PAGE_OFFSET+TEXT_OFFSET的地址处执行。</li>
<li>ZRELADDR（内核镜像启动的物理地址）：<br>ZRELADDR是指zImage格式的内核镜像的启动物理地址。zImage启动时，真正的内核代码会被解压到ZRELADDR地址，并从该地址处开始执行。</li>
<li>ZTEXTADDR（zImage运行物理地址）：<br>ZTEXTADDR是指zImage格式的内核镜像运行的物理地址。如果LOADADDR没有定义，U-Boot会将uImage加载到ZTEXTADDR地址处。这个地址空间可以是RAM或NOR FLASH的地址空间。</li>
</ol>
<h1 id="3-20-4-ulmage制作"><a href="#3-20-4-ulmage制作" class="headerlink" title="3.20.4 ulmage制作"></a>3.20.4 ulmage制作</h1><p>制作ulmage（uImage格式的内核镜像）可以使用mkimage工具，该工具位于U-Boot源码的tools目录下。下面是使用mkimage命令制作ulmage的示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mkimage -A arm -O linux -T kernel -C none -a 0x60003000 -e 0x60003000 -d zlmage ulmage</span></span><br></pre></td></tr></table></figure>

<p>这个命令的参数说明如下：</p>
<ul>
<li><code>-A arm</code>：指定CPU类型为ARM，根据实际情况选择正确的CPU类型。</li>
<li><code>-O linux</code>：指定操作系统为Linux。</li>
<li><code>-T kernel</code>：指定镜像类型为内核。</li>
<li><code>-C none</code>：指定压缩方式为无压缩。</li>
<li><code>-a 0x60003000</code>：指定内核加载地址（LOADADDR）。</li>
<li><code>-e 0x60003000</code>：指定内核入口地址（ENTRYADDR）。</li>
<li><code>-d zlmage</code>：指定输入的zImage格式的内核镜像文件。</li>
<li><code>ulmage</code>：指定输出的uImage格式的内核镜像文件。</li>
</ul>
<p>这样，mkimage工具会在当前目录下生成ulmage文件，该文件是uImage格式的内核镜像，包含了一个40字节的数据头记录了加载地址、入口地址、文件大小、CPU架构等信息。</p>
<h1 id="3-20-5-运行zlmage"><a href="#3-20-5-运行zlmage" class="headerlink" title="3.20.5 运行zlmage"></a>3.20.5 运行zlmage</h1><p>要运行zlmage（zImage格式的内核镜像），需要以下目标文件的支持：piggz.gzip.o、decompress.o、misc.o和head.o。</p>
<p>这些目标文件涉及到自解压过程，其中piggz.gzip.o用于gzip解压算法，decompress.o用于通用的解压算法，misc.o和head.o包含了与自解压相关的代码。</p>
<p>在运行zlmage之前，需要将这些目标文件与zlmage链接在一起，生成一个新的ELF文件。然后，将这个新的ELF文件转换为raw binary格式的镜像，以便在运行时执行。</p>
<p>具体的步骤如下：</p>
<ol>
<li><p>将zlmage与目标文件链接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ld -Ttext 0x80008000 -o vmlinux.elf zlmage piggz.gzip.o decompress.o misc.o head.o</span></span><br><span class="line">```</span><br><span class="line">这个命令将zlmage与目标文件链接在一起，生成一个名为vmlinux.elf的新的ELF文件。</span><br></pre></td></tr></table></figure>
</li>
<li><p>将vmlinux.elf转换为raw binary格式的镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objcopy -O binary -R .note -R .comment -S vmlinux.elf vmlinux.raw</span></span><br><span class="line">```</span><br><span class="line">这个命令将vmlinux.elf转换为raw binary格式的镜像，即vmlinux.raw。</span><br></pre></td></tr></table></figure>
</li>
<li><p>将vmlinux.raw加载到合适的地址并执行：<br>将vmlinux.raw加载到目标平台的合适地址（如ZRELADDR）处，并跳转到该地址开始执行内核代码。</p>
</li>
</ol>
<p>需要注意的是，具体的地址和步骤可能因平台和配置而有所不同。请根据实际情况进行相应的调整和适配。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.19-binutils工具集</title>
    <url>/2023/09/05/3-19-binutils%E5%B7%A5%E5%85%B7%E9%9B%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-19-1-编译器和binutils"><a href="#3-19-1-编译器和binutils" class="headerlink" title="3.19.1 编译器和binutils"></a>3.19.1 编译器和binutils</h1><p>编译器和binutils是GNU工具集（GNU Toolchain）中的两个重要组成部分。</p>
<p>GNU编译器（GCC）是GNU工具集中的一个核心组件，它是一款开源的编译器套件，支持多种编程语言（如C、C++、Objective-C、Fortran等）。GCC能够将源代码编译成可执行文件或库文件，它提供了词法分析、语法分析、优化、代码生成等功能，以及针对不同处理器架构的代码生成选项。</p>
<p>Binutils是GNU工具集中的另一个重要组件，它是一组用于二进制文件处理的工具集合。这些工具包括链接器（ld）、汇编器（as）、目标文件转换器（objcopy、objdump等）以及符号表处理工具（nm、readelf等）。Binutils提供了处理不同文件格式（如ELF、COFF等）的能力，可以将目标文件、可执行文件和库文件进行链接、转换和调试等操作。</p>
<p>GCC和Binutils通常一同使用，它们共同构成了GNU工具集，提供了完整的软件开发工具链。在编译过程中，GCC会生成中间代码或汇编代码，然后通过binutils工具集中的链接器将多个目标文件链接成最终的可执行文件或库文件。此外，binutils还提供了对生成的可执行文件进行调试和分析的工具，如objdump和readelf。</p>
<h1 id="3-19-2-常用的binutils工具"><a href="#3-19-2-常用的binutils工具" class="headerlink" title="3.19.2 常用的binutils工具"></a>3.19.2 常用的binutils工具</h1><p>以下是常用的binutils工具及其用途：</p>
<ol>
<li>as：汇编器，将汇编文件汇编为目标文件。</li>
<li>ld：链接器，将多个目标文件和库文件组合成一个可执行文件或共享库。</li>
<li>nm：列出目标文件中的符号（函数、变量等），包括其地址和类型。</li>
<li>size：列出目标文件的各个段（如代码段、数据段）的大小以及总大小。</li>
<li>strip：移除目标文件中的符号信息，可以用于减小文件大小和保护代码的机密性。</li>
<li>gprof：性能分析工具，用于生成程序的调用图表和性能统计数据。</li>
<li>ar：创建、修改和提取归档文件（静态库），用于将多个目标文件打包成一个库文件。</li>
<li>addr2line：将程序地址翻译成源文件名和行号，用于调试时定位代码中特定地址对应的源代码位置。</li>
<li>objcopy：用于将一种目标文件格式转换为另一种格式，比如将二进制文件转换为ELF格式。</li>
<li>objdump：显示目标文件的信息，包括可执行文件或库文件的反汇编代码、符号表、节表等。</li>
<li>readelf：显示有关ELF（Executable and Linkable Format）文件的详细信息，包括节表、符号表、动态链接信息等。</li>
<li>ranlib：用于创建一个归档文件（静态库）的索引，索引列出了归档文件中可重定位目标文件的所有符号。</li>
<li>strings：用于从给定的文件中输出不短于指定长度的所有可打印字符序列，对于目标文件，默认只打印初始化和加载部分的字符串。</li>
<li>libopcodes：一个库，用于处理处理器指令的可读文本版本（opcodes），可以用于解析和处理处理器指令。</li>
</ol>
<h1 id="3-19-3-readelf命令"><a href="#3-19-3-readelf命令" class="headerlink" title="3.19.3 readelf命令"></a>3.19.3 readelf命令</h1><p>readelf是一个常用的binutils工具，用于显示和分析ELF（Executable and Linkable Format）文件的信息。下面是readelf命令的一些常用参数及其说明：</p>
<ul>
<li>-a：显示完整的ELF文件头信息，包括ELF版本、目标体系结构、入口点地址等。</li>
<li>-h：读取并显示ELF文件头信息，包括ELF文件类型、目标体系结构、节头表偏移量等。</li>
<li>-S：读取并显示节头表（Section Headers）的信息，包括节的名称、类型、大小、偏移量等。</li>
<li>-s：显示符号表（Symbol Table）的内容，包括函数、变量、局部符号等。可以看到符号的名称、地址、大小等信息。</li>
<li>-e：显示目标文件的所有头信息，包括ELF文件头、程序头表（Program Headers）、节头表等。</li>
<li>-n：显示note段的信息，note段是用于存储与程序执行无关的附加信息的一种特殊节。</li>
<li>-d：显示dynamic section（动态节）的信息，包括动态链接器相关的信息，如动态链接库的依赖关系、符号重定位等。</li>
<li>-g：显示section group（节组）的信息，节组是一种特殊的ELF节，用于组织和管理其他节。</li>
</ul>
<h1 id="3-19-4-objdump用法"><a href="#3-19-4-objdump用法" class="headerlink" title="3.19.4 objdump用法"></a>3.19.4 objdump用法</h1><p>objdump是一个binutils工具，用于显示和分析目标文件的信息和反汇编代码。下面是objdump命令的一些常用参数及其说明：</p>
<ul>
<li>-X：输出目标文件的所有header信息，包括文件头、程序头表、节头表等。</li>
<li>-t：输出目标文件的符号表，显示函数、变量等符号的地址和大小。</li>
<li>-h：输出目标文件的节头表信息，包括节的名称、类型、大小、偏移量等。</li>
<li>-j section：仅反汇编指定的节（section），可以指定要反汇编的具体节的名称。</li>
<li>-s：将代码段反汇编，同时将反汇编代码和源码交替显示，方便对比源代码和反汇编结果。</li>
<li>-D：对二进制文件进行全局反汇编，反汇编所有的节（section）。</li>
<li>-d：反汇编代码段，仅反汇编目标文件的代码段。</li>
<li>-f：显示目标文件的文件头信息，包括ELF版本、目标体系结构、入口点地址等。</li>
<li>-S：显示目标文件的全部header信息，以及它们对应的16进制文件代码。</li>
</ul>
<h1 id="3-19-5-objcopy用法"><a href="#3-19-5-objcopy用法" class="headerlink" title="3.19.5 objcopy用法"></a>3.19.5 objcopy用法</h1><p>objcopy是一个binutils工具，主要用于拷贝目标文件的内容到另一个目标文件中，以及进行目标文件格式的转换。下面是objcopy命令的一些常用参数及其说明：</p>
<ul>
<li>-R name：从文件中删除所有名为name的段（section）。</li>
<li>-s：不拷贝源文件的重定位和符号信息到输出目标文件，只拷贝纯粹的代码和数据。</li>
<li>-g：不拷贝源文件的调试符号到输出目标文件，可以用于生成剥离调试信息的可执行文件。</li>
<li>-j section：只拷贝指定的节（section）到输出文件，可以指定要拷贝的具体节的名称。</li>
<li>-K symbol：从源文件拷贝名为symbol的符号，其他符号不进行拷贝。</li>
<li>-N symbol：不从源文件拷贝名为symbol的符号。</li>
<li>-L symbol：将符号symbol标记为文件内局部化，使其在外部不可见。</li>
<li>-W symbol：将符号symbol标记为弱符号，使其在链接时可以被覆盖。</li>
</ul>
<p>下面是一些使用示例，展示如何使用objcopy进行文件格式转换和瘦身操作：</p>
<ol>
<li><p>将ELF文件转换为BIN文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objcopy -O binary -R.comment -S uboot uboot.bin</span></span><br><span class="line">```</span><br><span class="line">这个命令将uboot.uboot.bin文件转换为原始的二进制文件uboot.bin。使用参数`-O binary`指定输出格式为二进制，`-R.comment`删除不需要的.comment节，`-S`指定不输出重定位和符号信息到目标文件。</span><br></pre></td></tr></table></figure>
</li>
<li><p>将BIN文件转换为HEX文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objcopy -I binary -O ihex uboot.bin uboot.hex</span></span><br><span class="line">```</span><br><span class="line">这个命令将uboot.bin文件转换为Intel Hex格式的uboot.hex文件。使用参数`-I binary`指定输入格式为二进制，`-O ihex`指定输出格式为Intel Hex。</span><br></pre></td></tr></table></figure>
</li>
<li><p>瘦身操作 - 去除不需要的信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objcopy -R .comment a.out slim_a.out</span></span><br><span class="line">```</span><br><span class="line">这个命令将目标文件a.out中的.comment节删除，生成瘦身后的目标文件slim_a.out。使用参数`-R .comment`指定删除.comment节。</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些示例展示了如何使用objcopy进行文件格式转换，从ELF到BIN、BIN到HEX，并且展示了如何使用objcopy进行瘦身操作，去除不需要的信息。根据具体需求，可以根据这些示例进行参数调整和使用。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.18-内核模块加载机制</title>
    <url>/2023/09/05/3-18-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-18-1-内核的加载"><a href="#3-18-1-内核的加载" class="headerlink" title="3.18.1 内核的加载"></a><strong>3.18.1 内核的加载</strong></h1><p>在Linux内核中，动态加载和初始化模块是通过系统调用<code>init_module</code>来完成的。这个系统调用位于<code>kernel/module.c</code>文件中。</p>
<p>下面是<code>init_module</code>系统调用的主要步骤：</p>
<ol>
<li>拷贝到内核（copy_module_from_user）：首先，内核从用户空间复制模块的代码和数据到内核空间。这样做是为了确保模块在内核中的存储是可访问和可执行的。</li>
<li>地址空间分配（layout_and_allocate）：内核为模块分配内存空间，并为模块的代码、数据和符号表等分配适当的地址空间。</li>
<li>符号解析（simplify_symbols）：内核对模块的符号进行解析，将符号与对应的地址进行关联。这包括模块内部的符号以及与其他模块或内核的符号之间的关联。</li>
<li>重定位（apply_relocations）：内核对模块进行重定位，将模块中的绝对地址修正为正确的运行时地址。这是为了确保模块可以正确地在内核中执行。</li>
<li>执行（complete_formation）：最后，模块的初始化过程完成，模块的入口点函数被调用，开始执行模块的功能。</li>
</ol>
<p>通过这些步骤，内核可以将模块加载到内核空间，并使其在内核中可用。加载和初始化模块使得内核能够动态地添加新的功能、驱动程序或文件系统，而无需重新编译整个内核。这提供了更大的灵活性和可扩展性，使得系统可以根据需要加载和卸载模块。</p>
<h1 id="3-18-2-内核模块和插件的异同"><a href="#3-18-2-内核模块和插件的异同" class="headerlink" title="3.18.2 内核模块和插件的异同"></a>3.18.2 内核模块和插件的异同</h1><p>内核模块和插件具有一些相同点，同时也有一些异同点。</p>
<p>相同点：</p>
<ol>
<li>动态链接：内核模块和插件都采用动态链接的方式，可以在运行时加载到内存中。这使得它们能够以模块化的方式扩展软件功能，而无需重新编译整个软件或内核。</li>
<li>空间分配、符号解析、重定位：内核模块和插件都需要进行空间分配、符号解析和重定位等步骤，以确保代码、数据和符号在加载后能够正确地运行和访问。</li>
</ol>
<p>异同点：</p>
<ol>
<li>运行环境：内核模块运行在内核空间，而插件运行在用户空间。内核空间是操作系统核心的一部分，具有更高的特权级别和更多的系统资源访问权限。用户空间是应用程序运行的环境。</li>
<li>依赖关系：内核模块不依赖于C库（如libc），因此在链接和重定位过程中，它们需要自行处理相关的操作。而应用程序的插件通常会依赖于C库，并通过C标准库的ld链接器来完成动态库的链接和重定位。</li>
<li>访问权限：内核模块可以直接访问和操作内核的数据结构和功能，因为它们运行在内核空间。而插件运行在用户空间，对于一些受限的系统资源和特权操作可能没有直接访问权限。</li>
</ol>
<p>总体而言，内核模块和插件都是利用动态链接的机制来扩展软件的功能。它们在加载、符号解析和重定位等方面有类似的工作原理，但由于运行环境和依赖关系的不同，它们在实现和使用上存在一些区别。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.17-开发一个插件</title>
    <url>/2023/09/05/3-17-%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="7-17-1-插件的工作原理"><a href="#7-17-1-插件的工作原理" class="headerlink" title="7.17.1 插件的工作原理"></a>7.17.1 插件的工作原理</h1><p>插件是一种用于软件扩展的机制，允许在不修改主程序逻辑框架的情况下，通过加载外部的动态链接库（共享库）来添加新的功能或增强软件的功能。</p>
<p>插件的本质就是共享库，它们以一种特定的组装形式存在，以便主程序能够动态加载和使用它们。一旦插件被加载，主程序可以通过调用插件中定义的函数或使用插件提供的接口来访问插件的功能。</p>
<p>插件的工作原理如下：</p>
<ol>
<li>主程序框架引用外部模块符号：主程序在编译时会引用插件可能提供的函数、接口或符号。这些符号在主程序中作为占位符存在，实际的实现在插件中。</li>
<li>动态加载和重定位：主程序在运行时使用系统调用（例如在Linux中使用dlopen函数）来显式加载插件的动态链接库。加载过程中，操作系统会进行动态链接和重定位，将插件的代码和数据映射到主程序的内存空间中。</li>
<li>访问插件功能：一旦插件被加载，主程序就可以通过调用插件中的函数或使用插件提供的接口来访问插件的功能。主程序可以根据需要动态加载、卸载或替换插件，从而实现软件的灵活扩展和功能更新。</li>
</ol>
<p>通过插件机制，软件的功能可以以模块化的方式组织和管理，实现更高的可扩展性和灵活性。同时，插件的使用也可以使软件的功能增值更加便捷，而无需重新编译和发布整个软件。</p>
<h1 id="7-17-2-显式加载动态库"><a href="#7-17-2-显式加载动态库" class="headerlink" title="7.17.2 显式加载动态库"></a>7.17.2 显式加载动态库</h1><p>在显式加载动态库时，可以使用dlopen函数打开动态链接库，该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flag)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>filename</code>参数是动态库文件的路径，可以是相对路径或绝对路径。</li>
<li>flag参数指定了加载动态库的行为和属性。常用的标志包括：<ul>
<li><code>RTLD_LAZY</code>：表示在解析动态库时，遇到未定义的符号不会导致程序退出，而是继续进行使用。</li>
<li><code>RTLD_NOW</code>：表示在解析动态库时，如果遇到未定义的符号，会立即退出。</li>
<li><code>RTLD_GLOBAL</code>：表示允许导出的符号可以被其他动态库引用。</li>
</ul>
</li>
</ul>
<p>dlopen函数返回一个操作句柄（<code>void *Handle</code>），可以用于后续对动态库的操作。</p>
<p>要获取动态对象（函数或变量）的地址，可以使用dlsym函数，该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">dlsym</span><span class="params">(<span class="type">void</span> *handle, <span class="type">const</span> <span class="type">char</span> *symbol)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>handle</code>参数是通过dlopen函数返回的动态库句柄。</li>
<li><code>symbol</code>参数是要获取地址的符号名称。</li>
</ul>
<p>dlsym函数会根据动态库句柄和符号名称返回符号对应的地址。一般情况下，我们需要定义一个符号类型的指针，将dlsym函数返回的地址赋值给该指针，以便后续使用。</p>
<p>以下是一个示例代码片段，演示了显式加载动态库并获取函数地址的过程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开动态链接库</span></span><br><span class="line"><span class="type">void</span> *Handle = dlopen(<span class="string">&quot;./libct.so&quot;</span>, RTLD_LAZY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取动态对象地址</span></span><br><span class="line"><span class="type">void</span> (*funcp)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">funcp = (<span class="type">void</span> (*)(<span class="type">int</span>, <span class="type">int</span>))dlsym(Handle, <span class="string">&quot;myfunc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，假设libct.so是动态库文件，myfunc是动态库中的函数名。通过dlopen函数打开动态库，然后使用dlsym函数获取myfunc函数的地址，并将其赋值给funcp指针，以便后续调用该函数。</p>
<p>需要注意的是，示例中的类型转换是为了将dlsym返回的地址转换为函数指针类型，以便正确调用函数。根据实际情况，类型转换的方式可能会有所不同。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.16-动态链接(3)-共享库</title>
    <url>/2023/09/05/3-16-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5-3-%E5%85%B1%E4%BA%AB%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-15-1-共享库的命名"><a href="#3-15-1-共享库的命名" class="headerlink" title="3.15.1 共享库的命名"></a>3.15.1 共享库的命名</h1><p>在Linux环境下，共享库的命名方式通常遵循以下格式：libname.so.X.Z。</p>
<ul>
<li>libname：表示库的名称，通常由开发者指定。</li>
<li>X：主版本号，表示库的重大升级。当主版本号发生变化时，表示库的接口发生了不兼容的变化，可能需要重新编译依赖该库的程序才能正常运行。</li>
<li>Z：发布版本号，表示库的发布版本。当发布版本号发生变化时，通常表示进行了错误修正、性能改进等，但没有增加新的接口，原有接口保持不变。</li>
</ul>
<p>例如，假设有一个名为libexample.so的共享库，其版本号为1.2.3，则库文件的命名可能是libexample.so.1.2.3。</p>
<p>次版本号（Y）在库的命名中没有直接体现，它通常用于表示库的增量升级，即增加一些新的接口符号，而原有的接口符号保持不变。次版本号的变化通常不会破坏与之前版本的兼容性，因此使用高版本的库通常可以向后兼容低版本的库。</p>
<h1 id="3-15-2-共享库软链接"><a href="#3-15-2-共享库软链接" class="headerlink" title="3.15.2 共享库软链接"></a>3.15.2 共享库软链接</h1><p>软链接（Symbolic link）是一个特殊类型的文件，它是一个指向另一个文件或目录的引用。在Linux系统中，软链接可以用来记录共享库的依赖关系，并且通常用于共享库的SO-NAME命名机制。</p>
<p>SO-NAME是共享库的一个命名约定，用于标识共享库的接口。它通常通过去除共享库文件名中的次版本号和发布版本号来得到。例如，如果一个共享库文件的名称是libexample.so.1.2.3，那么它的SO-NAME可能是libexample.so.1。</p>
<p>系统会在共享库文件所在的目录下创建一个与SO-NAME同名的软链接，该软链接指向具有相同主版本号的共享库文件中最新的次版本号和发布版本号。这样，依赖某个共享库的模块可以使用SO-NAME来引用该共享库，而不需要指定具体的版本号。这种方式有助于系统升级，因为只要保证新版本的共享库兼容旧版本的接口，依赖该库的模块就可以继续正常工作，无需修改代码。</p>
<p>使用SO-NAME和软链接的好处是，它提供了一种稳定的共享库接口，并简化了依赖管理。通过使用SO-NAME作为共享库的标识，系统可以方便地管理共享库的版本，并且可以在不破坏接口兼容性的情况下进行升级和替换。同时，依赖该共享库的模块可以通过引用SO-NAME来保持与共享库的连接，而不需要关注具体的版本号，从而提高了系统的灵活性和可维护性。</p>
<h1 id="3-15-3-共享库的路径"><a href="#3-15-3-共享库的路径" class="headerlink" title="3.15.3 共享库的路径"></a>3.15.3 共享库的路径</h1><p>在Linux系统中，共享库通常存放在以下三个主要路径：</p>
<ol>
<li>&#x2F;lib：该目录存放系统最关键和基础的共享库，例如动态链接器、C库、数学库等。这些库主要是用于&#x2F;bin、&#x2F;sbin下的程序运行以及系统启动所需要的库。这些共享库对于系统的正常运行非常重要。</li>
<li>&#x2F;usr&#x2F;lib：该目录存放非系统运行所需要的关键性共享库。这些库通常是开发过程中使用的一些共享库，包括开发工具链、编译器等。这些库一般不会被用户的程序或者Shell脚本直接使用，而是被开发工具链和编译器等系统工具所使用。</li>
<li>&#x2F;usr&#x2F;local&#x2F;lib：该目录主要存放第三方应用程序所需要的一些库。当用户安装自己编译或安装的软件时，这些软件通常会将其依赖的共享库安装到&#x2F;usr&#x2F;local&#x2F;lib目录下。这样做的好处是，可以将用户自定义的库与系统自带的库分开管理，避免冲突。</li>
</ol>
<h1 id="3-15-4-库的查找过程"><a href="#3-15-4-库的查找过程" class="headerlink" title="3.15.4 库的查找过程"></a>3.15.4 库的查找过程</h1><p>在Linux系统中，库的查找过程由动态链接器（dynamic linker）负责。以下是库的查找过程的基本步骤：</p>
<ol>
<li><p>ELF文件加载：当一个可执行的ELF文件被执行时，动态链接器（一般是&#x2F;lib&#x2F;ld-linux.so.x）会被加载并启动。</p>
</li>
<li><p>依赖关系查找：动态链接器会解析ELF文件的.dynamic段，查找该文件所依赖的共享库。</p>
</li>
<li><p>路径解析：根据共享库的路径信息，动态链接器会按照一定的顺序进行路径解析，以找到共享库文件。解析顺序如下：</p>
<ul>
<li>若路径是绝对路径，则直接到该绝对路径下查找共享库文件。</li>
<li>若路径是相对路径，则按照一定的顺序在以下目录中查找共享库文件：<ul>
<li>&#x2F;lib</li>
<li>&#x2F;usr&#x2F;lib</li>
<li>根据&#x2F;etc&#x2F;ld.so.conf配置文件中指定的目录</li>
</ul>
</li>
</ul>
<p>库目录缓存：为了加快库的查找速度，避免每次都进行路径解析，系统可以使用ldconfig命令生成一个缓存文件&#x2F;etc&#x2F;ld.so.cache。该缓存文件记录了系统中可用的共享库路径及其对应的共享库文件。动态链接器在查找库时会首先检查该缓存文件，并根据其中的路径信息进行查找。</p>
<ul>
<li>当新增、删除或更新共享库路径时，需要更新缓存文件，可以使用ldconfig命令进行更新。</li>
</ul>
</li>
</ol>
<h1 id="3-15-5-LD-LIBRARY-PATH"><a href="#3-15-5-LD-LIBRARY-PATH" class="headerlink" title="3.15.5 LD_LIBRARY_PATH"></a>3.15.5 LD_LIBRARY_PATH</h1><p>LD_LIBRARY_PATH是一个环境变量，它由若干个路径组成，每个路径之间用冒号”:”进行分隔。该环境变量用于临时改变程序运行时的共享库查找路径。</p>
<p>当一个程序在运行过程中需要加载共享库时，系统会按照一定的规则进行共享库的查找。这些规则包括默认的系统库路径、配置文件中指定的路径等。然而，通过设置LD_LIBRARY_PATH环境变量，可以临时修改共享库的查找路径，优先使用LD_LIBRARY_PATH中指定的路径。</p>
<p>当LD_LIBRARY_PATH环境变量被设置后，程序在加载共享库时会首先在LD_LIBRARY_PATH指定的路径中查找共享库文件，而不是按照默认的规则进行查找。如果找到了匹配的共享库文件，程序会使用该路径下的共享库进行链接和加载。</p>
<p>这个特性可以用于临时改变程序依赖的共享库查找路径，而不影响系统中的其他应用程序。一旦程序运行结束或者LD_LIBRARY_PATH环境变量被重置，系统将恢复到默认的共享库查找路径。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.15-动态链接(2)-全局符号表GOT</title>
    <url>/2023/09/05/3-15-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5-2-%E5%85%A8%E5%B1%80%E7%AC%A6%E5%8F%B7%E8%A1%A8GOT/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-15-1-表和结构"><a href="#3-15-1-表和结构" class="headerlink" title="3.15.1 表和结构"></a>3.15.1 表和结构</h1><p>下面是这些表和结构的简要介绍：</p>
<ol>
<li>.dynamic段：.dynamic段是一个特殊的段，它包含了动态链接器所需的信息。这些信息包括动态链接库的依赖关系、重定位表的位置、初始化函数等。动态链接器在加载可执行文件时会解析.dynamic段以获取这些信息。</li>
<li>动态符号表 (.dynsym)：动态符号表是一个表格，它记录了可执行文件或共享库中定义的所有动态符号。每个动态符号都有一个唯一的符号索引，可以用来在运行时进行符号解析和链接。动态符号表中的每个条目包含了符号名称、符号类型和符号值等信息。</li>
<li>动态链接重定位表 (PLT)：动态链接重定位表是一个重要的数据结构，用于处理在运行时动态链接的符号重定位。它包含了跳转指令和符号解析逻辑，用于在首次调用某个符号时进行符号解析和重定位。PLT中的每个条目包含了一个跳转指令和一个GOT表项的索引。</li>
<li>全局偏移表 (GOT)：全局偏移表是一个表格，用于存储全局符号的地址。GOT表的每个条目对应一个全局符号，它可以被动态链接器用来解析外部模块中的符号地址。GOT表的条目可能最初包含一个间接跳转指令，当符号地址被解析后，会被更新为具体的地址。</li>
</ol>
<h1 id="3-15-2-动态链接器"><a href="#3-15-2-动态链接器" class="headerlink" title="3.15.2 动态链接器"></a>3.15.2 动态链接器</h1><p>.interp：.interp是一个特殊的段，它包含了动态链接器的路径。当可执行文件被加载时，操作系统会使用.interp段中指定的路径来找到并加载动态链接器。这样可执行文件就能够正确地进行动态链接。</p>
<p>动态链接器是负责在程序运行时加载和链接共享库的系统组件。它负责解析程序的依赖关系，加载所需的共享库，并将其链接到程序的地址空间中。</p>
<p>.interp段是可执行文件中的一个特殊段，用于存放动态链接器的路径。该段中存储了一个字符串，指明了动态链接器的路径。当可执行文件被加载时，操作系统会根据.interp段中指定的路径找到并加载相应的动态链接器。</p>
<p>要查看.interp段的内容，可以使用命令 <code>readelf -p .interp a.out</code>（其中 <code>a.out</code> 是可执行文件的名称）。该命令会显示.interp段的内容，即动态链接器的路径。</p>
<p>动态链接器本质上也是一个共享库，它在程序运行之前首先需要进行自举（bootstrap），即对自身进行重定位。动态链接器通常由操作系统提供，并且在C标准库中实现，是GNU C库（Glibc）的一部分。Glibc是一个常用的C标准库实现，它包含了对动态链接器的实现。</p>
<p>通过动态链接器的工作，程序能够在运行时动态地加载和链接共享库，实现了模块化、可扩展和灵活的程序设计。动态链接器的存在使得共享库的使用更加方便，并提供了许多动态链接相关的功能，如符号解析、重定位和依赖管理。</p>
<h1 id="3-15-3-dynamic段"><a href="#3-15-3-dynamic段" class="headerlink" title="3.15.3 dynamic段"></a>3.15.3 dynamic段</h1><p>.dynamic段是可执行文件或共享库中的一个特殊段，它保存了动态链接器在加载和链接时所需的基本信息。这些信息包括：</p>
<ul>
<li>依赖的共享库：.dynamic段记录了程序或共享库所依赖的其他共享库的名称，使得动态链接器可以在加载时确定这些依赖关系，并加载相应的共享库。</li>
<li>动态链接符号表位置：.dynamic段指示了动态链接符号表的位置，该符号表包含了程序或共享库中定义的所有动态符号。动态链接器在加载时使用这个符号表来进行符号解析和链接。</li>
<li>动态链接字符串表的位置：.dynamic段也记录了动态链接字符串表的位置，这个字符串表包含了与动态链接相关的字符串，例如符号名称、共享库名称等。动态链接器使用这个字符串表来解析和处理动态链接相关的字符串。</li>
<li>动态链接重定位表位置：.dynamic段指定了动态链接重定位表的位置，这个重定位表用于在运行时进行动态链接的符号重定位。它包含了需要进行重定位的符号及其相关信息，使得动态链接器可以在加载时进行符号重定位操作。</li>
<li>共享库初始化代码位置：.dynamic段还包含了共享库初始化代码的位置信息，这些代码在共享库加载时被执行，用于执行一些初始化操作。</li>
</ul>
<p>.dynamic段的内容由多个结构体组成，这些结构体的定义可以在 <code>/usr/include/elf.h</code> 中找到。通过使用命令 <code>readelf -d xx.so</code>（其中 <code>xx.so</code> 是共享库文件的名称），可以查看.dynamic段的内容。这个命令会显示.dynamic段中的结构体信息，包括依赖的共享库、符号表位置、字符串表位置、重定位表位置等相关信息。</p>
<h1 id="3-15-4-动态链接符号表"><a href="#3-15-4-动态链接符号表" class="headerlink" title="3.15.4 动态链接符号表"></a>3.15.4 动态链接符号表</h1><p>动态链接符号表是在动态链接过程中使用的符号表，它与静态链接符号表有一些区别。下面是关于动态链接符号表的一些说明：</p>
<ul>
<li>动态链接符号表（.dynsym）：动态链接符号表是一个特殊的符号表，它只保存了与动态链接相关的符号信息，而不保存所有的符号定义和引用。它包含了程序或共享库中定义的所有动态符号，如函数、变量等。每个符号表条目包含了符号的名称、地址、大小、绑定属性等信息。</li>
<li>动态链接字符串表（.dynstr）：动态链接字符串表是动态链接符号表的辅助表，用于存储符号的名称。静态链接的符号表中的符号名称通常直接存储在符号表本身，但动态链接符号表中的符号名称存储在动态链接字符串表中。符号表（.dynsym）中的每个条目通过索引与字符串表（.dynstr）中的对应字符串关联起来。</li>
<li>符号哈希表：符号哈希表是动态链接文件中的一个段，用于提高程序在运行时查找符号的速度。它通过哈希算法将符号的名称映射到符号表中的条目，从而加快符号查找的效率。符号哈希表在动态链接过程中起到加速符号解析和查找的作用。</li>
</ul>
<p>要查看动态链接符号表和字符串表的内容，可以使用命令 <code>readelf -s a.out</code>（对于可执行文件）或 <code>readelf -sD xx.so</code>（对于共享库）来查看。这些命令会显示符号表中的条目，包括符号的名称、地址、大小、绑定属性等信息。通过对比符号表（.dynsym）和字符串表（.dynstr）中的索引，可以关联符号的名称和其他属性。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.14-动态链接(1)-与位置无关的代码</title>
    <url>/2023/09/05/3-14-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5-1-%E4%B8%8E%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-14-1-静态链接的缺点"><a href="#3-14-1-静态链接的缺点" class="headerlink" title="3.14.1 静态链接的缺点"></a>3.14.1 静态链接的缺点</h1><p>静态链接的确存在一些缺点，包括：</p>
<ol>
<li>可执行文件体积较大：由于静态链接将所有需要的代码和库函数都包含在可执行文件中，导致可执行文件的体积较大。如果多个程序都使用相同的静态库，会造成冗余的存储空间浪费。</li>
<li>内存占用较大：静态链接的可执行文件在运行时需要将所有的代码和数据加载到内存中。这意味着即使程序只用到了部分功能，也需要将整个程序加载到内存中，增加了内存占用的开销。</li>
<li>内存配置限制：对于内存配置较小的系统，静态链接的可执行文件可能会占用过多的内存，导致无法正常加载和运行。这是由于静态链接将所有代码和数据都打包在可执行文件中，无法根据系统的实际内存情况进行动态调整。</li>
<li>更新困难：当静态库或依赖的库发生更新时，需要重新编译和链接整个程序才能应用更新。这增加了更新和维护的复杂性，特别是在大型项目或多个项目共享同一静态库时。</li>
</ol>
<p>考虑到上述缺点，有些情况下可以选择使用动态链接库（共享库）。动态链接库在运行时被动态加载，可多个程序共享，减小了可执行文件的体积和内存占用。动态链接库的更新和维护也更加灵活，可以在不重新编译和链接整个程序的情况下进行库的更新。</p>
<h1 id="3-14-2-动态链接"><a href="#3-14-2-动态链接" class="headerlink" title="3.14.2 动态链接"></a>3.14.2 动态链接</h1><p>动态链接与静态链接不同，它推迟到程序运行时进行，而不是在链接过程中完成。在动态链接中，目标文件被编译成动态链接库（也称为共享库），而不是静态库。这些动态链接库在程序运行时被加载到内存中，并进行重定位。</p>
<p>动态链接的好处包括：</p>
<ol>
<li>节省内存：由于动态链接库是在运行时加载的，多个程序可以共享同一个动态链接库，避免了静态链接中的代码冗余和存储空间浪费。这样可以节省内存，并允许运行更大规模的程序。</li>
<li>简化升级：由于动态链接库是独立于可执行文件的，当库需要升级时，只需替换动态链接库文件，而不需要重新编译和链接整个程序。这使得库的升级更加方便和灵活，减少了对程序的影响。</li>
<li>提供更好的可维护性：动态链接库可以被多个程序共享，这意味着库的更新和维护只需在一个地方进行。这样有助于提高代码的可维护性，减少了重复的工作和潜在的错误。</li>
</ol>
<h1 id="3-14-3-程序执行过程"><a href="#3-14-3-程序执行过程" class="headerlink" title="3.14.3 程序执行过程"></a>3.14.3 程序执行过程</h1><p>在Linux命令行下运行一个程序的基本过程如下：</p>
<ol>
<li>操作系统给程序开启一个进程：当您在命令行中执行程序时，操作系统会为该程序创建一个新的进程，该进程将作为程序的执行环境。</li>
<li>动态链接器被映射到程序地址空间：动态链接器（通常是ld.so或ld-linux.so）是负责动态链接的系统组件。在程序启动时，操作系统将动态链接器映射到程序的地址空间中。</li>
<li>操作系统将控制权交给动态链接器：操作系统将控制权传递给动态链接器，使其可以开始执行动态链接的任务。</li>
<li>动态链接器解析未确定符号和动态库链接：动态链接器首先会解析可执行文件中的未确定符号，这些符号是指在编译时无法确定其地址的符号（如函数或变量）。动态链接器会查找并加载包含这些符号定义的动态库。</li>
<li>加载动态库并进行重定位：动态链接器会加载需要链接的动态库，并对这些库进行重定位操作。重定位是将动态库中的符号引用与实际的符号定义进行匹配，以确保程序能够正确地访问所需的函数和数据。</li>
<li>动态链接器将控制权交给可执行程序：一旦动态链接器完成了解析和重定位的工作，它将控制权交还给可执行程序。此时，可执行程序中的所有符号引用都已经解析完毕，并且程序可以开始运行。</li>
<li>可执行程序开始执行：控制权回到可执行程序，它会按照程序的逻辑开始执行，调用所需的函数和访问数据。</li>
</ol>
<p>在静态编译的情况下，可执行文件中包含了所有需要的代码和库函数，因此它是独立的、自包含的。以下是关于静态编译可执行文件和动态链接库的一些说明：</p>
<ol>
<li>可执行文件的加载和运行地址：<ul>
<li>静态编译的可执行文件在加载到进程地址空间时，通常会被加载到一个固定的运行地址。这是因为在编译和链接时，所有的符号引用已经被解析并确定了其最终的地址。</li>
<li>链接地址和运行地址是相同的，因此可执行文件在运行时可以直接通过固定的地址访问到所需的函数和数据。</li>
</ul>
</li>
<li>动态链接库的加载和运行地址：<ul>
<li>动态链接库（共享库）在加载到内存中时，其加载地址是由操作系统动态分配的。加载器根据当前进程的地址空间空闲情况，选择一个适当的地址来加载动态库。</li>
<li>动态库被装载到内存中的地址可以是任意的，并不需要与其他库或可执行文件的地址相同。这是因为动态库的地址信息会被动态链接器处理和重定位，以确保库中的符号引用与实际的符号定义相匹配。</li>
</ul>
</li>
</ol>
<p>动态链接库被装载到内存中的地址可变的主要原因是为了避免不同进程之间的冲突。由于多个进程可以同时运行，每个进程都有自己的地址空间，因此需要动态分配适当的地址来加载动态库，以避免地址冲突和重复使用相同的地址。</p>
<h1 id="3-14-4-装载时重定位"><a href="#3-14-4-装载时重定位" class="headerlink" title="3.14.4 装载时重定位"></a>3.14.4 装载时重定位</h1><p>装载时重定位是动态链接过程中的一项关键任务，它的基本思想是将对绝对地址的引用推迟到运行时进行解析和重定位。以下是装载时重定位的基本原理：</p>
<ol>
<li>推迟地址解析和重定位：在可执行文件中，对于动态库中的函数或变量的引用通常是使用绝对地址进行表示的。而在静态链接时，这些绝对地址是无法确定的，因为动态库的加载地址是在运行时动态分配的。因此，装载时重定位的基本思想是将对绝对地址的引用推迟到运行时去解析和重定位。</li>
<li>动态库加载和地址确定：当动态库被加载到内存中时，操作系统会为其分配一段合适的地址空间，并将库中的函数和变量映射到该地址空间中。此时，动态库中的每个符号都有了确定的地址。</li>
<li>可执行文件的重定位操作：一旦动态库的地址确定，装载时重定位会将可执行文件中对动态库中函数或变量的绝对地址引用进行重定位操作。具体而言，它会将绝对地址替换为实际的动态库中的地址，以确保可执行文件能够正确地访问所需的函数和变量。</li>
</ol>
<p>实现装载时重定位的方法有多种，编译器如GCC在生成共享动态链接库时可以使用<code>--shared</code>参数。这样生成的库在运行时会由动态链接器进行加载，并进行相应的地址解析和重定位操作。</p>
<p>通过推迟地址解析和重定位到运行时，装载时重定位实现了动态链接的灵活性和可扩展性。它允许不同的进程在加载同一个动态库时，根据其实际地址空间的情况进行地址分配和重定位，确保了符号的正确链接和访问。</p>
<h1 id="3-14-5-命令"><a href="#3-14-5-命令" class="headerlink" title="3.14.5 命令"></a>3.14.5 命令</h1><p>使用ldd命令可以查看一个可执行文件所需要的动态链接库</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309060823892.png" alt="image-20230906082331845"></p>
<h1 id="3-14-6-与地址无关的代码"><a href="#3-14-6-与地址无关的代码" class="headerlink" title="3.14.6 与地址无关的代码"></a>3.14.6 与地址无关的代码</h1><p>地址无关代码（Position-Independent Code，PIC）是一种技术，它使得代码可以在不进行重定位的情况下在不同的地址空间中执行。以下是地址无关代码的一些特点和实现方式：</p>
<p>特点：</p>
<ol>
<li>可以在任意地址加载和执行：地址无关代码可以在内存中的任意地址加载，并且无需进行重定位操作，就可以正确地执行。</li>
<li>与地址无关的指令：地址无关代码将需要修改的部分指令与数据分离，数据可以与需要修改的指令放在一起，而其余指令则不依赖于具体的地址，实现了与地址无关的特性。</li>
<li>被多个进程共享：地址无关代码可以被多个进程共享，每个进程都有自己的数据和需要修改的指令的副本，互不影响。</li>
</ol>
<p>实现方式：</p>
<ol>
<li>编译时生成位置无关代码：在编译阶段，可以使用编译器的参数来生成位置无关代码。对于GCC编译器，可以使用<code>-fPIC</code>参数来生成位置无关代码的目标文件。例如，使用命令<code>gcc -fPIC -c main.c</code>可以生成一个位置无关的目标文件。</li>
<li>使用相对寻址和间接寻址：地址无关代码使用相对寻址和间接寻址来访问数据和需要修改的指令。相对寻址是指使用相对于当前指令的偏移量来访问数据，而不是使用绝对地址。间接寻址则是通过间接引用来访问数据，而不是直接使用数据的地址。</li>
</ol>
<p>通过以上的实现方式，地址无关代码可以实现在不同的地址空间中加载和执行，而无需进行重定位操作。这使得地址无关代码可以被多个进程共享，并且具有较高的灵活性和可移植性。</p>
<h1 id="3-14-5-模块内部相对寻址"><a href="#3-14-5-模块内部相对寻址" class="headerlink" title="3.14.5 模块内部相对寻址"></a>3.14.5 模块内部相对寻址</h1><p>ARM相对寻址是一种使用PC作为基址，并将指令中的地址码段作为偏移量的寻址方式。通过将PC和偏移量相加，可以得到操作数的有效地址。这种寻址方式常见于ARM汇编语言中的B&#x2F;BL和ADR&#x2F;ADRL指令。</p>
<p>例如，考虑以下示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B LOOP</span><br><span class="line">.LOOP MOV R0, #1</span><br><span class="line">MOV R1, R0</span><br></pre></td></tr></table></figure>

<p>在这个例子中，B LOOP指令会跳转到标签LOOP处执行。相当于使用相对寻址方式进行跳转。</p>
<p>相对寻址的等效手动指令是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD PC, PC, #OFFSET</span><br></pre></td></tr></table></figure>

<p>其中OFFSET是B LOOP指令地址与LOOP标签地址之间的偏移量。B指令的前后跳转范围是[0, 32M]。</p>
<p>通过这种相对寻址方式，可以将跳转目标限制在指令附近的相对范围内，而不是使用绝对地址。这样可以增加代码的灵活性和可移植性。</p>
<h1 id="3-14-6-模块外部GOT表"><a href="#3-14-6-模块外部GOT表" class="headerlink" title="3.14.6 模块外部GOT表"></a>3.14.6 模块外部GOT表</h1><p>动态链接的核心GOT表问题是如何处理引用外部模块的符号地址无关。当一个模块需要引用其他模块中定义的符号（函数、变量等）时，如何确保在运行时能够正确找到这些符号的地址是一个关键问题。</p>
<p>动态链接的核心思想是使用全局偏移表（Global Offset Table，GOT）来解决这个问题。在链接时，被引用的外部模块的符号地址被存储在GOT中。</p>
<p>具体而言，当一个模块需要引用外部模块的符号时，它并不直接使用符号的地址，而是通过查找GOT表来间接获取符号的地址。GOT表中的每个表项对应一个被引用的符号，存储了该符号的地址或者加载该符号地址的指令。</p>
<p>在链接时，GOT表的位置已经确定，因此在运行时可以通过GOT表来获取外部符号的地址，而不需要硬编码具体的地址。</p>
<p>使用GOT表的好处是，它使得模块间的符号引用变得独立于具体的内存布局，从而增加了模块的可移植性和灵活性。当外部模块的地址发生变化时，只需要更新GOT表中对应的表项即可，而不需要修改引用该符号的模</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.13-链接静态库</title>
    <url>/2023/09/05/3-13-%E9%93%BE%E6%8E%A5%E9%9D%99%E6%80%81%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-13-1-静态库"><a href="#3-13-1-静态库" class="headerlink" title="3.13.1 静态库"></a>3.13.1 静态库</h1><p>静态库是一种包含预编译目标文件的归档文件，它可以被多个程序共享和链接。归档文件通常具有<code>.a</code>的文件扩展名，例如<code>libtest.a</code>。</p>
<h1 id="3-13-2-静态库制作的步骤"><a href="#3-13-2-静态库制作的步骤" class="headerlink" title="3.13.2 静态库制作的步骤"></a>3.13.2 静态库制作的步骤</h1><p>制作静态库的步骤如下：</p>
<ol>
<li>编译源代码生成目标文件：首先，将源代码编译成目标文件（<code>.o</code>文件）。例如，<code>x.c</code>和<code>xx.c</code>分别编译成<code>x.o</code>和<code>xx.o</code>。</li>
<li>创建归档文件：使用<code>ar</code>工具创建归档文件。命令格式为<code>ar rcs &lt;库文件名&gt; &lt;目标文件1&gt; &lt;目标文件2&gt; ...</code>。例如，使用命令<code>ar rcs libtest.a x.o xx.o</code>将<code>x.o</code>和<code>xx.o</code>归档到<code>libtest.a</code>文件中。</li>
</ol>
<h1 id="3-13-3-静态库链接的步骤"><a href="#3-13-3-静态库链接的步骤" class="headerlink" title="3.13.3 静态库链接的步骤"></a>3.13.3 静态库链接的步骤</h1><p>链接静态库的步骤如下：</p>
<ol>
<li>编写主程序：创建一个包含主程序逻辑的源文件，例如<code>main.c</code>。</li>
<li>指定头文件路径和库文件路径：使用编译器选项指定头文件和库文件的搜索路径。例如，使用选项<code>-I./include</code>指定头文件搜索路径为<code>./include</code>，使用选项<code>-L./lib</code>指定库文件搜索路径为<code>./lib</code>。</li>
<li>链接静态库：使用编译器选项<code>-l&lt;库名&gt;</code>指定要链接的静态库。例如，使用选项<code>-ltest</code>将<code>libtest.a</code>静态库链接到主程序中。</li>
</ol>
<p>完整的链接命令为<code>gcc main.c -I./include -L./lib -ltest</code>。该命令会将<code>main.c</code>编译成目标文件，并链接<code>libtest.a</code>静态库生成可执行文件。</p>
<p>通过制作和链接静态库，可以将常用的函数和模块封装为可重用的代码库，提高代码的复用性和可维护性。</p>
<h1 id="3-13-4-静态库的问题"><a href="#3-13-4-静态库的问题" class="headerlink" title="3.13.4 静态库的问题"></a>3.13.4 静态库的问题</h1><p>链接静态库可能会带来以下问题：</p>
<ol>
<li>可执行体积增大：当链接静态库时，所有库中的函数都会被组装到最终的可执行文件中，无论是否使用到这些函数。这会导致可执行文件的体积增大，尤其是当静态库包含大量函数时。</li>
<li>冗余代码：由于静态库中的所有函数都会被链接到可执行文件中，可能会包含一些未使用的函数，从而造成代码的冗余。这会增加可执行文件的大小，并且在一些资源受限的环境中可能会浪费存储空间。</li>
<li>更新困难：如果静态库中的函数发生变化，需要重新编译和链接整个程序才能更新。这会增加代码维护的复杂性，并且在多个项目中使用同一静态库时，每个项目都需要进行重新编译和链接。</li>
</ol>
<p>解决上述问题的一种方法是将每个函数的实现放在单独的源文件中，然后将这些源文件编译成对应的目标文件，最后将所有的目标文件归档到静态库中。这样做可以避免将未使用的函数链接到最终的可执行文件中，减小可执行文件的体积并提高代码的可维护性。</p>
<p>这种方法的基本原理是，编译器的基本单位是文件，而链接器的基本单位是目标文件。当引用一个目标文件中的符号时，链接器会将整个目标文件进行链接，将引用的符号和相关的代码组装到最终的可执行文件中。</p>
<p>举例来说，假设有以下几个源文件：</p>
<ul>
<li><code>func1.c</code>：包含函数<code>func1</code>的实现</li>
<li><code>func2.c</code>：包含函数<code>func2</code>的实现</li>
<li><code>main.c</code>：包含程序的主函数</li>
</ul>
<p>首先，分别将<code>func1.c</code>、<code>func2.c</code>和<code>main.c</code>编译成对应的目标文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -c func1.c -o func1.o</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -c func2.c -o func2.o</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -c main.c -o main.o</span></span><br></pre></td></tr></table></figure>

<p>然后，将这些目标文件归档到静态库中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ar rcs libtest.a func1.o func2.o</span></span><br></pre></td></tr></table></figure>

<p>最后，链接主程序并使用静态库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.o -L. -ltest -o executable</span></span><br></pre></td></tr></table></figure>

<p>这样，只有主程序中实际引用的函数会被链接到最终的可执行文件中，减小了可执行文件的体积。</p>
<p>Glibc（GNU C Library）就是使用类似的方法实现的。它将每个函数的实现放在单独的源文件中，然后将这些源文件编译成对应的目标文件，并将目标文件归档到一个静态库中。这样，在链接时只会将程序实际使用的函数链接到最终的可执行文件中，提高了程序的效率和可维护性。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.12-main函数入口分析</title>
    <url>/2023/09/05/3-12-main%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="7-12-1-main函数入口"><a href="#7-12-1-main函数入口" class="headerlink" title="7.12.1 main函数入口"></a>7.12.1 main函数入口</h1><p>编译器对程序入口有以下规定：</p>
<ol>
<li>缺省程序入口：编译器默认的程序入口是<code>_start</code>符号，而不是<code>main</code>函数。<code>_start</code>符号是由编译器生成的一个特殊符号，它标识程序的入口点。在程序启动时，操作系统会将控制权转移到<code>_start</code>符号所代表的代码位置。</li>
<li><code>main</code>函数作为入口点：<code>main</code>函数是一个被C标准库调用的符号，用来告诉编译器在一个项目中哪里是程序的入口点。程序员需要遵守这个约定，将程序的逻辑代码放在<code>main</code>函数中，在执行<code>main</code>函数之前进行一些准备工作。</li>
</ol>
<p>在程序启动时，编译器会进行以下操作：</p>
<ul>
<li>设置堆栈指针：编译器会设置栈指针，以确保函数调用和局部变量的正确处理。</li>
<li>初始化静态变量和全局变量：编译器会初始化静态变量和全局变量，即将它们所占用的数据段（data segment）中的内容赋初值。</li>
<li>BSS段赋初值：BSS段中的变量会被初始化为默认值。例如，<code>int</code>类型的变量会被初始化为0，<code>bool</code>类型会被初始化为<code>FALSE</code>，指针会被初始化为<code>NULL</code>。</li>
<li>传递参数给<code>main</code>函数：编译器会将命令行参数（<code>argc</code>、<code>argv</code>等）传递给<code>main</code>函数，并开始执行<code>main</code>函数中的代码。</li>
</ul>
<h1 id="7-12-2-CRT运行库"><a href="#7-12-2-CRT运行库" class="headerlink" title="7.12.2 CRT运行库"></a>7.12.2 CRT运行库</h1><p>CRT是C Runtime（运行时）的缩写，也称为C运行库。它是一组库函数和运行时环境，用于支持和管理C语言程序的执行。</p>
<p>CRT的主要功能包括：</p>
<ol>
<li>实现C标准库函数：CRT实现了C标准库中定义的各种函数，例如输入输出函数（如printf、scanf）、字符串处理函数（如strcpy、strlen）、内存管理函数（如malloc、free）等。这些函数提供了常用的操作和功能，方便程序员开发C语言程序。</li>
<li>执行初始化操作：CRT负责在程序执行之前进行一系列的初始化操作。这包括设置基本的堆栈环境和进程环境，准备动态库的加载和释放，进行动态库的初始化和清理等工作。</li>
<li>调用main函数：CRT负责给main函数传递参数，并调用main函数开始执行程序的主要逻辑。它将命令行参数（如argc、argv）传递给main函数，以便程序可以根据需要进行处理。</li>
<li>处理程序退出：在main函数执行完成后，CRT会调用exit函数，用于处理程序的退出。exit函数会执行一些清理操作，例如关闭文件、释放资源等，并将控制权返回给操作系统。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.11-BSS段的处理</title>
    <url>/2023/09/05/3-11-BSS%E6%AE%B5%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-11-1-bss段"><a href="#3-11-1-bss段" class="headerlink" title="3.11.1 bss段"></a>3.11.1 bss段</h1><p>BSS（Block Started by Symbol）段是可执行文件或目标文件中的一个段（section），用于存储未初始化的全局变量和静态局部变量。BSS段具有以下特点：</p>
<ol>
<li>存储未初始化的变量：BSS段用于存储未显式初始化的全局变量和静态局部变量。这些变量在编译时没有赋予初始值，因此它们的存储空间可以在程序运行时动态地分配和初始化。</li>
<li>不占目标文件空间：在目标文件中，BSS段不占用实际的空间。这是因为BSS段中的变量在编译时并没有实际的数值，所以在目标文件中只需记录BSS段的大小和位置信息。</li>
<li>运行时分配空间：当可执行文件被加载到内存中运行时，操作系统会为BSS段分配实际的内存空间。这时，BSS段中的变量将被初始化为默认值（通常是0），以确保它们的初始状态是可预测的。</li>
<li>节省存储资源：BSS段的设计初衷是为了节省存储资源。在早期计算机系统中，存储资源非常昂贵，因此将未初始化的变量放在BSS段中可以减少目标文件的大小，节省磁盘空间。</li>
<li>记录BSS段信息：BSS段的总大小通常会在节头表（Section Header Table）中进行记录。节头表是目标文件格式中的一部分，它包含了关于各个段的信息，包括大小、位置等。此外，在符号表（Symbol Table）中也会记录每个变量的大小和地址等信息。</li>
</ol>
<h1 id="3-11-2-数据段和BSS段"><a href="#3-11-2-数据段和BSS段" class="headerlink" title="3.11.2 数据段和BSS段"></a>3.11.2 数据段和BSS段</h1><p>数据段和BSS段是可执行文件或目标文件中用于存储变量数据的段。它们在编译系统中的处理流程是相同的，但有一些差异。</p>
<p>数据段用于存储已经初始化的全局变量和静态局部变量，这些变量在编译时已经赋予了初始值。数据段在可执行文件中占据实际的存储空间，并在程序运行时保持其初始值。</p>
<p>BSS段设计的初衷是为了减少文件体积和节省磁盘资源。它用于存储未初始化的全局变量和静态局部变量，这些变量在编译时没有初始值。在目标文件中，BSS段不占用实际的存储空间，只记录其大小和位置信息。当可执行文件被加载到内存中运行时，操作系统会为BSS段分配实际的存储空间，并将其中的变量初始化为默认值。</p>
<p>总的来说，数据段和BSS段都是用于存储变量数据的段。数据段存储已初始化的变量，占据实际的存储空间，而BSS段存储未初始化的变量，不占用实际的存储空间。它们在编译系统中的处理流程相同，但在可执行文件中的表现有所不同。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.10-程序的运行</title>
    <url>/2023/09/05/3-10-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-10-1-程序的运行"><a href="#3-10-1-程序的运行" class="headerlink" title="3.10.1 程序的运行"></a>3.10.1 程序的运行</h1><p>在操作系统环境下，可执行文件通常是以ELF（Executable and Linkable Format）格式存储的。ELF文件是一种可执行文件格式，包含了程序的机器代码、数据、符号表以及其他与程序执行相关的信息。运行可执行ELF文件需要依赖操作系统提供的执行环境和系统调用。</p>
<p>在裸机环境下，即没有操作系统的情况下，常见的可执行文件格式是BIN（Binary）或HEX（Intel Hexadecimal）文件。这些文件包含了程序的机器代码，通常是一系列的二进制指令。</p>
<p>运行BIN或HEX文件需要将其加载到裸机环境中执行，这通常涉及以下步骤：</p>
<ol>
<li>将BIN&#x2F;HEX文件加载到目标设备：<ul>
<li>将BIN文件直接复制到目标设备的存储介质上，或者通过特定的通信方式将HEX文件发送到目标设备。</li>
</ul>
</li>
<li>配置目标设备的执行环境：<ul>
<li>在裸机环境中，没有操作系统提供的运行时环境，因此需要手动配置目标设备的执行环境。</li>
<li>这包括设置适当的启动地址、堆栈地址、中断向量表等。</li>
</ul>
</li>
<li>执行加载的程序：<ul>
<li>在裸机环境中，程序的执行通常是从特定的启动地址开始。</li>
<li>目标设备会按照启动地址开始执行加载的程序，即执行BIN&#x2F;HEX文件中的机器代码指令。</li>
</ul>
</li>
</ol>
<h2 id="3-10-2-可执行ELF文件"><a href="#3-10-2-可执行ELF文件" class="headerlink" title="3.10.2 可执行ELF文件"></a>3.10.2 可执行ELF文件</h2><p>可执行的ELF文件在操作系统环境下执行时，会经过加载器的处理。加载器负责将可执行文件加载到内存中，并进行相关的操作，最后跳转到程序入口处运行该程序。</p>
<p>以下是与可执行ELF文件加载相关的一些概念和信息：</p>
<ol>
<li>镜像加载地址：<ul>
<li>可执行ELF文件在内存中的加载地址，也称为镜像加载地址或基址。</li>
<li>加载器将可执行文件的代码段、数据段等内容加载到内存时，会指定一个合适的地址作为加载地址，将文件映射到该地址开始的内存空间。</li>
</ul>
</li>
<li>程序头表：<ul>
<li>可执行ELF文件中包含一个程序头表（Program Header Table），记录了不同段的信息和在内存中的加载位置。</li>
<li>程序头表指定了可执行文件镜像加载到内存中的地址。</li>
<li>每个程序头表项描述了一个段（如代码段、数据段等），包括段的类型、文件偏移、在文件中的大小、在内存中的虚拟地址等信息。</li>
</ul>
</li>
<li>ELF文件头基本信息：<ul>
<li>ELF文件的开头是一个ELF文件头（ELF Header），包含了关于该可执行文件的基本信息。</li>
<li>ELF文件头中的一些重要字段包括文件类型、运行平台（操作系统和处理器架构）、程序入口地址等。</li>
<li>文件类型字段指示该文件是可执行文件、共享库还是目标文件。</li>
<li>运行平台字段标识了目标操作系统和处理器架构。</li>
<li>程序入口地址指示了程序在执行时的起始执行点，加载器会跳转到该地址开始执行程序。</li>
</ul>
</li>
</ol>
<h1 id="3-10-3-Linux内存映像"><a href="#3-10-3-Linux内存映像" class="headerlink" title="3.10.3 Linux内存映像"></a>3.10.3 Linux内存映像</h1><p>在Linux环境下，运行可执行文件涉及到创建进程和建立虚拟地址空间与可执行文件的映射关系。下面是在Linux环境下运行可执行文件的主要步骤：</p>
<ol>
<li>创建一个独立的虚拟地址空间：<ul>
<li>当调用<code>execve</code>函数启动加载器时，操作系统会为新进程创建一个独立的虚拟地址空间。</li>
<li>虚拟地址空间是进程独立使用的内存空间，包括代码段、数据段、堆、栈等区域。</li>
</ul>
</li>
<li>读取可执行文件头，建立映射关系：<ul>
<li>加载器会读取可执行文件的文件头，其中包含了关于该文件的一些基本信息，例如入口地址、段的大小等。</li>
<li>加载器将可执行文件的不同段（如代码段、数据段）映射到进程的虚拟地址空间中的相应区域。</li>
<li>这样，进程的虚拟地址空间中的某些区域就与可执行文件的对应部分建立了映射关系。</li>
</ul>
</li>
<li>设置PC指针为可执行文件的入口地址，启动运行：<ul>
<li>在建立好虚拟地址空间与可执行文件的映射关系之后，加载器会将程序计数器（PC）指针设置为可执行文件的入口地址。</li>
<li>入口地址指示了程序在执行时的起始执行点。</li>
<li>加载器启动运行，让进程从可执行文件的入口地址开始执行。</li>
</ul>
</li>
</ol>
<h1 id="3-10-4-MMU"><a href="#3-10-4-MMU" class="headerlink" title="3.10.4 MMU"></a>3.10.4 MMU</h1><p>MMU（Memory Management Unit，内存管理单元）是计算机系统中的一个硬件组件，负责虚拟地址与物理地址之间的转换。它是操作系统实现虚拟内存的关键部分。</p>
<p>在CPU管脚的地址信号中，传递的是物理地址，即直接对应到计算机系统中的物理内存地址。但当启用MMU后，操作系统运行在虚拟地址空间上，这就涉及到虚拟地址与物理地址的转换。</p>
<p>MMU的主要用途包括：</p>
<ol>
<li>虚拟内存：MMU负责将进程使用的虚拟地址映射到物理内存中的实际地址。通过虚拟内存技术，操作系统可以将部分进程的数据和代码存储在辅助存储设备（如硬盘）上，只在需要时加载到物理内存中。这样，操作系统可以运行比实际物理内存大的程序，提高系统的可用性和性能。</li>
<li>内存保护：MMU允许操作系统为不同的内存块设置不同的读写权限。通过在虚拟地址空间和物理地址空间之间建立映射关系，并设置相应的访问权限，可以实现对内存的保护，防止进程越界访问或修改其他进程的内存数据。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.9-链接过程(3)-重定位</title>
    <url>/2023/09/05/3-9-%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B-3-%E9%87%8D%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-9-1-重定位"><a href="#3-9-1-重定位" class="headerlink" title="3.9.1 重定位"></a>3.9.1 重定位</h1><p>重定位是链接过程中的核心步骤之一，它的主要目的是修正指令中的符号地址，使得程序可以正确地访问和调用其他模块或库中的函数和变量。</p>
<p>在链接过程中，重定位完成以下任务：</p>
<ol>
<li>地址空间分配：<ul>
<li>在链接过程中，编译器和链接器会为程序分配地址空间，包括代码段、数据段、堆、栈等。</li>
<li>重定位阶段负责将各个模块的代码段和数据段中的地址修正为最终的实际地址，确保模块之间的地址空间不发生冲突。</li>
</ul>
</li>
<li>符号解析：<ul>
<li>在链接过程中，各个模块之间可能存在对函数和变量的引用或调用。</li>
<li>重定位阶段负责解析这些引用，找到对应的函数或变量的实际地址，并将其填充到引用的位置，以便程序在执行时可以正确访问和调用。</li>
</ul>
</li>
</ol>
<h1 id="3-9-2-重定位过程1"><a href="#3-9-2-重定位过程1" class="headerlink" title="3.9.2 重定位过程1"></a>3.9.2 重定位过程1</h1><p>重定位过程是在链接过程中完成的，它涉及多个步骤和数据结构：</p>
<ol>
<li>汇编阶段：<ul>
<li>在汇编阶段，汇编器会将源代码转换为机器代码，并生成目标模块。</li>
<li>当汇编器遇到未定义的符号（外部定义的函数、变量、库函数引用等），它会认为这些符号在其他地方定义，不会报错。</li>
<li>汇编器会收集这些未定义符号，并生成一个重定位表（relocation table），用于告诉链接器这些符号不在当前模块中定义，可能在其他文件或库中定义，需要在链接时进行解析。</li>
</ul>
</li>
<li>段与重定位表：<ul>
<li>目标模块通常被划分为多个段，如代码段、数据段等。</li>
<li>在每个段中，可能存在对其他文件或库中定义的函数或变量的引用。</li>
<li>汇编器会为每个段生成相应的重定位表，记录需要重定位的符号及其对应的位置信息。</li>
</ul>
</li>
<li>重定位表的生成：<ul>
<li>重定位表是一个数据结构，用于记录需要进行重定位的各种符号。</li>
<li>对于每个需要重定位的符号，重定位表会记录符号的类型（函数或变量）、位置信息（段偏移量或地址）等。</li>
<li>链接器在链接过程中会根据重定位表的信息，解析和修正这些符号的地址，使得它们指向正确的位置。</li>
</ul>
</li>
</ol>
<h1 id="3-9-3-重定位过程2"><a href="#3-9-3-重定位过程2" class="headerlink" title="3.9.3 重定位过程2"></a>3.9.3 重定位过程2</h1><p>重定位表是在ELF文件中用于记录需要进行重定位的符号及其相关信息的数据结构。在一个可重定位的ELF文件中，每个需要重定位的段都会有一个对应的重定位表，例如<code>.rel.text</code>和<code>.rel.data</code>。</p>
<p>重定位表本身也是一个段，因此也被称为重定位段。通过查看重定位表，我们可以了解在链接过程中需要进行重定位的符号以及它们在代码中的偏移位置。</p>
<p>重定位表的构成如下所示（对于32位ELF文件）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf32_Rel</span> &#123;</span></span><br><span class="line">    Elf32_Addr r_offset;  <span class="comment">// 需要重定位的项在代码中的偏移位置</span></span><br><span class="line">    Elf32_Word r_info;    <span class="comment">// 重定位类型和符号索引</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，<code>r_offset</code>字段指定了需要重定位的项在代码中的偏移位置，<code>r_info</code>字段包含了重定位类型和符号索引。</p>
<p>通过解析重定位表中的信息，链接器可以根据符号索引找到对应的符号表项，并根据重定位类型进行相应的修正，使得符号的地址指向正确的位置。</p>
<p>要查看一个ELF文件的重定位表，可以使用工具如<code>arm-linux-gnueabi-objdump</code>或<code>arm-linux-gnueabi-readelf</code>，并指定相应的选项来打印出重定位表的内容和相关信息。</p>
<h1 id="3-9-4-重定位过程3"><a href="#3-9-4-重定位过程3" class="headerlink" title="3.9.4 重定位过程3"></a>3.9.4 重定位过程3</h1><p>在链接过程中，重定位过程涉及修改符号地址，通过读取各个目标文件中的重定位信息（重定位表）来进行符号重定位，即修改指令中的符号地址。</p>
<p>具体步骤如下：</p>
<ol>
<li>读取重定位信息：<ul>
<li>链接器会读取每个目标文件中的各个段的重定位信息，通常是通过读取重定位表来获取这些信息。</li>
<li>重定位表记录了需要进行重定位的符号在代码中的位置以及相关的重定位类型和符号索引。</li>
</ul>
</li>
<li>符号重定位：<ul>
<li>链接器根据重定位表中的信息，确定各个重定位符号的新地址。</li>
<li>这些新地址的计算通常涉及到基址的概念，即新的段基址加上段内的偏移量来得到重定位地址。</li>
<li>重定位地址计算公式为：重定位地址 &#x3D; 新段基址 + 段内偏移。</li>
</ul>
</li>
<li>修改指令中的符号地址：<ul>
<li>链接器对目标文件中的指令进行扫描，在指令中定位到需要进行重定位的符号地址的位置。</li>
<li>然后，链接器会将指令中的符号地址修改为相应的重定位地址，以完成符号的重定位。</li>
</ul>
</li>
<li>形成新的符号表：<ul>
<li>在重定位过程中，链接器会根据符号索引和重定位信息，确定每个重定位符号的新地址。</li>
<li>链接器会将这些新地址形成一个新的符号表，用于在最终的可执行文件或共享库中进行符号解析和访问。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.8-链接过程(2)-符号解析-强符号与弱符号</title>
    <url>/2023/09/05/3-8-%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B-2-%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90-%E5%BC%BA%E7%AC%A6%E5%8F%B7%E4%B8%8E%E5%BC%B1%E7%AC%A6%E5%8F%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-8-1-编译器对符号的处理规则"><a href="#3-8-1-编译器对符号的处理规则" class="headerlink" title="3.8.1 编译器对符号的处理规则"></a>3.8.1 编译器对符号的处理规则</h1><p>符号（Symbol）是在程序中引用或定义的标识符，通常是函数名、全局变量名或其他标识符。符号具有以下几种不同的概念：</p>
<ul>
<li><p>强符号（Strong Symbol）：强符号是指在程序中只有一个定义的符号。当多个目标文件中存在同名的强符号时，链接器会产生冲突并报错。通常，全局变量</p>
<p>和初始化的全局变量是强符号。每个强符号在整个程序中只能有一个定义。</p>
</li>
</ul>
<p>函数名：函数名是程序中表示函数的符号。函数名通常是强符号，因为每个函数在整个程序中只能有一个定义。</p>
<p>初始化的全局变量：初始化的全局变量是指在程序中定义并显式初始化的全局变量。它们通常是强符号，因为每个初始化的全局变量在整个程序中只能有一个定义。</p>
<ul>
<li><p>弱符号（Weak Symbol）：弱符号是指在程序中可以存在多个定义的符号。当多个目标文件中存在同名的弱符号时，链接器通常会选择其中一个定义，而其他</p>
<p>的定义会被忽略。弱符号通常用于具有默认实现或可选实现的函数或变量。未初始化的全局变量也是弱符号</p>
</li>
</ul>
<p>​	未初始化的全局变量：未初始化的全局变量是指在程序中定义但没有显式初始化的全局变量。它们通常是弱符号，因为多个目标文件中可以存在同名的未初始化全局变量，链接器会在运行时将它们合并为一个共享的内存区域。</p>
<p>编译器对符号的处理规则如下：</p>
<ol>
<li>强符号：<ul>
<li>强符号不允许多次定义，每个强符号在整个程序中只能有一个定义。</li>
<li>强符号和弱符号可以共存，即在程序中可以同时存在强符号和弱符号。</li>
<li>当强符号和弱符号共存时，强符号会覆盖弱符号。在链接时，如果存在多个同名符号，链接器会选择强符号作为最终的定义。</li>
</ul>
</li>
<li>弱符号：<ul>
<li>编译器允许多个弱符号在程序中存在。</li>
<li>在编译期间，编译器并不知道弱符号所占用的空间大小。为了解决这个问题，编译器会使用一个未定义的COMMON符号来代替弱符号的定义。COMMON符号表示一个未初始化的全局变量或未分配内存的占位符。</li>
<li>在链接期间，链接器会比较多个文件中的弱符号，并选择占用空间最大的弱符号作为最终的定义。这意味着在多个目标文件中存在同名弱符号时，链接器会选择占用空间最大的弱符号来作为最终的定义。</li>
</ul>
</li>
</ol>
<h1 id="3-8-2-弱符号与BSS段"><a href="#3-8-2-弱符号与BSS段" class="headerlink" title="3.8.2 弱符号与BSS段"></a>3.8.2 弱符号与BSS段</h1><p>弱符号和BSS段在编译和链接过程中的关系如下：</p>
<ol>
<li>不同目标文件中的BSS段：<ul>
<li>BSS段是用于存储未初始化的全局变量和静态变量的内存段。</li>
<li>在编译阶段，编译器将未初始化的全局变量和静态变量标记为BSS段，并分配了对应的空间。但是，BSS段中的变量并没有实际的初始化值。</li>
<li>在链接阶段，多个目标文件中的BSS段会被合并到一个统一的BSS段中，以便在最终的可执行文件中分配内存。</li>
</ul>
</li>
<li>可重定位目标文件的链接：<ul>
<li>在可重定位目标文件的链接过程中，链接器不会确定弱符号的最终定义。因此，未初始化的全局变量和弱符号不会放在BSS段中，而是放在临时的COMMON块中。</li>
<li>COMMON块是一个临时的内存区域，用于存放未初始化的全局变量和弱符号。在链接器最终确定了弱符号的定义后，它们将被分配到最终的BSS段中。</li>
</ul>
</li>
<li>可执行目标文件的链接：<ul>
<li>在可执行目标文件的链接过程中，链接器已经确定了弱符号的最终定义。</li>
<li>弱符号被分配了一个最大的空间，并放置在BSS段中。这是因为在链接过程中，链接器选择了占用空间最大的弱符号作为最终的定义，并为其分配了足够的内存空间。</li>
</ul>
</li>
</ol>
<h1 id="3-8-3-强引用与弱引用"><a href="#3-8-3-强引用与弱引用" class="headerlink" title="3.8.3 强引用与弱引用"></a>3.8.3 强引用与弱引用</h1><p>强引用和弱引用是指对符号的引用的特性，而符号本身代表一个地址，可以是函数或变量的名称。</p>
<p>在一个文件内，当我们定义一个函数或变量时，其函数名或变量名就是一个符号。在另一个文件中，如果我们通过函数名或变量名来调用该函数或引用该变量，就称为对符号的引用。引用的本质是使用符号的地址。</p>
<p>特点如下：</p>
<ol>
<li>强引用：<ul>
<li>当一个符号引用被标记为强引用时，如果在链接时找不到该符号的定义，链接过程将会报错。</li>
<li>强引用表示对符号的依赖性较高，如果缺少了符号的定义，程序无法正常链接和执行。</li>
</ul>
</li>
<li>弱引用：<ul>
<li>当一个符号引用被标记为弱引用时，如果这个符号没有定义，链接过程不会报错，而是在运行时可能会导致错误。</li>
<li>弱引用表示对符号的依赖性较低，如果缺少了符号的定义，链接过程仍然可以继续，但在运行时可能会遇到未定义符号的错误。</li>
</ul>
</li>
</ol>
<p>根据符号引用是否为0（即空指针或空引用），我们可以在程序中判断是否执行某个函数。如果符号引用为0，表示符号没有定义，可以根据这个判断来避免执行相应的函数。</p>
<h1 id="3-8-4-弱引用的应用"><a href="#3-8-4-弱引用的应用" class="headerlink" title="3.8.4 弱引用的应用"></a>3.8.4 弱引用的应用</h1><p>弱引用在以下场景中常被应用：</p>
<ol>
<li>库：<ul>
<li>在使用库时，可以将库中的函数定义为弱引用。</li>
<li>这样，在链接时，如果存在相同名称的函数定义，链接器会选择强引用的函数定义，但如果找不到强引用的函数定义，就会选择弱引用的函数定义。</li>
<li>这使得我们可以自定义函数来覆盖库中的函数，使用自定义版本的库函数。</li>
</ul>
</li>
<li>扩展功能模块：<ul>
<li>当程序依赖于某些可选的扩展功能模块时，可以将这些模块的引用定义为弱引用。</li>
<li>这样，在链接时，如果这些模块不存在或被删除，程序仍然可以正常链接和运行，因为对这些模块的引用是弱引用，链接器不会报错。</li>
</ul>
</li>
<li>多线程：<ul>
<li>在多线程编程中，有时需要根据运行时环境的不同来决定是否开启多线程模式。</li>
<li>例如，在Linux下，可以将<code>pthread_create</code>函数定义为弱引用。</li>
<li>运行时，程序可以判断链接的是单线程版本的glibc库还是多线程版本的glibc库，从而决定是否启用多线程模式。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.7-链接过程(1)-地址空间分配与链接脚本</title>
    <url>/2023/09/05/3-7-%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B-1-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E4%B8%8E%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-7-1-链接的重要性"><a href="#3-7-1-链接的重要性" class="headerlink" title="3.7.1 链接的重要性"></a>3.7.1 链接的重要性</h1><p>链接（Linking）是将多个可重定位目标文件合并、组装成可执行目标文件或共享库的过程。链接器（Linker）是执行链接操作的工具或程序。</p>
<p>链接的主要目的是解决多个目标文件之间的符号引用和地址重定位问题，使得程序能够正确地执行。</p>
<p>链接过程包括以下主要步骤：</p>
<ol>
<li>地址空间分配：链接器将可执行目标文件加载到内存中的适当地址空间中。这涉及到分配代码段、数据段、堆栈等内存区域，并为每个目标文件分配适当的地址范围。</li>
<li>符号解析：在链接过程中，符号解析是一个重要的步骤。符号解析的目的是解决符号的引用关系，将符号引用与符号定义进行匹配。在符号解析阶段，链接器会根据符号的绑定属性（如全局、局部、弱符号）来确定符号的可见性和重复定义规则。<ul>
<li>强符号（Strong Symbols）：具有全局绑定属性的符号，优先级高于弱符号。如果存在多个强符号同名定义，链接器会报错。</li>
<li>弱符号（Weak Symbols）：具有弱绑定属性的符号，允许在多个目标文件中重复定义。如果存在多个弱符号同名定义，并且没有对应的强符号，链接器会选择其中一个定义。</li>
</ul>
</li>
<li>重定位（Relocation）：重定位是将目标文件中的地址引用转换为最终可执行文件中的实际地址的过程。在链接过程中，由于目标文件中的地址是相对于各自的节（Section）的起始地址的偏移量，因此需要进行重定位操作，将这些相对地址转换为绝对地址。重定位过程涉及到修正目标文件中的跳转、调用和数据访问等指令，使得它们指向正确的地址。</li>
</ol>
<h1 id="3-7-2-地址空间分配"><a href="#3-7-2-地址空间分配" class="headerlink" title="3.7.2 地址空间分配"></a>3.7.2 地址空间分配</h1><p>地址空间分配是链接过程中的一项重要任务，它确定了各个目标文件中不同段（如代码段、数据段、bss段）在最终可执行目标文件中的位置和大小。</p>
<p>以下是地址空间分配的一般步骤：</p>
<ol>
<li>扫描所有目标文件：链接器会逐个扫描所有目标文件，包括主程序文件和库文件。对于每个目标文件，链接器会读取其文件头部和段表等信息。</li>
<li>获取段信息：链接器从各个目标文件的段表中获取各个段的信息，包括段的类型（如代码段、数据段、bss段）、大小和对齐等属性。每个目标文件中的段表记录了该文件中各个段的位置和长度。</li>
<li>确定链接地址：链接器会指定一个链接地址（linkaddr）作为起始地址，用于存放最终可执行目标文件的各个段。</li>
<li>合并同类型段：链接器按照段的类型（代码段、数据段、bss段）顺序，将各个目标文件中相同类型的段进行合并。对于代码段和数据段，链接器会根据链接地址和各个段的偏移量（offset）计算出最终的段地址。</li>
<li>重新计算段长度和位置：合并后，链接器会重新计算各个段的长度和位置。对于代码段和数据段，它们的长度是各个段的长度之和；而对于bss段，它的长度通常为0，因为bss段存放的是未初始化的全局变量和静态变量。</li>
<li>处理库文件：链接器还会处理库文件，将库文件中的目标模块合并到最终的可执行目标文件中。这涉及到符号解析、重定位和符号表的更新等操作。</li>
</ol>
<h1 id="3-7-3-创建全局符号表"><a href="#3-7-3-创建全局符号表" class="headerlink" title="3.7.3 创建全局符号表"></a>3.7.3 创建全局符号表</h1><p>创建全局符号表是链接过程的一项关键任务，它的目的是将各个目标文件中的符号收集起来，并统一保存在一个全局符号表中。</p>
<p>以下是创建全局符号表的一般步骤：</p>
<ol>
<li>扫描所有目标文件：链接器会逐个扫描所有目标文件，包括主程序文件和库文件。对于每个目标文件，链接器会读取其符号表信息。</li>
<li>收集符号：链接器从每个目标文件的符号表中收集符号信息。符号表中包含了各个目标文件中定义和引用的符号的名称、属性和地址等信息。</li>
<li>统一放入全局符号表：链接器将从各个目标文件中收集到的符号统一放入一个全局符号表中。全局符号表是链接器维护的一个数据结构，用于保存所有目标文件中的符号信息。</li>
<li>相对零地址偏移：在创建全局符号表时，符号的地址仍然是相对于零地址的偏移量。这是因为在链接过程的后续阶段，还需要进行重定位操作，将符号的地址转换为最终可执行目标文件中的实际地址。</li>
</ol>
<h1 id="3-7-4-链接脚本"><a href="#3-7-4-链接脚本" class="headerlink" title="3.7.4 链接脚本"></a>3.7.4 链接脚本</h1><p>不同的代码段在链接过程中的组装是由链接脚本（Linker Script）来规定的。链接脚本是一个文本文件，其中包含了链接器的指令和规则，用于指导链接器如何组装各个代码段。</p>
<p>链接脚本通常包含以下信息：</p>
<ol>
<li>组装顺序：链接脚本规定了各个代码段的组装顺序。根据链接脚本的指定顺序，链接器会按照代码段的顺序将它们组装到最终可执行目标文件中。</li>
<li>起始地址：链接脚本指定了各个代码段在最终可执行目标文件中的起始地址。链接器会根据链接脚本中的地址规定，将各个代码段放置到相应的地址位置。</li>
<li>位置对齐：链接脚本还规定了代码段的位置对齐要求。根据链接脚本中指定的对齐规则，链接器会确保代码段在最终可执行目标文件中按照规定的对齐边界进行放置。</li>
<li>输出格式和运行平台：链接脚本可以指定输出可执行文件的格式和运行平台。这些信息对于生成符合特定格式和平台要求的可执行目标文件非常重要。</li>
<li>入口地址：链接脚本可以指定可执行目标文件的入口地址。入口地址是程序执行的起始点，在加载和执行可执行文件时，操作系统会将控制权转移到指定的入口地址处开始执行程序。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">oUTPUT_FORMAT( <span class="string">&quot;elf32-littlearm”</span></span><br><span class="line"><span class="string">&quot;</span>elf32-bigarm”</span><br><span class="line"><span class="string">&quot;elf32-littlearm”)</span></span><br><span class="line"><span class="string">;输出ELF麻件格式</span></span><br><span class="line"><span class="string">OUTPUT_ARCH( “arm”)</span></span><br><span class="line"><span class="string">;输出可执行文件的运行平台为arm</span></span><br><span class="line"><span class="string">ENTRY(_start)</span></span><br><span class="line"><span class="string">;程序入口地址</span></span><br><span class="line"><span class="string">SECTIONS</span></span><br><span class="line"><span class="string">;各段描述</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">.= Ox60000000;</span></span><br><span class="line"><span class="string">;代码段起始地址</span></span><br><span class="line"><span class="string">.text:&#123;*(.text)&#125;</span></span><br><span class="line"><span class="string">;代码段描述:所有.o文件的. text</span></span><br><span class="line"><span class="string">.= Ox60200000;</span></span><br><span class="line"><span class="string">;数据段的起始地址</span></span><br><span class="line"><span class="string">.data: &#123;*(. data)&#125;</span></span><br><span class="line"><span class="string">;数据段描述</span></span><br><span class="line"><span class="string">.bss :&#123;*(. bss)&#125;</span></span><br><span class="line"><span class="string">; BSS段描述</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>在SECTIONS部分，代码段的起始地址为0x60000000，紧接着是代码段的描述；数据段的起始地址为0x60200000，后面是数据段的描述；最后是BSS段的描述。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.6-编译过程(3)-符号表</title>
    <url>/2023/09/05/3-6-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B-3-%E7%AC%A6%E5%8F%B7%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-6-1-符号表"><a href="#3-6-1-符号表" class="headerlink" title="3.6.1 符号表"></a>3.6.1 符号表</h1><p>符号表在编译过程中起到了重要的作用，主要用来保存源程序中各种符号（如变量、函数、类、常量等）的相关信息，如地址值、类型、占用空间的大小等。</p>
<p>符号表的主要作用如下：</p>
<ol>
<li>辅助语义检查：符号表可以用于辅助编译器进行语义检查。编译器通过符号表来验证标识符的合法性、类型匹配等语义规则，以确保源程序的语义正确性。例如，编译器在进行类型检查时可以通过符号表中记录的类型信息来判断赋值操作是否合法。</li>
<li>辅助代码生成：符号表在代码生成阶段发挥重要作用。编译器通过符号表来进行地址和空间的分配，以确定变量和函数在内存中的位置。符号表中记录的地址信息可以用于生成汇编代码或机器代码时的地址计算。例如，编译器可以根据符号表中的地址信息为变量分配栈空间或静态数据区空间。</li>
<li>符号决议：符号表用于解析标识符的引用，即在程序中使用某个标识符时，找到该标识符的定义位置。编译器通过符号表中记录的定义位置信息来处理标识符的引用，以确保标识符在使用前已经被定义。符号决议阶段还包括解决标识符的作用域和命名空间等问题。</li>
<li>重定位：符号表用于链接器进行符号重定位。在多个目标文件进行链接时，链接器需要解析和处理目标文件中的符号引用。链接器通过符号表中记录的地址信息，将符号引用链接到正确的地址上，以确保最终生成的可执行文件能够正确地访问和使用各个目标文件中的符号。</li>
</ol>
<h1 id="3-6-2-elf文件和bin文件"><a href="#3-6-2-elf文件和bin文件" class="headerlink" title="3.6.2 elf文件和bin文件"></a>3.6.2 elf文件和bin文件</h1><p>ELF文件和BIN文件是两种不同的可执行文件格式。</p>
<p>BIN文件是一种纯粹的二进制文件，只包含机器码，没有附加的元数据信息。它通常被称为raw binary文件或镜像文件。BIN文件中的机器码是直接按照内存中的布局排列的，没有分节或分段的概念。常见的BIN文件格式还包括HEX文件，它以十六进制形式表示机器码。</p>
<p>而ELF文件（Executable and Linkable Format）是一种更为复杂的可执行文件格式。除了包含机器码之外，ELF文件还包含了一些额外的元数据信息，用于描述程序的结构、加载地址、运行地址等。ELF文件具有分节（Section）和分段（Segment）的概念，不同的节和段存储了不同的信息，如代码段、数据段、符号表、重定位表等。</p>
<p>ELF文件的结构包括以下几个重要的部分：</p>
<ol>
<li>ELF头（ELF Header）：位于文件的开头，包含了对整个ELF文件的描述信息，如文件类型、目标体系结构、入口地址等。</li>
<li>节表（Section Table）：记录了ELF文件中各个节的信息。每个节存储了特定类型的数据，例如代码、数据、符号表、重定位表等。节表中的每个表项描述了一个节的名称、大小、偏移量等信息。</li>
<li>段表（Segment Table）：记录了ELF文件中各个段的信息。段是逻辑上一组相关的节的集合，用于定义程序的内存布局。段表中的每个表项描述了一个段的类型、虚拟地址、文件偏移量等信息。</li>
<li>符号表（Symbol Table）：记录了程序中定义和引用的符号（如变量、函数、类等）的信息。符号表中的每个表项描述了一个符号的名称、类型、地址等信息。符号表在链接过程中用于解析符号引用和进行符号重定位。</li>
<li>重定位表（Relocation Table）：记录了需要进行符号重定位的位置和相关信息。重定位表在链接过程中用于调整代码和数据的位置，确保程序能够正确访问和使用符号。</li>
</ol>
<h1 id="3-6-3-readelf-s-和readelf-S-的区别"><a href="#3-6-3-readelf-s-和readelf-S-的区别" class="headerlink" title="3.6.3 readelf -s 和readelf -S 的区别"></a>3.6.3 readelf -s 和readelf -S 的区别</h1><p><code>readelf -s</code>和<code>readelf -S</code>是<code>readelf</code>命令的两个不同的选项，它们用于显示ELF文件中的不同部分信息。</p>
<ol>
<li><code>readelf -s</code>：该选项用于显示ELF文件的符号表（Symbol Table）。符号表记录了程序中定义和引用的符号（如变量、函数、类等）的信息。使用<code>readelf -s</code>命令可以列出符号表中的所有符号，包括符号的名称、类型、绑定属性、地址等信息。这对于进行符号分析、调试和动态链接等操作非常有用。</li>
<li><code>readelf -S</code>：该选项用于显示ELF文件的节表（Section Table）。节表记录了ELF文件中各个节的信息，每个节存储了特定类型的数据，如代码、数据、符号表、重定位表等。使用<code>readelf -S</code>命令可以列出节表中的所有节，包括节的名称、类型、大小、偏移量、虚拟地址等信息。这对于了解程序的内存布局、代码和数据段的大小以及节之间的关系非常有帮助。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/home/topeet/demo# readelf -s sub.o </span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 13 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS sub.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    2 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     9: 0000000000000000    24 FUNC    GLOBAL DEFAULT    1 add</span><br><span class="line">    10: 0000000000000018    22 FUNC    GLOBAL DEFAULT    1 sub</span><br><span class="line">    11: 000000000000002e    23 FUNC    GLOBAL DEFAULT    1 mul</span><br><span class="line">    12: 0000000000000045    23 FUNC    GLOBAL DEFAULT    1 div</span><br><span class="line">root@ubuntu:/home/topeet/demo# readelf -S sub.o </span><br><span class="line">There are 12 section headers, starting at offset 0x398:</span><br><span class="line"></span><br><span class="line">节头：</span><br><span class="line">  [号] 名称              类型             地址              偏移量</span><br><span class="line">       大小              全体大小          旗标   链接   信息   对齐</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000005c  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .data             PROGBITS         0000000000000000  0000009c</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 3] .bss              NOBITS           0000000000000000  0000009c</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .comment          PROGBITS         0000000000000000  0000009c</span><br><span class="line">       000000000000002c  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 5] .note.GNU-stack   PROGBITS         0000000000000000  000000c8</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 6] .note.gnu.propert NOTE             0000000000000000  000000c8</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 7] .eh_frame         PROGBITS         0000000000000000  000000e8</span><br><span class="line">       0000000000000098  0000000000000000   A       0     0     8</span><br><span class="line">  [ 8] .rela.eh_frame    RELA             0000000000000000  000002d0</span><br><span class="line">       0000000000000060  0000000000000018   I       9     7     8</span><br><span class="line">  [ 9] .symtab           SYMTAB           0000000000000000  00000180</span><br><span class="line">       0000000000000138  0000000000000018          10     9     8</span><br><span class="line">  [10] .strtab           STRTAB           0000000000000000  000002b8</span><br><span class="line">       0000000000000017  0000000000000000           0     0     1</span><br><span class="line">  [11] .shstrtab         STRTAB           0000000000000000  00000330</span><br><span class="line">       0000000000000067  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br><span class="line">root@ubuntu:/home/topeet/demo# </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3-6-3-符号类型和绑定属性"><a href="#3-6-3-符号类型和绑定属性" class="headerlink" title="3.6.3 符号类型和绑定属性"></a>3.6.3 符号类型和绑定属性</h1><p>符号类型和绑定属性是符号表中的两个重要概念，用于描述符号的特性和可见性。</p>
<ol>
<li>符号类型（Symbol Type）：符号类型描述了符号关联的实体类型，即符号表示的是什么。在符号表中常见的符号类型包括：</li>
</ol>
<ul>
<li>OBJECT（对象）：符号关联的是一个数据对象，如变量、数组或指针。</li>
<li>FUNC（函数）：符号关联到一个函数或过程。</li>
<li>SECTION（节）：符号关联到一个节的名字。</li>
<li>FILE（文件）：符号关联一个文件名。</li>
<li>NOTYPE（未指定类型）：符号的类型未指定，它常用于未定义的引用。</li>
</ul>
<p>2.绑定属性（Binding Attribute）：绑定属性描述了符号的可见性和重复定义的规则。在符号表中常见的绑定属性包括：</p>
<ul>
<li>LOCAL（局部）：局部符号只在目标文件内可见，多个目标文件可以有相同的局部符号名而不会冲突。</li>
<li>GLOBAL（全局）：全局符号在目标文件内部可见，也可以被其他文件引用。全局符号在整个程序中是可见的，但是不同文件中的全局符号名称不能重复。</li>
<li>WEAK（弱）：弱符号是一种特殊的全局符号，它可以在多个文件中重复定义。即使弱符号未定义，链接过程也不会报错，而是将其符号值设置为0。弱符号可以被强符号覆盖。</li>
</ul>
<h1 id="3-6-4-节索引"><a href="#3-6-4-节索引" class="headerlink" title="3.6.4 节索引"></a>3.6.4 节索引</h1><p>节索引（Section Index）是在符号表中使用的一个索引值，用于指示每个符号所在的节（Section）。</p>
<p>在目标文件中，包含了多个节（如代码节、数据节、符号表节等），用于存储不同类型的数据和信息。而符号表（Symbol Table）中保存了所有节的符号信息。</p>
<p>为了确定每个符号所在的具体节，符号表中的每个符号都使用一个节索引来表示其所在的节。节索引是一个非负整数，它对应着目标文件中节头表（Section Header Table）中的表项序号。</p>
<p>节头表是目标文件中的一部分，用于描述每个节的属性和位置等信息。每个节头表的表项都包含了该节的名称、类型、大小、偏移量等信息。通过符号表中的节索引，可以找到符号所属的具体节，并将该符号绑定到该节上。</p>
<p>在符号表中，还有几个特殊的节索引值：</p>
<ul>
<li>ABS：表示符号的绝对值，不需要进行重定位，即该符号的地址是绝对的。</li>
<li>UNDEF：表示未定义符号，即在当前模块中引用了该符号，但在其他地方定义。</li>
<li>COMMON：表示尚未分配位置的未初始化数据，通常用于全局未初始化的变量。</li>
</ul>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.5-编译过程(2)-汇编过程</title>
    <url>/2023/09/05/3-5-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B-2-%E6%B1%87%E7%BC%96%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-5-1-汇编过程"><a href="#3-5-1-汇编过程" class="headerlink" title="3.5.1 汇编过程"></a>3.5.1 汇编过程</h1><p>汇编过程的基本流程如下：</p>
<ol>
<li>词法分析：在这个阶段，汇编器将输入的源文件（通常以.s为后缀，如main.s）进行词法分析。词法分析器将源代码分解为一个个的词法单元，如指令、寄存器、标识符等，并生成词法单元流。</li>
<li>语法分析：在语法分析阶段，汇编器使用词法单元流进行语法分析。语法分析器根据语法规则将词法单元流解析为语法结构，并构建相应的语法树。语法分析过程中还会生成符号表，用于记录和管理标识符、变量和常量等信息。</li>
<li>组装：在组装阶段，汇编器将语法树转换为可执行的目标文件。这个过程包括将汇编指令转换为机器指令、填充符号表、生成重定位表等。组装器的主要任务是将汇编代码转换为机器代码，并生成可执行目标文件。</li>
<li>代码生成：在代码生成阶段，汇编器根据语法树和符号表生成目标文件的指令。这个阶段涉及指令的翻译和生成各种表信息，如重定位表、赋值信息等。指令的翻译过程将汇编指令转化为目标机器的机器指令，生成的表信息用于链接和重定位等操作。</li>
<li>主要工作：汇编过程的主要工作包括词法分析、语法分析、组装、代码生成和生成各种表信息。这些工作协同完成，最终生成可重定位目标文件（通常以.o为后缀，如main.o）。</li>
</ol>
<h1 id="3-5-2-符号表（Symbol-Table）"><a href="#3-5-2-符号表（Symbol-Table）" class="headerlink" title="3.5.2 符号表（Symbol Table）"></a>3.5.2 符号表（Symbol Table）</h1><p>​	符号表（Symbol Table）是编译器和链接器中存储程序中符号信息的数据结构。它记录了源代码中定义和引用的变量、函数、类、常量等标识符的相关信息，如名称、类型、内存地址等。符号表在编译和链接过程中起着重要的作用，用于解析符号引用、符号重定位和符号解析等任务。</p>
<p>符号表通常包含以下信息：</p>
<ol>
<li>符号名称（Symbol Name）：记录标识符的名称，如变量名、函数名等。</li>
<li>符号类型（Symbol Type）：指示标识符的类型，如整型、浮点型、函数等。</li>
<li>符号属性（Symbol Attributes）：记录标识符的属性，如是否为全局变量、局部变量、静态变量等。</li>
<li>内存地址（Memory Address）：记录标识符在内存中的地址或偏移量。</li>
<li>作用域（Scope）：指示标识符的作用域范围，如全局作用域、局部作用域等。</li>
<li>定义位置（Definition Location）：记录标识符的定义位置，用于解析符号引用。</li>
<li>引用位置（Reference Locations）：记录标识符的引用位置，用于解析符号引用。</li>
</ol>
<p>符号表在编译过程中起着重要的作用：</p>
<ol>
<li>语法分析：在语法分析阶段，编译器将标识符添加到符号表中，并记录其名称、类型和定义位置等信息。</li>
<li>符号解析：在编译器的符号解析阶段，通过符号表来解析标识符的引用。编译器会检查符号表，找到标识符的定义位置，并进行类型检查和语义分析。</li>
<li>重复定义检查：符号表可以检查是否存在重复定义的标识符，如重复的变量名或函数名。</li>
<li>作用域管理：符号表中的作用域信息可以帮助编译器正确处理局部变量和全局变量的作用域范围。</li>
<li>符号重定位：在链接过程中，符号表用于解析符号引用和进行符号重定位。链接器会根据符号表中的地址信息，将各个目标文件中的符号引用链接到正确的地址上。</li>
</ol>
<h1 id="3-5-3-重定位表（Relocation-Table）"><a href="#3-5-3-重定位表（Relocation-Table）" class="headerlink" title="3.5.3 重定位表（Relocation Table）"></a>3.5.3 重定位表（Relocation Table）</h1><p>​	重定位表（Relocation Table）是链接器生成的一种表格，用于记录需要进行符号重定位的位置和相关信息。在目标文件中，由于代码和数据的位置是相对于起始地址的偏移量，因此在链接时需要对这些位置进行调整，以确保最终生成的可执行文件能够正确地访问和使用这些代码和数据。</p>
<p>重定位表通常包含以下信息：</p>
<ol>
<li>符号名称（Symbol Name）：记录需要进行重定位的符号的名称。</li>
<li>重定位类型（Relocation Type）：指示需要进行的重定位类型，如绝对重定位、相对重定位等。</li>
<li>位置（Location）：记录需要进行重定位的位置或偏移量。</li>
<li>目标地址（Target Address）：记录需要重定位到的目标地址。</li>
</ol>
<p>重定位表在链接过程中起着重要的作用：</p>
<ol>
<li>符号解析与重定位：链接器通过重定位表中的信息，对目标文件中的符号引用进行解析和重定位。它会根据目标文件的符号表和重定位表，将符号引用链接到正确的地址上。</li>
<li>位置调整：重定位表中记录了需要进行重定位的位置和目标地址，链接器根据这些信息对目标文件中的代码和数据位置进行调整，使其能够正确地访问和使用。</li>
<li>符号冲突解决：如果存在多个目标文件中相同名称的符号，重定位表可以帮助链接器解决符号冲突的问题。通过重定位表中的符号名称和目标地址，链接器可以确定每个符号应该链接到的具体地址，从而避免冲突。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.4-编译过程(1)-从源程序到汇编文件</title>
    <url>/2023/09/05/3-4-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B-1-%E4%BB%8E%E6%BA%90%E7%A8%8B%E5%BA%8F%E5%88%B0%E6%B1%87%E7%BC%96%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-4-1-编译输入输出"><a href="#3-4-1-编译输入输出" class="headerlink" title="3.4.1 编译输入输出"></a>3.4.1 编译输入输出</h1><p>编译过程主要是将高级语言（如C语言）的源代码转换为低级语言（如汇编语言或机器语言），以便计算机可以理解和执行。</p>
<p>在编译过程中，主要的步骤包括：</p>
<ol>
<li>词法分析（Lexical Analysis）：将源代码划分为词法单元（tokens），例如关键字、标识符、运算符和常量等。词法分析器（也称为扫描器）会扫描源代码，并生成词法单元流。</li>
<li>语法分析（Syntax Analysis）：根据语法规则，将词法单元流组织成语法树（Parse Tree）或抽象语法树（Abstract Syntax Tree，AST）。语法分析器（也称为解析器）会检查语法的正确性，并生成语法树或AST。</li>
<li>语义分析（Semantic Analysis）：对语法树或AST进行语义检查，包括类型检查、语义规则验证等。语义分析器会确保程序在语义上是合法的，并生成相应的符号表（Symbol Table）来记录变量、函数等的信息。</li>
<li>中间代码生成（Intermediate Code Generation）：将语法树或AST转换为中间表示形式，通常是一种类似于三地址码的中间代码。中间代码是一种抽象的表示形式，它更接近于底层的机器语言，但仍保留了高级语言的结构特点。</li>
<li>代码优化（Code Optimization）：对中间代码进行优化，以改善程序的性能、减少代码的执行时间或空间占用。代码优化技术包括常量传播、循环展开、公共子表达式消除等，旨在生成更高效的目标代码。</li>
<li>目标代码生成（Code Generation）：将优化后的中间代码转换为目标机器的机器代码或汇编代码。目标代码生成器会根据目标机器的体系结构和指令集生成对应的机器代码或汇编代码。</li>
<li>链接（Linking）：如果程序包含多个源文件或库文件，链接器会将它们合并为一个可执行文件。链接过程包括符号解析、重定位等步骤，以确保程序中引用的函数和变量正确地连接到对应的定义。</li>
</ol>
<h1 id="3-4-2-词法分析"><a href="#3-4-2-词法分析" class="headerlink" title="3.4.2 词法分析"></a>3.4.2 词法分析</h1><p>词法分析是编译过程中的一项关键任务，它将源代码作为输入，并将其划分为一系列记号（tokens）。</p>
<p>在词法分析过程中，主要的步骤包括：</p>
<ol>
<li>从左到右读取源程序：词法分析器按顺序逐个字符地读取源代码，从左到右进行扫描。</li>
<li>扫描和分解记号：词法分析器根据语言的词法规则，将源程序的字符流分解成一系列记号。记号可以是关键字、标识符、字面量（数字、字符串等）、特殊字符（运算符等）和分界符（分号、逗号等）等。</li>
<li>构建记号流：词法分析器将分解出的记号按顺序构建记号流，以便后续的语法分析和语义分析等阶段使用。</li>
<li>符号表：在词法分析过程中，识别到的标识符（如函数名、变量名、标号等）会被记录在符号表中。符号表是编译器维护的一张表格，用于存储标识符的属性信息（如类型、作用域等）。</li>
<li>字符串表：识别到的数字、字符串等字面量会被存放在字符串表中。字符串表是一个存储字符串字面量的表格，编译器可以使用索引来引用字符串表中的内容，以减少内存占用和提高效率。</li>
</ol>
<h1 id="3-4-3-语法分析"><a href="#3-4-3-语法分析" class="headerlink" title="3.4.3 语法分析"></a>3.4.3 语法分析</h1><p>语法分析是编译过程中的一个重要阶段，它根据语法规则检查词法分析器生成的记号流，以确定是否构成一个语法上正确的程序，并将其分解为语法短语（如程序、语句、表达式等）。语法分析器将记号流转化为语法树（Parse Tree），它是一种树形结构，表示了程序的语法结构。</p>
<p>在语法分析过程中，主要的步骤包括：</p>
<ol>
<li>语法规则：语法分析器使用预定义的语法规则来判断记号流是否符合语法要求。语法规则描述了语言的语法结构，包括语句的组成、表达式的形式等。</li>
<li>语法树构建：语法分析器根据语法规则，将记号流转化为语法树。语法树是一种树形结构，它以记号为节点，将程序的语法结构表示为树的分支和叶子节点。</li>
<li>语法分析工具：为了简化语法分析的实现，可以使用专门的语法分析工具，如Yacc（Yet Another Compiler Compiler）。这些工具提供了一种形式化的方式来描述语法规则，并自动生成语法分析器的代码。</li>
<li>通用性：由于语法规则是与编程语言相关的，不同的编程语言具有不同的语法规则。但幸运的是，对于常见的编程语言，不需要为每个编译器编写一个新的语法分析器。相同的语法分析技术和工具可以用于不同的编程语言，只需要提供相应的语法规则。</li>
<li>语法错误：如果记号流不能按照语法规则进行正确的匹配，就会发生语法错误（syntax error）。语法分析器会检测这些错误并生成相应的错误信息，指示程序中存在哪些语法错误以及其位置。</li>
</ol>
<h1 id="3-4-4-语义分析"><a href="#3-4-4-语义分析" class="headerlink" title="3.4.4 语义分析"></a>3.4.4 语义分析</h1><p>语义分析是编译过程中的一个关键阶段，它在语法分析的基础上对语句、程序、表达式等进行进一步检查，以确定其语义是否正确。语义分析器会检查静态语义和动态语义，并对整个语法树的表达式进行类型标注。</p>
<p>在语义分析过程中，主要的任务包括：</p>
<ol>
<li>静态语义：静态语义分析在编译期间进行，它关注的是在编译期能够确定的语义。静态语义包括函数实参与形参的类型匹配和转换、变量的声明和使用、类型检查等。例如，语义分析器会检查函数调用时实参与形参的类型是否匹配，是否存在未声明的变量等。</li>
<li>动态语义：动态语义分析在运行期间进行，它关注的是在运行时才能确定的语义。动态语义包括除数为零、数组越界访问等。例如，语义分析器会检查除法表达式中除数是否为零，以避免发生运行时错误。</li>
<li>类型标注：语义分析器会对整个语法树的表达式进行类型标注，即为每个表达式确定其类型信息。这可以帮助后续的代码生成和优化阶段进行类型检查和优化操作。</li>
<li>语义分析器：语义分析器是执行语义分析的工具或组件。它接收语法分析器生成的语法树作为输入，并根据语义规则进行分析和检查。语义分析器会发现并报告语义错误，如类型不匹配、未声明的变量等。</li>
</ol>
<h1 id="3-4-5-第四阶段"><a href="#3-4-5-第四阶段" class="headerlink" title="3.4.5 第四阶段"></a>3.4.5 第四阶段</h1><p>第四阶段是编译器的中间代码生成阶段。在这个阶段，编译器将语法树转换为中间代码，以便进行后续的优化和目标代码生成。</p>
<p>中间代码是一种抽象的表示形式，它通常比源代码更接近于目标代码，但仍具有较高的可移植性和可理解性。中间代码使得编译器可以对程序进行统一的优化处理，而不受目标机器的限制。</p>
<p>现代编译器的构造通常包括以下三个主要组成部分：</p>
<ol>
<li>前端：前端负责词法分析、语法分析和语义分析等任务。它将源代码转换为中间表示形式（如语法树或中间代码），并进行基本的语法和语义检查。前端确保源代码在语法和语义上是正确的，并为后续的优化和代码生成阶段提供准确的输入。</li>
<li>优化器：优化器是编译器的重要组成部分，它对中间代码进行优化。优化器通过分析和重写中间代码，以提高程序的执行效率、减少代码大小或改进其他性能指标。优化器使用各种技术，如常量传播、循环优化、数据流分析等，来改进程序的质量和性能。</li>
<li>后端：后端负责将优化后的中间代码转换为目标机器的汇编代码或机器代码。后端包括指令选择（将中间代码转换为适合目标机器的指令序列）、寄存器分配（为变量选择寄存器）、代码布局、代码生成等任务。后端将优化后的中间代码转化为目标机器能够执行的代码。</li>
</ol>
<p>中间代码是一维线性序列，更容易生成和处理。它可以在后续的优化和代码生成阶段中进行处理和转换。</p>
<p>生成中间代码的过程通常在语义分析阶段之后，在优化器之前。语义分析器将源代码转换为语法树，然后通过对语法树进行遍历和转换，生成中间代码表示。这个过程包括将每个语法结构转换为相应的中间代码指令，并保留必要的信息来保证后续的优化和代码生成。</p>
<p>中间代码具有一些特点，如：</p>
<ol>
<li>接近目标代码：中间代码的表示形式类似于目标代码，它更接近于实际的机器指令。这使得后续的代码生成阶段更容易进行，因为中间代码已经具有了一定的目标机器相关性。</li>
<li>容易生成和转换：中间代码的生成过程相对简单，通常是基于语法树的遍历和转换。中间代码的线性结构使得对其进行处理和转换更加方便，例如进行优化和目标代码生成。</li>
</ol>
<h1 id="3-4-6-为什么需要中间代码"><a href="#3-4-6-为什么需要中间代码" class="headerlink" title="3.4.6 为什么需要中间代码"></a>3.4.6 为什么需要中间代码</h1><p>使用中间代码有以下几个主要原因：</p>
<ol>
<li>可移植性：中间代码是一种与具体目标机器无关的表示形式。通过生成中间代码，编译器可以将源代码与目标机器解耦，使得编译器更加可移植。中间代码可以在不同的目标平台上进行后续的优化和代码生成，从而实现源代码在不同平台上的跨平台执行。</li>
<li>优化：中间代码提供了一个高层次的表示形式，使得编译器可以在这个层次上进行各种优化操作。编译器可以利用中间代码的结构和语义信息，进行常量传播、死代码消除、循环优化、内联函数等优化操作，以提高程序的执行效率和性能。</li>
<li>简化代码生成：中间代码更接近于目标代码的表示形式，因此在后续的代码生成阶段，可以更轻松地将中间代码转换为目标机器的汇编代码或机器代码。中间代码的生成和转换过程相对简单，可以通过一系列的规则和转换操作来实现。</li>
<li>可读性和可理解性：中间代码通常使用一种高级语言或伪代码的形式表示，相对于目标机器的汇编代码来说，更容易阅读和理解。中间代码使得编译器的工作更加透明和可追踪，同时也有助于开发人员理解编译器的工作过程。</li>
</ol>
<h2 id="3-4-6从中间代码到汇编"><a href="#3-4-6从中间代码到汇编" class="headerlink" title="3.4.6从中间代码到汇编"></a>3.4.6从中间代码到汇编</h2><p>编译器的第五阶段是生成汇编代码，该阶段将中间代码翻译为汇编文件，并最终生成目标文件。这个阶段涉及到指令选择、控制流分析、数据流分析、寄存器分配等过程。</p>
<p>以下是生成汇编代码的一般过程：</p>
<ol>
<li>指令选择：在这个过程中，编译器将中间代码转换为汇编语言指令。指令选择的目标是选择合适的汇编指令，使得它们能够实现中间代码所描述的操作。这个过程通常会根据目标机器的架构和指令集来进行，以生成与目标机器兼容的汇编代码。</li>
<li>控制流分析：控制流分析用于确定程序中的基本块和控制流图。基本块是一段连续的指令序列，没有分支或跳转。控制流图记录了程序中的基本块之间的控制流关系，包括条件分支、循环等。控制流分析是进行优化和寻找代码转换机会的基础。</li>
<li>数据流分析：数据流分析用于分析程序中的数据依赖关系。它可以确定变量的定义和使用位置，以及数据传递和转换的路径。数据流分析对于进行寄存器分配和优化非常重要，因为它提供了变量的生命周期和使用信息。</li>
<li>寄存器分配：寄存器分配是将变量和临时值映射到物理寄存器的过程。寄存器分配可以基于静态或动态策略进行。静态寄存器分配在编译时确定寄存器的分配方案，而动态寄存器分配在运行时根据需要进行寄存器分配。寄存器分配的目标是最大程度地利用寄存器，减少内存访问。</li>
<li>汇编语言生成：在这个过程中，编译器将经过指令选择、控制流分析、数据流分析和寄存器分配的中间代码转换为汇编语言。汇编语言是一种与目标机器相关的低级表示形式，它使用特定的汇编指令和寄存器来描述程序的操作和数据。生成的汇编代码将被进一步处理以生成目标文件。</li>
<li>汇编器：汇编器是一个独立工具，它将汇编语言代码转换为可执行的目标文件。汇编器接受汇编语言作为输入，根据目标机器的指令集和格式，将汇编语言翻译为机器代码，并生成目标文件。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>3.3-预处理过程</title>
    <url>/2023/09/05/3-3-%E9%A2%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-3-1-预处理的过程"><a href="#3-3-1-预处理的过程" class="headerlink" title="3.3.1 预处理的过程"></a>3.3.1 预处理的过程</h1><p>预处理是编译过程中的第一步，它对源代码进行一系列的处理，包括头文件展开、宏展开、条件编译、删除注释、添加行号和文件名标识等。下面是预处理过程的主要步骤：</p>
<ol>
<li>头文件展开：将所有<code>#include</code>指令包含的文件插入到指令所在的位置。这样可以将头文件的内容插入到源代码中，使得源代码中可以使用头文件中定义的函数、变量和宏等。</li>
<li>宏展开：对所有的宏定义进行展开，并删除<code>#define</code>指令。预处理器会查找源代码中使用的宏，并将其替换为宏定义中的内容。这样可以将宏定义的代码在预处理阶段进行替换，减少了函数调用的开销。</li>
<li>条件编译：处理所有的条件预编译指令，例如<code>#if</code>、<code>#ifdef</code>、<code>#else</code>等。根据条件的真假，选择性地编译或排除部分代码。这样可以根据不同的条件编译选项，编译不同的代码分支。</li>
<li>删除注释：去除源代码中的注释部分。注释对于程序的理解和阅读很重要，但在编译过程中并不需要注释，因此预处理阶段会将注释删除，减少后续编译的工作量。</li>
<li>添加行号和文件名标识：为了方便编译调试和错误定位，预处理阶段会为每一行源代码添加行号和文件名标识。这样在编译出错时，可以准确地定位错误所在的行和文件。</li>
<li>保留#pragma命令：预处理阶段会保留<code>#pragma</code>指令。<code>#pragma</code>指令是编译器提供的一些特定功能的扩展，用于控制编译器的行为或实现特定的功能。</li>
<li>宏命令展开和文本替换：预处理阶段最后一步是对源代码进行宏命令展开和文本替换。在宏展开过程中，预处理器会查找源代码中使用的宏，并将其展开为宏定义中的内容。同时，还会进行一些文本替换的操作，例如替换宏参数、替换宏函数调用等。</li>
</ol>
<h1 id="3-3-2-为什么要进行预处理"><a href="#3-3-2-为什么要进行预处理" class="headerlink" title="3.3.2 为什么要进行预处理"></a>3.3.2 为什么要进行预处理</h1><p>预处理过程在编译过程中起着重要的作用，原因如下：</p>
<ol>
<li>宏定义：预处理阶段允许使用宏定义，宏可以将一段代码或表达式替换为预定义的文本。通过使用宏定义，可以简化代码编写，提高代码的可读性和可维护性。</li>
<li>方便条件编译：条件编译指令（如<code>#if</code>、<code>#ifdef</code>、<code>#else</code>）允许根据不同的编译条件选择性地编译或排除代码块。这对于实现跨平台兼容性或针对不同的编译配置进行调试和优化非常有用。</li>
<li>兼容各个平台和处理器架构：预处理过程可以根据不同的平台和处理器架构进行编译选项的设置。通过使用条件编译指令，可以编写适用于不同平台和处理器的代码，提高代码的可移植性和兼容性。</li>
<li>最大程度复用公用代码：通过使用头文件，可以将公用的函数、结构体和宏等定义保存在独立的文件中，并在需要的地方进行引用。这样可以实现代码的模块化和复用，减少代码的冗余和重复编写。</li>
<li>头文件包含：预处理过程中的头文件展开允许将其他文件中的代码插入到源文件中。这样可以将相关的代码组织在一起，提高代码的可读性和可维护性，并减少代码中的重复内容。</li>
<li>模块化编程：预处理过程可以通过定义和使用宏来实现模块化编程。模块化编程将代码划分为独立的功能模块，使代码更易于理解、测试和维护。</li>
</ol>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>预处理过程</title>
    <url>/2023/09/05/%E9%A2%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>3.2 GCC命令参数</title>
    <url>/2023/09/05/3-2-GCC%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-2-1-什么是GCC"><a href="#3-2-1-什么是GCC" class="headerlink" title="3.2.1 什么是GCC ?"></a>3.2.1 什么是GCC ?</h1><p>GCC指的是GNU编译器套件（GNU Compiler Collection），它是一个开源的编译器集合。GCC包括预处理器、编译器、汇编器和链接器等工具，它能够将源代码转换为可执行文件。GCC支持多种编程语言，如C、C++、Objective-C、Fortran、Ada等，并且可在多个操作系统上使用，包括Linux、Unix、Windows等。</p>
<p>除了编译器本身，GCC还提供了一些文件处理工具，如objdump、objcopy、nm、readelf和strip等，用于处理目标文件、库文件和可执行文件。此外，GCC也提供了一套标准的库文件和头文件，供开发者在编译程序时使用。</p>
<h1 id="3-2-2-gcc-参数"><a href="#3-2-2-gcc-参数" class="headerlink" title="3.2.2 gcc 参数"></a>3.2.2 gcc 参数</h1><p>通过在GCC命令行中使用不同的参数，可以调用GCC工具集中的不同工具。以下是一些常用的参数和对应的工具：</p>
<ul>
<li><code>-E</code>：预处理，调用cpp预处理器，将源代码中的宏定义展开、包含头文件等操作。</li>
<li><code>-S</code>：生成汇编文件，GCC将合并预处理后的代码，并将其转换为汇编语言。</li>
<li><code>-c</code>：生成目标文件，调用汇编器as，将汇编代码转换为机器代码，但不进行链接操作。</li>
<li><code>-o &lt;output&gt;</code>：指定输出文件的名称，可以用于指定生成的目标文件或可执行文件的名称。</li>
<li><code>--verbose</code>：显示详细的编译信息，包括调用的工具和执行的步骤。</li>
</ul>
<p>gcc -E main.c<br>该命令会直接将预处理的内容打印到终端并不会生成一个文件，所以需要指定一下输出文件，重定向，如下所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309050822386.png" alt="image-20230905082213343"></p>
<p>同样的gcc -S main.c 也是如此</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309050822178.png" alt="image-20230905082250151"></p>
<p>更多参数的详细介绍</p>
<ol>
<li><p><strong>控制编译过程的参数</strong>：</p>
<ul>
<li><code>-c</code>：只编译源文件，生成目标文件而不进行链接。</li>
<li><code>-S</code>：生成汇编代码文件，不进行编译和链接。</li>
<li><code>-E</code>：只进行预处理，生成预处理后的源代码。</li>
<li><code>-o &lt;output&gt;</code>：指定输出文件的名称。</li>
<li><code>-I &lt;dir&gt;</code>：指定头文件搜索路径。</li>
<li><code>-L &lt;dir&gt;</code>：指定库文件搜索路径。</li>
<li><code>-M</code>：生成文件依赖关系。使用该选项时，GCC会分析源文件中的<code>#include</code>指令，输出每个源文件及其所包含的头文件之间的依赖关系。输出结果通常以makefile规则的格式呈现。</li>
<li><code>-MD</code>：与<code>-M</code>相同，但是将输出导入到<code>.d</code>文件中。生成的<code>.d</code>文件通常包含了源文件及其所包含的头文件之间的依赖关系，可以在makefile中引用这些<code>.d</code>文件来自动化编译过程。</li>
<li><code>-MM</code>：与<code>-M</code>相似，但忽略<code>#include &lt;file.h&gt;</code>产生的依赖关系。这意味着只生成自定义头文件（使用双引号<code>#include &quot;file.h&quot;</code>）的依赖关系，而不包括系统头文件（使用尖括号<code>#include &lt;file.h&gt;</code>）。</li>
<li></li>
</ul>
</li>
<li><p><strong>编译选项的设置</strong>：</p>
<ul>
<li><p><code>-std=&lt;standard&gt;</code>：指定使用的语言标准，如<code>-std=c11</code>表示使用C11标准。</p>
</li>
<li><p><code>-Wall</code>：开启所有警告信息。</p>
</li>
<li><p><code>-Werror</code>：将警告视为错误，编译过程中遇到警告将中止。</p>
</li>
<li><p><code>-Wextra</code>：开启额外的警告选项。</p>
</li>
<li><p><code>-pedantic</code>：严格遵循语言标准，显示更多警告信息。</p>
</li>
<li><p><code>-g</code>：在编译过程中生成调试信息，用于调试程序。这些调试信息可以被调试器（如GDB）使用。</p>
</li>
<li><p><code>-static</code>：禁止使用动态库，强制链接静态库。这意味着编译后的可执行文件将不依赖于系统上已安装的动态库，而是包含了所有必要的库的副本。</p>
</li>
<li><p><code>-shared</code>：生成共享目标文件，也称为共享库或动态库。共享库可以在运行时被不同的程序加载和使用。</p>
</li>
<li><p><code>-L&lt;dir&gt;</code>：指定库搜索路径。使用该选项可以告诉编译器在指定的目录中搜索库文件。</p>
</li>
<li><p><code>-l&lt;libname&gt;</code>：指定编译时使用的库。例如，<code>-lmath</code>将链接数学库。编译器会在标准库搜索路径和使用<code>-L</code>选项指定的路径中查找库文件。</p>
</li>
<li><p><code>-I&lt;dir&gt;</code>：指定头文件搜索路径。使用该选项可以告诉编译器在指定的目录中搜索头文件。</p>
</li>
<li><p><code>-w</code>：禁止生成任何警告信息。编译器将不会显示任何警告。</p>
</li>
<li><p><code>-std=c99</code>：指定使用C99标准进行编译。GCC默认采用GNU C标准。</p>
</li>
</ul>
</li>
<li><p><strong>编译器优化选项</strong>：</p>
<ul>
<li><code>-O0</code>、<code>-O1</code>、<code>-O2</code>、<code>-O3</code>：控制编译器的优化级别，从无优化到高级优化。</li>
<li><code>-Os</code>：优化代码大小。</li>
<li><code>-Ofast</code>：最大程度地优化代码执行速度，可能牺牲一些标准的符合性。</li>
<li><code>-march=&lt;arch&gt;</code>：指定目标处理器架构，优化代码以适应特定处理器。</li>
</ul>
</li>
</ol>
<h1 id="3-2-3-交叉编译"><a href="#3-2-3-交叉编译" class="headerlink" title="3.2.3 交叉编译"></a>3.2.3 交叉编译</h1><p>交叉编译是指在一种平台上进行编译，生成能够在另一种不同平台上运行的可执行文件或镜像。在交叉编译中，编译器和工具链被配置为目标平台的编译器和工具，以便生成与目标平台兼容的代码和可执行文件。</p>
<p>例如，如果你正在运行的是 x86 架构的电脑，但你想要编译一个在 ARM 架构的嵌入式设备上运行的程序，就需要进行交叉编译。在这种情况下，你需要使用针对 ARM 架构的交叉编译器和工具链，例如 <code>arm-linux-gnueabi-gcc</code>。</p>
<p>安装交叉编译器和工具链时，你可以使用适合你的发行版的包管理器。在这个例子中，你可以使用 <code>apt</code> 包管理器来安装 ARM 架构的交叉编译器和工具链，命令如下：</p>
<p>Copy</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install gcc-arm-linux-gnueabi</span><br></pre></td></tr></table></figure>

<p>安装完成后，你就可以使用 <code>arm-linux-gnueabi-gcc</code> 命令来进行 ARM 架构的交叉编译了。这样你就能够生成适用于 ARM 架构设备的可执行文件或镜像。</p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>程序的编译与可执行文件</title>
    <url>/2023/09/04/3-1-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-1-程序的编译与可执行文件"><a href="#3-1-程序的编译与可执行文件" class="headerlink" title="3.1 程序的编译与可执行文件"></a>3.1 程序的编译与可执行文件</h1><h2 id="3-1-1-可执行文件的组装"><a href="#3-1-1-可执行文件的组装" class="headerlink" title="3.1.1 可执行文件的组装"></a>3.1.1 可执行文件的组装</h2><p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042146452.png" alt="image-20230904214608380"></p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042146097.png" alt="image-20230904214623995"></p>
<p>编译过程的特点可以总结如下：</p>
<p>非一步到位：编译过程不是一次性完成的，而是分为多个阶段逐步完成的。</p>
<p>环环相扣：每个阶段的输出作为下一个阶段的输入，各个阶段之间有着紧密的联系和依赖关系。</p>
<p>分为预编译、编译、汇编、链接阶段：编译过程可以划分为预处理、编译、汇编和链接几个主要阶段。</p>
<p>调用不同的工具：每个阶段都调用不同的工具或编译器来完成特定的任务。</p>
<ul>
<li><p>预处理：在预处理阶段，预处理器将源文件进行处理，如宏展开、头文件包含等，生成处理后的源文件。</p>
</li>
<li><p>编译：在编译阶段，编译器将处理后的源文件转换为汇编语言代码，进行语法分析、语义分析、优化等操作。</p>
</li>
<li><p>汇编：在汇编阶段，汇编器将生成的汇编语言代码转换为机器语言指令，并生成目标文件。</p>
</li>
<li><p>链接：在链接阶段，链接器将多个目标文件和库文件进行链接，解析符号引用，生成可执行目标文件（如ELF格式）。</p>
</li>
</ul>
<p>生成可执行文件是编译过程中的最终目标，但为什么编译过程中不直接生成可执行文件，而是分为多个阶段呢？</p>
<p>首先是GNU的思想，即”一个工具只干一件事情”。GNU工具链以及许多其他编译工具都遵循这个原则。将编译过程分为多个阶段，每个阶段有专门的工具来处理，可以使得每个工具更加专注于自己的任务。例如，预处理器负责处理宏展开、头文件包含等，编译器负责将源代码转换为汇编代码，汇编器负责将汇编代码转换为机器代码，链接器负责将目标文件链接为可执行文件。这样的分工可以简化每个工具的实现和复杂度，使得工具更加可靠、可维护，并提高了工具的复用性。</p>
<p>其次是计算机工业思维中的标准接口和分层原则。将编译过程分为多个阶段，每个阶段的输入和输出都有明确定义的接口，使得每个阶段都可以独立进行开发和优化。这样的分层结构可以适配更多的平台、CPU架构和指令集，使得编译器可以在不同的系统上使用相同的前端和中间表示，通过后端进行特定平台的代码生成。这种模块化和分层的设计使得编译器更加灵活、可扩展，并能够适应不断变化的计算机体系结构和需求。</p>
<h2 id="3-1-2-从源程序到可执行文件"><a href="#3-1-2-从源程序到可执行文件" class="headerlink" title="3.1.2 从源程序到可执行文件"></a>3.1.2 从源程序到可执行文件</h2><p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042152389.png" alt="image-20230904215208244"></p>
<ol>
<li>预处理：源程序中的 <code>#include&lt;stdio.h&gt;</code> 被预处理器处理，将对应的头文件内容插入到源程序中，生成处理后的源程序。</li>
<li>编译：编译器将处理后的源程序进行语法分析、语义分析、优化等操作，生成目标文件。在目标文件中，包括以下部分：<ul>
<li>ELF header：ELF（可执行与可链接格式）头部，包含关于文件格式的信息。</li>
<li>Program header table：程序头表，描述程序的段（段包含代码、数据等）。</li>
<li>.text 段：包含程序的机器代码。</li>
<li>.rodata 段：包含只读数据，如字符串常量。</li>
<li>.data 段：包含已初始化的全局和静态变量。</li>
<li>.bss 段：包含未初始化的全局和静态变量。</li>
</ul>
</li>
<li>链接：链接器将目标文件进行链接，生成可执行文件。在可执行文件中，包括以下部分：<ul>
<li>ELF header：与目标文件相同，包含关于文件格式的信息。</li>
<li>Program header table：与目标文件相同，描述程序的段。</li>
<li>.text 段：与目标文件相同，包含程序的机器代码。</li>
<li>.rodata 段：与目标文件相同，包含只读数据。</li>
<li>.data 段：与目标文件相同，包含已初始化的全局和静态变量。</li>
<li>.bss 段：与目标文件相同，包含未初始化的全局和静态变量。</li>
<li>符号表（.symtab）：包含程序中定义的全局和静态符号的信息。</li>
<li>字符串表（.strtab）：保存符号表中的字符串。</li>
<li>调试信息（.debug）：包含调试器使用的信息。</li>
<li>行号信息（.line）：包含源代码的行号信息。</li>
</ul>
</li>
</ol>
<p>最终生成的可执行文件包含了程序的机器代码、数据、符号表等信息，可以在计算机上执行。编译过程中的中间文件和信息都嵌入到最终的可执行文件中，以便在运行时进行处理和调试。</p>
<h2 id="3-1-3-目标文件"><a href="#3-1-3-目标文件" class="headerlink" title="3.1.3 目标文件"></a>3.1.3 目标文件</h2><p>目标文件（Object file）是编译器生成的中间文件，它包含了编译后的机器代码、数据和符号信息，用于最终生成可执行文件或共享目标文件。目标文件的类型可以通过命令 <code>file</code> 进行查看。</p>
<p>常见的目标文件类型包括：</p>
<ul>
<li>可重定位目标文件（Relocatable files）：这种类型的目标文件包含了编译后的机器代码、数据和符号信息，但是它们的内部地址是相对于起始地址的偏移量，还没有进行最终的地址分配和链接。可重定位目标文件可以作为其他可重定位目标文件或可执行目标文件的输入，用于生成最终的可执行文件或共享目标文件。</li>
<li>可执行目标文件（Executable files）：这种类型的目标文件是经过链接的最终可执行文件，包含了所有的机器代码、数据和符号信息，可以直接在操作系统上执行。</li>
<li>可被共享目标文件（Shared object file）：也被称为动态链接库（Dynamic Linking Library）或共享库（Shared Library）。这种类型的目标文件包含了可被多个可执行文件或其他共享库共享使用的代码和数据，可以在运行时动态加载到内存中，并与其他程序共享使用。</li>
<li>可执行文件（ELF，Executable and Linkable Format）：这是一种可执行文件的格式，广泛用于类UNIX系统。可执行文件可以直接在操作系统上执行，包含了机器代码、数据和符号信息，以及其他与执行相关的信息（如程序入口点等）。</li>
</ul>
<h2 id="3-1-4-ELF可执行文件的结构"><a href="#3-1-4-ELF可执行文件的结构" class="headerlink" title="3.1.4 ELF可执行文件的结构"></a>3.1.4 ELF可执行文件的结构</h2><ol>
<li>ELF header（ELF 头）：包含了关于文件格式的信息，如文件类型、目标体系结构、入口点地址等。</li>
<li>Program header table（程序头表）：描述了可执行文件的段（segment）信息，每个段对应一个或多个节（section），包括代码段、只读数据段、可读写数据段等。程序头表记录了每个段的起始地址、大小、访问权限等信息。</li>
<li>.init 段：包含了可执行文件在加载到内存后需要执行的初始化代码，如全局变量的初始化和动态链接器的初始化等。</li>
<li>.text、.rodata、.data、.bss 等段：这些段包含了实际的代码和数据。<ul>
<li>.text 段：包含了可执行代码的机器指令，也就是程序的代码段。</li>
<li>.rodata 段：包含了只读数据，如字符串常量等。</li>
<li>.data 段：包含了已初始化的全局和静态变量。</li>
<li>.bss 段：包含了未初始化的全局和静态变量，这些变量在运行时会被初始化为 0。</li>
</ul>
</li>
<li>符号表（.symtab）：记录了程序中定义和引用的全局和静态符号的信息，如函数和变量。符号表中包含了符号的名称、类型、大小、地址等信息。</li>
<li>调试信息（.debug）：包含了调试器使用的信息，如源代码的行号信息、变量和函数的调试信息等。</li>
<li>行号信息（.line）：包含了源代码的行号信息，用于将机器代码映射回源代码的行号。</li>
<li>字符串表（.strtab）：保存了符号表和调试信息中使用的字符串。</li>
<li>Section header table（节头表）：描述了各个节的信息，包括名称、类型、偏移量、大小等。</li>
</ol>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_val = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> uninit_val;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> local_val = <span class="number">2</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> uninit_local_val;</span><br><span class="line">    </span><br><span class="line">    a = add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    b = sub(<span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sub.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用以下命令编译成目标文件，但是不进行链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c main.c sub.c</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042209197.png" alt="image-20230904220907171"></p>
<p>使用以下命令读取ELF header</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf -h main.o</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042211626.png" alt="image-20230904221103590"></p>
<p>然后使用以下命令查看节头表（section heads）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf -S main.o</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042213386.png" alt="image-20230904221310333"></p>
<p>最后使用以下命令进行链接,生成可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main.o sub.o</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042215351.png" alt="image-20230904221504326"></p>
<p>重新读取elf头和section heads</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">topeet@ubuntu:~/demo$ readelf -h a.out </span><br><span class="line">ELF 头：</span><br><span class="line">  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  类别:                              ELF64</span><br><span class="line">  数据:                              2 补码，小端序 (little endian)</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          0</span><br><span class="line">  类型:                              DYN (共享目标文件)</span><br><span class="line">  系统架构:                          Advanced Micro Devices X86-64</span><br><span class="line">  版本:                              0x1</span><br><span class="line">  入口点地址：               0x1060</span><br><span class="line">  程序头起点：          64 (bytes into file)</span><br><span class="line">  Start of section headers:          15016 (bytes into file)</span><br><span class="line">  标志：             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         13</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         31</span><br><span class="line">  Section header string table index: 30</span><br><span class="line">topeet@ubuntu:~/demo$ read</span><br><span class="line">read         readarray    readelf      readlink     readonly     readprofile  </span><br><span class="line">topeet@ubuntu:~/demo$ readelf -S a.out </span><br><span class="line">There are 31 section headers, starting at offset 0x3aa8:</span><br><span class="line"></span><br><span class="line">节头：</span><br><span class="line">  [号] 名称              类型             地址              偏移量</span><br><span class="line">       大小              全体大小          旗标   链接   信息   对齐</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .interp           PROGBITS         0000000000000318  00000318</span><br><span class="line">       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">  [ 2] .note.gnu.propert NOTE             0000000000000338  00000338</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE             0000000000000358  00000358</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .note.ABI-tag     NOTE             000000000000037c  0000037c</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 5] .gnu.hash         GNU_HASH         00000000000003a0  000003a0</span><br><span class="line">       0000000000000028  0000000000000000   A       6     0     8</span><br><span class="line">  [ 6] .dynsym           DYNSYM           00000000000003c8  000003c8</span><br><span class="line">       00000000000000c0  0000000000000018   A       7     1     8</span><br><span class="line">  [ 7] .dynstr           STRTAB           0000000000000488  00000488</span><br><span class="line">       0000000000000088  0000000000000000   A       0     0     1</span><br><span class="line">  [ 8] .gnu.version      VERSYM           0000000000000510  00000510</span><br><span class="line">       0000000000000010  0000000000000002   A       6     0     2</span><br><span class="line">  [ 9] .gnu.version_r    VERNEED          0000000000000520  00000520</span><br><span class="line">       0000000000000020  0000000000000000   A       7     1     8</span><br><span class="line">  [10] .rela.dyn         RELA             0000000000000540  00000540</span><br><span class="line">       00000000000000c0  0000000000000018   A       6     0     8</span><br><span class="line">  [11] .rela.plt         RELA             0000000000000600  00000600</span><br><span class="line">       0000000000000018  0000000000000018  AI       6    24     8</span><br><span class="line">  [12] .init             PROGBITS         0000000000001000  00001000</span><br><span class="line">       000000000000001b  0000000000000000  AX       0     0     4</span><br><span class="line">  [13] .plt              PROGBITS         0000000000001020  00001020</span><br><span class="line">       0000000000000020  0000000000000010  AX       0     0     16</span><br><span class="line">  [14] .plt.got          PROGBITS         0000000000001040  00001040</span><br><span class="line">       0000000000000010  0000000000000010  AX       0     0     16</span><br><span class="line">  [15] .plt.sec          PROGBITS         0000000000001050  00001050</span><br><span class="line">       0000000000000010  0000000000000010  AX       0     0     16</span><br><span class="line">  [16] .text             PROGBITS         0000000000001060  00001060</span><br><span class="line">       0000000000000225  0000000000000000  AX       0     0     16</span><br><span class="line">  [17] .fini             PROGBITS         0000000000001288  00001288</span><br><span class="line">       000000000000000d  0000000000000000  AX       0     0     4</span><br><span class="line">  [18] .rodata           PROGBITS         0000000000002000  00002000</span><br><span class="line">       0000000000000014  0000000000000000   A       0     0     4</span><br><span class="line">  [19] .eh_frame_hdr     PROGBITS         0000000000002014  00002014</span><br><span class="line">       0000000000000064  0000000000000000   A       0     0     4</span><br><span class="line">  [20] .eh_frame         PROGBITS         0000000000002078  00002078</span><br><span class="line">       0000000000000188  0000000000000000   A       0     0     8</span><br><span class="line">  [21] .init_array       INIT_ARRAY       0000000000003db8  00002db8</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [22] .fini_array       FINI_ARRAY       0000000000003dc0  00002dc0</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [23] .dynamic          DYNAMIC          0000000000003dc8  00002dc8</span><br><span class="line">       00000000000001f0  0000000000000010  WA       7     0     8</span><br><span class="line">  [24] .got              PROGBITS         0000000000003fb8  00002fb8</span><br><span class="line">       0000000000000048  0000000000000008  WA       0     0     8</span><br><span class="line">  [25] .data             PROGBITS         0000000000004000  00003000</span><br><span class="line">       0000000000000018  0000000000000000  WA       0     0     8</span><br><span class="line">  [26] .bss              NOBITS           0000000000004018  00003018</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     4</span><br><span class="line">  [27] .comment          PROGBITS         0000000000000000  00003018</span><br><span class="line">       000000000000002b  0000000000000001  MS       0     0     1</span><br><span class="line">  [28] .symtab           SYMTAB           0000000000000000  00003048</span><br><span class="line">       00000000000006f0  0000000000000018          29    49     8</span><br><span class="line">  [29] .strtab           STRTAB           0000000000000000  00003738</span><br><span class="line">       0000000000000255  0000000000000000           0     0     1</span><br><span class="line">  [30] .shstrtab         STRTAB           0000000000000000  0000398d</span><br><span class="line">       000000000000011a  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br><span class="line">topeet@ubuntu:~/demo$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-1-5-动态库和静态库的生成"><a href="#3-1-5-动态库和静态库的生成" class="headerlink" title="3.1.5 动态库和静态库的生成"></a>3.1.5 动态库和静态库的生成</h2><p>使用以下命令可以生成静态库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ar rcs libsub.a sub.o</span><br></pre></td></tr></table></figure>

<p>其中库的名字必须以lib开头，使用readelf重新读取以下该库的elf头，如下所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042226316.png" alt="image-20230904222640273"></p>
<p>使用以下命令生成动态库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -shared -fPIC -o libsub.so sub.c</span><br></pre></td></tr></table></figure>

<p>然后使用readelf 读取elf头如下所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042227936.png" alt="image-20230904222725900"></p>
]]></content>
      <categories>
        <category>c高级编程</category>
      </categories>
      <tags>
        <tag>程序的编译、链接和运行</tag>
      </tags>
  </entry>
  <entry>
    <title>rk3568 驱动开发第一篇 驱动基础</title>
    <url>/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%80%E7%AF%87-%E9%A9%B1%E5%8A%A8%E5%9F%BA%E7%A1%80-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第1章-前言"><a href="#第1章-前言" class="headerlink" title="第1章 前言"></a>第1章 前言</h1><p>磨刀不误砍柴工！在学习驱动之前先和同学们交流下学习方法和学习态度。</p>
<h2 id="1-1-学习方法"><a href="#1-1-学习方法" class="headerlink" title="1.1 学习方法"></a>1.1 学习方法</h2><p>在学习驱动的过程中，同学们难免会遇到很多问题，例如编译环境的问题造成内核编译不通过、交叉编译器或者架构类型没有设置导致驱动编译失败、内核版本和驱动版本不统一造成驱动加载不成功等多种问题。</p>
<p>在遇到问题的时候，同学们一定不要灰心，要敢于去尝试用自己的思路去解决问题。机遇与挑战往往是并存的。当同学们解决一个问题以后，自然就会前进一步。水滴石穿，才可以真正掌握linux驱动。</p>
<p> 所以一定要养成独立思考的好习惯！遇到问题之后，同学们可以先自己根据问题的具体表现，来找到问题的源头，仔细分析问题产生的原因和解决的方法，自主思考无果之后可以尝试去谷歌、百度、CSDN等各大检索网站上寻求帮助，Linux已经发展了很多年，前辈们在之前进行了无数的探索，总有许多类似的经验，能解决绝大多数的问题。</p>
<p>并且在学习过程中千万不要好高骛远，比如对于一些有基础的同学来说，学习过相似的知识点就一目十行甚至直接跳过，这种行为是不可取的，学习一遍和学习两遍的知识点，在认知和运用程度上是完全不一样的。读书要从薄到厚,再厚到薄，学习亦是如此。</p>
<p>端正学习态度后还要有一个好的学习方法，迅为公司在多年培训和产品开发中总结出来了一套适合初学者的学习方式，具体含义解释为框架化学习，快速原型。运用到嵌入式Linux驱动学习上就是从一开始先看到Linux驱动知识领域的外貌，然后逐渐深入！以了解北京这座城市为例，如果在胡同里转来转去，可能几年都搞不清楚这个城市是什么情况，但是如果先通过北京地图学习一下，了解天安门在什么地方，鸟巢在什么地方，香山八达岭在哪里，然后到这些地方看一看，可能很快就能掌握这座城市的全貌。所以运用框架学习法，在对不同层次的框架进行学习过程中，逐渐了解和掌握整个系统。 如果不注意方法，每天在胡同里面来回转悠，肯定是事倍功半，很长时间将不得要领。</p>
<p>需要注意的是，即便有了地图，也需要一些基础，比如知道什么是天安门，知道鸟巢的来历，明白八达岭是怎么回事，实际上这些就是基础知识。也就是说在学习系统框架之前要具备一定的基础，否则这张地图也是看不懂的。学习驱动知识也是需要一定的基础的，所以驱动学习是有门槛的！</p>
<p>对于学习方法和学习态度就先说这样多，关于基础方面，下一节会专门讨论。 </p>
<h2 id="1-2-基础准备"><a href="#1-2-基础准备" class="headerlink" title="1.2 基础准备"></a>1.2 基础准备</h2><p>首先，不要脱离硬件。就好比用仿真软件学习51单片机是永远掌握不了单片机的精髓的。所以有一块硬件开发板是学习驱动的前提。</p>
<p>第二，有了开发板之后，要掌握开发板的基本操作。如开发板的启动，烧写镜像等操作。</p>
<p>第三，能够成功编译开发板的系统源码。在驱动的学习过程中，是避免不了的要对内核的某些功能进行使能、修改设备树添加对应的设备，这些操作都需要进行源码编译。</p>
<p>第四，掌握C语言。驱动程序是由C语言编写的，而且内核源码中绝大多数的代码也都是由C语言编写的，在学习驱动的过程中，或多或少的要对源码进行阅读。所以C语言基础是学习驱动的必要条件之一。</p>
<p>第五，掌握Linux环境搭建以及shell命令的使用。</p>
<p>第六，驱动最后必然要落实到相应的硬件上，所以肯定要对底层电路有所了解，以驱动LED灯为例，必然要了解其控制电路，找到相应的控制引脚，要能读懂简单的硬件原理图。</p>
<h1 id="第2章-你好！内核源码"><a href="#第2章-你好！内核源码" class="headerlink" title="第2章 你好！内核源码"></a>第2章 你好！内核源码</h1><p>本章我们来认识Linux内核源码，开始真正进入到驱动的世界里面，不知道各位小伙伴们有没有做好准备呢？ </p>
<h2 id="2-1-初识内核源码"><a href="#2-1-初识内核源码" class="headerlink" title="2.1 初识内核源码"></a>2.1 初识内核源码</h2><p>Linux内核源码的官方网站为<a href="https://www.kernel.org/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%AF%A5%E7%BD%91%E7%AB%99%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%9A%84Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E3%80%82%E8%BF%9B%E5%85%A5%E8%AF%A5%E7%BD%91%E7%AB%99%E4%B9%8B%E5%90%8E%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%88%E5%9B%BE2-1%EF%BC%89%E6%89%80%E7%A4%BA%EF%BC%9A">https://www.kernel.org/，可以在该网站下载最新的Linux内核源码。进入该网站之后如下图（图2-1）所示：</a></p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115782.png"></p>
<p>图 2-1</p>
<p>从上图（图1）可以看到多个版本的内核分支，分别为主线版本（mainline）、稳定版本（stable）和长期支持版本（longterm）。以上各个支线和主线是由linus torvalds（Linux之父）所领导。半导体厂商和一些内核爱好者会在官网下载相应版本的内核源码，对该源码进行打补丁等操作。以此让官网的内核源码可以在半导体厂家设计的主控（CPU）上跑起来，所以在开发和学习的过程中，我们并不会直接去Linux内核官网下去下载源码，而且是使用半导体厂家提供的源码包。</p>
<p>但是不论是Linux官网的内核源码还是半导体厂家提供的内核源码不影响我们来看它的庐山真面目！作者下载了Linux官方网站的4.19.262分支源码，下载好的源码存放在“iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\01_Linux内核官方源码”如下图（图2-2）所示： </p>
<p>将Linux内核官方源码拷贝到虚拟机ubuntu上如下图（图2-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115757.jpeg" alt="img"> </p>
<p>图 2-3</p>
<p>使用以下命令对内核官方源码进行解压，解压完成如下图（图2-4）所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tar -vxf linux-4.19.262.tar.xz </span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115774.jpeg" alt="img"> </p>
<p>图 2-4</p>
<p>解压完成后我们会看到非常多的文件夹，这些文件夹放的就是Linux内核源码，在下一小节中作者来介绍Linux内核源码的结构和每个目录的作用。</p>
<h2 id="2-2-内核源码结构"><a href="#2-2-内核源码结构" class="headerlink" title="2.2 内核源码结构"></a>2.2 内核源码结构</h2><p>上一小节解压的目录下的内核源码目录都是用来做什么的呢？如下图（图2-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115788.jpeg" alt="img"> </p>
<p>图 2-5</p>
<p>目录的内容如下表（表2-6）所示：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>arch</td>
<td>存放不同平台体系相关代码</td>
</tr>
<tr>
<td>block</td>
<td>存放块设备相关代码</td>
</tr>
<tr>
<td>crypto</td>
<td>存放加密、压缩、CRC校验等算法相关代码</td>
</tr>
<tr>
<td>Documentation</td>
<td>存放相关说明文档，很多实用文档，包括驱动编写等</td>
</tr>
<tr>
<td>drivers</td>
<td>存放Linux 内核设备驱动程序源码。该目录包含众多驱动，目录按照设备类别进行分类，如 char、block 、input、i2c、spi、pci、usb等。</td>
</tr>
<tr>
<td>firmware</td>
<td>存放处理器相关的一些特殊固件</td>
</tr>
<tr>
<td>fs</td>
<td>存放虚拟文件系统代码</td>
</tr>
<tr>
<td>include</td>
<td>存放内核所需、与平台无关的头文件</td>
</tr>
<tr>
<td>init</td>
<td>Linux系统启动初始化相关的代码</td>
</tr>
<tr>
<td>ipc</td>
<td>存放进程间通信代码</td>
</tr>
<tr>
<td>kernel</td>
<td>Linux内核的核心代码，包含了进程调度子系统，以及和进程调度相关的模块。</td>
</tr>
<tr>
<td>lib</td>
<td>库文件代码， 实现需要在内核中使用的库函数，例如CRC、FIFO、list、MD5等。</td>
</tr>
<tr>
<td>mm</td>
<td>实现存放内存管理代码</td>
</tr>
<tr>
<td>net</td>
<td>存放网络相关代码</td>
</tr>
<tr>
<td>samples</td>
<td>存放提供的一些内核编程范例</td>
</tr>
<tr>
<td>scripts</td>
<td>存放一些脚本文件</td>
</tr>
<tr>
<td>security</td>
<td>存放系统安全性相关代码</td>
</tr>
<tr>
<td>sound</td>
<td>存放声音、声卡相关驱动</td>
</tr>
<tr>
<td>tools</td>
<td>一些常用工具，如性能剖析、自测试等</td>
</tr>
<tr>
<td>usr</td>
<td>用于生成initramfs的代码。</td>
</tr>
<tr>
<td>virt</td>
<td>提供虚拟机技术（KVM等）的支持</td>
</tr>
</tbody></table>
<p>表 2-6</p>
<h2 id="2-3-编译内核源码"><a href="#2-3-编译内核源码" class="headerlink" title="2.3 编译内核源码"></a>2.3 编译内核源码</h2><p>本小节使用的内核源码是半导体厂家提供的内核源码，是我们学习和开发要使用的内核源码。在进行驱动学习之前需要将此内核源码编译成功。</p>
<p>内核源码存放路径为“iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\02_Linux_SDK源码”，将对应目录下的内核源码拷贝到虚拟机ubuntu目录下，如下图（图2-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115736.jpeg" alt="img"></p>
<p>图 2-7</p>
<p>注：编译环境使用的是迅为搭建好的编译环境，迅为的环境经过测试在不进行修改的前提下，可以直接将内核源码编译通过。</p>
<p>使用以下命令对内核源码的进行解压，解压完成如下图（图2-8）所示：</p>
<p>tar -vxf linux_sdk.tar.gz</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115720.jpeg" alt="img"></p>
<p>图 2-8</p>
<p>使用“cd linux_sdk”命令进入内核源码目录，如下图（图2-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115085.jpeg" alt="img"></p>
<p>图 2-9</p>
<p>使用命令“.&#x2F;build.sh kernel”进行内核源码的编译，编译过程如下图（图2-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115089.jpeg" alt="img"></p>
<p>图 2-10</p>
<p>编译时间和电脑虚拟机配置相关，编译完成如下图（图2-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115144.jpeg" alt="img"></p>
<p>图 2-11</p>
<p>通过对内核源码官网的探索，内核源码的目录结构讲解以及内核源码的编译。我相信大家对Linux内核源码应该有了一个初步的认识了。下一章我们来学习第一个驱动helloworld。</p>
<h1 id="第3章-helloworld-驱动实验"><a href="#第3章-helloworld-驱动实验" class="headerlink" title="第3章 helloworld 驱动实验"></a>第3章 helloworld 驱动实验</h1><p>在学习C语言或者其他语言的时候，我们通常是打印一句“helloworld”来开启编程世界的大门。学习驱动程序编程亦可以如此，使用helloworld作为我们的第一个驱动程序。</p>
<p>接下来开始编写第一个驱动程序—helloworld。</p>
<h2 id="3-1-驱动编写"><a href="#3-1-驱动编写" class="headerlink" title="3.1 驱动编写"></a>3.1 驱动编写</h2><p>本小节来编写一个最简单的驱动——helloworld驱动。helloworld.c如下（图3-1）所示代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);<span class="comment">//注意：内核打印用printk而不是printf</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);    <span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(helloworld_exit);    <span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    <span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);    <span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>



<p>图 3-1</p>
<p>看似非常简单的helloworld驱动代码，却五脏俱全。一个简单的helloworld驱动包含驱动的基本框架。我们继续往下看。</p>
<h2 id="3-2-驱动的基本框架"><a href="#3-2-驱动的基本框架" class="headerlink" title="3.2 驱动的基本框架"></a>3.2 驱动的基本框架</h2><p>Linux驱动的基本框架主要由模块加载函数，模块卸载函数，模块许可证声明，模块参数，模块导出符号，模块作者信息等几部分组成，其中模块参数，模块导出符号，模块作者信息是可选的部分，也就是可要可不要。剩余部分是必须有的。我们来看一下这几个部分的作用：</p>
<p>1 模块加载函数</p>
<p>当使用加载驱动模块时，内核会执行模块加载函数，完成模块加载函数中的初始化工作。</p>
<p>2 模块卸载函数</p>
<p>当卸载某模块时，内核会执行模块卸载函数，完成模块卸载函数中的退出工作。</p>
<p>3 模块许可证声明</p>
<p>许可证声明描述了内核模块的许可权限，如果不声明模块许可，模块在加载的时候，会收到“内核被污染（kernel tainted）”的警告。可接受的内核模块声明许可包括“GPL”“GPL v2”。</p>
<p>4 模块参数（可选择）</p>
<p>模块参数是模块被加载的时候可以传递给它的值。</p>
<p>5 模块导出符号（可选择）</p>
<p>内核模块可以导出的符号，如果导出，其他模块可以使用本模块中的变量或函数。</p>
<p>6 模块作者信息等说明（可选择）</p>
<p>上一小节我们说，helloworld驱动麻雀虽小五脏俱全，我们来分析helloworld驱动。通过helloworld代码再来看驱动框架。</p>
<p>（1）模块加载函数：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">module_init(helloworld_init);    <span class="comment">//注册入口函数</span></span><br></pre></td></tr></table></figure>

<p>（2）模块卸载函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_exit(helloworld_exit);    <span class="comment">//注册出口函数</span></span><br></pre></td></tr></table></figure>

<p>（3）模块许可证声明</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    <span class="comment">//同意GPL开源协议</span></span><br></pre></td></tr></table></figure>

<p>（4）模块作者信息</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);    <span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>（5）头文件</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">//模块加载函数和卸载函数需要的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>通过上面的分析，helloworld驱动是不是包含了驱动框架的所有必要的部分呢。因此helloworld驱动我们可以看作是驱动代码的模板。任何一个驱动代码都用它作为基础来编写实现。同学们要将他记忆下来！</p>
<h1 id="第4章-内核模块实验"><a href="#第4章-内核模块实验" class="headerlink" title="第4章 内核模块实验"></a>第4章 内核模块实验</h1><p>在上一章节我们编写了最简单的helloworld驱动程序。有了驱动程序以后，要如何编译并使用驱动呢。编译驱动有俩种方法，分别是将驱动编译成内核和将驱动编译成内核模块。我们先来学习如何将驱动编译成内核模块、</p>
<h2 id="4-1-设置交叉编译器"><a href="#4-1-设置交叉编译器" class="headerlink" title="4.1 设置交叉编译器"></a>4.1 设置交叉编译器</h2><p>1 下载网盘资料下的交叉编译器，网盘路径为：“XXX”，将下载的交叉编译器拷贝到Ubuntu的&#x2F;usr&#x2F;local目录下，如下图（图4-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115189.jpeg" alt="img"></p>
<p>图 4-1</p>
<p>2 输入以下命令，解压交叉编译编译器压缩包，解压完毕会生成“gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu”文件夹，这是实验需要的交叉编译工具，如下图（图4-2）所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -vxf gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115207.jpeg" alt="img"></p>
<p>图 4-2</p>
<p>3 在终端输入“sudo vi &#x2F;etc&#x2F;profile”命令，在文件最后输入以下命令修改环境变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115170.jpeg" alt="img"></p>
<p>图 4-3</p>
<p>4 保存退出，在终端输入“reboot”命令重新启动Ubuntu系统，使交叉编译环境生效。Ubuntu系统重新启动之后，登录到系统后，打开终端，输入命令“aarch64-linux-gnu-gcc -v”，如果终端有如下图（图4-4）所示的打印信息，说明交叉编译环境搭建成功。如果没有出现如下图（图4-4）的打印信息，需要检查上一步骤是否设置正确。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115469.jpeg" alt="img"></p>
<p>图 4-4</p>
<h2 id="4-2-编写Makefile"><a href="#4-2-编写Makefile" class="headerlink" title="4.2 编写Makefile"></a>4.2 编写Makefile</h2><p>编译驱动程序还需要使用Makefile文件。我们为helloworld.c编写一个简单的Makefile，Makefile文件和源文件helloworld.c位于同一级目录，代码如下（图4-5）所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64  </span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-  </span><br><span class="line">obj-m += helloworld.o    <span class="comment">#helloworld.c对应.o文件的名称。名称要保持一致。</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#内核源码所在虚拟机ubuntu的实际路径</span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>图 4-5</p>
<p>代码解释如下：</p>
<p>第1行设置ARCH变量为arm64</p>
<p>第2行设置交叉编译器前缀为aarch64-linux-gnu-</p>
<p>第3行obj-m +&#x3D; &lt;文件&gt;：将指定的文件（需要是以.o结尾）设为编译时以模块形式编译</p>
<p>第4行是设备树内核的源码路径，请大家根据实际内核路径进行修改。</p>
<p>第5行是获取当前目录的变量</p>
<p>第7行是编译make操作，会进入内核源码的路径，然后把当前路径下的代码编译成模块。</p>
<p>第9行是清除编译文件</p>
<p>编写完成如下图（图4-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115551.jpeg" alt="img"></p>
<p>图 4-6</p>
<h2 id="4-3-编译模块"><a href="#4-3-编译模块" class="headerlink" title="4.3 编译模块"></a>4.3 编译模块</h2><p>有了Makefile以后，输入“make”命令就可以编译helloworld驱动模块，如下图（图4-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115536.jpeg" alt="img"></p>
<p>图 4-7</p>
<p>编译完生成helloworld.ko目标文件就是我们需要的内核模块。内核模块是以ko为后缀名，如下图（图4-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115548.jpeg" alt="img"></p>
<p>图 4-8</p>
<p>输入“make clean”命令清除编译文件，如下图（图4-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115544.jpeg" alt="img"></p>
<p>图 4-9</p>
<h2 id="4-4-模块加载与卸载"><a href="#4-4-模块加载与卸载" class="headerlink" title="4.4 模块加载与卸载"></a>4.4 模块加载与卸载</h2><p>有了内核模块以后，我们要如何使用呢？编译驱动有俩种方式，那Linux驱动的运行方式也肯定有俩种。一种就是将驱动编译进内核，这样Linux系统启动后会自动运行程序。第二种就是将驱动编译成模块，在Linux系统启动以后使用“insmod”命令加载驱动模块。</p>
<p>在上个小节中编译了驱动模块helloworld.ko，在RK3568开发板上通过“insmod helloworld.ko”命令可以加载驱动，在加载驱动模块的时候会执行驱动入口的函数，也就是helloworld程序中的helloworld_init函数，所以可以看到打印出来的字符串信息“helloworld_init”。如下图（图4-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115579.jpeg" alt="img"></p>
<p>图 4-10</p>
<p>如果要卸载helloworld内核模块，可以通过“rmmod helloworld”命令来卸载驱动模块，同理在卸载驱动模块的时候会执行驱动出口的函数，所以可以看到驱动出口函数打印出来的字符串信息“helloworld_exit”，如下图（图4-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115931.jpeg" alt="img"></p>
<p>图 4-11</p>
<p>加载驱动模块也可以使用modprobe命令，它比insmod命令更强大，modprobe命令在加载驱动模块的时候，会同时加载该模块依赖的其他模块。比如helloworld.ko依赖before.ko，使用insmod加载的时候，就必须先加载before.ko，然后在加载helloworld.ko才可以加载成功从。但是使用modprobe加载的时候，他会自动分析模块的依赖关系，然后将所有的依赖的模块都加载到内核当中。比较“聪明”。</p>
<p>同样，在卸载驱动模块的时候，如果模块存在依赖关系，如果使用insmod命令，需要手动卸载依赖的内核模块，但是使用modprobe命令可以自动卸载驱动模块所依赖的其他模块。</p>
<p>所以，如果驱动模块是以“modprobe helloworld.ko”命令加载的，卸载的时候使用“modprobe -r helloworld.ko”命令卸载。</p>
<p>但是使用modprobe卸载存在一个问题，如果所依赖的模块被其他模块所使用，比如刚才例子中的before.ko还被其他的模块使用，这时候就不能使用modprobe卸载。所以还是推荐使用rmmod命令来卸载。</p>
<h2 id="4-5查看模块信息"><a href="#4-5查看模块信息" class="headerlink" title="4.5查看模块信息"></a>4.5查看模块信息</h2><p>在驱动模块加载之后，使用“modinfo helloworld.ko”命令可以获得模块的信息，包括模块作者，模块说明，模块支持的参数等等。</p>
<p>lsmod 命令可以列出已经载入Linux内核模块，在helloworld驱动加载之后，查看内核中加载的模块，如下（图4-12）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115860.jpeg" alt="img"></p>
<p>图 4-12</p>
<h1 id="第5章-驱动模块传参实验"><a href="#第5章-驱动模块传参实验" class="headerlink" title="第5章 驱动模块传参实验"></a>第5章 驱动模块传参实验</h1><p>经过前两章实验的实战操作，我们已经完成最简单的helloworld驱动实验和模块驱动实验，加载模块可以使用“insmod”函数，使用“insmod”函数进行模块加载时也能进行参数的传递。运用得当可以极大提升内核测试速度。本节就来学习一下如何进行驱动模块的传参。</p>
<h2 id="5-1-驱动模块传参简介"><a href="#5-1-驱动模块传参简介" class="headerlink" title="5.1 驱动模块传参简介"></a>5.1 驱动模块传参简介</h2><p> 驱动模块传参是一种可以随时向内核模块传递、修改参数的方法。例如可以传递串口驱动的波特率、数据位数、校验位、停止位等参数，进行功能的设置，以此节省编译模块的时间，大大提高调试速度。</p>
<p> Linux内核提供了 module_param(name, type, perm)、module_param_array(name, type, nump, perm)宏和module_param_string(name, string, len, perm)宏，分别进行基本类型、数组和字符串参数的传递。它们定义在 “内核源码&#x2F;include&#x2F;linux&#x2F;moduleparam.h”文件中(在module.h文件中已经对export.h进行引用，所以不需要单独引用moduleparam.h文件),详细定义如下（图5-1）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> module_param(name, type, perm)              \</span></span><br><span class="line"><span class="meta">    module_param_named(name, name, type, perm)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_param_array(name, type, nump, perm)      \</span></span><br><span class="line"><span class="meta">module_param_array_named(name, name, type, nump, perm)  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_param_string(name, string, len, perm)            \</span></span><br><span class="line"><span class="meta">    static const struct kparam_string __param_string_##name     \                                                                                                                                                                                           </span></span><br><span class="line">        = &#123; len, <span class="built_in">string</span> &#125;;                  \</span><br><span class="line">    __module_param_call(MODULE_PARAM_PREFIX, name,          \</span><br><span class="line">                &amp;param_ops_string,              \</span><br><span class="line">                .str = &amp;__param_string_#<span class="meta">#name, perm, -1, 0);\</span></span><br><span class="line"><span class="meta">    __MODULE_PARM_TYPE(name, <span class="string">&quot;string&quot;</span>) </span></span><br></pre></td></tr></table></figure>

<p>图5-1</p>
<p>以上宏定义中的 module_param ()函数可以用来进行基本类型参数的传递，传入的三个参数定义如下：</p>
<p>l name：模块参数的名称</p>
<p>l type： 模块参数的数据类型</p>
<p>l perm： 模块参数的访问权限</p>
<p>参数type可以取以下任意一种情况：</p>
<ul>
<li>bool <strong>:</strong> 布尔型</li>
<li>inbool <strong>:</strong> 布尔反值</li>
<li>charp**:** 字符指针（相当于char *,不超过1024字节的字符串）</li>
<li>short**:** 短整型</li>
<li>ushort <strong>:</strong> 无符号短整型</li>
<li>int <strong>:</strong> 整型</li>
<li>uint <strong>:</strong> 无符号整型</li>
<li>long <strong>:</strong> 长整型</li>
<li>ulong**:** 无符号长整型。</li>
</ul>
<p>参数perm表示该参数在sysfs文件系统中所对应的文件节点的属性，其权限定义在“内核源码&#x2F;include&#x2F;linux&#x2F;stat.h”文件中。可以用宏定义和数字法两种方式来表示。详细宏定义如下（图5-2）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRUSR 00400 <span class="comment">/*文件所有者可读*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWUSR 00200 <span class="comment">/*文件所有者可写*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXUSR 00100 <span class="comment">/*文件所有者可执行*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRGRP 00040 <span class="comment">/*与文件所有者同组的用户可读*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWGRP 00020 <span class="comment">/*与文件所有者同组的用户可写*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXGRP 00010 <span class="comment">/*与文件所有者同组的用户可执行*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IROTH 00004 <span class="comment">/*与文件所有者不同组的用户可读*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWOTH 00002 <span class="comment">/*与文件所有者不同组的用户可写*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXOTH 00001 <span class="comment">/*与文件所有者不同组的用户可可执行*/</span></span></span><br></pre></td></tr></table></figure>

<p>图5-2</p>
<p>如果要传递数组类型参数可以使用 module_param_array ()函数，相较于 module_param ()函数多了n_para参数，用来表示传递参数个数;n_para参数值会根据输入的参数个数而改变,n_para的最终值为传递的数组元素个数。</p>
<p>最后是 module_param_string(name, string, len, perm)函数，用来传递字符串类型的变量，四个参数的定义如下所示：</p>
<ul>
<li>name：外部传入的参数名，即加载模块时的传入值</li>
<li>string:内部的变量名，即程序内定义的参数名</li>
<li>len:以string命名的buffer大小(可以小于buffer的大小，但是没有意义)</li>
<li>perm:模块参数的访问权限</li>
</ul>
<p>至此，关于驱动模块传参所使用的函数就讲解完成了，在下一小节中将编写驱动模块传参函数代码。</p>
<h2 id="5-2-实验程序的编写"><a href="#5-2-实验程序的编写" class="headerlink" title="5.2 实验程序的编写"></a>5.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\02。</p>
<p>本章实验将编写Linux下的驱动传参实例代码，通过“insmod”命令进行参数的传递，并将相应的参数打印到串口终端上。</p>
<p>编写完成的parameter.c代码如下（图5-3）所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> number;<span class="comment">//定义int类型变量number</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *name;<span class="comment">//定义char类型变量name</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> para[<span class="number">8</span>];<span class="comment">//定义int类型的数组</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> str1[<span class="number">10</span>];<span class="comment">//定义char类型字符串str1</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> n_para;<span class="comment">//定义int类型的用来记录module_param_array函数传递数组元素个数的变量n_para</span></span><br><span class="line">module_param(number, <span class="type">int</span>, S_IRUGO);<span class="comment">//传递int类型的参数number，S_IRUGO表示权限为可读</span></span><br><span class="line">module_param(name, charp, S_IRUGO);<span class="comment">//传递char类型变量name</span></span><br><span class="line">module_param_array(para , <span class="type">int</span> , &amp;n_para , S_IRUGO);<span class="comment">//传递int类型的数组变量para</span></span><br><span class="line">module_param_string(str, str1 ,<span class="keyword">sizeof</span>(str1), S_IRUGO);<span class="comment">//传递字符串类型的变量str1</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">parameter_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;%d\n&quot;</span>,number);</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;%s\n&quot;</span>,name);                                                                                                                                                          </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n_para; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_EMERG <span class="string">&quot;para[%d] : %d \n&quot;</span>, i, para[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;%s\n&quot;</span>,str1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">parameter_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;parameter_exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(parameter_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(parameter_exit);<span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>); <span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>图5-3</p>
<p>以上代码将传递int类型参数number、char类型参数name、int类型的数组para和char类型字符串str1，并在驱动入口函数中，对各个参数进行打印。在下一小节会进行驱动加载测试。</p>
<h2 id="5-3-运行测试"><a href="#5-3-运行测试" class="headerlink" title="5.3 运行测试"></a>5.3 运行测试</h2><h3 id="5-3-1-编译驱动程序"><a href="#5-3-1-编译驱动程序" class="headerlink" title="5.3.1 编译驱动程序"></a>5.3.1 编译驱动程序</h3><p>在上一小节中的parameter.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图5-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += parameter.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>图5-4</p>
<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放parameter.c和Makefile文件目录下，如下图（图5-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115943.jpeg" alt="img"> </p>
<p>图5-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图5-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115870.jpeg" alt="img"> </p>
<p>图5-6</p>
<p>编译完生成 parameter.ko目标文件，如下图（图5-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115920.jpeg" alt="img"> </p>
<p>图5-7</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h3 id="5-3-2-运行测试"><a href="#5-3-2-运行测试" class="headerlink" title="5.3.2 运行测试"></a>5.3.2 运行测试</h3><p>在上一章节中已经学习了使用insmod命令加载模块，而驱动模块传参的命令格式为</p>
<p>insmod 对应的模块 参数</p>
<p>parameter.ko 驱动加载可以传递3个参数，分别为int类型的参数number，char类型的参数name和int数组类型的参数para。使用以下命令进行驱动的加载，加载完成之后的打印信息如下图（图5-8）所示：</p>
<p>insmod parameter.ko number&#x3D;100 name&#x3D;”topeet” para&#x3D;0,1,2,3,4,5,6,7 str&#x3D;”itop”</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115895.jpeg" alt="img"> </p>
<p>图5-8</p>
<p>可以看到传递的参数都分别打印了出来。最后可以输入以下命令进行驱动的卸载，如下图（图5-9）所示：</p>
<p>rmmod parameter.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115187.jpeg" alt="img"> </p>
<p>图5-9</p>
<h1 id="第6章-内核模块符号导出实验"><a href="#第6章-内核模块符号导出实验" class="headerlink" title="第6章 内核模块符号导出实验"></a>第6章 内核模块符号导出实验</h1><p>在上一小节中，给大家讲解了驱动模块传参实验，使用insmod命令加载驱动时可以进行参数的传递，但是每一个内核模块之间是相互独立的，那模块间的符号传递要怎样进行呢，让我们带着疑问来进行本章节的学习吧！</p>
<h2 id="6-1-内核模块符号导出简介"><a href="#6-1-内核模块符号导出简介" class="headerlink" title="6.1 内核模块符号导出简介"></a>6.1 内核模块符号导出简介</h2><p>驱动程序编译生成的ko文件是相互独立的，即模块之间变量或者函数在正常情况下无法进行互相访问。而一些复杂的驱动模块需要分层进行设计，这时候就需要用到内核模块符号导出。</p>
<p>内核符号导出指的是在内核模块中导出相应的函数和变量，在加载模块时被记录在公共内核符号表中，以供其他模块调用。符号导出所使用的宏为EXPORT_SYMBOL(sym)和EXPORT_SYMBOL_GPL(sym)。它们定义在 “内核源码&#x2F;include&#x2F;linux&#x2F;export.h”文件中（在module.h文件中已经对export.h进行引用，所以不需要单独引用export.h文件）,详细定义如下（图6-1）所示： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT_SYMBOL(sym)                  \</span></span><br><span class="line"><span class="meta">__EXPORT_SYMBOL(sym, <span class="string">&quot;&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT_SYMBOL_GPL(sym)                  \</span></span><br><span class="line"><span class="meta">    __EXPORT_SYMBOL(sym, <span class="string">&quot;_gpl&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<p>图6-1</p>
<p>EXPORT_SYMBOL(sym)和EXPORT_SYMBOL_GPL(sym)两个宏使用方法相同，而EXPORT_SYMBOL_GPL(sym)导出的模块只能被 GPL 许可的模块使用，所以绝大多数的情况都使用EXPORT_SYMBOL(sym)进行符号导出。sym为函数的唯一参数，表示要导出的函数或变量名称。</p>
<p>至此，关于内核模块符号导出函数就讲解完成了，在下一小节中将会编写两个驱动代码来进行内核模块符号导出实验。</p>
<h2 id="6-2-实验程序的编写"><a href="#6-2-实验程序的编写" class="headerlink" title="6.2 实验程序的编写"></a>6.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\03。</p>
<p>本章实验将编写Linux下的内核模块符号导出实例代码，总共有两个驱动程序，第一个驱动文件名为mathmodule.c，用来定义参数num和函数add(a,b)，第二个驱动文件名为hello.c,会引用mathmodule.c驱动程序中的参数num和数学函数add(a,b)，并将相应的参数值和函数返回值打印到串口终端上。</p>
<p>编写完成的mathmodule.c代码如下（图6-2）所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;<span class="comment">//定义参数num</span></span><br><span class="line">EXPORT_SYMBOL(num);<span class="comment">//导出参数num</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//定义数学函数add()，用来实现加法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(add);<span class="comment">//导出数学函数add()</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">math_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;math_moudle init\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">math_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;math_module exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(math_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(math_exit);<span class="comment">//注册出口函数</span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);<span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>图6-2</p>
<p>以上代码定义了一个int类型的num变量和add()数学函数，并使用EXPORT_SYMBOL宏进行导出。</p>
<p>编写完成的hello.c代码如下（图6-3）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> num;<span class="comment">//导入int类型变量num</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;<span class="comment">//导入函数add</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> sum;</span><br><span class="line">    printk(<span class="string">&quot;num = %d\n&quot;</span>, num);<span class="comment">//打印num值</span></span><br><span class="line">    sum = add(<span class="number">3</span>, <span class="number">4</span>);<span class="comment">//使用add函数进行3+4的运算                                                                                                                                                                          </span></span><br><span class="line">    printk(<span class="string">&quot;sum = %d\n&quot;</span>, sum);<span class="comment">//打印add函数的运算值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;Goodbye hello module\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(hello_exit);<span class="comment">//注册出口函数</span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);<span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>图6-3</p>
<p>程序导入了int类型的变量num和add()函数，并在驱动入口函数中打印相应了num的参数值并对add()函数进行了调用。</p>
<p>至此两个驱动代码就编写完成了，代码较为简单，实现了内核模块符号的导出和导出符号的使用，具体的驱动加载运行测试会在下个小节进行。</p>
<h2 id="6-3-运行测试"><a href="#6-3-运行测试" class="headerlink" title="6.3 运行测试"></a>6.3 运行测试</h2><h3 id="6-3-1-编译驱动程序"><a href="#6-3-1-编译驱动程序" class="headerlink" title="6.3.1 编译驱动程序"></a>6.3.1 编译驱动程序</h3><p>在mathmodule.c和hello.c的同一目录下创建Makefile文件，Makefile文件内容如下（图6-4）所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m := mathmodule.o</span><br><span class="line">obj-m += hello.o</span><br><span class="line"></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    #make操作</span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    #make clean操作</span><br></pre></td></tr></table></figure>

<p>图6-4</p>
<p>对于Makefile的内容注释已在上图进行添加，这里要注意的是在hello.c代码中使用了mathmodule.c所导出的符号，所以mathmodule.c要在hello.c之前进行编译，即第3行和第4行顺序不能交换。保存退出之后，来到相应的文件目录下，如下图（图6-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115183.jpeg" alt="img"> </p>
<p>图6-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图6-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115229.jpeg" alt="img"> </p>
<p>图6-6</p>
<p>编译完后会生成hello.ko和mathmodule.ko目标文件，如下图（图6-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115254.jpeg" alt="img"> </p>
<p>图6-7</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的加载运行测试。</p>
<h3 id="6-3-2-运行测试"><a href="#6-3-2-运行测试" class="headerlink" title="6.3.2 运行测试"></a>6.3.2 运行测试</h3><p>这里要注意的是，由于 hello.ko依赖于mathmodule.ko，所以mathmodule.ko需要先加载，分别使用以下命令进行模块的加载（加载顺序不能变），如下（图6-8）所示：</p>
<p>insmod mathmodule.ko</p>
<p>insmod  hello.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115250.jpeg" alt="img"> </p>
<p>图6-8</p>
<p>可以看到 hello.ko驱动加载的时候，mathmodule.ko模块中定义的num参数值和调用sum()函数的后正确的返回值都被打印了出来。至此内核模块符号导出实验就完成了。</p>
<p>最后可以输入以下命令进行驱动的卸载，如下图（图6-9）所示：</p>
<p>rmmod  hello.ko</p>
<p>rmmod mathmodule.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115362.jpeg" alt="img"> </p>
<p>图6-9</p>
<p>注意：由于hello.ko文件使用了mathmodule.ko导出的符号，所以要先卸载hello.ko，卸载完成之后再卸载mathmodule.ko。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>驱动基础</tag>
      </tags>
  </entry>
  <entry>
    <title>rk3568 驱动开发第七篇 设备树</title>
    <url>/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%83%E7%AF%87-%E8%AE%BE%E5%A4%87%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第55章-初识设备树"><a href="#第55章-初识设备树" class="headerlink" title="第55章 初识设备树"></a>第55章 初识设备树</h1><h2 id="55-1-设备树的由来"><a href="#55-1-设备树的由来" class="headerlink" title="55.1 设备树的由来"></a>55.1 设备树的由来</h2><p>设备树（Device Tree）是一种硬件描述机制，用于在嵌入式系统和操作系统中描述硬件设备的特性、连接关系和配置信息。它提供了一种与平台无关的方式来描述硬件，使得内核与硬件之间的耦合度降低，提高了系统的可移植性和可维护性。</p>
<p>在上一篇平台总线内容的学习中，我们使用platform_device结构体来对硬件设备进行描述，这是一种传统的平台总线设备描述方式。每个platform_device结构表示一个特定的硬件设备，并通过注册到平台总线上来使得内核能够与该设备进行通信和交互。该结构包含设备的名称、资源（如内存地址、中断号等）、设备驱动程序等信息。</p>
<p>然而，随着时间的推移，Linux内核中的ARM部分存在着大量的平台相关配置代码，这些代码通常是杂乱而重复的，导致了维护的困难和工作量的增加。在2011年3月17日，Linux的创始人Linus Torvalds在ARM Linux邮件列表中发表了一封帖子，他表达了对ARM架构配置方式的不满，并宣称”Gaah. Guys, this whole ARM thing is a f*cking pain in the ass”。这引起了广泛的讨论和反思。ARM社区中的开发者们开始认识到，传统的平台相关配置方式已经变得不可持续，需要一种更加先进和可扩展的方法来解决这个问题。</p>
<p>为了应对这一挑战，ARM社区开始探索新的硬件描述机制，并逐渐形成了设备树的概念。设备树提供了一种更加灵活和可移植的描述硬件的机制，将设备的描述信息转移到设备树中。设备树使用一种结构化的数据格式，通过描述设备节点、属性和连接关系等信息，使得硬件的描述与具体的平台无关，同时允许多个平台共享相同的设备树描述。</p>
<p>设备树的引入为ARM架构上的Linux内核带来了革命性的变化。它提供了一种统一的硬件描述方式，使得不同芯片和板级的支持更加简单和灵活。此外，设备树还提供了硬件配置的可视化和可读性，方便开发者理解和调试硬件。</p>
<p>随着时间的推移，设备树逐渐成为了嵌入式系统和Linux内核中描述硬件的标准方式。它不仅在ARM架构上得到了广泛应用，也被扩展到其他架构和平台上。</p>
<h2 id="55-2-设备树基础知识"><a href="#55-2-设备树基础知识" class="headerlink" title="55.2 设备树基础知识"></a>55.2 设备树基础知识</h2><p>当描述设备树（Device Tree）时，通常会涉及到以下几个关键术语：DTS、DTSI、DTB和DTC。下面来对每个术语进行介绍。</p>
<p>DTS（Device Tree Source）：DTS是设备树的源文件，采用一种类似于文本的语法来描述硬件设备的结构、属性和连接关系。DTS文件以.dts为扩展名，通常由开发人员编写。它是人类可读的形式，用于描述设备树的层次结构和属性信息。</p>
<p>DTSI（Device Tree Source Include）：DTSI文件是设备树源文件的包含文件。它扩展了DTS文件的功能，用于定义可重用的设备树片段。DTSI文件以.dtsi为扩展名，可以在多个DTS文件中包含和共享。通过使用DTSI，可以提高设备树的可重用性和可维护性（和C语言中头文件的作用相同）。</p>
<p>DTB（Device Tree Blob）：DTB是设备树的二进制表示形式。DTB文件是通过将DTS或DTSI文件编译而成的二进制文件，以.dtb为扩展名。DTB文件包含了设备树的结构、属性和连接信息，被操作系统加载和解析。在运行时，操作系统使用DTB文件来动态识别和管理硬件设备。</p>
<p>DTC（Device Tree Compiler）：DTC是设备树的编译器。它是一个命令行工具，用于将DTS和DTSI文件编译成DTB文件。DTC将文本格式的设备树源代码转换为二进制的设备树表示形式，以便操作系统能够加载和解析。DTC是设备树开发中一个重要的工具。</p>
<p>DTS、DTSI、DTB和DTC之间的关系：</p>
<p>（1）开发人员使用文本编辑器编写DTS和DTSI文件，描述硬件设备的层次结构、属性和连接关系。</p>
<p>（2）DTSI文件可以在多个DTS文件中包含和共享，以提高设备树的可重用性和可维护性。</p>
<p>（3）使用DTC编译器，开发人员将DTS和DTSI文件编译成二进制的DTB文件，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps1.jpg" alt="img"> </p>
<p>（4）操作系统在启动过程中加载和解析DTB文件，以识别和管理硬件设备。</p>
<p>设备树文件存放路径</p>
<p>ARM体系结构：</p>
<p>ARM体系结构下的设备树源文件通常存放在arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;目录中。该目录是设备树源文件的根目录。如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps2.jpg" alt="img"> </p>
<p>ARM64体系结构：</p>
<p>设备树源文件路径：ARM64体系结构下的设备树源文件通常存放在arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;目录及其子目录中。该目录也是设备树源文件的根目录，并包含了针对不同ARM64平台和设备的子目录，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps3.jpg" alt="img"> </p>
<p>子目录结构：在ARM64的子目录中，同样会按照硬件平台、设备类型或制造商进行组织和分类。这些子目录的命名可能与特定芯片厂商（如Qualcomm、NVIDIA、Samsung）有关，由于我们本手册使用的soc是瑞芯微的rk3568，所以匹配的设备树目录为arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip。每个子目录中可能包含多个设备树文件，用于描述不同的硬件配置和设备类型，这里以rockchip目录内容如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps4.jpg" alt="img"> </p>
<h2 id="55-3-设备树的编译"><a href="#55-3-设备树的编译" class="headerlink" title="55.3 设备树的编译"></a>55.3 设备树的编译</h2><p>​	设备树的编译是将设备树源文件（如上述的.dts文件）转换为二进制的设备树表示形式（.dtb文件）的过程。编译器通常被称为DTC（Device Tree Compiler）。</p>
<p>在Linux内核源码中，DTC（Device Tree Compiler）的源代码和相关工具通常存放在scripts&#x2F;dtc&#x2F;目录中，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps5.jpg" alt="img"> </p>
<p>在编译完源码之后dtc设备树编译器会默认生成，如果没有生成相应的dtc可执行文件，可以查看在内核默认配置文件种CONFIG_DTC是否使能。</p>
<p>设备树的编译：</p>
<p>在Linux环境中，可以使用以下命令将设备树源文件编译为二进制设备树文件：</p>
<p>dtc -I dts -O dtb -o output.dtb input.dts</p>
<p>其中，<code>input.dts</code>是输入的设备树源文件，<code>output.dtb</code>是编译后的二进制设备树文件。</p>
<p>编译器会验证设备树源文件的语法和语义，生成与硬件描述相对应的设备树表示形式。</p>
<p>设备树的反编译：<br>    设备树的反编译是将二进制设备树文件转换回设备树源文件的过程，以便进行查看、编辑或修改。反编译器通常也是DTC。</p>
<p>在Linux环境中，可以使用以下命令将二进制设备树文件反编译为设备树源文件：</p>
<p>dtc -I dtb -O dts -o output.dts input.dtb</p>
<p>其中，input.dtb是输入的二进制设备树文件，output.dts是反编译后的设备树源文件。</p>
<p>反编译器会将二进制设备树文件解析并还原为文本形式的设备树源文件，使其可读性更好。</p>
<p>下面来进行一下实际的设备树编译和反编译的演示，首先创建一个名为test.dts的设备树文件，文件内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">/ &#123;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建完成如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps6.jpg" alt="img"> </p>
<p>这个设备树很简单，只包含了根节点&#x2F;，而根节点中没有任何子节点或属性。这个示例并没有描述任何具体的硬件设备或连接关系，它只是一个最基本的设备树框架，在本小节只是为了测试设备树的编译和反编译。</p>
<p>然后使用以下命令进行设备树的编译，编译完成如下图所示：</p>
<p>&#x2F;home&#x2F;topeet&#x2F;Linux&#x2F;linux_sdk&#x2F;kernel&#x2F;scripts&#x2F;dtc&#x2F;dtc -I dts -O dtb -o test.dtb test.dts</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps7.jpg" alt="img"> </p>
<p>可以看到test.dtb就生成了，然后继续使用以下命令对test.dtb进行反编译，反编译完成如下图所示：</p>
<p>&#x2F;home&#x2F;topeet&#x2F;Linux&#x2F;linux_sdk&#x2F;kernel&#x2F;scripts&#x2F;dtc&#x2F;dtc -I dtb -O dts -o 1.dts test.dtb </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps8.jpg" alt="img"> </p>
<p>可以看到反编译出的1.dts跟之前的test.dts内容相同。</p>
<h1 id="第56章-设备树基本语法"><a href="#第56章-设备树基本语法" class="headerlink" title="第56章 设备树基本语法"></a><strong>第56章</strong> 设备树基本语法</h1><h2 id="56-1设备树语法讲解1"><a href="#56-1设备树语法讲解1" class="headerlink" title="56.1设备树语法讲解1"></a>56.1设备树语法讲解1</h2><h3 id="56-1-1根节点"><a href="#56-1-1根节点" class="headerlink" title="56.1.1根节点"></a>56.1.1根节点</h3><p>设备树使用一种层次结构，其中的根节点（Root Node）是整个设备树的起始点和顶层节点。根节点由一个以&#x2F;开头的标识符来表示，然后使用{}来包含根节点所在的内容，一个最简单的根节点示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;  <span class="comment">// 设备树版本信息</span></span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    <span class="comment">// 根节点开始</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在这里可以添加注释，描述根节点的属性和配置</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中第一行的设备树中的版本信息行 dts-v1 是可选的，可以根据需要选择是否保留。这行注释通常用于指定设备树的语法版本。如果您不需要在设备树中指定版本信息，可以将其删除。</p>
<h3 id="56-1-2子节点"><a href="#56-1-2子节点" class="headerlink" title="56.1.2子节点"></a>56.1.2子节点</h3><p>设备树中的子节点是根节点的直接子项，用于描述具体的硬件设备或设备集合。子节点采用以下特定的格式来表示，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[label:] node-name@[unit-address] &#123;</span><br><span class="line">	[properties definitions]</span><br><span class="line">	[child nodes]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下是对这些部分的详细介绍：</p>
<p>（1）节点标签（Label）（可选）：节点标签是一个可选的标识符，用于在设备树中引用该节点。标签允许其他节点直接引用此节点，以便在设备树中建立引用关系。</p>
<p>（2）节点名称（Node Name）：节点名称是一个字符串，用于唯一标识该节点在设备树中的位置。节点名称通常是硬件设备的名称，但必须在设备树中是唯一的。</p>
<p>（3）单元地址（Unit Address）（可选）：单元地址用于标识设备的实例。它可以是一个整数、一个十六进制值或一个字符串，具体取决于设备的要求。单元地址的目的是区分相同类型的设备的不同实例，例如在下图中名为 cpu 的节点通过它们的单元地址值 0 和 1 来区分，名称为 ethernet 的节点通过其单元地址值 fe002000 和 fe003000 来区分。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps9.jpg" alt="img"> </p>
<p>（4）属性定义（Properties Definitions）：属性定义是一组键值对，用于描述设备的配置和特性。属性可以根据设备的需求进行定义，例如寄存器地址、中断号、时钟频率等，关于这些属性会在后面的小节中进行讲解</p>
<p>（5）子节点（Child Nodes）：子节点是当前节点的子项，用于进一步描述硬件设备的子组件或配置。子节点可以包含自己的属性定义和更深层次的子节点，形成设备树的层次结构。</p>
<h3 id="56-1-3-reg属性"><a href="#56-1-3-reg属性" class="headerlink" title="56.1.3 reg属性"></a>56.1.3 reg属性</h3><p>reg 属性用于在设备树中指定设备的寄存器地址和大小，提供了与设备树中的物理设备之间的寄存器映射关系。</p>
<p>reg 属性可以在设备节点中有单个值格式和列表值格式这两种常见格式，接下来将对这两种格式进行介绍：</p>
<p>（1）单个值格式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg = &lt;address size&gt;;</span><br></pre></td></tr></table></figure>

<p>这种格式适用于描述单个寄存器的情况。其中，address 是设备的起始寄存器地址，可以是一个整数或十六进制值。size 表示寄存器的大小，即占用的字节数。</p>
<p>例如，假设有一个设备节点 my_device，使用单个值格式的 reg 属性来描述一个 4 字节寄存器的地址和大小，可以这样定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;vendor,device&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x1000</span> <span class="number">0x4</span>&gt;;</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>my_device</code> 设备节点的 <code>reg</code> 属性值为 <code>&lt;0x1000 0x4&gt;</code>，表示从地址 <code>0x1000</code> 开始的 4 字节寄存器区域。</p>
<p>（2）列表值格式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg = &lt;address1 size1 address2 size2 ...&gt;;</span><br></pre></td></tr></table></figure>

<p>当设备具有多个寄存器区域时，可以使用列表值格式的 reg 属性来描述每个寄存器区域的地址和大小。通过这种方式，可以指定多个寄存器的位置和大小，以描述设备的完整寄存器映射。</p>
<p>例如，考虑一个设备节点 my_device，它具有两个寄存器区域，分别是 8 字节和 4 字节大小的寄存器。可以使用列表值格式的 reg 属性来描述这种情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;vendor,device&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x1000</span> <span class="number">0x8</span> <span class="number">0x2000</span> <span class="number">0x4</span>&gt;;</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，my_device 设备节点的 reg 属性值为 &lt;0x1000 0x8 0x2000 0x4&gt;，表示设备有两个寄存器区域。第一个寄存器区域从地址 0x1000 开始，大小为 8 字节；第二个寄存器区域从地址 0x2000 开始，大小为 4 字节。</p>
<p>通过使用 reg 属性，设备树可以提供有关设备寄存器布局和寄存器访问方式的信息。这对于操作系统的设备驱动程序很重要，因为它们需要了解设备的寄存器映射以正确地与设备进行交互和配置。</p>
<h3 id="56-1-4-address-cell和size-cells属性"><a href="#56-1-4-address-cell和size-cells属性" class="headerlink" title="56.1.4 address-cell和size-cells属性"></a>56.1.4 address-cell和size-cells属性</h3><p>#address-cells 和 #size-cells 属性用于指定在上个小节中要设置的设备树中地址单元和大小单元的位数。它们提供了设备树解析软件所需的元数据，以正确解释设备的地址和大小信息。下面对两个属性分别进行介绍：</p>
<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em><em><strong>*#address-cells*</strong></em><em><strong>*2*</strong></em> <em><strong>*属性：*</strong></em></p>
<p>#address-cells 属性是一个位于设备树根节点的特殊属性，它指定了设备树中地址单元的位数。地址单元是设备树中用于表示设备地址的单个单位。它通常是一个整数，可以是十进制或十六进制值。</p>
<p>#address-cells 属性的值告诉解析设备树的软件在解释设备地址时应该使用多少位来表示一个地址单元。</p>
<p>默认情况下，#address-cells 的值为 2，表示使用两个单元来表示一个设备地址。这意味着设备的地址将由两个整数（每个整数使用指定位数的位）组成。</p>
<p>例如，对于一个使用两个 32 位（4字节）整数表示地址的设备，可以在设备树的根节点中设置 #address-cells 属性为 &lt;2&gt;。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em><em><strong>*#size-cells 属性：*</strong></em></p>
<p>#size-cells 属性也是一个位于设备树根节点的特殊属性，它指定了设备树中大小单元的位数。大小单元是设备树中用于表示设备大小的单个单位。它通常是一个整数，可以是十进制或十六进制值。</p>
<p>#size-cells 属性的值告诉解析设备树的软件在解释设备大小时应该使用多少位来表示一个大小单元。</p>
<p>默认情况下，#size-cells 的值为 1，表示使用一个单元来表示一个设备的大小。这意味着设备的大小将由一个整数（使用指定位数的位）表示。</p>
<p>例如，对于一个使用一个 32 位（4 字节）整数表示大小的设备，可以在设备树的根节点中设置 #size-cells 属性为 &lt;1&gt;。</p>
<p>这两个属性的存在是为了使设备树能够灵活地描述各种设备的地址和大小表示方式。通过在设备树的根节点中设置适当的 #address-cells 和 #size-cells 值，设备树解析软件能够正确地解释设备节点中的地址和大小信息。</p>
<p>以下是两个个示例，展示了根节点中 #address-cells 和 #size-cells 属性的使用：</p>
<p><em><strong>*示例1：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">node1 &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    node1-child &#123;</span><br><span class="line">        reg = &lt;<span class="number">0x02200000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">        <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，node1-child 节点的 reg 属性使用了 &lt;0x02200000 0x4000&gt; 表示地址和大小。由于 #address-cells 的值为 &lt;1&gt;，表示使用一个单元来表示地址。#size-cells 的值也为 &lt;1&gt;，表示使用一个单元来表示大小。</p>
<p>解释后的地址和大小值如下：</p>
<p>地址部分：0x02200000 被解释为一个地址单元，地址为 0x02200000。</p>
<p>大小部分：0x4000 被解释为一个大小单元，大小为 0x4000。</p>
<p><em><strong>*示例2：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">node1 &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">    node1-child &#123;</span><br><span class="line">        reg = &lt;<span class="number">0x0000</span> <span class="number">0x0001</span>&gt;;</span><br><span class="line">        <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，node1-child 节点的 reg 属性使用了 &lt;0x0000 0x0001&gt; 表示地址。由于 #address-cells 的值为 &lt;2&gt;，表示使用两个单元来表示地址。#size-cells 的值为 &lt;0&gt;，表示不使用单元来表示大小。</p>
<p>解释后的地址值如下：</p>
<p>地址部分：0x0000 0x0001 被解释为两个地址单元，其中第一个地址单元为 0x0000，第二个地址单元为 0x0001。</p>
<p>这种使用 #address-cells 和 #size-cells 属性的方式使得设备树可以适应不同设备的寄存器映射和大小表示方式，并确保设备树解析软件能够正确解释设备的地址和大小信息。</p>
<h3 id="56-1-5-model属性"><a href="#56-1-5-model属性" class="headerlink" title="56.1.5 model属性"></a>56.1.5 model属性</h3><p>在设备树中，model 属性用于描述设备的型号或者名称。它通常作为设备节点的一个属性，用来提供关于设备的标识信息。model 属性是可选的，但在实际应用中经常被使用。</p>
<p>model 属性的值是一个字符串，可以是设备的型号、名称、或者其他标识符，用来识别设备。该值通常由设备的厂商定义，并且在设备树中使用。</p>
<p>以下是一个示例，展示了如何在设备树中使用 model 属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;vendor,device&quot;</span>;</span><br><span class="line">    model = <span class="string">&quot;My Device XYZ&quot;</span>;</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，my_device 节点具有 model 属性，其值为 “My Device XYZ”。这个值描述了设备的型号或名称为 “My Device XYZ”。</p>
<p>model 属性通常用于标识和区分不同的设备，特别是当设备节点的 compatible 属性相同或相似时。通过使用不同的 model 属性值，可以更加准确地确定所使用的设备类型。</p>
<h3 id="56-1-6-status属性"><a href="#56-1-6-status属性" class="headerlink" title="56.1.6 status属性"></a>56.1.6 status属性</h3><p>在设备树中，status 属性用于描述设备或节点的状态。它是设备树中常见的属性之一，用于表示设备或节点的可用性或操作状态。</p>
<p>status 属性的值可以是以下几种：</p>
<p>“okay”：表示设备或节点正常工作，可用。</p>
<p>“disabled”：表示设备或节点被禁用，不可用。</p>
<p>“reserved”：表示设备或节点已被保留，暂时不可用。</p>
<p>“fail”：表示设备或节点初始化或操作失败，不可用。</p>
<p>以下是一个示例，展示了如何在设备树中使用 status 属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;vendor,device&quot;</span>;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，my_device 节点具有 status 属性，其值为 “okay”。这表示设备处于正常工作状态，可用。</p>
<p>通过使用 status 属性，设备树可以动态地控制设备的启用和禁用状态。这对于在系统启动过程中选择性地启用或禁用设备，或者在运行时根据特定条件调整设备状态非常有用。</p>
<h3 id="56-1-7-compatible属性"><a href="#56-1-7-compatible属性" class="headerlink" title="56.1.7 compatible属性"></a>56.1.7 compatible属性</h3><p>在设备树中，compatible 属性用于描述设备的兼容性信息。它是设备树中重要的属性之一，用于识别设备节点与驱动程序之间的匹配关系。</p>
<p>compatible 属性的值是一个字符串或字符串列表，用于指定设备节点与相应的驱动程序或设备描述符兼容的规则。通常，compatible 属性的值由设备的厂商定义，并且在设备树中使用。</p>
<p>以下是一些常见的 compatible 属性值的示例：</p>
<p>（1）单个字符串值：例如 “vendor,device”，用于指定设备节点与特定厂商的特定设备兼容。</p>
<p>（2）字符串列表：例如 [“vendor,device1”, “vendor,device2”]，用于指定设备节点与多个设备兼容，通常用于设备节点具有多种变体或配置。</p>
<p>（3）通配符匹配：例如 “vendor,*”，用于指定设备节点与特定厂商的所有设备兼容，不考虑具体的设备标识。</p>
<p>以下是一个示例，展示了如何在设备树中使用 compatible 属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;vendor,device&quot;</span>;</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，my_device 节点具有 compatible 属性，其值为 “vendor,device”。这个值用于标识设备节点与特定厂商的特定设备兼容。</p>
<p>compatible 属性也可以具有多个匹配值，用于指定设备节点与多个设备或驱动程序的兼容性规则。这种情况下，compatible 属性的值是一个字符串列表，每个字符串表示一个匹配值。</p>
<p>以下是一个示例，展示了具有多个匹配值的 compatible 属性的用法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = [<span class="string">&quot;vendor,device1&quot;</span>, <span class="string">&quot;vendor,device2&quot;</span>];</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，my_device 节点具有 compatible 属性，其值为 [“vendor,device1”, “vendor,device2”]。这表示设备节点与厂商的 device1 和 device2 兼容。</p>
<p>通过使用 compatible 属性，设备树可以提供设备和驱动程序之间的匹配信息。当设备树被操作系统或设备管理软件解析时，会根据设备节点的 compatible 属性值来选择适合的驱动程序进行设备的初始化和配置。</p>
<h2 id="56-2设备树语法讲解2"><a href="#56-2设备树语法讲解2" class="headerlink" title="56.2设备树语法讲解2"></a>56.2设备树语法讲解2</h2><h3 id="56-2-1-aliases节点"><a href="#56-2-1-aliases节点" class="headerlink" title="56.2.1 aliases节点"></a>56.2.1 aliases节点</h3><p> aliases 节点是一个特殊的节点，用于定义设备别名。该节点位于设备树的根部，并具有节点路径 &#x2F;aliases。</p>
<p>aliases 节点是一个容器节点，包含一组属性，每个属性都代表一个设备别名。每个属性的名称是别名的标识符，而属性的值是被引用设备节点的路径或设备树中其他节点的路径。</p>
<p>以下是一个示例，演示了如何在设备树中使用 aliases 节点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line">    mmc0 = &amp;sdmmc0;</span><br><span class="line">    mmc1 = &amp;sdmmc1;</span><br><span class="line">    mmc2 = &amp;sdhci;</span><br><span class="line">    serial0 = <span class="string">&quot;/simple@fe000000/seria1@11c500&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在给定的例子中，有四个别名的定义：</p>
<p>（1）mmc0 别名与设备树中的 sdmmc0 节点相关联。通过使用别名 mmc0，其他设备节点或客户端程序可以更方便地引用 sdmmc0 节点，而不必直接使用其完整路径。</p>
<p>（2）mmc1 别名与设备树中的 sdmmc1 节点相关联。通过使用别名 mmc1，其他设备节点或客户端程序可以更方便地引用 sdmmc1 节点，而不必直接使用其完整路径。</p>
<p>（3）mmc2 别名与设备树中的 sdhci 节点相关联。通过使用别名 mmc2，其他设备节点或客户端程序可以更方便地引用 sdhci 节点，而不必直接使用其完整路径。</p>
<p>（4）serial0 别名与设备树中的路径 &#x2F;simple@fe000000&#x2F;seria1@11c500 相关联。通过使用别名 serial0，其他设备节点或客户端程序可以更方便地引用该路径，而不必记住整个路径字符串。</p>
<p>在别名的定义中，&amp; 符号用于引用设备树中的节点。别名的目的是提供可读性更高的名称，使设备树更易于理解和维护。通过使用别名，可以简化设备节点之间的关联，并减少重复输入设备节点的路径。</p>
<p>客户端程序可以使用别名属性名称来引用完整的设备路径或部分路径。当客户端程序将别名字符串视为设备路径时，应检测并使用别名。这样，设备树的使用者可以更方便地引用设备节点，而不必记住复杂的路径结构。</p>
<p>需要注意的是，aliases 节点中定义的别名只在设备树内部可见，不能在设备树之外引用。它们主要用于设备树的内部组织和引用，以提高可读性和可维护性。</p>
<h3 id="56-2-2-chosen节点"><a href="#56-2-2-chosen节点" class="headerlink" title="56.2.2 chosen节点"></a>56.2.2 chosen节点</h3><p>chosen节点是设备树中的一个特殊节点，用于传递和存储系统引导和配置的相关信息。它位于设备树的根部，并具有路径&#x2F;chosen。</p>
<p>chosen节点通常包含以下子节点和属性：</p>
<p>（1）bootargs：这是一个属性，用于存储引导内核时传递的命令行参数。它可以包含诸如内核参数、设备树参数等信息。在引导过程中，操作系统或引导加载程序可以读取该属性来获取启动参数。</p>
<p>（2）stdout-path：这是一个属性，用于指定用于标准输出的设备路径。在引导过程中，操作系统可以使用该属性来确定将控制台输出发送到哪个设备，例如串口或显示屏。</p>
<p>（3）firmware-name：这是一个属性，用于指定系统固件的名称。它可以用于标识所使用的引导加载程序或固件的类型和版本。</p>
<p>（4）linux,initrd-start和linux,initrd-end：这些属性用于指定Linux内核初始化RAM磁盘（initrd）的起始地址和结束地址。这些信息在引导过程中被引导加载程序使用，以将initrd加载到内存中供内核使用。</p>
<p>（5）其他自定义属性：chosen节点还可以包含其他自定义属性，用于存储特定于系统引导和配置的信息。这些属性的具体含义和用法取决于设备树的使用和上下文。</p>
<p>关于chosen节点的实际例子如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">chosen &#123;</span><br><span class="line">    bootargs = <span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0,115200&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，chosen 节点具有一个属性 bootargs，其值为”root&#x3D;&#x2F;dev&#x2F;nfs rw nfsroot&#x3D;192.168.1.1 console&#x3D;ttyS0,115200”。</p>
<p>通过这些命令行参数，操作系统或引导加载程序可以配置内核在引导过程中正确地加载 NFS 根文件系统，并将控制台输出发送到指定的串口设备。</p>
<p>通过使用chosen节点，系统引导过程中的相关信息可以方便地传递给操作系统或引导加载程序。这样，系统引导和配置的各个组件可以共享和访问这些信息，从而实现更灵活和可配置的系统引导流程。chosen节点提供了一种通用的机制，使得不同的设备树和引导系统可以在传递信息方面保持一致性，并且可以根据具体需求扩展和自定义。</p>
<h3 id="56-2-3-device-type节点"><a href="#56-2-3-device-type节点" class="headerlink" title="56.2.3 device_type节点"></a>56.2.3 device_type节点</h3><p>在设备树中，device_type 节点是用于描述设备类型的节点。它通常作为设备节点的一个属性存在。device_type 属性的值是一个字符串，用于标识设备的类型。</p>
<p>device_type 节点的存在有助于操作系统或其他软件识别和处理设备。它提供了设备的基本分类信息，使得驱动程序、设备树解析器或其他系统组件能够根据设备的类型执行相应的操作。</p>
<p>常见的设备类型包括但不限于：</p>
<p>（1）cpu：表示中央处理器。</p>
<p>（2）memory：表示内存设备。</p>
<p>（3）display：表示显示设备，如液晶显示屏。</p>
<p>（4）serial：表示串行通信设备，如串口。</p>
<p>（5）ethernet：表示以太网设备。</p>
<p>（6）usb：表示通用串行总线设备。</p>
<p>（7）i2c：表示使用 I2C (Inter-Integrated Circuit) 总线通信的设备。</p>
<p>（8）spi：表示使用 SPI (Serial Peripheral Interface) 总线通信的设备。</p>
<p>（9）gpio：表示通用输入&#x2F;输出设备。</p>
<p>（10）pwm：表示脉宽调制设备。</p>
<p>这些只是一些常见的设备类型示例，实际上，设备类型可以根据具体的硬件和设备树的使用情况进行自定义和扩展。根据设备类型，操作系统或其他软件可以加载适当的驱动程序、配置设备资源、建立设备之间的连接等。</p>
<h3 id="56-2-4-自定义属性"><a href="#56-2-4-自定义属性" class="headerlink" title="56.2.4 自定义属性"></a>56.2.4 自定义属性</h3><p>设备树中的自定义属性是用户根据特定需求添加的属性。这些属性可以用于提供额外的信息、配置参数或元数据，以满足设备或系统的特定要求。</p>
<p>在设备树中添加自定义属性时，可以在设备节点或其他适当的节点下定义新的属性。自定义属性可以是整数、字符串、布尔值或其他数据类型。它们的命名应遵循设备树的命名约定，并且应该与已有的属性名称避免冲突。</p>
<p>例如可以在设备树中自定义一个管脚标号的属性pinnum，添加好的设备树源码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;my_device&quot;</span>;</span><br><span class="line">    pinnum = &lt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，my_device 是一个自定义设备节点，并添加了一个自定义属性 pinnum。该属性的值 &lt;0 1 2 3 4&gt; 是一个整数数组，表示管脚的标号（PIN number）。</p>
<p>通过这样定义 pinnum 属性，您可以在设备树中为特定设备指定管教标号，以便操作系统、驱动程序或其他软件组件使用。这可以用于在设备初始化或配置过程中对特定管教进行操作或控制。</p>
<h1 id="第57章-实例分析：中断"><a href="#第57章-实例分析：中断" class="headerlink" title="第57章 实例分析：中断"></a><strong>第57章</strong> 实例分析：中断</h1><h2 id="57-1-中断相关属性"><a href="#57-1-中断相关属性" class="headerlink" title="57.1 中断相关属性"></a>57.1 中断相关属性</h2><h3 id="57-1-1-RK-ft5x06设备树节点"><a href="#57-1-1-RK-ft5x06设备树节点" class="headerlink" title="57.1.1 RK ft5x06设备树节点"></a>57.1.1 RK ft5x06设备树节点</h3><p>下面展示的是iTOP-RK3568开发板SDK源码中的ft5x06设备树，其中蓝色字体部分就是关于中断相关的描述，包括了interrupts、 interrupt-controller、#interrupt-cells、interrupt-parent四种常见属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio0: gpio@fdd60000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;rockchip,gpio-bank&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0</span> <span class="number">0xfdd60000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">33</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    clocks = &lt;&amp;pmucru PCLK_GPI00&gt;, &lt;&amp;pmucru DBCLK_GPI00&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    gpio-ranges = &lt;&amp;pinctrl <span class="number">0</span> <span class="number">0</span> <span class="number">32</span>&gt;;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06@<span class="number">38</span> &#123; </span><br><span class="line">    status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    compatible = <span class="string">&quot;edt,edt-ft5306&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">    touch-gpio = &lt;&amp;gpio0 RK_PB5 IRQ_TYPE_EDGE_RISING&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio0&gt;;</span><br><span class="line">    interrupts = &lt;RK_PB5 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">    reset-gpios = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    touchscreen-size-x = &lt;<span class="number">800</span>&gt;;</span><br><span class="line">    touchscreen-size-y = &lt;<span class="number">1280</span>&gt;;</span><br><span class="line">    touch_type = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中gpio0节点是在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568.dtsi”设备树的3549-3560行定义的，而ft5x06: ft5x06@38触摸芯片节点是在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;topeet_rk3568_lcds.dtsi”设备树的301-313行定义的。接下来将会对设备树常见的四个中断属性进行介绍。</p>
<h3 id="57-1-2-interrupts"><a href="#57-1-2-interrupts" class="headerlink" title="57.1.2 interrupts"></a>57.1.2 interrupts</h3><p>interrupts 属性用于指定设备的中断相关信息。它描述了中断控制器的类型、中断号以及中断触发类型。下面将对interrupts 属性的各个方面进行介绍。</p>
<p>在第一小节中列举的设备树源码中的gpio0节点和ft5x06节点都涉及到了interrupts 属性，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio0: gpio@fdd60000 &#123;</span><br><span class="line">    ....</span><br><span class="line">interrupts = &lt;GIC_SPI <span class="number">33</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06@<span class="number">38</span> &#123; </span><br><span class="line">    ....</span><br><span class="line">interrupts = &lt;RK_PB5 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>gpio0节点的interrupts具有三个参数，分别表示中断控制器类型、中断号和中断触发类型，每个参数的具体描述如下所示：</p>
<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em><em><strong>*中断控制器类型：*</strong></em></p>
<p>interrupts 属性的第一个参数指定了中断控制器的类型。常见的类型包括 GIC (Generic Interrupt Controller)、IRQ (Basic Interrupt Handling) 等。例如，在给定的代码片段中，GIC_SPI 表示中断控制器的类型为 GIC SPI 中断。</p>
<p>中断控制器负责管理系统中的中断信号，它可以是硬件中的专用中断控制器，也可以是处理器内部的中断控制器。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em><em><strong>*中断号：*</strong></em></p>
<p>interrupts 属性的第二个参数指定了设备所使用的中断号。中断号是一个唯一标识符，用于区分不同的中断信号源。系统使用中断号来识别中断源并进行相应的中断处理。</p>
<p>中断号可以是一个整数值，也可以是一个宏定义或符号引用。在给定的代码片段中，33 表示该设备使用中断号为 33。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em><em><strong>*中断触发类型：*</strong></em></p>
<p>interrupts 属性的第三个参数指定了中断的触发类型，即中断信号的触发条件。常见的触发类型包括边沿触发和电平触发。</p>
<p>边沿触发表示中断信号在从低电平到高电平或从高电平到低电平的变化时触发。触发类型可以是上升沿触发、下降沿触发或双边沿触发。电平触发表示中断信号在保持特定电平状态时触发，可以是高电平触发或低电平触发。</p>
<p>在给定的代码片段中，IRQ_TYPE_LEVEL_HIGH 表示中断的触发类型为高电平触发。触发类型的宏定义在内核源码“include&#x2F;dt-bindings&#x2F;interrupt-controller&#x2F;irq.h”目录下，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_NONE           0   <span class="comment">// 无中断触发类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_RISING    1   <span class="comment">// 上升沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_FALLING   2   <span class="comment">// 下降沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_BOTH    (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING)<span class="comment">// 双边沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_LEVEL_HIGH     4   <span class="comment">// 高电平触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_LEVEL_LOW      8   <span class="comment">// 低电平触发</span></span></span><br></pre></td></tr></table></figure>

<p>而在ft5x06节点中只有中断号和中断触发类型两个参数，这是为什么呢，带着疑问我们继续学习下面的几个属性。</p>
<h3 id="57-1-3-interrupt-controller"><a href="#57-1-3-interrupt-controller" class="headerlink" title="57.1.3 interrupt-controller"></a>57.1.3 interrupt-controller</h3><p>interrupt-controller 属性是设备树中用于描述中断控制器的属性之一。它提供了关于中断控制器的相关信息，以便操作系统和其他设备能够正确配置和使用中断系统。<br>    interrupt-controller 属性用于标识当前节点所描述的设备是一个中断控制器。中断控制器是硬件或软件模块，负责管理和分发中断信号。它接收来自各种设备的中断请求，并根据优先级和配置规则分发中断给相应的处理器或设备。<br>    interrupt-controller&#96;属性本身没有特定的属性值，只需出现在节点的属性列表中即可。出现该属性的存在即表示该节点描述的设备是中断控制器。</p>
<h3 id="57-1-4-interrupt-parent"><a href="#57-1-4-interrupt-parent" class="headerlink" title="57.1.4 interrupt-parent"></a>57.1.4 interrupt-parent</h3><p>interrupt-parent 属性是设备树中用于建立中断信号源与中断控制器之间关联的属性。它指定了中断信号源所属的中断控制器节点，以确保正确的中断处理和分发。<br>    interrupt-parent<code>属性用于指定中断信号源所属的中断控制器。中断信号源是产生中断的设备或其他中断源节点。通过指定中断控制器，操作系统可以正确地将中断请求传递给相应的中断控制器节点进行处理和分发。     interrupt-parent属性值是一个引用，它指向中断控制器节点的路径或标签。可以使用路径来引用中断控制器节点，如/interrupt-controller-node，或使用标签来引用中断控制器节点，如 &amp;interrupt-controller-label</code>，在第一小节例子中的 ft5x06就是通过中断控制器节点和gpio0中断控制器建立了联系，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ft5x06: ft5x06@38 &#123; </span><br><span class="line">    ....</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio0&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	中断信号源节点（例如设备节点或其他中断源节点）中的 interrupt-parent 属性用于指定中断信号源所属的中断控制器节点。这样，中断信号源就可以将中断请求传递给正确的中断控制器进行处理。中断信号源节点的 interrupts 属性中的中断号和其他相关信息将与指定的中断控制器关联起来。</p>
<p>在某些情况下，中断控制器可以形成多级结构，其中一个中断控制器节点可能是另一个中断控制器的父节点。在这种情况下，interrupt-parent 属性可以用于指定层次结构中的上级中断控制器。</p>
<h3 id="57-1-5-interrupt-cells"><a href="#57-1-5-interrupt-cells" class="headerlink" title="57.1.5 #interrupt-cells"></a>57.1.5 #interrupt-cells</h3><p>#interrupt-cells属性用于描述中断控制器中每个中断信号源的中断编号单元的数量。中断编号单元是指用于表示中断号和其他相关信息的固定大小的单元。通过指定中断编号单元的数量，操作系统可以正确解析和处理中断信息，并将其与中断控制器和中断信号源进行关联。<br>    #interrupt-cells属性的值是一个整数，表示中断编号单元的数量。通常，这个值是一个正整数，例如 1、2 或 3，取决于中断控制器和设备的要求。</p>
<p>在gpio0的中断控制器为gic，在gic节点中#interrupt-cells属性被设置为3，这也就是为什么在gpio0节点中interrupts 属性有三个值，而ft5x06的中断控制器为gpio0，在gpio0节点中#interrupt-cells属性被设置为2，所以ft5x06节点的interrupts 属性只有两个值。</p>
<h2 id="57-2-中断实例编写"><a href="#57-2-中断实例编写" class="headerlink" title="57.2 中断实例编写"></a>57.2 中断实例编写</h2><p>在上一个小节中对设备树中断要用到的属性进行了讲解，而在本小节将会编写一个在RK3568上ft5x06的中断设备树。</p>
<p>首先确定ft5x06的中断引脚号，由于iTOP-RK3568有1.2和1.7两个版本，所以这里展示两个版本的原理图：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps10.jpg" alt="img"> </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps11.jpg" alt="img"> </p>
<p>第一张图为V1.2版本的原理图，触摸引脚网络标号为TP_INT_L_GPIO0_B5，对应的CPU管脚为GPIO0_B5，第二张图为V1.7版本的原理图，触摸引脚网络标号为TP_INT_L_GPIO3_A5，对应的CPU管脚为GPIO3_A5。</p>
<p>然后来查看内核源码目录下的“drivers&#x2F;input&#x2F;touchscreen&#x2F;edt-ft5x06.c”文件，这是ft5x06的驱动文件，然后找到compatible匹配值相关的部分，如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps12.jpg" alt="img"> </p>
<p>这里的compatible匹配值都可以选择，我这里在后面编写设备树的时候会选择edt,edt-ft5206，选择其他compatible也是可以的。</p>
<p>最后在内核源码目录下的“include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h”头文件中，定义了RK引脚名和gpio编号的宏定义，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps13.jpg" alt="img"> </p>
<p>通过宏定义可以减少在编写设备树的过程中换算的时间。</p>
<p>至此，我们关于编写ft5x06设备树的前置内容就查找完成了，接下来进行设备树的编写。</p>
<p>  编写完成的设备树如下所示：<br>V1.2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/pinctrl/rockchip.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/interrupt-controller/irq.h&quot;</span></span></span><br><span class="line">/&#123;</span><br><span class="line">	model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line"></span><br><span class="line">	ft5x06@<span class="number">38</span> &#123;</span><br><span class="line">		compatible = <span class="string">&quot;edt,edt-ft5206&quot;</span>;</span><br><span class="line">		interrupt-parent = &lt;&amp;gpio0&gt;;</span><br><span class="line">		interrupts = &lt;RK_PB5 IRQ_TYPE_EDGE_RISING&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>V1.7</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/pinctrl/rockchip.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/interrupt-controller/irq.h&quot;</span></span></span><br><span class="line">/&#123;</span><br><span class="line">	model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line"></span><br><span class="line">	ft5x06@<span class="number">38</span> &#123;</span><br><span class="line">		compatible = <span class="string">&quot;edt,edt-ft5206&quot;</span>;</span><br><span class="line">		interrupt-parent = &lt;&amp;gpio3&gt;;</span><br><span class="line">		interrupts = &lt;RK_PA5 IRQ_TYPE_EDGE_RISING&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第1行: 设备树文件的头部，指定了使用的设备树语法版本。</p>
<p>第3行：用于定义 Rockchip 平台的引脚控制器相关的绑定。</p>
<p>第4行：用于定义中断控制器相关的绑定。</p>
<p>第5行：表示设备树的根节点开始。</p>
<p>第6行：指定了设备树的模型名称，描述为 “This is my devicetree!”。</p>
<p>第9行：指定了设备节点的兼容性字符串，表示该设备与 “edt,edt-ft5206” 兼容。</p>
<p>第10行：指定了中断的父节点，即中断控制器所在的节点。这里使用了一个引用（&amp;gpio0）来表示父节点。</p>
<p>第11行：指定了中断信号的配置。RK_PB5 表示中断信号的引脚编号，IRQ_TYPE_EDGE_RISING 表示中断类型为上升沿触发。</p>
<p>至此，关于ft5x06的设备树就讲解完成了。</p>
<h2 id="57-3-其他SOC设备树对比"><a href="#57-3-其他SOC设备树对比" class="headerlink" title="57.3 其他SOC设备树对比"></a>57.3 其他SOC设备树对比</h2><p>而无论使用的是瑞芯微SOC还是恩智浦、三星的SOC，在设备树关于中断相关的描述都是上面提到的四个属性，关于在恩智浦和三星源码中的ft5x06设备树如下所示：</p>
<p><em><strong>*恩智浦*</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio1: gpio@<span class="number">0209</span>c000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;fsl,inx6ul-gpio&quot;</span>, <span class="string">&quot;fsl,imx35-gpio&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0209c000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">66</span> IRQ_TYPE_LEVEL_HIGH&gt;, &lt;GIC_SPI <span class="number">67</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    edt-ft5x06@<span class="number">38</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;edt,edt-ft5306&quot;</span>, <span class="string">&quot;edt,edt-ft5x06&quot;</span>, <span class="string">&quot;edt,edt-ft5406&quot;</span>;</span><br><span class="line">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        pinctrl<span class="number">-0</span> = &lt;&amp;ts_int_pin &amp;ts_reset_pin&gt;;</span><br><span class="line">        reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">        interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">        interrupts = &lt;<span class="number">9</span> <span class="number">0</span>&gt;;</span><br><span class="line">        reset-gpios = &lt;&amp;gpio5 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">        irq-gpios = &lt;&amp;gpio1 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em><strong>*三星*</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio_c: gpioc &#123;</span><br><span class="line">    compatible = <span class="string">&quot;gpio-controller&quot;</span>;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06038 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;edt,edt-ft5406&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(RGB_1024x600) || defined(RGB_800x480)</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;tsc2007_irq&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio_c&gt;;</span><br><span class="line">    interrupts = &lt;<span class="number">26</span> IRQ_TYPE_EDGE_FALLING&gt;;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(LvDs_800×1280) || defined(LvDS_1024x768)</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;gt911_irq&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio_b&gt;;</span><br><span class="line">    interrupts = &lt;<span class="number">29</span> IRQ_TYPE_EDGE_FALLING&gt;;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    reset-gpios = &lt;&amp;gpio_e <span class="number">30</span> <span class="number">0</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对比之后会发现，不同厂商对于中断属性的配置都是类似的，只是里面的参数有些许区别，如果大家在之后遇到了其他平台，只需要稍加区分即可。</p>
<h1 id="第58章-实例分析：时钟"><a href="#第58章-实例分析：时钟" class="headerlink" title="第58章 实例分析：时钟"></a><strong>第58章</strong> 实例分析：时钟</h1><p>时钟（Clock）用于描述硬件设备和系统中的时钟源以及时钟相关的配置和连接关系。时钟在计算机系统中起着至关重要的作用，用于同步和定时各种硬件设备的操作。时钟可以分为两个主要角色：时钟生产者（clock provider）和时钟消费者（clock consumer）。</p>
<p><em><strong>*时钟生产者（Clock Provider）：*</strong></em></p>
<p>定义：时钟生产者是负责生成和提供时钟信号的硬件或软件模块。它可以是时钟控制器、PLL、时钟发生器等。</p>
<p>设备树节点：时钟生产者在设备树中以时钟节点的形式表示。</p>
<p>时钟节点属性：</p>
<p>****（1）clock-cells：****该属性用于指定时钟编号的位数。它是一个整数值，表示时钟编号的位数。通常情况下，当 clock-cells 为 0 时表示一个时钟，为 1 表示多个时钟。具体示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例<span class="number">1</span>：单个时钟</span><br><span class="line">osc24m: osc24m &#123;</span><br><span class="line">    compatible = <span class="string">&quot;clock&quot;</span>;</span><br><span class="line">    clock-frequency = &lt;<span class="number">24000000</span>&gt;;</span><br><span class="line">    clock-output-names = <span class="string">&quot;osc24m&quot;</span>;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;O&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">示例<span class="number">2</span>：多个时钟</span><br><span class="line">clock: clock &#123;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    clock-output-names = <span class="string">&quot;clock1&quot;</span>, <span class="string">&quot;clock2&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em><strong>*（2）clock-frequency*</strong></em> 属性是设备树中用于指定时钟频率的属性。它用于描述时钟节点所提供的时钟信号的频率，使用 Hertz (Hz) 作为单位。对于时钟生产者节点，clock-frequency 属性表示该节点生成的时钟信号的频率。它用于描述时钟控制器、晶振、PLL 等产生时钟信号的硬件或软件模块的输出频率，例如指定时钟频率为24000000的具体示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">osc24m: osc24m &#123;</span><br><span class="line">    compatible = <span class="string">&quot;clock&quot;</span>;</span><br><span class="line">    clock-frequency = &lt;<span class="number">24000000</span>&gt;;</span><br><span class="line">    clock-output-names = <span class="string">&quot;osc24m&quot;</span>;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;O&gt;</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em><em><strong>*assigned-clocks*</strong></em> <em><strong>*和 assigned-clock-rates*</strong></em> 是设备树中用于描述多路时钟的属性，通常一起使用。</p>
<p>assigned-clocks 属性用于标识时钟消费者节点所使用的时钟源。它是一个整数数组，每个元素对应一个时钟编号。时钟编号是指时钟生产者节点（如时钟控制器）所提供的时钟源的编号。通过在时钟消费者节点中使用 assigned-clocks 属性，可以指定该节点所需的时钟源。</p>
<p>assigned-clock-rates 属性用于指定每个时钟源的时钟频率。它是一个整数数组，每个元素对应一个时钟源的频率。时钟频率以 Hz (赫兹) 为单位表示。assigned-clock-rates 属性的元素数量和顺序应与 assigned-clocks 属性中的时钟编号相对应。</p>
<p>关于assigned-clocks 和 assigned-clock-rates 属性的一个具体示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cru: clock-controller@fdd20000 &#123;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    assigned-clocks = &lt;&amp;pmucru CLK_RTC_32K&gt;, &lt;&amp;cru ACLK_RKVDEC_PRE&gt;;</span><br><span class="line">    assigned-clock-rates = &lt;<span class="number">32768</span>&gt;, &lt;<span class="number">300000000</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em><strong>*（4）clock-indices*</strong></em>****：****clock-indices 属性用于指定时钟消费者节点所使用的时钟源的索引值。它是一个整数数组，每个元素对应一个时钟源的索引。</p>
<p>时钟索引是指时钟生产者节点（如时钟控制器）所提供的时钟源的编号。通过在时钟消费者节点中使用 clock-indices 属性，可以明确指定该节点所需的时钟源，并按照特定的顺序进行匹配。一个clock-indices示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">scpi_dvfs: clocks<span class="number">-0</span> &#123;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    clock-indices = &lt;<span class="number">0</span>&gt;, &lt;<span class="number">1</span>&gt;, &lt;<span class="number">2</span>&gt;;</span><br><span class="line">    clock-output-names = <span class="string">&quot;atlclk&quot;</span>, <span class="string">&quot;aplclk&quot;</span>, <span class="string">&quot;gpuclk&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">scpi_clk: clocks<span class="number">-1</span> &#123;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    clock-indices = &lt;<span class="number">3</span>&gt;;</span><br><span class="line">    clock-output-names = <span class="string">&quot;pxlclk&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在第一个节点中”atlclk”, “aplclk”, “gpuclk”三个时钟源的索引就分别被设置为了0、1、2，在第二个节点中”pxlclk”时钟源的索引值被设置为了3.</p>
<p><em><strong>*（5）*</strong></em><em><strong>*assigned-clock-parents*</strong></em> 属性用于指定时钟消费者节点所使用的时钟源的父时钟源。它是一个时钟源引用的数组，每个元素对应一个父时钟源的引用。在时钟的层次结构中，某些时钟源可能是其他时钟源的父时钟源，即它们提供时钟信号给其他时钟源作为输入。通过在时钟消费者节点中使用 assigned-clock-parents 属性，可以明确指定该节点所需的父时钟源，并按照特定的顺序进行匹配。一个实际的 assigned-clock-parents 属性例子如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clock: clock &#123;</span><br><span class="line">    assigned-clocks = &lt;&amp;clkcon <span class="number">0</span>&gt;, &lt;&amp;pll <span class="number">2</span>&gt;;</span><br><span class="line">    assigned-clock-parents = &lt;&amp;pll <span class="number">2</span>&gt;;</span><br><span class="line">    assigned-clock-rates = &lt;<span class="number">115200</span>&gt;, &lt;<span class="number">9600</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述设备树表示了一个名为 clock 的时钟消费者节点，具有以下属性：</p>
<p>assigned-clocks 属性指定了该节点使用的时钟源，引用了两个时钟源节点：clkcon 0 和 pll 2。</p>
<p>assigned-clock-parents 属性指定了这些时钟源的父时钟源，引用了 pll 2 时钟源节点。</p>
<p>assigned-clock-rates 属性指定了每个时钟源的时钟频率，分别是 115200 和 9600。</p>
<p><em><strong>*时钟消费者（Clock Consumer）：*</strong></em></p>
<p>定义：时钟消费者是依赖时钟信号的硬件设备或模块。它们通过引用时钟生产者节点提供的时钟源来获取时钟信号。</p>
<p>设备树节点：时钟消费者在设备树中的节点中使用属性来引用时钟生产者的时钟源。</p>
<p>时钟消费者属性：</p>
<p>（1）clocks：该属性用于指定时钟消费者节点所需的时钟源。它是一个整数数组，每个元素是一个时钟编号，表示时钟消费者需要的一个时钟源。</p>
<p>（2）clock-names：可选属性，用于指定时钟消费者节点所需时钟源的名称。它是一个字符串数组，与 clocks 数组一一对应，用于提供时钟源的描述性名称。</p>
<p>一个时钟消费者示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clock: clock &#123;</span><br><span class="line">    clocks = &lt;&amp;cru CLK_VOP&gt;;</span><br><span class="line">    clock-names = <span class="string">&quot;clk_vop&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>clocks 属性指定了该节点使用的时钟源，引用了 cru 节点中的 CLK_VOP 时钟源。</p>
<p>clock-names 属性指定了时钟源的名称，这里是 “clk_vop”。</p>
<h1 id="第59章-实例分析：CPU"><a href="#第59章-实例分析：CPU" class="headerlink" title="第59章 实例分析：CPU"></a><strong>第59章</strong> 实例分析：CPU</h1><h2 id="59-1-cpus节点"><a href="#59-1-cpus节点" class="headerlink" title="59.1 cpus节点"></a>59.1 cpus节点</h2><p>设备树的 cpus 节点是用于描述系统中的处理器的一个重要节点。它是处理器拓扑结构的顶层节点，包含了所有处理器相关的信息。下面将详细介绍设备树的 cpus 节点的各个方面。</p>
<p><em><strong>*节点结构：*</strong></em><br>    cpus 节点是一个容器节点，其下包含了系统中每个处理器的子节点。每个子节点的名称通常为 cpu@X，其中 X 是处理器的索引号。每个子节点都包含了与处理器相关的属性，例如时钟频率、缓存大小等。</p>
<p><em><strong>*处理器属性：*</strong></em><br>cpu@X 子节点中的属性可以包括以下信息：</p>
<p>（1）device_type：指示设备类型为处理器（”cpu”）。</p>
<p>（2）reg：指定处理器的地址范围，通常是物理地址或寄存器地址。</p>
<p>（3）compatible：指定处理器的兼容性信息，用于匹配相应的设备驱动程序。</p>
<p>（4）clock-frequency：指定处理器的时钟频率。</p>
<p>（5）cache-size：指定处理器的缓存大小。</p>
<p><em><strong>*处理器拓扑关系：*</strong></em><br>    除了处理器的基本属性，cpus 节点还可以包含其他用于描述处理器拓扑关系的节点，以提供更详细的处理器拓扑信息。这些节点可以帮助操作系统和软件了解处理器之间的连接关系、组织结构和特性。</p>
<p>cpu-map 节点：描述处理器的映射关系，通常在多核处理器系统中使用。</p>
<p>socket 节点：描述多处理器系统中的物理插槽或芯片组。</p>
<p>cluster 节点：描述处理器集群，即将多个处理器组织在一起形成的逻辑组。</p>
<p>core 节点：描述处理器核心，即一个物理处理器内的独立执行单元。</p>
<p>thread 节点：描述处理器线程，即一个物理处理器核心内的线程。</p>
<p>这些节点的嵌套关系可以在 cpus 节点下形成一个层次结构，反映了处理器的拓扑结构。上述这些节点会在后面的小节进行介绍。一个单核CPU设备树和一个四核CPU设备树示例如下所示：</p>
<p>单核CPU示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;0&gt;;</span><br><span class="line"></span><br><span class="line">    cpu0: cpu@0 &#123;</span><br><span class="line">        compatible = &quot;arm,cortex-a7&quot;;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        // 其他属性...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多核CPU示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;0&gt;;</span><br><span class="line"></span><br><span class="line">    cpu0: cpu@0 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a9&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@1 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a9&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu2: cpu@2 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a9&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu3: cpu@3 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a9&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cpus 节点是一个容器节点，包含了 cpu0 子节点。该节点使用了 #address-cells 和 #size-cells 属性来指定地址和大小的单元数量。</p>
<p>cpu0 子节点代表第一个处理器，具有以下属性：</p>
<p>compatible 属性指定了处理器的兼容性信息</p>
<p>device_type 属性指示设备类型为处理器。</p>
<p>你可以在此基础上继续添加其他属性来描述处理器的特性，如时钟频率、缓存大小等。</p>
<h2 id="59-2-cpu-map、socket、cluster节点"><a href="#59-2-cpu-map、socket、cluster节点" class="headerlink" title="59.2 cpu-map、socket、cluster节点"></a>59.2 cpu-map、socket、cluster节点</h2><p>cpu-map 节点是设备树中用于描述大小核架构处理器的映射关系的节点之一。它的父节点必须是 cpus 节点，而子节点可以是一个或多个 cluster 和 socket 节点。通过 cpu-map 节点，可以定义不同核心和集群之间的连接和组织结构。</p>
<p>socket 节点用于描述处理器插槽（socket）之间的映射关系。每个 socket 子节点表示一个处理器插槽，可以使用 cpu-map-mask 属性来指定该插槽使用的核心。通过为每个 socket 子节点指定适当的 cpu-map-mask，可以定义不同插槽中使用的核心。这样，操作系统和软件可以了解到不同插槽之间的核心分配情况。</p>
<p>cluster 节点用于描述核心（cluster）之间的映射关系。每个 cluster 子节点表示一个核心集群，可以使用 cpu-map-mask 属性来指定该集群使用的核心。通过为每个 cluster 子节点指定适当的 cpu-map-mask，可以定义每个集群中使用的核心。这样，操作系统和软件可以了解到不同集群之间的核心分配情况。</p>
<p>通过在 cpu-map 节点中定义 socket 和 cluster 子节点，并为它们指定适当的 cpu-map-mask，可以提供处理器的拓扑结构信息。这对于操作系统和软件来说非常有用，因为它们可以根据这些信息进行任务调度和资源分配的优化，以充分利用大小核架构处理器的性能和能效特性。</p>
<p>一个大小核架构的具体示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">    cpu-<span class="built_in">map</span> &#123;</span><br><span class="line">        cluster0 &#123;</span><br><span class="line">            core0 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_l0&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">            core1 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_l1&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">            core2 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_l2&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">            core3 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_l3&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        cluster1 &#123;</span><br><span class="line">            core0 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_b0&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">            core1 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_b1&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">	cpu_l0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_l1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_l2: cpu@<span class="number">2</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_l3: cpu@<span class="number">3</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_b0: cpu@<span class="number">100</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a72&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_b1: cpu@<span class="number">101</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a72&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个设备树描述了一个具有多个 CPU 核心的系统，包括四个 Cortex-A53 核心和两个 Cortex-A72 核心。下面是对设备树中各个部分的简要介绍：</p>
<p>#address-cells &#x3D; &lt;2&gt;; 和 #size-cells &#x3D; &lt;0&gt;;：这些属性指定了设备树中地址和大小的编码方式。</p>
<p>cpu-map：这个节点定义了 CPU 的映射关系。它包含了两个簇（clusters）：cluster0 和 cluster1。cluster0 包含了四个核心：core0、core1、core2 和 core3，分别对应 cpu_l0、cpu_l1、cpu_l2 和 cpu_l3。cluster1 包含了两个核心：core0 和 core1，分别对应 cpu_b0 和 cpu_b1。</p>
<p>cpu_l0、cpu_l1、cpu_l2 和 cpu_l3：这些节点描述了 Cortex-A53 核心。它们具有相同的设备类型 cpu 和兼容性属性 “arm,cortex-a53”, “arm,armv8”。</p>
<p>cpu_b0 和 cpu_b1：这些节点描述了 Cortex-A72 核心。它们具有相同的设备类型 cpu 和兼容性属性 “arm,cortex-a72”, “arm,armv8”。</p>
<h2 id="59-3-core、thread节点"><a href="#59-3-core、thread节点" class="headerlink" title="59.3 core、thread节点"></a>59.3 core、thread节点</h2><p>“core” 和 “thread” 节点通常用于描述处理器核心和线程的配置。下面是对这两个节点的详细介绍：</p>
<p>Core 节点用于描述处理器的核心。一个处理器通常由多个核心组成，每个核心可以独立执行指令和任务。</p>
<p>Thread 节点用于描述处理器的线程。线程是在处理器核心上执行的基本执行单元，每个核心可以支持多个线程。</p>
<p>通过使用 Core 和 Thread 节点，设备树可以准确描述处理器的核心和线程的配置，例如可以使用设备树来描述一个具有16个核心的CPU，一个物理插槽，每个集群中有两个核心，每个核心有两个线程的设备树示例，具体设备树如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    cpu-<span class="built_in">map</span> &#123;</span><br><span class="line">        socket0 &#123;</span><br><span class="line">            cluster0 &#123;</span><br><span class="line">                core0 &#123;</span><br><span class="line">                    thread0 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU0&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    thread1 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU1&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">                core1 &#123;</span><br><span class="line">                    thread0 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU2&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    thread1 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU3&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            cluster1 &#123;</span><br><span class="line">                core0 &#123;</span><br><span class="line">                    thread0 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU4&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    thread1 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU5&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">                core1 &#123;</span><br><span class="line">                    thread0 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU6&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    thread1 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU7&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        socket1 &#123;</span><br><span class="line">			cluster0 &#123;</span><br><span class="line">				core0 &#123;</span><br><span class="line">					thread0 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU8&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">					thread1 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU9&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;;</span><br><span class="line">				core1 &#123;</span><br><span class="line">					thread0 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU10&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">					thread1 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU11&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">			cluster1 &#123;</span><br><span class="line">				core0 &#123;</span><br><span class="line">					thread0 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU12&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">					thread1 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU13&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;;</span><br><span class="line">				core1 &#123;</span><br><span class="line">					thread0 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU14&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">					thread1 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU15&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="第60章-实例分析：GPIO"><a href="#第60章-实例分析：GPIO" class="headerlink" title="第60章 实例分析：GPIO"></a><strong>第60章</strong> 实例分析：GPIO</h1><h2 id="60-1-中断相关属性"><a href="#60-1-中断相关属性" class="headerlink" title="60.1 中断相关属性"></a>60.1 中断相关属性</h2><h3 id="60-1-1-RK-ft5x06设备树节点"><a href="#60-1-1-RK-ft5x06设备树节点" class="headerlink" title="60.1.1 RK ft5x06设备树节点"></a>60.1.1 RK ft5x06设备树节点</h3><p>下面展示的是iTOP-RK3568开发板SDK源码中的ft5x06设备树，其中蓝色字体部分就是关于gpio相关的描述，包括了interrupts、 interrupt-controller、#interrupt-cells、interrupt-parent四种常见属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio0: gpio@fdd60000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;rockchip,gpio-bank&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0</span> <span class="number">0xfdd60000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">33</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    clocks = &lt;&amp;pmucru PCLK_GPI00&gt;, &lt;&amp;pmucru DBCLK_GPI00&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    gpio-ranges = &lt;&amp;pinctrl <span class="number">0</span> <span class="number">0</span> <span class="number">32</span>&gt;;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06@<span class="number">38</span> &#123; </span><br><span class="line">    status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    compatible = <span class="string">&quot;edt,edt-ft5306&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">    touch-gpio = &lt;&amp;gpio0 RK_PB5 IRQ_TYPE_EDGE_RISING&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio0&gt;;</span><br><span class="line">    interrupts = &lt;RK_PB5 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">    reset-gpios = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    touchscreen-size-x = &lt;<span class="number">800</span>&gt;;</span><br><span class="line">    touchscreen-size-y = &lt;<span class="number">1280</span>&gt;;</span><br><span class="line">    touch_type = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中gpio0节点是在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568.dtsi”设备树的3549-3560行定义的，而ft5x06: ft5x06@38触摸芯片节点是在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;topeet_rk3568_lcds.dtsi”设备树的301-313行定义的。接下来将会对设备树常见的四个gpio属性进行介绍。</p>
<h3 id="60-1-2-gpio-controller"><a href="#60-1-2-gpio-controller" class="headerlink" title="60.1.2 gpio-controller"></a>60.1.2 gpio-controller</h3><p>gpio-controller属性用于标识一个设备节点作为GPIO控制器。GPIO控制器是负责管理和控制GPIO引脚的硬件模块或驱动程序。</p>
<p>gpio-controller属性通常作为设备节点的一个属性出现，位于设备节点的属性列表中。</p>
<p>当一个设备节点被标识为GPIO控制器时，它通常会定义一组GPIO引脚，并提供相关的GPIO控制和配置功能。其他设备节点可以使用该GPIO控制器来控制和管理其GPIO引脚。</p>
<p>通过使用gpio-controller属性，设备树可以明确标识出GPIO控制器设备节点，使系统可以正确识别和管理GPIO引脚的配置和控制。</p>
<h3 id="60-1-3-gpio-cells"><a href="#60-1-3-gpio-cells" class="headerlink" title="60.1.3 #gpio-cells"></a>60.1.3 #gpio-cells</h3><p>#gpio-cells属性用于指定GPIO引脚描述符的编码方式。GPIO引脚描述符是用于标识和配置GPIO引脚的一组值，例如引脚编号、引脚属性等。</p>
<p>#gpio-cells属性的属性值是一个整数，表示用于编码GPIO引脚描述符的单元数。通常，这个值为2。</p>
<p>在第一小节的示例中有1个gpio引脚描述属性,由于#gpio-cells属性被设置为了2，所以每个引脚描述属性中会有两个整数，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ft5x06: ft5x06@<span class="number">38</span> &#123; </span><br><span class="line">    .....</span><br><span class="line">    reset-gpios = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>RK_PB6、GPIO_ACTIVE_LOW都属于恒定义，会在下面的小节进行讲解。</p>
<p>通过使用#gpio-cells属性，设备树可以指定GPIO引脚描述符的编码方式，使系统能够正确识别和解析GPIO引脚的配置和控制。</p>
<h3 id="60-1-4-gpio-ranges"><a href="#60-1-4-gpio-ranges" class="headerlink" title="60.1.4 gpio-ranges"></a>60.1.4 gpio-ranges</h3><p>gpio-ranges属性是设备树中一个用于描述GPIO范围映射的属性。它通常用于描述具有大量GPIO引脚的GPIO控制器，以简化GPIO引脚的编码和访问。</p>
<p>在设备树中，GPIO控制器的每个引脚都有一个本地编号，用于在控制器内部进行引脚寻址。然而，这些本地编号并不一定与外部引脚的物理编号或其他系统中使用的编号一致。为了解决这个问题，可以使用gpio-ranges属性将本地编号映射到实际的引脚编号。</p>
<p>gpio-ranges属性是一个包含一系列整数值的列表，每个整数值对应于设备树中的一个GPIO控制器。列表中的每个整数值按照特定的顺序提供以下信息：</p>
<p>（1）外部引脚编号的起始值。	</p>
<p>（2）GPIO控制器内部本地编号的起始值。</p>
<p>（3）引脚范围的大小（引脚数量）。</p>
<p>在第一小节的示例中gpio-ranges属性的值为&lt;&amp;pinctrl 0 0 32&gt;，其中&lt;&amp;pinctrl&gt;表示引用了名为pinctrl的引脚控制器节点，0 0 32表示外部引脚从0开始，控制器本地编号从0开始，共映射了32个引脚。</p>
<p>这样，gpio-ranges属性将GPIO控制器的本地编号直接映射到外部引脚编号，使得GPIO引脚的编码和访问更加简洁和直观。</p>
<h3 id="60-1-5-gpio引脚描述属性"><a href="#60-1-5-gpio引脚描述属性" class="headerlink" title="60.1.5 gpio引脚描述属性"></a>60.1.5 gpio引脚描述属性</h3><p>第一小节的设备树中关于gpio引脚描述属性相关内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ft5x06: ft5x06@38 &#123; </span><br><span class="line">    .....</span><br><span class="line">    reset-gpios = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>gpio引脚描述属性个数由#gpio-cells所决定，因为gpio0节点中的#gpio-cells属性设置为了2，所以上面设备树gpio引脚描述属性个数也为2。</p>
<p>其中RK_PB6 定义在内核源码目录下的“include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h”头文件中，定义了RK引脚名和gpio编号的宏定义，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps14.jpg" alt="img"> </p>
<p>GPIO_ACTIVE_LOW定义在源码目录下的“include&#x2F;dt-bindings&#x2F;gpio&#x2F;gpio.h”中，表示设置为低电平，同理GPIO_ACTIVE_HIGH就表示将这个GPIO设置为高电平，但这里只是对设备的描述，具体的设置还是要跟驱动相匹配。</p>
<h3 id="60-1-6-其他属性"><a href="#60-1-6-其他属性" class="headerlink" title="60.1.6 其他属性"></a>60.1.6 其他属性</h3><p>本小节将根据下面的设备树示例讲解一下gpio的其他属性，设备树具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio-controller@<span class="number">00000000</span> &#123;</span><br><span class="line">    compatible = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x00000000</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    ngpios = &lt;<span class="number">18</span>&gt;;</span><br><span class="line">    gpio-reserved-ranges = &lt;<span class="number">0</span> <span class="number">4</span>&gt;, &lt;<span class="number">12</span> <span class="number">2</span>&gt;;</span><br><span class="line">    gpio-line-names = <span class="string">&quot;MMC-CD&quot;</span>, <span class="string">&quot;MMC-WP&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;voD eth&quot;</span>, <span class="string">&quot;RST eth&quot;</span>, <span class="string">&quot;LED R&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;LED G&quot;</span>, <span class="string">&quot;LED B&quot;</span>, <span class="string">&quot;col A&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;col B&quot;</span>, <span class="string">&quot;col C&quot;</span>, <span class="string">&quot;col D&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;NMI button&quot;</span>, <span class="string">&quot;Row A&quot;</span>, <span class="string">&quot;Row B&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;Row C&quot;</span>, <span class="string">&quot;Row D&quot;</span>, <span class="string">&quot;poweroff&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;reset&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第6行的ngpios 属性指定了 GPIO 控制器所支持的 GPIO 引脚数量。它表示该设备上可用的 GPIO 引脚的总数。在这个例子中，ngpios&#96; 的值为 18，意味着该 GPIO 控制器支持 18 个 GPIO 引脚。</p>
<p>第7行的gpio-reserved-ranges属性定义了保留的GPIO范围。每个范围由两个整数值表示，用尖括号括起来。保留的GPIO范围意味着这些GPIO引脚不可用或已被其他设备或功能保留。在这个例子中，有两个保留范围：&lt;0 4&gt;和&lt;12 2&gt;。&lt;0 4&gt;表示从第0个引脚开始的连续4个引脚被保留，而&lt;12 2&gt;表示从第12个引脚开始的连续2个引脚被保留。<br>    第8行的gpio-line-names 属性定义了GPIO引脚的名称，以逗号分隔。每个名称对应一个 GPIO 引脚。这些名称用于标识和识别每个GPIO引脚的作用或连接的设备。在这个例子中，gpio-line-names属性列出了多个GPIO引脚的名称，如 “MMC-CD”、”MMC-WP”、”voD eth” 等等。通过这些名称，可以清楚地了解每个GPIO引脚的功能或用途。</p>
<h2 id="60-2-中断实例编写"><a href="#60-2-中断实例编写" class="headerlink" title="60.2 中断实例编写"></a>60.2 中断实例编写</h2><p>在上一个小节中对设备树中断要用到的属性进行了讲解，而在本小节将会编写一个在RK3568上LED灯的中断设备树。</p>
<p>首先确定LED的引脚编号，LED原理图如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps119.jpg" alt="img"> </p>
<p>从上面的原理图可以得到LED灯的引脚网络标号为Working_LEDEN_H_GPIO0_B7，对应的引脚为GPIO0_B7。</p>
<p>然后来查看内核源码目录下的“drivers&#x2F;drivers&#x2F;leds&#x2F;leds-gpio.c”文件，这是led的驱动文件，然后找到compatible匹配值相关的部分，如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps120.jpg" alt="img"> </p>
<p>可以看到compatible匹配值为gpio-leds。</p>
<p>最后在内核源码目录下的“include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h”头文件中，定义了RK引脚名和gpio编号的宏定义，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps121.jpg" alt="img"> </p>
<p>在源码目录下的“include&#x2F;dt-bindings&#x2F;gpio&#x2F;gpio.h”文件中定义了引脚极性设置宏定义，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps122.jpg" alt="img"> </p>
<p>其中GPIO_ACTIVE_HIGH表示将该引脚设置为高电平，GPIO_ACTIVE_LOW表示将该引脚设置为低电平。</p>
<p>至此，我们关于编写LED设备树的前置内容就查找完成了，接下来进行设备树的编写。</p>
<p>  编写完成的设备树如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/pinctrl/rockchip.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/gpio/gpio.h&quot;</span></span></span><br><span class="line">/&#123;</span><br><span class="line">	model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line"></span><br><span class="line">	led led@<span class="number">1</span> &#123;</span><br><span class="line">		compatible = <span class="string">&quot;gpio-leds&quot;</span>;</span><br><span class="line">		gpios = &lt;&amp;gpio0 RK_PB7 GPIO_ACTIVE_HIGH&gt;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第1行: 设备树文件的头部，指定了使用的设备树语法版本。</p>
<p>第3行：用于定义 Rockchip 平台的引脚控制器相关的绑定。</p>
<p>第4行：用于定义中断控制器相关的绑定。</p>
<p>第5行：表示设备树的根节点开始。</p>
<p>第6行：指定了设备树的模型名称，描述为 “This is my devicetree!”。</p>
<p>第9行：指定了设备节点的兼容性字符串，表示该设备与 “gpio-leds” 兼容。</p>
<p>第10行：指定了该 LED 设备所使用的 GPIO 引脚。&amp;gpio0 是引脚控制器的引用，RK_PB7 是引脚的编号或标识，GPIO_ACTIVE_HIGH 表示该 GPIO 引脚的活动电平是高电平。</p>
<p>至此，关于led的设备树就讲解完成了。</p>
<h2 id="60-3-其他SOC设备树对比"><a href="#60-3-其他SOC设备树对比" class="headerlink" title="60.3 其他SOC设备树对比"></a>60.3 其他SOC设备树对比</h2><p>而无论使用的是瑞芯微SOC还是恩智浦、三星的SOC，在设备树关于gpio相关的描述都是类似的，关于在恩智浦和三星源码中的ft5x06设备树如下所示（关于gpio相关的属性已经标记为了蓝色）：</p>
<p><em><strong>*恩智浦*</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpio1: gpio@0209c000 &#123;</span><br><span class="line">    compatible = &quot;fsl,inx6ul-gpio&quot;, &quot;fsl,imx35-gpio&quot;;</span><br><span class="line">    reg = &lt;0x0209c000 0x4000&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH&gt;, &lt;GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    #gpio-cells = &lt;2&gt;;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">    #interrupt-cells = &lt;2&gt;;</span><br><span class="line"></span><br><span class="line">    edt-ft5x06@38 &#123;</span><br><span class="line">        compatible = &quot;edt,edt-ft5306&quot;, &quot;edt,edt-ft5x06&quot;, &quot;edt,edt-ft5406&quot;;</span><br><span class="line">        pinctrl-names = &quot;default&quot;;</span><br><span class="line">        pinctrl-0 = &lt;&amp;ts_int_pin &amp;ts_reset_pin&gt;;</span><br><span class="line">        reg = &lt;0x38&gt;;</span><br><span class="line">        interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">        interrupts = &lt;9 0&gt;;</span><br><span class="line">        reset-gpios = &lt;&amp;gpio5 9 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">        irq-gpios = &lt;&amp;gpio1 9 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">        status = &quot;disabled&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em><strong>*三星*</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpio_c: gpioc &#123;</span><br><span class="line">    compatible = &quot;gpio-controller&quot;;</span><br><span class="line">    #gpio-cells = &lt;2&gt;;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">    #interrupt-cells = &lt;2&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06038 &#123;</span><br><span class="line">    compatible = &quot;edt,edt-ft5406&quot;;</span><br><span class="line">    reg = &lt;0x38&gt;;</span><br><span class="line">    pinctrl-names = &quot;default&quot;;</span><br><span class="line"></span><br><span class="line">    #if defined(RGB_1024x600) || defined(RGB_800x480)</span><br><span class="line">    pinctrl-0 = &lt;&amp;tsc2007_irq&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio_c&gt;;</span><br><span class="line">    interrupts = &lt;26 IRQ_TYPE_EDGE_FALLING&gt;;</span><br><span class="line">    #endif</span><br><span class="line"></span><br><span class="line">    #if defined(LvDs_800×1280) || defined(LvDS_1024x768)</span><br><span class="line">    pinctrl-0 = &lt;&amp;gt911_irq&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio_b&gt;;</span><br><span class="line">    interrupts = &lt;29 IRQ_TYPE_EDGE_FALLING&gt;;</span><br><span class="line">    #endif</span><br><span class="line"> reset-gpios = &lt;&amp;gpio_e 30 0&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对比之后会发现，不同厂商对于gpio的配置都是类似的，只是里面的参数有些许区别，如果大家在之后遇到了其他平台，只需要稍加区分即可。</p>
<h1 id="第61章-实例分析：pinctrl"><a href="#第61章-实例分析：pinctrl" class="headerlink" title="第61章 实例分析：pinctrl"></a><strong>第61章</strong> 实例分析：pinctrl</h1><h2 id="61-1-pinmux介绍"><a href="#61-1-pinmux介绍" class="headerlink" title="61.1 pinmux介绍"></a>61.1 pinmux介绍</h2><p>Pinmux（引脚复用）是指在系统中配置和管理引脚功能的过程。在许多现代集成电路中，单个引脚可以具有多个功能，例如作为 GPIO、UART、SPI 或 I2C 等。通过使用引脚复用功能，可以在这些不同的功能之间切换。</p>
<p>引脚复用通过硬件和软件的方式实现。硬件层面，芯片设计会为每个引脚提供多个功能的选择。这些功能通常由芯片厂商在芯片规格文档中定义。通过编程设置寄存器或开关，可以选择某个功能来连接引脚。这种硬件层面的配置通常是由引脚控制器（Pin Controller）或引脚复用控制器（Pin Mux Controller）负责管理。</p>
<p>软件层面，操作系统或设备驱动程序需要了解和配置引脚的功能。它们使用设备树（Device Tree）或设备树绑定（Device Tree Bindings）来描述和配置引脚的功能。在设备树中，可以指定引脚的复用功能，将其连接到特定的硬件接口或功能。操作系统或设备驱动程序在启动过程中解析设备树，并根据配置对引脚进行初始化和设置。</p>
<p>那我们要怎样知晓每一个管脚都可以复用成什么功能呢，一般在核心板原理图都会标注出每个管脚的复用功能，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps123.jpg" alt="img"> </p>
<p>从上图可以看到UART4_RX_M1对应的引脚可以复用为以下6个功能LCDC_D16、VOP_BT1120_D7、GMAC1_RXD0_M0、UART4_RX_M1、PWM8_M0、GPIO3_B1_d，对应的BGA引脚标号为AG1,那这里的AG1是如何定位的呢。</p>
<p>在 BGA（Ball Grid Array，球栅阵列）封装中，引脚标号是用于唯一标识每个引脚的标识符。这些标号通常由芯片制造商定义，并在芯片的规格文档或数据手册中提供。</p>
<p>BGA 芯片的引脚标号通常由字母和数字的组合构成。它们用于在芯片的封装底部的焊盘上进行标记。每个引脚标号都与芯片内部的功能或信号相对应，以便正确连接到印刷电路板（PCB）上的目标位置。RK3568的引脚标号图如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps124.jpg" alt="img"> </p>
<p>可以看到纵向为A-AH的28个字母类型标号，横向为1-28的28个字母类型标号，瑞芯微也在对应的3568数据手册中加入了根据BGA位置制作的复用功能图，部分内容如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps125.jpg" alt="img"> </p>
<p>其中黑色框代表被保留的引脚，其他有颜色的框一般为电源和地，白色的框代表有具体复用功能的引脚。</p>
<p>最后对引脚复用的优点进行整理，引脚复用提高了芯片的灵活性和可重用性，通过允许同一个引脚在不同的功能之间切换，可以减少硬件设计的复杂性和成本。此外，引脚复用还使得在使用相同芯片的不同应用中可以更加灵活地配置和定制引脚功能。会在下一个小节中讲解如何使用pinctrl在设备树中配置引脚的复用。</p>
<h2 id="61-2使用pinctrl设置复用关系"><a href="#61-2使用pinctrl设置复用关系" class="headerlink" title="61.2使用pinctrl设置复用关系"></a>61.2使用pinctrl设置复用关系</h2><p>pinctrl（引脚控制）用于描述和配置硬件设备上的引脚功能和连接方式。它是设备树的一部分，用于在启动过程中传递引脚配置信息给操作系统和设备驱动程序，以便正确地初始化和控制引脚。</p>
<p>在设备树中，pinctrl（引脚控制）使用了客户端和服务端的概念来描述引脚控制的关系和配置。</p>
<h3 id="61-2-1-客户端（Client）"><a href="#61-2-1-客户端（Client）" class="headerlink" title="61.2.1 客户端（Client）"></a>61.2.1 客户端（Client）</h3><p>接下来将使用三个例子对客户端要用到的属性进行讲解。</p>
<p>例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node &#123;</span><br><span class="line">    pinctrl-names = &quot;default&quot;;</span><br><span class="line">    pinctrl-0 = &lt;&amp;pinctrl_hog_1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在例1中，pinctrl-names 属性定义了一个状态名称：default。</p>
<p>pinctrl-0 属性指定了第一个状态 default 对应的引脚配置。</p>
<p>&lt;&amp;pinctrl_hog_1&gt; 是一个引脚描述符，它引用了一个名为 pinctrl_hog_1 的引脚控制器节点。这表示在 default 状态下，设备的引脚配置将使用 pinctrl_hog_1 节点中定义的配置。</p>
<p>例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node &#123;</span><br><span class="line">    pinctrl-names = &quot;default&quot;, &quot;wake up&quot;;</span><br><span class="line">    pinctrl-0 = &lt;&amp;pinctrl_hog_1&gt;;</span><br><span class="line">    pinctrl-1 = &lt;&amp;pinctrl_hog_2&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在例2中，pinctrl-names 属性定义了两个状态名称：default 和 wake up。</p>
<p>pinctrl-0 属性指定了第一个状态 default 对应的引脚配置，引用了 pinctrl_hog_1 节点。</p>
<p>pinctrl-1 属性指定了第二个状态 wake up 对应的引脚配置，引用了 pinctrl_hog_2 节点。</p>
<p>这意味着设备可以处于两个不同的状态之一，每个状态分别使用不同的引脚配置。</p>
<p>例3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node &#123;</span><br><span class="line">    pinctrl-names = &quot;default&quot;;</span><br><span class="line">    pinctrl-0 = &lt;&amp;pinctrl_hog_1 &amp;pinctrl_hog_2&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，pinctrl-names 属性仍然定义了一个状态名称：default。</p>
<p>pinctrl-0 属性指定了第一个状态 default 对应的引脚配置，但与之前的例子不同的是，它引用了两个引脚描述符：pinctrl_hog_1 和 pinctrl_hog_2。</p>
<p>这表示在 default 状态下，设备的引脚配置将使用 pinctrl_hog_1 和 pinctrl_hog_2 两个节点中定义的配置。这种方式可以将多个引脚控制器的配置组合在一起，以满足特定状态下的引脚需求。</p>
<p>至此关于客户端的内容就讲解完成了，低于客户端的内容，不同厂家的编写格式是相同的，而服务端每个厂家就有区别了，在下一个小节将以rk3568的pinctrl服务端为例进行讲解。</p>
<h3 id="62-2-2-服务端（Server）"><a href="#62-2-2-服务端（Server）" class="headerlink" title="62.2.2 服务端（Server）"></a>62.2.2 服务端（Server）</h3><p>服务端是设备树中定义引脚配置的部分。它包含引脚组和引脚描述符，为客户端提供引脚配置选择。服务端在设备树中定义了 pinctrl 节点，其中包含引脚组和引脚描述符的定义。</p>
<p>这里以瑞芯微的RK3568为例进行pinctrl服务端的讲解，瑞芯微原厂BSP工程师为了方便用户通过pinctrl设置管脚的复用关系，将包含所有复用关系的配置写在了内核目录下的“arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568-pinctrl.dtsi”设备树中，具体内容如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps126.jpg" alt="img"> </p>
<p>在pinctrl节点中就是每个节点的复用功能，然后我们以uart4的引脚复用为例进行讲解，uart4的pinctrl服务端内容如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps127.jpg" alt="img"> </p>
<p>其中&lt;3 RK_PB1 4 &amp;pcfg_pull_up&gt;和&lt;3 RK_PB2 4 &amp;pcfg_pull_up&gt;分别表示将GPIO3的PB1引脚设置为功能4，将GPIO3的PB2也设置为功能4，且电器属性都会设置为上拉。通过查找原理图可以得到两个引脚在BGA封装位置分别为AG1和AF2，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps128.jpg" alt="img"> </p>
<p>然后在rk3568的数据手册中找到引脚复用表对应的位置，具体内容如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps129.jpg" alt="img"><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps130.jpg" alt="img"> </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps131.jpg" alt="img"> </p>
<p>可以看到功能4对应串口4的发送端和接收端，那如果要将RK_PB1和RK_PB2设置为GPIO功能要如何设置呢，从上图可以看到GPIO对应功能0，所以可以通过以下pinctrl内容将设置RK_PB1和RK_PB2设置为GPIO功能（事实上如果不对该管脚进行功能复用该引脚默认就会设置为GPIO功能）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;3 RK_PB1 0 &amp;pcfg_pull_up&gt;,                                                                                                                                                                                           </span><br><span class="line">&lt;3 RK_PB2 0 &amp;pcfg_pull_up&gt;;</span><br></pre></td></tr></table></figure>

<p>最后来看客户端对uart4服务端的引用，具体内容在内核源码目录“arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568-evb1-ddr4-v10-linux.dts”：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps132.jpg" alt="img"> </p>
<p>通过在客户端中引用服务端的引脚描述符，设备树可以将客户端和服务端的引脚配置关联起来。这样，在设备树被解析和处理时，操作系统和设备驱动程序可以根据客户端的需求，查找并应用适当的引脚配置。</p>
<h2 id="61-3-pinctrl实例编写"><a href="#61-3-pinctrl实例编写" class="headerlink" title="61.3 pinctrl实例编写"></a>61.3 pinctrl实例编写</h2><p>本小节将会对通过上面学到的pinctrl相关知识，将led的控制引脚设置成GPIO的模式。</p>
<p>首先来对rk3568的设备树结构进行以下介绍，根据sdk源码目录下的“device&#x2F;rockchip&#x2F;rk356x&#x2F;BoardConfig-rk3568-evb1-ddr4-v10.mk”默认配置文件可以了解到编译的设备树为rk3568-evb1-ddr4-v10-linux.dts,根据设备树之间的包含关系列出了下面的表格。</p>
<table>
<thead>
<tr>
<th>顶层设备树</th>
<th>rk3568-evb1-ddr4-v10-linux.dts</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>第二级设备树</td>
<td>rk3568-evb1-ddr4-v10.dtsi</td>
<td>rk3568-linux.dtsi</td>
</tr>
<tr>
<td>第三级设备树</td>
<td>rk3568.dtsirk3568-evb.dtsi                                                                                                     topeet_screen_choose.dtsitopeet_rk3568_lcds.dtsi</td>
<td></td>
</tr>
</tbody></table>
<p>Led在rk3568-evb.dtsi设备树中已经被正常配置了，如下图所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps133.jpg" alt="img"></p>
<p>这时候可能大家就有问题了，这里也并没有配置pinctrl呀，那为什么led最后能正常使用呢，这个原因在上节课中其实我们已经提到了，当一个引脚没有被复用为任何功能时，默认就是GPIO功能，所以这里没有pinctrl led功能也可以正常使用。</p>
<p>但这里我们仍旧使用pinctrl对led进行配置，从而熟练pinctrl，首先注释掉leds节点，注释完成如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps134.jpg" alt="img"> </p>
<p>保存退出之后，然后进入到rk3568-evb1-ddr4-v10.dtsi设备树中，找到rk_485_ctl节点，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps135.jpg" alt="img"> </p>
<p>这是根节点的最后一个节点，而且也是用来控制一个GPIO的，我们完全可以仿照该节点，在该节点下方编写led控制节点，仿写完成的设备树内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_led: led &#123;</span><br><span class="line">   compatible = &quot;topeet,led&quot;;</span><br><span class="line">   gpios = &lt;&amp;gpio0 RK_PB7 GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">   pinctrl-names = &quot;default&quot;;</span><br><span class="line">   pinctrl-0 = &lt;&amp;rk_led_gpio&gt;;</span><br><span class="line">   &#125;; </span><br></pre></td></tr></table></figure>

<p>第1行：节点名称为 led，标签名为my_led。</p>
<p>第2行：compatible 属性指定了设备的兼容性标识，即设备与驱动程序之间的匹配规则。在这里，设备标识为 “topeet,led”，表示该 LED 设备与名为 “topeet,led” 的驱动程序兼容。</p>
<p>第3行：gpios 属性指定了与LED相关的GPIO（通用输入&#x2F;输出）引脚配置。</p>
<p>第4行：pinctrl-names 属性指定了与引脚控制相关的命名。default表示状态 0</p>
<p>第5行：pinctrl-0 属性指定了与 pinctrl-names 属性中命名的引脚控制相关联的实际引脚控制器配置。&lt;&amp;rk_led_gpio&gt; 表示引用了名为 rk_led_gpio 的引脚控制器配置。</p>
<p>添加完成如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps136.jpg" alt="img"> </p>
<p>然后继续找到在同一设备树文件的485 pinctrl服务端节点，具体内容如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps137.jpg" alt="img"> </p>
<p>然后在该节点下方仿写led控制引脚pinctrl服务端节点，仿写完成的节点内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rk_led&#123;</span><br><span class="line">		rk_led_gpio:rk-led-gpio &#123;</span><br><span class="line">			rockchip,pins = &lt;0 RK_PB7 RK_FUNC_GPIO &amp;pcfg_pull_none&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p>添加完成之后如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps138.jpg" alt="img"> </p>
<p>至此，led的控制引脚就通过pinctrl被复用为了GPIO功能，保存退出之后，重新编译内核，没有报错就证明我们的实验完成了。</p>
<h1 id="第62章-dtb文件格式讲解"><a href="#第62章-dtb文件格式讲解" class="headerlink" title="第62章 dtb文件格式讲解"></a><strong>第62章</strong> dtb文件格式讲解</h1><p>设备树 Blob (DTB) 格式是设备树数据的平面二进制编码。它用于在软件程序之间交换设备树数据。例如，在启动操作系统时，固件会将 DTB 传递给操作系统内核。</p>
<p>DTB 格式在单个、线性、无指针数据结构中对设备树数据进行编码。它由一个小头部和三个可变大小的部分组成：内存保留块、结构块和字符串块。这些应该以该顺序出现在展平的设备树中。因此，设备树结构作为一个整体，当加载到内存地址时，将类似于下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps139.jpg" alt="img"> </p>
<p>本节课将以下面的设备树为例对设备树的二进制文件格式进行讲解：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = <span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0, 115200&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a35&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x1</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    aliases &#123;</span><br><span class="line">        led1 = <span class="string">&quot;/gpio@22020101&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node1 &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">        gpio@<span class="number">22020102</span> &#123;</span><br><span class="line">            reg = &lt;<span class="number">0x20220102</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node2 &#123;</span><br><span class="line">        node1-child &#123;</span><br><span class="line">            pinnum = &lt;<span class="number">01234</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@<span class="number">22020101</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;led&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x20220101</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而我们之后要分析的是二进制的dtb文件，所以需要使用dtc工具将上面的dts文件编译成dtb文件，具体命令如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps140.jpg" alt="img"> </p>
<p>为了方便用户学习，已经将本章节要讲解的设备树dts文件和dtb文件放在了对应的网盘路径下，同时也将pxBinaryViewerSetup二进制分析软件放在了同一目录下，iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\49_dt_format，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps141.jpg" alt="img"> </p>
<p>使用二进制分析软件打开deb文件并设置大端模式之后如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps142.jpg" alt="img"> </p>
<p>在接下来的小节中将会对读取出的设备树二进制内容进行讲解。</p>
<h2 id="62-1-Header"><a href="#62-1-Header" class="headerlink" title="62.1 Header"></a>62.1 Header</h2><p>devicetree 的头布局由以下 C 结构定义。所有的头字段都是 32 位整数，以大端格式存储。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdt_header</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> magic;                 <span class="comment">// 设备树头部的魔数</span></span><br><span class="line">    <span class="type">uint32_t</span> totalsize;             <span class="comment">// 设备树文件的总大小</span></span><br><span class="line">    <span class="type">uint32_t</span> off_dt_struct;         <span class="comment">// 设备树结构体（节点数据）相对于文件开头的偏移量</span></span><br><span class="line">    <span class="type">uint32_t</span> off_dt_strings;        <span class="comment">// 设备树字符串表相对于文件开头的偏移量</span></span><br><span class="line">    <span class="type">uint32_t</span> off_mem_rsvmap;        <span class="comment">// 内存保留映射表相对于文件开头的偏移量</span></span><br><span class="line">    <span class="type">uint32_t</span> version;               <span class="comment">// 设备树版本号</span></span><br><span class="line">    <span class="type">uint32_t</span> last_comp_version;     <span class="comment">// 最后一个兼容版本号</span></span><br><span class="line">    <span class="type">uint32_t</span> boot_cpuid_phys;       <span class="comment">// 启动 CPU 的物理 ID</span></span><br><span class="line">    <span class="type">uint32_t</span> size_dt_strings;       <span class="comment">// 设备树字符串表的大小</span></span><br><span class="line">    <span class="type">uint32_t</span> size_dt_struct;        <span class="comment">// 设备树结构体（节点数据）的大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个字段的描述如下所示：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>magic</td>
<td>该字段为固定值 0xd00dfeed（大端）。</td>
</tr>
<tr>
<td>totalsize</td>
<td>该字段包含设备树数据结构的总大小（以字节为单位）。此大小应包含结构的所有部分：标题、内存保留块、结构块和字符串块，以及块之间或最后一个块之后的任何空闲空间间隙。</td>
</tr>
<tr>
<td>off_dt_struct</td>
<td>该字段包含结构块从头开始的以字节为单位的偏移量。</td>
</tr>
<tr>
<td>off_dt_strings</td>
<td>该字段包含字符串块从头开始的以字节为单位的偏移量。</td>
</tr>
<tr>
<td>off_mem_rsvmap</td>
<td>该字段包含从头开始的内存保留块的字节偏移量。</td>
</tr>
<tr>
<td>version</td>
<td>该字段包含设备树数据结构的版本。</td>
</tr>
<tr>
<td>last_comp_version</td>
<td>向后兼容的设备树数据结构的最低版本。</td>
</tr>
<tr>
<td>boot_cpuid_phys</td>
<td>与设备树CPU 节点的reg属性对应</td>
</tr>
<tr>
<td>size_dt_strings</td>
<td>设备树字符串块部分的字节长度。</td>
</tr>
<tr>
<td>size_dt_struct</td>
<td>设备树结构块部分的字节长度。</td>
</tr>
</tbody></table>
<p>然后来查看二进制文件，其中4个字节表示一个单位，前十个单位分别代表上述的十个字段如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps143.jpg" alt="img"> </p>
<table>
<thead>
<tr>
<th>字段</th>
<th>十六进制数值</th>
<th>代表含义</th>
</tr>
</thead>
<tbody><tr>
<td>magic</td>
<td>D00DFEED</td>
<td>固定值</td>
</tr>
<tr>
<td>totalsize</td>
<td>000002A4</td>
<td>转换为十进制之后为676，表示该文件大小为676字节</td>
</tr>
<tr>
<td>off_dt_struct</td>
<td>00000038</td>
<td>表示结构块从00000038这个地址开始，和后面的size_dt_struct结构块大小参数一起可以确定结构块的存储范围</td>
</tr>
<tr>
<td>off_dt_strings</td>
<td>0000024C</td>
<td>表示字符串块从0000024C这个地址开始，和后面的size_dt_strings字符串块大小参数一起可以确定字符串块的存储范围</td>
</tr>
<tr>
<td>off_mem_rsvmap</td>
<td>00000028</td>
<td>表示内存保留块的偏移为00000028， header之后结构快之前都是属于内存保留块。</td>
</tr>
<tr>
<td>version</td>
<td>00000011</td>
<td>11转换为十进制之后为17，表示当前设备树结构版本为17</td>
</tr>
<tr>
<td>last_comp_version</td>
<td>00000010</td>
<td>10转换为十进制之后为16，表示向前兼容的设备树结构版本为16</td>
</tr>
<tr>
<td>boot_cpuid_phys</td>
<td>00000000</td>
<td>表示设备树的teg属性为0</td>
</tr>
<tr>
<td>size_dt_strings</td>
<td>00000058</td>
<td>表示字符串块的大小为00000058 ，和前面的off_dt_strings字符串块偏移值一起可以确定字符串块的范围</td>
</tr>
<tr>
<td>size_dt_struct</td>
<td>00000214</td>
<td>表示结构块的大小为00000214，和前面的off_dt_struct结构块偏移值一起可以确定结构块的范围</td>
</tr>
</tbody></table>
<p>在接下来的小节中将会对header提到的内存保留块、结构块和字符串块进行更详细的讲解。</p>
<h2 id="62-2-内存保留块"><a href="#62-2-内存保留块" class="headerlink" title="62.2 内存保留块"></a>62.2 内存保留块</h2><p>内存保留块（Memory Reserved Block）是用于客户端程序的保护和保留物理内存区域的列表。这些保留区域不应被用于一般的内存分配，而是用于保护重要数据结构，以防止客户端程序覆盖这些数据。内存保留块的目的是确保特定的内存区域在客户端程序运行时不被修改或使用。由于在示例设备树中没有设置内存保留块，所以相应的区域都为0，如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps144.jpg" alt="img"> </p>
<p><em><strong>*保留区域列表：*</strong></em> 内存保留块是一个由一组 64 位大端整数对构成的列表。每对整数对应一个保留内存区域，其中包含物理地址和区域的大小（以字节为单位）。这些保留区域应该彼此不重叠。</p>
<p><em><strong>*保留区域的用途：*</strong></em> 客户端程序不应访问内存保留块中的保留区域，除非引导程序提供的其他信息明确指示可以访问。引导程序可以使用特定的方式来指示客户端程序可以访问保留内存的部分内容。引导程序可能会在文档、可选的扩展或特定于平台的文档中说明保留内存的特定用途。</p>
<p><em><strong>*格式：*</strong></em> 内存保留块中的每个保留区域由一个64位大端整数对表示。每对由以下 C 结构表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdt_reserve_entry</span> &#123;</span> </span><br><span class="line">	<span class="type">uint64_t</span> address; </span><br><span class="line">	<span class="type">uint64_t</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的第一个整数表示保留区域的物理地址，第二个整数表示保留区域的大小（以字节为单位）。每个整数都以 64 位的形式表示，即使在32位架构上也是如此。在32位CPU上，整数的高 32 位将被忽略。</p>
<p>内存保留块为设备树提供了保护和保留物理内存区域的功能。它确保了特定的内存区域在客户端程序运行时不被修改或使用。这样可以确保引导程序和其他关键组件在需要的情况下能够访问保留内存的特定部分，并保护关键数据结构免受意外修改。</p>
<h2 id="62-3-结构块"><a href="#62-3-结构块" class="headerlink" title="62.3 结构块"></a>62.3 结构块</h2><p>结构块是设备树中描述设备树本身结构和内容的部分。它由一系列带有数据的令牌序列组成，这些令牌按照线性树结构进行组织。</p>
<p><strong>（1）</strong><em><strong>*令牌类型*</strong></em></p>
<p> 结构块中的令牌分为五种类型，每种类型用于不同的目的。</p>
<p>a. FDT_BEGIN_NODE (0x00000001): FDT_BEGIN_NODE 标记表示一个节点的开始。它后面跟着节点的单元名称作为额外数据。节点名称以以空字符结尾的字符串形式存储，并且可以包括单元地址。节点名称后可能需要填充零字节以对齐，然后是下一个标记，可以是除了 FDT_END 之外的任何标记。</p>
<p>b. FDT_END_NODE (0x00000002): FDT_END_NODE 标记表示一个节点的结束。该标记没有额外的数据，紧随其后的是下一个标记，可以是除了 FDT_PROP 之外的任何标记。</p>
<p>c. FDT_PROP (0x00000003): FDT_PROP 标记表示设备树中属性的开始。它后面跟着描述属性的额外数据，该数据首先由属性的长度和名称组成，表示为以下 C 结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">	uint32_t len; </span><br><span class="line">	uint32_t nameoff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>长度表示属性值的字节长度，名称偏移量指向字符串块中存储属性名称的位置。在这个结构之后，属性的值作为字节字符串给出。属性值后可能需要填充零字节以对齐，然后是下一个令牌，可以是除了 FDT_END 之外的任何标记。</p>
<p>d. FDT_NOP (0x00000004): FDT_NOP 令牌可以被解析设备树的程序忽略。该令牌没有额外的数据，紧随其后的是下一个令牌，可以是任何有效的令牌。使用 FDT_NOP 令牌可以覆盖树中的属性或节点定义，从而将其从树中删除，而无需移动设备树 blob 中的其他部分。</p>
<p>e. FDT_END (0x00000009): FDT_END 标记表示结构块的结束。应该只有一个 FDT_END 标记，并且应该是结构块中的最后一个标记。该标记没有额外的数据，紧随其后的字节应该位于结构块的开头偏移处，该偏移等于设备树 blob 标头中的 size_dt_struct 字段的值。</p>
<p><strong>（2）</strong><em><strong>*树状结构：*</strong></em></p>
<p>设备树的结构以线性树的形式表示。每个节点由 FDT_BEGIN_NODE 标记开始，由 FDT_END_NODE 标记结束。节点的属性和子节点在 FDT_END_NODE 之前表示，因此子节点的 FDT_BEGIN_NODE 和 FDT_END_NODE 令牌嵌套在父节点的令牌中。</p>
<p><strong>（3）</strong><em><strong>*结构块的结束*</strong></em></p>
<p>结构块以单个 FDT_END 标记结束。该标记没有额外的数据，它位于结构块的末尾，并且是结构块中的最后一个标记。FDT_END 标记之后的字节应位于结构块的开头偏移处，该偏移等于设备树 blob 标头中的 size_dt_struct 字段的值。</p>
<p>最后对结构块开头的部分内容进行讲解，具体内容如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps145.jpg" alt="img"> </p>
<table>
<thead>
<tr>
<th>十六进制数值</th>
<th>代表含义</th>
</tr>
</thead>
<tbody><tr>
<td>00000001</td>
<td>根节点的开始</td>
</tr>
<tr>
<td>00000000</td>
<td>根节点没有节点名，所以这里名字为0</td>
</tr>
<tr>
<td>00000003</td>
<td>设备树中属性的开始</td>
</tr>
<tr>
<td>00000017</td>
<td>代表该属性的大小，换算成十进制为23，也就是”This is my devicetree!”这一字符串的长度</td>
</tr>
<tr>
<td>00000000</td>
<td>代表该属性在字符串块的偏移量，这里为0，表示无偏移</td>
</tr>
<tr>
<td>54686973-65210000</td>
<td>model的具体值</td>
</tr>
</tbody></table>
<p>通过使用结构块，设备树可以以一种层次化的方式组织和描述系统中的设备和资源。每个节点可以包含属性和子节点，从而实现更加灵活和可扩展的设备树表示。</p>
<h2 id="62-4-字符串块"><a href="#62-4-字符串块" class="headerlink" title="62.4 字符串块"></a>62.4 字符串块</h2><p>字符串块用于存储设备树中使用的所有属性名称。它由一系列以空字符结尾的字符串组成，这些字符串在字符串块中简单地连接在一起，具体示例如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps146.jpg" alt="img"> </p>
<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em><em><strong>*字符串连接*</strong></em></p>
<p> 字符串块中的字符串以空字符（\0）作为终止符来连接。这意味着每个字符串都以空字符结尾，并且下一个字符串紧跟在上一个字符串的末尾。这种连接方式使得字符串块中的所有字符串形成一个连续的字符序列。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em><em><strong>*偏移量引用*</strong></em> </p>
<p>在结构块中，属性的名称是通过偏移量来引用字符串块中的相应字符串的。偏移量是一个无符号整数值，它表示字符串在字符串块中的位置。通过使用偏移量引用，设备树可以节省空间，并且在属性名称发生变化时也更加灵活，因为只需要更新偏移量，而不需要修改结构块中的属性引用。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em><em><strong>*对齐约束：*</strong></em></p>
<p>字符串块没有对齐约束，这意味着它可以出现在设备树 blob 的任何偏移处。这使得字符串块的位置在设备树 blob 中是灵活的，并且可以根据需要进行调整，而不会对设备树的解析和处理造成影响。</p>
<p>字符串块是设备树中用于存储属性名称的部分。它由字符串连接而成，并通过偏移量在结构块中进行引用。字符串块的灵活位置使得设备树的表示更加紧凑和可扩展。</p>
<h1 id="第63章-dtb展开成device-node实验"><a href="#第63章-dtb展开成device-node实验" class="headerlink" title="第63章 dtb展开成device_node实验"></a><strong>第63章</strong> dtb展开成device_node实验</h1><p>在上个小节中我们讲解了设备树deb的文件格式，那deb文件是怎样传递给内核的呢，那就进入到本小节的学习吧。</p>
<h2 id="63-1-dtb展开流程"><a href="#63-1-dtb展开流程" class="headerlink" title="63.1 dtb展开流程"></a>63.1 dtb展开流程</h2><p>dtb展开流程图如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps147.jpg" alt="img"> </p>
<p>接下来将会根据上图对deb的展开流程进行详细的讲解：</p>
<p>****（1）设备树源文件编写****：根据之前的章节中讲解的设备树的基本语法和相关知识编写符合规范的设备树。</p>
<p><em><strong>*（2）*</strong></em>****设备树编译：****设备树源文件经过设备树编译器（dtc）进行编译，生成设备树二进制文件（.dtb）。设备树编译器会检查源文件的语法和语义，并将其转换为二进制格式，以便内核能够解析和使用。</p>
<p><em><strong>*（3）b*</strong></em>****oot.img镜像生成****：boot.img是一个包含内核镜像、设备树二进制文件和其他一些资源文件的镜像文件（目前只是适用于瑞芯微的soc上，其他厂商的soc需要具体问题具体分析）。在生成boot.img时，通常会将内核镜像、设备树二进制文件和其他一些资源文件打包在一起。这个过程可以使用特定的工具或脚本完成。</p>
<p><em><strong>*（4）*</strong></em>****U-Boot加载：****U-Boot（Universal Bootloader）是一种常用的开源引导加载程序，用于引导嵌入式系统。在系统启动过程中，U-Boot会将boot.img中的内核和设备树的二进制文件加载到系统内存的特定地址。</p>
<p><em><strong>*（5）*</strong></em>****内核初始化：****U-Boot将内核和设备树的二进制文件加载到系统内存的特定地址后，控制权会转交给内核。在内核初始化的过程中，会解析设备树二进制文件，将其展开为内核可以识别的数据结构，以便内核能够正确地初始化和管理硬件资源。</p>
<p><em><strong>*（6）*</strong></em>****设备树展开：****设备树展开是指将设备树二进制文件解析成内核中的设备节点（device_node）的过程。内核会读取设备树二进制文件的内容，并根据设备树的描述信息，构建设备树数据结构，例如设备节点、中断控制器、寄存器、时钟等。这些设备树数据结构将在内核运行时用于管理和配置硬件资源。</p>
<p>而本章节要讲解的重点就在上面的第6步“设备树的展开”，最终设备树二进制文件会被解析成device_node，device_node结构体定义在内核源码的“&#x2F;include&#x2F;linux&#x2F;of.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;                <span class="comment">// 设备节点的名称</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *type;                <span class="comment">// 设备节点的类型</span></span><br><span class="line">	phandle phandle;                  <span class="comment">// 设备节点的句柄</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *full_name;           <span class="comment">// 设备节点的完整名称</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> <span class="title">fwnode</span>;</span>     <span class="comment">// 设备节点的固件节点句柄</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">properties</span>;</span>     <span class="comment">// 设备节点的属性列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">deadprops</span>;</span>      <span class="comment">// 已删除的属性列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">parent</span>;</span>      <span class="comment">// 父设备节点指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span>       <span class="comment">// 子设备节点指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">sibling</span>;</span>     <span class="comment">// 兄弟设备节点指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_KOBJ)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>             <span class="comment">// 内核对象（用于 sysfs）</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> _flags;            <span class="comment">// 设备节点的标志位</span></span><br><span class="line">	<span class="type">void</span> *data;                      <span class="comment">// 与设备节点相关的数据指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SPARC)</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *path_component_name; <span class="comment">// 设备节点的路径组件名称</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> unique_id;          <span class="comment">// 设备节点的唯一标识</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">of_irq_controller</span> *<span class="title">irq_trans</span>;</span> <span class="comment">// 设备节点的中断控制器</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后对该结构体的重要参数进行讲解：</p>
<p>（1）name：name 字段表示设备节点的名称。设备节点的名称是在设备树中唯一标识该节点的字符串。它通常用于在设备树中引用设备节点。</p>
<p>（2）type：type 字段表示设备节点的类型。设备节点的类型提供了关于设备节点功能和所属设备类别的信息。它可以用于识别设备节点的用途和特性。</p>
<p>（3）properties：properties 字段是指向设备节点属性列表的指针。设备节点的属性包含了与设备节点相关联的配置和参数信息。属性以键值对的形式存在，可以提供设备的特定属性、寄存器地址、中断信息等。property字段同样定义在内核源码的“&#x2F;include&#x2F;linux&#x2F;of.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> *name;                    <span class="comment">// 属性的名称</span></span><br><span class="line">	<span class="type">int</span> length;                    <span class="comment">// 属性值的长度（字节数）</span></span><br><span class="line">	<span class="type">void</span> *value;                   <span class="comment">// 属性值的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">next</span>;</span>         <span class="comment">// 下一个属性节点指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_DYNAMIC) || defined(CONFIG_SPARC)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> _flags;          <span class="comment">// 属性的标志位</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_PROMTREE)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> unique_id;        <span class="comment">// 属性的唯一标识</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_KOBJ)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bin_attribute</span> <span class="title">attr</span>;</span>     <span class="comment">// 内核对象二进制属性</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（4）parent：parent 字段指向父设备节点。设备树中的设备节点按照层次结构组织，父设备节点是当前设备节点的直接上级。通过 parent 字段，可以在设备树中遍历设备节点的父子关系。</p>
<p>（5）child：child 字段指向子设备节点。在设备树中，一个设备节点可以拥有多个子设备节点。通过 child 字段，可以遍历设备节点的所有子设备节点。</p>
<p>（6）sibling：sibling 字段指向兄弟设备节点。在设备树中，同一级别的兄弟设备节点共享相同的父设备节点。通过 sibling 字段，可以在同级设备节点之间进行遍历。</p>
<p>至此，关于device_node的相关讲解就完成了，虽然我们现在知道了，dtb文件最终会展开成device_node这一可以让内核识别的格式，那更具体的实现流程是怎样的呢，让我们进入下一小节的学习吧。</p>
<h2 id="63-2-dtb解析过程源码分析"><a href="#63-2-dtb解析过程源码分析" class="headerlink" title="63.2 dtb解析过程源码分析"></a>63.2 dtb解析过程源码分析</h2><p>首先来到源码目录下的“&#x2F;init&#x2F;main.c”文件，找到其中的start_kernel 函数，start_kernel 函数是 Linux 内核启动的入口点，它是Linux内核的核心函数之一，负责完成内核的初始化和启动过程，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __init <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *command_line;</span><br><span class="line">    <span class="type">char</span> *after_dashes;</span><br><span class="line"></span><br><span class="line">    set_task_stack_end_magic(&amp;init_task);    <span class="comment">// 设置任务栈的魔数</span></span><br><span class="line">    smp_setup_processor_id();    <span class="comment">// 设置处理器ID</span></span><br><span class="line">    debug_objects_early_init();    <span class="comment">// 初始化调试对象</span></span><br><span class="line">    cgroup_init_early();    <span class="comment">// 初始化cgroup（控制组）</span></span><br><span class="line"></span><br><span class="line">    local_irq_disable();    <span class="comment">// 禁用本地中断</span></span><br><span class="line">    early_boot_irqs_disabled = <span class="literal">true</span>;     <span class="comment">// 标记早期引导期间中断已禁用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 中断仍然被禁用。进行必要的设置，然后启用它们。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    boot_cpu_init();    <span class="comment">// 初始化引导CPU</span></span><br><span class="line">    page_address_init();    <span class="comment">// 设置页地址</span></span><br><span class="line">    pr_notice(<span class="string">&quot;%s&quot;</span>, linux_banner);    <span class="comment">// 打印Linux内核版本信息</span></span><br><span class="line">    setup_arch(&amp;command_line);    <span class="comment">// 架构相关的初始化</span></span><br><span class="line">    mm_init_cpumask(&amp;init_mm);    <span class="comment">// 初始化内存管理的cpumask（CPU掩码）</span></span><br><span class="line">    setup_command_line(command_line);    <span class="comment">// 设置命令行参数</span></span><br><span class="line">    setup_nr_cpu_ids();    <span class="comment">// 设置CPU个数</span></span><br><span class="line">    setup_per_cpu_areas();    <span class="comment">// 设置每个CPU的区域</span></span><br><span class="line">    smp_prepare_boot_cpu();    <span class="comment">// 准备启动CPU（架构特定的启动CPU钩子）</span></span><br><span class="line">    boot_cpu_hotplug_init();    <span class="comment">// 初始化热插拔的引导CPU</span></span><br><span class="line"></span><br><span class="line">    build_all_zonelists(<span class="literal">NULL</span>);    <span class="comment">// 构建所有内存区域列表</span></span><br><span class="line">    page_alloc_init();    <span class="comment">// 初始化页面分配器</span></span><br><span class="line">	........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中跟设备树相关的函数为第20行的 setup_arch**(&amp;<strong>command_line</strong>);**该函数定义在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;setup.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">setup_arch</span><span class="params">(<span class="type">char</span> **cmdline_p)</span></span><br><span class="line">&#123;</span><br><span class="line">	init_mm.start_code = (<span class="type">unsigned</span> <span class="type">long</span>) _text;</span><br><span class="line">	init_mm.end_code   = (<span class="type">unsigned</span> <span class="type">long</span>) _etext;</span><br><span class="line">	init_mm.end_data   = (<span class="type">unsigned</span> <span class="type">long</span>) _edata;</span><br><span class="line">	init_mm.brk	   = (<span class="type">unsigned</span> <span class="type">long</span>) _end;</span><br><span class="line"></span><br><span class="line">	*cmdline_p = boot_command_line;</span><br><span class="line"></span><br><span class="line">	early_fixmap_init();    <span class="comment">// 初始化 early fixmap</span></span><br><span class="line">	early_ioremap_init();    <span class="comment">// 初始化 early ioremap</span></span><br><span class="line"></span><br><span class="line">	setup_machine_fdt(__fdt_pointer);    <span class="comment">// 设置机器的 FDT（平台设备树）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化静态密钥，早期可能会被 cpufeature 代码和早期参数启用</span></span><br><span class="line">	jump_label_init();</span><br><span class="line">	parse_early_param();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在启动可能的早期控制台后，解除屏蔽异步中断和 FIQ（一旦我们可以报告发生的系统错误）</span></span><br><span class="line">	local_daif_restore(DAIF_PROCCTX_NOIRQ);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在这个阶段，TTBR0仅用于身份映射。将其指向零页面，以避免做出猜测性的新条目获取。</span></span><br><span class="line">	cpu_uninstall_idmap();</span><br><span class="line"></span><br><span class="line">	xen_early_init();    <span class="comment">// Xen 平台的早期初始化</span></span><br><span class="line">	efi_init();    <span class="comment">// EFI 平台的初始化</span></span><br><span class="line">	arm64_memblock_init();    <span class="comment">// ARM64 内存块的初始化</span></span><br><span class="line"></span><br><span class="line">	paging_init();    <span class="comment">// 分页初始化</span></span><br><span class="line"></span><br><span class="line">	acpi_table_upgrade();    <span class="comment">// ACPI 表的升级</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析 ACPI 表以进行可能的引导时配置</span></span><br><span class="line">	acpi_boot_table_init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (acpi_disabled)</span><br><span class="line">		unflatten_device_tree();    <span class="comment">// 展开设备树</span></span><br><span class="line"></span><br><span class="line">	bootmem_init();    <span class="comment">// 引导内存的初始化</span></span><br><span class="line">	............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在setup_arch函数中与设备树相关的函数分别为第13行的setup_machine_fdt(__fdt_pointer)和第37行的unflatten_device_tree()，接下来将对上述两个函数进行详细的介绍</p>
<p><strong>1.</strong> setup_machine_fdt(__fdt_pointer)</p>
<p>其中__fdt_pointer是dtb二进制文件加载到内存的地址，该地址由bootloader启动kernel时透过x0寄存器传递过来的，具体的汇编代码在内核源码目录下的“&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;head.S”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">preserve_boot_args:</span><br><span class="line">	mov	x21, x0				<span class="comment">// x21=FDT</span></span><br><span class="line"></span><br><span class="line">__primary_switched:</span><br><span class="line">	str_l	x21, __fdt_pointer, x5		<span class="comment">// Save FDT pointer</span></span><br></pre></td></tr></table></figure>

<p>第2行: 将寄存器 x0 的值复制到寄存器 x21。x0 寄存器中保存了一个指针，该指针指向设备树（Device Tree）。</p>
<p>第4行: 将寄存器 x21 的值存储到内存地址 __fdt_pointer 中。</p>
<p>然后来看setup_machine_fdt函数，该函数定义在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;setup.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化设置机器的设备树</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">setup_machine_fdt</span><span class="params">(<span class="type">phys_addr_t</span> dt_phys)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 将设备树物理地址映射到内核虚拟地址空间</span></span><br><span class="line">    <span class="type">void</span> *dt_virt = fixmap_remap_fdt(dt_phys, &amp;size, PAGE_KERNEL);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果映射成功</span></span><br><span class="line">    <span class="keyword">if</span> (dt_virt) &#123;</span><br><span class="line">        <span class="comment">// 保留设备树占用的内存区域</span></span><br><span class="line">        memblock_reserve(dt_phys, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设备树映射失败或者设备树解析失败</span></span><br><span class="line">    <span class="keyword">if</span> (!dt_virt || !early_init_dt_scan(dt_virt)) &#123;</span><br><span class="line">        <span class="comment">// 输出错误信息</span></span><br><span class="line">		pr_crit(<span class="string">&quot;\n&quot;</span></span><br><span class="line">			<span class="string">&quot;Error: invalid device tree blob at physical address %pa (virtual address 0x%p)\n&quot;</span></span><br><span class="line">			<span class="string">&quot;The dtb must be 8-byte aligned and must not exceed 2 MB in size\n&quot;</span></span><br><span class="line">			<span class="string">&quot;\nPlease check your bootloader.&quot;</span>,</span><br><span class="line">			&amp;dt_phys, dt_virt);</span><br><span class="line">        <span class="comment">// 无限循环，等待系统崩溃</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            cpu_relax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 早期修复完成，将设备树映射为只读模式</span></span><br><span class="line">    fixmap_remap_fdt(dt_phys, &amp;size, PAGE_KERNEL_RO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取设备树的机器名</span></span><br><span class="line">    name = of_flat_dt_get_machine_name();</span><br><span class="line">    <span class="comment">// 如果设备树没有机器名，则返回</span></span><br><span class="line">    <span class="keyword">if</span> (!name)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	    pr_info(<span class="string">&quot;Machine model: %s\n&quot;</span>, name); <span class="comment">// 输出机器型号信息</span></span><br><span class="line">    dump_stack_set_arch_desc(<span class="string">&quot;%s (DT)&quot;</span>, name); <span class="comment">// 设置栈转储的架构描述为机器型号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数用于在内核启动过程中设置机器的设备树。在此函数中，将执行以下步骤： </p>
<p>1.使用 fixmap_remap_fdt() 将设备树映射到内核虚拟地址空间中的 fixmap 区域。 </p>
<p>2.如果映射成功，则使用 memblock_reserve() 保留设备树占用的物理内存区域。 </p>
<p>3.检查设备树的有效性和完整性，通过调用early_init_dt_scan()进行早期扫描。 如果设备树无效或扫描失败，则会输出错误信息并进入死循环。 </p>
<p>4.早期修复已完成，现在将设备树映射为只读，通过调用 fixmap_remap_fdt() 实现。</p>
<p>5.获取设备树中的机器模型名称，通过调用 of_flat_dt_get_machine_name()。</p>
<p>6.如果机器模型名称存在，则输出机器模型的信息，并通过 dump_stack_set_arch_desc() 设置堆栈描述信息。</p>
<p>其中上面的第3步调用的early_init_dt_scan() 需要详细的讲解一下，该函数定义在内核源码的“drivers&#x2F;of&#x2F;fdt.c”目录下，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> __init <span class="title function_">early_init_dt_scan</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证设备树的兼容性和完整性</span></span><br><span class="line">    status = early_init_dt_verify(params);</span><br><span class="line">    <span class="keyword">if</span> (!status)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描设备树节点</span></span><br><span class="line">    early_init_dt_scan_nodes();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，调用 early_init_dt_verify() 函数对设备树进行兼容性和完整性验证。该函数可能会检查设备树中的一致性标记、版本信息以及必需的节点和属性是否存在。如果验证失败，函数会返回 false。该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> __init <span class="title function_">early_init_dt_verify</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 验证传入的参数是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!params)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查设备树头部的有效性</span></span><br><span class="line">    <span class="comment">// 如果设备树头部无效，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (fdt_check_header(params))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置指向设备树的指针为传入的参数</span></span><br><span class="line">    initial_boot_params = params;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算设备树的 CRC32 校验值</span></span><br><span class="line">    <span class="comment">// 并将结果保存在全局变量 of_fdt_crc32 中</span></span><br><span class="line">    of_fdt_crc32 = crc32_be(~<span class="number">0</span>, initial_boot_params, fdt_totalsize(initial_boot_params));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 true，表示设备树验证和初始化成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第4行：该进行参数的有效性检查，如果 params 为空，则直接返回 false，表示参数无效。</p>
<p>第9行：检查设备树头部的有效性。fdt_check_header 是一个用于检查设备树头部的函数，如果设备树头部无效，则返回 false，表示设备树不合法。</p>
<p>第13行：如果设备树头部有效，程序继续执行，将传入的 params 赋值给全局变量 initial_boot_params，用来保存设备树的指针。</p>
<p>第17行，使用 crc32_be 函数计算设备树的 CRC32 校验值，其中 crc32_be 是一个用于计算 CRC32 校验值的函数，~0 表示初始值为全1的位模式。计算完成后，将结果保存在全局变量 of_fdt_crc32 中。</p>
<p>然后继续回到early_init_dt_scan() 函数中，如果设备树验证成功（即 status 为真），则调用 early_init_dt_scan_nodes() 函数。这个函数的作用是扫描设备树的节点并进行相应的处理，该函数的具体内容如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">early_init_dt_scan_nodes</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 从 /chosen 节点中检索各种信息 */</span></span><br><span class="line">	of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化 &#123;size,address&#125;-cells 信息 */</span></span><br><span class="line">	of_scan_flat_dt(early_init_dt_scan_root, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置内存信息，调用 early_init_dt_add_memory_arch 函数 */</span></span><br><span class="line">	of_scan_flat_dt(early_init_dt_scan_memory, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数early_init_dt_scan_nodes被声明为__init，这表示它是在内核初始化阶段被调用，并且在初始化完成后不再需要。该函数的目的是在早期阶段扫描设备树节点，并执行一些初始化操作。</p>
<p>函数中主要调用了of_scan_flat_dt函数，该函数用于扫描平面设备树（flat device tree）。平面设备树是一种将设备树以紧凑形式表示的数据结构，它不使用树状结构，而是使用线性结构，以节省内存空间。</p>
<p>具体来看，early_init_dt_scan_nodes函数的执行步骤如下：</p>
<p>（1）of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line)：从设备树的&#x2F;chosen节点中检索各种信息。&#x2F;chosen节点通常包含了一些系统的全局配置参数，比如命令行参数。early_init_dt_scan_chosen是一个回调函数，用于处理&#x2F;chosen节点的信息。boot_command_line是一个参数，表示内核启动时的命令行参数。</p>
<p>（2）of_scan_flat_dt(early_init_dt_scan_root, NULL)：初始化{size,address}-cells信息。{size,address}-cells描述了设备节点中地址和大小的编码方式。early_init_dt_scan_root是一个回调函数，用于处理设备树的根节点。</p>
<p>（3）of_scan_flat_dt(early_init_dt_scan_memory, NULL)：设置内存信息，并调用early_init_dt_add_memory_arch函数。这个步骤主要用于在设备树中获取内存的相关信息，并将其传递给内核的内存管理模块。early_init_dt_scan_memory是一个回调函数，用于处理内存信息。</p>
<p>至此，关于setup_machine_fdt(__fdt_pointer)代码的分析就完成了。</p>
<p><strong>2.</strong> <em><strong>*unflatten_device_tree*</strong></em></p>
<p>该函数用于解析设备树，将紧凑的设备树数据结构转换为树状结构的设备树，该函数定义在内核源码目录下的“&#x2F;drivers&#x2F;of&#x2F;fdt.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">unflatten_device_tree</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 解析设备树 */</span></span><br><span class="line">    __unflatten_device_tree(initial_boot_params, <span class="literal">NULL</span>, &amp;of_root,</span><br><span class="line">                            early_init_dt_alloc_memory_arch, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取指向 &quot;/chosen&quot; 和 &quot;/aliases&quot; 节点的指针，以供全局使用 */</span></span><br><span class="line">    of_alias_scan(early_init_dt_alloc_memory_arch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 运行设备树的单元测试 */</span></span><br><span class="line">    unittest_unflatten_overlay_base();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数主要用于解析设备树，并将解析后的设备树存储在全局变量of_root中。</p>
<p>函数首先调用__unflatten_device_tree函数来执行设备树的解析操作。解析后的设备树将使用of_root指针进行存储。</p>
<p>接下来，函数调用of_alias_scan函数。这个函数用于扫描设备树中的&#x2F;chosen和&#x2F;aliases节点，并为它们分配内存。这样，其他部分的代码可以通过全局变量访问这些节点。</p>
<p>最后，函数调用unittest_unflatten_overlay_base函数，用于运行设备树的单元测试。</p>
<p>然后对__unflatten_device_tree这一设备树的解析函数进行详细的介绍，该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *__unflatten_device_tree(<span class="type">const</span> <span class="type">void</span> *blob,</span><br><span class="line">		      <span class="keyword">struct</span> device_node *dad,</span><br><span class="line">			      <span class="keyword">struct</span> device_node **mynodes,</span><br><span class="line">			      <span class="type">void</span> *(*dt_alloc)(u64 size, u64 align),</span><br><span class="line">			      <span class="type">bool</span> detached)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	<span class="type">void</span> *mem;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot; -&gt; unflatten_device_tree()\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!blob) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;No device tree pointer\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;Unflattening device tree:\n&quot;</span>);</span><br><span class="line">	pr_debug(<span class="string">&quot;magic: %08x\n&quot;</span>, fdt_magic(blob));</span><br><span class="line">	pr_debug(<span class="string">&quot;size: %08x\n&quot;</span>, fdt_totalsize(blob));</span><br><span class="line">	pr_debug(<span class="string">&quot;version: %08x\n&quot;</span>, fdt_version(blob));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fdt_check_header(blob)) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;Invalid device tree blob header\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 第一遍扫描，计算大小 */</span></span><br><span class="line">	size = unflatten_dt_nodes(blob, <span class="literal">NULL</span>, dad, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (size &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	size = ALIGN(size, <span class="number">4</span>);</span><br><span class="line">	pr_debug(<span class="string">&quot;  大小为 %d，正在分配内存...\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 为展开的设备树分配内存 */</span></span><br><span class="line">	mem = dt_alloc(size + <span class="number">4</span>, <span class="keyword">alignof</span>(<span class="keyword">struct</span> device_node));</span><br><span class="line">	<span class="keyword">if</span> (!mem)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(mem, <span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line">	*(__be32 *)(mem + size) = cpu_to_be32(<span class="number">0xdeadbeef</span>);</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;  正在展开 %p...\n&quot;</span>, mem);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 第二遍扫描，实际展开设备树 */</span></span><br><span class="line">	unflatten_dt_nodes(blob, mem, dad, mynodes);</span><br><span class="line">	<span class="keyword">if</span> (be32_to_cpup(mem + size) != <span class="number">0xdeadbeef</span>)</span><br><span class="line">		pr_warning(<span class="string">&quot;End of tree marker overwritten: %08x\n&quot;</span>,</span><br><span class="line">			   be32_to_cpup(mem + size));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (detached &amp;&amp; mynodes) &#123;</span><br><span class="line">		of_node_set_flag(*mynodes, OF_DETACHED);</span><br><span class="line">		pr_debug(<span class="string">&quot;unflattened tree is detached\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot; &lt;- unflatten_device_tree()\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的重点在两次设备树的扫描上，第一遍扫描的目的是计算展开设备树所需的内存大小。</p>
<p>第29行：unflatten_dt_nodes函数的作用是递归地遍历设备树数据块，并计算展开设备树所需的内存大小。它接受四个参数：blob（设备树数据块指针）、start（当前节点的起始地址，初始为NULL）、dad（父节点指针）和mynodes（用于存储节点指针数组的指针，初始为NULL）。</p>
<p>第一遍扫描完成后，unflatten_dt_nodes函数会返回展开设备树所需的内存大小，然后在对大小进行对齐操作，并为展开的设备树分配内存。</p>
<p>第二遍扫描的目的是实际展开设备树，并填充设备节点的名称、类型和属性等信息。</p>
<p>第49行：再次调用了unflatten_dt_nodes函数进行第二遍扫描。通过这样的过程，第二遍扫描会将设备树数据块中的节点展开为真正的设备节点，并填充节点的名称、类型和属性等信息。这样就完成了设备树的展开过程。</p>
<p>最后我们来对unflatten_dt_nodes函数内容进行一下深究，unflatten_dt_nodes函数具体定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">unflatten_dt_nodes</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *blob,</span></span><br><span class="line"><span class="params">			      <span class="type">void</span> *mem,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> device_node *dad,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> device_node **nodepp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">root</span>;</span>  <span class="comment">// 根节点</span></span><br><span class="line">	<span class="type">int</span> offset = <span class="number">0</span>, depth = <span class="number">0</span>, initial_depth = <span class="number">0</span>;  <span class="comment">// 偏移量、深度和初始深度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_MAX_DEPTH	64  <span class="comment">// 最大深度</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nps</span>[<span class="title">FDT_MAX_DEPTH</span>];</span>  <span class="comment">// 设备节点数组</span></span><br><span class="line">	<span class="type">void</span> *base = mem;  <span class="comment">// 基地址，用于计算偏移量</span></span><br><span class="line">	<span class="type">bool</span> dryrun = !base;  <span class="comment">// 是否只是模拟运行，不实际处理</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nodepp)</span><br><span class="line">		*nodepp = <span class="literal">NULL</span>;  <span class="comment">// 如果指针不为空，将其置为空指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果 @dad 有效，则表示正在展开设备子树。</span></span><br><span class="line"><span class="comment">	 * 在第一层深度可能有多个节点。</span></span><br><span class="line"><span class="comment">	 * 将 @depth 设置为 1，以使 fdt_next_node() 正常工作。</span></span><br><span class="line"><span class="comment">	 * 当发现负的 @depth 时，该函数会立即退出。</span></span><br><span class="line"><span class="comment">	 * 否则，除第一个节点外的设备节点将无法成功展开。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dad)</span><br><span class="line">		depth = initial_depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	root = dad;  <span class="comment">// 根节点为 @dad</span></span><br><span class="line">	nps[depth] = dad;  <span class="comment">// 将根节点放入设备节点数组</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (offset = <span class="number">0</span>;</span><br><span class="line">	     offset &gt;= <span class="number">0</span> &amp;&amp; depth &gt;= initial_depth;</span><br><span class="line">	     offset = fdt_next_node(blob, offset, &amp;depth)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(depth &gt;= FDT_MAX_DEPTH))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果未启用 CONFIG_OF_KOBJ 并且节点不可用，则跳过该节点</span></span><br><span class="line">		<span class="keyword">if</span> (!IS_ENABLED(CONFIG_OF_KOBJ) &amp;&amp;</span><br><span class="line">		    !of_fdt_device_is_available(blob, offset))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 填充节点信息，并将子节点添加到设备节点数组</span></span><br><span class="line">		<span class="keyword">if</span> (!populate_node(blob, offset, &amp;mem, nps[depth],</span><br><span class="line">				   &amp;nps[depth+<span class="number">1</span>], dryrun))</span><br><span class="line">			<span class="keyword">return</span> mem - base;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!dryrun &amp;&amp; nodepp &amp;&amp; !*nodepp)</span><br><span class="line">			*nodepp = nps[depth+<span class="number">1</span>];  <span class="comment">// 将子节点指针赋值给 @nodepp</span></span><br><span class="line">		<span class="keyword">if</span> (!dryrun &amp;&amp; !root)</span><br><span class="line">			root = nps[depth+<span class="number">1</span>];  <span class="comment">// 如果根节点为空，则将子节点设置为根节点</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset &lt; <span class="number">0</span> &amp;&amp; offset != -FDT_ERR_NOTFOUND) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;Error %d processing FDT\n&quot;</span>, offset);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 反转子节点列表。一些驱动程序假设节点顺序与 .dts 文件中的节点顺序一致</span></span><br><span class="line">	<span class="keyword">if</span> (!dryrun)</span><br><span class="line">		reverse_nodes(root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mem - base;  <span class="comment">// 返回处理的字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unflatten_dt_nodes 函数的作用我们在上面已经讲解过了，这里重点介绍第31行的 fdt_next_node()函数和第41行的populate_node函数。</p>
<p>fdt_next_node() 函数用来遍历设备树的节点。从偏移量为 0 开始，只要偏移量大于等于 0 且深度大于等于初始深度，就执行循环。循环中的每次迭代都会处理一个设备树节点。</p>
<p>在每次迭代中，首先检查深度是否超过了最大深度 FDT_MAX_DEPTH，如果超过了，则跳过该节点。</p>
<p>如果未启用 CONFIG_OF_KOBJ 并且节点不可用（通过 of_fdt_device_is_available() 函数判断），则跳过该节点。</p>
<p>随后调用 populate_node() 函数填充节点信息，并将子节点添加到设备节点数组 nps 中。 populate_node() 函数定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">populate_node</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *blob,</span></span><br><span class="line"><span class="params">			  <span class="type">int</span> offset,</span></span><br><span class="line"><span class="params">			  <span class="type">void</span> **mem,</span></span><br><span class="line"><span class="params">			  <span class="keyword">struct</span> device_node *dad,</span></span><br><span class="line"><span class="params">			  <span class="keyword">struct</span> device_node **pnp,</span></span><br><span class="line"><span class="params">			  <span class="type">bool</span> dryrun)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span>  <span class="comment">// 设备节点指针</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *pathp;  <span class="comment">// 节点路径字符串指针</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> l, allocl;  <span class="comment">// 路径字符串长度和分配的内存大小</span></span><br><span class="line"></span><br><span class="line">	pathp = fdt_get_name(blob, offset, &amp;l);  <span class="comment">// 获取节点路径和长度</span></span><br><span class="line">	<span class="keyword">if</span> (!pathp) &#123;</span><br><span class="line">		*pnp = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	allocl = ++l;  <span class="comment">// 分配内存大小为路径长度加一，用于存储节点路径字符串</span></span><br><span class="line"></span><br><span class="line">	np = unflatten_dt_alloc(mem, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> device_node) + allocl,</span><br><span class="line">				__alignof__(<span class="keyword">struct</span> device_node));  <span class="comment">// 分配设备节点内存</span></span><br><span class="line">	<span class="keyword">if</span> (!dryrun) &#123;</span><br><span class="line">		<span class="type">char</span> *fn;</span><br><span class="line">		of_node_init(np);  <span class="comment">// 初始化设备节点</span></span><br><span class="line">		np-&gt;full_name = fn = ((<span class="type">char</span> *)np) + <span class="keyword">sizeof</span>(*np);  <span class="comment">// 设置设备节点的完整路径名</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">memcpy</span>(fn, pathp, l);  <span class="comment">// 将节点路径字符串复制到设备节点的完整路径名中</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dad != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			np-&gt;parent = dad;  <span class="comment">// 设置设备节点的父节点</span></span><br><span class="line">			np-&gt;sibling = dad-&gt;child;  <span class="comment">// 设置设备节点的兄弟节点</span></span><br><span class="line">			dad-&gt;child = np;  <span class="comment">// 将设备节点添加为父节点的子节点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	populate_properties(blob, offset, mem, np, pathp, dryrun);  <span class="comment">// 填充设备节点的属性信息</span></span><br><span class="line">	<span class="keyword">if</span> (!dryrun) &#123;</span><br><span class="line">		np-&gt;name = of_get_property(np, <span class="string">&quot;name&quot;</span>, <span class="literal">NULL</span>);  <span class="comment">// 获取设备节点的名称属性</span></span><br><span class="line">		np-&gt;type = of_get_property(np, <span class="string">&quot;device_type&quot;</span>, <span class="literal">NULL</span>);  <span class="comment">// 获取设备节点的设备类型属性</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!np-&gt;name)</span><br><span class="line">			np-&gt;name = <span class="string">&quot;&lt;NULL&gt;&quot;</span>;  <span class="comment">// 如果设备节点没有名称属性，则设置为&quot;&lt;NULL&gt;&quot;</span></span><br><span class="line">		<span class="keyword">if</span> (!np-&gt;type)</span><br><span class="line">			np-&gt;type = <span class="string">&quot;&lt;NULL&gt;&quot;</span>;  <span class="comment">// 如果设备节点没有设备类型属性，则设置为&quot;&lt;NULL&gt;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*pnp = np;  <span class="comment">// 将设备节点指针赋值给*pnp</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在populate_node 函数中首先会调用第18行的 unflatten_dt_alloc 函数分配设备节点内存。分配的内存大小为 sizeof(struct device_node) + allocl 字节，并使用 <strong>alignof</strong>(struct device_node) 对齐。然后调用 populate_properties 函数填充设备节点的属性信息。该函数会解析设备节点的属性，并根据需要分配内存来存储属性值。</p>
<p>至此，关于dtb二进制文件的解析过程就讲解完成了，完整的源码分析流程图如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps148.jpg" alt="img"> </p>
<h1 id="第64章-device-node转换成platform-device实验"><a href="#第64章-device-node转换成platform-device实验" class="headerlink" title="第64章  device_node转换成platform_device实验"></a>第64章  device_node转换成platform_device实验</h1><p>在上一章中，我们学习了dtb二进制文件展开成device_node的具体流程，而device_node这时候还并不能跟内核中的platform_driver进行对接，而为了让操作系统能够识别和管理设备，需要将设备节点转换为平台设备。</p>
<h2 id="64-1-转换规格"><a href="#64-1-转换规格" class="headerlink" title="64.1 转换规格"></a>64.1 转换规格</h2><p>在之前学习的平台总线模型中，device部分是用platform_device结构体来描述硬件资源的，所以内核最终会将内核认识的device_node树转换platform_ device，但是并不是所有的device_node都会被转换成platform_ device，只有满足要求的才会转换成platform_ device,转换成platform_device的节点可以在&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;devices下查看，那device_node节点要满足什么要求才会被转换成platform_device呢? </p>
<p>根据规则1，首先遍历根节点下包含 compatible 属性的子节点，对于每个子节点，创建一个对应的 platform_device。</p>
<p>根据规则2，遍历包含 compatible 属性为 “simple-bus”、”simple-mfd” 或 “isa” 的节点以及它们的子节点。如果子节点包含 compatible 属性值则会创建一个对应的platform_device。</p>
<p>根据规则3，检查节点的 compatible 属性是否包含 “arm” 或 “primecell”。如果是，则不将该节点转换为 platform_device，而是将其识别为 AMBA 设备。</p>
<p>接下来将通过几个设备树示例对上述规则进行实践。</p>
<p><em><strong>*举例1：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = <span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0, 115200&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a35&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x1</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    aliases &#123;</span><br><span class="line">        led1 = <span class="string">&quot;/gpio@22020101&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node1 &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">        gpio@<span class="number">22020102</span> &#123;</span><br><span class="line">            reg = &lt;<span class="number">0x20220102</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node2 &#123;</span><br><span class="line">        node1-child &#123;</span><br><span class="line">            pinnum = &lt;<span class="number">01234</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@<span class="number">22020101</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;led&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x20220101</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的设备树中，总共有chosen、cpu1: cpu@1、aliases、node1、node2、gpio@22020101</p>
<p>这六个节点，其中前五个节点都没有compatible属性，所以并不会被转换为platform_device，而最后一个gpio@22020101节点符合规则一，在根节点下，且有compatible属性，所以最后会转换为platform_device。</p>
<p><em><strong>*举例2：*</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = &quot;This is my devicetree!&quot;;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;1&gt;;</span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = &quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0, 115200&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@1 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a35&quot;, &quot;arm,armv8&quot;;</span><br><span class="line">        reg = &lt;0x0 0x1&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    aliases &#123;</span><br><span class="line">        led1 = &quot;/gpio@22020101&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node1 &#123;</span><br><span class="line">        #address-cells = &lt;1&gt;;</span><br><span class="line">        #size-cells = &lt;1&gt;;</span><br><span class="line">		    compatible = &quot;simple-bus&quot;;</span><br><span class="line">        gpio@22020102 &#123;</span><br><span class="line">            reg = &lt;0x20220102 0x40&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node2 &#123;</span><br><span class="line">        node1-child &#123;</span><br><span class="line">            pinnum = &lt;01234&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@22020101 &#123;</span><br><span class="line">        compatible = &quot;led&quot;;</span><br><span class="line">        reg = &lt;0x20220101 0x40&gt;;</span><br><span class="line">        status = &quot;okay&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相较于示例1的设备树，这里在node1节点中添加了 compatible 属性，但是这个compatible属性值为simple-bus，我们需要继续看他的子节点，子节点 gpio@22020102 并没有compatible属性值，所以这里的node1节点不会被转换。</p>
<p><em><strong>*举例3：*</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = &quot;This is my devicetree!&quot;;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;1&gt;;</span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = &quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0, 115200&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@1 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a35&quot;, &quot;arm,armv8&quot;;</span><br><span class="line">        reg = &lt;0x0 0x1&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    aliases &#123;</span><br><span class="line">        led1 = &quot;/gpio@22020101&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node1 &#123;</span><br><span class="line">        #address-cells = &lt;1&gt;;</span><br><span class="line">        #size-cells = &lt;1&gt;;</span><br><span class="line">		    compatible = &quot;simple-bus&quot;;</span><br><span class="line">        gpio@22020102 &#123;</span><br><span class="line">			compatible = &quot;gpio&quot;;</span><br><span class="line">            reg = &lt;0x20220102 0x40&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node2 &#123;</span><br><span class="line">        node1-child &#123;</span><br><span class="line">            pinnum = &lt;01234&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@22020101 &#123;</span><br><span class="line">        compatible = &quot;led&quot;;</span><br><span class="line">        reg = &lt;0x20220101 0x40&gt;;</span><br><span class="line">        status = &quot;okay&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相较于示例2的设备树，这里在node1节点的子节点 gpio@22020102 中添加了 compatible 属性，node1节点的compatible属性值为simple-bus，然后需要继续看他的子节点，子节点 gpio@22020102 的compatible属性值为gpio，所以这里的gpio@22020102节点会被转换成platform_device。</p>
<p><em><strong>*举例4：*</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = &quot;This is my devicetree!&quot;;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;1&gt;;</span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = &quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0,115200&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpul: cpu@1 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a35&quot;, &quot;arm,armv8&quot;;</span><br><span class="line">        reg = &lt;0x0 0x1&gt;;</span><br><span class="line"></span><br><span class="line">        amba &#123;</span><br><span class="line">            compatible = &quot;simple-bus&quot;;</span><br><span class="line">            #address-cells = &lt;2&gt;;</span><br><span class="line">            #size-cells = &lt;2&gt;;</span><br><span class="line">            ranges;</span><br><span class="line"></span><br><span class="line">            dmac_peri: dma-controller@ff250000 &#123;</span><br><span class="line">                compatible = &quot;arm,p1330&quot;, &quot;arm,primecell&quot;;</span><br><span class="line">                reg = &lt;0x0 0xff250000 0x0 0x4000&gt;;</span><br><span class="line">                interrupts = &lt;GIC_SPI 2 IRQ_TYPE_LEVEL_HIGH&gt;,</span><br><span class="line">                             &lt;GIC_SPI 3 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">                #dma-cells = &lt;1&gt;;</span><br><span class="line">                arm,pl330-broken-no-flushp;</span><br><span class="line">                arm,p1330-periph-burst;</span><br><span class="line">                clocks = &lt;&amp;cru ACLK DMAC_PERI&gt;;</span><br><span class="line">                clock-names = &quot;apb_pclk&quot;;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            dmac_bus: dma-controller@ff600000 &#123;</span><br><span class="line">                compatible = &quot;arm,p1330&quot;, &quot;arm,primecell&quot;;</span><br><span class="line">                reg = &lt;0x0 0xff600000 0x0 0x4000&gt;;</span><br><span class="line">                interrupts = &lt;GIC_SPI 0 IRQ_TYPE_LEVEL_HIGH&gt;,</span><br><span class="line">                             &lt;GIC_SPI 1 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">                #dma-cells = &lt;1&gt;;</span><br><span class="line">                arm,pl330-broken-no-flushp;</span><br><span class="line">                arm,pl330-periph-burst;</span><br><span class="line">                clocks = &lt;&amp;cru ACLK_DMAC_BUS&gt;;</span><br><span class="line">                clock-names = &quot;apb_pclk&quot;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>amba 节点的compatible值为simple-bus，不会被转换为 platform_device，而是作为父节点用于组织其他设备，所以需要来查看他的子节点。</p>
<p>dmac_peri: dma-controller@ff250000 节点: 该节点的 compatible 属性包含 “arm,p1330” 和 “arm,primecell”，根据规则3，该节点不会被转换为 platform_device，而是被识别为 AMBA 设备。</p>
<p>dmac_bus: dma-controller@ff600000 节点: 该节点的 compatible 属性包含 “arm,p1330” 和 “arm,primecell”，根据规则3，该节点不会被转换为 platform_device，而是被识别为 AMBA 设备。</p>
<h2 id="64-2-转换流程源码分析"><a href="#64-2-转换流程源码分析" class="headerlink" title="64.2 转换流程源码分析"></a>64.2 转换流程源码分析</h2><p>首先进入到内核源码目录下的“drivers&#x2F;of&#x2F;platform.c”文件中，找到第555行，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arch_initcall_sync(of_platform_default_populate_init);</span><br></pre></td></tr></table></figure>

<p>arch_initcall_sync 是 Linux 内核中的一个函数，用于在内核初始化过程中执行架构相关的初始化函数。它属于内核的初始化调用机制，用于确保在系统启动过程中适时地调用特定架构的初始化函数。</p>
<p>在Linux内核的初始化过程中，各个子系统和架构会注册自己的初始化函数。这些初始化函数负责完成特定子系统或架构相关的初始化工作，例如初始化硬件设备、注册中断处理程序、设置内存映射等。而 arch_initcall_sync 函数则用于调用与当前架构相关的初始化函数。</p>
<p>当内核启动时，调用 rest_init() 函数来启动初始化过程。在初始化过程中，arch_initcall_sync 函数会被调用，以确保所有与当前架构相关的初始化函数按照正确的顺序执行。这样可以保证在启动过程中，特定架构相关的初始化工作得到正确地完成。</p>
<p>而of_platform_default_populate_init函数的作用是在内核初始化过程中自动解析设备树，并根据设备树中的设备节点创建对应的 platform_device 结构。它会遍历设备树中的设备节点，并为每个设备节点创建一个对应的 platform_device 结构，然后将其注册到内核中，使得设备驱动程序能够识别和操作这些设备。该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">of_platform_default_populate_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂停设备链接供应商同步状态</span></span><br><span class="line">    device_links_supplier_sync_state_pause();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设备树尚未填充，则返回错误码</span></span><br><span class="line">    <span class="keyword">if</span> (!of_have_populated_dt())</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 显式处理某些兼容性，因为我们不想为/reserved-memory中的每个具有“compatible”的节点创建platform_device。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    for_each_matching_node(node, reserved_mem_matches)</span><br><span class="line">        of_platform_device_create(node, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找节点 &quot;/firmware&quot;</span></span><br><span class="line">    node = of_find_node_by_path(<span class="string">&quot;/firmware&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="comment">// 使用该节点进行设备树平台设备的填充</span></span><br><span class="line">        of_platform_populate(node, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        of_node_put(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充其他设备</span></span><br><span class="line">    fw_devlink_pause();</span><br><span class="line">    of_platform_default_populate(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    fw_devlink_resume();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第6行：暂停设备链接供应商的同步状态，确保设备链接的状态不会在此过程中被改变。</p>
<p>第9行：检查设备树是否已经被填充。如果设备树尚未填充，则返回错误码 -ENODEV。</p>
<p>第16行：遍历设备树中与 reserved_mem_matches 匹配的节点。这些节点是 &#x2F;reserved-memory 中具有 “compatible” 属性的节点。</p>
<p>第17行：为 &#x2F;reserved-memory 中匹配的节点创建 platform_device 结构。这些节点不会为每个节点都创建 platform_device，而是根据需要进行显式处理。</p>
<p>第20行：在设备树中查找路径为 “&#x2F;firmware” 的节点。</p>
<p>第23行：使用找到的节点填充设备树中的平台设备。这些节点可能包含与固件相关的设备。</p>
<p>第28行：暂停固件设备链接，确保在填充其他设备时链接状态不会改变。</p>
<p>第29行：填充设备树中的其他设备。</p>
<p>第30行：恢复固件设备链接。</p>
<p>上诉内容中我们要着重关注的是第29行的of_platform_default_populate(NULL, NULL, NULL)函数，找到该函数的定义之后如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int of_platform_default_populate(struct device_node *root,</span><br><span class="line">				 const struct of_dev_auxdata *lookup,</span><br><span class="line">				 struct device *parent)</span><br><span class="line">&#123;</span><br><span class="line">	return of_platform_populate(root, of_default_bus_match_table, lookup,</span><br><span class="line">				    parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的作用是调用 of_platform_populate 函数来填充设备树中的平台设备，并使用默认的设备匹配表 of_default_bus_match_table，设备匹配表内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_default_bus_match_table</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;simple-bus&quot;</span>, &#125;,</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;simple-mfd&quot;</span>, &#125;,</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;isa&quot;</span>, &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM_AMBA</span></span><br><span class="line">	&#123; .compatible = <span class="string">&quot;arm,amba-bus&quot;</span>, &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_ARM_AMBA */</span></span></span><br><span class="line">	&#123;&#125; <span class="comment">/* Empty terminated list */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述的设备匹配表就是我们在第一小节中第2条规则，，函数将自动根据设备树节点的属性匹配相应的设备驱动程序，并填充内核的平台设备列表。接下来找到of_platform_populate函数的定义，该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_platform_populate</span><span class="params">(<span class="keyword">struct</span> device_node *root,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> of_device_id *matches,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> of_dev_auxdata *lookup,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> device *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span></span><br><span class="line">	<span class="type">int</span> rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 root 不为空，则增加 root 节点的引用计数；否则，在设备树中根据路径查找 root 节点</span></span><br><span class="line">	root = root ? of_node_get(root) : of_find_node_by_path(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!root)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;%s()\n&quot;</span>, __func__);</span><br><span class="line">	pr_debug(<span class="string">&quot; starting at: %pOF\n&quot;</span>, root);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 暂停设备链接供应商同步状态</span></span><br><span class="line">	device_links_supplier_sync_state_pause();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历 root 节点的所有子节点</span></span><br><span class="line">	for_each_child_of_node(root, child) &#123;</span><br><span class="line">		<span class="comment">// 创建平台设备并添加到设备树总线</span></span><br><span class="line">		rc = of_platform_bus_create(child, matches, lookup, parent, <span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">if</span> (rc) &#123;</span><br><span class="line">			of_node_put(child);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 恢复设备链接供应商同步状态</span></span><br><span class="line">	device_links_supplier_sync_state_resume();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置 root 节点的 OF_POPULATED_BUS 标志</span></span><br><span class="line">	of_node_set_flag(root, OF_POPULATED_BUS);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放 root 节点的引用计数</span></span><br><span class="line">	of_node_put(root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的具体执行步骤如下：</p>
<p>第10行：检查给定的设备树节点 node 是否为有效节点。如果节点为空，函数将立即返回。</p>
<p>第21行：遍历设备树节点的子节点，查找与平台设备相关的节点。这些节点通常具有 compatible 属性，用于匹配设备驱动程序。</p>
<p>第23行：对于每个找到的平台设备节点，创建一个 platform_device 结构，并根据设备树节点的属性设置该结构的各个字段。</p>
<p>第25行：将创建的 platform_device 添加到内核的平台设备列表中，以便设备驱动程序能够识别和操作这些设备。</p>
<p>接下来对该函数的第23行核心代码of_platform_bus_create(child, matches, lookup, parent, true)函数进行讲解，该函数的具体定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int of_platform_bus_create(struct device_node *bus,</span><br><span class="line">				  const struct of_device_id *matches,</span><br><span class="line">				  const struct of_dev_auxdata *lookup,</span><br><span class="line">				  struct device *parent, bool strict)</span><br><span class="line">&#123;</span><br><span class="line">	const struct of_dev_auxdata *auxdata;</span><br><span class="line">	struct device_node *child;</span><br><span class="line">	struct platform_device *dev;</span><br><span class="line">	const char *bus_id = NULL;</span><br><span class="line">	void *platform_data = NULL;</span><br><span class="line">	int rc = 0;</span><br><span class="line"></span><br><span class="line">	/* 确保设备节点具有 compatible 属性 */</span><br><span class="line">	if (strict &amp;&amp; (!of_get_property(bus, &quot;compatible&quot;, NULL))) &#123;</span><br><span class="line">		pr_debug(&quot;%s() - skipping %pOF, no compatible prop\n&quot;,</span><br><span class="line">			 __func__, bus);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 跳过不想创建设备的节点 */</span><br><span class="line">	if (unlikely(of_match_node(of_skipped_node_table, bus))) &#123;</span><br><span class="line">		pr_debug(&quot;%s() - skipping %pOF node\n&quot;, __func__, bus);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	if (of_node_check_flag(bus, OF_POPULATED_BUS)) &#123;</span><br><span class="line">		pr_debug(&quot;%s() - skipping %pOF, already populated\n&quot;,</span><br><span class="line">			__func__, bus);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	auxdata = of_dev_lookup(lookup, bus);</span><br><span class="line">	if (auxdata) &#123;</span><br><span class="line">		bus_id = auxdata-&gt;name;</span><br><span class="line">		platform_data = auxdata-&gt;platform_data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (of_device_is_compatible(bus, &quot;arm,primecell&quot;)) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * 在此处不返回错误以保持与旧设备树文件的兼容性。</span><br><span class="line">		 */</span><br><span class="line">		of_amba_device_create(bus, bus_id, platform_data, parent);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent);</span><br><span class="line">	if (!dev || !of_match_node(matches, bus))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	for_each_child_of_node(bus, child) &#123;</span><br><span class="line">		pr_debug(&quot;   create child: %pOF\n&quot;, child);</span><br><span class="line">		rc = of_platform_bus_create(child, matches, lookup, &amp;dev-&gt;dev, strict);</span><br><span class="line">		if (rc) &#123;</span><br><span class="line">			of_node_put(child);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	of_node_set_flag(bus, OF_POPULATED_BUS);</span><br><span class="line">	return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第14行：如果 strict 为真且设备节点 bus 没有兼容性属性，则输出调试信息并返回 0。这个条件判断确保设备节点具有 compatible 属性，因为 compatible 属性用于匹配设备驱动程序，对应我们在上一小节的第1条规则。</p>
<p>第21行：如果设备节点 bus 在被跳过的节点表中，则输出调试信息并返回 0。这个条件判断用于跳过不想创建设备的节点。</p>
<p>第27行：如果设备节点 bus 的 OF_POPULATED_BUS 标志已经设置，则输出调试信息并返回 0。这个条件判断用于避免重复创建已经填充的设备节点。</p>
<p>第34行：使用 lookup 辅助数据结构查找设备节点 bus 的特定配置信息，并将其赋值给变量 bus_id 和 platform_data。这个步骤用于获取设备节点的特定配置信息，以便在创建平台设备时使用，由于这里传入的参数为NULL，所以下面的条件判断并不会被执行。</p>
<p>第39行：如果设备节点 bus 兼容于 “arm,primecell”，则调用 of_amba_device_create 函数创建 AMBA 设备，并返回 0，对应我们在上一小节学习的第3条规则。</p>
<p>第47行：调用 of_platform_device_create_pdata函数创建平台设备，并将其赋值给变量 dev。然后，检查设备节点 bus是否与给定的匹配表 <code>matches</code> 匹配。如果平台设备创建失败或者设备节点不匹配，那么返回 0。</p>
<p>第51行-第58行：遍历设备节点 bus 的每个子节点 child，并递归调用 of_platform_bus_create 函数来创建子节点的平台设备。</p>
<p>接下来对该函数的第47行 of_platform_device_create_pdata函数进行讲解，该函数的具体定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> platform_device *<span class="title function_">of_platform_device_create_pdata</span><span class="params">(</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">					<span class="type">const</span> <span class="type">char</span> *bus_id,</span></span><br><span class="line"><span class="params">					<span class="type">void</span> *platform_data,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> device *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查设备节点是否可用或已填充 */</span></span><br><span class="line">	<span class="keyword">if</span> (!of_device_is_available(np) ||</span><br><span class="line">	    of_node_test_and_set_flag(np, OF_POPULATED))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 分配平台设备结构体 */</span></span><br><span class="line">	dev = of_device_alloc(np, bus_id, parent);</span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">goto</span> err_clear_flag;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置平台设备的一些属性 */</span></span><br><span class="line">	dev-&gt;dev.coherent_dma_mask = DMA_BIT_MASK(<span class="number">32</span>);</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;dev.dma_mask)</span><br><span class="line">		dev-&gt;dev.dma_mask = &amp;dev-&gt;dev.coherent_dma_mask;</span><br><span class="line">	dev-&gt;dev.bus = &amp;platform_bus_type;</span><br><span class="line">	dev-&gt;dev.platform_data = platform_data;</span><br><span class="line">	of_msi_configure(&amp;dev-&gt;dev, dev-&gt;dev.of_node);</span><br><span class="line">	of_reserved_mem_device_init_by_idx(&amp;dev-&gt;dev, dev-&gt;dev.of_node, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将平台设备添加到设备模型中 */</span></span><br><span class="line">	<span class="keyword">if</span> (of_device_add(dev) != <span class="number">0</span>) &#123;</span><br><span class="line">		platform_device_put(dev);</span><br><span class="line">		<span class="keyword">goto</span> err_clear_flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev;</span><br><span class="line"></span><br><span class="line">err_clear_flag:</span><br><span class="line">	<span class="comment">/* 清除设备节点的已填充标志 */</span></span><br><span class="line">	of_node_clear_flag(np, OF_POPULATED);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>第10行：函数会检查设备节点的可用性，即检查设备树对应节点的status属性。如果设备节点不可用或已经被填充，则直接返回 NULL。</p>
<p>第15行：函数调用 of_device_alloc 分配一个平台设备结构体，并将设备节点指针、设备标识符和父设备指针传递给它。如果分配失败，则跳转到 err_clear_flag 标签处进行错误处理。</p>
<p>第19行，函数设置平台设备的一些属性。它将 coherent_dma_mask 属性设置为 32 位的 DMA 位掩码，并检查 dma_mask 属性是否为 NULL。如果 dma_mask 为 NULL，则将其指向 coherent_dma_mask。然后，函数设置平台设备的总线类型为 platform_bus_type，并将平台数据指针存储在 platform_data 属性中。接着，函数调用 of_msi_configure 和 of_reserved_mem_device_init_by_idx 来配置设备的 MSI 和保留内存信息。</p>
<p>第29行：函数调用 of_device_add 将平台设备添加到设备模型中。如果添加失败，则释放已分配的平台设备，并跳转到 err_clear_flag 标签处进行错误处理。</p>
<p>至此，关于device_node转换成platform_device的具体流程就分析完成了，函数调用流程图如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps149.jpg" alt="img"> </p>
<h1 id="第65章-设备树下platform-device和platform-driver匹配实验"><a href="#第65章-设备树下platform-device和platform-driver匹配实验" class="headerlink" title="第65章 设备树下platform_device和platform_driver匹配实验"></a>第65章 设备树下platform_device和platform_driver匹配实验</h1><p>在上一章节中我们学习了从device_node到platform_device的转换流程，转换完成之后操作系统才能够识别和管理设备，从而与platform_driver进行匹配，在本章将将会对设备树下platform_device和platform_driver的匹配进行讲解。</p>
<h2 id="65-1-of-match-table"><a href="#65-1-of-match-table" class="headerlink" title="65.1 of_match_table"></a>65.1 of_match_table</h2><p>在前面平台总线相关章节的学习中，了解到只有platform_device结构体中的name 属性与platform_driver结构体中嵌套的driver结构体name属性或者id_table相同才能加载probe初始化函数。</p>
<p>而为了使设备树能够与驱动程序进行匹配，需要在platform_driver驱动程序中添加driver结构体的of_match_table 属性。这个属性是一个指向 const struct of_device_id 结构的指针，用于描述设备树节点和驱动程序之间的匹配规则。of_device_id 结构体定义在内核源码的“&#x2F;include&#x2F;linux&#x2F;mod_devicetable.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>	name[<span class="number">32</span>];</span><br><span class="line">	<span class="type">char</span>	type[<span class="number">32</span>];</span><br><span class="line">	<span class="type">char</span>	compatible[<span class="number">128</span>];</span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct of_device_id 结构体通常作为一个数组在驱动程序中定义，用于描述设备树节点和驱动程序之间的匹配规则。数组的最后一个元素必须是一个空的结构体，以标记数组的结束。</p>
<p>以下是一个示例，展示了如何在驱动程序中使用 struct of_device_id 进行设备树匹配：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">my_driver_match</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;vendor,device-1&quot;</span> &#125;,</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;vendor,device-2&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，my_driver_match 是一个 struct of_device_id 结构体数组。每个数组元素都包含了一个 compatible 字段，用于指定设备树节点的兼容性字符串。驱动程序将根据这些兼容性字符串与设备树中的节点进行匹配。</p>
<h2 id="65-2-实验程序编写"><a href="#65-2-实验程序编写" class="headerlink" title="65.2 实验程序编写"></a>65.2 实验程序编写</h2><p>本实验修改完成的dts文件和编译完成的boot.img镜像对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\54_devicetree_probe\dts。</p>
<p>本次实验的要求为使用设备树描述下面的内存资源：<br><em><strong>*内存资源：*</strong></em></p>
<p>起始地址：0xFDD60000</p>
<p>结束地址：0xFDD60004</p>
<p>标记：IORESOURCE_MEM</p>
<p>随后编写对应的platform_driver驱动程序，要求跟上述内存资源所创建的节点进行匹配，验证 of_match_table 属性。</p>
<h3 id="65-2-1-设备树的编写"><a href="#65-2-1-设备树的编写" class="headerlink" title="65.2.1 设备树的编写"></a>65.2.1 设备树的编写</h3><p>首先来对rk3568的设备树结构进行以下介绍，根据sdk源码目录下的“device&#x2F;rockchip&#x2F;rk356x&#x2F;BoardConfig-rk3568-evb1-ddr4-v10.mk”默认配置文件可以了解到编译的设备树为rk3568-evb1-ddr4-v10-linux.dts,根据设备树之间的包含关系列出了下面的表格。</p>
<table>
<thead>
<tr>
<th>顶层设备树</th>
<th>rk3568-evb1-ddr4-v10-linux.dts</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>第二级设备树</td>
<td>rk3568-evb1-ddr4-v10.dtsi</td>
<td>rk3568-linux.dtsi</td>
</tr>
<tr>
<td>第三级设备树</td>
<td>rk3568.dtsirk3568-evb.dtsi                                                                                                     topeet_screen_choose.dtsitopeet_rk3568_lcds.dtsi</td>
<td></td>
</tr>
</tbody></table>
<p>rk3568-evb1-ddr4-v10-linux.dts是顶层设备树，为了便于理解我们之后在该设备树下进行节点的添加（当然这里也可以修改其他设备树），进入该设备树文件之后如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps150.jpg" alt="img"> </p>
<p>然后将根据需求编写的设备树节点添加到rk3568-evb1-ddr4-v10-linux.dts中，要添加的内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">    topeet&#123;</span><br><span class="line">        #address-cells = &lt;1&gt;;</span><br><span class="line">        #size-cells = &lt;1&gt;;</span><br><span class="line">        compatible = &quot;simple-bus&quot;;</span><br><span class="line"></span><br><span class="line">        myLed&#123;</span><br><span class="line">            compatible = &quot;my devicetree&quot;;</span><br><span class="line">            reg = &lt;0xFDD60000 0x00000004&gt;;</span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;;       </span><br></pre></td></tr></table></figure>

<p>为了避免#address-cells &#x3D; <l>; 和 #size-cells &#x3D; &lt;1&gt;;这两个属性改变根节点其他的节点的属性，所以在这里创建了一个topeet节点。在这个示例中，#address-cells 设置为 1表示地址使用一个 32 位的单元，#size-cells 也设置为 1 表示大小使用一个 32 位的单元。</p>
<p>第5行：将compatible属性设置为”simple-bus”用于表示 topeet 节点的兼容性，指明它是一个简单总线设备，在转换platform_device的过程中，会继续查找该节点的子节点。</p>
<p>第8行：myLed 节点下的compatible属性为”my devicetree”，表明该节点将会被转换为platform_device。</p>
<p>第9行：这个属性用于描述 myLed 节点的寄存器信息。reg 属性的值 &lt;0xFDD60000 0x00000004&gt; 表示 myLed 设备的寄存器起始地址为 0xFDD60000，大小为 0x00000004。</p>
<p>添加完成如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps151.jpg" alt="img"> </p>
<p>保存退出之后，重新编译内核源码，编译完成之后将生成的boot.img烧写到开发板即可。</p>
<h3 id="66-2-2-驱动程序的编写"><a href="#66-2-2-驱动程序的编写" class="headerlink" title="66.2.2 驱动程序的编写"></a>66.2.2 驱动程序的编写</h3><p>本实验驱动对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\54_devicetree_probe\module。</p>
<p>本小节驱动程序是由“第52章 注册platform驱动实验”程序修改而来，相较于源程序只是添加了of_match_table相关代码，用来与设备树节点进行匹配。</p>
<p>编写完成的platform_driver.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mod_devicetable.h&gt;</span></span></span><br><span class="line"><span class="comment">// 平台设备的初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_probe: Probing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Removing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table_id</span>[]  =</span> &#123;</span><br><span class="line">	&#123;.compatible=<span class="string">&quot;my devicetree&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">		.of_match_table =  of_match_table_id,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="65-3-运行测试"><a href="#65-3-运行测试" class="headerlink" title="65.3 运行测试"></a>65.3 运行测试</h2><h3 id="65-3-1-编译驱动程序"><a href="#65-3-1-编译驱动程序" class="headerlink" title="65.3.1 编译驱动程序"></a>65.3.1 编译驱动程序</h3><p>在上一小节中的platform_driver.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m += platform_driver.o    #此处要和你的驱动源文件同名</span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    <span class="meta">#make操作</span></span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    <span class="meta">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_driver.c和Makefile文件目录下，如下图（图65-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps152.jpg" alt="img"> </p>
<p>图 65-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图65-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps153.jpg" alt="img"> </p>
<p>图 65-2</p>
<p>编译完生成platform_driver.ko目标文件，如下图（图65-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps154.jpg" alt="img"> </p>
<p>图 65-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="65-3-2-运行测试"><a href="#65-3-2-运行测试" class="headerlink" title="65.3.2 运行测试"></a>65.3.2 运行测试</h3><p>在进行实验之前，首先要确保开发板烧写的是我们在65.2.1小节中编译出来的boot.img。开发板启动之后，首先进入到“&#x2F;proc&#x2F;device-tree”目录下，查看是否已经存在了topeet目录，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps155.jpg" alt="img"> </p>
<p>只有在设备树节点编写正确的前提下，这里才会生成topeet目录，如果没有出现topeet目录就要回头检查看看了。</p>
<p>然后使用以下命令进行驱动模块的加载，如下图（图65-4）所示：</p>
<p>insmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps156.jpg" alt="img"> </p>
<p>图 65-4</p>
<p>可以看到成功打印了在probe函数中的打印，证明我们添加的设备树节点和platform_driver驱动匹配成功了。</p>
<p>然后使用以下命令进行驱动模块的卸载，如下图（图65-5）所示：</p>
<p>rmmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps157.jpg" alt="img"> </p>
<p>图 65-5</p>
<p>至此，设备树下platform_device和platform_driver匹配实验就完成了。</p>
<h1 id="第66章-of操作函数实验：获取设备树节点"><a href="#第66章-of操作函数实验：获取设备树节点" class="headerlink" title="第66章 of操作函数实验：获取设备树节点"></a><strong>第66章</strong> of操作函数实验：获取设备树节点</h1><p>在上一章节的学习中，我们学习了设备树下platform_device和platform_driver匹配，现在也只是让他们匹配在了一起，但这样显然是不够的，为了完成一些和硬件相关的需求，我们还需要获取到在设备树中编写的一些属性，那设备树中的属性要如何获取呢，让我们一起进入后续章节的学习吧。</p>
<h2 id="66-1-of操作：获取设备树节点"><a href="#66-1-of操作：获取设备树节点" class="headerlink" title="66.1 of操作：获取设备树节点"></a>66.1 of操作：获取设备树节点</h2><p>在Linux内核源码中提供了一系列的of操作函数来帮助我们获取到设备树中编写的属性，</p>
<p>在内核中以device_node结构体来对设备树进行描述，所以of操作函数实际上就是获取device_node结构体，所以接下来我们学习的of操作函数的返回值都是device_node结构体，关于device_node结构体的具体内容已经在63.1小节讲解过了，这里不再进行赘述。</p>
<h3 id="66-1-1-of-find-node-by-name"><a href="#66-1-1-of-find-node-by-name" class="headerlink" title="66.1.1 of_find_node_by_name"></a>66.1.1 of_find_node_by_name</h3><p>of_find_node_by_name 是Linux内核中用于通过节点名称查找设备树节点的函数。下面是对of_find_node_by_name 函数的详细介绍：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>struct device_node *of_find_node_by_name(struct device_node *from, const char *name);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;of.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em><br>    该函数通过指定的节点名称在设备树中进行查找，返回匹配的节点的 struct device_node 指针。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>from：指定起始节点，表示从哪个节点开始查找。如果 from 参数为 NULL，则从设备树的根节点开始查找。</p>
<p>name：要查找的节点名称。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>如果未找到匹配的节点，则返回 NULL。</p>
<p>会在接下来的实验小节中，对该函数进行实际演示。</p>
<h3 id="66-1-2-of-find-node-by-path"><a href="#66-1-2-of-find-node-by-path" class="headerlink" title="66.1.2 of_find_node_by_path"></a>66.1.2 of_find_node_by_path</h3><p>of_find_node_by_path 是Linux内核中用于通过节点路径查找设备树节点的函数。下面是对of_find_node_by_path函数的详细介绍：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>struct device_node *of_find_node_by_path(const char *path);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;of.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em><br>    该函数根据节点路径在设备树中进行查找，返回匹配的节点的 struct device_node 指针。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>path：节点的路径，以斜杠分隔的字符串表示。路径格式为设备树节点的绝对路径，例如 &#x2F;topeet&#x2F;myLed。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>如果未找到匹配的节点，则返回 NULL。</p>
<p>of_find_node_by_path 函数通过节点路径在设备树中进行查找。路径是设备树节点从根节点到目标节点的完整路径。可以通过指定正确的路径来准确地访问设备树中的特定节点。</p>
<p>使用 of_find_node_by_path 函数时，可以直接传递节点的完整路径作为 path 参数，函数会在设备树中查找匹配的节点。这对于已知节点路径的情况非常有用。</p>
<h3 id="66-1-3-of-get-parent"><a href="#66-1-3-of-get-parent" class="headerlink" title="66.1.3 of_get_parent"></a>66.1.3 of_get_parent</h3><p>在Linux内核中，of_get_parent 函数用于获取设备树节点的父节点。下面是对of_get_parent函数的详细介绍：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>struct device_node *of_get_parent(const struct device_node *node);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;of.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em><br>    该函数接收一个指向设备树节点的指针 node，并返回该节点的父节点的指针。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>node：要获取父节点的设备树节点指针。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>如果未找到匹配的节点，则返回 NULL。</p>
<p>使用 of_get_parent 函数时，可以将特定的设备树节点作为参数传递给函数，然后它将返回该节点的父节点。这对于在设备树中导航和访问节点之间的层次关系非常有用。</p>
<p>父节点在设备树中表示了节点之间的层次结构关系。通过获取父节点，你可以访问上一级节点的属性和配置信息，从而更好地理解设备树中的节点之间的关系。</p>
<h3 id="66-1-4-of-get-next-child"><a href="#66-1-4-of-get-next-child" class="headerlink" title="66.1.4 of_get_next_child"></a>66.1.4 of_get_next_child</h3><p>在Linux内核中，of_get_next_child 函数用于获取设备树节点的下一个子节点。下面是对of_get_next_child 函数的详细介绍：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>struct device_node *of_get_next_child(const struct device_node *node, struct device_node *prev);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;of.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em><br>    该函数接收两个参数：node 是当前节点，prev 是上一个子节点。它返回下一个子节点的指针。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>node：当前节点，用于指定要获取子节点的起始节点。</p>
<p>prev：上一个子节点，用于指定从哪个子节点开始获取下一个子节点。如果为 NULL，则从起始节点的第一个子节点开始。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>如果未找到匹配的节点，则返回 NULL。</p>
<p>使用 of_get_next_child 函数时，可以传递当前节点以及上一个子节点作为参数。函数将从上一个子节点的下一个节点开始，查找并返回下一个子节点。</p>
<p>设备树中的子节点表示了节点之间的层次关系。通过获取子节点，你可以遍历和访问当前节点的所有子节点，以便进一步处理它们的属性和配置信息。</p>
<h3 id="64-1-5-of-find-compatible-node函数"><a href="#64-1-5-of-find-compatible-node函数" class="headerlink" title="64.1.5 of_ find_ compatible_ node函数"></a>64.1.5 of_ find_ compatible_ node函数</h3><p>当设备树中存在多个设备节点，需要根据设备的兼容性字符串进行匹配时，可以使用 of_find_compatible_node 函数。该函数用于在设备树中查找与指定兼容性字符串匹配的节点。</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>struct device_node *of_find_compatible_node(struct device_node *from, const char *type, const char *compatible);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;of.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em><br>    在设备树中查找与指定兼容性字符串匹配的节点。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>from：指定起始节点，表示从哪个节点开始查找。如果 from 参数为 NULL，则从设备树的根节点开始查找。</p>
<p>type：要匹配的设备类型字符串，通常是 compatible 属性中的一部分。</p>
<p>compatible：要匹配的兼容性字符串，通常是设备树节点的 compatible 属性中的值。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>如果未找到匹配的节点，则返回 NULL。</p>
<p>使用 of_find_compatible_node 函数时，可以指定起始节点和需要匹配的设备类型字符串以及兼容性字符串。函数会从起始节点开始遍历设备树，查找与指定兼容性字符串匹配的节点，并返回匹配节点的指针。</p>
<h3 id="64-1-6-of-find-matching-node-and-match函数"><a href="#64-1-6-of-find-matching-node-and-match函数" class="headerlink" title="64.1.6 of_ find matching node_ and_ match函数"></a>64.1.6 of_ find matching node_ and_ match函数</h3><p>在Linux内核中，of_ find matching node_ and_ match函数用于根据给定的of_device_id匹配表在设备树中查找匹配的节点。</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>struct device_node *of_find_matching_node_and_match(struct device_node *from,const struct of_device_id *matches, const struct of_device_id **match);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;of.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em><br>    根据给定的of_device_id匹配表在设备树中查找匹配的节点。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>from：表示从哪个节点开始搜索。通常将上一次调用该函数返回的节点作为参数传递给from，以便从上一次的下一个节点开始搜索。如果要从设备树的根节点开始搜索，可以将from参数设置为NULL。</p>
<p>matches：指向一个of_device_id类型的匹配表，该表包含要搜索的匹配项。</p>
<p>match：用于输出匹配到的of_device_id条目的指针。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>如果未找到匹配的节点，则返回 NULL。</p>
<p>of_find_matching_node_and_match函数在设备树中遍历节点，对每个节点使用__of_match_node函数进行匹配。如果找到匹配的节点，将返回该节点的指针，并将match指针更新为匹配到的of_device_id条目，函数会自动增加匹配节点的引用计数。以下是使用of_find_matching_node_and_match函数的示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">my_match_table</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;vendor,device&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">match</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从根节点开始查找匹配的节点</span></span><br><span class="line">np = of_find_matching_node_and_match(<span class="literal">NULL</span>, my_match_table, &amp;match);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个of_device_id匹配表my_match_table，其中包含了一个兼容性字符串为”vendor,device”的匹配项。然后，我们使用of_find_matching_node_and_match函数从根节点开始查找匹配的节点。</p>
<h2 id="66-2-实验程序编写"><a href="#66-2-实验程序编写" class="headerlink" title="66.2 实验程序编写"></a>66.2 实验程序编写</h2><p>本实验驱动对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\55_of_01。</p>
<p>本小节驱动程序是由上一章程序修改而来，相较于源程序只是在probe函数中添加了本章节学习的of操作相关代码，用来获取设备树节点。</p>
<p>编写完成的platform_driver.c代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/platform_device.h&gt;</span><br><span class="line">#include &lt;linux/mod_devicetable.h&gt;</span><br><span class="line">#include &lt;linux/of.h&gt;</span><br><span class="line"></span><br><span class="line">struct device_node *mydevice_node;      </span><br><span class="line">const struct of_device_id *mynode_match;</span><br><span class="line">struct of_device_id mynode_of_match[] = &#123;</span><br><span class="line">	&#123;.compatible=&quot;my devicetree&quot;&#125;,</span><br><span class="line">	&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 平台设备的初始化函数</span><br><span class="line">static int my_platform_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO &quot;my_platform_probe: Probing platform device\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 通过节点名称查找设备树节点</span><br><span class="line">    mydevice_node = of_find_node_by_name(NULL, &quot;myLed&quot;);</span><br><span class="line">	printk(&quot;mydevice node is %s\n&quot;, mydevice_node-&gt;name);</span><br><span class="line">    </span><br><span class="line">	// 通过节点路径查找设备树节点</span><br><span class="line">    mydevice_node = of_find_node_by_path(&quot;/topeet/myLed&quot;);</span><br><span class="line">    printk(&quot;mydevice node is %s\n&quot;, mydevice_node-&gt;name);</span><br><span class="line">        </span><br><span class="line">    // 获取父节点</span><br><span class="line">    mydevice_node = of_get_parent(mydevice_node);</span><br><span class="line">    printk(&quot;myled&#x27;s parent node is %s\n&quot;, mydevice_node-&gt;name);</span><br><span class="line">            </span><br><span class="line">    // 获取子节点</span><br><span class="line">    mydevice_node = of_get_next_child(mydevice_node, NULL);</span><br><span class="line">    printk(&quot;myled&#x27;s sibling node is %s\n&quot;, mydevice_node-&gt;name);</span><br><span class="line"></span><br><span class="line">	// 使用compatible值查找节点</span><br><span class="line">	mydevice_node=of_find_compatible_node(NULL ,NULL, &quot;my devicetree&quot;);</span><br><span class="line">	printk(&quot;mydevice node is %s\n&quot; , mydevice_node-&gt;name);</span><br><span class="line">	</span><br><span class="line">	//根据给定的of_device_id匹配表在设备树中查找匹配的节点</span><br><span class="line">	mydevice_node=of_find_matching_node_and_match(NULL , mynode_of_match, &amp;mynode_match);</span><br><span class="line">	printk(&quot;mydevice node is %s\n&quot; ,mydevice_node-&gt;name);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 平台设备的移除函数</span><br><span class="line">static int my_platform_remove(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO &quot;my_platform_remove: Removing platform device\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 清理设备特定的操作</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const struct of_device_id of_match_table_id[]  = &#123;</span><br><span class="line">	&#123;.compatible=&quot;my devicetree&quot;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义平台驱动结构体</span><br><span class="line">static struct platform_driver my_platform_driver = &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = &quot;my_platform_device&quot;,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">		.of_match_table =  of_match_table_id,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 模块初始化函数</span><br><span class="line">static int __init my_platform_driver_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    // 注册平台驱动</span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;Failed to register platform driver\n&quot;);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO &quot;my_platform_driver: Platform driver initialized\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 模块退出函数</span><br><span class="line">static void __exit my_platform_driver_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 注销平台驱动</span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line">    printk(KERN_INFO &quot;my_platform_driver: Platform driver exited\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;topeet&quot;);</span><br></pre></td></tr></table></figure>



<h2 id="66-3-运行测试"><a href="#66-3-运行测试" class="headerlink" title="66.3 运行测试"></a>66.3 运行测试</h2><h3 id="66-3-1-编译驱动程序"><a href="#66-3-1-编译驱动程序" class="headerlink" title="66.3.1 编译驱动程序"></a>66.3.1 编译驱动程序</h3><p>在上一小节中的platform_driver.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m += platform_driver.o    #此处要和你的驱动源文件同名</span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    <span class="meta">#make操作</span></span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    <span class="meta">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_driver.c和Makefile文件目录下，如下图（图66-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps158.jpg" alt="img"> </p>
<p>图 66-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图66-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps159.jpg" alt="img"> </p>
<p>图 66-2</p>
<p>编译完生成platform_driver.ko目标文件，如下图（图66-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps160.jpg" alt="img"> </p>
<p>图 66-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="66-3-2-运行测试"><a href="#66-3-2-运行测试" class="headerlink" title="66.3.2 运行测试"></a>66.3.2 运行测试</h3><p>在进行实验之前，首先要确保开发板烧写的是我们在65.2.1小节中编译出来的boot.img，开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图66-4）所示：</p>
<p>insmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps161.jpg" alt="img"> </p>
<p>图 66-4</p>
<p>可以看到总共有4个打印，前两个打印都是查找的myLed节点，第三个打印是查找的myLed的父节点，也就是topeet节点，第四个打印是查找的topeet的子节点，也就又回到了myLed节点。第5个打印是通过compatible属性查找到的myLed节点，第6个打印是通过of_device_id匹配表查找到的myLed节点.</p>
<p>然后使用以下命令进行驱动模块的卸载，如下图（图66-5）所示：</p>
<p>rmmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps162.jpg" alt="img"> </p>
<p>图 66-5</p>
<p>至此，使用of操作函数获取设备树节点实验就完成了。</p>
<h1 id="第67章-of操作函数实验：获取属性"><a href="#第67章-of操作函数实验：获取属性" class="headerlink" title="第67章 of操作函数实验：获取属性"></a>第67章 of操作函数实验：获取属性</h1><h2 id="67-1-of操作：获取属性"><a href="#67-1-of操作：获取属性" class="headerlink" title="67.1 of操作：获取属性"></a>67.1 of操作：获取属性</h2><h3 id="67-1-1-of-find-property"><a href="#67-1-1-of-find-property" class="headerlink" title="67.1.1 of_find_property"></a>67.1.1 of_find_property</h3><p>of_find_property函数用于在设备树中查找节点 下具有指定名称的属性。如果找到了该属性，可以通过返回的属性结构体指针进行进一步的操作，比如获取属性值、属性长度等。</p>
<p>函数原型: <code>struct property *of_find_property(const struct device_node *np, const char *name, int *lenp)</code></p>
<p>头文件：</p>
<p>​		#include &lt;linux&#x2F;of.h&gt;</p>
<p>函数作用: 该函数用于在节点 <code>np</code> 下查找指定名称 <code>name</code> 的属性。</p>
<p>函数参数和返回值:</p>
<ul>
<li><code>np</code>: 要查找的节点。</li>
<li><code>name</code>: 要查找的属性的属性名。</li>
<li><code>lenp</code>: 一个指向整数的指针，用于接收属性值的字节数。</li>
</ul>
<p>返回值: 如果成功找到了指定名称的属性，则返回对应的属性结构体指针 <code>struct property *</code>；如果未找到，则返回 <code>NULL</code>。</p>
<h3 id="67-1-2-of-property-count-elems-of-size"><a href="#67-1-2-of-property-count-elems-of-size" class="headerlink" title="67.1.2 of_property_count_elems_of_size"></a>67.1.2 of_property_count_elems_of_size</h3><p>该函数在设备树中的设备节点下查找指定名称的属性，并获取该属性中元素的数量。调用该函数可以用于获取设备树属性中某个属性的元素数量，比如一个字符串列表的元素数量或一个整数数组的元素数量等。	</p>
<p>函数原型: <code>int of_property_count_elems_of_size(const struct device_node *np, const char *propname, int elem_size)</code></p>
<p>头文件：</p>
<p>​		#include &lt;linux&#x2F;of.h&gt;</p>
<p>函数作用: 该函数用于获取属性中指定元素的数量。</p>
<p>函数参数和返回值:</p>
<ul>
<li><code>np</code>: 设备节点。</li>
<li><code>propname</code>: 需要获取元素数量的属性名。</li>
<li><code>elem_size</code>: 单个元素的尺寸。</li>
</ul>
<p>返回值: 如果成功获取了指定属性中元素的数量，则返回该数量；如果未找到属性或属性中没有元素，则返回 0。</p>
<h3 id="67-1-3-of-property-read-u32-index"><a href="#67-1-3-of-property-read-u32-index" class="headerlink" title="67.1.3 of_property_read_u32_index"></a>67.1.3 of_property_read_u32_index</h3><p>该函数在设备树中的设备节点下查找指定名称的属性，并获取该属性在给定索引位置处的 u32 类型的数据值。</p>
<p>这个函数通常用于从设备树属性中读取特定索引位置的整数值。通过指定属性名和索引，可以获取属性中指定位置的具体数值。</p>
<p>函数原型: <code>int of_property_read_u32_index(const struct device_node *np, const char *propname, u32 index, u32 *out_value)</code></p>
<p>头文件：</p>
<p>​		#include &lt;linux&#x2F;of.h&gt;</p>
<p>函数作用: 该函数用于从指定属性中获取指定索引位置的 u32 类型的数据值。</p>
<p>函数参数和返回值:</p>
<ul>
<li><code>np</code>: 设备节点。</li>
<li><code>propname</code>: 要读取的属性名。</li>
<li><code>index</code>: 要读取的属性值在属性中的索引，索引从 0 开始。</li>
<li><code>out_value</code>: 用于存储读取到的值的指针。</li>
</ul>
<p>返回值: 如果成功读取到了指定属性指定索引位置的 u32 类型的数据值，则返回 0；如果未找到属性或读取失败，则返回相应的错误码。</p>
<h3 id="67-1-4-of-property-read-u64-index"><a href="#67-1-4-of-property-read-u64-index" class="headerlink" title="67.1.4 of_property_read_u64_index"></a>67.1.4 of_property_read_u64_index</h3><p>该函数在设备树中的设备节点下查找指定名称的属性，并获取该属性在给定索引位置处的 u64 类型的数据值。</p>
<p>这个函数通常用于从设备树属性中读取特定索引位置的 64 位整数值。通过指定属性名和索引，可以获取属性中指定位置的具体数值。</p>
<p>函数原型: </p>
<p><code>static inline int of_property_read_u64_index(const struct device_node *np, const char *propname, u32 index, u64 *out_value)</code></p>
<p>头文件：</p>
<p>​		#include &lt;linux&#x2F;of.h&gt;</p>
<p>函数作用: 该函数用于从指定属性中获取指定索引位置的 u64 类型的数据值。</p>
<p>函数参数和返回值:</p>
<ul>
<li><code>np</code>: 设备节点。</li>
<li><code>propname</code>: 要读取的属性名。</li>
<li><code>index</code>: 要读取的属性值在属性中的索引，索引从 0 开始。</li>
<li><code>out_value</code>: 用于存储读取到的值的指针。</li>
</ul>
<p>返回值: 如果成功读取到了指定属性指定索引位置的 u64 类型的数据值，则返回 0；如果未找到属性或读取失败，则返回相应的错误码。</p>
<h3 id="67-1-5-of-property-read-variable-u32-array"><a href="#67-1-5-of-property-read-variable-u32-array" class="headerlink" title="67.1.5 of_property_read_variable_u32_array"></a>67.1.5 of_property_read_variable_u32_array</h3><p>该函数用于从设备树中读取指定属性名的变长数组。通过提供设备节点、属性名和输出数组的指针，可以将设备树中的数组数据读取到指定的内存区域中。同时，还需要指定数组的最小大小和最大大小，以确保读取到的数组符合预期的大小范围。</p>
<p>函数原型：</p>
<p> <code>int of_property_read_variable_u32_array(const struct device_node *np, const char *propname, u32 *out_values, size_t SZ_min, size_t SZ_max)</code></p>
<p>函数作用: </p>
<p>​	从指定属性中读取变长的 u32 数组。</p>
<p>函数参数和返回值:</p>
<ul>
<li><code>np</code>: 设备节点。</li>
<li><code>propname</code>: 要读取的属性名。</li>
<li><code>out_values</code>: 用于存储读取到的 u8 数组的指针。</li>
<li><code>SZ_min</code>: 数组的最小大小。</li>
<li><code>SZ_max</code>: 数组的最大大小。</li>
</ul>
<p>返回值：</p>
<p>​	 如果成功读取到了指定属性的 u8 数组，则返回数组的大小。如果未找到属性或读取失败，则返回相应的错误码。</p>
<p>​	上面介绍的函数用于从指定属性中读取变长的 u32 数组，下面是另外三个读取其他数组大小的函数：</p>
<p>这里给出了四个函数，用于从设备树中读取数组类型的属性值：</p>
<p>从指定属性中读取变长的 u8 数组：</p>
<p>int of_property_read_variable_u8_array(const struct device_node *np, const char *propname, u8 *out_values, size_t SZ_min, size_t SZ_max)</p>
<p>从指定属性中读取变长的 u16 数组：</p>
<p>int of_property_read_variable_u16_array(const struct device_node *np, const char *propname, u16 *out_values, size_t SZ_min, size_t SZ_max)</p>
<p>从指定属性中读取变长的 u64 数组：</p>
<p> int of_property_read_variable_u64_array(const struct device_node *np, const char *propname, u64 *out_values, size_t SZ_min, size_t SZ_max)</p>
<h3 id="67-1-6-of-property-read-string"><a href="#67-1-6-of-property-read-string" class="headerlink" title="67.1.6 of_property_read_string"></a>67.1.6 of_property_read_string</h3><p>该函数在设备树中的设备节点下查找指定名称的属性，并获取该属性的字符串值，最后返回读取到的字符串的指针，通常用于从设备树属性中读取字符串值。通过指定属性名，可以获取属性中的字符串数据。</p>
<p>函数原型: </p>
<p>static inline int of_property_read_string(const struct device_node *np, const char *propname, const char **out_string)</p>
<p>头文件：</p>
<p>​		#include &lt;linux&#x2F;of.h&gt;</p>
<p>函数作用: 该函数用于从指定属性中读取字符串。</p>
<p>函数参数和返回值:</p>
<ul>
<li><code>np</code>: 设备节点。</li>
<li><code>propname</code>: 要读取的属性名。</li>
<li><code>out_string</code>: 用于存储读取到的字符串的指针。</li>
</ul>
<p>返回值: 如果成功读取到了指定属性的字符串，则返回 0；如果未找到属性或读取失败，则返回相应的错误码。</p>
<h2 id="67-2-实验程序编写"><a href="#67-2-实验程序编写" class="headerlink" title="67.2 实验程序编写"></a>67.2 实验程序编写</h2><p>本实验驱动对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\55_of_02。</p>
<p>本小节驱动程序是由65章驱动程序修改而来，由于本章节获取设备树属性的函数需要在查找到设备树节点的前提下使用，所以在下面的程序中，先在probe函数中添加查获取设备树节点，然后添加了本章节学习的of操作相关代码，用来获取设备树节点相关属性。</p>
<p>编写完成的platform_driver.c代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="67-3-运行测试"><a href="#67-3-运行测试" class="headerlink" title="67.3 运行测试"></a>67.3 运行测试</h2><h3 id="67-3-1-编译驱动程序"><a href="#67-3-1-编译驱动程序" class="headerlink" title="67.3.1 编译驱动程序"></a>67.3.1 编译驱动程序</h3><p>在上一小节中的platform_driver.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_driver.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_driver.c和Makefile文件目录下，如下图（图66-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps171.jpg" alt="img"></p>
<p>图 67-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图66-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/image-20230904181227189.png" alt="image-20230904181227189"></p>
<p>图 67-2</p>
<p>编译完生成platform_driver.ko目标文件，如下图（图66-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps160.jpg" alt="img"> </p>
<p>图 67-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="67-3-2-运行测试"><a href="#67-3-2-运行测试" class="headerlink" title="67.3.2 运行测试"></a>67.3.2 运行测试</h3><p>在进行实验之前，首先要确保开发板烧写的是我们在65.2.1小节中编译出来的boot.img，开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图66-4）所示：</p>
<p>insmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps161.jpg" alt="img"> </p>
<p>图 67-4</p>
<p>可以看到总共有4个打印，前两个打印都是查找的myLed节点，第三个打印是查找的myLed的父节点，也就是topeet节点，第四个打印是查找的topeet的子节点，也就又回到了myLed节点。第5个打印是通过compatible属性查找到的myLed节点，第6个打印是通过of_device_id匹配表查找到的myLed节点.</p>
<p>然后使用以下命令进行驱动模块的卸载，如下图（图66-5）所示：</p>
<p>rmmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps162.jpg" alt="img"> </p>
<p>图 67-5</p>
<p>至此，使用of操作函数获取设备树节点实验就完成了。</p>
<h1 id="第68章-ranges属性实验"><a href="#第68章-ranges属性实验" class="headerlink" title="第68章 ranges属性实验"></a>第68章 ranges属性实验</h1><h1 id="第69章-of操作函数实验：获取中断资源"><a href="#第69章-of操作函数实验：获取中断资源" class="headerlink" title="第69章 of操作函数实验：获取中断资源"></a>第69章 of操作函数实验：获取中断资源</h1><h1 id="第70章-参考文档：设备树bindings"><a href="#第70章-参考文档：设备树bindings" class="headerlink" title="第70章 参考文档：设备树bindings"></a>第70章 参考文档：设备树bindings</h1><h1 id="第71章-讨论：为什么学不会设备树"><a href="#第71章-讨论：为什么学不会设备树" class="headerlink" title="第71章 讨论：为什么学不会设备树"></a>第71章 讨论：为什么学不会设备树</h1>]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>设备树</tag>
      </tags>
  </entry>
  <entry>
    <title>rk3568 驱动开发第六篇 平台总线</title>
    <url>/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E5%85%AD%E7%AF%87-%E5%B9%B3%E5%8F%B0%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第50章-平台总线模型介绍"><a href="#第50章-平台总线模型介绍" class="headerlink" title="第50章 平台总线模型介绍"></a>第50章 平台总线模型介绍</h1><p>在前面所有章节中，无论要完成何种需求，我们都编写了一个独立的驱动程序，但这样编写出来的驱动程序在重用性和可移植性上是很低的，无论之后要编写一个同类型的驱动还是将该驱动更换一个平台，都要花费时间重新修改驱动代码，而驱动的分离和分层这一软件思路的提出（即本章节要讲解的平台总线模型），就是为了解决这个问题，下面让我们一起进入平台总线模型的学习吧。</p>
<h2 id="50-1-什么是平台总线？"><a href="#50-1-什么是平台总线？" class="headerlink" title="50.1 什么是平台总线？"></a>50.1 什么是平台总线？</h2><p>平台总线（Platform bus）是Linux内核中提供的一种虚拟总线，用于管理和组织与特定硬件平台相关的设备和驱动。它充当了平台设备（platform device）和平台驱动（platform driver）之间的桥梁，负责将它们进行匹配和绑定。</p>
<p>当系统注册一个平台设备时，平台总线会寻找与之匹配的平台驱动。它会遍历已注册的平台驱动列表，尝试与每个平台驱动进行匹配，直到找到与平台设备匹配的驱动为止。一旦找到匹配的驱动，平台总线会将平台设备与平台驱动进行绑定，使得设备可以被正确地初始化和操作。</p>
<p>同样地，当系统注册一个平台驱动时，平台总线会寻找与之匹配的平台设备。它会遍历已注册的平台设备列表，尝试与每个平台设备进行匹配，直到找到与平台驱动匹配的设备为止。一旦找到匹配的设备，平台总线会将平台设备与平台驱动进行绑定，使得驱动可以管理和控制与该设备相关的操作。</p>
<p>设备、平台总线、驱动的关系如下图（图 50-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps1.jpg" alt="img"> </p>
<p>图 50-1</p>
<p>通过引入平台总线，Linux内核提供了一种通用的机制来管理和组织与特定硬件平台相关的设备和驱动。它使得设备和驱动之间的匹配过程更加自动化和灵活，同时也提高了嵌入式系统的可移植性和可扩展性。</p>
<h2 id="50-2-平台总线的优势"><a href="#50-2-平台总线的优势" class="headerlink" title="50.2 平台总线的优势"></a>50.2 平台总线的优势</h2><p>在前面的章节中，我们编写的驱动程序将驱动和设备相关的内容放在一起，但是当涉及到多个相同类型的设备时，这种方法会引发一系列问题。举个例子，假设我们有一个硬件平台，该硬件平台上存在了500个模块，这些模块都使用了LED灯。如果我们使用杂项设备来编写驱动，虽然相比字符设备，杂项设备的代码量较少，但我们仍旧需要编写500份类似的代码，从而生成相应的设备节点，以供上层应用在不同模块上控制LED灯。</p>
<p>编写500份重复的代码会带来两个问题。首先，会造成大量重复劳动。其次，代码的重用性较差。如果我们需要将这些驱动从一个平台移植到另一个平台，就需要逐个修改驱动代码，尽管只需修改与硬件相关的部分，但仍旧是一个很大的工作量</p>
<p>而在引入了平台总线模型后，这些问题就得到了很好地解决。通过使用平台总线模型，将设备驱动和平台设备进行了分离。这样一来，我们只需编写一份通用的驱动代码即可，然后针对不同的平台设备进行配置，这就大大减少了重复编写代码的工作量，并提高了驱动代码的重用性。当我们需要将驱动移植到不同的平台时，只需对硬件相关的部分进行适配即可，其他部分可以保持不变。</p>
<p>整理出来的平台总线优势如下所示：</p>
<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em>****设备与驱动的分离：****传统的设备驱动模型将设备和驱动代码合并在同一个文件中，导致代码冗余和可维护性差。而平台总线模型将设备代码和驱动代码分离，设备代码放在device.c文件中，驱动代码放在driver.c文件中。这种分离使得设备和驱动的职责更加清晰，提高了代码的可读性和可维护性。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em>****提高代码的重用性：****平台总线模型使得相同类型的设备可以共享相同的驱动代码。例如，在一个硬件平台上存在多个相同类型的设备，传统的驱动模型需要为每个设备编写独立的驱动代码。而使用平台总线模型，只需编写一个通用的驱动代码，然后为每个设备创建相应的device.c文件，将设备特定的代码放在其中。这样可以减少代码的重复性，提高了代码的重用性和可维护性。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em>****减少重复性代码：****在传统的设备驱动模型中，如果有多个相同类型的设备存在，就需要为每个设备编写独立的驱动代码。而使用平台总线模型，只需编写一个通用的驱动代码，然后为每个设备创建相应的device.c文件，将设备特定的代码放在其中。这样可以避免大量的重复性代码，简化了驱动开发过程。</p>
<p><em><strong>*（*</strong></em><em><strong>*4*</strong></em><em><strong>*）*</strong></em>****提高可移植性：****平台总线模型可以提高驱动的可移植性。开发者可以编写适应平台总线的平台驱动程序，从而支持特定的外设，而无需依赖于特定的标准总线。这使得驱动可以更容易地在不同的硬件平台之间进行移植和重用。</p>
<h1 id="第51章-注册platform设备实验"><a href="#第51章-注册platform设备实验" class="headerlink" title="第51章 注册platform设备实验"></a>第51章 注册platform设备实验</h1><h2 id="51-1-注册platform设备"><a href="#51-1-注册platform设备" class="headerlink" title="51.1 注册platform设备"></a>51.1 注册platform设备</h2><h3 id="51-1-1-platform-device-register-函数"><a href="#51-1-1-platform-device-register-函数" class="headerlink" title="51.1.1 platform_device_register 函数"></a>51.1.1 platform_device_register 函数</h3><p>platform_device_register函数用于将platform_device结构体描述的平台设备注册到内核中。下面是对platform_device_register函数的详细介绍：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int platform_device_register(struct platform_device *pdev);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;platform_device.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em><br>    platform_device_register函数用于将platform_device结构体描述的平台设备注册到内核中，使其能够参与设备的资源分配和驱动的匹配。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>pdev：指向platform_device结构体的指针，描述要注册的平台设备的信息。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>成功：返回0，表示设备注册成功。</p>
<p>失败：返回负数，表示设备注册失败，返回的负数值表示错误代码。</p>
<p>pdev参数是一个指向platform_device结构体的指针，其中包含了描述平台设备的各种属性和信息。platform_device结构体包含了设备名称、设备资源、设备ID等信息，用于描述和标识平台设备，会在接下来的小节对该结构体进行详细的介绍。</p>
<p>该函数在内核源码目录下的“&#x2F;include&#x2F;linux&#x2F;platform_device.h”文件中，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern int platform_device_register(struct platform_device *);</span><br></pre></td></tr></table></figure>

<p>函数声明中的extern关键字表示该函数在其他地方定义，而不是在当前文件中实现。这样的声明通常出现在头文件中，用于告诉编译器该函数的定义存在于其他源文件中，以便在编译时能够正确引用该函数。</p>
<p>而platform_device_register实际定义在“&#x2F;drivers&#x2F;base&#x2F;platform.c”文件中，相关定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int platform_device_register(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">	device_initialize(&amp;pdev-&gt;dev);</span><br><span class="line">	arch_setup_pdev_archdata(pdev);</span><br><span class="line">	return platform_device_add(pdev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数内部有三个主要的操作。</p>
<p>第3行：调用了device_initialize函数，用于对pdev-&gt;dev进行初始化。pdev-&gt;dev是struct platform_device结构体中的一个成员，它表示平台设备对应的struct device结构体。通过调用device_initialize函数，对pdev-&gt;dev进行一些基本的初始化工作，例如设置设备的引用计数、设备的类型等。</p>
<p>第4行：调用了arch_setup_pdev_archdata函数，用于根据平台设备的架构数据来设置pdev的架构相关数据。这个函数的具体实现可能与具体的架构相关，它主要用于在不同的架构下对平台设备进行特定的设置。</p>
<p>第5行：调用了platform_device_add函数，将平台设备pdev添加到内核中。platform_device_add函数会完成平台设备的添加操作，包括将设备添加到设备层级结构中、添加设备的资源等。它会返回一个int类型的结果，表示设备添加的结果。</p>
<p>platform_device_register函数的主要作用是将platform_device结构体描述的平台设备注册到内核中，包括设备的初始化、添加到platform总线和设备层级结构、添加设备资源等操作。通过该函数，平台设备被注册后，就能够参与设备的资源分配和驱动的匹配过程。函数的返回值可以用于判断设备注册是否成功。</p>
<h3 id="51-1-2-platform-device-unregister-函数"><a href="#51-1-2-platform-device-unregister-函数" class="headerlink" title="51.1.2 platform_device_unregister 函数"></a>51.1.2 platform_device_unregister 函数</h3><p>platform_device_unregister函数用于取消注册已经注册的平台设备，即从内核中移除设备。在设备不再需要时，调用该函数可以进行设备的清理和释放操作。</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>void platform_device_unregister(struct platform_device *pdev);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;platform_device.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em><br>    platform_device_unregister函数用于取消注册已经注册的平台设备，从内核中移除设备。</p>
<p>参数含义：</p>
<p>pdev：指向要取消注册的平台设备的platform_device结构体指针。</p>
<p>返回值：<br>无返回值。</p>
<p>该函数在内核源码目录下的“&#x2F;include&#x2F;linux&#x2F;platform_device.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">platform_device_unregister</span><span class="params">(<span class="keyword">struct</span> platform_device *)</span>;</span><br></pre></td></tr></table></figure>

<p>函数声明中的extern关键字表示该函数在其他地方定义，而不是在当前文件中实现。这样的声明通常出现在头文件中，用于告诉编译器该函数的定义存在于其他源文件中，以便在编译时能够正确引用该函数。</p>
<p>而platform_device_unregister实际定义在“&#x2F;drivers&#x2F;base&#x2F;platform.c”文件中，相关定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">platform_device_unregister</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	platform_device_del(pdev);</span><br><span class="line">	platform_device_put(pdev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数内部有两个主要的操作：</p>
<p>第3行：调用了platform_device_del函数，用于将设备从platform总线的设备列表中移除。它会将设备从设备层级结构中移除，停止设备的资源分配和驱动的匹配。</p>
<p>第4行：这一步调用了platform_device_put函数，用于减少对设备的引用计数。这个函数会检查设备的引用计数，如果引用计数减为零，则会释放设备结构体和相关资源。通过减少引用计数，可以确保设备在不再被使用时能够被释放。</p>
<p>platform_device_unregister函数的作用是取消注册已经注册的平台设备，从内核中移除设备。它先调用platform_device_del函数将设备从设备层级结构中移除，然后调用platform_device_put函数减少设备的引用计数，确保设备在不再被使用时能够被释放。</p>
<h3 id="51-1-3-platform-device结构体"><a href="#51-1-3-platform-device结构体" class="headerlink" title="51.1.3 platform_device结构体"></a>51.1.3 platform_device结构体</h3><p>platform_device结构体是用于描述平台设备的数据结构。它包含了平台设备的各种属性和信息，用于在内核中表示和管理平台设备。该结构体定义在内核的“&#x2F;include&#x2F;linux&#x2F;platform_device.h”文件中，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct platform_device &#123;</span><br><span class="line">	const char *name;  // 设备的名称，用于唯一标识设备</span><br><span class="line">	int	id;        // 设备的ID，可以用于区分同一种设备的不同实例</span><br><span class="line">	bool	 id_auto;  // 表示设备的ID是否自动生成</span><br><span class="line">	struct device dev;  // 表示平台设备对应的 struct device 结构体，用于设备的基本管理和操作</span><br><span class="line">	u32	num_resources;   // 设备资源的数量</span><br><span class="line">	struct resource	*resource;   // 指向设备资源的指针</span><br><span class="line"></span><br><span class="line">	const struct platform_device_id *id_entry; // 指向设备的ID表项的指针，用于匹配设备和驱动</span><br><span class="line">	char *driver_override; // 强制设备与指定驱动匹配的驱动名称</span><br><span class="line"></span><br><span class="line">	/* MFD cell pointer */</span><br><span class="line">	struct mfd_cell *mfd_cell;   // 指向多功能设备（MFD）单元的指针，用于多功能设备的描述</span><br><span class="line"></span><br><span class="line">	/* arch specific additions */</span><br><span class="line">	struct pdev_archdata	archdata;    // 用于存储特定于架构的设备数据</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面对于几个重要的参数和结构体进行讲解</p>
<p>const char *name：设备的名称，用于唯一标识设备。必须提供一个唯一的名称，以便内核能够正确识别和管理该设备。</p>
<p>int id：设备的ID，可以用于区分同一种设备的不同实例。这个参数是可选的，如果不需要使用ID进行区分，可以将其设置为-1，</p>
<p>struct device dev：表示平台设备对应的struct device结构体，用于设备的基本管理和操作。必须为该参数提供一个有效的struct device对象，该结构体的release方法必须要实现，否则在编译的时候会报错。</p>
<p>u32 num_resources：设备资源的数量。如果设备具有资源（如内存区域、中断等），则需要提供资源的数量。</p>
<p>struct resource *resource：指向设备资源的指针。如果设备具有资源，需要提供一个指向资源数组的指针，会在下个小节对该结构体进行详细的讲解。</p>
<h3 id="51-1-4-resource结构体"><a href="#51-1-4-resource结构体" class="headerlink" title="51.1.4 resource结构体"></a>51.1.4 resource结构体</h3><p>struct resource结构体用于描述系统中的设备资源，包括内存区域、I&#x2F;O 端口、中断等，该结构体定义在内核的“&#x2F;include&#x2F;linux&#x2F;ioport.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line">    <span class="type">resource_size_t</span> start;          <span class="comment">/* 资源的起始地址 */</span></span><br><span class="line">    <span class="type">resource_size_t</span> end;            <span class="comment">/* 资源的结束地址 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;               <span class="comment">/* 资源的名称 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;            <span class="comment">/* 资源的标志位 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> desc;             <span class="comment">/* 资源的描述信息 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>;</span>        <span class="comment">/* 指向父资源的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">sibling</span>;</span>       <span class="comment">/* 指向同级兄弟资源的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">child</span>;</span>         <span class="comment">/* 指向子资源的指针 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以下宏定义用于保留未使用的字段 */</span></span><br><span class="line">    ANDROID_KABI_RESERVE(<span class="number">1</span>);</span><br><span class="line">    ANDROID_KABI_RESERVE(<span class="number">2</span>);</span><br><span class="line">    ANDROID_KABI_RESERVE(<span class="number">3</span>);</span><br><span class="line">    ANDROID_KABI_RESERVE(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中最重要的是前四个参数，每个参数的具体介绍如下所示：</p>
<p>（1）resource_size_t start：资源的起始地址。它表示资源的起始位置或者起始寄存器的地址。</p>
<p>（2）resource_size_t end：资源的结束地址。它表示资源的结束位置或者结束寄存器的地址。</p>
<p>（3）const char *name：资源的名称。它是一个字符串，用于标识和描述资源。</p>
<p>（4）unsigned long flags：资源的标志位。它包含了一些特定的标志，用于表示资源的属性或者特征。例如，可以用标志位来指示资源的可用性、共享性、缓存属性等。flags参数的具体取值和含义可以根据系统和驱动的需求进行定义和解释，但通常情况下，它用于表示资源的属性、特征或配置选项。下面是一些常见的标志位及其可能的含义：</p>
<p><em><strong>*1. 资源类型相关标志位：*</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IORESOURCE_IO：表示资源是I/O端口资源。</span><br><span class="line">IORESOURCE_MEM：表示资源是内存资源。</span><br><span class="line">IORESOURCE_REG：表示资源是寄存器偏移量。</span><br><span class="line">IORESOURCE_IRQ：表示资源是中断资源。</span><br><span class="line">IORESOURCE_DMA：表示资源是DMA（直接内存访问）资源。</span><br></pre></td></tr></table></figure>

<p><em><strong>*2. 资源属性和特征相关标志位：*</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IORESOURCE_PREFETCH：表示资源是无副作用的预取资源。</span><br><span class="line">IORESOURCE_READONLY：表示资源是只读的。</span><br><span class="line">IORESOURCE_CACHEABLE：表示资源支持缓存。</span><br><span class="line">IORESOURCE_RANGELENGTH：表示资源的范围长度。</span><br><span class="line">IORESOURCE_SHADOWABLE：表示资源可以被影子资源替代。</span><br><span class="line">IORESOURCE_SIZEALIGN：表示资源的大小表示对齐。</span><br><span class="line">IORESOURCE_STARTALIGN：表示起始字段是对齐的。</span><br><span class="line">IORESOURCE_MEM_64：表示资源是64位内存资源。</span><br><span class="line">IORESOURCE_WINDOW：表示资源由桥接器转发。</span><br><span class="line">IORESOURCE_MUXED：表示资源是软件复用的。</span><br><span class="line">IORESOURCE_SYSRAM：表示资源是系统RAM（修饰符）。</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> <em><strong>*其他状态和控制标志位：*</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IORESOURCE_EXCLUSIVE：表示用户空间无法映射此资源。</span><br><span class="line">IORESOURCE_DISABLED：表示资源当前被禁用。</span><br><span class="line">IORESOURCE_UNSET：表示尚未分配地址给资源。</span><br><span class="line">IORESOURCE_AUTO：表示地址由系统自动分配。</span><br><span class="line">IORESOURCE_BUSY：表示驱动程序将此资源标记为繁忙。</span><br></pre></td></tr></table></figure>

<h2 id="51-2-实验程序的编写"><a href="#51-2-实验程序的编写" class="headerlink" title="51.2 实验程序的编写"></a>51.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\40_platform_device\。</p>
<p>本实验将注册一个名为 “my_platform_device” 的平台设备，当注册平台设备时，该驱动程序提供了两个资源：一个内存资源和一个中断资源。这些资源被定义在名为 my_resources 的结构体数组中,具体内容如下：</p>
<p><em><strong>*内存资源：*</strong></em></p>
<p>起始地址：MEM_START_ADDR（0xFDD60000）</p>
<p>结束地址：MEM_END_ADDR（0xFDD60004）</p>
<p>标记：IORESOURCE_MEM</p>
<p><em><strong>*中断资源：*</strong></em></p>
<p>中断资源号：IRQ_NUMBER（101）</p>
<p>标记：IORESOURCE_IRQ</p>
<p>编写完成的platform_device.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_START_ADDR 0xFDD60000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_END_ADDR   0xFDD60004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_NUMBER     101</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">my_resources</span>[] =</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .start = MEM_START_ADDR,    <span class="comment">// 内存资源起始地址</span></span><br><span class="line">        .end = MEM_END_ADDR,        <span class="comment">// 内存资源结束地址</span></span><br><span class="line">        .flags = IORESOURCE_MEM,    <span class="comment">// 标记为内存资源</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .start = IRQ_NUMBER,        <span class="comment">// 中断资源号</span></span><br><span class="line">        .end = IRQ_NUMBER,          <span class="comment">// 中断资源号</span></span><br><span class="line">        .flags = IORESOURCE_IRQ,    <span class="comment">// 标记为中断资源</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_platform_device_release</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 释放资源的回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">my_platform_device</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_platform_device&quot;</span>,                  <span class="comment">// 设备名称</span></span><br><span class="line">    .id = <span class="number">-1</span>,                                      <span class="comment">// 设备ID</span></span><br><span class="line">    .num_resources = ARRAY_SIZE(my_resources),     <span class="comment">// 资源数量</span></span><br><span class="line">    .resource = my_resources,                      <span class="comment">// 资源数组</span></span><br><span class="line">    .dev.release = my_platform_device_release,     <span class="comment">// 释放资源的回调函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_device_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = platform_device_register(&amp;my_platform_device);   <span class="comment">// 注册平台设备</span></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Platform device registered\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_device_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_device_unregister(&amp;my_platform_device);   <span class="comment">// 注销平台设备</span></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Platform device unregistered\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_device_init);</span><br><span class="line">module_exit(my_platform_device_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="51-3-运行测试"><a href="#51-3-运行测试" class="headerlink" title="51.3 运行测试"></a>51.3 运行测试</h2><h3 id="51-3-1-编译驱动程序"><a href="#51-3-1-编译驱动程序" class="headerlink" title="51.3.1 编译驱动程序"></a>51.3.1 编译驱动程序</h3><p>在上一小节中的platform_device.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_device.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_device.c和Makefile文件目录下，如下图（图51-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps2.jpg" alt="img"> </p>
<p>图 51-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图51-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps3.jpg" alt="img"> </p>
<p>图 51-2</p>
<p>编译完生成platform_device.ko目标文件，如下图（图51-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps4.jpg" alt="img"> </p>
<p>图 51-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="51-3-2-运行测试"><a href="#51-3-2-运行测试" class="headerlink" title="51.3.2 运行测试"></a>51.3.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图51-4）所示：</p>
<p>insmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps5.jpg" alt="img"> </p>
<p>图 51-4</p>
<p>然后来到&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;devices目录下，可以看到我们创建的my_platform_device设备文件夹就成功生成了。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps6.jpg" alt="img"> </p>
<p>图 51-5</p>
<p>然后使用以下命令进行驱动模块的卸载，如下图（图51-6）所示：</p>
<p>rmmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps7.jpg" alt="img"> </p>
<p>图 51-6</p>
<p>至此，注册platform设备实验就完成了。</p>
<h1 id="第52章-注册platform驱动实验"><a href="#第52章-注册platform驱动实验" class="headerlink" title="第52章 注册platform驱动实验"></a>第52章 注册platform驱动实验</h1><p>在上个章节我们学习了如何注册platform设备，而本章节就要学习如何注册platform驱动了。</p>
<h2 id="52-1注册platform驱动"><a href="#52-1注册platform驱动" class="headerlink" title="52.1注册platform驱动"></a>52.1注册platform驱动</h2><h3 id="52-1-1-platform-driver-register-函数"><a href="#52-1-1-platform-driver-register-函数" class="headerlink" title="52.1.1 platform_driver_register 函数"></a>52.1.1 platform_driver_register 函数</h3><p>platform_driver_register 函数用于在 Linux 内核中注册一个平台驱动程序。下面是对该函数的详细介绍：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int platform_driver_register(struct platform_driver *driver);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;platform_device.h&gt;</p>
<p><em><strong>*函数作用*</strong></em><em><strong>*：*</strong></em></p>
<p>platform_driver_register 函数用于将一个平台驱动程序注册到内核中。通过注册平台驱动程序，内核可以识别并与特定的平台设备进行匹配，并在需要时调用相应的回调函数。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>driver：指向 struct platform_driver 结构体的指针，描述了要注册的平台驱动程序的属性和回调函数（会在下面的小节对该结构体进行详细的讲解）。</p>
<p>****返回值****：</p>
<p>返回一个整数值，表示函数的执行状态。如果注册成功，返回 0；如果注册失败，返回一个负数错误码。</p>
<p>该函数在内核源码目录下的“&#x2F;include&#x2F;linux&#x2F;platform_device.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> platform_driver_register(drv) \</span></span><br><span class="line"><span class="meta">	__platform_driver_register(drv, THIS_MODULE)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __platform_driver_register(<span class="keyword">struct</span> platform_driver *,					<span class="keyword">struct</span> module *);</span><br></pre></td></tr></table></figure>

<p>这个宏用于简化平台驱动程序的注册过程。它将实际的注册函数 __platform_driver_register 与当前模块（驱动程序）关联起来。宏的参数 drv 是一个指向 struct platform_driver 结构体的指针，描述了要注册的平台驱动程序的属性和回调函数。THIS_MODULE 是一个宏，用于获取当前模块的指针。</p>
<p>而__platform_driver_register实际定义在“&#x2F;drivers&#x2F;base&#x2F;platform.c”文件中，相关定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __platform_driver_register(<span class="keyword">struct</span> platform_driver *drv, <span class="keyword">struct</span> module *owner)</span><br><span class="line">&#123;</span><br><span class="line">    drv-&gt;driver.owner = owner;                   <span class="comment">// 将平台驱动程序的所有权设置为当前模块</span></span><br><span class="line">    drv-&gt;driver.bus = &amp;platform_bus_type;    <span class="comment">// 将平台驱动程序的总线类型设置为平台总线</span></span><br><span class="line">    drv-&gt;driver.probe = platform_drv_probe;      <span class="comment">// 设置平台驱动程序的探测函数</span></span><br><span class="line">    drv-&gt;driver.remove = platform_drv_remove;    <span class="comment">// 设置平台驱动程序的移除函数</span></span><br><span class="line">    drv-&gt;driver.shutdown = platform_drv_shutdown;<span class="comment">// 设置平台驱动程序的关机函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> driver_register(&amp;drv-&gt;driver);        <span class="comment">// 将平台驱动程序注册到内核</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第3行：将指向当前模块的指针 owner 赋值给平台驱动程序的 owner 成员。这样做是为了将当前模块与平台驱动程序关联起来，以确保模块的生命周期和驱动程序的注册和注销相关联。</p>
<p>第4行：将指向平台总线类型的指针 &amp;platform_bus_type 赋值给平台驱动程序的 bus 成员。这样做是为了指定该驱动程序所属的总线类型为平台总线，以便内核能够将平台设备与正确的驱动程序进行匹配。</p>
<p>第5行：将指向平台驱动程序探测函数 platform_drv_probe 的指针赋值给平台驱动程序的 probe 成员。这样做是为了指定当内核发现与驱动程序匹配的平台设备时，要调用的驱动程序探测函数。</p>
<p>第6行：将指向平台驱动程序移除函数 platform_drv_remove 的指针赋值给平台驱动程序的 remove 成员。这样做是为了指定当内核需要从系统中移除与驱动程序匹配的平台设备时，要调用的驱动程序移除函数。</p>
<p>第7行 &#x3D; platform_drv_shutdown;：将指向平台驱动程序关机函数 platform_drv_shutdown 的指针赋值给平台驱动程序的 shutdown 成员。这样做是为了指定当系统关机时，要调用的驱动程序关机函数。</p>
<p>第9行：调用 driver_register 函数，将平台驱动程序的 driver 成员注册到内核中。该函数负责将驱动程序注册到相应的总线上，并在注册成功时返回 0，注册失败时返回一个负数错误码。</p>
<p>通过这些操作，__platform_driver_register 函数将平台驱动程序与内核关联起来，并确保内核能够正确识别和调用驱动程序的各种回调函数，以实现与平台设备的交互和管理。函数的返回值表示注册过程的执行状态，以便在需要时进行错误处理。</p>
<h3 id="52-1-2-platform-device-unregister-函数"><a href="#52-1-2-platform-device-unregister-函数" class="headerlink" title="52.1.2 platform_device_unregister 函数"></a>52.1.2 platform_device_unregister 函数</h3><p>platform_device_unregister函数用于取消注册已经注册的平台设备，即从内核中移除设备。在设备不再需要时，调用该函数可以进行设备的清理和释放操作。</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>void platform_device_unregister(struct platform_device *pdev);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;platform_device.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em><br>    platform_device_unregister 函数用于从内核中注销平台设备。通过调用该函数，可以将指定的平台设备从系统中移除。</p>
<p>****参数含义****：</p>
<p>pdev：指向要注销的平台设备的指针。</p>
<p><em><strong>*返回值：*</strong></em><br>    无返回值。</p>
<p>该函数在内核源码目录下的“&#x2F;include&#x2F;linux&#x2F;platform_device.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">platform_driver_unregister</span><span class="params">(<span class="keyword">struct</span> platform_driver *)</span>;</span><br></pre></td></tr></table></figure>

<p>函数声明中的extern关键字表示该函数在其他地方定义，而不是在当前文件中实现。这样的声明通常出现在头文件中，用于告诉编译器该函数的定义存在于其他源文件中，以便在编译时能够正确引用该函数。</p>
<p>而platform_driver_unregister实际定义在“&#x2F;drivers&#x2F;base&#x2F;platform.c”文件中，相关定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">platform_driver_unregister</span><span class="params">(<span class="keyword">struct</span> platform_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">	driver_unregister(&amp;drv-&gt;driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数又调用了driver_unregister函数进行嵌套，追踪之后找到定义在“&#x2F;drivers&#x2F;base&#x2F;driver.c”目录下的driver_unregister函数，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">driver_unregister</span><span class="params">(<span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查传入的设备驱动程序指针和 p 成员是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (!drv || !drv-&gt;p) &#123;</span><br><span class="line">        WARN(<span class="number">1</span>, <span class="string">&quot;Unexpected driver unregister!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    driver_remove_groups(drv, drv-&gt;groups); <span class="comment">// 移除与设备驱动程序关联的属性组</span></span><br><span class="line">    bus_remove_driver(drv);    <span class="comment">// 从总线中移除设备驱动程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数内部有三个主要的操作：</p>
<p>第4-7行：检查传入的设备驱动程序指针 drv 是否为空，或者驱动程序的 p 成员是否为空。如果其中任何一个条件为真，表示传入的参数无效，会发出警告并返回。</p>
<p>第9行：调用 driver_remove_groups 函数，用于从内核中移除与设备驱动程序关联的属性组。drv-&gt;groups 是指向属性组的指针，指定了要移除的属性组列表。</p>
<p>第10行：调用 bus_remove_driver 函数，用于从总线中移除设备驱动程序。该函数会执行以下操作：</p>
<p>（1）从总线驱动程序列表中移除指定的设备驱动程序。</p>
<p>（2）调用与设备驱动程序关联的 remove 回调函数（如果有定义）。</p>
<p>（3）释放设备驱动程序所占用的资源和内存。</p>
<p>（4）最终销毁设备驱动程序的数据结构。</p>
<p>通过调用 driver_unregister 函数，可以正确地注销设备驱动程序，并在注销过程中进行必要的清理工作。这样可以避免资源泄漏和其他问题。在调用该函数后，应避免继续使用已注销的设备驱动程序指针，因为该驱动程序已不再存在于内核中。</p>
<h3 id="52-1-3-platform-driver结构体"><a href="#52-1-3-platform-driver结构体" class="headerlink" title="52.1.3 platform_driver结构体"></a>52.1.3 platform_driver结构体</h3><p>platform_driver 结构体是Linux内核中用于编写平台设备驱动程序的重要数据结构。它提供了与平台设备驱动相关的函数和数据成员，以便与平台设备进行交互和管理。该结构体定义在内核的“&#x2F;include&#x2F;linux&#x2F;platform_device.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*probe)(<span class="keyword">struct</span> platform_device *); <span class="comment">/* 平台设备的探测函数指针 */</span></span><br><span class="line">	<span class="type">int</span> (*remove)(<span class="keyword">struct</span> platform_device *); <span class="comment">/* 平台设备的移除函数指针 */</span></span><br><span class="line">	<span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> platform_device *);<span class="comment">/* 平台设备的关闭函数指针 */</span></span><br><span class="line">	<span class="type">int</span> (*suspend)(<span class="keyword">struct</span> platform_device *, <span class="type">pm_message_t</span> state);<span class="comment">/* 平台设备的挂起函数指针 */</span></span><br><span class="line">	<span class="type">int</span> (*resume)(<span class="keyword">struct</span> platform_device *);<span class="comment">/* 平台设备的恢复函数指针 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span><span class="comment">/* 设备驱动程序的通用数据 */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_table</span>;</span><span class="comment">/* 平台设备与驱动程序的关联关系表 */</span></span><br><span class="line">	<span class="type">bool</span> prevent_deferred_probe; <span class="comment">/* 是否阻止延迟探测 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>probe：平台设备的探测函数指针。当系统检测到一个平台设备与该驱动程序匹配时，该函数将被调用以初始化和配置设备。</p>
<p>remove：平台设备的移除函数指针。当平台设备从系统中移除时，该函数将被调用以执行清理和释放资源的操作。</p>
<p>shutdown：平台设备的关闭函数指针。当系统关闭时，该函数将被调用以执行与平台设备相关的关闭操作。</p>
<p>suspend：平台设备的挂起函数指针。当系统进入挂起状态时，该函数将被调用以执行与平台设备相关的挂起操作。</p>
<p>resume：平台设备的恢复函数指针。当系统从挂起状态恢复时，该函数将被调用以执行与平台设备相关的恢复操作。</p>
<p>driver：包含了与设备驱动程序相关的通用数据，它是 struct device_driver 类型的实例。其中包括驱动程序的名称、总线类型、模块拥有者、属性组数组指针等信息，该结构体的name参数需要与上个章节的platform_device的.name参数相同才能匹配成功，从而进入probe函数。</p>
<p>id_table：指向 struct platform_device_id 结构体数组的指针，用于匹配平台设备和驱动程序之间的关联关系。通过该关联关系，可以确定哪个平台设备与该驱动程序匹配，和.driver.name起到相同的作用，但是优先级高于.driver.name。</p>
<p>prevent_deferred_probe：一个布尔值，用于确定是否阻止延迟探测。如果设置为 true，则延迟探测将被禁用。</p>
<p>使用 struct platform_driver 结构体，开发人员可以定义平台设备驱动程序，并将其注册到内核中。当系统检测到与该驱动程序匹配的平台设备时，内核将调用相应的函数来执行设备的初始化、配置、操作和管理。驱动程序可以利用提供的函数指针和通用数据与平台设备进行交互，并提供必要的功能和服务。</p>
<p>需要注意的是，struct platform_driver 结构体继承了 struct device_driver 结构体，因此可以直接访问 struct device_driver 中定义的成员。这使得平台驱动程序可以利用通用的驱动程序机制，并与其他类型的设备驱动程序共享代码和功能。</p>
<h2 id="52-2-实验程序的编写"><a href="#52-2-实验程序的编写" class="headerlink" title="52.2 实验程序的编写"></a>52.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\41。</p>
<p>本小节的实验只是编写一个platform驱动的一个大体框架，在下一个章节中再讲解platform设备和platform驱动的匹配</p>
<p>编写完成的platform_driver.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的探测函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_probe: Probing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Removing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="52-3-运行测试"><a href="#52-3-运行测试" class="headerlink" title="52.3 运行测试"></a>52.3 运行测试</h2><h3 id="52-3-1-编译驱动程序"><a href="#52-3-1-编译驱动程序" class="headerlink" title="52.3.1 编译驱动程序"></a>52.3.1 编译驱动程序</h3><p>在上一小节中的platform_driver.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_driver.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_driver.c和Makefile文件目录下，如下图（图52-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps8.jpg" alt="img"> </p>
<p>图 52-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图52-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps9.jpg" alt="img"> </p>
<p>图 51-2</p>
<p>编译完生成platform_driver.ko目标文件，如下图（图52-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps10.jpg" alt="img"> </p>
<p>图 52-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="52-3-2-运行测试"><a href="#52-3-2-运行测试" class="headerlink" title="52.3.2 运行测试"></a>52.3.2 运行测试</h3><p>本小节的测试需要用到两个驱动ko文件，即上一章节的注册platform设备ko文件和本章节的注册platform驱动ko文件。</p>
<p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图21-7）所示：</p>
<p>insmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps11.jpg" alt="img"> </p>
<p>然后来到&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;drivers目录下，可以看到我们创建的my_platform_driver驱动文件夹就成功生成了。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps12.jpg" alt="img"> </p>
<p>然后使用以下命令加载注册platform设备ko文件，加载成功之后如下图所示：</p>
<p> insmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps13.jpg" alt="img"> </p>
<p>可以看到匹配成功之后就会进入probe函数，显示出了相应的打印（加载上述两个ko文件不分先后顺序）。然后使用以下命令进行驱动模块的卸载，如下图（图21-7）所示：</p>
<p>rmmod platform_driver.ko</p>
<p>rmmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps14.jpg" alt="img"> </p>
<p>至此，注册platform驱动实验就完成了。</p>
<h1 id="第53章-probe函数编写实验"><a href="#第53章-probe函数编写实验" class="headerlink" title="第53章 probe函数编写实验"></a>第53章 probe函数编写实验</h1><p>在上面的两个章节中分别注册了platform设备和platform驱动，匹配成功之后会进入在注册platform驱动程序中编写的probe函数，在上个章节只是为了验证是否匹配成功，所以只是在probe中加入了一句相关打印，而驱动是要控制硬件的，但是平台总线模型对硬件的描述写在了platform_device.c中,platform设备和platform驱动匹配成功之后，那我们如何在驱动platform_driver.c的probe函数中，得到platform_device.c中编写的硬件资源呢。下面开始本节课程的学习吧。</p>
<h2 id="53-1-获取device资源"><a href="#53-1-获取device资源" class="headerlink" title="53.1 获取device资源"></a>53.1 获取device资源</h2><p><em><strong>*方法*</strong></em><em><strong>*1*</strong></em><em><strong>*：直接访问 platform_device 结构体的资源数组*</strong></em></p>
<p>在上一章节的讲解中提到：struct platform_driver 结构体继承了 struct device_driver 结构体，因此可以直接访问 struct device_driver 中定义的成员。实例代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (pdev-&gt;num_resources &gt;= 2) &#123;</span><br><span class="line">      struct resource *res_mem = &amp;pdev-&gt;resource[0];</span><br><span class="line">      struct resource *res_irq = &amp;pdev-&gt;resource[1];</span><br><span class="line"></span><br><span class="line">      // 使用获取到的硬件资源进行处理</span><br><span class="line">      printk(&quot;Method 1: Memory Resource: start = 0x%lld, end = 0x%lld\n&quot;,</span><br><span class="line">              res_mem-&gt;start, res_mem-&gt;end);</span><br><span class="line">      printk(&quot;Method 1: IRQ Resource: number = %lld\n&quot;, res_irq-&gt;start);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在这种方法中，直接访问platform_device结构体的资源数组来获取硬件资源。pdev-&gt;resource是一个资源数组，其中存储了设备的硬件资源信息。通过访问数组的不同索引，可以获取到特定的资源。</p>
<p>在这个示例中，假设资源数组的第一个元素是内存资源，第二个元素是中断资源。所以我们将第一个元素的指针赋值给res_mem，第二个元素的指针赋值给res_irq。</p>
<p><em><strong>*方法*</strong></em><em><strong>*2*</strong></em><em><strong>*：使用 platform_get_resource() 获取硬件资源*</strong></em></p>
<p>platform_get_resource()函数用于获取设备的资源信息。它的声明位于&lt;linux&#x2F;platform_device.h&gt;头文件中，与平台设备（platform_device）相关。</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>struct resource *platform_get_resource(struct platform_device *pdev,                    unsigned int type, unsigned int num);</p>
<p><em><strong>*参数说明：*</strong></em></p>
<p>pdev：指向要获取资源的平台设备（platform_device）结构体的指针。</p>
<p>type：指定资源的类型，可以是以下值之一：</p>
<p>IORESOURCE_MEM：表示内存资源。</p>
<p>IORESOURCE_IO：表示I&#x2F;O资源。</p>
<p>IORESOURCE_IRQ：表示中断资源。</p>
<p>其他资源类型的宏定义可在&lt;linux&#x2F;ioport.h&gt;和&lt;linux&#x2F;irq.h&gt;头文件中找到。</p>
<p>num：指定要获取的资源的索引。在一个设备中可能存在多个相同类型的资源，通过索引可以选择获取特定的资源。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>如果成功获取资源，则返回指向资源（struct resource）的指针。</p>
<p>如果获取资源失败，或者指定的资源不存在，则返回NULL。</p>
<p>platform_get_resource()函数用于从平台设备的资源数组中获取指定类型和索引的资源。在平台设备的资源数组中，每个元素都是一个struct resource结构体，描述了一个资源的信息，如起始地址、结束地址、中断号等。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line"></span><br><span class="line">res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!res) &#123;</span><br><span class="line">    <span class="comment">// 处理获取内存资源失败的情况</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用获取到的内存资源进行处理</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> start = res-&gt;start;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> end = res-&gt;end;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在上述示例中，首先通过platform_get_resource()函数获取平台设备的第一个内存资源（索引为0）。如果获取资源失败（返回NULL），则可以根据实际情况进行错误处理。如果获取资源成功，则可以使用返回的资源指针来访问资源的信息，如起始地址和结束地址。</p>
<p>通过platform_get_resource()函数，可以方便地在驱动程序中获取平台设备的资源信息，并根据这些信息进行后续的操作和配置。</p>
<h2 id="53-2-实验程序的编写"><a href="#53-2-实验程序的编写" class="headerlink" title="53.2 实验程序的编写"></a>53.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\42_probe。</p>
<p>在上一章程序的基础上，添加第一小节两种获取设备资源的方式并打印出来。</p>
<p>编写完成的probe.c代码如下所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_driver_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res_mem</span>, *<span class="title">res_irq</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法1：直接访问 platform_device 结构体的资源数组</span></span><br><span class="line">    <span class="keyword">if</span> (pdev-&gt;num_resources &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res_mem</span> =</span> &amp;pdev-&gt;resource[<span class="number">0</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res_irq</span> =</span> &amp;pdev-&gt;resource[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用获取到的硬件资源进行处理</span></span><br><span class="line">        printk(<span class="string">&quot;Method 1: Memory Resource: start = 0x%llx, end = 0x%llx\n&quot;</span>,</span><br><span class="line">                res_mem-&gt;start, res_mem-&gt;end);</span><br><span class="line">        printk(<span class="string">&quot;Method 1: IRQ Resource: number = %lld\n&quot;</span>, res_irq-&gt;start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法2：使用 platform_get_resource() 获取硬件资源</span></span><br><span class="line">    res_mem = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!res_mem) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get memory resource\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res_irq = platform_get_resource(pdev, IORESOURCE_IRQ, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!res_irq) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get IRQ resource\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用获取到的硬件资源进行处理</span></span><br><span class="line">    printk(<span class="string">&quot;Method 2: Memory Resource: start = 0x%llx, end = 0x%llx\n&quot;</span>,</span><br><span class="line">            res_mem-&gt;start, res_mem-&gt;end);</span><br><span class="line">    printk(<span class="string">&quot;Method 2: IRQ Resource: number = %lld\n&quot;</span>, res_irq-&gt;start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_driver_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设备移除操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>, <span class="comment">// 与 platform_device.c 中的设备名称匹配</span></span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = my_platform_driver_probe,</span><br><span class="line">    .remove = my_platform_driver_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver); <span class="comment">// 注册平台驱动</span></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;Platform driver registered\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver); <span class="comment">// 注销平台驱动</span></span><br><span class="line">    printk(<span class="string">&quot;Platform driver unregistered\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="53-3-运行测试"><a href="#53-3-运行测试" class="headerlink" title="53.3 运行测试"></a>53.3 运行测试</h2><h3 id="53-3-1-编译驱动程序"><a href="#53-3-1-编译驱动程序" class="headerlink" title="53.3.1 编译驱动程序"></a>53.3.1 编译驱动程序</h3><p>在上一小节中的probe.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += probe.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放probe.c和Makefile文件目录下，如下图（图53-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps15.jpg" alt="img"> </p>
<p>图 53-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图53-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps16.jpg" alt="img"> </p>
<p>图 53-2</p>
<p>编译完生成probe.ko目标文件，如下图（图53-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps17.jpg" alt="img"> </p>
<p>图 53-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="53-3-2-运行测试"><a href="#53-3-2-运行测试" class="headerlink" title="53.3.2 运行测试"></a>53.3.2 运行测试</h3><p>本小节的测试要使用两个ko文件，第一个ko文件为第53章编译出来的platform_device.ko驱动，第二个ko文件为在上一小节编译出的probe.ko驱动文件。</p>
<p>开发板启动之后，首先使用以下命令进行platform设备的注册，如下图（图53-4）所示：</p>
<p>insmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps18.jpg" alt="img"> </p>
<p>图 53-4</p>
<p>然后继续使用以下命令加载probe.ko驱动，打印如下图（53-5）所示：</p>
<p>insmod probe.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps19.jpg" alt="img"> </p>
<p>图 53-5</p>
<p>在上图中，打印了两种方式下获取得到的内存信息和中断信息，最后可以使用以下命令进行驱动的卸载，如下图（图53-6）所示：</p>
<p>rmmod  probe.ko</p>
<p>rmmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps20.jpg" alt="img"> </p>
<p>图 53-6</p>
<h1 id="第54章-点亮LED灯实验（平台总线）"><a href="#第54章-点亮LED灯实验（平台总线）" class="headerlink" title="第54章 点亮LED灯实验（平台总线）"></a>第54章 点亮LED灯实验（平台总线）</h1><p>在上个章节中，我们成功在platform驱动程序中读取到了设备资源信息，在本章节将进行具体的项目实践，要求在上节platform驱动程序的基础上，加入控制LED灯相关的代码（这部分代码可以参考“第18章 点亮LED灯实验”）。</p>
<h2 id="54-1-实验程序的编写"><a href="#54-1-实验程序的编写" class="headerlink" title="54.1 实验程序的编写"></a>54.1 实验程序的编写</h2><h3 id="54-1-1-驱动程序编写"><a href="#54-1-1-驱动程序编写" class="headerlink" title="54.1.1 驱动程序编写"></a>54.1.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\43_platform_led\module。</p>
<p>编写完成的platform_led.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *vir_gpio_dr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(test_dev-&gt;kbuf[<span class="number">0</span>]==<span class="number">1</span>)&#123;   <span class="comment">//如果应用层传入的数据是1，则打开灯</span></span><br><span class="line">            *(test_dev-&gt;vir_gpio_dr) = <span class="number">0x8000c040</span>;   <span class="comment">//设置数据寄存器的地址</span></span><br><span class="line">              printk(<span class="string">&quot;test_dev-&gt;kbuf [0]  is %d\n&quot;</span>,test_dev-&gt;kbuf[<span class="number">0</span>]);  <span class="comment">//打印传入的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(test_dev-&gt;kbuf[<span class="number">0</span>]==<span class="number">0</span>)  <span class="comment">//如果应用层传入的数据是0，则关闭灯</span></span><br><span class="line">    &#123;</span><br><span class="line">            *(test_dev-&gt;vir_gpio_dr) = <span class="number">0x80004040</span>; <span class="comment">//设置数据寄存器的地址</span></span><br><span class="line">            printk(<span class="string">&quot;test_dev-&gt;kbuf [0]  is %d\n&quot;</span>,test_dev-&gt;kbuf[<span class="number">0</span>]); <span class="comment">//打印传入的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_driver_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res_mem</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!res_mem) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get memory resource\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line">    dev1.vir_gpio_dr=ioremap(res_mem-&gt;start,<span class="number">4</span>);  <span class="comment">//将物理地址转化为虚拟地址</span></span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.vir_gpio_dr))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.vir_gpio_dr);  <span class="comment">//PTR_ERR()来返回错误代码</span></span><br><span class="line">        <span class="keyword">goto</span> err_ioremap;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_ioremap:</span><br><span class="line">        iounmap(dev1.vir_gpio_dr);</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_driver_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设备移除操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>, <span class="comment">// 与 platform_device.c 中的设备名称匹配</span></span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = my_platform_driver_probe,</span><br><span class="line">    .remove = my_platform_driver_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver); <span class="comment">// 注册平台驱动</span></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;Platform driver registered\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">	platform_driver_unregister(&amp;my_platform_driver); <span class="comment">// 注销平台驱动</span></span><br><span class="line">    printk(<span class="string">&quot;Platform driver unregistered\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="54-1-2-编写测试-APP"><a href="#54-1-2-编写测试-APP" class="headerlink" title="54.1.2 编写测试 APP"></a>54.1.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\43_platform_led\app。</p>
<p>编写测试app,led驱动加载成功之后会生成&#x2F;dev&#x2F;test节点，应用程序APP通过操作&#x2F;dev&#x2F;test文件来完成对LED设备的控制。向&#x2F;dev&#x2F;test文件写入0表示关闭LED灯，写入1表示打开LED灯。编写完成的应用程序app.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开led驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// atoi()将字符串转为整型，这里将第一个参数转化为整型后，存放在 buf[0]中</span></span><br><span class="line">buf[<span class="number">0</span>] =atoi(argv[<span class="number">1</span>]);  </span><br><span class="line">write(fd,buf,<span class="keyword">sizeof</span>(buf));  <span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="54-2-运行测试"><a href="#54-2-运行测试" class="headerlink" title="54.2 运行测试"></a>54.2 运行测试</h2><h3 id="54-2-1-编译驱动程序"><a href="#54-2-1-编译驱动程序" class="headerlink" title="54.2.1 编译驱动程序"></a>54.2.1 编译驱动程序</h3><p>在上一小节中的platform_led.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_led.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_led.c和Makefile文件目录下，如下图（图54-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps21.jpg" alt="img"> </p>
<p>图 54-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图54-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps22.jpg" alt="img"> </p>
<p>图 54-2</p>
<p>编译完生成platform_led.ko目标文件，如下图（图54-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps23.jpg" alt="img"> </p>
<p>图 54-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="54-2-2-编译应用程序"><a href="#54-2-2-编译应用程序" class="headerlink" title="54.2.2 编译应用程序"></a>54.2.2 编译应用程序</h3><p>下面进行应用程序编译，因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图54-4）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps24.jpg" alt="img"> </p>
<p>图 54-4</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="54-2-3-运行测试"><a href="#54-2-3-运行测试" class="headerlink" title="54.2.3 运行测试"></a>54.2.3 运行测试</h3><p>本小节的测试要使用两个ko文件和一个测试应用程序，第一个ko文件为第53章编译出来的platform_device.ko驱动，第二个ko文件为在上一小节编译出的probe.ko驱动文件，应用程序为上一小节编译出来的app。</p>
<p>开发板启动之后，首先使用以下命令进行platform设备的注册，如下图（图54-5）所示：</p>
<p>insmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps25.jpg" alt="img"> </p>
<p>图 54-5</p>
<p>然后继续使用以下命令加载platform_led.ko驱动，打印如下图（54-6）所示：</p>
<p>insmod platform_led.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps26.jpg" alt="img"> </p>
<p>图 54-6</p>
<p>可以看到led字符设备成功注册了，主设备号为236，次设备号为0，相应的test节点也成功创建了，如下图（54-7）所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps27.jpg" alt="img"></p>
<p>图 54-7</p>
<p>默认情况下led灯的状态为常亮，然后输入“.&#x2F;app 0”命令LED灯熄灭，如下图（图 54-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps28.jpg" alt="img"> </p>
<p>图 54-8</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps29.jpg" alt="img"> </p>
<p>图 54-9</p>
<p>然后输入“.&#x2F;app 0”，LED灯点亮，如下图（图 54-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps30.jpg" alt="img"> </p>
<p>图 54-10</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps31.jpg" alt="img"> </p>
<p>图 54-11</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图54-12）所示：</p>
<p>rmmod platform_led.ko</p>
<p>rmmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps32.jpg" alt="img"> </p>
<p>图 54-12</p>
<p>至此，使用平台总线的点亮LCD灯实验就完成了。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>平台总线</tag>
      </tags>
  </entry>
  <entry>
    <title>rk3568 驱动开发第五篇 中断</title>
    <url>/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%94%E7%AF%87-%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第39章-中断实验"><a href="#第39章-中断实验" class="headerlink" title="第39章 中断实验"></a>第39章 中断实验</h1><p>在前面的课程中，我们深入学习了高级字符设备的进阶知识，包括IO模型、定时器原理、llseek设备定位和通过ioctl传递参数等。通过这些课程，我们对高级字符设备有了深入的理解，并掌握了一些实用的技术和编程方法。从今天开始，我们就进入中断课程的学习了。中断是操作系统中至关重要的机制，它能够显著提高系统的响应性能和并发处理能力。</p>
<h2 id="39-1什么是中断？"><a href="#39-1什么是中断？" class="headerlink" title="39.1什么是中断？"></a>39.1什么是中断？</h2><h3 id="39-1-1-中断的概念"><a href="#39-1-1-中断的概念" class="headerlink" title="39.1.1 中断的概念"></a>39.1.1 中断的概念</h3><p>中断是指在CPU正常运行期间，由外部或内部事件引起的一种机制。当中断发生时，CPU会停止当前正在执行的程序，并转而执行触发该中断的中断处理程序。处理完中断处理程序后，CPU会返回到中断发生的地方，继续执行被中断的程序。中断机制允许CPU在实时响应外部或内部事件的同时，保持对其他任务的处理能力。</p>
<p>可以想象这样一幅画面，你正在烹饪一顿美味的晚餐，准备了各种食材，点燃了炉灶，开始了幸福的烹饪过程，突然，你的手机响起，有人打来了一个紧急电话，打破了你正常的烹饪流程，这时候你需要立刻停止手中的工作，迅速接起电话，与对方进行交流，在接完电话之后，再回到厨房继续之前的烹饪流程。这就是一个在实际生活中的中断案例，中断的概念流程图如下（39-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps33.jpg" alt="img"> </p>
<p>图 39-1</p>
<h3 id="39-1-2-中断的重要性"><a href="#39-1-2-中断的重要性" class="headerlink" title="39.1.2 中断的重要性"></a>39.1.2 中断的重要性</h3><p>在上面的场景中，作为唯一具有处理能力的主体，我们一次只能专注于一个任务，可以等待水烧开、看电视等等。然而，当我们专心致志地完成一项任务时，常常会有紧迫或不紧迫的其他事情突然出现，需要我们关注和处理。有些情况甚至要求我们立即停下手头的工作来应对。只有在处理完这些中断事件之后，我们才能回到先前的任务。</p>
<p>中断机制赋予了我们处理意外情况的能力，而且如果我们能充分利用这个机制，就能够同时完成多个任务。回到烧水的例子，无论我们是否在厨房，煤气灶都会将水烧开。我们只需要在水烧开后及时关掉煤气。为了避免在厨房等待的时间，而水烧开时产生的声音就是中断信号，提醒我们炉子上的水已经烧开。这样，我们就可以在等待的时间里做其他事情，比如看电视。当水壶烧开发出声音之后，它会打断当前的任务，提醒水已经烧开，这时只需要前往厨房关掉煤气即可。</p>
<p>中断机制使我们能够有条不紊地同时处理多个任务，从而提高了并发处理能力。类似地，计算机系统中也使用中断机制来应对各种外部事件。例如，在键盘输入时，会发送一个中断信号给CPU，以便及时响应用户的操作。这样，CPU就不必一直轮询键盘的状态，而可以专注于其他任务。中断机制还可以用于处理硬盘读写完成、网络数据包接收等事件，提高了系统的资源利用率和并发处理能力。</p>
<h3 id="39-1-3-中断的上下半部"><a href="#39-1-3-中断的上下半部" class="headerlink" title="39.1.3 中断的上下半部"></a>39.1.3 中断的上下半部</h3><p>中断的执行需要快速响应，但并不是所有中断都能迅速完成。此外，Linux中的中断不支持嵌套，意味着在正式处理中断之前会屏蔽其他中断，直到中断处理完成后再重新允许接收中断，如果中断处理时间过长，将会引发问题。</p>
<p>这里仍旧以烹饪的过程中接电话进行举例：当你正在烹饪一顿美味的晚餐时，所有的食材都准备好了，炉灶上的火焰跳跃着，你正享受着烹饪的乐趣。突然，你的手机响起，发出紧急电话的铃声，打破了你正常的烹饪流程，接电话的时间很短并不会对烹饪产生很大的影响，而接电话的时候可能就有问题了，水烧开之后可能会煮干、错过了最好的添加调味料的时间等等。</p>
<p>而为了让系统可以更好地处理中断事件，提高实时性和响应能力，将中断服务程序划分为上下文两部分：</p>
<p>中断上文是中断服务程序的第一部分，它主要处理一些紧急且需要快速响应的任务。中断上文的特点是执行时间较短，旨在尽快完成对中断的处理。这些任务可能包括保存寄存器状态、更新计数器等，以便在中断处理完成后能够正确地返回到中断前的执行位置。</p>
<p>中断下文是中断服务程序的第二部分，它主要处理一些相对耗时的任务。由于中断上文需要尽快完成，因此中断下文负责处理那些不能立即完成的、需要更多时间的任务。这些任务可能包括复杂的计算、访问外部设备或进行长时间的数据处理等。</p>
<h2 id="39-2中断子系统框架"><a href="#39-2中断子系统框架" class="headerlink" title="39.2中断子系统框架"></a>39.2中断子系统框架</h2><p>一个完整的中断子系统框架可以分为四个层次，由上到下分别为用户层、通用层、硬件相关层和硬件层，每个层相关的介绍如下（图39-2）所示：</p>
<p>****用户层：****用户层是中断的使用者，主要包括各类设备驱动。这些驱动程序通过中断相关的接口进行中断的申请和注册。当外设触发中断时，用户层驱动程序会进行相应的回调处理，执行特定的操作。</p>
<p>****通用层：****通用层也可称为框架层，它是硬件无关的层次。通用层的代码在所有硬件平台上都是通用的，不依赖于具体的硬件架构或中断控制器。通用层提供了统一的接口和功能，用于管理和处理中断，使得驱动程序能够在不同的硬件平台上复用。</p>
<p>****硬件相关层：****硬件相关层包含两部分代码。一部分是与特定处理器架构相关的代码，比如ARM64处理器的中断处理相关代码。这些代码负责处理特定架构的中断机制，包括中断向量表、中断处理程序等。另一部分是中断控制器的驱动代码，用于与中断控制器进行通信和配置。这些代码与具体的中断控制器硬件相关。</p>
<p>****硬件层：****硬件层位于最底层，与具体的硬件连接相关。它包括外设与SoC（系统片上芯片）的物理连接部分。中断信号从外设传递到中断控制器，由中断控制器统一管理和路由到处理器。硬件层的设计和实现决定了中断信号的传递方式和硬件的中断处理能力。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps34.jpg" alt="img"> </p>
<p>图 39-2</p>
<p>本小节的重点会聚集在硬件层各部分的详细讲解以及用户层编写驱动程序所用到的接口函数。</p>
<h3 id="39-2-1-中断控制器GIC"><a href="#39-2-1-中断控制器GIC" class="headerlink" title="39.2.1 中断控制器GIC"></a>39.2.1 中断控制器GIC</h3><p>中断控制器GIC（Generic Interrupt Controller）是中断子系统框架硬件层中的一个关键组件，用于管理和控制中断。它接收来自各种中断源的中断请求，并根据预先配置的中断优先级、屏蔽和路由规则，将中断请求分发给适当的处理器核心或中断服务例程。</p>
<p>GIC是由ARM公司提出设计规范，当前有四个版本，GIC V1-v4。设计规范中最常用的，有3个版本V2.0、V3.1、V4.1，GICv3版本设计主要运行在Armv8-A, Armv9-A等架构上。ARM公司并给出一个实际的控制器设计参考，比如GIC-400(支持GIC v2架构)、gic500(支持GIC v3架构)、GIC-600(支持GIC v3和GIC v4架构)。最终芯片厂商可以自己实现GIC或者直接购买ARM提供的设计。</p>
<p>每个GIC版本及相应特性如下表（表 39-3）所示：</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>关键特性</th>
<th>常用核心</th>
</tr>
</thead>
<tbody><tr>
<td>GICv1</td>
<td>-支持最多八个处理器核心（PE）- 支持最多1020个中断ID</td>
<td>ARM Cortex-A5 MPCoreARM Cortex-A9 MPCoreARM Cortex-R7 MPCore</td>
</tr>
<tr>
<td>GICv2</td>
<td>- GICv1的所有关键特性-支持虚拟化</td>
<td>ARM Cortex-A7 MPCoreARM Cortex-A15 MPCoreARM Cortex-A53 MPCoreARM Cortex-A57 MPCore</td>
</tr>
<tr>
<td>GICv3</td>
<td>- GICv2的所有关键特性-支持超过8个处理器核心-支持基于消息的中断-支持超过1020个中断ID- CPU接口寄存器的系统寄存器访问-增强的安全模型，分离安全和非安全的Group 1中断</td>
<td>ARM Cortex-A53MPCoreARM Cortex-A57MPCoreARM Cortex-A72 MPCore</td>
</tr>
<tr>
<td>GICv4</td>
<td>- GICv3的所有关键特性-虚拟中断的直接注入</td>
<td>ARM Cortex-A53 MPCoreARMCortex-A57MPCoreARM Cortex-A72 MPCore</td>
</tr>
</tbody></table>
<p>表 39-3</p>
<p>在RK3568上使用的GIC版本为GICv3，相应的中断控制器模型如下（图 39-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps35.jpg" alt="img"> </p>
<p>图 39-4</p>
<p>GIC中断控制器可以分为Distributor接口、Redistributor接口和CPU接口，下面是每个部分的说明：</p>
<p><em><strong>*Distributor*</strong></em><em><strong>*中断仲裁器：*</strong></em></p>
<p>包含影响所有处理器核心中断的全局设置。包含以下编程接口：</p>
<p>●启用和禁用SPI。</p>
<p>●设置每个SPI的优先级级别。</p>
<p>●每个SPI的路由信息。</p>
<p>●将每个SPI设置为电平触发或边沿触发。</p>
<p>●生成基于消息的SPI。</p>
<p>●控制SPI的活动和挂起状态。</p>
<p>●用于确定在每个安全状态中使用的程序员模型的控制（亲和性路由或遗留模型）。</p>
<p>****Redistributor重新分配器****：</p>
<p>对于每个连接的处理器核心（PE），都有一个重新分配器（Redistributor）。重新分配器提供以下编程接口：</p>
<p>●启用和禁用SGI（软件生成的中断）和PPI（处理器专用中断）。</p>
<p>●设置SGI和PPI的优先级级别。</p>
<p>●将每个PPI设置为电平触发或边沿触发。</p>
<p>●将每个SGI和PPI分配给一个中断组。</p>
<p>●控制SGI和PPI的状态。</p>
<p>●对支持关联LPI（低功耗中断）的中断属性和挂起状态的内存中的数据结构进行基址控制。</p>
<p>●支持与连接的处理器核心的电源管理。</p>
<p><em><strong>*CPU接口*</strong></em><em><strong>*：*</strong></em></p>
<p>每个重新分配器都连接到一个CPU接口。CPU接口提供以下编程接口：</p>
<p>●通用控制和配置，用于启用中断处理。</p>
<p>●确认中断。</p>
<p>●执行中断的优先级降低和停用。</p>
<p>●为处理器核心设置中断优先级屏蔽。</p>
<p>●定义处理器核心的抢占策略。</p>
<p>●确定处理器核心最高优先级的挂起中断。</p>
<h3 id="39-2-2-中断类型"><a href="#39-2-2-中断类型" class="headerlink" title="39.2.2 中断类型"></a>39.2.2 中断类型</h3><p>GIC-V3支持四种类型的中断，分别是SGI、PPI、SPI和LPI，每个中断类型的介绍如下：</p>
<p>SGI（Software Generated Interrupt，软件生成中断）：SGI 是通过向 GIC 中的 SGI 寄存器写入来生成的中断。它通常用于处理器之间的通信，允许一个 PE 发送中断给一个或多个指定的 PE，中断号ID0 - ID15用于SGI。</p>
<p>PPI（Private Peripheral Interrupt，私有外设中断）：针对特定 PE 的外设中断。不与其他 PE 共享，中断号ID16 - ID31用于PPI。</p>
<p>SPI（Shared Peripheral Interrupt，共享外设中断）：全局外设中断，可以路由到指定的处理器核心（PE）或一组 PE，它允许多个 PE 接收同一个中断。中断号ID32 - ID1019用于SPI，</p>
<p>LPI（Locality-specific Peripheral Interrupt，特定局部外设中断）：LPI 是 GICv3 中引入的一种中断类型，与其他类型的中断有几个不同之处。LPI 总是基于消息的中断，其配置存储在内存表中，而不是寄存器中。</p>
<table>
<thead>
<tr>
<th>INTID范围</th>
<th>中断类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>0 - 15</td>
<td>SGI（软件生成中断）</td>
<td>每个核心分别存储</td>
</tr>
<tr>
<td>16 - 31</td>
<td>PPI（私有外设中断）</td>
<td>每个核心分别存储</td>
</tr>
<tr>
<td>32 - 1019</td>
<td>SPI（共享外设中断）</td>
<td></td>
</tr>
<tr>
<td>1020 - 1023</td>
<td>特殊中断号</td>
<td>用于表示特殊情况</td>
</tr>
<tr>
<td>1024 - 8191</td>
<td>保留</td>
<td></td>
</tr>
<tr>
<td>8192及更大</td>
<td>LPI（特定局部外设中断）</td>
<td>上限由实现定义</td>
</tr>
</tbody></table>
<p>表 39-5</p>
<p>中断处理的状态机如下图（图 39-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps36.jpg" alt="img"> </p>
<p>图 39-6</p>
<p>Inactive（非活动状态）：中断源当前未被触发。</p>
<p>Pending（等待状态）：中断源已被触发，但尚未被处理器核心确认。</p>
<p>Active（活动状态）：中断源已被触发，并且已被处理器核心确认。</p>
<p>Active and Pending（活动且等待状态）：已确认一个中断实例，同时另一个中断实例正在等待处理。</p>
<p>每个外设中断可以是以下两种类型之一：<br><em><strong>*边沿触发（Edge-triggered）*</strong></em><em><strong>*：*</strong></em><br>    这是一种在检测到中断信号上升沿时触发的中断，然后无论信号状态如何，都保持触发状态，直到满足本规范定义的条件来清除中断。</p>
<p><em><strong>*电平触发（Level-sensitive）*</strong></em><em><strong>*：*</strong></em><br>    这是一种在中断信号电平处于活动状态时触发的中断，并且在电平不处于活动状态时取消触发。</p>
<h3 id="39-2-3-中断号"><a href="#39-2-3-中断号" class="headerlink" title="39.2.3 中断号"></a>39.2.3 中断号</h3><p>在linux 内核中，我们使用IRQ number和HW interrupt ID两个ID来标识一个来自外设的中断：</p>
<p>****IRQ number****：CPU需要为每一个外设中断编号，我们称之IRQ Number。这个IRQ number是一个虚拟的interrupt ID，和硬件无关，仅仅是被CPU用来标识一个外设中断。</p>
<p>****HW interrupt ID：****对于GIC中断控制器而言，它收集了多个外设的interrupt request line并向上传递，因此，GIC中断控制器需要对外设中断进行编码。GIC中断控制器用HW interrupt ID来标识外设的中断。如果只有一个GIC中断控制器，那IRQ number和HW interrupt ID是可以一一对应的，如下图（图 39-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps37.jpg" alt="img"> </p>
<p>图 39-7</p>
<p>但如果是在GIC中断控制器级联的情况下，仅仅用HW interrupt ID就不能唯一标识一个外设中断，还需要知道该HW interrupt ID所属的GIC中断控制器（HW interrupt ID在不同的Interrupt controller上是会重复编码的）。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps38.jpg" alt="img"> </p>
<p>图 39-8</p>
<p>这样，CPU和中断控制器在标识中断上就有了一些不同的概念，但是，对于驱动工程师而言，我们和CPU视角是一样的，我们只希望得到一个IRQ number，而不关系具体是那个GIC中断控制器上的那个HW interrupt ID。这样一个好处是在中断相关的硬件发生变化的时候，驱动软件不需要修改。因此，linux kernel中的中断子系统需要提供一个将HW interrupt ID映射到IRQ number上来的机制，也就是irq domain。</p>
<h3 id="39-2-4-中断申请函数"><a href="#39-2-4-中断申请函数" class="headerlink" title="39.2.4 中断申请函数"></a>39.2.4 中断申请函数</h3><h4 id="（1）-request-irq"><a href="#（1）-request-irq" class="headerlink" title="（1）****request_irq"></a><strong>（<strong><strong>1</strong></strong>）****request_irq</strong></h4><p>request_irq 函数是在 Linux 内核中用于注册中断处理程序的函数。它用于请求一个中断号（IRQ number）并将一个中断处理程序与该中断关联起来。下面是对 request_irq 函数的详细介绍：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>  int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev);</p>
<p>****头文件****：</p>
<p>  #include &lt;linux&#x2F;interrupt.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>request_irq 函数的主要功能是请求一个中断号，并将一个中断处理程序与该中断号关联起来。当中断事件发生时，与该中断号关联的中断处理程序会被调用执行。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>irq：要请求的中断号（IRQ number）。</p>
<p>handler：指向中断处理程序的函数指针。</p>
<p>flags：标志位，用于指定中断处理程序的行为和属性，如中断触发方式、中断共享等。</p>
<p>name：中断的名称，用于标识该中断。</p>
<p>dev：指向设备或数据结构的指针，可以在中断处理程序中使用。</p>
<p>返回值：</p>
<p>成功：0 或正数，表示中断请求成功。</p>
<p>失败：负数，表示中断请求失败，返回的负数值表示错误代码。</p>
<p>irq参数用来指定要请求的中断号，中断号需要通过gpio_to_irq 函数映射 GPIO 引脚来获得（gpio_to_irq 函数接下来会进行介绍）。</p>
<p>irq_handler_t handler参数是一个函数指针，指向了中断处理程序的函数。中断处理程序是在中断事件发生时调用的函数，用于处理中断事件（关于中断处理程序会在下个小节进行详细的讲解）。</p>
<p>unsigned long flags：中断处理程序的标志位</p>
<p>这个参数用于指定中断处理程序的行为和属性，如中断触发方式、中断共享等。可以使用不同的标志位进行位运算来组合多个属性。常用的标志位包括：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IRQF_TRIGGER_NONE：无触发方式，表示中断不会被触发。</span><br><span class="line">IRQF_TRIGGER_RISING：上升沿触发方式，表示中断在信号上升沿时触发。</span><br><span class="line">IRQF_TRIGGER_FALLING：下降沿触发方式，表示中断在信号下降沿时触发。</span><br><span class="line">IRQF_TRIGGER_HIGH：高电平触发方式，表示中断在信号为高电平时触发。</span><br><span class="line">IRQF_TRIGGER_LOW：低电平触发方式，表示中断在信号为低电平时触发。</span><br><span class="line">IRQF_SHARED：中断共享方式，表示中断可以被多个设备共享使用。</span><br></pre></td></tr></table></figure>



<h4 id="（2）-gpio-to-irq"><a href="#（2）-gpio-to-irq" class="headerlink" title="（2）****gpio_to_irq"></a><strong>（2）****gpio_to_irq</strong></h4><p>gpio_to_irq 函数用于将 GPIO 引脚的编号（GPIO pin number）转换为对应的中断请求号（interrupt request number）。</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>unsigned int gpio_to_irq(unsigned int gpio);</p>
<p>****头文件****：</p>
<p>#include &lt;linux&#x2F;gpio.h&gt;</p>
<p><em><strong>*函数功能：*</strong></em><br>    gpio_to_irq 是一个用于将 GPIO 引脚映射到对应中断号的函数。它的作用是根据给定的 GPIO 引脚号，获取与之关联的中断号。</p>
<p><em><strong>*参数说明：*</strong></em></p>
<p>gpio：要映射的 GPIO 引脚号。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>成功：返回值为该 GPIO 引脚所对应的中断号。</p>
<p>失败：返回值为负数，表示映射失败或无效的 GPIO 引脚号。</p>
<h4 id="（3）free-irq"><a href="#（3）free-irq" class="headerlink" title="（3）free_irq"></a>（3）<strong>free_irq</strong></h4><p>free_irq 函数用于释放之前通过 request_irq 函数注册的中断处理程序。它的作用是取消对中断的注册并释放相关的系统资源。下面是关于该函数的详细解释：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>void free_irq(unsigned int irq, void *dev_id);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;interrupt.h&gt;</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>free_irq 函数用于释放之前通过 request_irq 函数注册的中断处理程序。它会取消对中断的注册并释放相关的系统资源，包括中断号、中断处理程序和设备标识等。</p>
<p><em><strong>*参数说明：*</strong></em></p>
<p>irq：要释放的中断号。</p>
<p>dev_id：设备标识，用于区分不同的中断请求。它通常是在 request_irq 函数中传递的设备特定数据指针。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>free_irq 函数没有返回值。</p>
<h3 id="39-2-5-中断服务函数"><a href="#39-2-5-中断服务函数" class="headerlink" title="39.2.5 中断服务函数"></a>39.2.5 中断服务函数</h3><p>中断处理程序是在中断事件发生时自动调用的函数。它负责处理与中断相关的操作，例如读取数据、清除中断标志、更新状态等。</p>
<p>irqreturn_t handler(int irq, void *dev_id) 是一个典型的中断服务函数的函数原型。下面对该函数原型及其参数进行详细解释：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>irqreturn_t handler(int irq, void *dev_id);</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>handler 函数是一个中断服务函数，用于处理特定中断事件。它在中断事件发生时被操作系统或硬件调用，执行必要的操作来响应和处理中断请求。</p>
<p><em><strong>*参数说明：*</strong></em></p>
<p>irq：表示中断号或中断源的标识符。它指示引发中断的硬件设备或中断控制器。</p>
<p>dev_id：是一个 void 类型的指针，用于传递设备特定的数据或标识符。它通常用于在中断处理程序中区分不同的设备或资源。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>irqreturn_t 是一个特定类型的枚举值，用于表示中断服务函数的返回状态。它可以有以下几种取值：</p>
<p>IRQ_NONE：表示中断服务函数未处理该中断，中断控制器可以继续处理其他中断请求。</p>
<p>IRQ_HANDLED：表示中断服务函数已成功处理该中断，中断控制器无需进一步处理。</p>
<p>IRQ_WAKE_THREAD：表示中断服务函数已处理该中断，并且请求唤醒一个内核线程来继续执行进一步的处理。这在一些需要长时间处理的中断情况下使用。</p>
<p>在处理程序中，通常需要注意以下几个方面：</p>
<p>（1）处理程序应该尽可能地快速执行，以避免中断丢失或过多占用 CPU 时间。</p>
<p>（2）如果中断源是共享的，处理程序需要处理多个设备共享同一个中断的情况。</p>
<p>（3）处理程序可能需要与其他部分的代码进行同步，例如访问共享数据结构或使用同步机制来保护临界区域。</p>
<p>（4）处理程序可能需要与其他线程或进程进行通信，例如唤醒等待的线程或发送信号给其他进程。</p>
<h2 id="39-3实验程序编写"><a href="#39-3实验程序编写" class="headerlink" title="39.3实验程序编写"></a>39.3实验程序编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\30_interrupt\03_中断驱动例程。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中会打印申请的GPIO号和This is irq_handler。</p>
<p>iTOP-RK3568有 5 组 GPIO bank：GPIO0<del>GPIO4，每组又以 A0</del>A7, B0<del>B7, C0</del>C7, D0~D7 作为编号区分,常用以下公式计算引脚：</p>
<ul>
<li>GPIO pin脚计算公式：pin <strong>&#x3D;</strong> bank ***** 32 <strong>+</strong> number   &#x2F;&#x2F;bank为组号，number为小组编号</li>
<li>GPIO 小组编号计算公式：number <strong>&#x3D;</strong> group ***** 8 <strong>+</strong> X</li>
</ul>
<p>LCD触摸屏对应的中断引脚标号为TP_INT_L_GPIO3_A5，对应的计算过程如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bank = <span class="number">3</span>;       <span class="comment">//GPIO3_A5=&gt; 3, bank ∈ [0,4]</span></span><br><span class="line">group = <span class="number">0</span>;      <span class="comment">//GPIO3_A5 =&gt; 0, group ∈ &#123;(A=0), (B=1), (C=2), (D=3)&#125;</span></span><br><span class="line">X = <span class="number">5</span>;         <span class="comment">//GPIO3_A5 =&gt; 5, X ∈ [0,7]</span></span><br><span class="line">number = group * <span class="number">8</span> + X = <span class="number">0</span> * <span class="number">8</span> + <span class="number">5</span> =<span class="number">5</span></span><br><span class="line">pin = bank*<span class="number">32</span> + number= <span class="number">3</span> * <span class="number">32</span> + <span class="number">5</span> = <span class="number">101</span>;</span><br></pre></td></tr></table></figure>

<p> 得到中断引脚的引脚标号后，下面开始编写对应的驱动程序，编写完成的interrupt.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN 101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_irq_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt occurred on GPIO %d\n&quot;</span>, GPIO_PIN);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;This is irq_handler\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">interrupt_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> irq_num;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Initializing GPIO Interrupt Driver\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将GPIO引脚映射到中断号</span></span><br><span class="line">    irq_num = gpio_to_irq(GPIO_PIN);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;GPIO %d mapped to IRQ %d\n&quot;</span>, GPIO_PIN, irq_num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求中断</span></span><br><span class="line">    <span class="keyword">if</span> (request_irq(irq_num, gpio_irq_handler, IRQF_TRIGGER_RISING, <span class="string">&quot;irq_test&quot;</span>, <span class="literal">NULL</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to request IRQ %d\n&quot;</span>, irq_num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求中断失败，释放GPIO引脚</span></span><br><span class="line">        gpio_free(GPIO_PIN);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">interrupt_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;                                                                                                                                                                                                                                     </span><br><span class="line">    <span class="type">int</span> irq_num = gpio_to_irq(GPIO_PIN);</span><br><span class="line">    <span class="comment">// 释放中断</span></span><br><span class="line">    free_irq(irq_num, <span class="literal">NULL</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;GPIO Interrupt Driver exited successfully\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(interrupt_init);</span><br><span class="line">module_exit(interrupt_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="39-4-运行测试"><a href="#39-4-运行测试" class="headerlink" title="39.4 运行测试"></a>39.4 运行测试</h2><h3 id="39-4-1-编译驱动程序"><a href="#39-4-1-编译驱动程序" class="headerlink" title="39.4.1 编译驱动程序"></a>39.4.1 编译驱动程序</h3><p>在上一小节中的timer_mod.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m +=interrupt.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图(图 39-9)所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps39.jpg" alt="img"> </p>
<p>图 39-9</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 39-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps40.jpg" alt="img"> </p>
<p>图 39-10</p>
<p>编译完生成 interrupt.ko目标文件，如下图（图 39-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps41.jpg" alt="img"> </p>
<p>图 39-11</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="39-4-2-运行测试"><a href="#39-4-2-运行测试" class="headerlink" title="39.4.2 运行测试"></a>39.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 39-12）所示：</p>
<p>insmod interrupt.ko </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps42.jpg" alt="img"> </p>
<p>图 39-12</p>
<p>可以看到驱动加载之后，打印了“Initializing GPIO Interrupt Driver”表示程序加载成功了，在后面又打印了gpio映射后的中断请求号为113，然后触摸LCD屏，触发中断服务程序，打印如下图（图 39-13）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps43.jpg" alt="img"> </p>
<p>图 39-13</p>
<p>成功打印了GPIO的引脚编号以及“This is irq_handler”，证明编写的驱动程序没有问题，最后使用以下命令卸载相应的驱动，如下图（图 39-14）所示：</p>
<p>rmmod  interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps44.jpg" alt="img"> </p>
<p>图 39-14</p>
<h1 id="第40章-中断申请流程"><a href="#第40章-中断申请流程" class="headerlink" title="第40章 中断申请流程"></a>第40章 中断申请流程</h1><p>在上一章中，我们简单的认识了一下中断以及中断子系统框架，最后编写了中断申请和中断服务函数的实验，大家会发现虽然前面讲解的只是点很多，但实际用起来只需要两三个函数就可以了，但中断的具体申请流程是怎样的呢，大家就不是很清楚了，在本章节将带领大家研究中断的申请流程。</p>
<h2 id="40-1-request-irq函数"><a href="#40-1-request-irq函数" class="headerlink" title="40.1 request_irq函数"></a>40.1 request_irq函数</h2><p>中断申请使用的是request_irq 函数，它用于请求一个中断号（IRQ number）并将一个中断处理程序与该中断关联起来，它定义在内核源码的“&#x2F;include&#x2F;linux&#x2F;interrupt.h”目录下，具体定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">request_irq(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span><br><span class="line">	    <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的内容可以得到request_irq()函数实际上是调用了request_threaded_irq()函数来完成中断申请的过程。request_threaded_irq()函数提供了线程化的中断处理方式，可以在中断上下文中执行中断处理函数。</p>
<h2 id="40-2-request-threaded-irq函数"><a href="#40-2-request-threaded-irq函数" class="headerlink" title="40.2 request_threaded_irq函数"></a>40.2 request_threaded_irq函数</h2><p>request_threaded_irq 函数是 Linux 内核提供的一个功能强大的函数，用于请求分配一个中断，并将中断处理程序与该中断关联起来。该函数的主要作用是在系统中注册中断处理函数，以响应对应中断的发生。以下是 request_threaded_irq 函数的功能和作用的详细介绍：</p>
<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em>****中断请求****：request_threaded_irq 函数用于请求一个中断。它会向内核注册对应中断号的中断处理函数，并为该中断分配必要的资源。中断号是标识特定硬件中断的唯一标识符。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em>****中断处理函数关联：****通过 handler 参数，将中断处理函数与中断号关联起来。中断处理函数是一个预定义的函数，用于处理中断事件。当中断发生时，内核将调用该函数来处理中断事件。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em>****线程化中断处理****：request_threaded_irq 函数还支持使用线程化中断处理函数。通过指定 thread_fn 参数，可以在一个内核线程上下文中异步执行较长时间的中断处理或延迟敏感的工作。这有助于避免在中断上下文中阻塞时间过长。</p>
<p><em><strong>*（*</strong></em><em><strong>*4*</strong></em><em><strong>*）*</strong></em>****中断属性设置：****通过 irqflags 参数，可以设置中断处理的各种属性和标志。例如，可以指定中断触发方式（上升沿、下降沿、边沿触发等）、中断类型（边沿触发中断、电平触发中断等）以及其他特定的中断行为。</p>
<p><em><strong>*（*</strong></em><em><strong>*5*</strong></em><em><strong>*）*</strong></em>****设备标识关联：****通过 dev_id 参数，可以将中断处理与特定设备关联起来。这样可以在中断处理函数中访问与设备相关的数据。设备标识符可以是指向设备结构体或其他与设备相关的数据的指针。</p>
<p><em><strong>*（*</strong></em><em><strong>*6*</strong></em><em><strong>*）*</strong></em>****错误处理：****request_threaded_irq 函数会返回一个整数值，用于指示中断请求的结果。如果中断请求成功，返回值为 0；如果中断请求失败，则返回一个负数错误代码，表示失败的原因。</p>
<p>request_threaded_irq 函数定义在内核源码目录下的“&#x2F;kernel&#x2F;irq&#x2F;manage.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span>  <span class="comment">// 中断动作结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span>  <span class="comment">// 中断描述符指针</span></span><br><span class="line">	<span class="type">int</span> retval;  <span class="comment">// 返回值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查中断号是否为未连接状态</span></span><br><span class="line">	<span class="keyword">if</span> (irq == IRQ_NOTCONNECTED)</span><br><span class="line">		<span class="keyword">return</span> -ENOTCONN;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查中断标志的有效性</span></span><br><span class="line">	<span class="keyword">if</span> (((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id) ||</span><br><span class="line">	    (!(irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)) ||</span><br><span class="line">	    ((irqflags &amp; IRQF_NO_SUSPEND) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据中断号获取中断描述符</span></span><br><span class="line">	desc = irq_to_desc(irq);</span><br><span class="line">	<span class="keyword">if</span> (!desc)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查中断设置是否可以进行中断请求，以及是否为每个CPU分配唯一设备ID</span></span><br><span class="line">	<span class="keyword">if</span> (!irq_settings_can_request(desc) ||</span><br><span class="line">	    WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果未指定中断处理函数，则使用默认的主处理函数</span></span><br><span class="line">	<span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!thread_fn)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		handler = irq_default_primary_handler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配并初始化中断动作数据结构</span></span><br><span class="line">	action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!action)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	action-&gt;handler = handler;  <span class="comment">// 中断处理函数</span></span><br><span class="line">	action-&gt;thread_fn = thread_fn;  <span class="comment">// 线程处理函数</span></span><br><span class="line">	action-&gt;flags = irqflags;  <span class="comment">// 中断标志</span></span><br><span class="line">	action-&gt;name = devname;  <span class="comment">// 设备名称</span></span><br><span class="line">	action-&gt;dev_id = dev_id;  <span class="comment">// 设备ID</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取中断的电源管理引用计数</span></span><br><span class="line">	retval = irq_chip_pm_get(&amp;desc-&gt;irq_data);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		kfree(action);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置中断并将中断动作与中断描述符关联</span></span><br><span class="line">	retval = __setup_irq(irq, desc, action);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理中断设置失败的情况</span></span><br><span class="line">	<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">		irq_chip_pm_put(&amp;desc-&gt;irq_data);</span><br><span class="line">		kfree(action-&gt;secondary);</span><br><span class="line">		kfree(action);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SHIRQ_FIXME</span></span><br><span class="line">	<span class="keyword">if</span> (!retval &amp;&amp; (irqflags &amp; IRQF_SHARED)) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">		disable_irq(irq);</span><br><span class="line">		local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">		handler(irq, dev_id);</span><br><span class="line"></span><br><span class="line">		local_irq_restore(flags);</span><br><span class="line">		enable_irq(irq);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> retval;  <span class="comment">// 返回设置中断的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em><em><strong>*声明变量和初始化：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span>  <span class="comment">// 中断动作结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span>  <span class="comment">// 中断描述符指针</span></span><br><span class="line"><span class="type">int</span> retval;  <span class="comment">// 返回值</span></span><br></pre></td></tr></table></figure>

<p>第5行：用于存储中断动作结构体的指针（会在下面的小节进行详细的讲解）。</p>
<p>第6行：用于存储中断描述符的指针（会在下面的小节进行详细的讲解）。</p>
<p>第7行：用于存储函数的返回值。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em><em><strong>*参数检查：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查中断号是否为未连接状态</span></span><br><span class="line"><span class="keyword">if</span> (irq == IRQ_NOTCONNECTED)</span><br><span class="line">	<span class="keyword">return</span> -ENOTCONN;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查中断标志的有效性</span></span><br><span class="line"><span class="keyword">if</span> (((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id) ||</span><br><span class="line">    (!(irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)) ||</span><br><span class="line">    ((irqflags &amp; IRQF_NO_SUSPEND) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)))</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br></pre></td></tr></table></figure>

<p>第10行：检查中断号是否为未连接状态（IRQ_NOTCONNECTED）。</p>
<p>第14-17行：检查中断标志的有效性，包括共享标志与设备ID的关联性，条件挂起标志的有效性，以及无挂起标志与条件挂起标志的关联性。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em><em><strong>*获取中断描述符：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据中断号获取中断描述符</span></span><br><span class="line">desc = irq_to_desc(irq);</span><br><span class="line"><span class="keyword">if</span> (!desc)</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br></pre></td></tr></table></figure>

<p>第20行：根据中断号调用irq_to_desc函数获取对应的中断描述符。</p>
<p>第21行：如果获取中断描述符失败，则返回-EINVAL表示无效的参数。</p>
<p><em><strong>*（*</strong></em><em><strong>*4*</strong></em><em><strong>*）*</strong></em><em><strong>*检查中断设置：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查中断设置是否可以进行中断请求，以及是否为每个CPU分配唯一设备ID</span></span><br><span class="line"><span class="keyword">if</span> (!irq_settings_can_request(desc) ||</span><br><span class="line">    WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br></pre></td></tr></table></figure>

<p>第25-26行：检查中断设置是否可以进行中断请求，以及是否为每个CPU分配唯一设备ID。如果中断设置不满足要求，则返回-EINVAL表示无效的参数。</p>
<p><em><strong>*（*</strong></em><em><strong>*5*</strong></em><em><strong>*）*</strong></em><em><strong>*处理中断处理函数和线程处理函数：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果未指定中断处理函数，则使用默认的主处理函数</span></span><br><span class="line"><span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!thread_fn)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	handler = irq_default_primary_handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果未指定中断处理函数，则将默认的主处理函数（irq_default_primary_handler）赋值给handler。</p>
<p><em><strong>*（*</strong></em><em><strong>*6*</strong></em><em><strong>*）*</strong></em><em><strong>*分配并初始化中断动作数据结构：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配并初始化中断动作数据结构</span></span><br><span class="line">action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!action)</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">action-&gt;handler = handler;  <span class="comment">// 中断处理函数</span></span><br><span class="line">action-&gt;thread_fn = thread_fn;  <span class="comment">// 线程处理函数</span></span><br><span class="line">action-&gt;flags = irqflags;  <span class="comment">// 中断标志</span></span><br><span class="line">action-&gt;name = devname;  <span class="comment">// 设备名称</span></span><br><span class="line">action-&gt;dev_id = dev_id;  <span class="comment">// 设备ID</span></span><br></pre></td></tr></table></figure>

<p>第37行：调用kzalloc函数分配内存空间，大小为sizeof(struct irqaction)。	</p>
<p>第38行：如果分配内存失败，则返回-ENOMEM表示内存不足。</p>
<p>第41行-第45行：将中断处理函数、线程处理函数、中断标志、设备名称和设备ID赋值给相应的字段。</p>
<p><em><strong>*（*</strong></em><em><strong>*7*</strong></em><em><strong>*）*</strong></em><em><strong>*获取中断的电源管理引用计数：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取中断的电源管理引用计数</span></span><br><span class="line">retval = irq_chip_pm_get(&amp;desc-&gt;irq_data);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	kfree(action);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第48行：调用irq_chip_pm_get函数获取中断的电源管理引用计数。</p>
<p>第49行：如果获取失败，则释放先前分配的内存空间，并返回获取失败的结果。</p>
<p><em><strong>*（*</strong></em><em><strong>*8*</strong></em><em><strong>*）*</strong></em><em><strong>*设置中断并关联中断动作：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置中断并将中断动作与中断描述符关联</span></span><br><span class="line">retval = __setup_irq(irq, desc, action);</span><br></pre></td></tr></table></figure>

<p>第55行：调用__setup_irq函数设置中断并将中断动作与中断描述符关联。</p>
<p><em><strong>*（*</strong></em><em><strong>*9*</strong></em><em><strong>*）*</strong></em><em><strong>*处理设置中断失败的情况：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理中断设置失败的情况</span></span><br><span class="line"><span class="keyword">if</span> (retval) &#123;</span><br><span class="line">	irq_chip_pm_put(&amp;desc-&gt;irq_data);</span><br><span class="line">	kfree(action-&gt;secondary);</span><br><span class="line">	kfree(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第59行：调用irq_chip_pm_put函数释放中断的电源管理引用计数。</p>
<p>第60行：释放次要中断动作的内存空间。</p>
<p>第61行：释放中断动作的内存空间。</p>
<p><em><strong>*（*</strong></em><em><strong>*10*</strong></em><em><strong>*）*</strong></em><em><strong>*可选的共享中断处理：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SHIRQ_FIXME</span></span><br><span class="line">	<span class="keyword">if</span> (!retval &amp;&amp; (irqflags &amp; IRQF_SHARED)) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">		disable_irq(irq);</span><br><span class="line">		local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">		handler(irq, dev_id);</span><br><span class="line"></span><br><span class="line">		local_irq_restore(flags);</span><br><span class="line">		enable_irq(irq);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>第65行：如果设置中断成功且中断标志中包含共享标志（IRQF_SHARED），则执行以下操作：</p>
<p>第68行：禁用中断。</p>
<p>第69行：保存当前中断状态并禁用本地中断。</p>
<p>第70行：调用主处理函数处理中断。</p>
<p>第73行：恢复中断状态。</p>
<p>第74行）：重新使能中断。</p>
<h2 id="40-3-irq-desc结构体"><a href="#40-3-irq-desc结构体" class="headerlink" title="40.3 irq_desc结构体"></a>40.3 irq_desc结构体</h2><p>irq_desc 结构体是 Linux 内核中用于描述中断的数据结构之一。每个硬件中断都有一个对应的 irq_desc 实例，它用于记录与该中断相关的各种信息和状态。该结构体的主要功能是管理中断处理函数、中断行为以及与中断处理相关的其他数据。</p>
<p>以下是 irq_desc 结构体的主要作用和功能：</p>
<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em>****中断处理函数管理****：irq_desc 结构体中的 handle_irq 字段保存中断处理函数的指针。当硬件触发中断时，内核会调用该函数来处理中断事件。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em>****中断行为管理：****irq_desc 结构体中的 action 字段是一个指向中断行为列表的指针。中断行为是一组回调函数，用于注册、注销和处理与中断相关的事件。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em>****中断统计信息：****irq_desc 结构体中的 kstat_irqs 字段是一个指向中断统计信息的指针。该信息用于记录中断事件的发生次数和处理情况，可以帮助分析中断的性能和行为。</p>
<p><em><strong>*（*</strong></em><em><strong>*4*</strong></em><em><strong>*）*</strong></em>****中断数据管理：****irq_desc 结构体中的 irq_data 字段保存了与中断相关的数据，如中断号、中断类型等。这些数据用于识别和管理中断。</p>
<p><em><strong>*（*</strong></em><em><strong>*5*</strong></em><em><strong>*）*</strong></em>****通用中断数据管理：****irq_desc 结构体中的 irq_common_data 字段保存了与中断处理相关的通用数据，如中断控制器、中断屏蔽等。这些数据用于处理和控制中断的行为。</p>
<p><em><strong>*（*</strong></em><em><strong>*6*</strong></em><em><strong>*）*</strong></em>****中断状态管理：****irq_desc 结构体中的其他字段用于管理中断的状态，如嵌套中断禁用计数、唤醒使能计数等。这些状态信息帮助内核跟踪和管理中断的状态变化。</p>
<p>通过使用 irq_desc 结构体，内核可以有效地管理和处理系统中的硬件中断。它提供了一个统一的接口，用于注册和处理中断处理函数、管理中断行为，并提供了必要的信息和数据结构来监视和控制中断的行为和状态。</p>
<p> irq_desc 结构体定义在内核源码目录的“include&#x2F;linux&#x2F;irqdesc.h”文件，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_common_data</span>	<span class="title">irq_common_data</span>;</span>    <span class="comment">/* 通用中断数据 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span>		<span class="title">irq_data</span>;</span>  <span class="comment">/* 中断数据 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> __percpu	*kstat_irqs;  <span class="comment">/* 中断统计信息 */</span></span><br><span class="line">	<span class="type">irq_flow_handler_t</span>	handle_irq;    <span class="comment">/* 中断处理函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IRQ_PREFLOW_FASTEOI</span></span><br><span class="line">	<span class="type">irq_preflow_handler_t</span>	preflow_handler;   <span class="comment">/* 预处理中断处理函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">action</span>;</span>   * IRQ action <span class="built_in">list</span> */</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		status_use_accessors;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		core_internal_state__do_not_mess_with_it; <span class="comment">/* 内核内部状态标志位，请勿修改 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		depth;     <span class="comment">/* 嵌套中断禁用计数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		wake_depth;   <span class="comment">/* 嵌套唤醒使能计数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		tot_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq_count;     <span class="comment">/* 用于检测损坏的IRQ计数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		last_unhandled;  <span class="comment">/* 未处理计数的老化计时器 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irqs_unhandled; <span class="comment">/* 未处理的中断计数 */</span></span><br><span class="line">	<span class="type">atomic_t</span>		threads_handled;   <span class="comment">/* 处理中断的线程计数 */</span></span><br><span class="line">	<span class="type">int</span>			threads_handled_last;</span><br><span class="line">	<span class="type">raw_spinlock_t</span>		lock;        <span class="comment">/* 自旋锁 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>		*<span class="title">percpu_enabled</span>;</span>      <span class="comment">/* 指向每个CPU的使能掩码 */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>	*<span class="title">percpu_affinity</span>;</span>     <span class="comment">/* 指向每个CPU亲和性掩码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>	*<span class="title">affinity_hint</span>;</span>   <span class="comment">/* CPU亲和性提示 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_affinity_notify</span> *<span class="title">affinity_notify</span>;</span>  <span class="comment">/* CPU亲和性变化通知 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PENDING_IRQ</span></span><br><span class="line">	<span class="type">cpumask_var_t</span>		pending_mask;          <span class="comment">/* 等待处理的中断掩码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		threads_oneshot;</span><br><span class="line">	<span class="type">atomic_t</span>		threads_active;    <span class="comment">/* 活动中的线程计数 */</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span>       wait_for_threads;   <span class="comment">/* 等待线程的等待队列头 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		nr_actions;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		no_suspend_depth;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		cond_suspend_depth;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		force_resume_depth;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>	*<span class="title">dir</span>;</span>       <span class="comment">/* proc文件系统目录项 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_IRQ_DEBUGFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>		*<span class="title">debugfs_file</span>;</span>    <span class="comment">/* 调试文件系统文件 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*dev_name;           <span class="comment">/* 设备名称 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSE_IRQ</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		<span class="title">kobj</span>;</span>  <span class="comment">/* 内核对象 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">request_mutex</span>;</span>   <span class="comment">/* 请求互斥锁 */</span></span><br><span class="line">	<span class="type">int</span>			parent_irq;     <span class="comment">/* 父中断号 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span>        <span class="comment">/* 模块拥有者 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*name;          <span class="comment">/* 中断名称 */</span></span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<p>在irq_desc 结构体中最重要的就是 action 字段，会在下个小节对action 字段进行详细的讲解。</p>
<h2 id="40-4-irqaction-结构体"><a href="#40-4-irqaction-结构体" class="headerlink" title="40.4 irqaction 结构体"></a>40.4 irqaction 结构体</h2><p>irqaction 结构体是 Linux 内核中用于描述中断行为的数据结构之一。它用于定义中断处理过程中的回调函数和相关属性。irqaction 结构体的主要功能是管理与特定中断相关的行为和处理函数。</p>
<p>以下是 irqaction 结构体的主要作用和功能：</p>
<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em>****中断处理函数管理****：irqaction 结构体中的 handler 字段保存中断处理函数的指针。该函数在中断发生时被调用，用于处理中断事件。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em>****中断处理标志管理：****irqaction 结构体中的 flags 字段用于指定中断处理的各种属性和标志。这些标志控制中断处理的行为，例如触发方式、中断类型等。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em>****设备标识符管理****：irqaction 结构体中的 dev_id 字段用于保存与中断处理相关的设备标识符。它可以是指向设备结构体或其他与设备相关的数据的指针，用于将中断处理与特定设备关联起来。</p>
<p><em><strong>*（*</strong></em><em><strong>*4*</strong></em><em><strong>*）*</strong></em>****中断行为链表管理****：irqaction 结构体中的 next 字段是一个指向下一个 irqaction 结构体的指针，用于构建中断行为的链表。这样可以将多个中断处理函数链接在一起，以便在中断发生时按顺序调用它们。</p>
<p>通过使用 irqaction 结构体，内核可以灵活地定义和管理与特定中断相关的行为和处理函数。它提供了一个统一的接口，用于注册和注销中断处理函数，并提供了必要的属性和数据结构来控制中断处理的行为和顺序。</p>
<p>irqaction 体定义在内核源码的“include&#x2F;linux&#x2F;interrupt.h”文件中如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> &#123;</span></span><br><span class="line">	<span class="type">irq_handler_t</span>		handler;          <span class="comment">// 中断处理函数</span></span><br><span class="line">	<span class="type">void</span>			*dev_id;          <span class="comment">// 设备ID</span></span><br><span class="line">	<span class="type">void</span> __percpu		*percpu_dev_id;   <span class="comment">// 每个CPU的设备ID</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">next</span>;</span>            <span class="comment">// 下一个中断动作结构体</span></span><br><span class="line">	<span class="type">irq_handler_t</span>		thread_fn;        <span class="comment">// 线程处理函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">thread</span>;</span>          <span class="comment">// 线程结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">secondary</span>;</span>       <span class="comment">// 次要中断动作结构体</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq;              <span class="comment">// 中断号</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		flags;            <span class="comment">// 中断标志</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		thread_flags;     <span class="comment">// 线程标志</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		thread_mask;      <span class="comment">// 线程掩码</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*name;            <span class="comment">// 设备名称</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>	*<span class="title">dir</span>;</span>             <span class="comment">// proc文件系统目录项指针</span></span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<h1 id="第41章-中断下文tasklet实验"><a href="#第41章-中断下文tasklet实验" class="headerlink" title="第41章 中断下文tasklet实验"></a>第41章 中断下文tasklet实验</h1><p>在上一个章节中，我们申请GPIO中断，使用的是request_irq,但是request_irq绑定的中断服务程序指的是中断上文。在之前的中断视频中讲解了：中断分为俩个部分——中断上文和中断下文。本章节我们来学习中断下文的一种实现方式——tasklet。</p>
<h2 id="41-1-什么是tasklet"><a href="#41-1-什么是tasklet" class="headerlink" title="41.1 什么是tasklet"></a>41.1 什么是tasklet</h2><p>在Linux内核中，tasklet是一种特殊的软中断机制，被广泛用于处理中断下文相关的任务。它是一种常见且有效的方法，在多核处理系统上可以避免并发问题。Tasklet绑定的函数在同一时间只能在一个CPU上运行，因此不会出现并发冲突。然而，需要注意的是，tasklet绑定的函数中不能调用可能导致休眠的函数，否则可能引起内核异常。</p>
<p>在Linux内核中，tasklet结构体的定义位于include&#x2F;linux&#x2F;interrupt.h头文件中。其原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> state;</span><br><span class="line">    <span class="type">atomic_t</span> count;</span><br><span class="line">    <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet_t</span>;</span></span><br></pre></td></tr></table></figure>

<p>tasklet_struct结构体包含以下成员：</p>
<p>l next:指向下一个tasklet的指针，用于形成链表结构，以便内核中可以同时管理多个tasklet。</p>
<p>l state:表示tasklet的当前状态。</p>
<p>l count:用于引用计数，用于确保tasklet在多个地方调度或取消调度时的正确处理。</p>
<p>l func:指向tasklet绑定的函数的指针，该函数将在tasklet执行时被调用。</p>
<p>l data:传递给tasklet绑定函数的参数</p>
<p>此外，为了方便，还定义了tasklet_t类型作为struct tasklet_struct的别名。这样我们可以使用tasklet_t来声明tasklet变量，而不是直接使用struct tasklet_struct。</p>
<h2 id="41-2-tasklet相关接口函数"><a href="#41-2-tasklet相关接口函数" class="headerlink" title="41.2 tasklet相关接口函数"></a>41.2 tasklet相关接口函数</h2><h3 id="41-2-1-静态初始化函数"><a href="#41-2-1-静态初始化函数" class="headerlink" title="41.2.1 静态初始化函数"></a>41.2.1 静态初始化函数</h3><p>在Linux内核中，有一个用于静态初始化tasklet的宏函数：DECLARE_TASKLET。这个宏函数可以帮助我们更方便地进行tasklet的静态初始化。</p>
<p>宏函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，name是tasklet的名称，func是tasklet的处理函数，data是传递给处理函数的参数。</p>
<p>初始化状态为使能状态。</p>
<p>如果tasklet初始化函数为非使能状态，使用以下宏定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，name是tasklet的名称，func是tasklet的处理函数，data是传递给处理函数的参数。</p>
<p>初始化状态为非使能状态。</p>
<p>下面是一个示例，展示了如何使用DECLARE_TASKLET宏函数进行tasklet的静态初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，my_tasklet是tasklet的名称，my_tasklet_handler是tasklet的处理函数，0是传递给处理函数的参数。但是需要注意的是，使用DECLARE_TASKLET静态初始化的tasklet无法在运行时动态销毁，因此在不需要tasklet时，应该避免使用此方法。如果需要在运行时销毁tasklet，应使用tasklet_init和tasklet_kill函数进行动态初始化和销毁，接下来我们来学习动态初始化函数。</p>
<h3 id="41-2-2-动态初始化函数"><a href="#41-2-2-动态初始化函数" class="headerlink" title="41.2.2 动态初始化函数"></a>41.2.2 动态初始化函数</h3><p> 在Linux内核中，可以使用tasklet_init函数对tasklet进行动态初始化。该函数原型为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，t是指向tasklet结构体的指针，func是tasklet的处理函数，data是传递给处理函数的参数</p>
<p>以下是一个示例，tasklet_init函数进行动态初始化如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在示例中，我们首先定义了my_tasklet_handler作为tasklet的处理函数。然后，声明了一个名为my_tasklet的tasklet结构体。接下来，通过调用tasklet_init函数，进行动态初始化。</p>
<p>通过使用tasklet_init函数，我们可以在运行时动态创建和初始化tasklet。这样，我们可以根据需要灵活地管理和控制tasklet的生命周期。在不再需要tasklet时，可以使用tasklet_kill函数进行销毁，以释放相关资源。</p>
<h3 id="41-2-3-关闭函数"><a href="#41-2-3-关闭函数" class="headerlink" title="41.2.3 关闭函数"></a>41.2.3 关闭函数</h3><p>在Linux内核中，可以使用tasklet_disabled函数来关闭一个已经初始化的tasklet。该函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，t是指向tasklet结构体的指针。</p>
<p>以下是一个示例，使用tasklet_disable函数来关闭tasklet。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先定义了my_tasklet_handler作为tasklet的处理函数。然后，声明了一个名为my_tasklet的tasklet结构体，并使用tasklet_init函数对其进行初始化。最后，通过调用tasklet_disable函数，我们关闭了my_tasklet。</p>
<p>关闭tasklet后，即使调用tasklet_schedule函数触发tasklet，tasklet的处理函数也不会再被执行。这可以用于临时暂停或停止tasklet的执行，直到再次启用（通过调用tasklet_enable函数）。</p>
<p>需要注意的是，关闭tasklet并不会销毁tasklet结构体，因此可以随时通过调用tasklet_enable函数重新启用tasklet，或者调用tasklet_kill函数来销毁tasklet。</p>
<h3 id="41-2-4-使能函数"><a href="#41-2-4-使能函数" class="headerlink" title="41.2.4 使能函数"></a>41.2.4 使能函数</h3><p>在Linux内核中，可以使用tasklet_enable函数来使能（启用）一个已经初始化的tasklet。该函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，t是指向tasklet结构体的指针。</p>
<p>以下是一个示例，展示如何使用tasklet_enable函数来使能tasklet：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先定义了my_tasklet_handler作为tasklet的处理函数。然后，声明了一个名为my_tasklet的tasklet结构体，并使用tasklet_init函数对其进行初始化。最后，通过调用tasklet_enable函数，我们使能（启用）了my_tasklet。</p>
<p>使能tasklet后，如果调用tasklet_schedule函数触发tasklet，则tasklet的处理函数将会被执行。这样，tasklet将开始按计划执行其处理逻辑。</p>
<p>需要注意的是，使能tasklet并不会自动触发tasklet的执行，而是通过调用tasklet_schedule函数来触发。同时，可以使用tasklet_disable函数来临时暂停或停止tasklet的执行。如果需要永久停止tasklet的执行并释放相关资源，则应调用tasklet_kill函数来销毁tasklet。</p>
<h3 id="41-2-5-调度函数"><a href="#41-2-5-调度函数" class="headerlink" title="41.2.5 调度函数"></a>41.2.5 调度函数</h3><p>在Linux内核中，可以使用tasklet_schedule函数来调度（触发）一个已经初始化的tasklet执行。该函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	其中，t是指向tasklet结构体的指针。</p>
<p>以下是一个示例，展示如何使用tasklet_schedule函数来调度tasklet执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先定义了my_tasklet_handler作为tasklet的处理函数。然后，声明了一个名为my_tasklet的tasklet结构体，并使用tasklet_init函数对其进行初始化。最后，通过调用tasklet_schedule函数，我们调度（触发）了my_tasklet的执行。</p>
<p>需要注意的是，调度tasklet只是将tasklet标记为需要执行，并不会立即执行tasklet的处理函数。实际的执行时间取决于内核的调度和处理机制。</p>
<h3 id="41-2-6-销毁函数"><a href="#41-2-6-销毁函数" class="headerlink" title="41.2.6 销毁函数"></a>41.2.6 销毁函数</h3><p>​	在Linux内核中，可以使用tasklet_kill函数来销毁一个已经初始化的tasklet，释放相关资源。该函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，t是指向tasklet结构体的指针。</p>
<p>以下是一个示例，展示如何使用tasklet_kill函数来销毁tasklet：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先定义了my_tasklet_handler作为tasklet的处理函数。然后，声明了一个名为my_tasklet的tasklet结构体，并使用tasklet_init函数对其进行初始化。最后，通过调用tasklet_kill函数，我们销毁了my_tasklet。</p>
<p>调用tasklet_kill函数会释放tasklet所占用的资源，并将tasklet标记为无效。因此，销毁后的tasklet不能再被使用。</p>
<p>需要注意的是，在销毁tasklet之前，应该确保该tasklet已经被停止（通过调用tasklet_disable函数）。否则，销毁一个正在执行的tasklet可能导致内核崩溃或其他错误。</p>
<p>一旦销毁了tasklet，如果需要再次使用tasklet，需要重新进行初始化（通过调用tasklet_init函数）。在下一小节中我们将使用上述tasklet函数相关接口函数进行相应的实验。</p>
<h2 id="41-3-实验程序的编写"><a href="#41-3-实验程序的编写" class="headerlink" title="41.3 实验程序的编写"></a>41.3 实验程序的编写</h2><h3 id="41-3-1-驱动程序编写"><a href="#41-3-1-驱动程序编写" class="headerlink" title="41.3.1 驱动程序编写"></a>41.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\32_tasklet\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中调度中断下文tasklet处理函数，打印“This id test_interrupt”和“<em><strong>*data is*</strong></em> ****1****”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO转换为中断号，并使用request_irq函数请求中断，然后对tasklet进行初始化。在中断处理函数中，我们调度tasklet执行，使得当中断触发时，tasklet会被调度执行。在模块退出函数中，我们释放中断资源，并使能tasklet销毁tasklet。</p>
<p>编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="41-4-运行测试"><a href="#41-4-运行测试" class="headerlink" title="41.4 运行测试"></a>41.4 运行测试</h2><h3 id="41-4-1-编译驱动程序"><a href="#41-4-1-编译驱动程序" class="headerlink" title="41.4.1 编译驱动程序"></a>41.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图41-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps45.jpg" alt="img"></p>
<p>图 41-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图41-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps46.jpg" alt="img"></p>
<p>图 41-2</p>
<p>编译完生成interrupt.ko目标文件，如下图（图41-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps47.jpg" alt="img"></p>
<p>图 41-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="41-4-2-运行测试"><a href="#41-4-2-运行测试" class="headerlink" title="41.4.2 运行测试"></a>41.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 41-4）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps48.jpg" alt="img"> </p>
<p>图 41-4</p>
<p>看到驱动加载之后，可以看到申请的中断号（113）被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，触发中断服务程序，打印如下图（41-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps49.jpg" alt="img"></p>
<p>图 41-5</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”和tasklet处理函数中添加的打印“data is 1”，说明成功执行了中断下文tasklet处理函数。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图图 41-6）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps50.jpg" alt="img"></p>
<p>图 41-6</p>
<p>之前的理论章节我们强调说tasklet函数中不能调用休眠的函数，在此我们在上述驱动实验的基础上实验一下，驱动文件中添加休眠函数，如下（图 41-7）所示：</p>
<p>​	<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps51.png" alt="img"></p>
<p>图 41-7</p>
<p>同理，进行编译驱动模块，卸载掉之前的驱动模块后，加载新编译的驱动模块，如下图（图 41-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps52.jpg" alt="img"></p>
<p>图 41-8</p>
<p>然后用手触摸连接的LVDS 7寸屏幕，打印如下图（41-9）所示，内核会崩溃。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps53.jpg" alt="img"></p>
<p>图 41-9</p>
<p>至此，中断下文tasklet实验就完成了。</p>
<h1 id="第42章-软中断实验"><a href="#第42章-软中断实验" class="headerlink" title="第42章 软中断实验"></a>第42章 软中断实验</h1><p>在上个章节我们学习了中断下文的一种实验方式——tasklet，本章节我们来学习中断下文的另一种实现方式——软中断。软中断的资料有限，对应的中断号不多，一般用在网络设备驱动，块设备驱动当中。这时本章节要学习的软中断就闪耀登场了。</p>
<h2 id="42-1-什么是软中断"><a href="#42-1-什么是软中断" class="headerlink" title="42.1 什么是软中断"></a>42.1 什么是软中断</h2><p>打开Linux源码linux_sdk&#x2F;kernel&#x2F;include&#x2F;linux&#x2F;interrupt.h文件，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上代码定义了一个枚举类型，用于标识软中断的不同类型或优先级。每个枚举常量对应一个特定的软中断类型。</p>
<p>以下是每个枚举常量的含义：</p>
<p>HI_SOFTIRQ：高优先级软中断</p>
<p>TIMER_SOFTIRQ：定时器软中断</p>
<p>NET_TX_SOFTIRQ：网络传输发送软中断</p>
<p>NET_RX_SOFTIRQ：网络传输接收软中断</p>
<p>BLOCK_SOFTIRQ：块设备软中断</p>
<p>IRQ_POLL_SOFTIRQ：中断轮询软中断</p>
<p>TASKLET_SOFTIRQ：任务软中断</p>
<p>SCHED_SOFTIRQ：调度软中断</p>
<p>HRTIMER_SOFTIRQ, &#x2F;* Unused, but kept as tools rely on the numbering. Sigh! *&#x2F;</p>
<p>RCU_SOFTIRQ,   &#x2F;* Preferable RCU should always be the last softirq *&#x2F;</p>
<p>NR_SOFTIRQS：表示软中断的总数，用于指示软中断类型的数据</p>
<p>中断号的优先级越小，代表优先级越高。在驱动代码中，我们可以使用Linux驱动代码中上述的软中断，当然我们也可以自己添加软中断。我们添加一个自定义的软中断，如下所示，TEST_SOFTIRQ为自定义添加的软中断。</p>
<p>enum</p>
<p>{</p>
<p>​	HI_SOFTIRQ&#x3D;0,</p>
<p>​	TIMER_SOFTIRQ,</p>
<p>​	NET_TX_SOFTIRQ,</p>
<p>​	NET_RX_SOFTIRQ,</p>
<p>​	BLOCK_SOFTIRQ,</p>
<p>​	IRQ_POLL_SOFTIRQ,</p>
<p>​	TASKLET_SOFTIRQ,</p>
<p>​	SCHED_SOFTIRQ,</p>
<p>​	HRTIMER_SOFTIRQ, &#x2F;* Unused, but kept as tools rely on the</p>
<p>​			  numbering. Sigh! *&#x2F;</p>
<p>​	RCU_SOFTIRQ,   &#x2F;* Preferable RCU should always be the last softirq *&#x2F;</p>
<p>​	TEST_SOFTIRQ, &#x2F;&#x2F;添加的自定义软中断</p>
<p>​	NR_SOFTIRQS</p>
<p>};</p>
<p>这里要注意：尽管我们添加一个自定义的软中断非常简单，但是Linux内核的开发者并不希望我们这样去做，如果我们要用软中断，建议使用tasklet。虽然Linux内核开发者不建议自定义软中断，但是我们抱着学习的态度，了解学习下软中断还是很有必要的。上述修改之后，重新编译内核源码，接下来我们来学习下软中断的使用方法。</p>
<h2 id="42-2-软中断接口函数"><a href="#42-2-软中断接口函数" class="headerlink" title="42.2 软中断接口函数"></a>42.2 软中断接口函数</h2><p>软中断的接口函数非常简单，介绍如下所示：</p>
<p>1 注册软中断，使用open_softirq函数，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数的参数如下所示：</p>
<p>nr: 软中断的编号或优先级。它是一个整数，表示要注册的软中断的标识符。</p>
<p>action: 指向一个函数的指针，这个函数将作为软中断的处理程序。该函数接受一个struct softirq_action类型的参数。</p>
<p>2 触发软中断，使用 raise_softirq函数，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数的参数如下所示：</p>
<p>nr: 软中断的编号或优先级。它是一个整数，表示要注册的软中断的标识符。</p>
<p>3 在禁用硬件中断的情况下，触发软中断使用raise_softirq_irqoff函数，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数的参数如下所示：</p>
<p>nr: 软中断的编号或优先级。它是一个整数，表示要注册的软中断的标识符。</p>
<p>在下一小节中将使用上述软中断API进行相应的实验。</p>
<h2 id="42-3-实验程序的编写"><a href="#42-3-实验程序的编写" class="headerlink" title="42.3 实验程序的编写"></a>42.3 实验程序的编写</h2><h3 id="42-3-1-驱动程序编写"><a href="#42-3-1-驱动程序编写" class="headerlink" title="42.3.1 驱动程序编写"></a>42.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\33_softirq\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中触发软中断，打印“This id test_interrupt”和“****This is testsoft_func****”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO转换为中断号，并使用request_irq函数请求中断，然后注册软中断函数。在中断处理函数中，我们触发软中断，使得当中断触发时，软中断处理函数会被调度执行。</p>
<p>接下来我们编写驱动代码，使用软中断来实现中断的下半部分。编写完成的interrupt.c代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="42-4-运行测试"><a href="#42-4-运行测试" class="headerlink" title="42.4 运行测试"></a>42.4 运行测试</h2><h3 id="42-4-1-编译驱动程序"><a href="#42-4-1-编译驱动程序" class="headerlink" title="42.4.1 编译驱动程序"></a>42.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图42-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps54.jpg" alt="img"></p>
<p>图 42-1</p>
<p>然后使用命令“make”进行驱动的编译，编译如下图（图42-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps55.jpg" alt="img"></p>
<p>图 42-2</p>
<p>上图中提示open_softirq和raise_softirq没有被定义，但是为什么还会提示这样的错误呢？</p>
<p>这是因为Linux内核开发者不希望驱动工程师擅自在枚举类型中添加软中断。我们将这俩个函数导出到符号表，修改linux_sdk&#x2F;kernel&#x2F;kernel&#x2F;softirq.c，修改内容如下（图42-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps56.jpg" alt="img"></p>
<p>图42-3</p>
<p>修改完成后，重新编译内核源码，编译源码通过后，再次编译驱动模块，如下图（图 42-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps57.jpg" alt="img"></p>
<p>图 42-4</p>
<p>编译完生成interrupt.ko目标文件，如下图（图42-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps58.jpg" alt="img"></p>
<p>图 42-5</p>
<h3 id="42-4-2-运行测试"><a href="#42-4-2-运行测试" class="headerlink" title="42.4.2 运行测试"></a>42.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图42-6）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps59.jpg" alt="img"></p>
<p>图42-6</p>
<p>驱动加载成功之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，触发中断服务程序，打印如下图（42-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps60.jpg" alt="img"></p>
<p>图 42-7</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”和软中断处理函数中添加的打印“This is testsoft_func”</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图42-8）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps61.jpg" alt="img"></p>
<p>图 42-8</p>
<p>至此，软中断实验就完成了。</p>
<h1 id="第43章-特殊的软中断tasklet分析实验"><a href="#第43章-特殊的软中断tasklet分析实验" class="headerlink" title="第43章 特殊的软中断tasklet分析实验"></a>第43章 特殊的软中断tasklet分析实验</h1><p>Tasklet是Linux内核中的一种软中断机制，它可以被看作是一种轻量级的延迟处理机制。它是通过软中断控制结构来实现的，因此也被称为软中断。本章节我们来从代码层面分析一下为什么tasklet是一个特殊的软中断呢？</p>
<p>软中断处理函数的定义内核源码kernel&#x2F;kernel&#x2F;softirq.c文件中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面开始对上述代码详细解释：</p>
<p>l for_each_possible_cpu(cpu)：遍历每个可能的CPU。在多核系统中，此循环用于初始化每个CPU的tasklet_vec和tasklet_hi_vec。</p>
<p>l per_cpu(tasklet_vec, cpu).tail &#x3D; &amp;per_cpu(tasklet_vec, cpu).head;：将每个CPU的tasklet_vec的tail指针设置为对应的head指针的初始位置。这样做是为了确保tasklet_vec的初始状态是空的。</p>
<p>l per_cpu(tasklet_hi_vec, cpu).tail &#x3D; &amp;per_cpu(tasklet_hi_vec, cpu).head;：将每个CPU的tasklet_hi_vec的tail指针设置为对应的head指针的初始位置。这样做是为了确保tasklet_hi_vec的初始状态是空的。</p>
<p>l open_softirq(TASKLET_SOFTIRQ, tasklet_action);：注册TASKLET_SOFTIRQ软中断，并指定对应的处理函数为tasklet_action。这样，在TASKLET_SOFTIRQ被触发时，将会调用tasklet_action函数来处理相应的任务。</p>
<p>l open_softirq(HI_SOFTIRQ, tasklet_hi_action);：注册HI_SOFTIRQ软中断，并指定对应的处理函数为tasklet_hi_action。这样，在HI_SOFTIRQ被触发时，将会调用tasklet_hi_action函数来处理相应的任务。</p>
<p>在执行__init softirq_init函数时，会触发TASKLET_SOFTIRQ，然后会调用tasklet_action函数，tasklet_action函数如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述函数中调用了tasklet_action_common函数，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>tasklet_action_common函数，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>在上面的代码中，tasklet_action_common()函数对任务链表中的每个tasklet进行处理。它首先禁用本地中断，获取任务链表头指针，清空任务链表，并重新设置尾指针。然后它循环遍历任务链表，对每个tasklet进行处理。如果tasklet的锁获取成功，并且计数器为0，它将执行tasklet的处理函数，并清除状态标志位。如果锁获取失败或计数不为0，它将tasklet添加到任务链表的尾部，并触发指定的软中断。最后，它启用本地中断，完成任务处理过程。</p>
<p>那么tasklet在什么时候加到链表里面的呢？tasklet是通__tasklet_schedule_common()函数加入到链表中的。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过上述代码，__tasklet_schedule_common()函数将tasklet成功添加到链表的末尾。当软中断被触发时，系统会遍历链表并处理每个tasklet。因此，在添加到链表后，tasklet将在适当的时机被系统调度和执行。</p>
<p>经过上述分析，所以说tasklet是一个特殊的软中断。</p>
<p>内核开发者不希望我们去添加软中断的软中断号，更希望我们使用tasklet。那么tasklet相比自己添加软中断有哪些优点和缺点呢？</p>
<p>使用Tasklet相比自己添加软中断有一些优点和缺点。以下是它们的比较：</p>
<p>优点：</p>
<p>\1. 简化的接口和编程模型：Tasklet提供了一个简单的接口和编程模型，使得在内核中处理延迟工作变得更加容易。相比自己添加软中断，Tasklet提供了更高级的抽象。</p>
<p>\2. 低延迟：Tasklet在软中断上下文中执行，避免了内核线程的上下文切换开销，因此具有较低的延迟。这对于需要快速响应的延迟敏感任务非常重要。</p>
<p>\3. 自适应调度：Tasklet具有自适应调度的特性，当多个Tasklet处于等待状态时，内核会合并它们以减少不必要的上下文切换。这种调度机制可以提高系统的效率。</p>
<p>缺点：</p>
<p>\1. 无法处理长时间运行的任务：Tasklet适用于短时间运行的延迟工作，如果需要处理长时间运行的任务，可能会阻塞其他任务的执行。对于较长的操作，可能需要使用工作队列或内核线程来处理。</p>
<p>\2. 缺乏灵活性：Tasklet的执行受限于软中断的上下文，不适用于所有类型的延迟工作。某些情况下，可能需要更灵活的调度和执行机制，这时自定义软中断可能更加适合。</p>
<p>\3. 资源限制：Tasklet的数量是有限的，系统中可用的Tasklet数量取决于架构和内核配置。如果需要大量的延迟工作处理，可能会受到Tasklet数量的限制。</p>
<p>综上所述，Tasklet提供了一种简单且低延迟的延迟工作处理机制，适用于短时间运行的任务和对响应时间敏感的场景。然而，对于长时间运行的任务和需要更灵活调度的情况，自定义软中断可能更合适。在选择使用Tasklet还是自定义软中断时，需要根据具体的需求和系统特性进行权衡和决策。</p>
<h1 id="第44章-共享工作队列实验"><a href="#第44章-共享工作队列实验" class="headerlink" title="第44章 共享工作队列实验"></a>第44章 共享工作队列实验</h1><p>在上个章节我们学习了中断下文的一种实验方式——软中断，本章节我们来学习中断下文的另一种实现方式——工作队列。工作队列是操作系统中管理和调度异步任务执行的一种机制，接下来开始学习工作队列吧。	</p>
<h2 id="44-1-什么是工作队列"><a href="#44-1-什么是工作队列" class="headerlink" title="44.1 什么是工作队列"></a>44.1 什么是工作队列</h2><p>工作队列是实现中断下半部分的机制之一，是一种用于管理任务的数据结构或机制。它通常用于多线程，多进程或分布式系统中，用于协调和分配****待处理的任务*<em><strong>给</strong></em>*可用的工作线程或工作进程****。</p>
<p>工作队列的基本原理是将需要执行的任务按顺序排列在队列中，并提供一组工作线程或者工作进程来处理队列中的任务。当有新的任务到达时，它们会被添加到队列的末尾，工作线程或工作进程从队列的头部获取任务，并执行相应的处理操作。</p>
<p>工作队列和之前学习的tasklet有什么不同呢？tasklet也是实现中断下半部分的机制之一。他们最主要的区别是tasklet不能休眠，而工作队列是可以休眠的，所以tasklet可以用来处理比较耗时间的事情，而工作队列可以处理更耗时间的事情。</p>
<p>工作队列将工作推后以后，会交给内核线程去执行。Linux在启动过程中会创建一个工作者内核线程，这个线程创建以后处于sleep状态。当有工作需要处理的时候，会唤醒这个线程去处理工作。</p>
<p>在内核中，工作队列包括共享工作队列和自定义工作队列这俩种类型。这两种类型的工作队列具有不同的特点和用途。</p>
<p>1  共享队列是由****内核管理****的全局工作队列，用于处理内核中一些系统级任务。共享工作队列是内核中一个默认工作队列，可以由多个内核组件和驱动程序共享使用。</p>
<p>2 自定义工作队列是由****内核或驱动程序创建的****特定工作队列，用于处理特定的任务。自定义工作队列通常与特定的内核模块或驱动程序相关联，用于执行该模块或驱动程序相关的任务。</p>
<p> 本章节我们先来学习共享工作队列相关的知识。 </p>
<p>在Linux 内核中，使用 work_struct 结构体表示一个工作项，这些工作组织成工作队列，工作队列使用 workqueue_struct 结构体表示，如下图所示，流水线相当于工作队列，流水线上一个个等待处理的物料相当于一个个工作。机器相当于内核线程或进程。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps62.jpg" alt="img"> </p>
<p>图 44-1</p>
<p>work_struct 结构体表示一个工作项，定义在include&#x2F;linux&#x2F;workqueue.h中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		</p>
<h2 id="44-2-工作队列相关接口函数"><a href="#44-2-工作队列相关接口函数" class="headerlink" title="44.2 工作队列相关接口函数"></a>44.2 工作队列相关接口函数</h2><h3 id="44-2-1-初始化函数"><a href="#44-2-1-初始化函数" class="headerlink" title="44.2.1 初始化函数"></a>44.2.1 初始化函数</h3><p>在实际的驱动开发中，我们只需要定义工作项(work_struct)即可，关于工作队列和工作者线程我们基本不用去管。简单创建工作很简单，直接定义一个 work_struct 结构体变量即可，然后使用 INIT_WORK 宏来初始化工作，INIT_WORK 宏定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>INIT_WORK 宏接受两个参数：_work 和 _func，分别表示要初始化的工作项和工作项的处理函数。</p>
<p>也可以使用 DECLARE_WORK 宏一次性完成工作的创建和初始化，宏定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数n 表示定义的工作(work_struct)，f 表示工作对应的处理函数。</p>
<h3 id="44-2-2-调度-取消调度工作队列函数"><a href="#44-2-2-调度-取消调度工作队列函数" class="headerlink" title="44.2.2 调度&#x2F;取消调度工作队列函数"></a>44.2.2 调度&#x2F;取消调度工作队列函数</h3><p>和 tasklet 一样，工作也是需要调度才能运行的，工作的调度函数为 schedule_work，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数是指向工作项的指针。这个函数作用是将工作项提交到工作队列中，并请求调度器在合适的时机执行工作项。该函数会返回一个布尔值，表示工作项是否成功被提交到工作队列。</p>
<p>如果想要取消该工作项的调度，使用以下函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数是指向工作项的指针。这个函数的作用是取消该工作项的调度。如果工作项已经在工作队列中，它将被从队列中移除。如果工作项已经在工作队列中，它将被从队列中移除，并等待工作项执行完成。函数返回一个布尔值，表示工作项是否成功取消。</p>
<h2 id="44-3-实验程序的编写"><a href="#44-3-实验程序的编写" class="headerlink" title="44.3 实验程序的编写"></a>44.3 实验程序的编写</h2><h3 id="44-3-1-驱动程序编写"><a href="#44-3-1-驱动程序编写" class="headerlink" title="44.3.1 驱动程序编写"></a>44.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\34_workqueue\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中提交工作项到共享工作队列中，打印“This id test_interrupt”和“****This is test_work****”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO转换为中断号，并使用request_irq函数请求中断，然后初始化工作项。当中断被触发时，中断处理函数被调用，并将工作项提交到共享工作队列中，最终由工作项处理函数异步执行。编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="44-4-运行测试"><a href="#44-4-运行测试" class="headerlink" title="44.4 运行测试"></a>44.4 运行测试</h2><h3 id="44-4-1-编译驱动程序"><a href="#44-4-1-编译驱动程序" class="headerlink" title="44.4.1 编译驱动程序"></a>44.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图44-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps63.jpg" alt="img"></p>
<p>图 44-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图44-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps64.jpg" alt="img"> </p>
<p>图 44-3</p>
<p>编译完生成interrupt.ko目标文件，如下图（图44-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps65.jpg" alt="img"> </p>
<p>图 44-4</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="44-4-2-运行测试"><a href="#44-4-2-运行测试" class="headerlink" title="44.4.2 运行测试"></a>44.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图44-5）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps66.jpg" alt="img"></p>
<p>图44-5</p>
<p>加载驱动之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（44-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps67.jpg" alt="img"></p>
<p>图 44-6</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”被多次打印，说明触发了好几次中断上文，那么中断上文会多次调度中断下文，所以也会打印工作项处理函数中添加的打印“This is test_work”。但是为什么只会打印俩次“This is test_work”呢？这是因为在中断上文调度工作项处理函数之后，内核没有来得及去执行工作项处理函数，没有执行相当于无效操作，有效的执行则打印了俩次“This is test_work”。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图44-7）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps68.jpg" alt="img"></p>
<p>图 44-7</p>
<p>至此，共享工作队列实验就完成了。	</p>
<h1 id="第45章-自定义工作队列实验"><a href="#第45章-自定义工作队列实验" class="headerlink" title="第45章 自定义工作队列实验"></a>第45章 自定义工作队列实验</h1><p>在上一章节中对工作队列以及共享工作队列知识进行了学习，并使用共享队列进行了实验。共享队列是由****内核管理*<em><strong>的全局工作队列，自定义工作队列是由</strong></em>*内核或驱动程序创建的****特定工作队列，用于处理特定的任务。下面就让我们一起来进行自定义工作队列的学习吧。</p>
<h2 id="45-1-工作队列相关结构体"><a href="#45-1-工作队列相关结构体" class="headerlink" title="45.1 工作队列相关结构体"></a>45.1 工作队列相关结构体</h2><p>在Linux内核中，结构体struct work_struct描述的是要延迟执行的工作项，定义在include&#x2F;linux&#x2F;workqueue.h当中，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>  这些工作组织成工作队列，内核使用struct workqueue_struct结构体描述一个工作队列，定义在include&#x2F;linux&#x2F;workqueue.h 当中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="45-2-工作队列相关接口函数"><a href="#45-2-工作队列相关接口函数" class="headerlink" title="45.2 工作队列相关接口函数"></a>45.2 工作队列相关接口函数</h2><p>在Linux内核中，create_workqueue函数用于创建一个工作队列，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数name是创建的工作队列的名字。使用这个函数可以给每个CPU都创建一个CPU相关的工作队列。创建成功返回一个struct workqueue_struct类型指针，创建失败返回NULL。</p>
<p>如果只给一个CPU创建一个CPU相关的工作队列，使用以下函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数name是创建的工作队列的名字。使用这个函数只会给一个CPU创建一个CPU相关的工作队列。创建成功之后返回一个struct workqueue_struct 类型指针，创建失败返回NULL。 </p>
<p>当工作队列创建好之后，需要将要延迟执行的工作项放在工作队列上，调度工作队列，使用queue_work_on函数，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>  该函数有三个参数，第一个参数是一个整数cpu，第二个参数是一个指向struct workqueue_struct的指针wq，第三个参数是一个指向struct work_struct的指针work。</p>
<p>该函数的返回类型是布尔值，表示是否成功调度工作队列。 queue_work_on函数还有其他变种，比如queue_work函数，这里略过，其实思路是一致的，用于将定义好的工作项立即添加到工作队列中，并在工作队列可用时立即执行。</p>
<p>​	如果要取消一个已经调度的工作，使用函数bool cancel_work_sync，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>  函数的作用是取消一个已经调度的工作，如果被取消的工作已经正在执行，则会等待他执行完成再返回。</p>
<p>在Linux 内核中，使用flush_workqueue函数将刷新该工作队列中所有已提交但未执行的工作项。函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p> 该函数参数是一个指向struct workqueue_struct类型的指针wq。函数的作用是刷新工作队列，告诉内核尽快处理工作队列上的工作。</p>
<p>如果要删除自定义的工作队列，使用destroy_workqueue函数，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>  该函数参数是一个指向struct workqueue_struct类型的指针wq。</p>
<p>在下一小节中将使用上述工作队列API函数进行相应的实验。</p>
<h2 id="45-3-实验程序的编写"><a href="#45-3-实验程序的编写" class="headerlink" title="45.3 实验程序的编写"></a>45.3 实验程序的编写</h2><h3 id="45-3-1-驱动程序编写"><a href="#45-3-1-驱动程序编写" class="headerlink" title="45.3.1 驱动程序编写"></a>45.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\35_workqueue_share\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中提交工作项到工作队列中，打印“This id test_interrupt”和“****This is test_work****”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO转换为中断号，并使用request_irq函数请求中断，然后创建自定义工作队列，初始化工作项。当中断被触发时，中断处理函数被调用，并将工作项提交到自定义工作队列中，最终由工作项处理函数异步执行。编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="45-4-运行测试"><a href="#45-4-运行测试" class="headerlink" title="45.4 运行测试"></a>45.4 运行测试</h2><h3 id="45-4-1-编译驱动程序"><a href="#45-4-1-编译驱动程序" class="headerlink" title="45.4.1 编译驱动程序"></a>45.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图45-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps69.jpg" alt="img"> </p>
<p>图 45-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图45-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps70.jpg" alt="img"></p>
<p>图 45-2</p>
<p>编译完生成interrupt.ko目标文件，如下图（图45-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps71.jpg" alt="img"></p>
<p>图 45-3</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="45-4-2-运行测试"><a href="#45-4-2-运行测试" class="headerlink" title="45.4.2 运行测试"></a>45.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图45-4）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps72.jpg" alt="img"> </p>
<p>图45-4</p>
<p>加载驱动之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（45-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps73.jpg" alt="img"> </p>
<p>图 45-5</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”被打印了俩次，说明触发了2次中断上文，那么中断上文会调度2次中断下文，所以也会打印2次工作项处理函数中添加的打印“This is test_work”。</p>
<p>在按屏幕之后，立即输入ps -aux|grep test_workqueue命令可以查看自己创建的工作队列，如下（图 45-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps74.jpg" alt="img"></p>
<p>图 45-6</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图45-7）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps75.jpg" alt="img"></p>
<p>图 45-7</p>
<p>至此，自定义工作队列实验就完成了。</p>
<h1 id="第46章-延迟工作实验"><a href="#第46章-延迟工作实验" class="headerlink" title="第46章 延迟工作实验"></a>第46章 延迟工作实验</h1><p>在之前的章节中，我们学习了共享工作队列和自定义工作队列，为了更形象地理解学习，将流水线比作工作队列，流水线上一个个等待处理的物料比作一个个工作。机器比作内核线程或进程。本章节我们即将学习的延迟工作，可以类比为将物料延迟一定时间，再放到生产线上加工。延迟工作不仅可以在自定义工作队列中实现 也可以在共享工作队列上实现。现在，我们对延迟工作有了一个感性的认识，接下来详细的学习下延迟工作吧。</p>
<h2 id="46-1-什么是延迟工作"><a href="#46-1-什么是延迟工作" class="headerlink" title="46.1 什么是延迟工作"></a>46.1 什么是延迟工作</h2><p>延迟工作是一种将工作的执行延迟到稍后时间点进行处理的技术。通常情况下，当某个任务需要花费较长时间，不需要立即执行或需要按时执行时，延迟工作就会派上用场。</p>
<p>延迟工作的基本思想是将任务放入一个队列中，然后由后台的工作进程会任务调度程序来处理队列中的任务。任务可以在指定的延迟时间后执行，也可以根据优先级，任务类型或者其他条件进行排序和处理。</p>
<p>延迟工作在许多应用场景中都非常有用，尤其是在需要处理大量任务，提供系统性能和可靠性的情况下。以下是一些常用的应用场景：</p>
<p>1 延迟工作常用于处理那些需要花费较长时间的任务，比如发送电子邮件，处理图像等。通过将这些任务放入队列中并延迟执行，可以避免阻塞应用程序的主线程，提高系统的响应速度。</p>
<p>2 延迟工作可以用来执行定时任务，比如定时备份数据库，通过将任务设置为在未来的某个时间点执行，提高系统的可靠性和效率。</p>
<p>为了方便大家理解，我们再举个形象点的例子，比如说开发板上的按键，现在我们想通过驱动程序读取按键的状态，那么只需要读取这个按键所连接的GPIO的状态就可以了。</p>
<p>理想型的按键电压变化过程如图（图 46-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps76.png" alt="img"> </p>
<p>图 46-1</p>
<p>在上图中，按键没有按下的时候按键值为 1，当按键在 t1 时刻按键被按下以后按键值就变为 0，这是最理想的状态。但是实际的按键是机械结构，加上刚按下去的一瞬间人手可能也有抖动，实际的按键电压变化过程如下图（图 46-2）所示：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\ksohtml17816\wps77.png" alt="img"> </p>
<p>图 46-2</p>
<p>在上图中，t1 时刻按键被按下，但是由于抖动的原因，直到 t2 时刻才稳定下来，t1 到t2 这段时间就是抖动。一般这段时间就是十几 ms 左右，从上图中可以看出在抖动期间会有多次触发，如果不消除这段抖动的话软件就会误判，本来按键就按下了一次，结果软件读取IO 值发现电平多次跳变以为按下了多次。所以我们需要跳过这段抖动时间再去读取按键的 IO值，也就是至少要在 t2 时刻以后再去读 IO 值。在之前的驱动视频中，我们使用了定时器来实现消抖。按键采用中断驱动方式，当按键按下以后触发按键中断，在按键中断中开启一个定时器，定时周期为 10ms，当定时时间到了以后就会触发定时器中断，最后在定时器中断处理函数中读取按键的值，如果按键值还是按下状态那就表示这是一次有效的按键。定时器按键消抖如下图（图 46-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps78.png" alt="img"> </p>
<p>图 46-3</p>
<p>在上图中t1<del>t3 这一段时间就是按键抖动，是需要消除的。设置按键为下降沿触发，因此会在 t1、t2 和 t3 这三个时刻会触发按键中断，每次进入中断处理函数都会重新开器定时器中断，所以会在 t1、t2 和 t3 这三个时刻开器定时器中断。但是 t1</del>t2 和 t2~t3 这两个时间段是小于我们设置的定时器中断周期(也就是消抖时间，比如 10ms)，所以虽然 t1 开启了定时器，但是定时器定时时间还没到呢 t2 时刻就重置了定时器，最终只有 t3 时刻开启的定时器能完整的完成整个定时周期并触发中断，我们就可以在中断处理函数里面做按键处理了，这就是定时器实现按键防抖的原理，Linux 里面的按键驱动用的就是这个原理！</p>
<p>除了使用定时器方式进行消抖，也可以使用本章节讲述的延迟工作。在中断下文中将工作延迟3秒之后，再去读GPIO电平状态。</p>
<p>在Linux内核中，使用struct delayed_work来描述延迟工作，定义在include&#x2F;linux&#x2F;workqueue.h当中，原型定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>struct delayed_work结构体包含了两个成员：</p>
<p>1  work：这是一个struct work_struct类型的成员，用于表示延迟工作的基本工作结构。struct work_struct是表示工作的常见数据结构，用于定义要执行的工作内容。</p>
<p>2  timer：这是一个struct timer_list类型的成员，用于管理延迟工作的定时器。struct timer_list是Linux内核中的定时器结构，用于设置延迟时间和触发工作执行的时机。</p>
<p>  使用struct delayed_work结构体，可以将需要执行的工作封装成一个延迟工作，并使用定时器来控制工作的延迟执行。通过设置定时器的延迟时间，可以指定工作在一定时间后执行。</p>
<p>接下来我们学习下延迟工作相关的接口函数吧。</p>
<h2 id="46-2-延迟工作相关接口函数"><a href="#46-2-延迟工作相关接口函数" class="headerlink" title="46.2 延迟工作相关接口函数"></a>46.2 延迟工作相关接口函数</h2><h3 id="46-2-1-初始化延迟工作函数"><a href="#46-2-1-初始化延迟工作函数" class="headerlink" title="46.2.1 初始化延迟工作函数"></a>46.2.1 初始化延迟工作函数</h3><p>静态定义并初始化延迟工作使用宏DECLARE_DELAYED_WORK，函数原型如下所示：	</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用宏定义后，可以将上述代码简化为#define DECLARE_DELAYED_WORK(n,f)，n代表延迟工作的变量名，f是延迟工作的处理函数。</p>
<p>动态定义并初始化延迟工作使用宏INIT_DELAYED_WORK，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用宏定义后，可以将上述代码简化为#define INIT_DELAYED_WORK(_work, _func)， n代表延迟工作的变量名，f是延迟工作的处理函数。</p>
<h3 id="46-2-2-调度-取消调度-延迟工作函数"><a href="#46-2-2-调度-取消调度-延迟工作函数" class="headerlink" title="46.2.2 调度&#x2F;取消调度 延迟工作函数"></a>46.2.2 调度&#x2F;取消调度 延迟工作函数</h3><p>如果是在共享工作队列上调度延迟工作，使用以下函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数是一个内联函数，用于在给定的延迟时间后调度延迟工作执行。</p>
<p>函数参数dwork:是指向延迟工作的指针，即要被调度的延迟工作。</p>
<p>delay:表示延迟的时间长度，以内核时钟节拍数jiffies为单位。</p>
<p>如果是在自定义工作队列上调度延迟工作，使用以下函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数是一个内联函数，用于将延迟工作加入工作队列后在指定的延迟时间后执行。</p>
<p>函数参数wq是指向工作队列结构的指针，即要将延迟工作加入的目标工作队列。</p>
<p>dwork:指向延迟工作的指针，也就是要被加入工作队列的延迟工作。</p>
<p>delay: 表示延迟的时间长度，以内核时钟节拍数jiffies为单位。</p>
<p>如果要取消调度函数，使用以下函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数是一个外部声明的函数，用于取消延迟工作并等待其完成。dwork参数是指向延迟工作的指针，也就是要被取消的延迟工作。函数如果返回true，说明成功取消延迟工作并等待其完成。函数如果返回false，说明无法取消延迟工作或等待其完成。</p>
<p>在下一小节中将在自定义工作队列实验的基础上修改驱动，进行延迟工作实验。</p>
<h2 id="46-3-实验程序的编写"><a href="#46-3-实验程序的编写" class="headerlink" title="46.3 实验程序的编写"></a>46.3 实验程序的编写</h2><h3 id="46-3-1-驱动程序编写"><a href="#46-3-1-驱动程序编写" class="headerlink" title="46.3.1 驱动程序编写"></a>46.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\36_workqueue_delay\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中提交延迟工作项到工作队列中，打印“This id test_interrupt”，并延迟打印“****This is test_work****”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO转换为中断号，并使用request_irq函数请求中断，然后创建自定义工作队列，初始化延迟工作项。当中断被触发时，中断处理函数被调用，并将延迟工作项提交到自定义工作队列中，最终由工作项处理函数异步执行。编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="46-4-运行测试"><a href="#46-4-运行测试" class="headerlink" title="46.4 运行测试"></a>46.4 运行测试</h2><h3 id="46-4-1-编译驱动程序"><a href="#46-4-1-编译驱动程序" class="headerlink" title="46.4.1 编译驱动程序"></a>46.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图46-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps79.jpg" alt="img"></p>
<p>图 46-4</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图46-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps80.jpg" alt="img"></p>
<p>图46-5</p>
<p>编译完生成interrupt.ko目标文件，如下图（图46-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps81.jpg" alt="img"></p>
<p>图 46-6</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="46-4-2-运行测试"><a href="#46-4-2-运行测试" class="headerlink" title="46.4.2 运行测试"></a>46.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图46-7）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps82.jpg" alt="img"></p>
<p>图46-7</p>
<p>加载驱动之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（46-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps83.jpg" alt="img"></p>
<p>图46-8</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”被打印了多次，说明触发了多次中断上文，在4秒之后，打印工作项处理函数中的“This is test_work”。4秒之后打印“This is test_work”是因为调度延迟工作函数写了延迟3秒，再加上工作项处理函数中延迟了一秒，所以一共是4秒。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图46-9）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps84.jpg" alt="img"></p>
<p>图 46-9</p>
<p>至此，延迟工作实验就完成了。</p>
<h1 id="第47章-工作队列传参实验"><a href="#第47章-工作队列传参实验" class="headerlink" title="第47章 工作队列传参实验"></a>第47章 工作队列传参实验</h1><p>在41章节中，我们使用tasklet来实现中断下文，并使用tasklet给中断下文传参，如果我们使用工作队列来实现中断的下半部分，那么如何用工作队列给中断下文传参呢？本章节我们来一探究竟！</p>
<h2 id="47-1-工作队列传参"><a href="#47-1-工作队列传参" class="headerlink" title="47.1 工作队列传参"></a>47.1 工作队列传参</h2><p>在Linux内核的工作队列中，可以通过使用工作项的方式向工作队列传递参数。工作项是一个抽象的结构，可以用于封装需要执行的工作及其相关的参数。</p>
<p>首先我们定义工作项结构，如下所示，在结构体struct work_data中定义了需要传递给工作项处理函数的参数a和b，然后定义一个类型为struct work_data 的变量test_workqueue_work。</p>
<p>struct work_data {</p>
<p> struct work_struct test_work;</p>
<p> int a;</p>
<p> int b;</p>
<p>};  </p>
<p>struct work_data test_workqueue_work;</p>
<p>接下来在模块初始化函数interrupt_irq_init 中创建了一个工作队列test_workqueue 和一个工作项 test_workqueue_work。</p>
<p>test_workqueue &#x3D; create_workqueue(“test_workqueue”); &#x2F;&#x2F; 创建工作队列</p>
<p>INIT_WORK(&amp;test_workqueue_work.test_work, test_work); &#x2F;&#x2F; 初始化工作项</p>
<p>然后在模块初始化函数中，为工作项的参数 a 和 b 赋值。</p>
<p>test_workqueue_work.a &#x3D; 1;</p>
<p>test_workqueue_work.b &#x3D; 2;</p>
<p>当中断触发时，在中断处理函数 test_interrupt 中，通过调用 queue_work 函数将工作项 test_workqueue_work.test_work 提交到工作队列 test_workqueue 中。</p>
<p>queue_work(test_workqueue, &amp;test_workqueue_work.test_work);</p>
<p>然后工作项处理函数 test_work 定义了一个指针 pdata，将工作项转换为 struct work_data 结构，并通过该结构访问参数 a 和 b。如下所示：</p>
<p>void test_work(struct work_struct *work)</p>
<p>{</p>
<p> struct work_data *pdata;</p>
<p> pdata &#x3D; container_of(work, struct work_data, test_work);</p>
<p> printk(“a is %d\n”, pdata-&gt;a);</p>
<p> printk(“b is %d\n”, pdata-&gt;b);</p>
<p>}</p>
<p>这样，当工作队列被调度执行时，工作项处理函数test_work将能够访问到传递给工作项的参数a和b,并在内核日志中打印他们的值。</p>
<p>注意，工作项处理函数中的 container_of 宏用于从工作项结构的指针获取整个 struct work_data 结构的指针。这样可以通过指针偏移来访问工作项结构中的其他字段，例如参数 a 和 b。</p>
<p>详细的驱动代码编写见下一小节。</p>
<h2 id="47-2实验程序的编写"><a href="#47-2实验程序的编写" class="headerlink" title="47.2实验程序的编写"></a>47.2实验程序的编写</h2><h3 id="47-2-1-驱动程序编写"><a href="#47-2-1-驱动程序编写" class="headerlink" title="47.2.1 驱动程序编写"></a>47.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\37_workqueue_data\module。</p>
<p>编写完成的interrupt.c代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="47-3-运行测试"><a href="#47-3-运行测试" class="headerlink" title="47.3 运行测试"></a>47.3 运行测试</h2><h3 id="47-3-1-编译驱动程序"><a href="#47-3-1-编译驱动程序" class="headerlink" title="47.3.1 编译驱动程序"></a>47.3.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>.对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图47-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps85.jpg" alt="img"></p>
<p>图 47-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图47-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps86.jpg" alt="img"></p>
<p>图 47-2</p>
<p>编译完生成interrupt.ko目标文件，如下图（图47-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps87.jpg" alt="img"></p>
<p>图 47-3</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="47-3-2-运行测试"><a href="#47-3-2-运行测试" class="headerlink" title="47.3.2 运行测试"></a>47.3.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图47-4）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps88.jpg" alt="img"> </p>
<p>图47-4</p>
<p>驱动加载之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（47-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps89.jpg" alt="img"> </p>
<p>图 47-5</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”和传递给工作项的参数a和b的值。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图47-6）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps90.jpg" alt="img"> </p>
<p>图 47-6</p>
<p>至此，工作队列传参实验就完成了。</p>
<h1 id="第48章-并发管理工作队列实验"><a href="#第48章-并发管理工作队列实验" class="headerlink" title="第48章 并发管理工作队列实验"></a>第48章 并发管理工作队列实验</h1><p>在现代的软件开发中，我们常常面临着需要同时处理多个任务的挑战。这些任务可能是并行的、独立的，或者需要以某种顺序进行处理。为了高效地管理这些并发任务，我们需要一种有效的机制来协调它们的执行。这就是并发管理工作队列发挥作用的地方。本章节我们来学习并发管理工作队列。</p>
<h2 id="48-1工作队列的实现"><a href="#48-1工作队列的实现" class="headerlink" title="48.1工作队列的实现"></a>48.1工作队列的实现</h2><p>在44章节和45章节，我们学习了共享工作队列和自定义工作队列，在使用工作队列时，我们首先定义一个work结构体，然后将work添加到workqueue(工作队列)中，最后worker thread 执行workqueue。当工作队列中有新work产生时，工作线程（worker thread）会执行工作队列中每个work。当执行完结束的时候，worker thread会睡眠，等到新的中断产生，work再继续添加到工作队列，然后工作线程执行每个工作，周而复始。</p>
<p>在单核线程的系统中，通常会为每个 CPU（核心）初始化一个工作线程并关联一个工作队列。这种默认设置确保每个CPU都有一个专门的线程来处理与其绑定的工作队列上的工作项。如下图（48-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps91.jpg" alt="img"> </p>
<p>图 48-1</p>
<p>在多核线程系统中，工作队列的设计与单核线程系统有所不同。在多核线程系统中，通常会存在多个工作队列，每个工作队列与一个工作线程（Worker Thread）绑定。这样可以充分利用多个核心的并行处理能力。如下图（48-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps92.jpg" alt="img"></p>
<p>图 48-2</p>
<p>当有新的工作项产生时，系统需要决定将其分配给哪个工作队列。一种常见的策略是使用负载均衡算法，根据工作队列的负载情况来平衡分配工作项，以避免某个工作队列过载而导致性能下降。每个工作队列独立管理自己的工作项。当有新的工作项添加到工作队列时，工作线程会从其关联的工作队列中获取待执行的工作项，并执行相应的处理函数。在多核线程系统中，多个工作线程可以同时执行各自绑定的工作队列中的工作项。这样可以实现并行处理，提高系统的整体性能和响应速度。</p>
<p>了解了工作队列是如何实现的，接下来我们看看传统的工作队列有什么弊端呢？</p>
<h2 id="48-2-workqueue队列弊端"><a href="#48-2-workqueue队列弊端" class="headerlink" title="48.2 workqueue队列弊端"></a>48.2 workqueue队列弊端</h2><p>假如说有三个work放到了同一个工作队列上，接下来CPU会启动工作线程去执行这三个work，如下图（48-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps93.jpg" alt="img"> </p>
<p>图 48-3</p>
<p>在上图中，工作项w0、w1、w2被排队到同一个CPU上的绑定工作队列上。w0工作项执行的时候，先工作 5毫秒，然后睡觉10毫秒，然后再工作CPU 5毫秒，然后完成。工作项w1和w2都是工作5ms，然后睡眠10 ms，然后完成。传统工作队列的弊端如下所示：</p>
<p>1 在工作项w0 工作甚至是睡眠时，工作项w1 w2是排队等待的，在繁忙的系统中，工作队列可能会积累大量的待处理工作项，导致任务调度的延迟，这可能会影响系统的响应性能，并增加工作项的处理时间。</p>
<p>2 在工作队列中，不同的工作项可能具有不同的处理时间和资源需求。如果工作项的处理时间差异很大，一些工作线程可能会一直忙于处理长时间的工作项，而其他工作线程则处于空闲状态，导致资源利用不均衡。</p>
<p>3 在多线程环境下，多个工作线程同时访问和修改工作队列可能会导致竞争条件的发生。为了确保数据的一致性和正确性，需要采用适当的同步机制，如锁或原子操作，来保护共享数据，但这可能会引入额外的同步开销。</p>
<p>4 工作队列通常按照先进先出（FIFO）的方式处理工作项，缺乏对工作项优先级的细粒度控制。在某些场景下，可能需要根据工作项的重要性或紧急程度进行优先级调度，而工作队列本身无法提供这种级别的优先级控制。</p>
<p>5 当工作线程从工作队列中获取工作项并执行时，可能需要频繁地进行上下文切换，将处理器的执行上下文从一个线程切换到另一个线程。这种上下文切换开销可能会影响系统的性能和效率。</p>
<h2 id="48-2-什么是并发管理工作队列"><a href="#48-2-什么是并发管理工作队列" class="headerlink" title="48.2 什么是并发管理工作队列"></a>48.2 什么是并发管理工作队列</h2><p>通过上一小节的学习，我们认识到传统的工作队列无论是单核系统还是多核系统上都是有缺陷的。比如无法充分利用多核处理器的计算能力以及对于不同优先级的工作项无法提供公平的调度。为了解决这些问题，Con Kolivas提出了CMWQ调度算法。</p>
<p>CMWQ 全称是concurrency Managed Workqueue，意为并发管理工作队列。并发管理工作队列是一种并发编程模式，用于有效地管理和调度待执行的任务或工作项。它通常用于多线程或多进程环境中，以实现并发执行和提高系统的性能。CMWQ 工作实现如下图（48-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps94.jpg" alt="img"> </p>
<p>图 48-4</p>
<p>当我们需要在一个系统中同时处理多个任务或工作时，使用并发管理工作队列是一种有效的方式。</p>
<p>想象一下，你是一个餐厅的服务员，有很多顾客同时来到餐厅用餐。为了提高效率，你需要将顾客的点菜请求放到一个队列中，这就是工作队列。然后，你和其他服务员可以从队列中获取顾客的点菜请求，每个服务员独立地为顾客提供服务。通过这种方式，你们可以并发地处理多个顾客的点菜请求，而不需要等待上一个顾客点完菜再去处理下一个顾客的请求。每个服务员可以独立地从队列中获取任务，并根据需要执行相应的服务。这种独立获取任务的过程就是从工作队列中取出任务并执行的过程。</p>
<p>通过并发管理工作队列，你们能够更高效地处理顾客的点菜请求，提高服务的速度和质量。同时，这种方式也能够更好地利用你们的工作能力，因为每个服务员都可以独立处理任务，而不会相互干扰或等待。</p>
<p>总的来说，通过并发管理工作队列，我们可以同时处理多个任务或工作，提高系统的并发性和性能。每个任务独立地从队列中获取并执行，这种解耦使得整个系统更加高效、灵活，并且能够更好地应对多任务的需求。</p>
<h2 id="48-3-并发管理工作队列接口函数"><a href="#48-3-并发管理工作队列接口函数" class="headerlink" title="48.3 并发管理工作队列接口函数"></a>48.3 并发管理工作队列接口函数</h2><p>​	alloc_workqueue是Linux内核中的一个函数，用于创建和分配一个工作队列。工作队列是一种用于管理和调度工作项的机制，可用于实现并发处理和异步任务处理。alloc_workqueue函数的原型如下：</p>
<p>struct workqueue_struct *alloc_workqueue(const char *fmt, unsigned int flags, int max_active);</p>
<p>参数说明：</p>
<p>****fmt：****指定工作队列的名称格式。</p>
<p>****flags****：指定工作队列的标志，可以控制工作队列的行为和属性，如WQ_UNBOUND表示无绑定的工作队列，WQ_HIGHPRI表示高优先级的工作队列等。</p>
<p>****max_active****：指定工作队列中同时活跃的最大工作项数量。</p>
<p>函数返回一个指向工作队列结构体（struct workqueue_struct）的指针，或者返回NULL表示创建失败。</p>
<p>在下一小节中将使用上述API进行相应的实验。</p>
<h2 id="48-4-实验程序的编写"><a href="#48-4-实验程序的编写" class="headerlink" title="48.4 实验程序的编写"></a>48.4 实验程序的编写</h2><h3 id="45-4-1-驱动程序编写"><a href="#45-4-1-驱动程序编写" class="headerlink" title="45.4.1 驱动程序编写"></a>45.4.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\38_CMWQ\module。</p>
<p>本实验在35自定义工作队列实验的基础上进行修改，使用alloc_workqueue函数创建和分配一个工作队列。编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="48-5-运行测试"><a href="#48-5-运行测试" class="headerlink" title="48.5 运行测试"></a>48.5 运行测试</h2><h3 id="48-5-1-编译驱动程序"><a href="#48-5-1-编译驱动程序" class="headerlink" title="48.5.1 编译驱动程序"></a>48.5.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图48-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps95.jpg" alt="img"> </p>
<p>图 48-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图48-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps96.jpg" alt="img"></p>
<p>图 48-6</p>
<p>编译完生成interrupt.ko目标文件，如下图（图48-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps97.jpg" alt="img"> </p>
<p>图 48-7</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="48-5-2-运行测试"><a href="#48-5-2-运行测试" class="headerlink" title="48.5.2 运行测试"></a>48.5.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图48-8）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps98.jpg" alt="img"></p>
<p>图48-8</p>
<p>驱动加载之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（48-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps99.jpg" alt="img"></p>
<p>图 48-9</p>
<p>我们按一下屏幕，立即输入“ps -aux | grep test_workqueue”,可以看到工作线程，如下图（48-10）所示，u代表无绑定的工作队列。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps100.jpg" alt="img"></p>
<p>图 48-10</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图48-11）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps101.jpg" alt="img"></p>
<p>图 48-11</p>
<p>至此，并发管理工作队列实验就完成了。	</p>
<h1 id="第49章-中断线程化实验"><a href="#第49章-中断线程化实验" class="headerlink" title="第49章 中断线程化实验"></a>第49章 中断线程化实验</h1><p>中断线程化是实时Linux项目开发的一个新特性，目的是降低中断处理对系统实时延迟的影响。本章节我们来一项新技术——中断线程化。</p>
<h2 id="49-1什么是中断线程化"><a href="#49-1什么是中断线程化" class="headerlink" title="49.1什么是中断线程化"></a>49.1什么是中断线程化</h2><p>中断线程化是一种优化技术，用于提高多线程程序的性能。</p>
<p>想象一下，你正在做一项任务，但是总是被别人的打扰所中断，每次都要停下手头的工作去处理别人的事情。这样频繁的中断会让你的工作效率变低，因为你需要反复切换任务，无法专心做好自己的工作。</p>
<p>在多线程程序中，也存在类似的问题。有时硬件或其他事件会发出中断信号，打断正在执行的线程，需要切换到中断处理程序去处理这些事件。这种频繁的中断切换会导致额外的开销和延迟，影响程序的性能。</p>
<p>为了解决这个问题，中断线程化提出了一种优化方案。它将中断处理程序从主线程中独立出来，创建一个专门的线程来处理这些中断事件。这样，主线程就不再受到中断的干扰，可以专注于自己的工作，不再频繁地被打断。</p>
<p>中断线程化的核心思想是将中断处理和主线程的工作分开，让它们可以并行执行。中断线程负责处理中断事件，而主线程负责执行主要的工作任务。这样一来，不仅可以减少切换的开销，还可以提高整个程序的响应速度和性能。</p>
<p>需要注意的是，中断线程化还需要处理线程之间的同步和数据共享问题。因为中断线程和主线程可能会同时访问和修改共享的数据，所以需要合理地进行同步操作，确保数据的一致性和正确性。</p>
<p>总而言之，中断线程化是一种优化技术，通过将中断处理和主线程的工作分开，提高多线程程序的性能。让主线程不再频繁被中断，可以专注于自己的工作，从而提高程序的效率和响应速度。</p>
<p>中断线程化的处理仍然可以看作是将原来的中断上半部分和中断下半部分。上半部分还是用来处理紧急的事情，下半部分也是出路比较耗时的操作，但是下半部分会交给一个专门的内核线程来处理。这个内核线程只用于这个中断。当发生中断的时候，会唤醒这个内核线程，然后由这个内核线程来执行中断下半部分的函数。</p>
<h2 id="49-2-中断线程化接口函数"><a href="#49-2-中断线程化接口函数" class="headerlink" title="49.2 中断线程化接口函数"></a>49.2 中断线程化接口函数</h2><p>request_threaded_irq 是 Linux 内核中用于请求并注册一个线程化的中断处理函数的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p><em><strong>*参数说明*</strong></em></p>
<p>****irq****：中断号，表示要请求的中断线路。</p>
<p>****handler****：是在发生中断时首先要执行的处理程序，非常类似于顶半部，该函数最后会返回IRQ_WAKE_THREAD来唤醒中断，一般handler设为NULL，用系统提供的默认处理。</p>
<p>****thread_fn****：线程化的中断处理函数，非常类似于底半部。如果此处设置为NULL 则表示没有使用中断线程化。</p>
<p>****irqflags****：中断标志，用于指定中断的属性和行为。</p>
<p>****devname****：中断的名称，用于标识中断请求的设备。</p>
<p>****dev_id****：设备标识符，用于传递给中断处理函数的参数。</p>
<p><em><strong>*函数返回值*</strong></em></p>
<p>  函数返回一个整数值，表示中断请求的结果。如果中断请求成功，返回值为0，否则返回一个负数错误代码。</p>
<p>在下一小节中将使用上述API进行相应的实验，利用中断线程化相关知识来对共享工作队列实验进行优化。</p>
<h2 id="49-3-实验程序的编写"><a href="#49-3-实验程序的编写" class="headerlink" title="49.3 实验程序的编写"></a>49.3 实验程序的编写</h2><h3 id="49-3-1-驱动程序编写"><a href="#49-3-1-驱动程序编写" class="headerlink" title="49.3.1 驱动程序编写"></a>49.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\39_request_threaded_irq\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中提交工作项到工作队列中，打印“This id test_interrupt”，并打印“****This is test_work****”。</p>
<p>我们要实现一个简单的中断处理的例子，用于展示中断的顶半部和底半部处理的概念，并通过线程化的工作队列实现了底半部的延时处理。编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="49-4-运行测试"><a href="#49-4-运行测试" class="headerlink" title="49.4 运行测试"></a>49.4 运行测试</h2><h3 id="49-4-1-编译驱动程序"><a href="#49-4-1-编译驱动程序" class="headerlink" title="49.4.1 编译驱动程序"></a>49.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图49-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps102.jpg" alt="img"></p>
<p>图 49-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图49-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps103.jpg" alt="img"></p>
<p>图 49-2</p>
<p>编译完生成interrupt.ko目标文件，如下图（图49-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps104.jpg" alt="img"></p>
<p>图 49-3</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="49-4-2-运行测试"><a href="#49-4-2-运行测试" class="headerlink" title="49.4.2 运行测试"></a>49.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图49-4）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps105.jpg" alt="img"></p>
<p>图49-4</p>
<p>可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（49-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps106.jpg" alt="img"></p>
<p>图 49-5</p>
<p>我们按一下屏幕，立即输入“ps -aux | grep test_workqueue”,可以看到工作线程，如下图（49-6）所示，u代表无绑定的工作队列。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps107.jpg" alt="img"></p>
<p>图 49-6</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图49-7）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps108.jpg" alt="img"></p>
<p>图 49-7</p>
<p>至此，中断线程化实验就完成了。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>rk3568 驱动开发第四篇 高级字符设备进阶</title>
    <url>/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E5%9B%9B%E7%AF%87-%E9%AB%98%E7%BA%A7%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第25章-IO模型引入实验"><a href="#第25章-IO模型引入实验" class="headerlink" title="第25章 IO模型引入实验"></a>第25章 IO模型引入实验</h1><p>我们经常提到 IO、NIO 这些名词。那么，到底什么是 IO 呢？什么又是 NIO 呢？另外，我们平时又会听到两组很相似的概念：阻塞&#x2F;非阻塞、同步&#x2F;异步。那么，阻塞和非阻塞有什么区别呢？同步和异步的差别又在哪里呢？</p>
<p>为了更好的理解IO模型，在本章节将对IO的概念、IO的执行过程及IO模型的分类进行详细分析，下面就让我们一起进入IO的世界吧！</p>
<h2 id="25-1-IO的概念"><a href="#25-1-IO的概念" class="headerlink" title="25.1 IO的概念"></a>25.1 IO的概念</h2><p>IO是英文Input和Output的首字母，代表了输入和输出，当然这样的描述有一点点抽象，更直观的意思是计算机的输入与输出。在冯.诺依曼结构中，将计算机分成了5个部分，分别是运算器，控制器，存储器，输入设备，输出设备。如下图（图 25-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps173.jpg" alt="img"> </p>
<p>图 25-1</p>
<p>上图中的输入设备指的是鼠标和键盘等向计算机输入数据和信息的设备，输出设备指的是电脑显示器等用于计算机信息输出的设备，下面对计算机输入输出过程进行实际举例，当敲击键盘（输入设备）任意按键后，按键的数据会传递给计算机，计算机CPU会对数据进行运算，运算完成之后会将数据输出到显示器（输出设备）上，整个过程如下图（图 25-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps174.jpg" alt="img"> </p>
<p>图 25-2</p>
<p>上述事例中，鼠标、显示器只是输入输出的直观表现形式，而在计算机架构层面上，IO是涉及计算机核心与其他设备间数据迁移的过程。以磁盘IO为例，内存读取磁盘数据和将内存数据写入磁盘，就是一对输入输出的过程。</p>
<p>至此，对于IO的概念就讲解完成了，在下一小节中将对IO执行过程进行分析。</p>
<h2 id="25-2-IO执行过程"><a href="#25-2-IO执行过程" class="headerlink" title="25.2 IO执行过程"></a>25.2 IO执行过程</h2><p>操作系统（Linux）负责对计算机的资源进行管理和对进程进行调度，应用程序运行在操作系统上，处于用户空间。应用程序不能直接对硬件进行操作，只能通过操作系统提供的API来操作硬件。需要将进程切换到内核空间，才能进行IO操作，并且应用程序不能直接操作内核空间的数据，需要把内核空间的数据拷贝到用户空间。</p>
<p>应用程序运行在用户空间，它不存在实质的IO过程，真正的IO是在操作系统执行的。那么应用程序操作IO就会有两个动作：IO调用和IO执行。IO调用是应用程序向操作系统内核发起调用，IO执行是操作系统内核完成的IO操作。</p>
<p>一个完整的IO过程需要包含以下三个步骤，如下图（图25-3）所示：</p>
<p>（1） 用户空间的应用程序向内核发起IO调用请求(系统调用)</p>
<p>（2） 内核操作系统准备数据，把IO设备的数据加载到内核缓冲区</p>
<p>（3） 操作系统拷贝数据，把内核缓冲区的数据拷贝到用户进程缓冲区</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps175.jpg" alt="img"> </p>
<p>图 25-2</p>
<h2 id="25-3-IO模型的分类"><a href="#25-3-IO模型的分类" class="headerlink" title="25.3 IO模型的分类"></a>25.3 IO模型的分类</h2><p>假设有这样一个场景，从磁盘中循环读取100M的数据并处理，磁盘读取100M需要花费20秒的时间，CPU同样也需要20秒的时间处理完这些数据。如果采用传统的模式编写代码：读数据-&gt;等待数据读取完毕-&gt;数据处理，可以发现，数据的读取花费了一半的时间，而这就导致该任务的效率极其低下，那么能不能在等待数据的同时对数据进行处理呢？当然可以！这时候就轮到IO编程模型来出场了。</p>
<p>IO模型根据实现的功能可以划分为为阻塞IO、非阻塞IO、信号驱动IO， IO多路复用和异步IO。根据等待IO的执行结果进行划分，前四个IO模型又被称为同步IO，如下图（图 25-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps176.jpg" alt="img"> </p>
<p>图 25-4</p>
<p>所谓同步，即发出一个功能调用后，只有得到结果该调用才会返回。异步的概念和同步相对。当一个异步过程调用发出后，调用者并不能立刻得到结果，实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>
<p>以现实生活去餐馆吃饭为例，根据菜单进行点餐之后，这时会存在两个选择，第一个选择是在餐馆等待饭菜制作完毕，这就是同步IO的具体表现。第二个选择是，离开餐馆去做其他的事情，工作人员会在饭菜制作完成之后提醒你回餐馆取餐，这就是异步IO的具体表现。</p>
<p>下面让我们来认识一下这五种IO模型。</p>
<p><em><strong>*1 阻塞IO*</strong></em></p>
<p>以****阻塞读****为例：进程进行IO操作时(如read操作)，首先会发起一个系统调用，从而转到内核空间进行处理，内核空间的数据没有准备就绪时，进程会被阻塞，不会继续向下执行，直到内核空间的数据准备完成后，数据才会从内核空间拷贝到用户空间，最后返回用户进程，由用户空间进行数据的处理，如下图（图 25-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps177.jpg" alt="img"> </p>
<p>图 25-6</p>
<p>以现实生活中的钓鱼为例，在做好相应准备抛下鱼钩之后，需要耐心等待鱼儿的上钩，等待的过程中必须聚精会神的关注鱼竿的状态，鱼儿上钩之后立刻扬竿，这就是阻塞IO在实际生活中的事例。</p>
<p>通过上述例子可以总结出阻塞IO的优势与不足，首先可以及时的获取结果，并立刻对获取到的结果进行处理，然而在获取结果之前，无法去处理其他任务，需要时刻对结果进行监听。</p>
<p>阻塞IO比较有代表性的是C语言中的scanf()函数。编写好的io.c文件，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>,i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，scanf函数用于从键盘上接收数据，如果键盘不进行数据的输入，该任务会持续阻塞，只有键盘输入数据之后，才会有相应的输入值打印到系统终端上。输入以下命令进行可执行文件的编译，如下（图 25-7）所示</p>
<p>gcc io.c -o io</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps178.jpg" alt="img"> </p>
<p>图 25-8</p>
<p>编译完成之后，输入“.&#x2F;io”运行可执行文件，如下所示，键盘没有输入数据时，该任务会持续阻塞，当在键盘上输入“123”之后，输入的值才会被打印出来，如下（图 25-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps179.jpg" alt="img"> </p>
<p>图 25-9</p>
<p><em><strong>*2 非阻塞IO*</strong></em></p>
<p>和阻塞IO模型不同，非阻塞IO进行IO操作时，如果内核数据没有准备好，内核会立即向进程返回err，不会进行阻塞；如果内核空间数据准备就绪，内核会立即把数据返回给用户空间的进程，如下图（图 25-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps180.jpg" alt="img"> </p>
<p>图 25-10</p>
<p>仍旧以现实生活中钓鱼为例，在做好相应准备抛下鱼钩之后，这次并没有持续不断的关注鱼竿的状态，而是去做其他的事情（不阻塞等待结果），每隔几分钟对鱼竿的状态进行检查，如果没有鱼儿上钩，就继续去做其他事情，如果上钩了就把鱼钓上来,这就是非阻塞IO在实际生活中的事例。</p>
<p>从上述案例中可以看出非阻塞IO的优点是效率高，同样的时间可以做更多的事。但是缺点也很明显，需要不断对结果进行轮询查看，从而导致结果获取不及时（结果可能在两次轮询之间就已经准备完毕，但是只能在发起轮询的时候才能知道），如果要增加非阻塞IO的实时性，就要加快轮询的频率，但这样无疑也会增加CPU的负担。</p>
<p><em><strong>*3 IO多路复用*</strong></em></p>
<p>通常情况下使用select()、poll()、epoll()函数实现IO多路复用。这里以select函数为例进行讲解，使用时可以对select传入多个描述符，并设置超时时间。当执行select的时候，系统会发起一个系统调用，内核会遍历检查传入的描述符是否有事件发生（如可读、可写事件）。如有，立即返回，否则进入睡眠状态，使进程进入阻塞状态，直到任何一个描述符事件产生后（或者等待超时）立刻返回。此时用户空间需要对全部描述符进行遍历，以确认具体是哪个发生了事件，这样就能使用一个进程对多个IO进行管理，如下图（图 25-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps181.jpg" alt="img"> </p>
<p>图 25-11</p>
<p>继续以现实生活中的钓鱼为例，和之前案例只有一个鱼竿不同，这次会在十个不同的地方做好相应准备抛下鱼钩，并把十个鱼竿连在了一个铃铛上，这样只要铃铛响了就表示有鱼上钩，只需挨个检查到底是哪个鱼竿有鱼上钩即可。</p>
<p>这样的优点是一个进程&#x2F;线程可以同时监听和处理多路IO，效率成倍提高。但是IO多路复用并不是能医治百病的良药，虽然IO多路复用可以监听多个IO，但是实际上对结果的处理也只能依次进行，比较适合IO密集但是每一路IO数据量不多且到达时间分散的场合（如网络聊天）。</p>
<p>另外select监听的描述符有上限（一般描述符最大不超过1024），而且需要遍历究竟是哪一个IO产生了数据。因此IO较多时，效率不高（这个问题被epoll解决，感兴趣的读者可以自行了解）。</p>
<p><em><strong>*4 信号驱动*</strong></em></p>
<p>信号驱动IO顾名思义与信号相关。系统在一些事件发生之后，会对进程发出特定的信号，而信号与处理函数相绑定，当信号产生时就会调用绑定的处理函数。例如在Linux系统任务执行的过程中可以按下ctrl+C来对任务进行终止，系统实际上是对该进程发送一个SIGINT信号，该信号的默认处理函数就是退出当前程序。</p>
<p>具体到IO模型上，可以对SIGIO信号注册相应的信号处理函数，并打开对应描述符的信号驱动。每当有IO数据产生时，系统就会发送一个SIGIO信号，进而调用相应的信号处理函数，从而在这个处理函数中对数据进行读取，如下图（图 25-12）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps182.jpg" alt="img"> </p>
<p>图 25-12</p>
<p>仍旧以现实生活中的钓鱼为例，在做好相应准备抛下鱼钩之后，这次同样没有持续不断的关注鱼竿的状态，而是去做其他的事情（不阻塞等待结果），与之前不同的是，在鱼竿处绑定了一个提醒铃铛，当鱼咬钩之后，铃铛就会响(有SIGIO信号)，进而得知到鱼儿上钩的消息之，这样就可以及时把鱼钓上来了(调用处理函数)。</p>
<p><em><strong>*5 异步IO*</strong></em></p>
<p>aio_read函数常常用于异步IO，当进程使用aio_read读取数据时，如果数据尚未准备就绪就立即返回，不会阻塞。若数据准备就绪就会把数据从内核空间拷贝到用户空间的缓冲区中，然后执行定义好的回调函数对接收到的数据进行处理。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps183.jpg" alt="img"> </p>
<p>图 25-13</p>
<p>最后，还是以钓鱼为例。小马同学喜欢吃新鲜的鱼，但是不想自己钓，所以他请了一个助手来帮他钓鱼，他自己去忙其他的事情（进程不阻塞，立即返回）。如果有鱼上钩助手会帮忙钓上来（将数据拷贝到指定的缓冲区），并立即通知小马同学回来把鱼取走（处理数据）。</p>
<h1 id="第26章-阻塞IO实验"><a href="#第26章-阻塞IO实验" class="headerlink" title="第26章  阻塞IO实验"></a>第26章  阻塞IO实验</h1><p>在上一章节，对IO的相关概念和五种IO模型分类进行了学习，在接下来的章节中将分别对四种同步IO进行详细的讲解和实验，本章节要讲解的IO模型是阻塞IO，阻塞IO在Linux内核中是非常常用的IO模型，所依赖的机制是等待队列。下面让我们来开始阻塞IO的学习吧。</p>
<h2 id="26-1-什么是等待队列"><a href="#26-1-什么是等待队列" class="headerlink" title="26.1 什么是等待队列"></a>26.1 什么是等待队列</h2><p>在Linux驱动程序中，阻塞进程可以使用等待队列来实现。等待队列是内核实现阻塞和唤醒的内核机制，以双循环链表为基础结构，由链表头和链表项两部分组成，分别表示等待队列头和等待队列元素，如下图（图26-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps184.jpg" alt="img"> </p>
<p>图26-1</p>
<p>等待队列头使用结构体wait_queue_head_t 来表示，等待队列头是一个等待队列的头部，这个结构体定义在文件include&#x2F;linux&#x2F;wait.h里面，结构体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">wait_queue_head</span>&#123;</span></span><br><span class="line"><span class="type">spinlock_t</span> lock;    <span class="comment">//自旋锁</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span> //链表头</span></span><br><span class="line"><span class="class">&#125;；</span></span><br><span class="line"><span class="class"><span class="title">typefef</span> <span class="keyword">struct</span> _<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br></pre></td></tr></table></figure>

<p>等待队列项使用结构体wait_queue_t来表示，等待队列项是等待队列元素，该结构体同样定义在文件include&#x2F;linux&#x2F;wait.h里面，结构体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">wait_queue</span>&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">void</span> *private;</span><br><span class="line"><span class="type">wait_queue_func_t</span> func;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">wait_queue</span> <span class="title">wait_queue_t</span>;</span></span><br></pre></td></tr></table></figure>

<h2 id="26-2-等待队列API函数"><a href="#26-2-等待队列API函数" class="headerlink" title="26.2 等待队列API函数"></a>26.2 等待队列API函数</h2><p><em><strong>*1 定义并初始化等待队列头*</strong></em></p>
<p>等待队列要想被使用，第一步就是对等待队列头进行初始化，有俩种办法如下所示：</p>
<p>方法一：使用 DECLARE_WAIT_QUEUE_HEAD宏静态创建等待队列头，宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WAIT_QUEUE_HEAD(name) \</span></span><br><span class="line"><span class="meta">wait_queue_head_t name = __WAIT_QUEUE_HEAD_INITIALIZER(name)</span></span><br></pre></td></tr></table></figure>

<p>参数name表示要定义的队列头名字。通常以全局变量的方式定义,如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DECLARE_WAIT_QUEUE_HEAD(head);</span><br></pre></td></tr></table></figure>

<p>方法二：使用init_waitqueue_head宏动态初始化等待队列头，宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> init_waitqueue_head(q)				\</span></span><br><span class="line"><span class="meta">	do &#123;						\</span></span><br><span class="line"><span class="meta">		static struct lock_class_key __key;	\</span></span><br><span class="line"><span class="meta">							\</span></span><br><span class="line"><span class="meta">		__init_waitqueue_head((q), #q, &amp;__key);	\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>参数q表示需要初始化的队列头指针。使用宏定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">wait_queue_head_t</span> head;       <span class="comment">//等待队列头</span></span><br><span class="line">init_waitqueue_head(&amp;head);    <span class="comment">//初始化等待队列头指针</span></span><br></pre></td></tr></table></figure>



<p>然后再来学习如何创建等待队列元素，也就是等待队列项。</p>
<p><em><strong>*2 创建等待队列项*</strong></em></p>
<p>一般使用宏 DECLARE_WAITQUEUE(name,tsk)给当前正在运行的进程创建并初始化一个等待队列项，宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WAITQUEUE(name, tsk)						\</span></span><br><span class="line"><span class="meta">struct wait_queue_entry name = __WAITQUEUE_INITIALIZER(name, tsk)</span></span><br></pre></td></tr></table></figure>

<p>第一个参数name是等待队列项的名字，第二个参数tsk表示此等待队列项属于哪个任务（进程），一般设置为current。在Linux内核中current相当于一个全局变量，表示当前进程。创建等待队列项如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DECLARE_WAITQUEUE(wait,current);  <span class="comment">//给当前正在运行的进程创建一个名为wait的等待队列项。</span></span><br><span class="line">add_wait_queue(wq,&amp;wait); <span class="comment">//将wait这个等待队列项加到wq这个等待队列当中</span></span><br></pre></td></tr></table></figure>

<p><em><strong>*3添加&#x2F;删除队列*</strong></em></p>
<p>当设备没有准备就绪（如没有可读数据）而需要进程阻塞的时候，就需要将进程对应的等待队列项添加到前面创建的等待队列中，只有添加到等待队列中以后进程才能进入休眠态。当设备可以访问时（如有可读数据），再将进程对应的****等待队列项****从等待队列中移除即可。</p>
<p>等待队列项添加队列函数如下所示：</p>
<p><em><strong>*函数原型:*</strong></em></p>
<p>  void add_wait_queue(wait_queue_head_t *q,wait_queue_t *wait)</p>
<p><em><strong>*函数功能:*</strong></em></p>
<p> (通过等待队列头)向等待队列中添加队列项</p>
<p><em><strong>*参数含义:*</strong></em></p>
<p> wq_head表示等待队列项要加入等待队列的等待队列头</p>
<p>wq_entry表示要加入的等待队列项</p>
<p><em><strong>*函数返回值*</strong></em>  </p>
<p>无</p>
<p>等待队列项移除队列函数如下所示：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>void remove_wait_queue(wait_queue_head_t *q,wait_queue_t *wait)</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>要删除的等待队列项所处的等待队列头</p>
<p><em><strong>*函数含义：*</strong></em></p>
<p>第一个参数q表示等待队列项要加入等待队列的等待队列头</p>
<p>第二个参数wait表示要加入的等待队列项</p>
<p><em><strong>*函数返回值：*</strong></em></p>
<p>无</p>
<p><em><strong>*4等待事件*</strong></em></p>
<p>除了主动唤醒以外，也可以设置等待队列等待某个事件，当这个事件满足以后就自动唤醒等待队列中的进程，使用如下所示的宏，是不可中断的阻塞等待。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __wait_event(wq_head, condition)					\</span></span><br><span class="line"><span class="meta">(void)___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 0, 0,	\</span></span><br><span class="line"><span class="meta">schedule())</span></span><br></pre></td></tr></table></figure>

<p><em><strong>*宏定义功能：*</strong></em></p>
<p>不可中断的阻塞等待，让调用进程进入不可中断的睡眠状态，在等待队列里面睡眠直到condition变成真，被内核唤醒。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>第一个参数wq: wait_queue_head_t 类型变量</p>
<p>第二个参数condition : 等待条件，为假时才可以进入休眠。如果condition为真，则不会休眠</p>
<p>除此之外，wait_event_interruptible的宏是可中断的阻塞等待。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __wait_event_interruptible(wq_head, condition)				\</span></span><br><span class="line"><span class="meta">___wait_event(wq_head, condition, TASK_INTERRUPTIBLE, 0, 0,		\</span></span><br><span class="line"><span class="meta">schedule())</span></span><br></pre></td></tr></table></figure>



<p><em><strong>*宏含义功能：*</strong></em></p>
<p>可中断的阻塞等待，让调用进程进入可中断的睡眠状态，直到condition变成真被内核唤醒或信号打断唤醒。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>第一个参数wq :wait_queue_head_t 类型变量</p>
<p>第二个参数condition :等待条件。为假时才可以进入休眠。如果condition为真，则不会休眠。</p>
<p>wait_event_timeout() 宏也与 wait_event()类似.不过如果所给的睡眠时间为负数则立即返回.如果在睡眠期间被唤醒,且condition 为真则返回剩余的睡眠时间,否则继续睡眠直到到达或超过给定的睡眠时间,然后返回 0。</p>
<p>wait_event_interruptible_timeout() 宏与 wait_event_timeout()类似,不过如果在睡眠期间被信号打断则返回 ERESTARTSYS 错误码。</p>
<p>wait_event_interruptible_exclusive() 宏同样和 wait_event_interruptible()一样,不过该睡眠的进程是一个互斥进程</p>
<p>注意：调用的时要确认 condition 值是真还是假，如果调用 condition 为真，则不会休眠。</p>
<p><em><strong>*5等待队列唤醒*</strong></em></p>
<p>当设备可以使用的时候就要唤醒进入休眠态的进程，唤醒可以使用如下俩个函数</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>wake_up(wait_queue_head_t *q)</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>唤醒所有休眠进程</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>q表示要唤醒的等待队列的等待队列头</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>wake_up_interruptible(wait_queue_head_t *q)</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>唤醒可中断的休眠进程</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>q表示要唤醒的等待队列的等待队列头</p>
<h2 id="26-3-等待队列使用方法"><a href="#26-3-等待队列使用方法" class="headerlink" title="26.3 等待队列使用方法"></a>26.3 等待队列使用方法</h2><p>步骤一：初始化等待队列头，并将条件置成假(condition&#x3D;0)。</p>
<p>步骤二：在需要阻塞的地方调用wait_event()，使进程进入休眠状态。</p>
<p>步骤三：当条件满足时，需要解除休眠，先将条件(condition&#x3D;1),然后调用wake_up函数唤醒等待队列中的休眠进程。</p>
<h2 id="26-4-实验程序编写"><a href="#26-4-实验程序编写" class="headerlink" title="26.4 实验程序编写"></a>26.4 实验程序编写</h2><h3 id="26-4-1-驱动程序编写"><a href="#26-4-1-驱动程序编写" class="headerlink" title="26.4.1 驱动程序编写"></a>26.4.1 驱动程序编写</h3><p>本实验对应的驱动网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\20\module。</p>
<p>接着编写等待队列的实验代码，在此代码中，按照上一小节等待队列使用方法的三个步骤进行编写，在read函数中调用wait_event_interruptible函数阻塞，使进程进入休眠状态。在write函数中唤醒等待队列中的休眠进程。编写好的驱动程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span>  flag;  <span class="comment">//标志位</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  </span><br><span class="line"></span><br><span class="line">DECLARE_WAIT_QUEUE_HEAD(read_wq); <span class="comment">//定义并初始化等待队列头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test_dev-&gt;flag=<span class="number">1</span>;<span class="comment">//将条件置1</span></span><br><span class="line">    wake_up_interruptible(&amp;read_wq); <span class="comment">//并使用wake_up_interruptible唤醒等待队列中的休眠进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    wait_event_interruptible(read_wq,test_dev-&gt;flag); <span class="comment">//可中断的阻塞等待，使进程进入休眠态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="26-4-2-编写测试-APP"><a href="#26-4-2-编写测试-APP" class="headerlink" title="26.4.2 编写测试 APP"></a>26.4.2 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\20\app。</p>
<p>接下来编写应用程序read.c，此程序实现了从设备读取数据的功能。编写好的应用程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开led驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read before \n&quot;</span>);</span><br><span class="line">    read(fd,buf1,<span class="keyword">sizeof</span>(buf1));  <span class="comment">//从/dev/test文件读取数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf is %s  \n&quot;</span>,buf1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read after \n&quot;</span>);</span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理 ，编写应用程序write.c，实现向设备写入数据的功能，编写好的应用程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开led驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write before \n&quot;</span>);</span><br><span class="line">    write(fd,buf2,<span class="keyword">sizeof</span>(buf2));  <span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;write after\n&quot;</span>);</span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-5运行测试"><a href="#26-5运行测试" class="headerlink" title="26.5运行测试"></a>26.5运行测试</h2><h3 id="26-5-1编译驱动程序"><a href="#26-5-1编译驱动程序" class="headerlink" title="26.5.1编译驱动程序"></a>26.5.1编译驱动程序</h3><p>在上一小节中的wq.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += wq.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放wq.c和Makefile文件目录下，如下图（图 26-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps185.jpg" alt="img"> </p>
<p>图 26-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 26-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps186.jpg" alt="img"> </p>
<p>图 26-3</p>
<p>编译完生成 wq.ko目标文件，如下图（图 26-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps187.jpg" alt="img"> </p>
<p>图 26-4</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="26-5-2-编译应用程序"><a href="#26-5-2-编译应用程序" class="headerlink" title="26.5.2 编译应用程序"></a>26.5.2 编译应用程序</h3><p>来到存放应用程序read.c和write.c的文件夹下，使用以下命令对read.c和write.c进行交叉编译，编译完成如下图（图 26-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o read read.c -static</p>
<p>aarch64-linux-gnu-gcc -o write write.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps188.jpg" alt="img"> </p>
<p>图 26-4</p>
<p>生成的read write文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="26-5-3-运行测试"><a href="#26-5-3-运行测试" class="headerlink" title="26.5.3 运行测试"></a>26.5.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 26-5）所示：</p>
<p>insmod wq.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps189.jpg" alt="img"></p>
<p>图 26-5</p>
<p>输入以下命令运行read可执行文件，如下图（图 26-6）所示，read应用程序进程阻塞</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps190.jpg" alt="img"></p>
<p>图 26-6</p>
<p>然后输入以下命令运行write可执行文件，如下图（图 26-7）所示，使用write函数向设备写入数据，唤醒等待队列中的休眠进程。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps191.jpg" alt="img"></p>
<p>图 26-7</p>
<p>在使用可执行程序write向缓冲区写入数据时，read可执行程序读取到了缓冲区的数据并打印。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps192.jpg" alt="img"></p>
<p>图 26-8</p>
<h1 id="第27章-非阻塞IO实验"><a href="#第27章-非阻塞IO实验" class="headerlink" title="第27章 非阻塞IO实验"></a>第27章 非阻塞IO实验</h1><p>上个章节中我们学习了阻塞IO，阻塞IO是通过等待队列来实现的，那么如何让驱动实现非阻塞呢？带着疑问，让我们开始本章节非阻塞IO的学习吧！</p>
<h2 id="27-1-非阻塞IO简介"><a href="#27-1-非阻塞IO简介" class="headerlink" title="27.1 非阻塞IO简介"></a>27.1 非阻塞IO简介</h2><p>应用程序可以使用如下所示示例代码来实现阻塞访问：</p>
<p>int fd;</p>
<p>int data &#x3D; 0;</p>
<p>fd &#x3D; open(“&#x2F;dev&#x2F;xxx_dev”, <em><strong>*O_RDWR*</strong></em>);  &#x2F;* 阻塞方式打开 *&#x2F;</p>
<p>ret &#x3D; read(fd, &amp;data, sizeof(data));   &#x2F;* 读取数据 *&#x2F;</p>
<p>可以看出对于设备驱动文件的默认读取方式就是阻塞式的，所以之前实验例程测试 APP 都是采用阻塞 IO。</p>
<p>如果应用程序要采用非阻塞的方式来访问驱动设备文件，可以使用如下所示代码：</p>
<p>int fd;</p>
<p>int data &#x3D; 0;</p>
<p>fd &#x3D; open(“&#x2F;dev&#x2F;xxx_dev”, <em><strong>*O_RDWR | O_NONBLOCK*</strong></em>); &#x2F;* 非阻塞方式打开 *&#x2F;</p>
<p>ret &#x3D; read(fd, &amp;data, sizeof(data)); &#x2F;* 读取数据 *&#x2F;</p>
<p>使用 open 函数打开“&#x2F;dev&#x2F;xxx_dev”设备文件的时候添加了参数“O_NONBLOCK”，表示以非阻塞方式打开设备，这样从设备中读取数据的时候是非阻塞方式了。</p>
<h2 id="27-2-实验程序编写"><a href="#27-2-实验程序编写" class="headerlink" title="27.2 实验程序编写"></a>27.2 实验程序编写</h2><h3 id="27-2-1-编写测试-APP"><a href="#27-2-1-编写测试-APP" class="headerlink" title="27.2.1 编写测试 APP"></a>27.2.1 编写测试 APP</h3><p>非阻塞IO实验需要应用程序和驱动配合，所以需要编写驱动代码和应用测试代码。</p>
<p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\21\app。</p>
<p>首先来编写应用测试代码read.c，在此代码中使用非阻塞的方式打开设备，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;  <span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//定义读取缓冲区buf</span></span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//定义读取缓冲区buf</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR| O_NONBLOCK);  <span class="comment">//打开/dev/test设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read before \n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         read(fd,buf1,<span class="keyword">sizeof</span>(buf1));  <span class="comment">//从/dev/test文件读取数据</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;buf is %s \n&quot;</span>,buf1);  <span class="comment">//打印读取的数据</span></span><br><span class="line">         sleep(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read after\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着编写应用程序write.c，用来向设备文件写入数据，编写好的应用程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR|O_NONBLOCK);  <span class="comment">//打开/dev/test设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write before \n&quot;</span>);</span><br><span class="line">    write(fd,buf2,<span class="keyword">sizeof</span>(buf2));  <span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;write after\n&quot;</span>);</span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="27-2-1-驱动程序编写"><a href="#27-2-1-驱动程序编写" class="headerlink" title="27.2.1 驱动程序编写"></a>27.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\21\module。</p>
<p> 编写好的驱动程序wq.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span>  flag;  <span class="comment">//标志位</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  </span><br><span class="line"></span><br><span class="line">DECLARE_WAIT_QUEUE_HEAD(read_wq); <span class="comment">//定义并初始化等待队列头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test_dev-&gt;flag=<span class="number">1</span>;    <span class="comment">//将条件置1，并使用wake_up_interruptible唤醒等待队列中的休眠进程</span></span><br><span class="line">    wake_up_interruptible(&amp;read_wq); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span>(file-&gt;f_flags &amp; O_NONBLOCK )&#123;</span><br><span class="line">        <span class="keyword">if</span> (test_dev-&gt;flag !=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    &#125;</span><br><span class="line">    wait_event_interruptible(read_wq,test_dev-&gt;flag); <span class="comment">//可中断的阻塞等待，使进程进入休眠态</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="27-3-运行测试"><a href="#27-3-运行测试" class="headerlink" title="27.3 运行测试"></a>27.3 运行测试</h2><h3 id="27-3-1-编译驱动程序"><a href="#27-3-1-编译驱动程序" class="headerlink" title="27.3.1 编译驱动程序"></a>27.3.1 编译驱动程序</h3><p>在上一小节中的wq.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += wq.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放wq.c和Makefile文件目录下，如下图（图 27-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps193.jpg" alt="img"> </p>
<p>图 27-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图27-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps194.jpg" alt="img"> </p>
<p>图 27-2</p>
<p>编译完生成 wq.ko目标文件，如下图（图 27-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps195.jpg" alt="img"> </p>
<p>图 27-3</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="27-3-2-编译应用程序"><a href="#27-3-2-编译应用程序" class="headerlink" title="27.3.2 编译应用程序"></a>27.3.2 编译应用程序</h3><p>来到存放应用程序read.c和write.c的文件夹下，使用以下命令对read.c和write.c进行交叉编译，编译完成如下图（图 27-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o read read.c -static</p>
<p>aarch64-linux-gnu-gcc -o write write.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps196.jpg" alt="img"> </p>
<p>图 27-4</p>
<p>生成的read write文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="27-3-3-测试"><a href="#27-3-3-测试" class="headerlink" title="27.3.3 测试"></a>27.3.3 测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 27-5）所示：</p>
<p>insmod wq.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps197.jpg" alt="img"></p>
<p>图 27-5</p>
<p>输入以下命令运行read可执行文件，如下图（图 27-6）所示，应用程序进程非阻塞，读取不到数据便返回，然后一直轮询查看是否有数据。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps198.jpg" alt="img"></p>
<p>图 27-6</p>
<p>然后输入以下命令运行write可执行文件向设备文件写入数据，如下图（图 27-7）所示:</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps199.jpg" alt="img"></p>
<p>图 27-7</p>
<p>在使用可执行程序write向缓冲区写入数据时，read可执行程序读取到了缓冲区的数据并打印。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps200.jpg" alt="img"></p>
<p>图 27-8</p>
<h1 id="第28章-IO多路复用实验"><a href="#第28章-IO多路复用实验" class="headerlink" title="第28章 IO多路复用实验"></a>第28章 IO多路复用实验</h1><p>在上俩个章节中，我们对阻塞IO和非阻塞IO进行了学习，本章节将学习第三种IO模型-多路复用IO。</p>
<h2 id="28-1-IO多路复用简介"><a href="#28-1-IO多路复用简介" class="headerlink" title="28.1 IO多路复用简介"></a>28.1 IO多路复用简介</h2><p>IO多路复用是一种同步的IO模型。IO多路复用可以实现一个进程监视多个文件描述符。一旦某个文件描述符准备就绪，就通知应用程序进行相应的读写操作。没有文件描述符就绪时就会阻塞应用程序，从而释放出CPU资源。</p>
<p>在第25章中，我们以钓鱼为例，对IO多路复用有了一个简单的认识。下面对钓鱼例子进行回顾：小李同时放置了十个鱼竿，并把十个鱼竿连在了一个铃铛上。这样小李就不必在岸边等待。当铃铛响了就表示有鱼上钩，再回来挨个检查到底是哪个鱼竿有鱼上钩即可。接着进一步体会IO多路复用。</p>
<p>在应用层Linux提供了三种实现IO多路复用的模型，分别是select、poll 和 epoll。在本驱动手册中主要偏重于对驱动的讲解，所以应用层中select、poll 和 epoll函数的使用在这里不做重点讲解。</p>
<p>首先来学习下select、poll 和 epoll函数有什么区别呢？poll函数和seslect函数都可以监听多个文件描述符，通过轮询来获取已经准备好的文件描述符。但是epoll函数将主动轮询变成了被动通知，当事件发生时被动接收通知。为了方便理解，举个形象的例子。假如poll和select是公司的前台，某天一位客户来公司找硬件工程师-小李，请求前台帮忙找人。于是poll和select前台带着这位客户挨个屋子寻找小李，直到找到小李为止。假如epoll是公司的前台，他提前统计了公司每个员工的工位。当客户来找小李的时候，不必像poll select一样，可以直接带着客户到硬件部门去找小李。从上面的俩个例子，明显对比epoll的效率更高。假如公司园区很大，那么poll select需要花费很长时间寻找小李，而epoll已经提前知道小李坐在哪个工位了，直接带客户去找小李即可。</p>
<p>select,poll,epoll有什么区别呢？在单个线程中，select函数最大可以监视1024个文件描述符，而poll函数和select函数并没有什么区别，只是poll函数没有最大文件描述符的限制。在本章节的实验中，以poll为例进行实验。在Linux应用程序中poll函数如下所示：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int poll(struct pollfd *fds,</p>
<p>nfds_t nfds,</p>
<p>int timeout);</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>监视并等待多个文件描述符的属性变化</p>
<p><em><strong>*函数参数：*</strong></em></p>
<p><em><strong>*第一个参数fds*</strong></em>: 要监视的文件描述符集合以及要监视的事件，为一个数组，数组元素都是结构体pollfd类型，pollfd结构体如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"><span class="type">int</span> fd;       <span class="comment">//被监视的文件描述符</span></span><br><span class="line"><span class="type">short</span> events;  <span class="comment">//等待的事件</span></span><br><span class="line"><span class="type">short</span> revents;  <span class="comment">//实际发生的事件</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>在pollfd结构体中，第一个成员fd是被监视的文件描述符。第二个成员events是要监视的事件，可监视的事件类型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POLLIN   有数据可以读取</span><br><span class="line">POLLPRI  有紧急的数据需要读取</span><br><span class="line">POLLOUT  可以写数据</span><br><span class="line">POLLERR   指定的文件描述符发生错误</span><br><span class="line">POLLHUP   指定的文件描述符挂起</span><br><span class="line">POLLNVAL  无效的请求</span><br><span class="line">POLLRDNORM  等同于POLLIN</span><br></pre></td></tr></table></figure>

<p>第三个成员是返回事件，由Linux内核设置具体的返回事件。</p>
<p><em><strong>*第二个参数nfds*</strong></em>: poll函数要监视的文件描述符数量</p>
<p><em><strong>*第三个参数timeout*</strong></em>:指定等待的时间，单位是ms。无论I&#x2F;O是否准备好，时间到POLL就会返回。如果timepoll大于0 等待指定的时间，如果timeout等于0，立即返回。如果timeout等于-1，事件发生以后才返回。</p>
<p><em><strong>*函数返回值：*</strong></em></p>
<p>失败返回-1，成功返回revents不为0的文件描述符个数。</p>
<p>当应用程序使用select或者poll函数对驱动程序进行非阻塞访问时，驱动程序中file_operations操作集的poll函数会执行。所以需要完善驱动中的poll函数。驱动中的poll函数原型如下所示：</p>
<p>unsigned int (*poll)(struct file *filp,struct poll_table_struct *wait);</p>
<p><em><strong>*函数参数：*</strong></em></p>
<p>filp:要打开的文件描述符</p>
<p>wait: 结构体poll_table_struct类型指针，此参数是由应用程序中传递的。一般此参数要传递给poll_wait函数。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>向应用程序返回资源状态，可以返回的资源状态如下：</p>
<p>POLLIN  有数据可以读取</p>
<p>POLLPRI  有紧急的数据需要读取</p>
<p>POLLOUT  可以写数据</p>
<p>POLLERR  指定的文件描述符发生错误</p>
<p>POLLHUP  指定的文件描述符挂起</p>
<p>POLLNVAL  无效的请求</p>
<p>POLLRDNORM 等同于POLLIN，普通数据可读。</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>这个函数要进行下面两项工作。首先，对可能引起设备文件状态变化的等待队列调用poll_wait(),将对应的等待队列头添加到poll_table.然后返回表示是否能对设备进行无阻塞读写访问的掩码。</p>
<p>驱动程序的poll函数中调用poll_wait函数，注意！poll_wait函数是不会引起阻塞的。poll_wait函数原型如下所示：</p>
<p>void poll_wait(struct file *filp,wait_queue_head_t *queue,poll_table *wait);</p>
<p>参数queue是要添加到poll_table中的等待队列头，参数wait是poll_table，也就是file_operations中poll函数的wait参数。</p>
<h2 id="28-2-实验程序编写"><a href="#28-2-实验程序编写" class="headerlink" title="28.2 实验程序编写"></a>28.2 实验程序编写</h2><h3 id="28-2-1-编写测试-APP"><a href="#28-2-1-编写测试-APP" class="headerlink" title="28.2.1 编写测试 APP"></a>28.2.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\22\app。</p>
<p>在应用层Linux提供了三种API函数，分别是select poll和epoll。本次实验使用poll函数进行实验，如果对select 和epoll函数感兴趣，可以查找一些系统编程课程学习。</p>
<p>编写好的应用程序read.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;  <span class="comment">//要监视的文件描述符</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>  <span class="title">fds</span>[1];</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开/dev/test设备，阻塞式访问</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//构造结构体</span></span><br><span class="line">    fds[<span class="number">0</span>] .fd =fd;</span><br><span class="line">    fds[<span class="number">0</span>].events = POLLIN; <span class="comment">//监视数据是否可以读取</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read before \n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = poll(fds,<span class="number">1</span>,<span class="number">3000</span>);  <span class="comment">//轮询文件是否可操作，超时3000ms</span></span><br><span class="line">    <span class="keyword">if</span>(!ret)&#123;  <span class="comment">//超时</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;time out !!\n,&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(fds[<span class="number">0</span>].revents == POLLIN) <span class="comment">//如果返回事件是有数据可读取</span></span><br><span class="line">    &#123;</span><br><span class="line">        read(fd,buf1,<span class="keyword">sizeof</span>(buf1));  <span class="comment">//从/dev/test文件读取数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf is %s \n,&quot;</span>,buf1); <span class="comment">//打印读取的数据</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read after\n&quot;</span>);</span><br><span class="line">close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码第16行，在打开设备节点时不使用非阻塞方式，要使用阻塞方式，所以改为O_RDWR。</p>
<p>在上述代码的第28行，使用poll函数监视并等待多个文件描述符的属性变化。poll函数第一个参数是被监视的文件描述符，是pollfd结构体类型的数组，所以在14行定义了pollfd结构体类型的数组fds。poll函数第2个参数是要监视的文件描述符数量，这里监视的文件描述符为1个。poll函数第3个参数是指定等待的时间 3000ms。</p>
<p>然后编写应用程序write.c，实现向设备文件写入数据的功能，编写好的write.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR);  <span class="comment">//打开/dev/test设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write before \n&quot;</span>);</span><br><span class="line">    write(fd,buf2,<span class="keyword">sizeof</span>(buf2));  <span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;write after\n&quot;</span>);</span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="28-2-2-驱动程序编写"><a href="#28-2-2-驱动程序编写" class="headerlink" title="28.2.2 驱动程序编写"></a>28.2.2 驱动程序编写</h3><p>本实验对应的驱动程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\22\module。</p>
<p>IO多路复用实验需要应用程序和驱动程序进行配合，接下来编写驱动程序。编写好的驱动程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span>  flag;  <span class="comment">//标志位</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  </span><br><span class="line">DECLARE_WAIT_QUEUE_HEAD(read_wq); <span class="comment">//定义并初始化等待队列头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test_dev-&gt;flag=<span class="number">1</span>;</span><br><span class="line">    wake_up_interruptible(&amp;read_wq);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span>(file-&gt;f_flags &amp; O_NONBLOCK )&#123;</span><br><span class="line">        <span class="keyword">if</span> (test_dev-&gt;flag !=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    &#125;</span><br><span class="line">    wait_event_interruptible(read_wq,test_dev-&gt;flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span>  <span class="type">__poll_t</span>  <span class="title function_">cdev_test_poll</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> poll_table_struct *p)</span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;  <span class="comment">//设置私有数据</span></span><br><span class="line">     <span class="type">__poll_t</span> mask=<span class="number">0</span>;    </span><br><span class="line">     poll_wait(file,&amp;read_wq,p);     <span class="comment">//应用阻塞</span></span><br><span class="line">     <span class="keyword">if</span> (test_dev-&gt;flag == <span class="number">1</span>)    </span><br><span class="line">     &#123;</span><br><span class="line">         mask |= POLLIN; </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> mask; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">    .poll = cdev_test_poll,  <span class="comment">//将poll字段指向chrdev_poll(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>首先在第9行代码添加&lt;linux&#x2F;poll.h&gt;头文件。然后在第94行将poll字段指向chrdev_poll(…)函数，最后在73行到84行编写这个函数。</p>
<h2 id="28-3-运行测试"><a href="#28-3-运行测试" class="headerlink" title="28.3 运行测试"></a>28.3 运行测试</h2><h3 id="28-3-1-编译驱动程序"><a href="#28-3-1-编译驱动程序" class="headerlink" title="28.3.1 编译驱动程序"></a>28.3.1 编译驱动程序</h3><p>在上一小节中的poll.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += poll.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放poll.c和Makefile文件目录下，如下图（图 28-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps201.jpg" alt="img"> </p>
<p>图 28-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 28-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps202.jpg" alt="img"> </p>
<p>图 28-2</p>
<p>编译完生成poll.ko目标文件，如下图（图 28-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps203.jpg" alt="img"></p>
<p>图 28-3</p>
<p>至此驱动模块就编译成功了，下面进行应用程序read.c和write.c的编译。</p>
<h3 id="28-3-2-编译应用程序"><a href="#28-3-2-编译应用程序" class="headerlink" title="28.3.2 编译应用程序"></a>28.3.2 编译应用程序</h3><p>来到存放应用程序read.c和write.c的文件夹下，使用以下命令对read.c和write.c进行交叉编译，编译完成如下图（图 28-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o read read.c -static</p>
<p>aarch64-linux-gnu-gcc -o write write.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps204.jpg" alt="img"> </p>
<p>图 28-4</p>
<p>生成的read write文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="28-3-3-测试"><a href="#28-3-3-测试" class="headerlink" title="28.3.3 测试"></a>28.3.3 测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 28-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps205.jpg" alt="img"></p>
<p>图 28-5</p>
<p>在加载驱动程序之后，会生成如下图（图 28-6）所示的设备节点，在应用程序中也是操作这个设备节点。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps206.jpg" alt="img"></p>
<p>图 28-6</p>
<p>首先运行read可执行程序，如下（图 28-7）所示，在三秒钟以后打印“time out”。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps207.jpg" alt="img"></p>
<p>图 28-7</p>
<p>然后运行write可执行程序写入数据，如下（图 28-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps208.jpg" alt="img"></p>
<p>图 28-8</p>
<p>接着可以看到read读取到了数据，如下（图 28-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps209.jpg" alt="img"></p>
<p>图 28-9</p>
<h1 id="第29章-信号驱动IO实验"><a href="#第29章-信号驱动IO实验" class="headerlink" title="第29章 信号驱动IO实验"></a>第29章 信号驱动IO实验</h1><p>本章节要讲解的信号驱动IO是最后一个IO模型，在第25章中我们已经对信号驱动IO有了基本的认识，本章节将对信号驱动IO进行深入的学习，最后通过相应的实验，来加深对信号驱动IO的理解。</p>
<h2 id="29-1-信号驱动IO简介"><a href="#29-1-信号驱动IO简介" class="headerlink" title="29.1 信号驱动IO简介"></a>29.1 信号驱动IO简介</h2><p>信号驱动IO不需要应用程序查询设备的状态，一旦设备准备就绪，会触发SIGIO信号，进而调用注册的处理函数。仍旧以钓鱼为例。小马同学喜欢吃新鲜的鱼，但是不想自己钓，所以他请了一个助手来帮他钓鱼，他自己去忙其他的事情（进程不阻塞，立即返回）。如果有鱼上钩助手会帮忙钓上来（将数据拷贝到指定的缓冲区），并立即通知小马同学回来把鱼取走（处理数据）。</p>
<p>如果要实现信号驱动IO，需要应用程序和驱动程序配合，应用程序使用信号驱动IO的步骤有三步：</p>
<p>步骤1 ：注册信号处理函数 应用程序使用signal函数来注册SIGIO信号的信号处理函数。</p>
<p>步骤2： 设置能够接收这个信号的进程</p>
<p>步骤3： 开启信号驱动IO 通常使用fcntl函数的F_SETFL命令打开FASYNC标志。</p>
<p>fcntl函数如下所示：</p>
<p>****函数原型****： </p>
<p>int fcntl(int fd,int cmd, …)</p>
<p>****函数功能****： </p>
<p>fcntl函数可以用来操作文件描述符</p>
<p><em><strong>*函数参数*</strong></em>:</p>
<p>fd: 被操作的文件描述符</p>
<p>cmd: 操作文件描述符的命令，cmd参数决定了要如何操作文件描述符fd</p>
<p>…: 根据cmd的参数来决定是不是需要使用第三个参数</p>
<p>操作文件描述符的命令如下表（表 29-1）所示：</p>
<table>
<thead>
<tr>
<th>命令名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>F_DUPFD</td>
<td>复制文件描述符</td>
</tr>
<tr>
<td>F_GETFD</td>
<td>获取文件描述符标志</td>
</tr>
<tr>
<td>F_SETFD</td>
<td>设置文件描述符标志</td>
</tr>
<tr>
<td>F_GETFL</td>
<td>获取文件状态标志</td>
</tr>
<tr>
<td>F_SETFL</td>
<td>设置文件状态标志</td>
</tr>
<tr>
<td>F_GETLK</td>
<td>获取文件锁</td>
</tr>
<tr>
<td>F_SETLK</td>
<td>设置文件锁</td>
</tr>
<tr>
<td>F_SETLKW</td>
<td>类似F_SETLK，但等待返回</td>
</tr>
<tr>
<td>F_GETOWN</td>
<td>获取当前接收SIGIO和SIGURG信号的进程ID和进程组ID</td>
</tr>
<tr>
<td>F_SETOWN</td>
<td>设置当前接收SIGIO和SIGURG信号的进程ID和进程组ID</td>
</tr>
</tbody></table>
<p>表 29-2</p>
<p>接下来学习驱动程序实现fasync方法</p>
<p>步骤1 </p>
<p>当应用程序开启信号驱动IO时，会触发驱动中的fasync函数。所以首先在file_operations结构体中实现fasync函数，函数原型如下：</p>
<p>int (*fasync) (int fd,struct file *filp,int on)</p>
<p>步骤2</p>
<p>在驱动中的fasync函数调用fasync_helper函数来操作fasync_struct结构体，fasync_helper函数原型如下：</p>
<p>int fasync_helper(int fd,struct file *filp,int on,struct fasync_struct **fapp)</p>
<p>步骤3：</p>
<p>当设备准备好的时候，驱动程序需要调用kill_fasync函数通知应用程序，此时应用程序的SIGIO信号处理函数就会被执行。kill_fasync负责发送指定的信号，函数原型如下：</p>
<p>void kill_fasync(struct fasync_struct **fp,int sig,int band)</p>
<p><em><strong>*函数参数：*</strong></em></p>
<p>fp: 要操作的fasync_struct</p>
<p>sig: 发送的信号</p>
<p>band: 可读的时候设置成POLLIN ，可写的时候设置成POLLOUT</p>
<h2 id="29-2-实验程序编写"><a href="#29-2-实验程序编写" class="headerlink" title="29.2 实验程序编写"></a>29.2 实验程序编写</h2><h3 id="29-2-1-编写测试-APP"><a href="#29-2-1-编写测试-APP" class="headerlink" title="29.2.1 编写测试 APP"></a>29.2.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\23\app。</p>
<p>编写应用程序write.c，在此代码中，调用write函数向&#x2F;dev&#x2F;test设备写入数据“nihao”。编写好的程序如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    char buf1[32] = &#123;0&#125;;   </span><br><span class="line">    char buf2[32] = &quot;nihao&quot;;</span><br><span class="line">    fd = open(&quot;/dev/test&quot;,O_RDWR);  //打开/dev/test设备</span><br><span class="line">    if (fd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;open error \n&quot;);</span><br><span class="line">        return fd;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;write before \n&quot;);</span><br><span class="line">    write(fd,buf2,sizeof(buf2));  //向/dev/test文件写入数据</span><br><span class="line">    printf(&quot;write after\n&quot;);</span><br><span class="line">    close(fd);     //关闭文件</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后来编写应用程序read.c，在此代码中要使用信号驱动IO读取数据。编写好的应用程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//SIGIO信号的信号处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> signum)</span></span><br><span class="line">&#123;</span><br><span class="line">    read(fd,buf1,<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;buf is %s\n&quot;</span>,buf1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">       fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开led驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signal(SIGIO,func);  <span class="comment">//步骤一：使用signal函数注册SIGIO信号的信号处理函数</span></span><br><span class="line">     <span class="comment">//步骤二：设置能接收这个信号的进程</span></span><br><span class="line">     <span class="comment">//fcntl函数用来操作文件描述符，</span></span><br><span class="line">     <span class="comment">//F_SETOWN 设置当前接收的SIGIO的进程ID</span></span><br><span class="line">     fcntl(fd,F_SETOWN,getpid()); </span><br><span class="line"></span><br><span class="line">    flags = fcntl(fd,F_GETFD); <span class="comment">//获取文件描述符标志</span></span><br><span class="line">    <span class="comment">//步骤三  开启信号驱动IO 使用fcntl函数的F_SETFL命令打开FASYNC标志</span></span><br><span class="line">    fcntl(fd,F_SETFL,flags| FASYNC);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);    </span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="29-2-2-驱动程序编写"><a href="#29-2-2-驱动程序编写" class="headerlink" title="29.2.2 驱动程序编写"></a>29.2.2 驱动程序编写</h3><p>本实验对应的驱动程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\23\module。</p>
<p>接下来编写驱动程序，在29.1小节中介绍了驱动程序中实现fasync方法的三个步骤，按照这个思路，依次实现这三步，编写好的驱动程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span>  flag;  <span class="comment">//标志位</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  </span><br><span class="line"></span><br><span class="line">DECLARE_WAIT_QUEUE_HEAD(read_wq); <span class="comment">//定义并初始化等待队列头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test_dev-&gt;flag=<span class="number">1</span>;</span><br><span class="line">    wake_up_interruptible(&amp;read_wq);</span><br><span class="line">    kill_fasync(&amp;test_dev-&gt;fasync,SIGIO,POLLIN);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span>(file-&gt;f_flags &amp; O_NONBLOCK )&#123;</span><br><span class="line">        <span class="keyword">if</span> (test_dev-&gt;flag !=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    &#125;</span><br><span class="line">    wait_event_interruptible(read_wq,test_dev-&gt;flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span>  <span class="type">__poll_t</span>  <span class="title function_">cdev_test_poll</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> poll_table_struct *p)</span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;  <span class="comment">//设置私有数据</span></span><br><span class="line">     <span class="type">__poll_t</span> mask=<span class="number">0</span>;    </span><br><span class="line">     poll_wait(file,&amp;read_wq,p);     <span class="comment">//应用阻塞</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (test_dev-&gt;flag == <span class="number">1</span>)    </span><br><span class="line">     &#123;</span><br><span class="line">         mask |= POLLIN;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> mask;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_fasync</span> <span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;  <span class="comment">//设置私有数据</span></span><br><span class="line">    <span class="keyword">return</span>  fasync_helper(fd,file,on,&amp;test_dev-&gt;fasync);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">    .poll = cdev_test_poll,  <span class="comment">//将poll字段指向chrdev_poll(...)函数</span></span><br><span class="line">    .fasync = cdev_test_fasync,   <span class="comment">//将fasync字段指向cdev_test_fasync(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="29-3-运行测试"><a href="#29-3-运行测试" class="headerlink" title="29.3 运行测试"></a>29.3 运行测试</h2><h3 id="29-3-1-编译程序"><a href="#29-3-1-编译程序" class="headerlink" title="29.3.1 编译程序"></a>29.3.1 编译程序</h3><p>在上一小节中的fasync.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m +=fasync.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放fasync.c.c和Makefile文件目录下，如下图（图 29-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps210.jpg" alt="img"> </p>
<p>图 29-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图29-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps211.jpg" alt="img"> </p>
<p>图 29-3</p>
<p>编译完生成fasync.ko目标文件，如下图（图 29-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps212.jpg" alt="img"> </p>
<p>图 29-4</p>
<p>至此驱动模块就编译成功了，下面进行交叉编译应用程序。</p>
<h3 id="29-3-2-编译应用程序"><a href="#29-3-2-编译应用程序" class="headerlink" title="29.3.2 编译应用程序"></a>29.3.2 编译应用程序</h3><p>来到存放应用程序read.c和write.c的文件夹下，使用以下命令对read.c和write.c进行交叉编译，编译完成如下图（图 29-5）所示：</p>
<p>aarch64-linux-gnu-gcc -o read read.c -static</p>
<p>aarch64-linux-gnu-gcc -o write write.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps213.jpg" alt="img"> </p>
<p>图 29-5</p>
<p>生成的read write文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="29-3-3-测试"><a href="#29-3-3-测试" class="headerlink" title="29.3.3 测试"></a>29.3.3 测试</h3><p>输入以下命令加载驱动程序。</p>
<p>insmod fasync.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps214.jpg" alt="img"></p>
<p>图 29-6</p>
<p>输入以下命令运行read应用程序，如下图（图 29-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps215.jpg" alt="img"></p>
<p>图 29-7</p>
<p>然后输入以下命令运行write应用程序，如下图（图 29-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps216.jpg" alt="img"></p>
<p>图 29-8</p>
<p>如下图（图29-9）所示，read程序窗口打印读取的数据。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps217.jpg" alt="img"></p>
<p>图 29-9</p>
<h1 id="第30章-定时器实验"><a href="#第30章-定时器实验" class="headerlink" title="第30章 定时器实验"></a>第30章 定时器实验</h1><p>在Linux内核中很多函数是基于定时器进行驱动的，所以时间管理在内核中占有非常重要的地位。本小节将对Linux中的时间管理相关知识进行学习.</p>
<h2 id="30-1-Linux定期器"><a href="#30-1-Linux定期器" class="headerlink" title="30.1 Linux定期器"></a>30.1 Linux定期器</h2><p>硬件为内核提供了一个系统定时器来计算流逝的时间（即基于未来时间点的计时方式，以当前时刻为计时开始的起点，以未来的某一时刻为计时的终点），内核只有在系统定时器的帮助下才能计算和管理时间，但是内核定时器的精度并不高，所以不能作为高精度定时器使用。并且内核定时器的运行没有周期性，到达计时终点后会自动关闭。如果要实现周期性定时，就要在定时处理函数中重新开启定时器。</p>
<p>Linux内核中使用timer_list 结构体表示内核定时器，该结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;timer.h”文件中，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct timer_list &#123;</span><br><span class="line">    struct hlist_node   entry;</span><br><span class="line">    unsigned long       expires;/* 定时器超时时间，单位是节拍数 */</span><br><span class="line">    void            (*function)(struct timer_list *);/* 定时处理函数 */</span><br><span class="line">    u32         flags;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_LOCKDEP</span><br><span class="line">    struct lockdep_map  lockdep_map;</span><br><span class="line">#endif</span><br><span class="line">    ANDROID_KABI_RESERVE(1);</span><br><span class="line">    ANDROID_KABI_RESERVE(2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用以下宏对timer_list结构体进行定义，_name为定义的结构体名称，_function为定时处理函数，该宏同样定义在文件 “内核源码&#x2F;include&#x2F;linux&#x2F;timer.h”文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_TIMER(_name, _function)              \</span></span><br><span class="line"><span class="meta">struct timer_list _name =               \</span></span><br><span class="line"><span class="meta">    __TIMER_INITIALIZER(_function, 0)     </span></span><br></pre></td></tr></table></figure>

<p>例如可以使用以下代码对定时器和相应的定时处理函数进行定义 </p>
<p>DEFINE_TIMER(timer_test,function_test);&#x2F;&#x2F;定义一个定时器</p>
<p>定时器定义完成之后还需要通过一系列的 API 函数来初始化此定时器，部分函数说明如下(表30-1)所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void add_timer(struct timer_list *timer)</td>
<td>向 Linux 内核注册定时器，使用 add_timer 函数向内核注册定时器以后，定时器就会开始运行</td>
</tr>
<tr>
<td>int del_timer(struct timer_list * timer)</td>
<td>删除一个定时器</td>
</tr>
<tr>
<td>int mod_timer(struct timer_list *timer,unsigned long expires)</td>
<td>修改定时值，如果定时器还没有激活的话，mod_timer 函数会激活定时器</td>
</tr>
</tbody></table>
<p>表 	30-1</p>
<p>在使用add_timer()函数向 Linux 内核注册定时器之前，还需要设置定时时间，定时时间由timer_list结构体中的expires参数所确定，单位为节拍数，可以通过图形化界面设置系统节拍的频率，具体路径如下图(图 30-2)所示：</p>
<p>-&gt; Kernel Features</p>
<p>-&gt; Timer frequency (<choice> [&#x3D;y])</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps218.jpg" alt="img"> </p>
<p>图 30-2</p>
<p>​	从上图可以看出可选的系统节拍率为 100Hz、250Hz、300Hz和 1000Hz，默认情况下选择 300Hz。</p>
<p>通过全局变量jiffies来记录自系统启动以来产生节拍的总数。启动时，内核将该变量初始化为0，此后，每次时钟中断处理程序都会增加该变量的值，一秒内jiffes增加的值为设置的系统节拍数，该变量定义在”内核源码&#x2F;include&#x2F;linux&#x2F;jiffies.h”文件中（timer.h文件中已经包含，不需要重复引用），具体定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern u64 __cacheline_aligned_in_smp jiffies_64;</span><br><span class="line">extern unsigned long volatile __cacheline_aligned_in_smp __jiffy_arch_data jiffies;</span><br></pre></td></tr></table></figure>

<p>​	其中jiffies_64用于64位系统，而jiffies用于 32 位系统。为了方便开发，Linux 内核还提供了几个jiffies和ms、us、ns之间的转换函数，如下(表 30-2)所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>int jiffies_to_msecs(const unsigned long j)</td>
<td>将 jiffies 类型的参数 j 分别转换为对应的毫秒</td>
</tr>
<tr>
<td>int jiffies_to_usecs(const unsigned long j)</td>
<td>将 jiffies 类型的参数 j 分别转换为对应的微秒</td>
</tr>
<tr>
<td>u64 jiffies_to_nsecs(const unsigned long j)</td>
<td>将 jiffies 类型的参数 j 分别转换为对应的纳秒</td>
</tr>
<tr>
<td>long msecs_to_jiffies(const unsigned int m)</td>
<td>将毫秒转换为 jiffies 类型</td>
</tr>
<tr>
<td>long usecs_to_jiffies(const unsigned int u)</td>
<td>将微秒转换为 jiffies 类型</td>
</tr>
<tr>
<td>unsigned long nsecs_to_jiffies(u64 n)</td>
<td>将纳秒转换为 jiffies 类型</td>
</tr>
</tbody></table>
<p>表 30-3</p>
<p>​	例如可以使用以下命令进行3秒钟的定时：</p>
<p>timer_test.expires &#x3D; jiffies_64 +msecs_to_jiffies(3000) </p>
<p>至此关于Linux定时器相关的知识就讲解完成了，在下个小节中将进行相应的实验。</p>
<h2 id="30-2-实验程序编写"><a href="#30-2-实验程序编写" class="headerlink" title="30.2 实验程序编写"></a>30.2 实验程序编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\24\module。</p>
<p>本实验将实现五秒钟的计时，五秒钟之后将打印“this is function test”相关字符，为了实现循环打印还需要在定时处理函数中使用mod_timer函数重新设置定时时间。</p>
<p> 编写好的驱动程序timer_mod.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">function_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span>;<span class="comment">//定义function_test定时功能函数</span></span><br><span class="line">DEFINE_TIMER(timer_test,function_test);<span class="comment">//定义一个定时器</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">function_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;this is function test \n&quot;</span>);</span><br><span class="line">	mod_timer(&amp;timer_test,jiffies_64 + msecs_to_jiffies(<span class="number">5000</span>));<span class="comment">//使用mod_timer函数将定时时间设置为五秒后</span></span><br><span class="line">&#125;	</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_mod_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">	timer_test.expires = jiffies_64 + msecs_to_jiffies(<span class="number">5000</span>);<span class="comment">//将定时时间设置为五秒后</span></span><br><span class="line">	add_timer(&amp;timer_test);<span class="comment">//添加一个定时器</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_mod_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">	del_timer(&amp;timer_test);<span class="comment">//删除一个定时器</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_mod_init);</span><br><span class="line">module_exit(timer_mod_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="30-3-运行测试"><a href="#30-3-运行测试" class="headerlink" title="30.3 运行测试"></a>30.3 运行测试</h2><h3 id="30-3-1-编译驱动程序"><a href="#30-3-1-编译驱动程序" class="headerlink" title="30.3.1 编译驱动程序"></a>30.3.1 编译驱动程序</h3><p>在上一小节中的timer_mod.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m += timer_mod.o    #此处要和你的驱动源文件同名</span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    #make操作</span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    #make clean操作</span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放timer_mod.c和Makefile文件目录下，如下图()所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps219.jpg" alt="img"> </p>
<p>图 30-4</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图30-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps220.jpg" alt="img"> </p>
<p>图30-5</p>
<p>编译完生成 timer_mod.ko目标文件，如下图（图 30-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps221.jpg" alt="img"> </p>
<p>图 30-6</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="30-3-2-运行测试"><a href="#30-3-2-运行测试" class="headerlink" title="30.3.2 运行测试"></a>30.3.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 30-7）所示：</p>
<p>insmod timer_mod.ko </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps222.jpg" alt="img"> </p>
<p>图 30-7</p>
<p>可以看到驱动加载之后，每隔五秒钟会打印“this is function test”相关打印，证明编写的驱动程序没有问题，最后使用以下命令卸载相应的驱动，如下图（图30-8）所示：</p>
<p>rmmod timer_mod.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps223.jpg" alt="img"> </p>
<p>图 30-8</p>
<h1 id="第31章-秒字符设备驱动实验"><a href="#第31章-秒字符设备驱动实验" class="headerlink" title="第31章 秒字符设备驱动实验"></a>第31章 秒字符设备驱动实验</h1><p>本章节将实现秒字符设备驱动，以此对之前学习到的知识进行巩固。本章节实验要实现的任务如下：</p>
<p>\1. 实现字符设备驱动框架，自动生成设备节点。</p>
<p>\2. 根据上一小节学到的知识，实现秒计时。</p>
<p>\3. 通过原子变量来记录递增的秒数，避免竞争的发生。</p>
<p>\4. 通过用户空间和内核空间的数据交换，将记录的秒数传递到应用空间，并通过应用程序打印出来。</p>
<h2 id="31-1-实验程序编写"><a href="#31-1-实验程序编写" class="headerlink" title="31.1 实验程序编写"></a>31.1 实验程序编写</h2><h3 id="31-1-1-编写测试-APP"><a href="#31-1-1-编写测试-APP" class="headerlink" title="31.1.1 编写测试 APP"></a>31.1.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\25\app。</p>
<p>首先来编写应用测试代码timer.c，在此代码中每隔一秒钟打印从用户空间传递来的秒数，具体代码内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符fd</span></span><br><span class="line">	<span class="type">int</span> count;<span class="comment">//定义int类型记录秒数的变量count</span></span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR);<span class="comment">//使用open()函数以可读可写的方式打开设备文件</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		read(fd,&amp;count,<span class="keyword">sizeof</span>(count));<span class="comment">//使用read函数读取内核传递来的秒数</span></span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;num is %d\n&quot;</span>,count);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="31-1-2-驱动程序编写"><a href="#31-1-2-驱动程序编写" class="headerlink" title="31.1.2 驱动程序编写"></a>31.1.2 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\25\module。</p>
<p> 编写好的驱动程序timer_dev.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">	<span class="type">int</span> sec; <span class="comment">//秒</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">atomic64_t</span> v = ATOMIC_INIT(<span class="number">0</span>);<span class="comment">//定义原子类型变量v，并定义为0</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">function_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span>;<span class="comment">//定义function_test定时功能函数</span></span><br><span class="line">DEFINE_TIMER(timer_test,function_test);<span class="comment">//定义一个定时器</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">function_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span></span><br><span class="line">&#123;</span><br><span class="line">	atomic64_inc(&amp;v);<span class="comment">//原子变量v自增</span></span><br><span class="line">	dev1.sec = <span class="type">atomic_read</span>(&amp;v);<span class="comment">//将读取到的原子变量v,赋值给sec</span></span><br><span class="line">	<span class="comment">//printk(&quot;the sec is %d\n&quot;,dev1.sec);</span></span><br><span class="line">	mod_timer(&amp;timer_test,jiffies_64 + msecs_to_jiffies(<span class="number">1000</span>));<span class="comment">//使用mod_timer函数将定时时间设置为一秒后</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">	add_timer(&amp;timer_test);	<span class="comment">//添加一个定时器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(copy_to_user(buf,&amp;dev1.sec,<span class="keyword">sizeof</span>(dev1.sec)))&#123;<span class="comment">//使用copy_to_user函数将sec传递到应用层</span></span><br><span class="line">		printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	del_timer(&amp;timer_test);<span class="comment">//删除一个定时器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_dev_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  	dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_dev_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_dev_init);</span><br><span class="line">module_exit(timer_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="31-2-运行测试"><a href="#31-2-运行测试" class="headerlink" title="31.2 运行测试"></a>31.2 运行测试</h2><h3 id="31-2-1-编译驱动程序"><a href="#31-2-1-编译驱动程序" class="headerlink" title="31.2.1 编译驱动程序"></a>31.2.1 编译驱动程序</h3><p>在上一小节中的timer_dev.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += timer_dev.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放timer_dev.c和Makefile文件目录下，如下图（图31-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps224.jpg" alt="img"> </p>
<p>图31-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 31-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps225.jpg" alt="img"> </p>
<p>图 31-2</p>
<p>编译完生成 timer_dev.ko目标文件，如下图（图 31-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps226.jpg" alt="img"> </p>
<p>图 31-3</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="31-2-2-编译应用程序"><a href="#31-2-2-编译应用程序" class="headerlink" title="31.2.2 编译应用程序"></a>31.2.2 编译应用程序</h3><p>然后来到存放应用程序timer.c的文件夹下，使用以下命令对timer.c进行交叉编译，编译完成如下图（图 31-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o timer timer.c</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps227.jpg" alt="img"> </p>
<p>图 31-4</p>
<p>生成的timer文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="31-2-3-运行测试"><a href="#31-2-3-运行测试" class="headerlink" title="31.2.3 运行测试"></a>31.2.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 31-5）所示：</p>
<p>insmod timer_dev.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps228.jpg" alt="img"> </p>
<p>图 31-5</p>
<p>然后输入以下命令进行可执行程序的运行，如下图（图 31-6）所示：</p>
<p>.&#x2F;timer</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps229.jpg" alt="img"> </p>
<p>图 31-6</p>
<p>可以看到每隔一秒钟就会打印由内核空间传递来的秒数，我们要实现的任务就完成了，最后使用以下命令卸载对应的驱动，如下图（图 31-7）所示：</p>
<p>rmmod timer_dev</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps230.jpg" alt="img"> </p>
<p>图 31-7</p>
<p>第32章 Linux内核打印实验 </p>
<p>本手册的实验都是在buildroot系统上完成的，由于buildroot系统已经设置了相应的打印等级，所以驱动的相关打印都能正常显示在串口终端上，如果将实验系统换成了ubuntu，然后加载同样的驱动，会发现打印信息不见了，这一现象的基本原因就是内核打印等级不同，那打印等级是如何修改的呢，查看打印等级的方式又有哪些呢，就让我们进入本章节的学习吧！</p>
<h2 id="32-1-方法一：dmseg-命令"><a href="#32-1-方法一：dmseg-命令" class="headerlink" title="32.1 方法一：dmseg 命令"></a>32.1 方法一：dmseg 命令</h2><p>在终端使用dmseg命令可以获取内核打印信息，该命令的具体使用方法如下所示：</p>
<p>dmesg命令</p>
<p>****英文全称：****display message（显示信息）</p>
<p><em><strong>*作用*</strong></em>****：****kernel 会将打印信息存储在 ring <a href="https://so.csdn.net/so/search?q=buffer&spm=1001.2101.3001.7020">buffer</a> 中。可以利用 dmesg命令来查看内核打印信息。。</p>
<p><em><strong>*常用参数:*</strong></em></p>
<p>-C，–clear清除内核环形缓冲区</p>
<p>-c，—-read-clear读取并清除所有消息</p>
<p>-T，–显示时间戳</p>
<p>****提示：****dmesg命令也可以与grep命令组合使用。如查找待用usb关键字的打印信息，就可以使用如下命令:dmseg | grep usb</p>
<p>首先在串口终端使用“dmseg”命令，可以看见相应的内核打印信息已经加载了出来，如下图（图 32-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps231.jpg" alt="img"> </p>
<p>图 32-1</p>
<p>然后使用以下组合命令查找nfs相关的打印信息，如下图（图 32-2）所示：</p>
<p>dmesg | grep nfs</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps232.jpg" alt="img"> </p>
<p>图 32-2</p>
<p>至此关于dmesg命令就讲解演示完成了。</p>
<h2 id="32-2-方法二：查看kmsg文件"><a href="#32-2-方法二：查看kmsg文件" class="headerlink" title="32.2 方法二：查看kmsg文件"></a>32.2 方法二：查看kmsg文件</h2><p>内核所有的打印信息都会输出到循环缓冲区 ‘log_buf’，为了能够方便的在用户空间读取 内核打印信息，Linux内核驱动将该循环缓冲区映射到了&#x2F;proc目录下的文件节点kmsg。通过 cat或者其他应用程序读取Log Buffer的时候可以不断的等待新的log，所以访问&#x2F;proc&#x2F;kmsg 的方式适合长时间的读取log，一旦有新的log就可以被打印出来。</p>
<p>首先使用以下命令读取kmsg文件，在没有新的内核打印信息时会阻塞，如下图（图 32-3）所示：</p>
<p>cat &#x2F;proc&#x2F;kmsg</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps233.jpg" alt="img"> </p>
<p>图 32-3</p>
<p>然后在该设备的其他终端加载任意有打印信息的驱动文件（这里使用的是ssh），如下图（图 32-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps234.jpg" alt="img"> </p>
<p>图 32-4</p>
<p>在串口终端中可以看到对应驱动的打印信息就被打印了出来，如下图（图 32-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps235.jpg" alt="img"> </p>
<p>图 32-5</p>
<h2 id="32-3-方法三：调整内核打印等级"><a href="#32-3-方法三：调整内核打印等级" class="headerlink" title="32.3 方法三：调整内核打印等级"></a>32.3 方法三：调整内核打印等级</h2><p>内核的日志打印由相应的打印等级来控制，可以通过调整内核打印等级来控制打印日志的输出。使用以下命令查看当前默认打印等级，如下图（图 32-6）所示:</p>
<p>cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;printk</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps236.jpg" alt="img"> </p>
<p>图 32-6</p>
<p>可以看到内核打印等级由四个数字所决定，“7 4 1 7” 分别对应console_loglevel、default_message_loglevel、minimum_c onsole_loglevel、default_console_loglevel，具体类型说明如下表（表 32-7）所示：</p>
<table>
<thead>
<tr>
<th>终端打印类型</th>
<th>对应类型说明</th>
</tr>
</thead>
<tbody><tr>
<td>console_loglevel</td>
<td>只有当printk打印消息的log优先级高于console_loglevel时，才能输出到终端上</td>
</tr>
<tr>
<td>default_message_loglevel</td>
<td>printk打印消息时默认的log等级</td>
</tr>
<tr>
<td>minimum_console_loglevel</td>
<td>console_loglevel可以被设置的最小值</td>
</tr>
<tr>
<td>default_console_loglevel</td>
<td>console_loglevel的缺省值</td>
</tr>
</tbody></table>
<p>表 32-7</p>
<p>上面的“7 4 1 7”意味着只有优先级高于KERN_DEBUG(7)的打印消息才能输出到终端，在“内核源码&#x2F;include&#x2F;linux&#x2F;kern_levels.h”文件中对于文件打印等级进行了如下打印等级定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_EMERG  KERN_SOH <span class="string">&quot;0&quot;</span>    <span class="comment">/* system is unusable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ALERT  KERN_SOH <span class="string">&quot;1&quot;</span>    <span class="comment">/* action must be taken immediately */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_CRIT   KERN_SOH <span class="string">&quot;2&quot;</span>    <span class="comment">/* critical conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ERR    KERN_SOH <span class="string">&quot;3&quot;</span>    <span class="comment">/* error conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_WARNING    KERN_SOH <span class="string">&quot;4&quot;</span>    <span class="comment">/* warning conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_NOTICE KERN_SOH <span class="string">&quot;5&quot;</span>    <span class="comment">/* normal but significant condition */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_INFO   KERN_SOH <span class="string">&quot;6&quot;</span>    <span class="comment">/* informational */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_DEBUG  KERN_SOH <span class="string">&quot;7&quot;</span>    <span class="comment">/* debug-level messages */</span></span></span><br></pre></td></tr></table></figure>

<p>printk在打印信息前，可以加入相应的打印等级宏定义，具体格式如下所示：</p>
<p>printk(打印等级 “打印信息”)</p>
<p>接下来将使用以下驱动例程进行实际的打印等级测试：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot; 0000 KERN_EMERG\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot; 1111 KERN_ALERT\n&quot;</span>);</span><br><span class="line">    printk(KERN_CRIT <span class="string">&quot; 2222 KERN_CRIT\n&quot;</span>);</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot; 3333 KERN_ERR\n&quot;</span>);</span><br><span class="line">    printk(KERN_WARNING <span class="string">&quot; 4444 KERN_WARNING\n&quot;</span>);</span><br><span class="line">    printk(KERN_NOTICE <span class="string">&quot; 5555 KERN_NOTICE\n&quot;</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot; 6666 KERN_INFO\n&quot;</span>);</span><br><span class="line">    printk(KERN_DEBUG <span class="string">&quot; 7777 KERN_DEBUG\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot; 8888 no_fix\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);</span><br><span class="line">module_exit(helloworld_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>加载该驱动之后，第5-11行0-6等级的打印信息就被打印了出来，第13行由于没有设置打印等级，所以会被赋予默认打印等级4，高于console_loglevel打印等级，所以也会被打印出来，最后只有第12行打印等级为7的信息，和console_loglevel打印等级相同，所以不会被打印出来，如下图（图 32-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps237.jpg" alt="img"> </p>
<p>图 32-8</p>
<p>然后使用以下命令将console_loglevel打印等级设置为4，如下图（图 32-9）所示：</p>
<p>echo 4 4 1 7 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;printk</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps238.jpg" alt="img"> </p>
<p>图 32-9</p>
<p>卸载驱动之后，再一次加载驱动，发现只有打印等级高于4的相关信息被打印了出来，如下图（图32-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps239.jpg" alt="img"> </p>
<p>图32-10</p>
<p>至此关于内核打印等级的实验就结束了。</p>
<h1 id="第33章llseek定位设备驱动实验"><a href="#第33章llseek定位设备驱动实验" class="headerlink" title="第33章llseek定位设备驱动实验"></a>第33章llseek定位设备驱动实验</h1><p>相信经过了前面章节的学习，大家已经对内核空间与用户空间的数据交互很是熟悉，但在之前的例子中都是对字符串的全部内容进行读写，假如现在有这样一个场景，将两个字符串依次进行写入，并对写入完成的字符串进行读取，如果仍采用之前的方式，第二次的写入值会覆盖第一次写入值，那要如何来实现上述功能呢？这就要轮到llseek出场了。</p>
<h2 id="33-1-定位设备llseek"><a href="#33-1-定位设备llseek" class="headerlink" title="33.1 定位设备llseek"></a>33.1 定位设备llseek</h2><h3 id="33-1-1-lseek函数的使用"><a href="#33-1-1-lseek函数的使用" class="headerlink" title="33.1.1 lseek函数的使用"></a>33.1.1 lseek函数的使用</h3><p>在应用程序中使用lseek函数进行读写位置的调整，该函数的具体使用说明如下所示：</p>
<p>lseek函数</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>​    off_t lseek(int fd, off_t offset, int whence);</p>
<p>****头文件****：</p>
<p>​    #include &lt;sys&#x2F;types.h&gt;</p>
<p>​    #include &lt;unistd.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>移动文件的读写位置。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>fd:	文件描述符；</p>
<p>off_t offset:	偏移量，单位是字节的数量，可以正负，如果是负值表示向前移动；如果是正值，表示向后移动。</p>
<p>whence：当前位置的基点，可以使用以下三组值。</p>
<p>​				SEEK_SET：相对于文件开头</p>
<p>​				SEEK_CUR:相对于当前的文件读写指针位置</p>
<p>​				SEEK_END:相对于文件末尾</p>
<p>****函数返回值：****成功返回当前位移大小，失败返回-1</p>
<p>函数使用示例：</p>
<p>把文件位置指针设置为5：	</p>
<p>lseek(fd,5,SEEK_SET);</p>
<p>把文件位置设置成文件末尾： </p>
<p>  lseek(fd,0,SEEK_END);</p>
<p>确定当前的文件位置：		</p>
<p>​	 lseek(fd,0,SEEK_CUR);</p>
<h3 id="33-1-2-驱动程序的完善"><a href="#33-1-2-驱动程序的完善" class="headerlink" title="33.1.2 驱动程序的完善"></a>33.1.2 驱动程序的完善</h3><p>上一小节中讲解的lseek函数如果要对设备文件生效，还需要完善相应的驱动程序。lseek函数会调用file_operation结构体中的llseek接口，所以需要对驱动中的llseek函数进行填充，并且完善read和write函数中偏移相关的部分。</p>
<p>下面对相关API接口函数进行填充：</p>
<p><em><strong>*llseek函数完善：*</strong></em></p>
<p>llseek填充完成的函数如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">loff_t</span> <span class="title function_">cdev_test_llseek</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">loff_t</span> offset, <span class="type">int</span> whence)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">loff_t</span> new_offset;<span class="comment">//定义loff_t类型的新的偏移值</span></span><br><span class="line">	<span class="keyword">switch</span>(whence)<span class="comment">//对lseek函数传递的whence参数进行判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> SEEK_SET:</span><br><span class="line">			<span class="keyword">if</span>(offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(offset &gt; BUFSIZE)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;	</span><br><span class="line">			&#125;</span><br><span class="line">			new_offset = offset;<span class="comment">//如果whence参数为SEEK_SET，则新偏移值为offset</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SEEK_CUR:</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &gt; BUFSIZE)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            new_offset = file-&gt;f_pos + offset;<span class="comment">//如果whence参数为SEEK_CUR，则新偏移值为file-&gt;f_pos + offset，file-&gt;f_pos为当前的偏移值</span></span><br><span class="line">			<span class="keyword">break</span>;			</span><br><span class="line">		<span class="keyword">case</span> SEEK_END:</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            new_offset = BUFSIZE + offset;<span class="comment">//如果whence参数为SEEK_END，则新偏移值为BUFSIZE + offset，BUFSIZE为最大偏移量</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	file-&gt;f_pos = new_offset;<span class="comment">//更新file-&gt;f_pos偏移值</span></span><br><span class="line">	<span class="keyword">return</span> new_offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第4行使用switch语句对传递的whence参数进行判断，whence在这里可以有三个取值，分别为SEEK_SET、SEEK_CUR和SEEK_END。</p>
<p>在6-16、17-28、29-38行代码中，分别对三个参数所代表的功能进行实现，其中需要注意的是file-&gt;f_pos指的是当前文件的偏移值。</p>
<p>在第40行和41行分别对f_pos偏移值进行更新，对新的偏移值进行返回。</p>
<p><em><strong>*read接口函数完善：*</strong></em></p>
<p>填充完成的read接口函数如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">loff_t</span> p = *off;<span class="comment">//将读取数据的偏移量赋值给loff_t类型变量p</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">size_t</span> count = size;</span><br><span class="line">	<span class="keyword">if</span>(p &gt; BUFSIZE)&#123;<span class="comment">//如果当前偏移值比最大偏移量大则返回错误</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(count &gt; BUFSIZE - p)&#123;</span><br><span class="line">		count  = BUFSIZE - p;<span class="comment">//如果要读取的偏移值超出剩余的空间，则读取到最后位置</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(copy_to_user(buf,mem+p,count))&#123;<span class="comment">//将mem中的值写入buf，并传递到用户空间</span></span><br><span class="line">		printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">		printk(<span class="string">&quot;buf[%d] is %c\n&quot;</span>,i,mem[i]);<span class="comment">//将mem中的值打印出来</span></span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;mem is %s,p is %llu,count is %d\n&quot;</span>,mem+p,p,count);</span><br><span class="line">	*off = *off + count;<span class="comment">//更新偏移值</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相较于之前的read接口函数，在第7行和第10行分别加入了对偏移值p和读取数量进行判定，在第13行通过偏移值p进行内核空间和用户空间数据的传递，最后在第21行对偏移值进行更新。</p>
<p><em><strong>*write接口函数完善：*</strong></em></p>
<p>write接口函数的完善和read接口函数相似，填充完成的write接口函数如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">loff_t</span> p = *off;<span class="comment">//将写入数据的偏移量赋值给loff_t类型变量p</span></span><br><span class="line">    <span class="type">size_t</span> count = size;</span><br><span class="line">    <span class="keyword">if</span>(p &gt; BUFSIZE)&#123;<span class="comment">//如果当前偏移值比最大偏移量大则返回错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &gt; BUFSIZE - p)&#123;</span><br><span class="line">        count  = BUFSIZE - p;<span class="comment">//如果要写入的偏移值超出剩余的空间，则写入到最后位置</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(copy_from_user(mem+p,buf,count))&#123;<span class="comment">//将buf中的值，从用户空间传递到内核空间</span></span><br><span class="line"> 		printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	printk(<span class="string">&quot;mem is %s,p is %llu\n&quot;</span>,mem+p,p);<span class="comment">//打印写入的值</span></span><br><span class="line">	*off = *off + count;<span class="comment">//更新偏移值</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相较于之前的write接口函数，在第7行和第10行分别加入了对偏移值p和读取数量进行判定，在第13行通过偏移值p进行内核空间和用户空间数据的传递，最后在第18行对偏移值进行更新。</p>
<p>至此，关于定位设备相关的API接口函数就都填充完成了，将在下一小节进行定位设备驱动实验代码的编写。</p>
<h2 id="33-2-实验程序编写"><a href="#33-2-实验程序编写" class="headerlink" title="33.2 实验程序编写"></a>33.2 实验程序编写</h2><h3 id="33-2-1-编写测试-APP"><a href="#33-2-1-编写测试-APP" class="headerlink" title="33.2.1 编写测试 APP"></a>33.2.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\26\app。</p>
<p>首先来编写应用测试代码llseek.c，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型文件描述符</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> off;<span class="comment">//定义读写偏移位置</span></span><br><span class="line">	<span class="type">char</span> readbuf[<span class="number">13</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区readbuf</span></span><br><span class="line">	<span class="type">char</span> readbuf1[<span class="number">19</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区readbuf1</span></span><br><span class="line"></span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR,<span class="number">666</span>);<span class="comment">//打开/dev/test设备</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	write(fd,<span class="string">&quot;hello world&quot;</span>,<span class="number">13</span>);<span class="comment">//向fd写入数据hello world</span></span><br><span class="line">	off = lseek(fd,<span class="number">0</span>,SEEK_CUR);<span class="comment">//读取当前位置的偏移量</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">    off = lseek(fd,<span class="number">0</span>,SEEK_SET);<span class="comment">//将偏移量设置为0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">	read(fd,readbuf,<span class="keyword">sizeof</span>(readbuf));<span class="comment">//将写入的数据读取到readbuf缓冲区</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;read is %s\n&quot;</span>,readbuf);</span><br><span class="line"></span><br><span class="line">    off = lseek(fd,<span class="number">0</span>,SEEK_CUR);<span class="comment">//读取当前位置的偏移量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">	off = lseek(fd,<span class="number">-1</span>,SEEK_CUR);<span class="comment">//将当前位置的偏移量向前挪动一位</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">    write(fd,<span class="string">&quot;Linux&quot;</span>,<span class="number">6</span>);<span class="comment">//向fd写入数据Linux</span></span><br><span class="line">    off = lseek(fd,<span class="number">0</span>,SEEK_CUR);<span class="comment">//读取当前位置的偏移量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">    off = lseek(fd,<span class="number">0</span>,SEEK_SET);<span class="comment">//将偏移量设置为0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">    read(fd,readbuf1,<span class="keyword">sizeof</span>(readbuf1));<span class="comment">//将写入的数据读取到readbuf1缓冲区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read is %s\n&quot;</span>,readbuf1);</span><br><span class="line"></span><br><span class="line">    off = lseek(fd,<span class="number">0</span>,SEEK_CUR);<span class="comment">//读取当前位置的偏移量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="33-2-2-驱动程序编写"><a href="#33-2-2-驱动程序编写" class="headerlink" title="33.2.2 驱动程序编写"></a>33.2.2 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\26\module。</p>
<p> 编写好的驱动程序llseek.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024<span class="comment">//设置最大偏移量为1024</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> mem[BUFSIZE] = &#123;<span class="number">0</span>&#125;;<span class="comment">//设置数据存储数组mem</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">loff_t</span> p = *off;<span class="comment">//将读取数据的偏移量赋值给loff_t类型变量p</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">size_t</span> count = size;</span><br><span class="line">	<span class="keyword">if</span>(p &gt; BUFSIZE)&#123;<span class="comment">//如果当前偏移值比最大偏移量大则返回错误</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(count &gt; BUFSIZE - p)&#123;</span><br><span class="line">		count  = BUFSIZE - p;<span class="comment">//如果要读取的偏移值超出剩余的空间，则读取到最后位置</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(copy_to_user(buf,mem+p,count))&#123;<span class="comment">//将mem中的值写入buf，并传递到用户空间</span></span><br><span class="line">		printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">		printk(<span class="string">&quot;buf[%d] is %c\n&quot;</span>,i,mem[i]);<span class="comment">//将mem中的值打印出来</span></span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;mem is %s,p is %llu,count is %d\n&quot;</span>,mem+p,p,count);</span><br><span class="line">	*off = *off + count;<span class="comment">//更新偏移值</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">loff_t</span> p = *off;<span class="comment">//将写入数据的偏移量赋值给loff_t类型变量p</span></span><br><span class="line">    <span class="type">size_t</span> count = size;</span><br><span class="line">    <span class="keyword">if</span>(p &gt; BUFSIZE)&#123;<span class="comment">//如果当前偏移值比最大偏移量大则返回错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &gt; BUFSIZE - p)&#123;</span><br><span class="line">        count  = BUFSIZE - p;<span class="comment">//如果要写入的偏移值超出剩余的空间，则写入到最后位置</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(copy_from_user(mem+p,buf,count))&#123;<span class="comment">//将buf中的值，从用户空间传递到内核空间</span></span><br><span class="line"> 		printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	printk(<span class="string">&quot;mem is %s,p is %llu\n&quot;</span>,mem+p,p);<span class="comment">//打印写入的值</span></span><br><span class="line">	*off = *off + count;<span class="comment">//更新偏移值</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">loff_t</span> <span class="title function_">cdev_test_llseek</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">loff_t</span> offset, <span class="type">int</span> whence)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">loff_t</span> new_offset;<span class="comment">//定义loff_t类型的新的偏移值</span></span><br><span class="line">	<span class="keyword">switch</span>(whence)<span class="comment">//对lseek函数传递的whence参数进行判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> SEEK_SET:</span><br><span class="line">			<span class="keyword">if</span>(offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(offset &gt; BUFSIZE)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;	</span><br><span class="line">			&#125;</span><br><span class="line">			new_offset = offset;<span class="comment">//如果whence参数为SEEK_SET，则新偏移值为offset</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SEEK_CUR:</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &gt; BUFSIZE)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            new_offset = file-&gt;f_pos + offset;<span class="comment">//如果whence参数为SEEK_CUR，则新偏移值为file-&gt;f_pos + offset，file-&gt;f_pos为当前的偏移值</span></span><br><span class="line">			<span class="keyword">break</span>;			</span><br><span class="line">		<span class="keyword">case</span> SEEK_END:</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            new_offset = BUFSIZE + offset;<span class="comment">//如果whence参数为SEEK_END，则新偏移值为BUFSIZE + offset，BUFSIZE为最大偏移量</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	file-&gt;f_pos = new_offset;<span class="comment">//更新file-&gt;f_pos偏移值</span></span><br><span class="line">	<span class="keyword">return</span> new_offset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">	.llseek = cdev_test_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_dev_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  	dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_dev_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_dev_init);</span><br><span class="line">module_exit(timer_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="33-3-运行测试"><a href="#33-3-运行测试" class="headerlink" title="33.3 运行测试"></a>33.3 运行测试</h2><h3 id="33-3-1-编译驱动程序"><a href="#33-3-1-编译驱动程序" class="headerlink" title="33.3.1 编译驱动程序"></a>33.3.1 编译驱动程序</h3><p>在上一小节中的llseek.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += llseek.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放llseek.c和Makefile文件目录下，如下图（图 33-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps240.jpg" alt="img"> </p>
<p>图 33-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 33-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps241.jpg" alt="img"> </p>
<p>图 33-2</p>
<p>编译完生成 llseek.ko目标文件，如下图（图 33-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps242.jpg" alt="img"> </p>
<p>图 33-3</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="33-3-2-编译应用程序"><a href="#33-3-2-编译应用程序" class="headerlink" title="33.3.2 编译应用程序"></a>33.3.2 编译应用程序</h3><p>来到存放应用程序llseek.c的文件夹下，使用以下命令对llseek.c进行交叉编译，编译完成如下图（图 33-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o read read.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps243.jpg" alt="img"> </p>
<p>图 33-4</p>
<p>生成的llseek文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="33-3-3-运行测试"><a href="#33-3-3-运行测试" class="headerlink" title="33.3.3 运行测试"></a>33.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 33-5）所示：</p>
<p>insmod llseek.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps244.jpg" alt="img"> </p>
<p>图 33-5</p>
<p>然后使用以下命令运行可执行文件llseek，运行结果如下图（图 33-6）所示：</p>
<p>.&#x2F;llseek</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps245.jpg" alt="img"> </p>
<p>图 33-6</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps246.jpg" alt="img"> </p>
<p>图 33-7</p>
<p>然后使用以下命令卸载对应的驱动，如下图（图 33-8）所示：</p>
<p>rmmod timer_dev</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps247.jpg" alt="img"> </p>
<p>图 33-8</p>
<h1 id="第34章-IOCTL驱动传参实验"><a href="#第34章-IOCTL驱动传参实验" class="headerlink" title="第34章 IOCTL驱动传参实验"></a>第34章 IOCTL驱动传参实验</h1><p>用户如果要对外设进行操作，对应的设备驱动不仅要具备读写的能力，还需要对硬件进行控制。以点亮LED灯驱动实验为例，应用程序通过向内核空间写入1和0从而控制LED灯的亮灭，但是读写操作主要是数据流对数据进行操作，而一些复杂的控制通常需要非数据操作，这时本章节要学习的ioctl函数就闪耀登场了。</p>
<h2 id="34-1-ioctl基础"><a href="#34-1-ioctl基础" class="headerlink" title="34.1 ioctl基础"></a>34.1 ioctl基础</h2><p>ioctl是设备驱动程序中用来控制设备的接口函数，一个<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87&spm=1001.2101.3001.7020">字符设备</a>驱动通常需要实现设备的打开、关闭、读取、写入等功能，而在一些需要细分的情况下，就需要扩展新的功能，通常以增设ioctl()命令的方式来实现。</p>
<p>下面将从应用层和驱动函数两个方面来对ioctl函数进行学习。</p>
<p><em><strong>*应用层：*</strong></em></p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>​    int ioctl(int fd, unsigned int cmd, unsigned long args);</p>
<p>****头文件****：</p>
<p>​    #include &lt;sys&#x2F;ioctl.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>用于向设备发送控制和配置命令。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>fd ：是用户程序打开设备时返回的文件描述符 </p>
<p>cmd ：是用户程序对设备的控制命令，</p>
<p>args：应用程序向驱动程序下发的参数，如果传递的参数为指针类型，则可以接收驱动向用户空间传递的数据（在下面的实验中会进行使用）</p>
<p>上述三个参数中，最重要的是第二个cmd参数，为unsigned int 类型，为了高效的使用cmd参数传递更多的控制信息，一个unsigned int cmd被拆分为了4段，每一段都有各自的意义，unsigned int cmd位域拆分如下：</p>
<p>cmd[31:30]—数据（args）的传输方向（读写）</p>
<p>​	cmd[29:16]—数据（args）的大小</p>
<p>​	cmd[15:8]—&gt;命令的类型，可以理解成命令的密钥，一般为ASCII码（0-255的一个字符，有部分字符已经被占用，每个字符的序号段可能部分被占用）</p>
<p>​	cmd[7:0] —&gt;命令的序号，是一个8bits的数字（序号，0-255之间）</p>
<p>cmd参数由ioctl合成宏定义得到，四个合成宏定义如下所示：</p>
<p>定义一个命令，但是不需要参数：</p>
<p>#define _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)</p>
<p>定义一个命令，应用程序从驱动程序读参数：</p>
<p>#define _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))</p>
<p>定义一个命令，应用程序向驱动程序写参数：</p>
<p>#define _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</p>
<p>定义一个命令，参数是双向传递的：</p>
<p>#define _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</p>
<p>宏定义参数说明如下所示：</p>
<p>type：命令的类型，一般为一个ASCII码值，一个驱动程序一般使用一个type</p>
<p>​	nr：该命令下序号。一个驱动有多个命令，一般他们的type，序号不同</p>
<p>​	size：args的类型</p>
<p>例如可以使用以下代码定义不需要参数、向驱动程序写参数、向驱动程序读参数三个宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST0 _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST1 _IOW(<span class="string">&#x27;L&#x27;</span>,1,int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST2 _IOR(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br></pre></td></tr></table></figure>

<p>至此，关于应用程序的ioctl相关知识就讲解完成了。</p>
<p><em><strong>*驱动函数：*</strong></em></p>
<p>应用程序中ioctl函数会调用file_operation结构体中的unlocked_ioctl接口，接口定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long (*unlocked_ioctl) (struct file *file , unsigned int cmd, unsigned long arg);</span><br></pre></td></tr></table></figure>

<p>参数说明如下所示：</p>
<p>file：文件描述符。</p>
<p>​	cmd：与应用程序的cmd参数对应，在驱动程序中对传递来的cmd参数进行判断从而做出不同的动作。</p>
<p>​	arg：与应用程序的arg参数对应，从而实现内核空间和用户空间参数的传递。</p>
<p>至此，关于驱动函数中的ioctl相关知识就讲解完成了。在下一小节中将进行ioctl驱动传参实验。</p>
<h2 id="34-2-实验程序编写"><a href="#34-2-实验程序编写" class="headerlink" title="34.2 实验程序编写"></a>34.2 实验程序编写</h2><h3 id="34-2-1-编写测试-APP"><a href="#34-2-1-编写测试-APP" class="headerlink" title="34.2.1 编写测试 APP"></a>34.2.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\27\app。</p>
<p>首先来编写应用测试代码ioctl.c，在此代码中使用非阻塞的方式打开设备，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST0 _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST1 _IOW(<span class="string">&#x27;L&#x27;</span>,1,int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST2 _IOR(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符fd</span></span><br><span class="line">	<span class="type">int</span> val;<span class="comment">//定义int类型的传递参数val</span></span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR);<span class="comment">//打开test设备节点</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open fail\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;write&quot;</span>))&#123;</span><br><span class="line">		ioctl(fd,CMD_TEST1,<span class="number">1</span>);<span class="comment">//如果第二个参数为write，向内核空间写入1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;read&quot;</span>))&#123;</span><br><span class="line">		ioctl(fd,CMD_TEST2,&amp;val);<span class="comment">//如果第二个参数为read，则读取内核空间传递向用户空间传递的值</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;val is %d\n&quot;</span>,val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="34-2-2-驱动程序编写"><a href="#34-2-2-驱动程序编写" class="headerlink" title="34.2.2 驱动程序编写"></a>34.2.2 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\27\module。</p>
<p> 编写好的驱动程序ioctl.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST0 _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST1 _IOW(<span class="string">&#x27;L&#x27;</span>,1,int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST2 _IOR(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">cdev_test_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> val;<span class="comment">//定义int类型向应用空间传递的变量val</span></span><br><span class="line">	<span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> CMD_TEST0:</span><br><span class="line">            printk(<span class="string">&quot;this is CMD_TEST0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;		</span><br><span class="line">        <span class="keyword">case</span> CMD_TEST1:</span><br><span class="line">            printk(<span class="string">&quot;this is CMD_TEST1\n&quot;</span>);</span><br><span class="line">			printk(<span class="string">&quot;arg is %ld\n&quot;</span>,arg);<span class="comment">//打印应用空间传递来的arg参数</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CMD_TEST2:</span><br><span class="line">			val = <span class="number">1</span>;<span class="comment">//将要传递的变量val赋值为1</span></span><br><span class="line">            printk(<span class="string">&quot;this is CMD_TEST2\n&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span>(copy_to_user((<span class="type">int</span> *)arg,&amp;val,<span class="keyword">sizeof</span>(val)) != <span class="number">0</span>)&#123;<span class="comment">//通过copy_to_user向用户空间传递数据</span></span><br><span class="line">				printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);	</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">break</span>;			</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	.unlocked_ioctl = cdev_test_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_dev_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  	dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_dev_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_dev_init);</span><br><span class="line">module_exit(timer_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="34-3-运行测试"><a href="#34-3-运行测试" class="headerlink" title="34.3 运行测试"></a>34.3 运行测试</h2><h3 id="34-3-1-编译驱动程序"><a href="#34-3-1-编译驱动程序" class="headerlink" title="34.3.1 编译驱动程序"></a>34.3.1 编译驱动程序</h3><p>在上一小节中的ioctl.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m += ioctl.o    #此处要和你的驱动源文件同名</span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    #make操作</span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    #make clean操作</span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放ioctl.c和Makefile文件目录下，如下图（图 34-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps248.jpg" alt="img"> </p>
<p>图 34-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 34-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps249.jpg" alt="img"> </p>
<p>图 34-2</p>
<p>编译完生成 ioctl.ko目标文件，如下图（图 34-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps250.jpg" alt="img"> </p>
<p>图 34-4</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="34-3-2-编译应用程序"><a href="#34-3-2-编译应用程序" class="headerlink" title="34.3.2 编译应用程序"></a>34.3.2 编译应用程序</h3><p>来到存放应用程序ioctl.c的文件夹下，使用以下命令对ioctl.c进行交叉编译，编译完成如下图（图 34-5）所示：</p>
<p>aarch64-linux-gnu-gcc -o ioctl ioctl.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps251.jpg" alt="img"> </p>
<p>图 34-5</p>
<p>生成的ioctl文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="34-3-3-运行测试"><a href="#34-3-3-运行测试" class="headerlink" title="34.3.3 运行测试"></a>34.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 34-6）所示：</p>
<p>insmod ioctl.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps252.jpg" alt="img"> </p>
<p>图 34-6</p>
<p>然后使用以下命令通过ioctl向内核空间传递arg参数，传递成功如下图（图 34-7）所示：</p>
<p>.&#x2F;ioctl write</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps253.jpg" alt="img"> </p>
<p>图 34-7</p>
<p>然后使用以下命令通过ioctl读取内核空间向用户空间传递的val值，读取成功如下图（图 34-8）所示：</p>
<p>.&#x2F;ioctl read</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps254.jpg" alt="img"> </p>
<p>图 34-8</p>
<p>至此关于iocto驱动传参实验就测试完成了，可以使用以下命令卸载对应的驱动，如下图（图 34-9）所示： </p>
<p>rmmod ioctl.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps255.jpg" alt="img"> </p>
<p>图 34-9</p>
<h1 id="第35章-IOCTL地址传参实验"><a href="#第35章-IOCTL地址传参实验" class="headerlink" title="第35章 IOCTL地址传参实验"></a>第35章 IOCTL地址传参实验</h1><p>在上一章节中对ioctl基础知识进行了学习，并通过ioctl进行了驱动传参实验，在本章节将以传递结构体为例，进行地址传参实验，从而加深大家对ioctl的认识。</p>
<h2 id="35-1-实验程序编写"><a href="#35-1-实验程序编写" class="headerlink" title="35.1 实验程序编写"></a>35.1 实验程序编写</h2><h3 id="35-1-1-编写测试-APP"><a href="#35-1-1-编写测试-APP" class="headerlink" title="35.1.1 编写测试 APP"></a>35.1.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\28\app。</p>
<p>首先编写应用程序ioctl.c，用来向设备文件写入数据，编写好的应用程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST0 _IOW(<span class="string">&#x27;L&#x27;</span>,0,int)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span>&#123;</span><span class="comment">//定义要传递的结构体</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型文件描述符</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">test</span>;</span><span class="comment">//定义args类型的结构体变量test</span></span><br><span class="line">	test.a = <span class="number">1</span>;</span><br><span class="line">	test.b = <span class="number">2</span>;</span><br><span class="line">	test.c = <span class="number">3</span>;</span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR,<span class="number">0777</span>);<span class="comment">//打开/dev/test设备</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ioctl(fd,CMD_TEST0,&amp;test);<span class="comment">//使用ioctl函数传递结构体变量test地址</span></span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="35-1-1-驱动程序编写"><a href="#35-1-1-驱动程序编写" class="headerlink" title="35.1.1 驱动程序编写"></a>35.1.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\28\module。</p>
<p> 编写好的驱动程序ioctl.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST0 _IOW(<span class="string">&#x27;L&#x27;</span>,0,int)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">cdev_test_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">test</span>;</span>  </span><br><span class="line">	<span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> CMD_TEST0:</span><br><span class="line">			<span class="keyword">if</span>(copy_from_user(&amp;test,(<span class="type">int</span> *)arg,<span class="keyword">sizeof</span>(test)) != <span class="number">0</span>)&#123;<span class="comment">//将用户空间传递来的arg赋值给test</span></span><br><span class="line">				printk(<span class="string">&quot;copy_from_user error\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			printk(<span class="string">&quot;a = %d\n&quot;</span>,test.a);<span class="comment">//对传递的值进行打印验证</span></span><br><span class="line">  			printk(<span class="string">&quot;b = %d\n&quot;</span>,test.b);</span><br><span class="line">  	  		printk(<span class="string">&quot;c = %d\n&quot;</span>,test.c);</span><br><span class="line">            <span class="keyword">break</span>;			</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	.unlocked_ioctl = cdev_test_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_dev_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line"> dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/*5  创建设备*/</span></span><br><span class="line"> 	dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_dev_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_dev_init);</span><br><span class="line">module_exit(timer_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="35-2-运行测试"><a href="#35-2-运行测试" class="headerlink" title="35.2 运行测试"></a>35.2 运行测试</h2><h3 id="35-2-1-编译驱动程序"><a href="#35-2-1-编译驱动程序" class="headerlink" title="35.2.1 编译驱动程序"></a>35.2.1 编译驱动程序</h3><p>在上一小节中的ioctl.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += ioctl.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放ioctl.c和Makefile文件目录下，如下图（图 35-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps256.jpg" alt="img"> </p>
<p>图 35-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 35-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps257.jpg" alt="img"> </p>
<p>图 35-2</p>
<p>编译完生成 wq.ko目标文件，如下图（图 35-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps258.jpg" alt="img"> </p>
<p>图 35-3</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="35-2-2-编译应用程序"><a href="#35-2-2-编译应用程序" class="headerlink" title="35.2.2 编译应用程序"></a>35.2.2 编译应用程序</h3><p>来到存放应用程序ioctl.c的文件夹下，使用以下命令对ioctl.c进行交叉编译，编译完成如下图（图 35-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o ioctl ioctl.c</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps259.jpg" alt="img"> </p>
<p>图 35-4</p>
<p>生成的ioctl文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="35-2-3-运行测试"><a href="#35-2-3-运行测试" class="headerlink" title="35.2.3 运行测试"></a>35.2.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 35-5）所示：</p>
<p>insmod ioctl.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps260.jpg" alt="img"> </p>
<p>图 35-5</p>
<p>然后使用以下命令运行可执行程序，运行成功如下图（图 35-6）所示：</p>
<p> .&#x2F;ioctl</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps261.jpg" alt="img"> </p>
<p>图 35-6</p>
<p>可以看到结构体类型变量test已经成功传递到了内核空间，a、b、c的值都被正确打印了出来，我们的ioctl地址传参实验就完成了。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps262.jpg" alt="img"> </p>
<p>图 35-7</p>
<h1 id="第36章-封装驱动API接口实验"><a href="#第36章-封装驱动API接口实验" class="headerlink" title="第36章 封装驱动API接口实验"></a>第36章 封装驱动API接口实验</h1><p>相信经过前面两个章节的学习已经能够熟练的使用ioctl函数了，在本章节会进行两个实验，每个实验的要完成的任务如下所示：</p>
<p>实验一：通过ioctl对定时器进行控制，分别实现打开定时器、关闭定时器和设置定时时间的功能。</p>
<p>实验二：对实验一的应用程序进行封装，从而让应用编程人员更好的对设备进行编程。</p>
<h2 id="36-1-ioctl控制定时器实验"><a href="#36-1-ioctl控制定时器实验" class="headerlink" title="36.1 ioctl控制定时器实验"></a>36.1 ioctl控制定时器实验</h2><p>首先进行ioctl控制定时器实验，通过该实验可以综合ioctl函数和定时器相关知识，从而进一步加深对ioctl的理解。</p>
<h3 id="36-1-1-编写测试-APP"><a href="#36-1-1-编写测试-APP" class="headerlink" title="36.1.1 编写测试 APP"></a>36.1.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\29\app1。</p>
<p>首先来编写应用测试代码ioctl.c，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_OPEN _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_CLOSE _IO(<span class="string">&#x27;L&#x27;</span>,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_SET _IOW(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR,<span class="number">0777</span>);<span class="comment">//打开test节点</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    ioctl(fd,TIME_SET,<span class="number">1000</span>);</span><br><span class="line">	ioctl(fd,TIME_OPEN);</span><br><span class="line">	sleep(<span class="number">3</span>);</span><br><span class="line">    ioctl(fd,TIME_SET,<span class="number">3000</span>);</span><br><span class="line">	sleep(<span class="number">7</span>);</span><br><span class="line">	ioctl(fd,TIME_CLOSE);</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第8-10行通过合成宏定义了三个ioctl命令，分别代表定时器打开、定时器关闭、定时时间设置。</p>
<p>第18行和第21行将定时时间分别设置为1秒和3秒。</p>
<p>第19行打开定时器。</p>
<p>第23行关闭定时器。</p>
<h3 id="36-1-2-驱动程序编写"><a href="#36-1-2-驱动程序编写" class="headerlink" title="36.1.2 驱动程序编写"></a>36.1.2 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\29\module。</p>
<p> 编写好的驱动程序ioctl_timer.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_OPEN _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_CLOSE _IO(<span class="string">&#x27;L&#x27;</span>,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_SET _IOW(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">	<span class="type">int</span> counter; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">fnction_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span>;<span class="comment">//定义function_test定时功能函数</span></span><br><span class="line">DEFINE_TIMER(timer_test,fnction_test);<span class="comment">//定义一个定时器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fnction_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;this is fnction_test\n&quot;</span>);</span><br><span class="line">    mod_timer(&amp;timer_test,jiffies_64 + msecs_to_jiffies(dev1.counter));<span class="comment">//使用mod_timer函数重新设置定时时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">cdev_test_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span> =</span> (<span class="keyword">struct</span> device_test *)file-&gt;private_data;<span class="comment">//设置私有数据</span></span><br><span class="line">	<span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> TIMER_OPEN:</span><br><span class="line">			add_timer(&amp;timer_test);<span class="comment">//添加一个定时器</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TIMER_CLOSE:</span><br><span class="line">			del_timer(&amp;timer_test);<span class="comment">//删除一个定时器</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TIMER_SET:</span><br><span class="line">			test_dev-&gt;counter = arg;</span><br><span class="line">			timer_test.expires = jiffies_64 + msecs_to_jiffies(test_dev-&gt;counter);<span class="comment">//设置定时时间</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	.open = cdev_test_open,</span><br><span class="line">	.release = cdev_test_release,</span><br><span class="line">	.unlocked_ioctl = cdev_test_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_dev_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line"> dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">&#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  	dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_dev_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_dev_init);</span><br><span class="line">module_exit(timer_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="36-2-运行测试"><a href="#36-2-运行测试" class="headerlink" title="36.2 运行测试"></a>36.2 运行测试</h2><h3 id="36-2-1-编译驱动程序"><a href="#36-2-1-编译驱动程序" class="headerlink" title="36.2.1 编译驱动程序"></a>36.2.1 编译驱动程序</h3><p>在上一小节中的ioctl_timer.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += ioctl_timer.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放ioctl_timer.c和Makefile文件目录下，如下图（图 36-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps263.jpg" alt="img"> </p>
<p>图 36-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 36-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps264.jpg" alt="img"> </p>
<p>图 36-2</p>
<p>编译完生成 ioctl_timer.ko目标文件，如下图（图 36-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps265.jpg" alt="img"> </p>
<p>图 36-3</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="36-2-2-编译应用程序"><a href="#36-2-2-编译应用程序" class="headerlink" title="36.2.2 编译应用程序"></a>36.2.2 编译应用程序</h3><p>来到存放应用程序ioctl.c的文件夹下，使用以下命令对ioctl.c进行交叉编译，编译完成如下图（图 36-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o ioctl ioctl.c</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps266.jpg" alt="img"> </p>
<p>图 36-4</p>
<p>生成的ioctl文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="36-2-3-运行测试"><a href="#36-2-3-运行测试" class="headerlink" title="36.2.3 运行测试"></a>36.2.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 36-5）所示：</p>
<p>insmod ioctl_timer.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps267.jpg" alt="img"> </p>
<p>图 36-5</p>
<p>输入以下命令运行可执行文件,运行成功如下图（图 36-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps268.jpg" alt="img"> </p>
<p>图 36-6</p>
<p>可以看到前面三个打印信息间隔为1秒钟，后面三个打印信息间隔为3秒钟，至此，实验一就结束了，然后使用以下命令卸载驱动模块，如下图（图 36-7）所示：</p>
<p>rmmod ioctl_timer.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps269.jpg" alt="img"> </p>
<p>图 36-7</p>
<h2 id="36-3-封装驱动API接口"><a href="#36-3-封装驱动API接口" class="headerlink" title="36.3 封装驱动API接口"></a>36.3 封装驱动API接口</h2><p>至此，随着ioctl练习的结束，字符设备驱动框架相关的知识也就完结了，相信细心的小伙伴在上一小节应用程序的编写中会发现问题，应用程序是从驱动的角度进行编写的，具体内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_OPEN _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_CLOSE _IO(<span class="string">&#x27;L&#x27;</span>,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_SET _IOW(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR,<span class="number">0777</span>);<span class="comment">//打开test节点</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    ioctl(fd,TIME_SET,<span class="number">1000</span>);</span><br><span class="line">	ioctl(fd,TIME_OPEN);</span><br><span class="line">	sleep(<span class="number">3</span>);</span><br><span class="line">    ioctl(fd,TIME_SET,<span class="number">3000</span>);</span><br><span class="line">	sleep(<span class="number">7</span>);</span><br><span class="line">	ioctl(fd,TIME_CLOSE);</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为驱动工程师的我们当然可以理解每一行代码所要完成的功能，而一般情况下，应用都是由专业的应用工程师来进行编写的，上述代码编写方式很不利于应用工程师的理解和程序的移植，所以对于应用程序API的封装是一件必然的事情。</p>
<p>封装好的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\29\app2。</p>
<p>首先来编写整体库文件timerlib.h，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TIMELIB_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TIMELIB_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_OPEN _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_CLOSE _IO(<span class="string">&#x27;L&#x27;</span>,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_SET _IOW(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_open</span><span class="params">()</span>;<span class="comment">//定义设备打开函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_open</span><span class="params">(<span class="type">int</span> fd)</span>;<span class="comment">//定义定时器打开函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_close</span><span class="params">(<span class="type">int</span> fd)</span>;<span class="comment">//定义定时器关闭函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_set</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> arg)</span>;<span class="comment">//定义设置计时时间函数</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在9-11行使用合成宏定义了三个ioctl命令，分别代表定时器打开、定时器关闭、定时时间设置。</p>
<p>在第12-15行定义了四个功能函数，所代表的功能分别为设备打开、定时器打开、定时器关闭、定时时间设置。</p>
<p>接下来将创建每个功能函数的c文件，最后编译为单独的库，首先编写dev_open.c文件，编写好的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;timerlib.h&quot;</span><br><span class="line">int dev_open()</span><br><span class="line">&#123;</span><br><span class="line">    int fd；</span><br><span class="line">    fd = open(&quot;/dev/test&quot;,O_RDWR,0777);</span><br><span class="line">    if(fd &lt; 0)&#123;</span><br><span class="line">        printf(&quot;file open error \n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写定时器打开函数timeropen.c文件，编写好的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;timerlib.h&quot;</span><br><span class="line">int timer_open(int fd)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	ret = ioctl(fd,TIMER_OPEN);</span><br><span class="line">	if(ret &lt; 0)&#123;</span><br><span class="line">		printf(&quot;ioctl open error \n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写定时器打开函数timerclose.c文件，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timerlib.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_close</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = ioctl(fd,TIMER_CLOSE);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ioctl  close error \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写定时器打开函数timerset.c文件，编写好的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;timerlib.h&quot;</span><br><span class="line">int timer_set(int fd,int arg)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	ret = ioctl(fd,TIMER_SET,arg);</span><br><span class="line">	if(ret &lt; 0)&#123;</span><br><span class="line">		printf(&quot;ioctl error \n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后编写测试要用到的应用程序ioctl.c文件，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timerlib.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	fd = dev_open();</span><br><span class="line">    timer_set(fd,<span class="number">1000</span>);</span><br><span class="line">	timer_open(fd);</span><br><span class="line">	sleep(<span class="number">3</span>);</span><br><span class="line">	timer_set(fd,<span class="number">3000</span>);</span><br><span class="line">	sleep(<span class="number">7</span>);</span><br><span class="line">	timer_close(fd);</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，要用到的文件就都编写完成了，会在下一小节进行库的制作，以及应用程序的编译。</p>
<h2 id="36-4-运行测试"><a href="#36-4-运行测试" class="headerlink" title="36.4 运行测试"></a>36.4 运行测试</h2><h3 id="36-4-1-编译应用程序"><a href="#36-4-1-编译应用程序" class="headerlink" title="36.4.1 编译应用程序"></a>36.4.1 编译应用程序</h3><p>首先使用以下命令将存放功能函数的c文件编译成.o文件，编译完成如下图（图 36-7）所示：</p>
<p>aarch64-linux-gnu-gcc -c dev_open.c</p>
<p>aarch64-linux-gnu-gcc -c timer*.c</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps270.jpg" alt="img"> </p>
<p>图 36-7</p>
<p>然后使用以下命令将相应的.o文件编译成.a静态库（这里要注意库的名称都以lib开头），编译完成如下图（图 36-8）所示：</p>
<p>aarch64-linux-gnu-ar rcs libtime.a timer*.o</p>
<p>aarch64-linux-gnu-ar rcs libopen.a dev_open.o</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps271.jpg" alt="img"> </p>
<p>图 36-8</p>
<p>最后使用以下命令对ioctl.c进行交叉编译，编译完成如下图（图 36-9）所示：</p>
<p>aarch64-linux-gnu-gcc -o ioctl ioctl.c -L.&#x2F; -ltime -lopen</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps272.jpg" alt="img"> </p>
<p>图 36-9</p>
<p>生成的ioctl文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="36-4-2-运行测试"><a href="#36-4-2-运行测试" class="headerlink" title="36.4.2 运行测试"></a>36.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 36-10）所示：</p>
<p>insmod ioctl_timer.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps273.jpg" alt="img"> </p>
<p>图 36-10</p>
<p>输入以下命令运行可执行文件,运行成功如下图（图 36-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps274.jpg" alt="img"> </p>
<p>图 36-11</p>
<p>可以看到前面三个打印信息间隔为1秒钟，后面三个打印信息间隔为3秒钟，至此，实验一就结束了，然后使用以下命令卸载驱动模块，如下图（图 36-12）所示：</p>
<p>rmmod ioctl_timer.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps275.jpg" alt="img"> </p>
<p>图 36-12</p>
<h1 id="第37章-优化驱动稳定性和效率实验"><a href="#第37章-优化驱动稳定性和效率实验" class="headerlink" title="第37章 优化驱动稳定性和效率实验"></a>第37章 优化驱动稳定性和效率实验</h1><p>在Linux中应用程序运行在用户空间，应用程序错误之后，并不会影响其他程序的运行，而驱动工作在内核层，是内核代码的一部分，当驱动出现问题之后，可能会导致整个系统的崩溃。所以在驱动中，需要对各种判断、预处理等进行排查等，在本小节将对如何优化驱动稳定性和提高驱动效率进行学习。</p>
<h2 id="37-1-方法一：检测ioctl命令"><a href="#37-1-方法一：检测ioctl命令" class="headerlink" title="37.1 方法一：检测ioctl命令"></a>37.1 方法一：检测ioctl命令</h2><p>ioctl的cmd命令是由合成宏合成得到的，也有相应的分解宏得到各个参数，四个分解宏如下所示：</p>
<p>分解cmd命令，得到命令的类型：</p>
<p>_IOC_TYPE(cmd)</p>
<p>分解cmd命令，得到数据（args）的传输方向：</p>
<p>_IOC_DIR(cmd)</p>
<p>分解cmd命令，得到命令的序号：</p>
<p>_IOC_NR(cmd)</p>
<p>分解cmd命令，得到数据（args）的大小：</p>
<p>_IOC_SIZE(cmd)</p>
<p>可以在驱动中通过上述分解宏对传入的ioctl命令类型等参数进行判断，从而得到判断传入的参数是否正确，以此优化驱动的稳定性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(_IOC_TYPE(cmd) != <span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">   printk(<span class="string">&quot;cmd type error \n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如可以通过上述代码对传入参数的类型进行判断，如果传入的参数类型不为“L”,就返回错误，其他参数的检测方法相同。</p>
<h2 id="37-2-方法二：检测传递地址是否合理"><a href="#37-2-方法二：检测传递地址是否合理" class="headerlink" title="37.2 方法二：检测传递地址是否合理"></a>37.2 方法二：检测传递地址是否合理</h2><p>access_ok()函数</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>​    access_ok(addr,size);</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>检查用户空间内存块是否可用</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>addr  :  用户空间的指针变量，其指向一个要检查的内存块开始处。</p>
<p>size   :  要检查内存块的大小。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>成功返回1，失败返回0</p>
<p>以第35章的ioctl地址传参实验为例，对传入的args地址进行判断，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">test</span>;</span></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">	<span class="keyword">case</span> CMD_TEST0:</span><br><span class="line">		len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> args);</span><br><span class="line">		<span class="keyword">if</span>(!access_ok(arg,len))&#123;</span><br><span class="line">			 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(copy_from_user(&amp;test,(<span class="type">int</span> *)arg,<span class="keyword">sizeof</span>(test)) != <span class="number">0</span>)&#123;</span><br><span class="line">			 printk(<span class="string">&quot;copy_from_user error\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>在第6行对传入的args参数地址进行判断，如果不合法则返回-1，从而保证了驱动运行的稳定性。</p>
<h2 id="37-3-方法三：分支预测优化"><a href="#37-3-方法三：分支预测优化" class="headerlink" title="37.3 方法三：分支预测优化"></a>37.3 方法三：分支预测优化</h2><p>现在的CPU都有ICache和流水线机制。即运行当前指令时，ICache会预读取后面的指令，从而提升效率。但是如果条件分支的结果是跳转到了其他指令，那预取下一条指令就浪费时间了。而本章节要用到的likely和unlikely宏，会让编译器总是将大概率执行的代码放在靠前的位置，从而提高驱动的效率。</p>
<p>likely和unlikely宏定义在“内核源码&#x2F;include&#x2F;linux&#x2F;compiler.h”文件中，具体定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define likely(x) __builtin_expect(!!(x), 1)</span><br><span class="line">#define unlikely(x) __builtin_expect(!!(x), 0)</span><br></pre></td></tr></table></figure>

<p>__builtin_expect的作用是告知编译器预期表达式exp等于c的可能性更大，编译器可以根据该因素更好的对代码进行优化，所以likely与unlikely的作用就是表达性x为真的可能性更大（likely）和更小（unlikely）。</p>
<p>这里以上一小节添加传递地址检测内容后的代码为例，对copy_from_user函数添加分支预测优化函数，添加完成如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">test</span>;</span></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">	<span class="keyword">case</span> CMD_TEST0:</span><br><span class="line">		len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> args);</span><br><span class="line">		<span class="keyword">if</span>(!access_ok(arg,len))&#123;</span><br><span class="line">			 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(unlikely(copy_from_user(&amp;test,(<span class="type">int</span> *)arg,<span class="keyword">sizeof</span>(test)) != <span class="number">0</span>))&#123;</span><br><span class="line">			 printk(<span class="string">&quot;copy_from_user error\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>传递地址检测成功之后才会使用执行copy_from_user函数，在传递地址正确的前提下copy_from_user函数运行失败为小概率事件，所以这里使用unlikely函数进行驱动效率的优化。</p>
<p>至此，关于分支预测优化相关的知识就讲解完成了。</p>
<h1 id="第38章-驱动调试方法实验"><a href="#第38章-驱动调试方法实验" class="headerlink" title="第38章 驱动调试方法实验"></a>第38章 驱动调试方法实验</h1><p>在之前编写的驱动程序中，通常都使用printk函数打印相应的提示信息从而对驱动进行调试，那有没有其他的方式来调试驱动呢，答案是肯定的，在本章节中将对不同驱动调试方法进行学习。</p>
<h2 id="38-1-方法1：dump-stack函数"><a href="#38-1-方法1：dump-stack函数" class="headerlink" title="38.1 方法1：dump_stack函数"></a>38.1 方法1：dump_stack函数</h2><p>作用:打印内核调用堆栈，并打印函数的调用关系。</p>
<p>这里以最简单的helloworld驱动为例进行dump_stack函数演示，实验代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>        </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">	dump_stack();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);    </span><br><span class="line">module_exit(helloworld_exit);   </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    </span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>和原helloworld驱动程序相比，在第6行添加了dump_stack()，驱动加载之后打印信息如下（图 38-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps276.jpg" alt="img"> </p>
<p>图 38-1</p>
<p>可以看到helloworld_init函数的调用关系就都打印了出来。</p>
<p>至此关于dump_stack函数的测试就完成了。</p>
<h2 id="38-2-方法2：WARN-ON-condition-函数"><a href="#38-2-方法2：WARN-ON-condition-函数" class="headerlink" title="38.2 方法2：WARN_ON(condition)函数"></a>38.2 方法2：WARN_ON(condition)函数</h2><p>WARN_ON (condition)函数作用:在括号中的条件成立时，内核会抛出栈回溯，打印函数的调用关系。通常用于内核抛出一个警告，暗示某种不太合理的事情发生了。</p>
<p>WARN_ON实际上也是调用dump_stack，只是多了参数condition判断条件是否成立，例如WARN_ON (1)则条件判断成功，函数会成功执行。</p>
<p>这里仍然以最简单的helloworld驱动为例进行WARN_ON函数演示，实验代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>        </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">	WARN_ON(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);    </span><br><span class="line">module_exit(helloworld_exit);   </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    </span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);c</span><br></pre></td></tr></table></figure>

<p>和原helloworld驱动程序相比，在第6行添加了WARN_ON(1)，驱动加载之后打印信息如下（图 38-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps277.jpg" alt="img"> </p>
<p>图 38-2</p>
<p>可以看到helloworld_init函数的调用关系以及寄存器值就都打印了出来。</p>
<p>至此关于WARN_ON函数的测试就完成了。</p>
<h2 id="38-3-方法3：BUG-ON-condition-函数"><a href="#38-3-方法3：BUG-ON-condition-函数" class="headerlink" title="38.3 方法3：BUG_ON (condition)函数"></a>38.3 方法3：BUG_ON (condition)函数</h2><p>内核中有许多地方调用类似BUG_ON()的语句，它非常像一个内核运行时的断言，意味着本来不该执行到BUG_ON()这条语句，一旦BUG_ON()执行内核就会立刻抛出oops，导致栈的回溯和错误信息的打印。大部分体系结构把BUG()和BUG_ON()定义成某种非法操作，这样自然会产生需要的oops。参数condition判断条件是否成立，例如BUG_ON (1)则条件判断成功，函数会成功执行。</p>
<p>这里仍然以最简单的helloworld驱动为例进行BUGON函数演示，实验代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>        </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">	BUGON(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);    </span><br><span class="line">module_exit(helloworld_exit);   </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    </span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>和原helloworld驱动程序相比，在第6行添加了BUGON(1)，驱动加载之后打印信息如下（图 38-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps278.jpg" alt="img"> </p>
<p>图 38-3</p>
<p>可以看到helloworld_init函数的调用关系以及寄存器值就都打印了出来。</p>
<p>至此关于BUGON(1)函数的测试就完成了。</p>
<h2 id="38-4-方法4：panic-fmt…-函数"><a href="#38-4-方法4：panic-fmt…-函数" class="headerlink" title="38.4 方法4：panic (fmt…)函数"></a>38.4 方法4：panic (fmt…)函数</h2><p>panic (fmt…)函数:输出打印会造成系统死机并将函数的调用关系以及寄存器值就都打印了出来。</p>
<p>这里仍然以最简单的helloworld驱动为例进行panic 函数的演示，实验代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>        </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">	panic(<span class="string">&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);    </span><br><span class="line">module_exit(helloworld_exit);   </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    </span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>和原helloworld驱动程序相比，在第6行添加了panic(“!!!!!!!!!!!!!!!!!!!!!!!!!!!!”)，驱动加载之后打印信息如下（图 38-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps279.jpg" alt="img"> </p>
<p>图 38-4</p>
<p>可以看到helloworld_init函数的调用关系以及寄存器值就都打印了出来，信息打印完成之后会发现系统已经崩溃了，终端已经无法再进行输入。</p>
<p>至此关于panic函数的测试就完成了。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>高级字符设备进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>rk3568 驱动开发第三篇 并发与竞争</title>
    <url>/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%89%E7%AF%87-%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第19章-并发与竞争实验"><a href="#第19章-并发与竞争实验" class="headerlink" title="第19章 并发与竞争实验"></a>第19章 并发与竞争实验</h1><p>在前面章节的学习中，相信大家已经对用户空间与内核空间数据传递进行了实验，假如要传递的数据被存放在了全局变量，该数据就可以作为共享资源被多个任务共同读写，从而造成数据的错误传输，多个程序同时访问一个共享资源产生的问题就叫做竞争。竞争产生的根本原因就是Linux系统的并发访问。</p>
<p>在本章节中首先会对并发与并行的概念进行讲解，随后对竞争产生的原因进行总结，最后以一个实际的竞争实验加深大家的理解。下面就让我们开始本章节的学习吧。</p>
<h2 id="19-1-并发与竞争"><a href="#19-1-并发与竞争" class="headerlink" title="19.1 并发与竞争"></a>19.1 并发与竞争</h2><h3 id="19-1-1并发"><a href="#19-1-1并发" class="headerlink" title="19.1.1并发"></a>19.1.1并发</h3><p>早期计算机大多只有一个CPU核心，一个CPU在同一时间只能执行一个任务，当系统中有多个任务等待执行时，CPU只能执行完一个再执行下一个。而计算机的很多指令会涉及I&#x2F;O操作，执行速度远远低于CPU内高速存储器的存取速度，这就导致CPU经常处于空闲状态，只能等待I&#x2F;O操作完成后才能继续执行后面的指令。为了提高CPU利用率，减少等待时间，提出了CPU并发工作理论。</p>
<p>所谓并发，就是通过算法将CPU资源合理地分配给多个任务，当一个任务执行 I&#x2F;O 操作时，CPU可以转而执行其它的任务，等到 I&#x2F;O 操作完成以后，或者新的任务遇到 I&#x2F;O 操作时，CPU再回到原来的任务继续执行。</p>
<p>下图（图19-1）展示了两个任务并发执行的过程（为了容易理解，这里以两个任务并发执行为例，当然一个CPU核心并不仅仅只能两个任务并发）：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps109.jpg" alt="img"> </p>
<p>图 19-1</p>
<p>虽然CPU在同一时刻只能执行一个任务，但是通过将CPU的使用权在恰当的时机分配给不同的任务，使得多个任务看起来是一起执行的（CPU的执行速度极快，多任务切换的时间也极短）。</p>
<p>至此关于并发的概念就讲解完成了。</p>
<h3 id="19-1-2并行"><a href="#19-1-2并行" class="headerlink" title="19.1.2并行"></a>19.1.2并行</h3><p>并发是针对单核CPU提出的，而并行则是针对多核CPU提出的。和单核CPU不同，多核CPU真正实现了“同时执行多个任务”。多核CPU的每个核心都可以独立地执行一个任务，而且多个核心之间不会相互干扰。在不同核心上执行的多个任务，是真正地同时运行，这种状态就叫做并行。双核CPU的工作状态如下图（图19-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps110.jpg" alt="img"> </p>
<p>图 19-2</p>
<p>双核CPU执行两个任务时，每个核心各自执行一个任务，和单核CPU在两个任务之间不断切换相比，它的执行效率更高。</p>
<p>至此对于并行的概念就讲解完成了。</p>
<h3 id="19-1-3并发-并行"><a href="#19-1-3并发-并行" class="headerlink" title="19.1.3并发+并行"></a>19.1.3并发+并行</h3><p>在并行的工作状态中，两个CPU分别执行两个任务，是一种理想状态。但是在实际场景中，处于运行状态的任务是非常多的，以实际办公电脑为例，windows系统在开机之后会运行几十个任务，而CPU往往只有4核、8核等，远远低于任务的数量，这个时候就会同时存在并发和并行两种情况，即所有核心在并行工作的同时，每个核心还要并发工作。</p>
<p>例如一个双核 CPU 要执行四个任务，它的工作状态如下图（图19-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps111.jpg" alt="img"> </p>
<p>图 19-3</p>
<p>为了容易理解，这里是以两个任务并发执行为例，当然一个CPU核心并不仅仅只能两个任务并发，并发任务的数量和操作系统的分配方式、以及每个任务的工作状态有关系。</p>
<p>至此，对于并发+并行的概念讲解就结束了。</p>
<p>并发可以看作是并行的理想状态，为了便于讲解和避免产生歧义，之后的章节无论是并发还是并行，都会统称为并发。</p>
<h3 id="19-1-4-竞争"><a href="#19-1-4-竞争" class="headerlink" title="19.1.4 竞争"></a>19.1.4 竞争</h3><p>并发可能会造成多个程序同时访问一个共享资源，这时候由并发同时访问一个共享资源产生的问题就叫做竞争。</p>
<p>竞争产生的原因如下所示：</p>
<p>（1）多线程的并发访问。由于Linux 是多任务操作系统，所以多线程访问是竞争产生的基本原因。</p>
<p>（2）中断程序的并发访问。中断任务产生后，CPU会立刻停止当前工作，从而去执行中断中的任务，如果中断任务对共享资源进行了修改，就会产生竞争。</p>
<p>（3）抢占式并发访问。linux2.6及更高版本引入了抢占式内核，高优先级的任务可以打断低优先级的任务。在线程访问共享资源的时候，另一个线程打断了现在正在访问共享资源的线程同时也对共享资源进行操作，从而造成了竞争。</p>
<p>（4）多处理器(SMP）并发访问。多核处理器之间存在核间并发访问。</p>
<h3 id="19-1-5-共享资源的保护"><a href="#19-1-5-共享资源的保护" class="headerlink" title="19.1.5 共享资源的保护"></a>19.1.5 共享资源的保护</h3><p>竞争是由并发访问同一个共享资源产生的。为了防止“竞争”的产生就要对共享资源进行保护，这里提到的共享资源又是什么呢？</p>
<p>以实际生活中的共享资源为例，可以是公共电话，也可以是共享单车、共享充电宝等公共物品，以上都属于共享资源的范畴，以公共电话为例，每个人都可以对它进行使用，但在同一时间内只能由一个人进行使用，如果两个人都要对电话进行使用，则产生了竞争。而在实际的驱动的代码中，共享资源可以是全局变量，也可以是驱动中的设备结构体等，需要根据具体的驱动程序来进行分析。在下一小节的实验中，会以全局变量为例，进行并发与竞争实验。</p>
<h2 id="19-2-实验程序的编写"><a href="#19-2-实验程序的编写" class="headerlink" title="19.2 实验程序的编写"></a>19.2 实验程序的编写</h2><h3 id="19-2-1-驱动程序编写"><a href="#19-2-1-驱动程序编写" class="headerlink" title="19.2.1 驱动程序编写"></a>19.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\14\module。</p>
<p>本实验将编写并发与竞争的驱动代码，首先完善字符设备驱动框架，然后通过copy_from_user(…)函数接收用户空间传递到内核空间的数据并进行判断，如果接收到的字符串数据为“topeet”会在睡眠4秒钟后打印接收到的数据，如果接收到的字符串数据为“itop”会在睡眠2秒钟后打印接收到的数据。</p>
<p>编写完成的example.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;\nthis is open_test \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//printk(&quot;\nthis is release_test \n&quot;);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对于重要逻辑部分已经加粗，后续章节的实验都是对上述并发与竞争实验的改进，以不同的方式来避免竞争的产生。</p>
<h3 id="19-2-2-编写测试-APP"><a href="#19-2-2-编写测试-APP" class="headerlink" title="19.2.2 编写测试 APP"></a>19.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\14\app。</p>
<p>本测试app较为简单，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="19-3-运行测试"><a href="#19-3-运行测试" class="headerlink" title="19.3 运行测试"></a>19.3 运行测试</h2><h3 id="19-3-1-编译驱动程序"><a href="#19-3-1-编译驱动程序" class="headerlink" title="19.3.1 编译驱动程序"></a>19.3.1 编译驱动程序</h3><p>在上一小节中的example.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += example.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放example.c和Makefile文件目录下，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps112.jpg" alt="img"> </p>
<p>图 19-4</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图19-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps113.jpg" alt="img"> </p>
<p>图 19-5</p>
<p>编译完生成example.ko目标文件，如下图（图19-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps114.jpg" alt="img"> </p>
<p>图 19-6</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h3 id="19-3-2-编译应用程序"><a href="#19-3-2-编译应用程序" class="headerlink" title="19.3.2 编译应用程序"></a>19.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图19-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps115.jpg" alt="img"> </p>
<p>图 19-7</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图19-8）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps116.jpg" alt="img"> </p>
<p>图 19-8</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="19-3-3-运行测试"><a href="#19-3-3-运行测试" class="headerlink" title="19.3.3 运行测试"></a>19.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图19-9）所示：</p>
<p>insmod example.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps117.jpg" alt="img"> </p>
<p>图 19-9</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图19-10）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps118.jpg" alt="img"> </p>
<p>图 19-10</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图19-11）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps119.jpg" alt="img"> </p>
<p>图 19-11</p>
<p>可以看到传递的buf值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图19-12）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet &amp;</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test itop &amp;</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps120.jpg" alt="img"> </p>
<p>图 19-12</p>
<p>在不存在竞争的情况下，传递的两个字符串数据应该是topeet和itop，而在上图中的打印信息为两个itop，原因是第二个app应用程序运行之后对共享资源进行了修改，两个app应用程序就产生了竞争关系，会在之后的章节中使用不同的方法对上述驱动程序进行改进，从而避免竞争的产生。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图19-13）所示：</p>
<p>rmmod  example.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps121.jpg" alt="img"> </p>
<p>图 19-13</p>
<p>至此，并发与竞争的实验就完成了。</p>
<h1 id="第20章-原子操作实验"><a href="#第20章-原子操作实验" class="headerlink" title="第20章 原子操作实验"></a>第20章 原子操作实验</h1><p>在上一章节的实验中，对并发与竞争进行了实验，两个app应用程序之间对共享资源的竞争访问引起了数据传输错误，而在Linux内核中，提供了四种处理并发与竞争的常见方法，分别是原子操作、自旋锁、信号量、互斥体，在之后的几个章节中会依次对上述四种方法进行讲解。</p>
<p>本章首先对四种常见方法中的原子操作进行讲解。</p>
<h2 id="20-1-原子操作"><a href="#20-1-原子操作" class="headerlink" title="20.1 原子操作"></a>20.1 原子操作</h2><p>“原子”是化学世界中不可再分的最小微粒，一切物质都由原子组成。在Linux内核中的原子操作可以理解为“不可被拆分的操作”，就是不能被更高等级中断抢夺优先的操作。在C语言中可以使用以下代码对一个整形变量赋值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> v;<span class="comment">//定义一个int类型的变量v</span></span><br><span class="line">v = <span class="number">1</span>;<span class="comment">//将int类型的变量v赋值为1</span></span><br></pre></td></tr></table></figure>

<p>而上述代码仍然不是“不可拆分的操作”，C语言程序仍然需要翻译成汇编指令，在汇编指令的执行过程中仍可能会有竞争的产生。而原子操作会将整形变量的操作当成一个整体，不可再进行分割。而原子操作又可以进一步细分为“整型原子操作”和“位原子操作”，这里首先对****整型原子操作****进行讲解。</p>
<p>在Linux内核中使用 atomic_t和atomic64_t结构体分别来完成32位系统和64位系统的整形数据原子操作，两个结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;types.h”文件中，具体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     <span class="type">int</span> counter;</span><br><span class="line"> &#125; <span class="type">atomic_t</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     <span class="type">long</span> counter;</span><br><span class="line">&#125; <span class="type">atomic64_t</span>;</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>例如可以使用以下代码定义一个64位系统的原子整形变量：</p>
<p>atomic64_t v;</p>
<p>在成功定义原子变量之后，必然要对原子变量进行读取、加减等动作，原子操作的部分常用API函数如下所示，定义在“内核源码&#x2F;include&#x2F;linux&#x2F;atomic.h”文件中，所以在接下来的实验中需要加入该头文件的引用。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ATOMIC_INIT(int i)</td>
<td>定义原子变量的时候对其初始化，赋值为i</td>
</tr>
<tr>
<td>int atomic_read(atomic_t *v)</td>
<td>读取v的值，并且返回。</td>
</tr>
<tr>
<td>void atomic_set(atomic_t *v, int i)</td>
<td>向原子变量v写入i值。</td>
</tr>
<tr>
<td>void atomic_add(int i, atomic_t *v)</td>
<td>原子变量v加上i值。</td>
</tr>
<tr>
<td>void atomic_sub(int i, atomic_t *v)</td>
<td>原子变量v减去i值。</td>
</tr>
<tr>
<td>void atomic_inc(atomic_t *v)</td>
<td>原子变量v加1</td>
</tr>
<tr>
<td>void atomic_dec(atomic_t *v)</td>
<td>原子变量v减1</td>
</tr>
<tr>
<td>int atomic_dec_return(atomic_t *v)</td>
<td>原子变量v减1，并返回v的值。</td>
</tr>
<tr>
<td>int atomic_inc_return(atomic_t *v)</td>
<td>原子变量v加 1，并返回v的值。</td>
</tr>
<tr>
<td>int atomic_sub_and_test(int i, atomic_t *v)</td>
<td>原子变量v减 i，如果结果为0就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_dec_and_test(atomic_t *v)</td>
<td>原子变量v减 1，如果结果为0就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_inc_and_test(atomic_t *v)</td>
<td>原子变量v加 1，如果结果为0就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_add_negative(int i, atomic_t *v)</td>
<td>原子变量v加 i，如果结果为负就返回真，否则返回假</td>
</tr>
</tbody></table>
<p>图表20- 1</p>
<p>至此，对于整型原子操作的相关API函数就讲解完成了，会在下一小节中使用上述原子整形操作API进行相应的实验。</p>
<p>下面对原子位操作进行讲解，和原子整形变量不同，原子位操作没有 atomic_t 的数据结构，原子位操作是直接对内存进行操作，原子位操作相关API函数如下（图表20-2）所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void set_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位置 1。</td>
</tr>
<tr>
<td>void clear_bit(int nr,void *p)</td>
<td>将 p 地址的第 nr 位清零。</td>
</tr>
<tr>
<td>void change_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位进行翻转。</td>
</tr>
<tr>
<td>int test_bit(int nr, void *p)</td>
<td>获取 p 地址的第 nr 位的值。</td>
</tr>
<tr>
<td>int test_and_set_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位置 1，并且返回 nr 位原来的值。</td>
</tr>
<tr>
<td>int test_and_clear_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位清零，并且返回 nr 位原来的值。</td>
</tr>
<tr>
<td>int test_and_change_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位翻转，并且返回 nr 位原来的值。</td>
</tr>
</tbody></table>
<p>图表20- 2</p>
<p>对于原子位操作的知识就不再深入讲解和实验，感兴趣的同学可以到相关网站上进行自主学习。</p>
<p>在下一小节中，将会使用原子整形操作对19章的并发与竞争实验进行改进。</p>
<h2 id="20-2-实验程序的编写"><a href="#20-2-实验程序的编写" class="headerlink" title="20.2 实验程序的编写"></a>20.2 实验程序的编写</h2><h3 id="20-2-1-驱动程序编写"><a href="#20-2-1-驱动程序编写" class="headerlink" title="20.2.1 驱动程序编写"></a>20.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\15\module。</p>
<p>为了解决第19章实验中并发与竞争的问题，本章节实验将加入原子整形操作相关实验代码，在open()函数和release()函数中加入原子整形变量v的赋值代码，并且在open()函数中加入原子整形变量v的判断代码，从而实现同一时间内只允许一个应用打开该设备节点，以此来防止共享资源竞争的产生。</p>
<p>编写完成的atomic.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">atomic64_t</span> v = ATOMIC_INIT(<span class="number">1</span>);<span class="comment">//初始化原子类型变量v,并设置为1</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(atomic64_read(&amp;v) != <span class="number">1</span>)&#123;<span class="comment">//读取原子类型变量v的值并判断是否等于1</span></span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line">	atomic64_set(&amp;v,<span class="number">0</span>);<span class="comment">//将原子类型变量v的值设置为0</span></span><br><span class="line">	<span class="comment">//printk(&quot;\nthis is open_test \n&quot;);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//printk(&quot;\nthis is release_test \n&quot;);</span></span><br><span class="line">	atomic64_set(&amp;v,<span class="number">1</span>);<span class="comment">//将原子类型变量v的值赋1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">	dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="20-2-2-编写测试-APP"><a href="#20-2-2-编写测试-APP" class="headerlink" title="20.2.2 编写测试 APP"></a>20.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\15\app。</p>
<p>本测试app代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-3-运行测试"><a href="#20-3-运行测试" class="headerlink" title="20.3 运行测试"></a>20.3 运行测试</h2><h3 id="20-3-1-编译驱动程序"><a href="#20-3-1-编译驱动程序" class="headerlink" title="20.3.1 编译驱动程序"></a>20.3.1 编译驱动程序</h3><p>在上一小节中的atomic.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += atomic.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放atomic.c和Makefile文件目录下，如下图（图20-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps122.jpg" alt="img"> </p>
<p>图 20-4</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图20-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps123.jpg" alt="img"> </p>
<p>图 20-5</p>
<p>编译完生成atomic.ko目标文件，如下图（图20-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps124.jpg" alt="img"> </p>
<p>图 20-6</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h3 id="20-3-2-编译应用程序"><a href="#20-3-2-编译应用程序" class="headerlink" title="20.3.2 编译应用程序"></a>20.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图20-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps125.jpg" alt="img"> </p>
<p>图 20-7</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图20-8）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps126.jpg" alt="img"> </p>
<p>图 20-8</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="20-3-3-运行测试"><a href="#20-3-3-运行测试" class="headerlink" title="20.3.3 运行测试"></a>20.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图20-9）所示：</p>
<p>insmod atomic.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps127.jpg" alt="img"> </p>
<p>图 20-9</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图20-10）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps128.jpg" alt="img"> </p>
<p>图 20-10</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图20-11）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps129.jpg" alt="img"> </p>
<p>图 20-11</p>
<p>可以看到传递的buf值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图20-12）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet &amp;</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test itop </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps130.jpg" alt="img"> </p>
<p>图 20-12</p>
<p>​	可以看到应用程序在打开第二次&#x2F;dev&#x2F;device_test 文件的时候，出现了“file open failed”打印，证明文件打开失败，只有在第一个应用关闭相应的文件之后，下一个应用才能打开，通过限制同一时间内设备访问数量，来对共享资源进行保护。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图20-13）所示：</p>
<p>rmmod flag.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps131.jpg" alt="img"> </p>
<p>图 20-13</p>
<p>至此，原子操作实验就完成了。</p>
<h1 id="第21章-自旋锁实验"><a href="#第21章-自旋锁实验" class="headerlink" title="第21章 自旋锁实验"></a>第21章 自旋锁实验</h1><p>在上一节中对原子操作进行了讲解，并使用原子整形操作对并发与竞争实验进行了改进，但是原子操作只能对整形变量或者位进行保护，而对于结构体或者其他类型的共享资源，原子操作就力不从心了，这时候就轮到自旋锁的出场了，下面就让我们一起来进行自旋锁的学习吧。</p>
<h2 id="21-1-自旋锁"><a href="#21-1-自旋锁" class="headerlink" title="21.1 自旋锁"></a>21.1 自旋锁</h2><p>自旋锁是为了保护共享资源提出的一种锁机制。自旋锁（spin lock）是一种非阻塞锁，也就是说，如果某线程需要获取锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取锁。</p>
<p>在有些场景中，同步资源(用来保持一致性的两个或多个资源)的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果计算机有多个CPU核心，能够让两个或以上的线程同时并行执行，这样我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，直到持有锁的线程释放锁，后面请求锁的线程才可以获取锁。</p>
<p>为了让后面那个请求锁的线程“稍等一下”，我们需让它进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么该线程便不必阻塞，并且直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。我们再举个形象生动的例子，以现实生活中银行ATM机办理业务为例，ATM机防护舱在同一时间内只允许一个人进入，当有人进入ATM机防护舱之后，两秒钟之后自动上锁，其他也想要存取款的人员，只能在外部等待，办理完相应的存取款业务之后，舱内人员需要手动打开防护锁，其他人才能进入其中，办理业务。而自旋锁在驱动中的使用和上述ATM机办理业务流程相同，当一个任务要访问某个共享资源之前需要先获取相应的自旋锁，自旋锁只能被一个任务持有，在该任务持有自旋锁的过程中，其他任务只能原地等待该自旋锁的释放，在等待过程中的任务同样会持续占用CPU，消耗CPU资源，所以临界区的代码不能太多。</p>
<p>如果自旋锁被错误使用可能会导致死锁的产生，对于自旋锁死锁会在下一章节进行详细说明，并进行相应的实验。</p>
<p>内核中以spinlock_t结构体来表示自旋锁，定义在“内核源码&#x2F;include&#x2F;linux&#x2F;spinlock_types.h”文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            u8 __padding[LOCK_PADSIZE];</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     &#125;;</span><br><span class="line">&#125; <span class="type">spinlock_t</span>;</span><br></pre></td></tr></table></figure>

<p>自旋锁相关API函数定义在“内核源码&#x2F;include&#x2F;linux&#x2F;spinlock.h”文件中，所以在本章节的实验中要加入该头文件（spinlock.h头文件包含spinlock_types.h等，所以只需加入spinlock.h头文件即可），部分API函数如下（表 21-1）所示，</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_SPINLOCK(spinlock_t lock)</td>
<td>定义并初始化自旋锁。</td>
</tr>
<tr>
<td>int spin_lock_init(spinlock_t *lock)</td>
<td>初始化自旋锁。</td>
</tr>
<tr>
<td>void spin_lock(spinlock_t *lock)</td>
<td>获取指定的自旋锁，也叫做加锁。</td>
</tr>
<tr>
<td>void spin_unlock(spinlock_t *lock)</td>
<td>释放指定的自旋锁。</td>
</tr>
<tr>
<td>int spin_trylock(spinlock_t *lock)</td>
<td>尝试获取指定的自旋锁，如果没有获取到就返回 0</td>
</tr>
<tr>
<td>int spin_is_locked(spinlock_t *lock)</td>
<td>检查指定的自旋锁是否被获取，如果没有被获取就返回非0，否则返回 0。</td>
</tr>
</tbody></table>
<p>表 21-1</p>
<p>除了上述API之外还有其他与终端相关的自旋锁API函数，会在接下来的自旋锁死锁章节进行讲解。</p>
<p>自旋锁的使用步骤：</p>
<p>1 在访问临界资源的时候先申请自旋锁</p>
<p>2 获取到自旋锁之后就进入临界区，获取不到自旋锁就“原地等待”。</p>
<p>3 退出临界区的时候要释放自旋锁。</p>
<p>在下一小节中将使用上述自旋锁API进行相应的实验，利用自旋锁相关知识来对第19章节的并发与竞争实验进行优化。</p>
<h2 id="21-2-实验程序的编写"><a href="#21-2-实验程序的编写" class="headerlink" title="21.2 实验程序的编写"></a>21.2 实验程序的编写</h2><h3 id="21-2-1-驱动程序编写"><a href="#21-2-1-驱动程序编写" class="headerlink" title="21.2.1 驱动程序编写"></a>21.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\16\module。</p>
<p>与上一章节使用原子整形操作避免并发与竞争逻辑相同，在驱动入口函数初始化自旋锁，然后在open函数中使用自旋锁实现对设备的互斥访问，最后在 release 函数中解锁，表示设备被释放了，可以被其他的应用程序使用。上述操作都将共享资源由自旋锁进行保护，从而实现同一时间内只允许一个应用打开该设备节点，以此来防止共享资源竞争的产生。</p>
<p>编写完成的spinlock.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">spinlock_t</span> spinlock_test;<span class="comment">//定义spinlock_t类型的自旋锁变量spinlock_test</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> flag = <span class="number">1</span>;<span class="comment">//定义flag标准为，flag等于1表示设备没有被打开，等于0则证明设备已经被打开了</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//printk(&quot;\nthis is open_test \n&quot;);</span></span><br><span class="line">	spin_lock(&amp;spinlock_test);<span class="comment">//自旋锁加锁</span></span><br><span class="line">	<span class="keyword">if</span>(flag != <span class="number">1</span>)&#123;<span class="comment">//判断标志位flag的值是否等于1</span></span><br><span class="line">spin_unlock(&amp;spinlock_test);<span class="comment">//自旋锁解锁</span></span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line">	 &#125;</span><br><span class="line">	flag = <span class="number">0</span>;<span class="comment">//将标志位的值设置为0</span></span><br><span class="line">	spin_unlock(&amp;spinlock_test);<span class="comment">//自旋锁解锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;\nthis is release_test \n&quot;</span>);</span><br><span class="line">	spin_lock(&amp;spinlock_test);<span class="comment">//自旋锁加锁</span></span><br><span class="line">	flag = <span class="number">1</span>;</span><br><span class="line">	spin_unlock(&amp;spinlock_test);<span class="comment">//自旋锁解锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	spin_lock_init(&amp;spinlock_test);</span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">	dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="21-2-2-编写测试-APP"><a href="#21-2-2-编写测试-APP" class="headerlink" title="21.2.2 编写测试 APP"></a>21.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\16\app。</p>
<p>本测试app代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="21-3-运行测试"><a href="#21-3-运行测试" class="headerlink" title="21.3 运行测试"></a>21.3 运行测试</h2><h3 id="21-3-1-编译驱动程序"><a href="#21-3-1-编译驱动程序" class="headerlink" title="21.3.1 编译驱动程序"></a>21.3.1 编译驱动程序</h3><p>在上一小节中的spinlock.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += spinlock.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放spinlock.c和Makefile文件目录下，如下图（图21-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps132.jpg" alt="img"> </p>
<p>图 21-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图21-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps133.jpg" alt="img"> </p>
<p>图 21-3</p>
<p>编译完生成spinlock.ko目标文件，如下图（图21-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps134.jpg" alt="img"> </p>
<p>图 21-4</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h3 id="21-3-2-编译应用程序"><a href="#21-3-2-编译应用程序" class="headerlink" title="21.3.2 编译应用程序"></a>21.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图21-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps135.jpg" alt="img"> </p>
<p>图 21-5</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图21-6）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps136.jpg" alt="img"> </p>
<p>图 21-6</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="21-3-3-运行测试"><a href="#21-3-3-运行测试" class="headerlink" title="21.3.3 运行测试"></a>21.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图21-7）所示：</p>
<p>insmod spinlock.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps137.jpg" alt="img"> </p>
<p>图21-7</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（21-8）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps138.jpg" alt="img"> </p>
<p>图 21-8</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图21-9）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps139.jpg" alt="img"> </p>
<p>图 21-9</p>
<p>可以看到传递的buf值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图21-10）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet &amp;</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test itop </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps140.jpg" alt="img"> </p>
<p>图 21-10</p>
<p>​	可以看到应用程序在打开第二次&#x2F;dev&#x2F;device_test 文件的时候，出现了“file open failed”打印，证明文件打开失败，只有在第一个应用关闭相应的文件之后，下一个应用才能打开。本次实验的自旋锁只是对标志位flag进行保护，flag用来表示设备的状态，确保同一时间内，该设备只能被一个应用程序打开。进而对共享资源进行保护。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图21-11）所示：</p>
<p>rmmod spinlock.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps141.jpg" alt="img"> </p>
<p>图 21-11</p>
<p>至此，自旋锁实验就完成了。</p>
<h1 id="第22章-自旋锁死锁实验"><a href="#第22章-自旋锁死锁实验" class="headerlink" title="第22章 自旋锁死锁实验"></a>第22章 自旋锁死锁实验</h1><p>在上一小节中，学习了内核中自旋锁的使用，而自旋锁若是使用不当就会产生死锁，在本章将会对自旋锁的特殊情况-死锁进行讲解。</p>
<h2 id="22-1-自旋锁死锁"><a href="#22-1-自旋锁死锁" class="headerlink" title="22.1 自旋锁死锁"></a>22.1 自旋锁死锁</h2><p>死锁是指两个或多个事物在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。当多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进，这种情况就是死锁。</p>
<p>自旋锁死锁发生存在两种情况：</p>
<p>（1）第一种情况是拥有自旋锁的进程A在内核态阻塞了，内核调度B进程，碰巧B进程也要获得自旋锁，此时B只能自旋转。而此时抢占已经关闭(在单核条件下)不会调度A进程了，B永远自旋，产生死锁，如下图（图 22-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps142.jpg" alt="img"> </p>
<p>图 22-1</p>
<p>相应的解决办法是，在自旋锁的使用过程中要尽可能短的时间内拥有自旋锁，而且不能在临界区中调用导致线程休眠的函数。</p>
<p>第二种情况是进程A拥有自旋锁，中断到来，CPU执行中断函数，中断处理函数，中断处理函数需要获得自旋锁，访问共享资源，此时无法获得锁，只能自旋，从而产生死锁，如下图（图22-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps143.jpg" alt="img"> </p>
<p>图 22-2</p>
<p>对于中断引发的死锁，最好的解决方法就是在获取锁之前关闭本地中断，Linux内核在“&#x2F;include&#x2F;linux&#x2F;spinlock.h”文件中提供了相应的API 函数，如下（图22-3）所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void spin_lock_irq(spinlock_t *lock)</td>
<td>禁止本地中断，并获取自旋锁。</td>
</tr>
<tr>
<td>void spin_unlock_irq(spinlock_t *lock)</td>
<td>激活本地中断，并释放自旋锁。</td>
</tr>
<tr>
<td>void spin_lock_irqsave(spinlock_t *lock, unsigned long flags)</td>
<td>恢复中断状态，关闭中断并获取自旋锁。</td>
</tr>
<tr>
<td>void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)</td>
<td>将中断状态恢复到以前的状态，打开中断并释放自旋锁</td>
</tr>
<tr>
<td>void spin_lock_bh(spinlock_t *lock)</td>
<td>关闭下半部，获取自旋锁</td>
</tr>
<tr>
<td>void spin_unlock_bh(spinlock_t *lock)</td>
<td>打开下半部，获取自旋锁</td>
</tr>
</tbody></table>
<p>表 22-3</p>
<p>由于Linux内核运行是非常复杂的，很难确定某个时刻的中断状态，因此建议使用 spin_lock_irqsave&#x2F;spin_unlock_irqrestore，因为这一组函数会保存中断状态，在释放锁的时候会恢复中断状态。</p>
<p>在下一小节中将进行自旋锁死锁实验，本次实验所采取的是第一种情况，即拥有自旋锁的进程A在内核态阻塞了，内核调度B进程，碰巧B进程也要获得自旋锁，依次产生死锁。</p>
<h2 id="22-2-实验程序的编写"><a href="#22-2-实验程序的编写" class="headerlink" title="22.2 实验程序的编写"></a>22.2 实验程序的编写</h2><h3 id="22-2-1-驱动程序编写"><a href="#22-2-1-驱动程序编写" class="headerlink" title="22.2.1 驱动程序编写"></a>22.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\17\module。</p>
<p>本章节实验以19章并发与竞争实验为基础，在open()函数中加入了自旋锁加锁，在close()函数中加入了自旋锁解锁，由于在write()函数中存在sleep()睡眠函数，所以会造成内核阻塞，睡眠期间如果使用另一个进程获取该自旋锁，就会造成死锁。</p>
<p>编写完成的dielock.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">spinlock_t</span> spinlock_test;<span class="comment">//定义spinlock_t类型的自旋锁变量spinlock_test</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//printk(&quot;\nthis is open_test \n&quot;);</span></span><br><span class="line">	spin_lock(&amp;spinlock_test);<span class="comment">//自旋锁加锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;\nthis is release_test \n&quot;</span>);</span><br><span class="line">	spin_unlock(&amp;spinlock_test);<span class="comment">//自旋锁解锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	spin_lock_init(&amp;spinlock_test);</span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">	dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="22-2-2-编写测试-APP"><a href="#22-2-2-编写测试-APP" class="headerlink" title="22.2.2 编写测试 APP"></a>22.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\17\app。</p>
<p>本测试app代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于本次测试的CPU为多核心CPU，其他核心仍旧可以调度其他进程，所以需要多次使用taskset函数指定CPU进行进程的运行，以此来产生死锁，在与app.c同级目录下创建名为app.sh的脚本文件，脚本内容如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">taskset -c 0 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 1 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 2 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 3 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 0 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 1 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 2 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 3 ./app /dev/device_test topeet &amp;</span><br></pre></td></tr></table></figure>

<p>保存退出之后，需要使用以下命令赋予脚本可执行权限，如下图（图22-4）所示：</p>
<p>chmod 777 app.sh</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps144.jpg" alt="img"> </p>
<p>图 22-4</p>
<p>至此测试程序app.c和运行脚本app.sh就编写完成了。</p>
<h2 id="22-3-运行测试"><a href="#22-3-运行测试" class="headerlink" title="22.3 运行测试"></a>22.3 运行测试</h2><h3 id="22-3-1-编译驱动程序"><a href="#22-3-1-编译驱动程序" class="headerlink" title="22.3.1 编译驱动程序"></a>22.3.1 编译驱动程序</h3><p>在上一小节中的dielock.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += dielock.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放dielock.c和Makefile文件目录下，如下图（图22-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps145.jpg" alt="img"> </p>
<p>图 22-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图22-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps146.jpg" alt="img"> </p>
<p>图 22-6</p>
<p>编译完生成dielock.ko目标文件，如下图（图22-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps147.jpg" alt="img"> </p>
<p>图 22-7</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h3 id="22-3-2-编译应用程序"><a href="#22-3-2-编译应用程序" class="headerlink" title="22.3.2 编译应用程序"></a>22.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图22-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps148.jpg" alt="img"> </p>
<p>图 22-8</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图22-9）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps149.jpg" alt="img"> </p>
<p>图 22-9</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="22-3-3-运行测试"><a href="#22-3-3-运行测试" class="headerlink" title="22.3.3 运行测试"></a>22.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图22-10）所示：</p>
<p>insmod dielock.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps150.jpg" alt="img"> </p>
<p>图 22-10</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图22-11）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps151.jpg" alt="img"> </p>
<p>图 22-11</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行app.sh脚本，该脚本会指定CPU在加锁之后进入内核休眠状态，如下图（图22-12）所示：</p>
<p>.&#x2F;app.sh</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps152.jpg" alt="img"> </p>
<p>图 22-12</p>
<p>​	在指令输入之后，串口终端无法输入，引发了死锁，进而造成了系统崩溃，所以在编写驱动的过程中，要尽可能的避免死锁的出现。</p>
<p>至此，自旋锁死锁驱动实验就完成了。</p>
<h1 id="第23章-信号量实验"><a href="#第23章-信号量实验" class="headerlink" title="第23章 信号量实验"></a>第23章 信号量实验</h1><p>在上面两个章节对自旋锁和自旋锁死锁进行了学习，自旋锁会让请求的任务原地“自旋”，在等待的过程中会循环检测自旋锁的状态，进而占用系统资源，而本章节要讲解的信号量也是解决竞争的一种常用方法，与自旋锁不同的是，信号量会使等待的线程进入休眠状态，适用于那些占用资源比较久的场合。下面对信号量相关知识的进行讲解。</p>
<h2 id="23-1-信号量"><a href="#23-1-信号量" class="headerlink" title="23.1 信号量"></a>23.1 信号量</h2><p>信号量是操作系统中最典型的用于同步和互斥的手段，本质上是一个全局变量，信号量的值表示控制访问资源的线程数，可以根据实际情况来自行设置，如果在初始化的时候将信号量量值设置为大于1，那么这个信号量就是计数型信号量，允许多个线程同时访问共享资源。如果将信号量量值设置为1，那么这个信号量就是二值信号量，同一时间内只允许一个线程访问共享资源，注意！信号量的值不能小于0。当信号量的值为0时，想访问共享资源的线程必须等待，直到信号量大于0时，等待的线程才可以访问。当访问共享资源时，信号量执行“减一”操作，访问完成后再执行“加一”操作。</p>
<p>相比于自旋锁，信号量具有休眠特性，因此适用长时间占用资源的场合，但由于信号量会引起休眠，所以不能用在中断函数中，最后如果共享资源的持有时间比较短，使用信号量的话会造成频繁的休眠，反而带来更多资源的消耗，使用自旋锁反而效果更好。再同时使用信号量和自旋锁的时候，要先获取信号量，再使用自旋锁，因为信号量会导致睡眠。</p>
<p>以现实生活中的银行办理业务为例，银行的业务办理窗口就是共享资源，业务办理窗口的数量就是信号量量值，进入银行之后，客户需要领取相应的排序码，然后在休息区进行等待，可以看作线程的睡眠阶段，当前面的客户办理完业务之后，相应的窗口会空闲出来，可以看作信号量的释放，之后银行会通过广播，提醒下一位客户到指定的窗口进行业务的办理，可以看作线程的唤醒并获取到信号量，访问共享资源的过程。</p>
<p>Linux 内核使用semaphore结构体来表示信号量，该结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;semaphore.h”文件内（所以在下一章节的信号量实验中需要加入该头文件），结构体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="type">raw_spinlock_t</span>      lock;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 与信号量相关的 API 函数同样定义在semaphore.h文件内，部分常用API函数如下（表23-1）所示： </p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_SEAMPHORE(name)</td>
<td>定义信号量，并且设置信号量的值为 1。</td>
</tr>
<tr>
<td>void sema_init(struct semaphore *sem, int val)</td>
<td>初始化信号量 sem，设置信号量值为 val。</td>
</tr>
<tr>
<td>void down(struct semaphore *sem)</td>
<td>获取信号量，不能被中断打断，如ctrl+c</td>
</tr>
<tr>
<td>int down_interruptible(struct semaphore *sem)</td>
<td>获取信号量，可以被中断打断，如ctrl+c</td>
</tr>
<tr>
<td>void up(struct semaphore *sem)</td>
<td>释放信号量</td>
</tr>
<tr>
<td>int down_trylock(struct semaphore *sem);</td>
<td>尝试获取信号量，如果能获取到信号量就获取，并且返回 0。如果不能就返回非 0</td>
</tr>
</tbody></table>
<p>表 23-1</p>
<p>至此，关于信号量相关的知识就讲解完成了，上述API函数会在下一小节的实验中用到。</p>
<h2 id="23-2-实验程序的编写"><a href="#23-2-实验程序的编写" class="headerlink" title="23.2 实验程序的编写"></a>23.2 实验程序的编写</h2><h3 id="23-2-1-驱动程序编写"><a href="#23-2-1-驱动程序编写" class="headerlink" title="23.2.1 驱动程序编写"></a>23.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\18\module。</p>
<p>与之前章节设置标志位，在同一时间内只允许一个任务对共享资源进行访问的方式所不同，本小节将采用信号量的方式避免竞争的产生。本实验设置的信号量量值为1，所以需要在open()函数中加入信号量获取函数，在release()函数中加入信号量释放函数即可。</p>
<p>编写完成的semaphore.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">semaphore_test</span>;</span><span class="comment">//定义一个semaphore类型的结构体变量semaphore_test</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;\nthis is open_test \n&quot;</span>);</span><br><span class="line">down(&amp;semaphore_test);<span class="comment">//信号量数量减1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">up(&amp;semaphore_test);<span class="comment">//信号量数量加1</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is release_test \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	sema_init(&amp;semaphore_test,<span class="number">1</span>);<span class="comment">//初始化信号量结构体semaphore_test，并设置信号量的数量为1</span></span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">	dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="23-2-2-编写测试-APP"><a href="#23-2-2-编写测试-APP" class="headerlink" title="23.2.2 编写测试 APP"></a>23.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\18\app。</p>
<p>本测试app代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="23-3-运行测试"><a href="#23-3-运行测试" class="headerlink" title="23.3 运行测试"></a>23.3 运行测试</h2><h3 id="23-3-1-编译驱动程序"><a href="#23-3-1-编译驱动程序" class="headerlink" title="23.3.1 编译驱动程序"></a>23.3.1 编译驱动程序</h3><p>在上一小节中的semaphore.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += semaphore.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放semaphore.c和Makefile文件目录下，如下图（图23-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps153.jpg" alt="img"> </p>
<p>图 23-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图23-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps154.jpg" alt="img"> </p>
<p>图 23-3</p>
<p>编译完生成semaphore.ko目标文件，如下图（图23-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps155.jpg" alt="img"> </p>
<p>图 23-4</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的安装。</p>
<h3 id="23-3-2-编译应用程序"><a href="#23-3-2-编译应用程序" class="headerlink" title="23.3.2 编译应用程序"></a>23.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图 23-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps156.jpg" alt="img"> </p>
<p>图 23-5</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图23-6）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps157.jpg" alt="img"> </p>
<p>图23-6</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="23-3-3-运行测试"><a href="#23-3-3-运行测试" class="headerlink" title="23.3.3 运行测试"></a>23.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 23-7）所示：</p>
<p>insmod semaphore.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps158.jpg" alt="img"> </p>
<p>图 23-7</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图23-8）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps159.jpg" alt="img"> </p>
<p>图 23-8</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图23-9）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps160.jpg" alt="img"> </p>
<p>图 23-9</p>
<p>可以看到传递的buf值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图23-10）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet &amp;</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test itop </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps161.jpg" alt="img"> </p>
<p>图 23-10</p>
<p>​	上述打印信息正常，证明数据被正确传递了，没有发生共享资源的竞争，第一个任务运行之后，由于设置的信号量量值为1，所以第二个任务会进入休眠状态，第一个任务执行完毕之后，会唤醒第二个任务去执行，所以避免了并发与竞争。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图 23-11）所示：</p>
<p>rmmod semaphore.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps162.jpg" alt="img"> </p>
<p>图 23-11</p>
<p>至此，信号量实验就完成了。</p>
<h1 id="第24章-互斥锁实验"><a href="#第24章-互斥锁实验" class="headerlink" title="第24章 互斥锁实验"></a>第24章 互斥锁实验</h1><p>在上一章节中对信号量进行了学习，而本章节要学习的互斥锁可以说是“量值”为 1 的信号量，最终实现的效果相同，既然有了信号量，那为什么还要有互斥锁呢，带着疑问，让我们来进行本章节的学习吧！</p>
<h2 id="24-1-互斥锁"><a href="#24-1-互斥锁" class="headerlink" title="24.1 互斥锁"></a>24.1 互斥锁</h2><p>在上一章节中，将信号量量值设置为1，最终实现的就是互斥效果，与本章节要学习的互斥锁功能相同，虽然两者功能相同但是具体的实现方式是不同的，但是使用互斥锁效率更高、更简洁，所以如果使用到的信号量“量值”为 1，一般将其修改为使用互斥锁实现。</p>
<p>当有多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制。线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。互斥锁为资源引入一个状态：锁定或者非锁定。某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性，能够保证多个线程访问共享数据不会出现资源竞争及数据错误。</p>
<p>为了方便大家理解，这里举个例子来说明。比如公司部门里，我在使用着打印机打印东西的同时（还没有打印完），别人刚好也在此刻使用打印机打印东西，如果不做任何处理的话，打印出来的东西肯定是错乱的。那么怎么解决这种情况呢？只要我在打印着的时候别人是不允许打印的，只有等我打印结束后别人才允许打印。这个过程有点类似于，把打印机放在一个房间里，给这个房间安把锁，这个锁默认是打开的。当 A 需要打印时，他先过来检查这把锁有没有锁着，没有的话就进去，同时上锁在房间里打印。而在这时，刚好 B 也需要打印，B 同样先检查锁，发现锁是锁住的，他就在门外等着。而当 A 打印结束后，他会开锁出来，这时候 B 才进去上锁打印。看了这个例子，相信大家已经理解了互斥锁。</p>
<p>互斥锁会导致休眠，所以在中断里面不能用互斥锁。同一时刻只能有一个线程持有互斥锁，并且只有持有者才可以解锁，并且不允许递归上锁和解锁。</p>
<p>内核中以mutex结构体来表示互斥体，定义在“内核源码&#x2F;include&#x2F;linux&#x2F;mutex.h”文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_long_t</span>       owner;</span><br><span class="line">    <span class="type">spinlock_t</span>      wait_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MUTEX_SPIN_ON_OWNER</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">optimistic_spin_queue</span> <span class="title">osq</span>;</span> <span class="comment">/* Spinner MCS lock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">    <span class="type">void</span>            *magic;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>  <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一些和互斥体相关的API函数也定义在mutex.h文件中，常用API函数如下（表24-1）所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_MUTEX(name)</td>
<td>定义并初始化一个 mutex 变量。</td>
</tr>
<tr>
<td>void mutex_init(mutex *lock)</td>
<td>初始化 mutex。</td>
</tr>
<tr>
<td>void mutex_lock(struct mutex *lock)</td>
<td>获取 mutex，也就是给 mutex 上锁。如果获取不到就进休眠。</td>
</tr>
<tr>
<td>void mutex_unlock(struct mutex *lock)</td>
<td>释放 mutex，也就给 mutex 解锁。</td>
</tr>
<tr>
<td>int mutex_is_locked(struct mutex *lock)</td>
<td>判断 mutex 是否被获取，如果是的话就返回1，否则返回 0。</td>
</tr>
</tbody></table>
<p>表 24-1</p>
<p>至此，关于互斥体相关的知识就讲解完成了，在下一小节的实验中会对上述API函数进行运用。</p>
<h2 id="24-2-实验程序的编写"><a href="#24-2-实验程序的编写" class="headerlink" title="24.2 实验程序的编写"></a>24.2 实验程序的编写</h2><h3 id="24-2-1-驱动程序编写"><a href="#24-2-1-驱动程序编写" class="headerlink" title="24.2.1 驱动程序编写"></a>24.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\19\module。</p>
<p>本小节实验将使用互斥体对19章的并发与竞争实验进行改进，由于互斥体在同一时间内只允许一个任务对共享资源进行，所以除了在atomic_init()函数内加入初始化互斥锁函数之外，只需要在open()函数中加入互斥锁加锁函数，在release()函数中加入互斥锁解锁函数即可。</p>
<p>编写完成的mutex.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex_test</span>;</span><span class="comment">//定义mutex类型的互斥锁结构体变量mutex_test</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;\nthis is open_test \n&quot;</span>);</span><br><span class="line">	mutex_lock(&amp;mutex_test);<span class="comment">//互斥锁加锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex_unlock(&amp;mutex_test);<span class="comment">//互斥锁解锁</span></span><br><span class="line">printk(<span class="string">&quot;\nthis is release_test \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex_init(&amp;mutex_test);<span class="comment">//对互斥体进行初始化</span></span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">	dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="24-2-2-编写测试-APP"><a href="#24-2-2-编写测试-APP" class="headerlink" title="24.2.2 编写测试 APP"></a>24.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\19\app。</p>
<p>本测试app代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24-3-运行测试"><a href="#24-3-运行测试" class="headerlink" title="24.3 运行测试"></a>24.3 运行测试</h2><h3 id="24-3-1-编译驱动程序"><a href="#24-3-1-编译驱动程序" class="headerlink" title="24.3.1 编译驱动程序"></a>24.3.1 编译驱动程序</h3><p>在上一小节中的mutex.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += mutex.c    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放mutex.c和Makefile文件目录下，如下图（图24-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps163.jpg" alt="img"> </p>
<p>图 24-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图24-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps164.jpg" alt="img"> </p>
<p>图24-3</p>
<p>编译完生成mutex.ko目标文件，如下图（图 24-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps165.jpg" alt="img"> </p>
<p>图 24-4</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h3 id="24-3-2-编译应用程序"><a href="#24-3-2-编译应用程序" class="headerlink" title="24.3.2 编译应用程序"></a>24.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图 24-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps166.jpg" alt="img"> </p>
<p>图 24-5</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图 24-6）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps167.jpg" alt="img"> </p>
<p>图 24-6</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="24-3-3-运行测试"><a href="#24-3-3-运行测试" class="headerlink" title="24.3.3 运行测试"></a>24.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图24-7）所示：</p>
<p>insmod mutex.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps168.jpg" alt="img"> </p>
<p>图 24-7</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图24-8）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps169.jpg" alt="img"> </p>
<p>图 24-8</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图24-9）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps170.jpg" alt="img"> </p>
<p>图 24-9</p>
<p>可以看到传递的buf值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图24-10）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet &amp;</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test itop </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps171.jpg" alt="img"> </p>
<p>图 24-10</p>
<p>​	与23章实验测试现象相同，两个app被同时运行，最终打印信息正常，证明数据被正确传递了，没有发生共享资源的竞争，证明互斥量就起到了作用。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图24-11）所示：</p>
<p>rmmod mutex.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps172.jpg" alt="img"> </p>
<p>图 24-11</p>
<p>至此，互斥体实验就完成了。</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>并发与竞争</tag>
      </tags>
  </entry>
  <entry>
    <title>rk3568 驱动开发第二篇 字符设备基础</title>
    <url>/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%8C%E7%AF%87-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第7章-menuconfig图形化配置实验"><a href="#第7章-menuconfig图形化配置实验" class="headerlink" title="第7章 menuconfig图形化配置实验"></a>第7章 menuconfig图形化配置实验</h1><p>Linux内核可以通过输入“make menuconfig”来打开图形化配置界面，menuconfig是一套图形化的配置工具，本章节来学习使用menuconfig配置内核。</p>
<h2 id="7-1图形化界面的操作"><a href="#7-1图形化界面的操作" class="headerlink" title="7.1图形化界面的操作"></a>7.1图形化界面的操作</h2><p>menuconfig图形化的配置工具需要 ncurses 库支持。ncurses库提供了一系列的API函数供调用者生成基于文本的图形界面，因此在使用menuconfig图形化配置界面之前需要先在 Ubuntu 中安装ncurses库，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line"></span><br><span class="line">sudo apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure>

<p>图形化配置界面主要有以下四种，在这四种方式中，最推荐的是 make menuconfig，它不依赖于 QT 或 GTK+，且非常直观。</p>
<p>make config （基于文本的最为传统的配置界面，不推荐使用）</p>
<p>make menuconfig （基于文本菜单的配置界面）</p>
<p>make xconfig （要求 QT 被安装）</p>
<p>make gconfig （要求 GTK+ 被安装）</p>
<p>如何打开menuconfig图形化配置界面呢？</p>
<p>以RK3568为例，在内核源码目录下输入以下命令，打开图形化配置界面。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export ARCH=arm64</span><br><span class="line"></span><br><span class="line">make rockchip_linux_defconfig</span><br><span class="line"></span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps33.jpg" alt="img"> </p>
<p>图 7-1</p>
<p>打开后界面如下所（图7-2）示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps34.jpg" alt="img"> </p>
<p>图 7-2</p>
<p>打开menuconfig图形化配置界面以后，可以使用以下方式进行操作，如下表（表7-3）所示：</p>
<table>
<thead>
<tr>
<th>上下键</th>
<th>选择不同的行，即移动到不同的（每一行的）选项上</th>
</tr>
</thead>
<tbody><tr>
<td>空格键</td>
<td>用于在选择该选项，取消选择该选项之间来回切换</td>
</tr>
<tr>
<td>选择该（行所在的）选项</td>
<td>则对应的该选项前面就变成了 [ * ]，表示被选中了。把驱动编译编译成模块，用 M 来表示。把驱动编译到内核里面，用*来表示。</td>
</tr>
<tr>
<td>取消该选项</td>
<td>则对应的该选项变成了只有一个中括号，里面是空的，即：[ ]</td>
</tr>
<tr>
<td>左右键</td>
<td>用于在 Select&#x2F;Exit&#x2F;Help 之前切换</td>
</tr>
<tr>
<td>回车键</td>
<td>左右键切换到了某个键上，此时回车键，就执行相应的动作</td>
</tr>
<tr>
<td>Select</td>
<td>此时一般都是所在（的行的）选项，后面有三个短横线加上一个右箭头，即 —&gt;，表示此项下面还有子选项，即进入子菜单</td>
</tr>
<tr>
<td>Exit</td>
<td>直接退出当前的配置。所以，当你更改了一些配置，但是又没有去保存，此时一般都会询问你是否要保存当前（已修改后的最新的）配置，然后再退出。</td>
</tr>
<tr>
<td>Help</td>
<td>针对你当前所在某个（行的）选项，查看其帮助信息。一般来说，其帮助信息，都包含针对该选项的很详细的解释。换句话说：如果你对某个选项的功能，不是很清楚，那么就应该认真仔细的去看看其 Help，往往都会找到详细解释，以便你更加了解此配置的含义。另外一般也会写出，此选项所对应的宏。该宏，就是写出到配置文件中的那个宏，对于写 makefile 的人来说，往往也是利用此相关的宏，在 makefile 中，实现对应的不同的控制。</td>
</tr>
<tr>
<td>快捷键快速跳转到对应的选项</td>
<td>menuconfig 中的每一行的选项，都有一个用特殊颜色标记出来的字母，很明显，此字母，就是该行的快捷字母。注意：此类快捷字母，一般都是大写的，且是大小写区分的</td>
</tr>
<tr>
<td>&#x2F; 键</td>
<td>输入“&#x2F;”即可弹出搜索界面，然后输入我们想要搜索的内容即可。</td>
</tr>
</tbody></table>
<p>表 7-3</p>
<h2 id="7-2-Kconfig-语法简介"><a href="#7-2-Kconfig-语法简介" class="headerlink" title="7.2 Kconfig 语法简介"></a>7.2 Kconfig 语法简介</h2><p>上一小节我们打开的图形化配置界面是如何生成的呢？图形化配置界面中的每一个界面都会对应一个Kconfig文件。所以图形化配置界面的每一级菜单是由Kconfig文件来决定的。</p>
<p>图形化配置界面有很多菜单。所以就会有很多Kconfig文件，这也就是为什么我们会在内核源码的每个子目录下，都会看到Kconfig文件的原因，那掌握Kconfig文件相关的知识是不是就非常重要呢。</p>
<p>所以这一小节我们来看下如何编写Kconfig文件来生成图形化配置界面，也就是Kconfig文件的语法是什么。</p>
<p>\1. Mainmenu</p>
<p>mainmenu顾名思义就是主菜单，也就是我们输入完“make menuconfig”以后默认打开的界面，mainmenu用来设置主菜单的标题，如下所示：</p>
<p>mainmenu “Linux&#x2F;$(ARCH) $(KERNELVERSION) Kernel Configuration”</p>
<p>此行代码是设置菜单的名字为“Linux&#x2F;$(ARCH) $(KERNELVERSION) Kernel Configuration”。如下图（图7-4）所示，ARCH变量是通过“export ARCH&#x3D;arm64”设置的，内核版本KERNELVERSION为4.19.232。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps35.jpg" alt="img"> </p>
<p>图 7-4</p>
<p>2.source</p>
<p>source用于读取另一个Kconfig文件，比如“source “init&#x2F;Kconfig””就是读取init目录下的Kconfig文件。</p>
<p>3.menu&#x2F;endmenu</p>
<p>menu&#x2F;endmenu条目用于生成菜单，如下（图7-5）所示，生成了Watchdog Timer Support的菜单。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">menu <span class="string">&quot;Watchdog Timer Support&quot;</span></span><br><span class="line"> </span><br><span class="line">config HW_WATCHDOG</span><br><span class="line">	bool</span><br><span class="line"> </span><br><span class="line">config WDT</span><br><span class="line">	bool <span class="string">&quot;Enable driver model for watchdog timer drivers&quot;</span></span><br><span class="line">	depends on DM</span><br><span class="line">	help</span><br><span class="line">	  Enable driver model for watchdog timer. At the moment the API.</span><br><span class="line">......</span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure>

<p>图 7-5</p>
<p>menu之后的字符串是菜单名，“menu”是菜单开始的标志，“endmenu”是菜单结束的标志，这俩个是成对出现的。“menu”和“endmenu”之间有很多config条目。在kernel目录下输入make menuconfig，如下图（图7-6）所示，可以看到上述代码描述的”Watchdog Timer Support”菜单。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps36.jpg" alt="img"> </p>
<p>图 7-6</p>
<p>进入“ Watchdog Timer Support  —&gt; ”可以看到很多config定义的条目，如下（图7-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps37.jpg" alt="img"> </p>
<p>图 7-7</p>
<p>4.if&#x2F;endif</p>
<p>if&#x2F;endif 语句是一个条件判断，定义了一个 if 结构，Kconfig中代码如下（图7-8）所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">menu &quot;Hardware Drivers Config&quot;</span><br><span class="line">    menuconfig BSP_USING_CAN</span><br><span class="line">        bool &quot;Enable CAN&quot;</span><br><span class="line">        default n</span><br><span class="line">        select RT_USING_CAN</span><br><span class="line">        if BSP_USING_CAN</span><br><span class="line">            config BSP_USING_CAN1</span><br><span class="line">                bool &quot;Enable CAN1&quot;</span><br><span class="line">                default n</span><br><span class="line">        endif</span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure>

<p>图 7-8</p>
<p>当没有选中 “Enable CAN” 选项时，下面通过 if 判断的 Enable CAN1 选项并不会显示出来。当上一级菜单选中 “Enable CAN” 时，Enable CAN1 选项才会显示。</p>
<p>\5. choice&#x2F;endchooice</p>
<p>choice条目将多个类似的配置选项组合到一起，供用户选择，用户选择是从“choice”开始，从“endchoice”结束，“choice”和“endchoice”之间有很多的config条目，这些config条目是提供用户选择的，如下（图7-9）所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">choice</span><br><span class="line">        bool <span class="string">&quot;Parade TrueTouch Gen5 MultiTouch Protocol&quot;</span></span><br><span class="line">        depends on TOUCHSCREEN_CYPRESS_CYTTSP5</span><br><span class="line">        default TOUCHSCREEN_CYPRESS_CYTTSP5_MT_B</span><br><span class="line">        help</span><br><span class="line">          This option controls which MultiTouch protocol will be used to</span><br><span class="line">          report the touch events.</span><br><span class="line">config TOUCHSCREEN_CYPRESS_CYTTSP5_MT_A</span><br><span class="line">        bool <span class="string">&quot;Protocol A&quot;</span></span><br><span class="line">        help</span><br><span class="line">          Select to enable MultiTouch touch reporting using protocol A</span><br><span class="line">          on Parade TrueTouch(tm) Standard Product Generation4 touchscreen</span><br><span class="line">          controller.</span><br><span class="line"> </span><br><span class="line">config TOUCHSCREEN_CYPRESS_CYTTSP5_MT_B</span><br><span class="line">        bool <span class="string">&quot;Protocol B&quot;</span></span><br><span class="line">        help</span><br><span class="line">          Select to enable MultiTouch touch reporting using protocol B</span><br><span class="line">          on Parade TrueTouch(tm) Standard Product Generation4 touchscreen</span><br><span class="line">          controller.</span><br><span class="line"> </span><br><span class="line">endchoice</span><br></pre></td></tr></table></figure>

<p>图 7-9</p>
<p>我们在内核目录下输入make menuconfig可以看到，如下（图7-10）所示，“Parade TrueTouch Gen5 MultiTouch Protocol”是choice选项名称，“Protocol B”是Kconfig里面默认选择的。“–&gt;”代表此菜单能进入，需要键盘操作进入。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps38.jpg" alt="img"> </p>
<p>图7-10</p>
<p>进入“Parade TrueTouch Gen5 MultiTouch Protocol”后，可以看到多选项提供给用户进行选择，如下（图7-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps39.jpg" alt="img"> </p>
<p>图7-11</p>
<p>6.comment</p>
<p>comment 语句出现在界面的第一行，用于定义一些提示信息。</p>
<p>comment “Compiler: $(CC_VERSION_TEXT)”</p>
<p>以上代码的配置界面如下（图7-12）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps40.jpg" alt="img"> </p>
<p>图7-12</p>
<p>7.config</p>
<p>使用关键字config来定义一个新的选项，如下（图7-13）所示</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">config helloworld</span><br><span class="line">bool “hello world support”</span><br><span class="line">default y</span><br><span class="line">help</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>图7-13</p>
<p>如上所示，使用config关键字定义了一个“helloworld”选项，每个选项都必须指定类型，类型包括bool，tristate,string,hex,int。最常见的是bool,tristate,string这三个。</p>
<p>bool类型取值只有“y”和“n”</p>
<p>tristate类型的变量取值有3种：“y”,“n”,“m”</p>
<p>string类型取值为字符串</p>
<p>hex类型取值为十六进制的数据</p>
<p>int类型取值为十进制的数据</p>
<p>help表示帮助信息，当我们在图形化界面按下h按键，弹出来的就是help的内容。</p>
<p>8.depends on</p>
<p>Kconfig中depends on关键字用来指定依赖关系，当依赖的选项被选中时，当前的配置选项的信息才会在菜单中显示出来，才能操作该选项的内容。举例来说，如下所示，选项A依赖选项B，只有当选项B被选中时，选项A才可以被选中。</p>
<p>config A</p>
<p>depends on B</p>
<p>9.select</p>
<p>Kconfig中select关键字用来表示反向依赖关系，当指定当前选项被选中时，此时select后面的选项也会被自动选中。举个例子来说，如下所示，在选项A被选中的情况下，选项B自动被选中。</p>
<p>config A</p>
<p>select on B</p>
<p>\10. menuconfig</p>
<p>menuconfig可以认为是config 中的升级版。menuconfig也是一个正常的配置项，通过自己的配置值来决定另外一组配置项是否作为子菜单的形式显示出来并供用户配置。代码如下（图7-14）所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menuconfig NETDEVICES</span><br><span class="line">	default y if UML</span><br><span class="line">	depends on NET</span><br><span class="line">	bool &quot;Network device support&quot;</span><br><span class="line">	---help---</span><br><span class="line">if NETDEVICES</span><br><span class="line">config MII</span><br><span class="line">	tristate</span><br><span class="line"></span><br><span class="line">config NET_CORE</span><br><span class="line">	default y</span><br><span class="line">	bool &quot;Network core driver support&quot;</span><br><span class="line">	---help---</span><br><span class="line">	  You can say N here if you do not intend to use any of the</span><br><span class="line">	  networking core drivers (i.e. VLAN, bridging, bonding, etc.)</span><br></pre></td></tr></table></figure>

<p>图7-14</p>
<p>以上代码中通过menuconfig配置了一个bool类型的配置项，在图形化配置界面中显示（图7-15）如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps41.jpg" alt="img"> </p>
<p>图7-15</p>
<p>当我们选中”Network device support”配置项时，其子菜单被显示出来，如下图（图7-16）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps42.jpg" alt="img"> </p>
<p>图7-16</p>
<h2 id="7-3-config配置文件介绍"><a href="#7-3-config配置文件介绍" class="headerlink" title="7.3 .config配置文件介绍"></a>7.3 .config配置文件介绍</h2><p>我们在图形化配置界面配置好了以后，会得到一个.config配置文件。在编译内核的时候会根据这个.config文件来编译内核。这样是不是就实现了通过图像化界面的配置来配置内核呀。用通俗的话来说，Kconfig就是饭店的菜单，.config就是客人点完的菜。然后厨师会根据客人点的菜，也就是.config来做菜，对应的操作就是编译内核。</p>
<p>那.config是如何产生的呢？对应上面的例子就是要有服务员给我们点菜呀。</p>
<p>当我们使用make menuconfig的时候，会通过mconf程序去解析Kconfig文件，然后生成对应的配置文件.config。所以这个mconf就是服务员。</p>
<p>mconf程序源码在内核源码scripts&#x2F;kconfig目录下，如下图所示，这里不对Kconfig文件的解析流程进行分析，感兴趣的同学可以自行分析下mconf的源码。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps43.jpg" alt="img"> </p>
<p>图7-18</p>
<p>有了.config配置文件以后，内核就可以根据这个配置文件来编译内核，比如控制某些驱动编译进内核，或者控制某些驱动不编译内核。那他是怎么实现的呢？</p>
<p>.config会通过syncconfig目标将.config作为输入然后输出需要文件，这里我们重点更关注auto.conf和autoconf.h。如下图（图7-19）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps44.jpg" alt="img"> </p>
<p>图7-19</p>
<p>在auto.conf文件中，存放的是配置信息。如下图（图7-20）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps45.jpg" alt="img"> </p>
<p>图7-20</p>
<p>在内核源码的顶层Makefile中会包含auto.conf文件，以此引用其中的变量来控制Makefile的动作，如哪些驱动编译，哪些驱动不编译。如：</p>
<p>auto.conf文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include include/config/auto.conf</span><br><span class="line">CONFIG _A=y</span><br></pre></td></tr></table></figure>

<p>顶层Makefile中包含auto.conf文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifeq ($(dot-config),1)</span><br><span class="line">include include/config/auto.conf</span><br><span class="line">Endif</span><br></pre></td></tr></table></figure>



<p>内核源码下drivers&#x2F;A&#x2F;Makefile引用这个变量</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG _A) +=A.o</span><br></pre></td></tr></table></figure>



<p>注：obj-y就是编译进内核，obj-m就是编译成ko文件。</p>
<p>在autoconf.h中，是C语言代码。用来配合编译时的条件选择。如下图（图7-21）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps46.jpg" alt="img"> </p>
<p>图7-21</p>
<h2 id="7-4-defconfig配置文件"><a href="#7-4-defconfig配置文件" class="headerlink" title="7.4 defconfig配置文件"></a>7.4 defconfig配置文件</h2><p>defconfig文件和.config文件都是linux内核的配置文件，defconfig文件在内核源码的arch&#x2F;$(ARCH)&#x2F;configs目录下，是Linux系统默认的配置文件。比如说瑞芯微平台Linux源码默认的配置文件为：kernel&#x2F;arch&#x2F;arm64&#x2F;configs&#x2F;rockchip_linux_defconfig。</p>
<p>.config文件位于Linux内核源码的顶层目录下，编译Linux内核时会使用.config文件里面的配置来编译内核镜像。</p>
<p>如果.config文件存在，make menuconfig界面的默认配置也就是当前.config文件的配置，如果修改了图形化配置界面的设置并保存，那么.config文件会被更新。</p>
<p>如果.config文件不存在，使用命令“make XXX_defconfig”命令会根据arch&#x2F;$(ARCH)&#x2F;configs目录下的XXX_defconfig自动生成.config。make menuconfig界面的默认配置则为defconfig文件中的默认配置，比如说瑞芯微平台Linux内核源码目录下输入“make rockchip_linux_defconfig”会自动生成.config文件。那么此时rockchip_linux_defconfig的配置项和.config的配置项是相同的。</p>
<h2 id="7-5-自定义菜单实验"><a href="#7-5-自定义菜单实验" class="headerlink" title="7.5 自定义菜单实验"></a>7.5 自定义菜单实验</h2><p>有了上面的理论基础后，我们就可以自己在图形化配置界面中来自定义一个菜单，要定义一个菜单，根据我们前面的分析，是不是就要从Kconfig文件入手呀。因为图形化配置界面是根据Kconfig文件来生成的！</p>
<p>1 在kernel目录下创建一个topeet的文件夹，如下（图7-22）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps47.jpg" alt="img"> </p>
<p>图7-22</p>
<p>2 打开kernel下的Kconfig文件，在里面加入以下代码：</p>
<p>source “topeet&#x2F;Kconfig”</p>
<p>添加完成后如下（图7-23）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps48.jpg" alt="img"> </p>
<p>图7-23</p>
<p>3 然后进入到topeet文件夹，在此文件夹下创建一个Kconfig文件，创建完成如下（图7-24）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps49.jpg" alt="img"> </p>
<p>图7-24</p>
<p>4 打开创建好的Kconfig文件，写入以下（图7-25）内容：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">menu <span class="string">&quot;test menu&quot;</span></span><br><span class="line">config TEST_CONFIG</span><br><span class="line">bool <span class="string">&quot;test&quot;</span></span><br><span class="line">default y</span><br><span class="line">help</span><br><span class="line">just test</span><br><span class="line">comment <span class="string">&quot;just test&quot;</span></span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure>

<p>图7-25</p>
<p>在上面的代码中，我们在主菜单中添加了一个名为 test menu 的子菜单，然后在这个子菜单里面我们添加了一个名为 TEST_CONFIG 的配置项，这个配置项变量类型为 bool，默认配置为 Y，帮助信息为 just test，注释为 just test。添加完成如下图（图7-26）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps50.jpg" alt="img"> </p>
<p>图7-26</p>
<p>5 添加完成以后，打开图形化配置界面，如下图（图7-27）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps51.jpg" alt="img"> </p>
<p>图7-27</p>
<p>6子菜单中的配置项，默认为 y，注释信息为 just test。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps52.jpg" alt="img"> </p>
<p>图7-28</p>
<p>7 在此界面输入？，显示帮助信息为 just test，如下（图7-29）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps53.jpg" alt="img"> </p>
<p>图7-29</p>
<p>8 保存退出后，打开内核源码目录下的.config 文件，如下图（图7-30）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps54.jpg" alt="img"> </p>
<p>图7-30</p>
<p>9 可以在这个.config 文件中找到添加的 TEST_CONFIG（注意，我们需要在 make menuconfig 中保存才可以看到，否则是看不到我们添加的这个选项的），这样在编译内核的时候就可以根据这个配置信息来执行对应的操作了，就是我们下一章节要给大家讲的把驱动编译进内核，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps55.jpg" alt="img"> </p>
<p>图7-31</p>
<h1 id="第8章-驱动模块编译进内核实验"><a href="#第8章-驱动模块编译进内核实验" class="headerlink" title="第8章 驱动模块编译进内核实验"></a>第8章 驱动模块编译进内核实验</h1><p>通过上一章的学习，我们学会了使用menuconfig图形化配置工具，以及了解了menuconfig相关的文件：Kconfig .config XXXdefconfig。本章节学习将helloworld驱动编译进内核。</p>
<p>输入“cd drivers&#x2F;char”进入到 drivers&#x2F;char 目录下，然后输入“mkdir hello”建立hello文件夹，并输入“cd hello”进入hello文件夹，如下（图8-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps56.jpg" alt="img"> </p>
<p>图8-1</p>
<p>然后将第三章编写的hello.c文件拷贝到hello文件夹内。如下（图8-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps57.jpg" alt="img"> </p>
<p>图8-2</p>
<p>输入“touch Kconfig”命令创建Kconfig文件，Kconfig文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config HELLO</span><br><span class="line">tristate &quot;hello world&quot;</span><br><span class="line">help</span><br><span class="line">hello hello</span><br></pre></td></tr></table></figure>

<p>然后“touch Makefile”命令创建Makefile文件,Makefile文件内容如下所示：</p>
<p>obj-$(CONFIG_HELLO)+&#x3D;helloworld.o</p>
<p>接下来修改上一级目录的Kconfig文件和Makefile文件，也就是driver&#x2F;char目录。Makefile添加如下图(图8-3)所示内容。</p>
<p>obj-y +&#x3D; hello&#x2F;</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps58.jpg" alt="img"> </p>
<p>图8-3</p>
<p>Kconfig添加如下图（图8-4）所示内容：</p>
<p>source “drivers&#x2F;char&#x2F;hello&#x2F;Kconfig”</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps59.jpg" alt="img"> </p>
<p>图8-4</p>
<p>最后打开menuconfig图形化配置工具，在配置界面选择helloworld驱动。把驱动编译进Linux内核，用 * 来表示，所以配置选项改为*。如果想要将驱动编译为模块，则用M来表示，配置选项改为M。这里我们选择成 * </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">Device Drivers ─&gt;</span><br><span class="line">    Character devices ---&gt;</span><br><span class="line">        &lt;*&gt; hello world或者&lt;M&gt; hello world</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps60.jpg" alt="img"> </p>
<p>图8-5</p>
<p>然后将光标移动到save，保存配置，如下图（图8-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps61.jpg" alt="img"> </p>
<p>图8-6</p>
<p>保存到.config文件，如下（图8-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps62.jpg" alt="img"> </p>
<p>图-7</p>
<p>退出配置界面，然后输入以下命令便可以编译源码了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make savedefconfig</span><br><span class="line">cp defconfig arch/arm64/configs/rockchip_linux_defconfig </span><br><span class="line">cd ../</span><br><span class="line">./build.sh kernel</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps63.jpg" alt="img"> </p>
<p>图8-8</p>
<p>编译成功之后，进入到drivers&#x2F;char&#x2F;hello目录下，可以看到会生成对应的.o文件。就说明已经成功将驱动编译进内核。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps64.jpg" alt="img"> </p>
<p>图8-9</p>
<p>将编译好的内核镜像烧写到开发板上后，在开发板系统启动的时候也可以成功看到加载helloworld驱动，如下图（图8-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps65.jpg" alt="img"> </p>
<p>图8-10</p>
<p>如果在图形化配置界面中选择的M，也就是编译成驱动模块，则生成helloworld.ko文件如下图（图8-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps66.jpg" alt="img"> </p>
<p>图8-11</p>
<h1 id="第9章-申请字符设备号实验"><a href="#第9章-申请字符设备号实验" class="headerlink" title="第9章 申请字符设备号实验"></a>第9章 申请字符设备号实验</h1><p>经过前面章节的学习，相信大家已经对驱动模块的基本框架、驱动模块传参等知识有了自己的认识，本章节开始就要进入字符设备的世界了。 字符设备是指在I&#x2F;O传输过程中以字符为单位进行传输的设备，可以使用与普通文件相同的文件操作命令（打开、关闭、读、写等）对字符设备进行操作，是Linux驱动中最基本的一类设备驱动，例如最常见的LED、按键、IIC、SPI，LCD等都属于字符设备的范畴。要想对字符设备进行操作，需要通过设备号来对相应的设备进行查找，在本章节将对设备号相关知识进行讲解。 </p>
<h2 id="9-1-申请驱动设备号"><a href="#9-1-申请驱动设备号" class="headerlink" title="9.1 申请驱动设备号"></a>9.1 申请驱动设备号</h2><h3 id="9-1-1-设备号申请"><a href="#9-1-1-设备号申请" class="headerlink" title="9.1.1 设备号申请"></a>9.1.1 设备号申请</h3><p>在Linux系统中每一个设备都有相应的设备号，通过该设备号查找对应的设备，从而进行之后的文件操作。设备号有主设备号与次设备号之分，主设备号用来表示一个特定的驱动，次设备号用来管理下面的设备。</p>
<p>在Linux驱动中可以使用以下两种方法进行设备号的申请：</p>
<p>1.通过register_chrdev_region(dev_t from, unsigned count, const char *name)函数进行静态申请设备号。</p>
<p>2.通过alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,const char *name)函数进行动态申请设备号。</p>
<p>两个函数在“内核源码&#x2F;include&#x2F;linux&#x2F;fs.h”文件中引用(在编写驱动程序的时候要加入该文件的引用)，如下（图9-1）所示： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *, <span class="type">unsigned</span>, <span class="type">unsigned</span>, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">register_chrdev_region</span><span class="params">(<span class="type">dev_t</span>, <span class="type">unsigned</span>, <span class="type">const</span> <span class="type">char</span> *)</span>;   </span><br></pre></td></tr></table></figure>

<p>图9-1</p>
<p>静态申请设备号：</p>
<p><strong>函数原型</strong>：</p>
<p>register_chrdev_region(dev_t from, unsigned count, const char *name)</p>
<p><strong>函数作用：</strong></p>
<p>静态申请设备号，对指定好的设备号进行申请。</p>
<p><strong>参数含义：</strong></p>
<p> from: 自定义的dev_t类型设备号</p>
<p> count: 申请设备的数量</p>
<p> name: 申请的设备名称</p>
<p><strong>函数返回值：</strong>申请成功返回0，申请失败返回负数</p>
<p>动态申请设备号：</p>
<p><strong>函数原型：</strong></p>
<p>alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,const char *name)</p>
<p><strong>函数作用</strong></p>
<p>动态申请设备号，内核会自动分配一个未使用的设备号，相较于静态申请设备号，动态申请会避免注册设备号相同引发冲突的问题。</p>
<p><strong>参数含义</strong></p>
<p>dev *: 会将申请完成的设备号保存在dev变量中</p>
<p>baseminor: 次设备号可申请的最小值</p>
<p>count: 申请设备的数量</p>
<p>name: 申请的设备名称</p>
<p>****函数返回值：****申请成功返回0，申请失败返回负数</p>
<p>对于申请设备号所用到的函数就讲解完成了，会在之后的测试小节对两个函数进行实际运用。</p>
<h3 id="9-1-2-设备号类型"><a href="#9-1-2-设备号类型" class="headerlink" title="9.1.2 设备号类型"></a>9.1.2 设备号类型</h3><p>申请的设备号类型为dev_t ，在“内核源码&#x2F;include&#x2F;linux&#x2F;types.h” 文件中定义如下（图9-2）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> u32 <span class="type">__kernel_dev_t</span>;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">__kernel_dev_t</span>      <span class="type">dev_t</span>;</span><br></pre></td></tr></table></figure>

<p>图 9-2</p>
<p>dev_t为u32类型，而u32 定义在文件 “内核源码&#x2F;include&#x2F;uapi&#x2F;asm-generic&#x2F;int-ll64.h”文件中，定义如下（图9-3）： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> __u32;</span><br></pre></td></tr></table></figure>

<p>图 9-3</p>
<p>__u32为unsigned int类型，所以dev_t是一个无符号的32位整形类型。其中高12位表示主设备号，低20位表示次设备号。在“内核源码&#x2F;include&#x2F;linux&#x2F;kdev_t.h”中提供了设备号相关的宏定义，如下（图9-4）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MINORBITS   20   <span class="comment">/*次设备号位数*/</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINORMASK   ((1U &lt;&lt; MINORBITS) - 1)  <span class="comment">/*次设备号掩码*/</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAJOR(dev)  ((unsigned int) ((dev) &gt;&gt; MINORBITS))<span class="comment">/*dev右移20位得到主设备号*/</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINOR(dev)  ((unsigned int) ((dev) &amp; MINORMASK))  <span class="comment">/*与次设备掩码与，得到次设备号*/</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MKDEV(ma,mi)    (((ma) &lt;&lt; MINORBITS) | (mi))<span class="comment">/*MKDEV宏将主设备号（ma）左移20位，然后与次设备号（mi）相与，得到设备号*/</span></span></span><br></pre></td></tr></table></figure>

<p>图 9-4</p>
<p>在稍后的实验中不论是静态申请设备号还是动态申请设备号都会用到上述宏，例如在静态申请设备号时需要将指定的主设备号和从设备号通过MKDEV(ma,mi)宏进行设备号的转换，在动态申请设备号时可以用MAJOR(dev) 和MINOR(dev)宏将动态申请的设备号转化为主设备号和从设备号。</p>
<p>至此，关于设备号相关的知识就结束了，在下一小节中将对申请设备号实验代码进行编写。</p>
<h2 id="9-2-实验程序的编写"><a href="#9-2-实验程序的编写" class="headerlink" title="9.2 实验程序的编写"></a>9.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\04。</p>
<p>本章节实验将编写Linux下申请字符设备号实例代码，如果在进行驱动模块加载时传入了major主设备号，则通过静态的方式进行设备号的申请，如果不传入任何参数进行驱动模块加载，则通过动态的方式进行设备号申请。</p>
<p>编写完成的dev_t.c代码如下（图9-5）所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>                                                                                                                                </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major;<span class="comment">//定义静态加载方式时的主设备号参数major</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> minor;<span class="comment">//定义静态加载方式时的次设备号参数minor</span></span><br><span class="line">module_param(major,<span class="type">int</span>,S_IRUGO);<span class="comment">//通过驱动模块传参的方式传递主设备号参数major</span></span><br><span class="line">module_param(minor,<span class="type">int</span>,S_IRUGO);<span class="comment">//通过驱动模块传参的方式传递次设备号参数minor</span></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型(32位大小)的变量dev_num</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">dev_t_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;<span class="comment">//定义int类型的变量ret，用来判断函数返回值</span></span><br><span class="line">    <span class="comment">/*以主设备号进行条件判断，即如果通过驱动传入了major参数则条件成立，进入以下分支*/</span></span><br><span class="line">    <span class="keyword">if</span>(major)&#123;</span><br><span class="line">        dev_num = MKDEV(major,minor);<span class="comment">//通过MKDEV函数将驱动传参的主设备号和次设备号转换成dev_t类型的设备号</span></span><br><span class="line">        printk(<span class="string">&quot;major is %d\n&quot;</span>,major);</span><br><span class="line">        printk(<span class="string">&quot;minor is %d\n&quot;</span>,minor);</span><br><span class="line">        ret = register_chrdev_region(dev_num,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>);<span class="comment">//通过静态方式进行设备号册</span></span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            printk(<span class="string">&quot;register_chrdev_region is error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        printk(<span class="string">&quot;register_chrdev_region is ok\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*如果没有通过驱动传入major参数，则条件成立，进入以下分支*/</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ret = alloc_chrdev_region(&amp;dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_num&quot;</span>);<span class="comment">//通过动态方式进行设备号注册</span></span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);</span><br><span class="line">        &#125;                                                                                                                                              </span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line">        major=MAJOR(dev_num);<span class="comment">//通过MAJOR()函数进行主设备号获取</span></span><br><span class="line">        minor=MINOR(dev_num);<span class="comment">//通过MINOR()函数进行次设备号获取</span></span><br><span class="line">        printk(<span class="string">&quot;major is %d\n&quot;</span>,major);</span><br><span class="line">        printk(<span class="string">&quot;minor is %d\n&quot;</span>,minor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">dev_t_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    unregister_chrdev_region(dev_num,<span class="number">1</span>);<span class="comment">//释放字符驱动设备号 </span></span><br><span class="line">    printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(dev_t_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(dev_t_exit);<span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);  <span class="comment">//作者信息  </span></span><br></pre></td></tr></table></figure>

<p>图 9-5</p>
<p>以上代码通过对传入参数的判断，从而进行设备号申请方式的选择，会在下一小节进行相应的驱动加载测试。</p>
<h2 id="9-3-运行测试"><a href="#9-3-运行测试" class="headerlink" title="9.3 运行测试"></a>9.3 运行测试</h2><h3 id="9-3-1-编译驱动程序"><a href="#9-3-1-编译驱动程序" class="headerlink" title="9.3.1 编译驱动程序"></a>9.3.1 编译驱动程序</h3><p>在上一小节中的dev_t.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图9-6）所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m += dev_c.o    #此处要和你的驱动源文件同名</span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    #make操作</span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    #make clean操作</span><br></pre></td></tr></table></figure>

<p>图 9-6</p>
<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放dev_t.c和Makefile文件目录下，如下图（图9-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps67.jpg" alt="img"> </p>
<p>图 9-7</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图9-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps68.jpg" alt="img"> </p>
<p>图 9-8</p>
<p>编译完生成dev_t.ko目标文件，如下图（图9-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps69.jpg" alt="img"> </p>
<p>图 9-9</p>
<p>至此我们的驱动模块就编译成功了，下面对驱动进行加载测试。</p>
<h3 id="9-3-2-运行测试"><a href="#9-3-2-运行测试" class="headerlink" title="9.3.2 运行测试"></a>9.3.2 运行测试</h3><p>开发板上电启动之后，使用以下命令加载dev_t.ko驱动，加载完成之后的打印信息如下图图（9-10）所示：</p>
<p>insmod dev_t.ko major&#x3D;200 minor&#x3D;0</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps70.jpg" alt="img"> </p>
<p>图 9-10</p>
<p>可以看到传入的主设备号和次设备号都被打印了出来，“register_chrdev_region is ok”也被成功打印了证明设备注册成功了，然后使用以下命令进行注册设备号的查看，如下图（图9-11）所示：</p>
<p> cat &#x2F;proc&#x2F;devices</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps71.jpg" alt="img"> </p>
<p>图 9-11</p>
<p>可以看到主设备号200的设备名为chrdev_name，和驱动程序中设置的相同，证明我们的设备号注册成功了，然后使用以下命令进行驱动的卸载，如下图（图9-12）所示：</p>
<p>rmmod dev_t.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps72.jpg" alt="img"> </p>
<p>图 9-12</p>
<p>下面进行动态申请设备号实验，使用以下命令进行驱动模块的加载，如下图（图9-13）所示：</p>
<p> insmod dev_t.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps73.jpg" alt="img"> </p>
<p>图 9-13</p>
<p>可以看到动态申请设备号成功了，主设备号为236，次设备号为0，然后使用以下命令进行注册设备号的查看，如下图（图9-14）所示：</p>
<p> cat &#x2F;proc&#x2F;devices</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps74.jpg" alt="img"> </p>
<p>图 9-14</p>
<p>可以看到主设备号236的设备名为chrdev_name，和驱动程序中设置的相同，证明我们的设备号注册成功了，最后可以输入以下命令对驱动进行卸载，卸载完成如下图（图9-15）所示：</p>
<p>rmmod dev_t.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps75.jpg" alt="img"> </p>
<p>图 9-15</p>
<h1 id="第10章-注册字符设备实验"><a href="#第10章-注册字符设备实验" class="headerlink" title="第10章 注册字符设备实验"></a>第10章 注册字符设备实验</h1><p>在上一小节中已经对设备号的相关知识进行了讲解，并成功申请到了设备号，那在Linux系统中，设备号是怎样与字符设备进行关联的呢？字符设备又是怎样注册的呢？带着疑问，让我们开始本章节的学习吧。</p>
<h2 id="10-1-注册字符设备"><a href="#10-1-注册字符设备" class="headerlink" title="10.1 注册字符设备"></a>10.1 注册字符设备</h2><p>注册字符设备可以分为两个步骤：</p>
<p>1.字符设备初始化</p>
<p>2.字符设备的添加</p>
<p>在本小节将对上述两个步骤所用到的函数和结构体进行讲解。</p>
<h3 id="10-1-1-字符设备初始化"><a href="#10-1-1-字符设备初始化" class="headerlink" title="10.1.1 字符设备初始化"></a>10.1.1 字符设备初始化</h3><p>字符设备初始化所用到的函数为cdev_init(…),在对该函数讲解之前，首先对cdev结构体进行介绍。</p>
<p>Linux 内核中将字符设备抽象成一个具体的数据结构 (struct cdev), 我们可以理解为字符设备对象，cdev 记录了字符设备号、内核对象、文件操作file_operations结构体（设备的打开、读写、关闭等操作接口）等信息，struct cdev 结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;cdev.h”文件中（在编写驱动程序的时候要加入该文件的引用），如下（图10-1）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>                  <span class="comment">//内嵌的内核对象.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>                 <span class="comment">//该字符设备所在的内核模块的对象指针.</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span>    <span class="comment">//该结构描述了字符设备所能实现的方法，是极为关键的一个结构体.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>                <span class="comment">//用来将已经向内核注册的所有字符设备形成链表.</span></span><br><span class="line">	<span class="type">dev_t</span> dev;                            <span class="comment">//字符设备的设备号，由主设备号和次设备号构成.</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> count;                   <span class="comment">//隶属于同一主设备号的次设备号的个数.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>图 10-1</p>
<p>关于该结构体参数的注释在上图已经添加，设备初始化所用到的函数为cdev_init(),该函数同样在“内核源码&#x2F;include&#x2F;linux&#x2F;cdev.h”文件中所引用如下（图10-2）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="type">const</span> <span class="keyword">struct</span> file_operations *)</span>;</span><br></pre></td></tr></table></figure>

<p> 图10-2</p>
<p>该函数的详细内容在“内核源码&#x2F;include&#x2F;fs&#x2F;char_dev.c”文件中定义，如下（图10-3）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cdev, <span class="number">0</span>, <span class="keyword">sizeof</span> *cdev);<span class="comment">//将整个结构体清零；</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);<span class="comment">//初始化list成员使其指向自身；</span></span><br><span class="line">    kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);<span class="comment">//初始化kobj成员；</span></span><br><span class="line">    cdev-&gt;ops = fops;<span class="comment">//初始化ops成员，建立cdev 和 file_operations之间的连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图 10-3</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>初始化传入的cdev 类型的结构体，并与自定义的file_operations * 类型的结构体进行链接。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p> cdev: 要传入的cdev类型结构体，为要初始化的字符设备。</p>
<p> fops：要传入的file_operations * 类型结构体，关于file_operations结构体的相关的知识会在下一章节进行讲解。</p>
<p>****函数返回值：****无返回值。</p>
<h3 id="10-1-2-字符设备的注册"><a href="#10-1-2-字符设备的注册" class="headerlink" title="10.1.2 字符设备的注册"></a>10.1.2 字符设备的注册</h3><p><em><strong>*字符设备的注册：*</strong></em>	</p>
<p>字符设备添加所用到的函数为cdev_add()，该函数在“内核源码&#x2F;include&#x2F;linux&#x2F;cdev.h”文件中所引用，如下（图10-4）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="type">dev_t</span>, <span class="type">unsigned</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>图 10-4</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int cdev_add(struct cdev *p, dev_t dev, unsigned count)   </p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>该函数向内核注册一个struct cdev结构体</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>(1)第一个参数为要添加的struct cdev 类型的结构体</p>
<p>(2)第二个参数为申请的字符设备号</p>
<p>(3)第三个参数为和该设备关联的设备编号的数量。</p>
<p>这两个参数直接赋值给struct cdev 的dev成员和count成员。</p>
<p>****函数返回值：****添加成功返回0，添加失败返回负数。</p>
<p><em><strong>*字符设备的注销：*</strong></em></p>
<p>字符设备删除所用到的函数为cdev_del()，该函数同样在“内核源码&#x2F;include&#x2F;linux&#x2F;cdev.h”文件中所引用，如下（图10-5）所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void cdev_del(struct cdev *);</span><br></pre></td></tr></table></figure>

<p>图 10-5</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>void cdev_del(struct cdev *p)  </p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>该函数会向内核删除一个struct cdev 类型结构体</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>该函数只有一个参数，为要删除的struct cdev 类型的结构体</p>
<p>****函数返回值：****无返回值</p>
<p>至此，关于注册字符设备实验所用到的函数就讲解完成了，在下一小节中将编写注册字符设备代码。</p>
<h2 id="10-2-实验程序的编写"><a href="#10-2-实验程序的编写" class="headerlink" title="10.2 实验程序的编写"></a>10.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\05。</p>
<p>本实验采用动态申请设备号的方式进行设备号的申请，然后对设备进行注册，并将申请到的主设备号和次设备号以及设备注册情况打印到终端上。</p>
<p>编写完成的cdev.c代码如下（图10-6）所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型（32位大小）的变量dev_num,用来存放设备号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义cdev结构体类型的变量cdev_test</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_ops</span>&#123;</span></span><br><span class="line">	.owner=THIS_MODULE<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">&#125;;<span class="comment">//定义file_operations结构体类型的变量cdev_test_ops</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">module_cdev_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;<span class="comment">//定义int类型变量ret，进行函数返回值判断</span></span><br><span class="line">    <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>);<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_register_region is ok\n&quot;</span>);</span><br><span class="line">    major = MAJOR(dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">    minor = MINOR(dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">    printk(<span class="string">&quot;major is %d\n&quot;</span>,major);</span><br><span class="line">    printk(<span class="string">&quot;minor is %d\n&quot;</span>,minor);                                         </span><br><span class="line">cdev_init(&amp;cdev_test,&amp;cdev_test_ops);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到cdev_test_ops结构体</span></span><br><span class="line">cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块 </span></span><br><span class="line">    ret = cdev_add(&amp;cdev_test,dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        printk(<span class="string">&quot;cdev_add is error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;cdev_add is ok\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">module_cdev_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cdev_del(&amp;cdev_test);<span class="comment">//使用cdev_del()函数进行字符设备的删除</span></span><br><span class="line">    unregister_chrdev_region(dev_num,<span class="number">1</span>);<span class="comment">//释放字符驱动设备号 </span></span><br><span class="line">    printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(module_cdev_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(module_cdev_exit);<span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);  <span class="comment">//作者信息  </span></span><br></pre></td></tr></table></figure>

<p>图 10-6</p>
<p>相较于上一章节实验，本章节的代码去掉了静态申请设备号部分代码，并在申请设备号完成之后注册了相应的字符设备，并在驱动出口函数中添加了相应的字符设备删除代码（相关代码已加粗）。</p>
<p>需要注意的是，字符设备的注册要放在申请字符设备号之后，字符设备的删除要放在释放字符驱动设备号之前。</p>
<h2 id="10-3-运行测试"><a href="#10-3-运行测试" class="headerlink" title="10.3 运行测试"></a>10.3 运行测试</h2><h3 id="10-3-1-编译驱动程序"><a href="#10-3-1-编译驱动程序" class="headerlink" title="10.3.1 编译驱动程序"></a>10.3.1 编译驱动程序</h3><p>在上一小节中的cdev.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图10-7）所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m += cdev.o    #此处要和你的驱动源文件同名</span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    #make操作</span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    #make clean操作</span><br></pre></td></tr></table></figure>

<p>图 10-7</p>
<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放parameter.c和Makefile文件目录下，如下图（图10-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps76.jpg" alt="img"> </p>
<p>图 10-8</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图10-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps77.jpg" alt="img"> </p>
<p>图 10-9</p>
<p>编译完会生成 cdev.ko目标文件，如下图（图10-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps78.jpg" alt="img"> </p>
<p>图 10-10</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h3 id="10-3-2-运行测试"><a href="#10-3-2-运行测试" class="headerlink" title="10.3.2 运行测试"></a>10.3.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图10-11）所示：</p>
<p>insmod cdev.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps79.jpg" alt="img"> </p>
<p>图 10-11</p>
<p>可以看到动态申请设备号成功了，主设备号为236，次设备号为0，然后使用以下命令进行注册设备号的查看，如下图（图10-12）所示：</p>
<p> cat &#x2F;proc&#x2F;devices</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps80.jpg" alt="img"> </p>
<p>图 10-12</p>
<p>可以看到主设备号236的设备名为chrdev_name，和驱动程序中设置的设备名称相同，证明字符设备注册成功了，最后可以使用以下命令对驱动进行卸载，卸载完成如下图（10-13）所示：</p>
<p>rmmod cdev.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps81.jpg" alt="img"> </p>
<p>图 10-13</p>
<h1 id="第11章-创建设备节点实验"><a href="#第11章-创建设备节点实验" class="headerlink" title="第11章 创建设备节点实验"></a>第11章 创建设备节点实验</h1><p>在上两个章节的学习中，我们已经成功的申请了设备号并且注册了相应的字符设备。系统通过设备号对设备进行查找，而字符设备注册到内核之后，并不能直接进行设备文件操作命令（打开、关闭、读、写等），需要相应的设备文件作为桥梁以此来进行设备的访问，在本章节将对如何创建设备节点进行学习。 </p>
<h2 id="11-1-创建设备节点"><a href="#11-1-创建设备节点" class="headerlink" title="11.1 创建设备节点"></a>11.1 创建设备节点</h2><p>在Linux操作系统中一切皆文件，设备访问也是通过文件的方式来进行的，对于用来进行设备访问的文件称之为设备节点，设备节点被创建在&#x2F;dev目录下，将内核中注册的设备与用户层进行链接，这样应用程序才能对设备进行访问。</p>
<p>根据设备节点的创建方式不同，分为了手动创建设备节点和自动创建设备节点，下面对两种设备节点创建方式进行介绍。</p>
<h3 id="11-1-1-手动创建设备节点"><a href="#11-1-1-手动创建设备节点" class="headerlink" title="11.1.1 手动创建设备节点"></a>11.1.1 手动创建设备节点</h3><p>使用mknod命令手动创建设备节点，mknod 命令格式为：</p>
<p>mknod NAME TYPE MAJOR MINOR</p>
<p>参数含义：</p>
<p>NAME: 要创建的节点名称</p>
<p>TYPE: b表示块设备，c表示字符设备，p表示管道</p>
<p>MAJOR：要链接设备的主设备号</p>
<p>MINOR: 要链接设备的从设备号</p>
<p>例如使用以下命令创建一个名为device_test的字符设备节点，链接设备的主设备号和从设备号分别为236和0：</p>
<p>mknod &#x2F;dev&#x2F;device_test c 236 0 </p>
<h3 id="11-1-2-自动创建设备节点"><a href="#11-1-2-自动创建设备节点" class="headerlink" title="11.1.2 自动创建设备节点"></a>11.1.2 自动创建设备节点</h3><p>设备文件的自动创建是利用udev(mdev)机制来实现，多数情况下采用自动创建设备节点的方式。udev(mdev)可以检测系统中硬件设备状态，可以根据系统中硬件设备状态来创建或者删除设备文件。在驱动中首先使用class_create(…)函数对class进行创建，这个类存放于&#x2F;sys&#x2F;class&#x2F; 目录下，之后使用device_create(…)函数创建相应的设备，在进行模块加载时，用户空间中的udev会自动响应device_create()函数，寻找对应的类从而创建设备节点。</p>
<p>下面对于自动创建节点中所用到的函数进行解释说明：</p>
<p><em><strong>*class_create(…)函数*</strong></em></p>
<p>该函数在“内核源码&#x2F;include&#x2F;linux&#x2F;device.h”文件中所引用（由于上一小节中引用的cdev.h文件已包含device.h，所以不需要再重复引用），如下（图11-1）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> class_create(owner, name)       \</span></span><br><span class="line"><span class="meta">(&#123;                      \</span></span><br><span class="line"><span class="meta">   static struct lock_class_key __key; \</span></span><br><span class="line"><span class="meta">    __class_create(owner, name, &amp;__key);    \                                                                           </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>图 11-1</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>用于动态创建设备的逻辑类，并完成部分字段的初始化，然后将其添加进Linux内核系统。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>owner：struct module结构体类型的指针，指向函数即将创建的这个struct class的模块。一般赋值为THIS_MODULE。</p>
<p>name：char类型的指针，代表即将创建的struct class变量的名字。</p>
<p>返回值：struct class * 类型的结构体。 </p>
<p><em><strong>*class_destroy(…)函数*</strong></em></p>
<p>该函数在“内核源码&#x2F;include&#x2F;linux&#x2F;device.h”文件中所引用，如下（图11-2）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">class_destroy</span><span class="params">(<span class="keyword">struct</span> class *cls)</span>;  </span><br></pre></td></tr></table></figure>

<p>图 11-2</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>用于删除设备的逻辑类，即从Linux内核系统中删除设备的逻辑类。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>owner：struct module结构体类型的指针，指向函数即将创建的这个struct class的模块。一般赋值为THIS_MODULE。</p>
<p>name：char类型的指针，代表即将创建的struct class变量的名字。</p>
<p>返回值：无</p>
<p><em><strong>*device_create(…)函数*</strong></em></p>
<p>该函数在“内核源码&#x2F;include&#x2F;linux&#x2F;device.h”文件中所引用，如下（图11-3）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> device *<span class="title function_">device_create</span><span class="params">(<span class="keyword">struct</span> class *cls, <span class="keyword">struct</span> device *parent,                                                  </span></span><br><span class="line"><span class="params">               <span class="type">dev_t</span> devt, <span class="type">void</span> *drvdata,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>图 11-3</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>用来在class类中下创建一个设备属性文件，udev会自动识别从而进行设备节点的创建。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>cls：指定所要创建的设备所从属的类。</p>
<p>parent:指定该设备的父设备，如果没有就指定为NULL。</p>
<p>devt:指定创建设备的设备号。</p>
<p>drvdata:被添加到该设备回调的数据，没有则指定为NULL。</p>
<p>fmt：添加到系统的设备节点名称。</p>
<p>****返回值：****struct device * 类型结构体</p>
<p><em><strong>*device_destroy(…)函数*</strong></em></p>
<p>在“内核源码&#x2F;include&#x2F;linux&#x2F;device.h”文件中所引用，如下（图11-4）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">device_destroy</span><span class="params">(<span class="keyword">struct</span> class *cls, <span class="type">dev_t</span> devt)</span>; </span><br></pre></td></tr></table></figure>

<p>图 11-4</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>用来删除class类中的设备属性文件，udev会自动识别从而进行设备节点的删除。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>cls：指定所要创建的设备所从属的类。</p>
<p>devt:指定创建设备的设备号。</p>
<p>返回值：无</p>
<p>至此，关于自动创建节点相关的函数就介绍完成了，会在下一小节中对于设备节点的自动创建进行相应实验程序的编写。</p>
<h2 id="11-2-实验程序的编写"><a href="#11-2-实验程序的编写" class="headerlink" title="11.2 实验程序的编写"></a>11.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\06。</p>
<p>本章实验将编写Linux下的自动创建设备节点实验代码，首先采用自动申请设备号的方式进行设备号的申请，并对获取的主设备号与次设备号进行打印，之后对字符设备进行注册(file_operations结构体只填充owner 字段即可，会在下个章节对file_operations结构体进行讲解)，最后自动对设备节点进行创建。</p>
<p>编写完成的chrdev_node.c代码如下（图11-5）所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_fops_test</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">&#125;;<span class="comment">//定义file_operations结构体类型的变量cdev_test_ops</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chrdev_fops_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;<span class="comment">//定义int类型的变量ret，用来对函数返回值进行判断</span></span><br><span class="line">    <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>);<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">    <span class="keyword">if</span> (ret  &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">    major = MAJOR(dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">    minor = MINOR(dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">    printk(<span class="string">&quot;major is %d\n minor is %d \n&quot;</span>,major,minor);</span><br><span class="line">    cdev_init(&amp;cdev_test,&amp;cdev_fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到cdev_test_ops结构&gt;体</span></span><br><span class="line">    cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    ret = cdev_add(&amp;cdev_test,dev_num,<span class="number">1</span>); <span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">         printk(<span class="string">&quot;cdev_add is error \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;cdev_add is ok \n&quot;</span>);</span><br><span class="line">    class_test  = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">    device_create(class_test,<span class="literal">NULL</span>,dev_num,<span class="literal">NULL</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chrdev_fops_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cdev_del(&amp;cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">    unregister_chrdev_region(dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">    device_destroy(class_test,dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">    class_destroy(class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">    printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(chrdev_fops_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(chrdev_fops_exit);<span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);<span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>图 11-5</p>
<p>相较于上一章节实验，本章节代码在入口函数中添加了自动创建设备节点相关代码，在驱动出口函数中添加了相应的删除设备节点相关代码(相关代码已加粗)。</p>
<p>需要注意的是，在进行设备节点添加时，类的创建要放在设备创建之前；在进行设备节点删除时，类的删除要放在设备删除之后。</p>
<h2 id="11-3-运行测试"><a href="#11-3-运行测试" class="headerlink" title="11.3 运行测试"></a>11.3 运行测试</h2><h3 id="11-3-1-编译驱动程序"><a href="#11-3-1-编译驱动程序" class="headerlink" title="11.3.1 编译驱动程序"></a>11.3.1 编译驱动程序</h3><p>在上一小节中的chrdev_node.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图11-6）所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += chrdev_node.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>图 11-6</p>
<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放chrdev_node.c和Makefile文件目录下，如下图（图11-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps82.jpg" alt="img"> </p>
<p>图 11-7</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图11-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps83.jpg" alt="img"> </p>
<p>图 11-8</p>
<p>编译完生成 chrdev_node.ko目标文件，如下图（图11-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps84.jpg" alt="img"> </p>
<p>图 11-9</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h3 id="11-3-2-运行测试"><a href="#11-3-2-运行测试" class="headerlink" title="11.3.2 运行测试"></a>11.3.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图11-10）所示：</p>
<p>insmod cdev.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps85.jpg" alt="img"> </p>
<p>图 11-10</p>
<p>可以看到动态申请设备号成功了，主设备号为236，次设备号为0，然后使用以下命令进行注册设备号的查看，如下图（图11-11）所示：</p>
<p> cat &#x2F;proc&#x2F;devices</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps86.jpg" alt="img"> </p>
<p>图 11-11</p>
<p>可以看到主设备号236的设备名为chrdev_name，和驱动程序中设置的相同，证明我们的设备号注册成功了，然后使用以下命令对class目录进行查看，如下图（图11-12）所示：</p>
<p>ls &#x2F;sys&#x2F;class&#x2F;</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps87.jpg" alt="img"> </p>
<p>图 11-12</p>
<p>可以看到在驱动程序中创建的class_test 类已经被成功创建了，然后使用以下命令对class_test 目录进行查看，如下图（图11-12）所示：</p>
<p>ls &#x2F;sys&#x2F;class&#x2F;class_test&#x2F;</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps88.jpg" alt="img"> </p>
<p>图 11-12</p>
<p>可以看到在驱动程序中创建的名为device_test的设备属性文件夹也被创建了，然后使用命令“ls &#x2F;dev&#x2F;device_test”对&#x2F;dev目录进行查看，相应的设备节点也已经被自动创建了，如下图（图11-13）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps89.jpg" alt="img"> </p>
<p>图 11-13</p>
<p>最后可以使用以下命令进行驱动的卸载，卸载完成如下图（图11-14）所示：</p>
<p>rmmod chrdev_node.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps90.jpg" alt="img"> </p>
<p>图 11-14</p>
<h1 id="第12章-字符设备驱动框架实验"><a href="#第12章-字符设备驱动框架实验" class="headerlink" title="第12章 字符设备驱动框架实验"></a>第12章 字符设备驱动框架实验</h1><p>下面对前面三个章节进行总结，首先驱动向Linux内核进行设备号申请，之后的字符设备注册时，会对申请的设备号进行使用。而Linux 内核会将字符设备抽象成一个具体的struct cdev结构体，该结构体记录了字符设备的字符设备号、内核对象等信息，cdev_init(…)函数对结构体进行初始化之后，cdev_add(…)函数将设备号和cdev结构体进行链接，这时设备号才真正指向了内核中注册的设备。设备注册成功之后，此时还不能对字符设备进行文件操作，所以需要设备节节点来充当内核和用户层通信的桥梁，至此，前面三个章节就总结完成了，以上步骤并没有涉及到操作设备文件，本章节将对字符设备框架进行最终的完善。 </p>
<h2 id="12-1-文件操作集简介"><a href="#12-1-文件操作集简介" class="headerlink" title="12.1 文件操作集简介"></a>12.1 文件操作集简介</h2><p> 在进行注册字符设备实验章节中，使用cdev_init(…)函数对struct cdev结构体类型变量和struct file_operations结构体类型变量相链接，struct file_operations结构体就是把系统调用和驱动程序关联起来的关键数据结构。该结构体的每一个成员都对应着一个系统调用，读取file_operation中相应的函数指针，接着把控制权转交给函数，从而完成了Linux设备驱动程序的工作。</p>
<p>file_operations结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;fs.h”文件中，下面对部分常用函数进行说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br></pre></td></tr></table></figure>

<p>owner是第一个 file_operations 成员，它并不是一个操作, 而一个指向拥有该结构的模块的指针，避免正在操作时被卸载，一般为初始化为THIS_MODULES (在 &lt;linux&#x2F;module.h&gt; 中定义的宏)</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br></pre></td></tr></table></figure>

<p>read函数指针用来从设备中同步读取数据，读取成功返回读取的字节数。与应用程序中的 read函数对应。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br></pre></td></tr></table></figure>

<p>write函数指针用来发送数据给设备. 写入成功返回写入的字节数。与应用程序中的write函数对应。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br></pre></td></tr></table></figure>

<p>unlocked_ioctl函数指针提供对于设备的控制功能，与应用程序中的ioctl函数对应。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br></pre></td></tr></table></figure>

<p>open函数指针用于打开设备,与应用程序中的open函数对应。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br></pre></td></tr></table></figure>

<p>release函数指针在file结构体释放时被调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br></pre></td></tr></table></figure>

<p>至此对于file_operations文件操作集的部分常用函数就介绍完了，填充了部分常用函数的 file_operations结构体如下（图12-1）所示：</p>
<p>图 12-1</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_fops_test</span> =</span> &#123;</span><br><span class="line">   .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">   .open = chrdev_open,<span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">   .read = chrdev_read,<span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">   .write = chrdev_write,<span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">   .release = chrdev_release,<span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;<span class="comment">//定义file_operations结构体类型的变量cdev_test_ops</span></span><br></pre></td></tr></table></figure>



<p>会在下个小节进行字符设备驱动框架实验代码的编写，在上一章节实验的基础上加入file_operations结构体，并通过应用程序对字符设备驱动进行文件操作测试。</p>
<h2 id="12-2-实验程序的编写"><a href="#12-2-实验程序的编写" class="headerlink" title="12.2 实验程序的编写"></a>12.2 实验程序的编写</h2><h3 id="12-2-1-驱动程序编写"><a href="#12-2-1-驱动程序编写" class="headerlink" title="12.2.1 驱动程序编写"></a>12.2.1 驱动程序编写</h3><p>本实验驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\07\module。</p>
<p>本章实验将编写字符设备驱动框架实验，会在上一章节实验基础上对file_operation结构体相关内容进行补充。</p>
<p>首先采用自动申请设备号的方式进行设备号的申请，然后对获取的主设备号与次设备号进行打印，之后对字符设备进行注册，并填充相应的file_openration结构体和相关函数，最后自动对设备节点进行创建，编写完成的chrdev_fops.c代码如下（图12-2）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>                                                                                                    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chrdev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is chrdev_open \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">chrdev_read</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is chrdev_read \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">chrdev_write</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *buf,<span class="type">size_t</span> size,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is chrdev_write \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chrdev_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_fops_test</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = chrdev_open,<span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = chrdev_read,<span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = chrdev_write,<span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = chrdev_release,<span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;<span class="comment">//定义file_operations结构体类型的变量cdev_test_ops</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chrdev_fops_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;<span class="comment">//定义int类型的变量ret，用来对函数返回值进行判断</span></span><br><span class="line">    <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>);<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">    <span class="keyword">if</span> (ret  &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">    major = MAJOR(dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">    minor = MINOR(dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">    printk(<span class="string">&quot;major is %d\n minor is %d \n&quot;</span>,major,minor);</span><br><span class="line">    cdev_init(&amp;cdev_test,&amp;cdev_fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到cdev_test_ops结构体</span></span><br><span class="line">    cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    ret = cdev_add(&amp;cdev_test,dev_num,<span class="number">1</span>); <span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">         printk(<span class="string">&quot;cdev_add is error \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;cdev_add is ok \n&quot;</span>);                                                                                </span><br><span class="line">    class_test  = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">    device_create(class_test,<span class="literal">NULL</span>,dev_num,<span class="literal">NULL</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chrdev_fops_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    device_destroy(class_test,dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">class_destroy(class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">    cdev_del(&amp;cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">    unregister_chrdev_region(dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">    printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(chrdev_fops_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(chrdev_fops_exit);<span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);<span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>图 12-2</p>
<h3 id="12-2-2-编写测试-APP"><a href="#12-2-2-编写测试-APP" class="headerlink" title="12.2.2 编写测试 APP"></a>12.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\07\app。</p>
<p>由于在驱动程序中，只是对一系列文件操作函数添加了标志打印（之后的章节会加入数据的读写），所以本小节的应用程序只是起简单的测试作用。编写完成的应用程序app.c内容如下（图12-3）所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>];<span class="comment">//定义读取缓冲区buf</span></span><br><span class="line">    fd=open(argv[<span class="number">1</span>],O_RDWR,<span class="number">0666</span>);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;open is ok\n&quot;</span>);</span><br><span class="line">	<span class="comment">/*如果第二个参数为read，条件成立，调用read函数，对文件进行读取*/</span>                                                                                                                                  </span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;read&quot;</span>))&#123;</span><br><span class="line">        read(fd,buf,<span class="number">32</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为write，条件成立，调用write函数，对文件进行写入*/</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;write&quot;</span>))&#123;</span><br><span class="line">        write(fd,<span class="string">&quot;hello\n&quot;</span>,<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">close(fd);<span class="comment">//调用close函数，对取消文件描述符到文件的映射</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>图 12-3</p>
<p>上述应用程序逻辑较为简单，第一个参数为要进行读写操作的设备节点，第二个参数为read时，对设备节点进行读操作，第二个参数为write时，对设备节点进行写操作。</p>
<h2 id="12-3-运行测试"><a href="#12-3-运行测试" class="headerlink" title="12.3 运行测试"></a>12.3 运行测试</h2><h3 id="12-3-1-编译驱动程序"><a href="#12-3-1-编译驱动程序" class="headerlink" title="12.3.1 编译驱动程序"></a>12.3.1 编译驱动程序</h3><p>在上一小节中的chrdev_fops.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图12-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += chrdev_fops.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>图 12-4</p>
<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放chrdev_fops.c和Makefile文件目录下，如下图（图12-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps91.jpg" alt="img"> </p>
<p>图 12-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图12-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps92.jpg" alt="img"> </p>
<p>图 12-6</p>
<p>编译完生成chrdev_fops.ko目标文件，如下图（图12-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps93.jpg" alt="img"> </p>
<p>图 12-7</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h3 id="12-3-2-编译应用程序"><a href="#12-3-2-编译应用程序" class="headerlink" title="12.3.2 编译应用程序"></a>12.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图12-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps94.jpg" alt="img"> </p>
<p>图 12-8</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图12-9）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps95.jpg" alt="img"> </p>
<p>图 12-9</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="12-3-3-运行测试"><a href="#12-3-3-运行测试" class="headerlink" title="12.3.3 运行测试"></a>12.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图12-10）所示：</p>
<p>insmod chrdev_fops.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps96.jpg" alt="img"> </p>
<p>图 12-10</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图12-11）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps97.jpg" alt="img"> </p>
<p>图 12-11</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令对open()函数进行测试，如下图（图12-11）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps98.jpg" alt="img"> </p>
<p>图 12-12</p>
<p>可以看到“This is chrdev_open”和“open is ok”信息被打印了，证明应用程序运行成功，且调用了驱动程序中的open(…)函数，而“Segmentation fault”相关打印是因为没有对第二个参数进行传入，这里忽略即可，随后使用以下命令对设备进行读测试，如下图（图12-13）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test read</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps99.jpg" alt="img"> </p>
<p>图 12-13</p>
<p>可以看到“This is chrdev_read”信息被打印了出来，证明驱动程序中的read(…)函数被调用了,然后使用以下命令对设备进行写测试，如下图（图12-14）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test write</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps100.jpg" alt="img"> </p>
<p>图 12-14</p>
<p>可以看到“This is chrdev_write”信息被打印了出来，证明驱动程序中的write(…)函数被调用了。最后可以使用以下命令进行驱动的卸载，如下图（图12-15）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps101.jpg" alt="img"> </p>
<p>图 12-15</p>
<p>至此，字符设备驱动框架实验就完成了。</p>
<h1 id="第13章-杂项设备驱动实验"><a href="#第13章-杂项设备驱动实验" class="headerlink" title="第13章 杂项设备驱动实验"></a>第13章 杂项设备驱动实验</h1><p>经过前面章节的学习，我们已经对字符设备驱动框架有了一定的理解，而本章要讲解的杂项设备属于特殊的一种字符型设备，是对字符设备的一种封装，为最简单的字符设备。为什么从字符设备中单独提取出了杂项设备呢？杂项设备又要如何进行使用呢？带着疑问，让我们进行杂项设备的学习吧！</p>
<h2 id="13-1-杂项设备驱动简介"><a href="#13-1-杂项设备驱动简介" class="headerlink" title="13.1 杂项设备驱动简介"></a>13.1 杂项设备驱动简介</h2><p>在Linux中，把无法归类的五花八门的设备定义成杂项设备。相较于字符设备，杂项设备有以下两个优点:</p>
<p>(1)节省主设备号:杂项设备的主设备号固定为10，而字符设备不管是动态分配还是静态分配设备号，都会消耗一个主设备号，进而造成了主设备号浪费。当系统中注册了多个misc设备驱动时，只需使用子设备号进行区分即可。</p>
<p>(2)使用简单：当使用普通的字符设备驱动时，如果开发人员需要导出操作接口给用户空间，就需要注册对应的字符驱动，并创建字符设备class从而自动在&#x2F;dev下生成设备节点，而misc驱动只需要将基本信息通过结构体传递给相应处理函数即可。</p>
<p>在驱动中使用miscdevice结构体描述misc设备，该结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;miscdevice.h”文件中（在下面的实验代码中需要加入该头文件的引用），具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span>  &#123;</span></span><br><span class="line">	<span class="type">int</span> minor; <span class="comment">/* 子设备号 需要用户填写*/</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;<span class="comment">/* 设备名 需要用户填写*/</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span><span class="comment">/* 设备操作集 需要用户填写*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">this_device</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *nodename;</span><br><span class="line">	<span class="type">umode_t</span> mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义一个misc 设备，一般只需要填充minor、name、fops 这三个成员变量。</p>
<p>minor指次设备号，可以从“内核源码&#x2F;include&#x2F;linux&#x2F;miscdevice.h”文件中预定义的次设备号挑选，也可以自行定义子设备号（没有被其他设备使用即可），通常情况下将该参数设置为MISC_DYNAMIC_MINOR，表示自动分配子设备号。</p>
<p>name表示misc设备的名字。misc设备驱动注册成功之后，会在dev目录下生成名为name的设备节点。</p>
<p>fops 指向了file_operations的结构体，表示字符设备的操作集合。</p>
<h2 id="13-2-杂项设备的注册和卸载"><a href="#13-2-杂项设备的注册和卸载" class="headerlink" title="13.2 杂项设备的注册和卸载"></a>13.2 杂项设备的注册和卸载</h2><p>不同于字符设备的注册和卸载的繁琐，杂项设备的注册可以直接使用函数misc_register函数来完成，杂项设备的卸载可以直接使用misc_deregister函数来完成。上述两个函数均定义在“内核源码&#x2F;include&#x2F;linux&#x2F;miscdevice.h”文件当中。</p>
<p>杂项设备的注册：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int misc_register(struct miscdevice *misc)</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>基于misc_class构造一个设备，将miscdevice结构挂载到misc_list列表上，并初始化与linux设备模型相关的结构。进而起到杂项设备注册的作用。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p> misc: 杂项设备的结构体指针</p>
<p>****函数返回值：****申请成功返回0，申请失败返回负数</p>
<p>杂项设备的卸载：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int misc_deregister(struct miscdevice *misc)</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>从mist_list中删除miscdevice，进而起到杂项设备卸载的作用。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p> misc: 杂项设备的结构体指针</p>
<p>****函数返回值：****卸载成功返回0，申请失败返回负数</p>
<p>至此，注册和卸载杂项设备的API函数就讲解完成了，会在接下来的驱动章节中对上述函数进行具体使用。</p>
<h2 id="13-3-杂项设备驱动框架"><a href="#13-3-杂项设备驱动框架" class="headerlink" title="13.3 杂项设备驱动框架"></a>13.3 杂项设备驱动框架</h2><p>MISC驱动一般使用以下结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">xxx_fops</span>&#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">	.read = xxx_read,</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">xxx_dev</span>&#123;</span></span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">    .name = <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">    .fops = &amp;xxx_fops</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;xxx_init\r\n&quot;</span>);</span><br><span class="line">    ret = misc_register(&amp;xxx_dev);<span class="comment">//注册杂项设备</span></span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         printk( <span class="string">&quot;misc_register failed\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> 	printk( <span class="string">&quot;misc_register ok\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_exit</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;xxx_exit\r\n&quot;</span>);</span><br><span class="line">    misc_deregister(&amp;xxx_dev);  <span class="comment">//卸载杂项设备</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(xxx_init);    <span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(xxx_exit);   </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);   </span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="13-4-实验程序的编写"><a href="#13-4-实验程序的编写" class="headerlink" title="13.4 实验程序的编写"></a>13.4 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\08。</p>
<p>本小节将编写最简单的misc驱动，在驱动入口函数中通过misc_register(…)函数注册杂项设备驱动，在驱动出口函数中通过misc_deregister(…)函数注销杂项设备驱动。编写完成的miscdevice.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>              <span class="comment">//初始化头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>            <span class="comment">//最基本的文件，支持动态添加和卸载模块。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span>        <span class="comment">//注册杂项设备头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span>                <span class="comment">//注册设备节点的文件结构体</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">misc_fops</span> =</span> &#123; <span class="comment">//文件操作集</span></span><br><span class="line">    .owner = THIS_MODULE <span class="comment">////将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">misc_dev</span> =</span> &#123;       <span class="comment">//杂项设备结构体</span></span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR,     <span class="comment">//动态申请的次设备号</span></span><br><span class="line">    .name = <span class="string">&quot;test&quot;</span>,                  <span class="comment">//杂项设备名字是hello_misc</span></span><br><span class="line">    .fops = &amp;misc_fops,              <span class="comment">//文件操作集</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">misc_init</span><span class="params">(<span class="type">void</span>)</span>           </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = misc_register(&amp;misc_dev); <span class="comment">//在初始化函数中注册杂项设备</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;misc registe is error \n&quot;</span>); <span class="comment">//打印注册杂项设备失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;misc registe is succeed \n&quot;</span>);<span class="comment">//打印注册杂项设备成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">misc_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">    misc_deregister(&amp;misc_dev);     <span class="comment">//在卸载函数中注销杂项设备</span></span><br><span class="line">    printk(<span class="string">&quot; misc goodbye! \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(misc_init);</span><br><span class="line">module_exit(misc_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="13-5-运行测试"><a href="#13-5-运行测试" class="headerlink" title="13.5 运行测试"></a>13.5 运行测试</h2><h3 id="13-5-1-编译驱动程序"><a href="#13-5-1-编译驱动程序" class="headerlink" title="13.5.1 编译驱动程序"></a>13.5.1 编译驱动程序</h3><p>在上一小节中的miscdevice.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += miscdevice.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>Makefile保存退出之后，来到存放miscdevice.c和Makefile文件目录下，如下图（图13-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps102.jpg" alt="img"> </p>
<p>图 13-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 13-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps103.jpg" alt="img"> </p>
<p>图 13-2</p>
<p>编译完生成 miscdevice.ko目标文件，如下图（图 13-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps104.jpg" alt="img"> </p>
<p>图 13-2</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h3 id="13-5-2-运行测试"><a href="#13-5-2-运行测试" class="headerlink" title="13.5.2 运行测试"></a>13.5.2 运行测试</h3><p>将编译生成的驱动模块miscdevice.ko拷贝到开发板上，输入以下命令加载驱动模块。</p>
<p>insmod miscdevice.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps105.jpg" alt="img"> </p>
<p>图 13-3</p>
<p>可以看到驱动加载之后，打印“misc registe is succeed”,说明misc驱动注册成功。输入以下命令查看加载的驱动模块，驱动加载成功如下（图13-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps106.jpg" alt="img"> </p>
<p>图 13-4</p>
<p>然后来到&#x2F;sys&#x2F;class&#x2F;misc目录下，可以看到名为“test”的文件夹已经被创建了，在&#x2F;sys&#x2F;class&#x2F;misc目录下有misc类的所有设备，每个注册的杂项设备对应一个文件夹目录，如下图（图13-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps107.jpg" alt="img"> </p>
<p>图 13-5</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps108.jpg" alt="img"> </p>
<p>图 13-7</p>
<p>驱动加载成功之后会生成&#x2F;dev&#x2F;test设备驱动文件，输入以下命令查看杂项设备的主次设备号。</p>
<p>ls &#x2F;dev&#x2F;test -al</p>
<p>结果如下图（图 13-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps109.jpg" alt="img"> </p>
<p>图 13-8</p>
<p>从上图可以看出，&#x2F;dev&#x2F;test这个杂项设备的主设备号为10，次设备号为53，最后可以使用以下命令对驱动进行卸载，卸载完成如下图（图 13-9）所示：</p>
<p>rmmod miscdevice.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps110.jpg" alt="img"> </p>
<p>图 13-9</p>
<h1 id="第14章-内核空间与用户空间数据交互实验"><a href="#第14章-内核空间与用户空间数据交互实验" class="headerlink" title="第14章 内核空间与用户空间数据交互实验"></a>第14章 内核空间与用户空间数据交互实验</h1><p>在“第12章 字符设备驱动框架实验”中，已经对file_operations结构体的进行了填充，该结构体的每一个成员都对应着一个系统调用，例如read、write等，在对应的实验中，只是对调用函数进行了标志打印，并没有真正实现设备的读写功能，而在本章节将对内核空间与用户空间的数据交换功能进行实现。</p>
<h2 id="14-1-内核空间与用户空间"><a href="#14-1-内核空间与用户空间" class="headerlink" title="14.1 内核空间与用户空间"></a>14.1 内核空间与用户空间</h2><p>Linux系统将可访问的内存空间分为了两个部分，一部分是内核空间，一部分是用户空间。操作系统和驱动程序运行在内核空间（内核态），应用程序运行在用户空间（用户态）。</p>
<p>那么为什么要区分用户空间和内核空间呢？</p>
<p>（1）内核空间中的代码控制了硬件资源，用户空间中的代码只能通过内核暴露的系统调用接口来使用系统中的硬件资源，这样的设计可以保证操作系统自身的安全性和稳定性。</p>
<p>（2）从另一方面来说，内核空间的代码更偏向于系统管理，而用户空间中的代码更偏重业务逻辑实现，俩者的分工不同。</p>
<p>硬件资源管理都是在内核空间完成的，应用程序无法直接对硬件进行操作，只能通过调用相应的内核接口来完成相应的操作。比如应用程序要对磁盘上的一个文件进行读取，应用程序可以向内核发起一个“系统调用”申请——我要读取磁盘上的文件。这个过程其实是通过一个特殊的指令让进程从用户态进入到了内核态。在内核空间中，CPU可以执行任何命令，包括从磁盘上读取数据，具体过程是先把数据读取到内核空间中，然后再把数据拷贝到用户空间并从内核态切换到用户态。此时应用程序已经从系统调用中返回并拿到了想要的数据，可以继续往下执行了。</p>
<p>进程只有从用户空间切换到内核空间才可以使用系统的硬件资源，切换的方式有三种：系统调用，软中断，硬中断，如下图（图 14-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps111.jpg" alt="img"> </p>
<p>图 14-1</p>
<h2 id="14-2-用户空间和内核空间数据交换"><a href="#14-2-用户空间和内核空间数据交换" class="headerlink" title="14.2 用户空间和内核空间数据交换"></a>14.2 用户空间和内核空间数据交换</h2><p>内核空间和用户空间的内存是不能互相访问的。但是很多应用程序都需要和内核进行数据的交换，例如应用程序使用read函数从驱动中读取数据，使用write函数向驱动中写数据，上述功能就需要使用copy_from_user和copy_to_user俩个函数来完成。copy_from_user函数是将用户空间的数据拷贝到内核空间。copy_to_user函数是将内核空间的数据拷贝到用户空间。</p>
<p>这俩个函数定义在了kernel&#x2F;include&#x2F;linux&#x2F;uaccess.h文件下，如下所示：</p>
<p>copy_to_user</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>unsigned long copy_to_user_inatomic(void __user *to, const void *from, unsigned long n);</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>把内核空间的数据复制到用户空间。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>*to是用户空间的指针</p>
<p>*from是内核空间的指针</p>
<p>n是从内核空间向用户空间拷贝的字节数</p>
<p>copy_from_user</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>unsigned long copy_from_user(void *to, const void __user *from, unsigned long n)</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>把用户空间的数据复制到内核空间。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>*to是内核空间的指针</p>
<p>*from是用户空间的指针</p>
<p>n是从用户空间向内核空间拷贝的字节数</p>
<h2 id="14-3-实验程序编写"><a href="#14-3-实验程序编写" class="headerlink" title="14.3 实验程序编写"></a>14.3 实验程序编写</h2><h3 id="14-3-1-驱动程序编写"><a href="#14-3-1-驱动程序编写" class="headerlink" title="14.3.1 驱动程序编写"></a>14.3.1 驱动程序编写</h3><p>本驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\09\module。</p>
<p>在该实验中将实现内核空间和用户空间进行数据交换的功能。以12章编写的字符设备驱动框架实验为基础编写驱动程序，程序使用copy_to_user函数和copy_from_user函数来实现内核空间和用户空间互传数据的功能，编写完成的file.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;  <span class="comment">//主设备号</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> minor = <span class="number">0</span>;  <span class="comment">//次设备号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>       <span class="comment">//类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>    <span class="comment">//设备</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*本章实验重点******/</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//定义写入缓存区kbuf</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);<span class="comment">//打印copy_from_user函数执行失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_write\r\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;kbuf is %s\r\n&quot;</span>, kbuf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*本章实验重点******/</span></span><br><span class="line"><span class="type">char</span> kbuf[<span class="number">32</span>] = <span class="string">&quot;This is cdev_test_read!&quot;</span>;<span class="comment">//定义内核空间数据</span></span><br><span class="line"><span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, kbuf, <span class="built_in">strlen</span>(kbuf)) != <span class="number">0</span>)     &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>); <span class="comment">//打印copy_to_user函数执行失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数，定义file_operations结构体类型的变量cdev_test_fops*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read,  <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"><span class="comment">/*1 创建设备号*/</span></span><br><span class="line"><span class="comment">//动态分配设备号</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>);     <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);<span class="comment">//打印动态分配设备号失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    major = MAJOR(dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    minor = MINOR(dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">    cdev_add(&amp;cdev_test, dev_num, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">    device = device_create(class, <span class="literal">NULL</span>, dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;cdev_test);               <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(class, dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);   <span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(chr_fops_exit);  <span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码在cdev_test_read函数中使用copy_to_user函数将内核数据拷贝到用户空间，在cdev_test_write函数中使用copy_from_user函数将用户空间数据拷贝到内核空间。</p>
<h3 id="14-3-2-编写测试-APP"><a href="#14-3-2-编写测试-APP" class="headerlink" title="14.3.2 编写测试 APP"></a>14.3.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\09\app。</p>
<p>编写测试APP其实是在编写Linux应用，编译完成的应用程序app.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  <span class="comment">//主函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;   <span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//定义读取缓存区buf1</span></span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>; <span class="comment">//定义写入缓存区buf2</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开字符设备驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    read(fd, buf1, <span class="keyword">sizeof</span>(buf1));<span class="comment">//从/dev/test文件读取数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf1 is %s \r\n&quot;</span>, buf1); <span class="comment">//打印读取的数据</span></span><br><span class="line"></span><br><span class="line">    write(fd,buf2,<span class="keyword">sizeof</span>(buf2));<span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="14-4-运行测试"><a href="#14-4-运行测试" class="headerlink" title="14.4 运行测试"></a>14.4 运行测试</h2><h3 id="14-4-1-编译驱动程序"><a href="#14-4-1-编译驱动程序" class="headerlink" title="14.4.1 编译驱动程序"></a>14.4.1 编译驱动程序</h3><p>在上一小节中的file.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下   所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m +=file.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放file.c和Makefile文件目录下，如下图（图14-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps112.jpg" alt="img"> </p>
<p>图 14-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图14-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps113.jpg" alt="img"> </p>
<p>图14-3</p>
<p>编译完生成 file.ko目标文件，如下图（图 14-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps114.jpg" alt="img"> </p>
<p>图 14-4</p>
<p>至此我们的驱动模块就编译成功了，下面进行应用程序编译.</p>
<h3 id="14-4-2-编译应用程序"><a href="#14-4-2-编译应用程序" class="headerlink" title="14.4.2 编译应用程序"></a>14.4.2 编译应用程序</h3><p>因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图 14-5）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps115.jpg" alt="img"> </p>
<p>图 14-5</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="14-4-3-运行测试"><a href="#14-4-3-运行测试" class="headerlink" title="14.4.3 运行测试"></a>14.4.3 运行测试</h3><p>驱动模块file.ko和测试程序app都已经准备好了，接下来就是运行测试。首先输入以下命令加载驱动程序，如下图（图14–6）所示：</p>
<p>insmod file.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps116.jpg" alt="img"> </p>
<p>图 14-6</p>
<p>输入以下命令运行应用程序，如下图（图 14-7）所示</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps117.jpg" alt="img"> </p>
<p>图 14-7</p>
<p>由上图可知，打印“This is cdev_test_open”信息说明成功打开了字符设备驱动。</p>
<p>打印“ This is cdev_test_read”和“buf1 is This is cdev_test_read!”说明应用程序成功读取到内核的数据。</p>
<p>打印“This is cdev_test_write”和“kbuf is nihao”说明应用程序向内核写数据成功。</p>
<p>最后打印“This is cdev_test_release”说明卸载字符设备。</p>
<h1 id="第15章-文件私有数据实验"><a href="#第15章-文件私有数据实验" class="headerlink" title="第15章 文件私有数据实验"></a>第15章 文件私有数据实验</h1><p>在之前章节编写的驱动程序中，将生成字符设备的一些硬件属性（设备号、类、设备名称等）全都写成了变量的形式，虽然这样编写驱动代码不会产生报错，但是会显得有点不专业。通常在驱动开发中会为设备定义相关的设备结构体，将硬件属性的描述信息全部放在该结构体中，在本章节中将对设备结构体的功能实现和文件私有数据进行学习。</p>
<h2 id="15-1-文件私有数据简介"><a href="#15-1-文件私有数据简介" class="headerlink" title="15.1 文件私有数据简介"></a>15.1 文件私有数据简介</h2><p>Linux中并没有明确规定要使用文件私有数据，但是在linux驱动源码中，广泛使用了文件私有数据，这是Linux驱动遵循的“潜规则”，实际上也体现了Linux面向对象的思想。struct file 结构体中专门为用户留了一个域用于定义私有数据。结构体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">fu_llist</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">fu_rcuhead</span>;</span></span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span>	<span class="comment">/* cached value */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protects f_ep_links, f_flags.</span></span><br><span class="line"><span class="comment">	 * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rw_hint</span>		<span class="title">f_write_hint</span>;</span></span><br><span class="line">	<span class="type">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> 		f_flags;</span><br><span class="line">	<span class="type">fmode_t</span>			f_mode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">	<span class="type">loff_t</span>			f_pos;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="type">void</span>			*private_data;<span class="comment">//私有数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_ep_links</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_tfile_llink</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span></span><br><span class="line">	<span class="type">errseq_t</span>		f_wb_err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件私有数据的概念在Linux驱动中有着非常广泛的应用，文件私有数据就是将私有数据private_data指向设备结构体。通过它可以将私有数据一路从open函数带到read, write函数层层传入。一般是在open 的时候赋值，read、write时使用。open函数中私有数据的使用如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">	file-&gt;private_data=&amp;dev1;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，定义了一个设备结构体dev1，然后在open函数中，将私有数据private_data指向了设备结构体dev1。</p>
<p>我们可以在read write函数中通过private_data访问设备结构体，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> _user *buf, <span class="type">size_t</span> size,<span class="type">loff_t</span> *<span class="type">off_t</span>)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-2-实验程序编写"><a href="#15-2-实验程序编写" class="headerlink" title="15.2 实验程序编写"></a>15.2 实验程序编写</h2><h3 id="15-2-1-驱动程序编写"><a href="#15-2-1-驱动程序编写" class="headerlink" title="15.2.1 驱动程序编写"></a>15.2.1 驱动程序编写</h3><p>本驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\10\module。</p>
<p>本章实验将编写Linux下的使用文件私有数据实例代码，在open函数中对私有数据结构体赋值，在write函数中使用。编写完成的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">dev_t</span> dev_num;              <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;                  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;                   <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span>          <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>             <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>          <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];                <span class="comment">//缓存区buf</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  <span class="comment">//定义一个device_test结构体变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;  <span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data; <span class="comment">//在write函数中读取private_data</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_write\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;kbuf is %s\r\n&quot;</span>, test_dev-&gt;kbuf); <span class="comment">//打印kbuf的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;    </span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,         <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open,         <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read,          <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write,         <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release,<span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">  dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">    cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建设备*/</span></span><br><span class="line">    dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="15-2-2-编写测试-APP"><a href="#15-2-2-编写测试-APP" class="headerlink" title="15.2.2 编写测试 APP"></a>15.2.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\10\app。</p>
<p>编写测试APP其实是在编写Linux应用，在应用程序中向设备文件写入数据，编写完成的应用程序app.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> <span class="comment">//主函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>;  <span class="comment">//定义写入缓存区buf1</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR); <span class="comment">//打开/dev/test设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd,buf1,<span class="keyword">sizeof</span>(buf1)); <span class="comment">//向/dev/test设备写入数据</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-3-运行测试"><a href="#15-3-运行测试" class="headerlink" title="15.3 运行测试"></a>15.3 运行测试</h2><h3 id="15-3-1-编译驱动程序"><a href="#15-3-1-编译驱动程序" class="headerlink" title="15.3.1 编译驱动程序"></a>15.3.1 编译驱动程序</h3><p>在上一小节中的file.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图5-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += file.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放file.c和Makefile文件目录下，如下图（图15-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps118.jpg" alt="img"> </p>
<p>图15-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图15-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps119.jpg" alt="img"> </p>
<p>图 15-2</p>
<p>编译完生成 file.ko目标文件，如下图（图15-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps120.jpg" alt="img"> </p>
<p>图 15-3</p>
<p>至此我们的驱动模块就编译成功了，下面进行应用程序编译，</p>
<h3 id="15-3-2-编译应用程序"><a href="#15-3-2-编译应用程序" class="headerlink" title="15.3.2 编译应用程序"></a>15.3.2 编译应用程序</h3><p>因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图15-4）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps121.jpg" alt="img"> </p>
<p>图15-4</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="15-3-3-运行测试"><a href="#15-3-3-运行测试" class="headerlink" title="15.3.3 运行测试"></a>15.3.3 运行测试</h3><p>驱动模块file.ko和测试程序app都已经准备好了，接下来就是运行测试。</p>
<p>输入以下命令加载驱动程序</p>
<p>insmod file.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps122.jpg" alt="img"> </p>
<p>图 15-5</p>
<p>驱动加载成功之后会生成&#x2F;dev&#x2F;test设备驱动文件，输入以下命令查看杂项设备的主次设备号。</p>
<p>ls &#x2F;dev&#x2F;test -al</p>
<p>结果如下图（图15-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps123.jpg" alt="img"> </p>
<p>图 15-6</p>
<p>运行应用程序，如下（图 15-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps124.jpg" alt="img"> </p>
<p>图 15-7</p>
<p>在此实验中，将硬件属性的信息全部放在一个结构体private_data，依然可以实现字符设备的操作。</p>
<h1 id="第16章-一个驱动兼容不同设备实验"><a href="#第16章-一个驱动兼容不同设备实验" class="headerlink" title="第16章 一个驱动兼容不同设备实验"></a>第16章 一个驱动兼容不同设备实验</h1><p>在Linux中，使用主设备号来表示对应某一类驱动，使用次设备号来表示这类驱动下的各个设备。假如现在驱动要支持的主设备号相同，但是次设备号不同的设备。驱动程序要怎样编写呢，上一章节学习的私有数据private_date在此时就派上了用场，具体是怎样使用的呢，多个设备是如何在一个驱动中兼容的呢，带着疑问，让我们开始本章节的学习吧。</p>
<h2 id="16-1-container-of函数简介"><a href="#16-1-container-of函数简介" class="headerlink" title="16.1 container_of函数简介"></a>16.1 container_of函数简介</h2><p>container_of在Linux内核中是一个常用的宏，用于从包含在某个结构中的指针获得结构本身的指针，通俗地讲就是通过结构体变量中某个成员的首地址进而获得整个结构体变量的首地址。那么可以使用这个函数获取不同设备的地址，来对不同的设备进行操作，从而一个驱动可以兼容不同的设备。</p>
<p>container_of</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>container_of(ptr,type,member)</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>通过结构体变量中某个成员的首地址获取到整个结构体变量的首地址。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>ptr是结构体变量中某个成员的地址。</p>
<p>type是结构体的类型 </p>
<p>member是该结构体变量的具体名字</p>
<p>container_of宏的作用是通过结构体内某个成员变量的地址和该变量名，以及结构体类型。找到该结构体变量的地址。</p>
<h2 id="16-2-实验程序编写"><a href="#16-2-实验程序编写" class="headerlink" title="16.2 实验程序编写"></a>16.2 实验程序编写</h2><h3 id="16-2-1-驱动程序编写"><a href="#16-2-1-驱动程序编写" class="headerlink" title="16.2.1 驱动程序编写"></a>16.2.1 驱动程序编写</h3><p>本驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\11\module。</p>
<p>本章实验将使用container_of函数编写一个驱动兼容不同设备的实例代码，编写完成的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> dev_num;             <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major;                  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor;                  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span>        <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>           <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>        <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];              <span class="comment">//定义缓冲区kbuf</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span>   <span class="comment">//定义一个device_test结构体变量dev1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev2</span>;</span>  <span class="comment">//定义一个device_test结构体变量dev2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    dev1.minor = <span class="number">0</span>;    <span class="comment">//设置dev1的次设备号为0</span></span><br><span class="line">    dev2.minor = <span class="number">1</span>;   <span class="comment">//设置dev2的次设备号为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//inode-&gt;i_rdev 为该 inode 的设备号，使用container_of函数找到结构体变量dev1 dev2的地址</span></span><br><span class="line"><span class="comment">//然后设置私有数据</span></span><br><span class="line">    file-&gt;private_data = container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> device_test, cdev_test);</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span> =</span> (<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="comment">//如果次设备号是0，则为dev1</span></span><br><span class="line">    <span class="keyword">if</span> (test_dev-&gt;minor == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(<span class="string">&quot; test_dev-&gt;kbuf is %s\r\n&quot;</span>, test_dev-&gt;kbuf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果次设备号是1，则为dev2</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(test_dev-&gt;minor == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(<span class="string">&quot; test_dev-&gt;kbuf is %s\r\n&quot;</span>, test_dev-&gt;kbuf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span> =</span> (<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>(test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数,定义file_operations结构体类型的变量cdev_test_fops*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号,,这里注册2个设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对设备1进行操作</span></span><br><span class="line">    <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">    cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">    dev1.class = class_create(THIS_MODULE, <span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5 创建设备*/</span></span><br><span class="line">    dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev2.major = MAJOR(dev1.dev_num + <span class="number">1</span>); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev2.minor = MINOR(dev1.dev_num + <span class="number">1</span>); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev2.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev2.minor); <span class="comment">//打印次设备号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对设备2进行操作</span></span><br><span class="line">  <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev2.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev2.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">    cdev_add(&amp;dev2.cdev_test, dev1.dev_num + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">    dev2.class = class_create(THIS_MODULE, <span class="string">&quot;test2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">    dev2.device = device_create(dev2.class, <span class="literal">NULL</span>, dev1.dev_num + <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&quot;test2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>);    <span class="comment">//注销设备号</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num + <span class="number">1</span>, <span class="number">1</span>);  <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                  <span class="comment">//删除cdev</span></span><br><span class="line">    cdev_del(&amp;dev2.cdev_test);                  <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);     <span class="comment">//删除设备</span></span><br><span class="line">    device_destroy(dev2.class, dev1.dev_num + <span class="number">1</span>);  <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">    class_destroy(dev2.class);                 <span class="comment">//删除类</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="16-2-2-编写测试-APP"><a href="#16-2-2-编写测试-APP" class="headerlink" title="16.2.2 编写测试 APP"></a>16.2.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\11\app。</p>
<p>编写应用程序，打开生成的俩个设备，并向俩个设备中写入数据，编写完成的应用程序app.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd1;  <span class="comment">//定义设备1的文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd2;  <span class="comment">//定义设备2的文件描述符</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = <span class="string">&quot;nihao /dev/test1&quot;</span>;   <span class="comment">//定义写入缓存区buf1</span></span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = <span class="string">&quot;nihao /dev/test2&quot;</span>;   <span class="comment">//定义写入缓存区buf2</span></span><br><span class="line">    fd1 = open(<span class="string">&quot;/dev/test1&quot;</span>, O_RDWR);  <span class="comment">//打开设备1：test1</span></span><br><span class="line">    <span class="keyword">if</span> (fd1 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd1;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd1,buf1,<span class="keyword">sizeof</span>(buf1));  <span class="comment">//向设备1写入数据</span></span><br><span class="line">    close(fd1); <span class="comment">//取消文件描述符到文件的映射</span></span><br><span class="line"></span><br><span class="line">    fd2= open(<span class="string">&quot;/dev/test2&quot;</span>, O_RDWR); <span class="comment">//打开设备2：test2</span></span><br><span class="line">    <span class="keyword">if</span> (fd2 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd2;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd2,buf2,<span class="keyword">sizeof</span>(buf2));  <span class="comment">//向设备2写入数据</span></span><br><span class="line">    close(fd2);   <span class="comment">//取消文件描述符到文件的映射</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="16-3-运行测试"><a href="#16-3-运行测试" class="headerlink" title="16.3 运行测试"></a>16.3 运行测试</h2><h3 id="16-3-1-编译驱动程序"><a href="#16-3-1-编译驱动程序" class="headerlink" title="16.3.1 编译驱动程序"></a>16.3.1 编译驱动程序</h3><p>在上一小节中的file.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图5-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += file.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放file.c和Makefile文件目录下，如下图（图16-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps125.jpg" alt="img"> </p>
<p>图 16-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图16-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps126.jpg" alt="img"> </p>
<p>图 16-2</p>
<p>编译完生成 file.ko目标文件，如下图（图16-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps127.jpg" alt="img"> </p>
<p>图 16-3</p>
<p>至此我们的驱动模块就编译成功了，下面进行应用程序编译</p>
<h3 id="16-3-2-编译应用程序"><a href="#16-3-2-编译应用程序" class="headerlink" title="16.3.2 编译应用程序"></a>16.3.2 编译应用程序</h3><p>因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图 16-4）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps128.jpg" alt="img"> </p>
<p>图 16-5</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="16-3-2-运行测试"><a href="#16-3-2-运行测试" class="headerlink" title="16.3.2 运行测试"></a>16.3.2 运行测试</h3><p>驱动模块file.ko和测试程序app都已经准备好了，接下来就是运行测试。</p>
<p>输入以下命令加载驱动模块，如下图（图 16-6）所示：</p>
<p>insmod file.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps129.jpg" alt="img"> </p>
<p>图 16-7</p>
<p>驱动加载成功之后会生成&#x2F;dev&#x2F;test1和&#x2F;dev&#x2F;test2设备驱动文件，输入以下命令查看设备，可以看到一个驱动创建并管理了多个驱动设备，如下图（图 16-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps130.jpg" alt="img"> </p>
<p>图 16-9</p>
<p>运行应用程序，如下（图 16-10）所示:</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps131.jpg" alt="img"> </p>
<p>图 16-11</p>
<p>如上图所示，可以看到用户顺利向俩个设备写入数据，且每个设备拥有私有数据。</p>
<h1 id="第17章-Linux错误处理实验"><a href="#第17章-Linux错误处理实验" class="headerlink" title="第17章 Linux错误处理实验"></a>第17章 Linux错误处理实验</h1><p>在前面章节进行的字符设备驱动实验中，即使是最简单的注册字符设备，也存在注册失败的可能性，因此在之前编写的驱动代码中采用检查函数返回值的方式，确认函数是否成功执行，而在本章节中将采用goto语句对Linux错误处理进行更进一步的处理。</p>
<h2 id="17-1-goto语句简介"><a href="#17-1-goto语句简介" class="headerlink" title="17.1 goto语句简介"></a>17.1 goto语句简介</h2><p>在编写驱动程序时，驱动程序应该提供函数执行失败后处理的能力。如果驱动程序中函数执行失败了，必须取消掉所有失败前的注册，否则内核会处于一个不稳定的状态，因为它包含了不存在代码的内部指针。在处理Linux错误时，最好使用goto语句，goto语句的使用示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>   init <span class="title function_">my_init_function</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line">err = register_this(ptr1, <span class="string">&quot;skull&quot;</span>); </span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">	<span class="keyword">goto</span> fail_this;</span><br><span class="line"></span><br><span class="line">err = register_that(ptr2, <span class="string">&quot;skull&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">	<span class="keyword">goto</span> fail_that;</span><br><span class="line"></span><br><span class="line">err = register_those(ptr3, <span class="string">&quot;skull&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">	<span class="keyword">goto</span> fail_those;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line"> </span><br><span class="line">fail_those:</span><br><span class="line">	unregister_that(ptr2, <span class="string">&quot;skull&quot;</span>); </span><br><span class="line">fail_that:</span><br><span class="line">	unregister_this(ptr1, <span class="string">&quot;skull&quot;</span>);</span><br><span class="line">fail_this:</span><br><span class="line">	<span class="keyword">return</span> err;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中试图注册3个虚构设备，goto语句在失败情况下使用，对之前已经成功注册的设施进行注销。使用goto语句处理的时候，应该遵循“先进后出”的原则，如下图（图 17-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps132.jpg" alt="img"> </p>
<p>图 17-2</p>
<p>如果在驱动代码中初始化和卸载函数比较复杂，goto方法可能变得难于管理，为了使代码重复性最小以及流程化，Linux提供了更简便的方法，我们接着来学习下一小节。</p>
<h2 id="17-2-IS-ERR-简介"><a href="#17-2-IS-ERR-简介" class="headerlink" title="17.2 IS_ERR()简介"></a>17.2 IS_ERR()简介</h2><p>对于任何一个指针来说，必然存在三种情况，一种是合法指针，一种是NULL(也就是空指针)，一种是错误指针(也就是无效指针)。在Linux内核中，所谓的错误指针已经指向了内核空间的最后一页，例如，对于一个64位系统来说，内核空间最后地址为0xffffffffffffffff，那么最后一页的地址是0xfffffffffffff000~0xffffffffffffffff，这段地址是被保留的，如果指针落在这段地址之内，说明是错误的无效指针。</p>
<p>在Linux内核源码中实现了指针错误的处理机制，相关的函数接口主要有IS_ERR()、PTR_ERR()、ERR_PTR()等，其函数的源码在include&#x2F;linux&#x2F;err.h文件中，如下所示：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\ksohtml55808\wps133.jpg" alt="img"> </p>
<p>如上图所示，在Linux源码中IS_ERR()函数其实就是判断指针是否出错，如果指针指向了内核空间的最后一页，就说明指针是一个无效指针，如果指针并不是落在内核空间的最后一页，就说明这指针是有效的。无效的指针能表示成一种负数的错误码，如果想知道这个指针是哪个错误码，使用PTR_ERR函数转化。0xfffffffffffff000~0xffffffffffffffff这段地址和Linux错误码是一一对应的，内核错误码保存在errno-base.h文件中。如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_GENERIC_ERRNO_BASE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_GENERIC_ERRNO_BASE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EPERM		 1	<span class="comment">/* Operation not permitted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOENT		 2	<span class="comment">/* No such file or directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ESRCH		 3	<span class="comment">/* No such process */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EINTR		 4	<span class="comment">/* Interrupted system call */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EIO		 5	<span class="comment">/* I/O error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENXIO		 6	<span class="comment">/* No such device or address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	E2BIG		 7	<span class="comment">/* Argument list too long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOEXEC		 8	<span class="comment">/* Exec format error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EBADF		 9	<span class="comment">/* Bad file number */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ECHILD		10	<span class="comment">/* No child processes */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EAGAIN		11	<span class="comment">/* Try again */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOMEM		12	<span class="comment">/* Out of memory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EACCES		13	<span class="comment">/* Permission denied */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EFAULT		14	<span class="comment">/* Bad address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOTBLK		15	<span class="comment">/* Block device required */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EBUSY		16	<span class="comment">/* Device or resource busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EEXIST		17	<span class="comment">/* File exists */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EXDEV		18	<span class="comment">/* Cross-device link */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENODEV		19	<span class="comment">/* No such device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOTDIR		20	<span class="comment">/* Not a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EISDIR		21	<span class="comment">/* Is a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EINVAL		22	<span class="comment">/* Invalid argument */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENFILE		23	<span class="comment">/* File table overflow */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EMFILE		24	<span class="comment">/* Too many open files */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOTTY		25	<span class="comment">/* Not a typewriter */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ETXTBSY		26	<span class="comment">/* Text file busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EFBIG		27	<span class="comment">/* File too large */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOSPC		28	<span class="comment">/* No space left on device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ESPIPE		29	<span class="comment">/* Illegal seek */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EROFS		30	<span class="comment">/* Read-only file system */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EMLINK		31	<span class="comment">/* Too many links */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EPIPE		32	<span class="comment">/* Broken pipe */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EDOM		33	<span class="comment">/* Math argument out of domain of func */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ERANGE		34	<span class="comment">/* Math result not representable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>那么如何判断函数返回的指针是有效地址还是错误码呢？对于IS_ERR()的使用，实例代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">myclass = class_create(THIS_MODULE, <span class="string">&quot;myclass&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(myclass)) &#123;</span><br><span class="line">　　ret = PTR_ERR(myclass);</span><br><span class="line">   <span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">mydevice = device_create(myclass, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;simple-device&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(mydevice)) &#123;</span><br><span class="line">　　class_destroy(myclass);</span><br><span class="line">　　ret = PTR_ERR(mydevice);</span><br><span class="line">　　<span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，调用了class_create()和device_create()函数，必须使用IS_ERR()函数判断返回的指针是否是有效的，如果是无效的，需要调用PTR_ERR()函数将无效指针转换为错误码，并进行错误码的返回。</p>
<h2 id="17-3-实验程序编写"><a href="#17-3-实验程序编写" class="headerlink" title="17.3 实验程序编写"></a>17.3 实验程序编写</h2><h3 id="17-3-1-驱动程序编写"><a href="#17-3-1-驱动程序编写" class="headerlink" title="17.3.1 驱动程序编写"></a>17.3.1 驱动程序编写</h3><p>本驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\12\module。</p>
<p>本实验在15章的驱动程序基础上进行编写，进行Linux错误处理实验。当创建设备号，初始化cdev，注册字符设备，创建类，创建设备的这些函数执行失败时，应该怎么处理呢，编写好的驱动程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];  <span class="comment">//定义缓存区kbuf</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>   <span class="comment">//定义一个device_test结构体变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">    file-&gt;private_data=&amp;dev1;  <span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_write\r\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;kbuf is %s\r\n&quot;</span>, test_dev-&gt;kbuf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;   </span><br><span class="line"><span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">       ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="17-3-2-编写测试-APP"><a href="#17-3-2-编写测试-APP" class="headerlink" title="17.3.2 编写测试 APP"></a>17.3.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\12\app。</p>
<p>编写应用程序app.c，完成的应用程序app.c代码如下所示，应用程序只是起简单的测试作用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> <span class="comment">//主函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>;  <span class="comment">//定义写入缓存区buf1</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR); <span class="comment">//打开/dev/test设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd,buf1,<span class="keyword">sizeof</span>(buf1)); <span class="comment">//向/dev/test设备写入数据</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="17-4-运行测试"><a href="#17-4-运行测试" class="headerlink" title="17.4 运行测试"></a>17.4 运行测试</h2><h3 id="17-4-1-编译驱动程序"><a href="#17-4-1-编译驱动程序" class="headerlink" title="17.4.1 编译驱动程序"></a>17.4.1 编译驱动程序</h3><p>在上一小节中的file.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图5-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += chrdev_fops.o                     <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel   <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules     <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放file.c和Makefile文件目录下，如下图（图17-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps134.jpg" alt="img"> </p>
<p>图 17-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图17-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps135.jpg" alt="img"> </p>
<p>图 17-3</p>
<p>编译完生成 file.ko目标文件，如下图（图17-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps136.jpg" alt="img"> </p>
<p>图 17-4</p>
<p>至此我们的驱动模块就编译成功了。</p>
<h3 id="17-4-2-编译应用程序"><a href="#17-4-2-编译应用程序" class="headerlink" title="17.4.2 编译应用程序"></a>17.4.2 编译应用程序</h3><p>下面进行应用程序编译，因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图17-5）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps137.jpg" alt="img"> </p>
<p>图 17-5</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="17-4-3运行测试"><a href="#17-4-3运行测试" class="headerlink" title="17.4.3运行测试"></a>17.4.3运行测试</h3><p>驱动模块file.ko和测试程序app都已经准备好了，接下来就是运行测试。</p>
<p>输入以下命令，加载驱动程序，如下图（图17-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps138.jpg" alt="img"> </p>
<p>图 17-6</p>
<p>运行应用程序如下（图17-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps139.jpg" alt="img"> </p>
<p>图 17-7</p>
<p>卸载驱动程序，如下图（图17-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps140.jpg" alt="img"> </p>
<p>图 17-8</p>
<h1 id="第18章-点亮LED灯实验"><a href="#第18章-点亮LED灯实验" class="headerlink" title="第18章 点亮LED灯实验"></a>第18章 点亮LED灯实验</h1><p>经过前面章节的学习，我们已经对字符设备相关的知识进行了学习和实验，但实际上并没有涉及到对硬件的操作，而在本小节中将通过字符设备驱动及相关的应用程序对LED灯进行控制，通过对硬件的实际操作，从而对之前学习到的知识进行整合与回顾。</p>
<h2 id="18-1-查看原理图"><a href="#18-1-查看原理图" class="headerlink" title="18.1 查看原理图"></a>18.1 查看原理图</h2><p>首先打开底板原理图，如下图（图18-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps141.jpg" alt="img"> </p>
<p>图 18-1</p>
<p>由上图可以看出，LED灯是由GPIO0_B7控制的。当GPIO0_B7为高电平时，三极管Q16导通，LED9点亮。当GPIO0_B7为低电平时，三极管Q16截止，LED9不亮。</p>
<h2 id="18-2-查询寄存器地址"><a href="#18-2-查询寄存器地址" class="headerlink" title="18.2 查询寄存器地址"></a>18.2 查询寄存器地址</h2><p>在上一小节，我们查询到了控制LED灯的GPIO为GPIO0_B7。在接下来的实验中需要对GPIO进行配置，一般情况下需要对GPIO的复用寄存器，方向寄存器，数据寄存器进行配置。接下来我们打开RK3568的参考手册part1查找这几个寄存器的地址。</p>
<p>查找复用寄存器</p>
<p>打开参考手册part1的第三章，GPIOB的复用寄存器的偏移地址如下（图18-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps142.jpg" alt="img"> </p>
<p>图 18-2</p>
<p>搜索gpio0b7，如下图（图 18-3）所示，gpio0b7_sel在PMU_GRF_GPIO0B_IOMUX_H上，所以偏移地址为0x000C。gpio0b7可以通过控制[14:12]位来选择复用为哪个功能，我们要控制led灯，所以功能要复用为gpio。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps143.jpg" alt="img"> </p>
<p>图 18-3</p>
<p>复用寄存器的基地址如下图(图 18-4)所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps144.jpg" alt="img"> </p>
<p>图 18-4</p>
<p>所以复用寄存器地址&#x3D;基地址+偏移地址&#x3D;0xFDC2000C 。使用io命令查看此寄存器的地址：</p>
<p>io -r -4 0xFDC2000C</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps145.jpg" alt="img"> </p>
<p>图 18-5</p>
<p>如上图(图 18-5)所示，寄存器值为00000001，[14:12]位为000，如下图（图 18-6）所示，所以默认设置的为gpio功能。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps146.jpg" alt="img"> </p>
<p>图 18-6</p>
<p>查找方向寄存器</p>
<p>打开参考手册part1的第16章节，数据寄存器的偏移地址如下图（图 18-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps147.jpg" alt="img"> </p>
<p>图 18-7</p>
<p>GPIO有四组GPIO，分别是GPIOA，GPIOB，GPIOC，GPIOD。每组又以 A0<del>A7, B0</del>B7, C0<del>C7, D0</del>D7 作为编号区分。GPIO0B7在GPIO_SWPORT_DDR_L上所以，方向寄存器的偏移地址为0x0008。接着查看GPIO_SWPORT_DDR_L寄存器的具体描述，如下图（图18-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps148.jpg" alt="img"> </p>
<p>图 18-8</p>
<p>如上图（图 18-8）所示，[31:16]位属性是WO，也就是只可写入。这[31:16]位是写标志位，是低16位的写使能。如果低16位中某一位要设置输入输入输出，则对应高位写标志也应该设置为1。 [15：0] 是数据方向控制寄存器低位，如果要设置某个GPIO为输出，则对应位置1，如果要设置某个GPIO为输入，则对应位置0。那么GPIO0 B7 ，我们要设置第15位为输入还是输出，那么对应的[31:16]位写使能也要置1。</p>
<p>打开参考手册part1的1.1小节Address Mapping。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps149.jpg" alt="img"> </p>
<p>图 18-9</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps150.jpg" alt="img"> </p>
<p>图 18-10</p>
<p>如上图（图18-10）所示，GPIO0的基地址为0xFDD60000。方向寄存器的地址&#x3D;基地址+偏移地址&#x3D;0xFDD60000+0x0008&#x3D;0xFDD60008</p>
<p>然后使用IO命令查看该寄存器的值，如下（图18-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps151.jpg" alt="img"> </p>
<p>图 18-11</p>
<p>如下图（图 18-11）所示，第15位默认为1，设置GPIO0_B7为输出。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps152.jpg" alt="img"> </p>
<p>查找数据寄存器</p>
<p>打开参考手册part1的1.1小节Address Mapping。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps153.jpg" alt="img"> </p>
<p>图 18-12</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps154.jpg" alt="img"> </p>
<p>图 18-13</p>
<p>如上图（图18-13）所示，GPIO0的基地址为0xFDD60000。</p>
<p>数据寄存器的偏移地址如下（图18-14）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps155.jpg" alt="img"> </p>
<p>图 18-14</p>
<p>所以数据寄存器的地址为基地址+偏移地址&#x3D;0xFDD60000。使用IO命令查看地址的值，如下（图18-15）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps156.jpg" alt="img"> </p>
<p>图 18-15</p>
<p>我们来看一下这个数据寄存器的描述，如下图（图18-16）所示，</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps157.jpg" alt="img"> </p>
<p>图18-16</p>
<p>分析上图的方法和在分析方向寄存器的方法同理，由上图可知，如果要控制第15位为高电平（置1），需要设置31位为1，那么点亮灯，需要向数据寄存器写入0x8000c040，如下图（图18-17）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps158.jpg" alt="img"> </p>
<p>图 18-17</p>
<p>如果要灭灯，需要设置第15位为0 ，第31位为1，那么向数据寄存器中写入0x80004040，如下图（图 18-18）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps159.jpg" alt="img"> </p>
<p>图 18-18</p>
<p>总结</p>
<p>l 复用关系寄存器的基地址为0xFDC20000 ，偏移地址为000C ，所以要操作的地址为基地址+偏移地址&#x3D;0xFDC2000C </p>
<p>l GPIO的基地址为0xFDD60000，偏移地址为0x0008，所以方向寄存器要操作的地址为基地址+偏移地址&#x3D;0xFDD60008</p>
<p>l GPIO的基地址为0xFDD60000，偏移地址为0x0000，所以数据寄存器要操作的地址为基地址+偏移地址&#x3D;0xFDD60000</p>
<p>l 默认的数据寄存器的值：0x8000c040亮灯，0x80004040灭灯</p>
<h2 id="18-3-实验程序编写"><a href="#18-3-实验程序编写" class="headerlink" title="18.3 实验程序编写"></a>18.3 实验程序编写</h2><h3 id="18-3-1-驱动程序编写"><a href="#18-3-1-驱动程序编写" class="headerlink" title="18.3.1 驱动程序编写"></a>18.3.1 驱动程序编写</h3><p>本驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\13\module。</p>
<p>本次实验在15章的驱动程序基础上进行编写，通过在应用层传入0&#x2F;1数据到内核，如果传入数据是1，则设置GPIO的数据寄存器值为0x8000c040，如果应用层传入0，则设置GPIO的数据寄存器值为0x80004040，这样就可以达到控制led的效果， 编写好的驱动程序file.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_DR 0xFDD60000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *vir_gpio_dr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(test_dev-&gt;kbuf[<span class="number">0</span>]==<span class="number">1</span>)&#123;   <span class="comment">//如果应用层传入的数据是1，则打开灯</span></span><br><span class="line">            *(test_dev-&gt;vir_gpio_dr) = <span class="number">0x8000c040</span>;   <span class="comment">//设置数据寄存器的地址</span></span><br><span class="line">            printk(<span class="string">&quot;test_dev-&gt;kbuf [0]  is %d\n&quot;</span>,test_dev-&gt;kbuf[<span class="number">0</span>]);  <span class="comment">//打印传入的数据</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(test_dev-&gt;kbuf[<span class="number">0</span>]==<span class="number">0</span>)&#123;  <span class="comment">//如果应用层传入的数据是0，则关闭灯</span></span><br><span class="line">        *(test_dev-&gt;vir_gpio_dr) = <span class="number">0x80004040</span>; <span class="comment">//设置数据寄存器的地址</span></span><br><span class="line">        printk(<span class="string">&quot;test_dev-&gt;kbuf [0]  is %d\n&quot;</span>,test_dev-&gt;kbuf[<span class="number">0</span>]); <span class="comment">//打印传入的数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*本实验重点*****/</span></span><br><span class="line">    dev1.vir_gpio_dr=ioremap(GPIO_DR,<span class="number">4</span>);  <span class="comment">//将物理地址转化为虚拟地址</span></span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.vir_gpio_dr))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.vir_gpio_dr);  <span class="comment">//PTR_ERR()来返回错误代码</span></span><br><span class="line">        <span class="keyword">goto</span> err_ioremap;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_ioremap:</span><br><span class="line">        iounmap(dev1.vir_gpio_dr);</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);    <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="18-3-2-编写测试-APP"><a href="#18-3-2-编写测试-APP" class="headerlink" title="18.3.2 编写测试 APP"></a>18.3.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\13\app。</p>
<p>编写测试app,led驱动加载成功之后会生成&#x2F;dev&#x2F;test节点，应用程序APP通过操作&#x2F;dev&#x2F;test文件来完成对LED设备的控制。向&#x2F;dev&#x2F;test文件写入0表示关闭LED灯，写入1表示打开LED灯。编写完成的应用程序app.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开led驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// atoi()将字符串转为整型，这里将第一个参数转化为整型后，存放在 buf[0]中</span></span><br><span class="line">buf[<span class="number">0</span>] =atoi(argv[<span class="number">1</span>]);  </span><br><span class="line">write(fd,buf,<span class="keyword">sizeof</span>(buf));  <span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-4-运行测试"><a href="#18-4-运行测试" class="headerlink" title="18.4 运行测试"></a>18.4 运行测试</h2><h3 id="18-4-1编译驱动程序"><a href="#18-4-1编译驱动程序" class="headerlink" title="18.4.1编译驱动程序"></a>18.4.1编译驱动程序</h3><p>在上一小节中的file.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图5-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += file.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放file.c和Makefile文件目录下，如下图（图18-19）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps160.jpg" alt="img"> </p>
<p>图 18-19</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 18-20）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps161.jpg" alt="img"> </p>
<p>图 18-20</p>
<p>编译完生成 file.ko目标文件，如下图（图 18-21）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps162.jpg" alt="img"> </p>
<p>图 18-21</p>
<h3 id="18-4-2-编译应用程序"><a href="#18-4-2-编译应用程序" class="headerlink" title="18.4.2 编译应用程序"></a>18.4.2 编译应用程序</h3><p>至此我们的驱动模块就编译成功了，下面进行应用程序编译，因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图 18-21）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps163.jpg" alt="img"> </p>
<p>图 18-21</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="18-4-3-运行测试"><a href="#18-4-3-运行测试" class="headerlink" title="18.4.3 运行测试"></a>18.4.3 运行测试</h3><p>驱动模块file.ko和测试程序app都已经准备好了，接下来就是运行测试。</p>
<p>输入以下命令加载驱动程序，如下（图 18-22）所示：</p>
<p>insmod file.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps164.jpg" alt="img"> </p>
<p>图 18-22</p>
<p>然后运行测试程序，输入“.&#x2F;app 1”，LED灯点亮，如下图（图 18-24）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps165.jpg" alt="img"> </p>
<p>图 18-23</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps166.jpg" alt="img"> </p>
<p>图 18-24</p>
<p>输入“.&#x2F;app 0”,LED灯熄灭，如下图（图 18-26）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps167.jpg" alt="img"> </p>
<p>图 18-25</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps168.jpg" alt="img"> </p>
<p>图 18-26</p>
]]></content>
      <categories>
        <category>rk3568 驱动</category>
      </categories>
      <tags>
        <tag>字符设备基础</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake 基础课</title>
    <url>/2023/09/03/cmake-%E5%9F%BA%E7%A1%80%E8%AF%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、准备知识"><a href="#一、准备知识" class="headerlink" title="一、准备知识"></a>一、准备知识</h1><h2 id="1-1-C-的编译过程"><a href="#1-1-C-的编译过程" class="headerlink" title="1.1 C++的编译过程"></a>1.1 C++的编译过程</h2><ul>
<li>-E 仅预处理；不编译、汇编或链接。</li>
<li>-S 仅编译；不汇编或链接。</li>
<li>-c 编译和汇编，但不链接。</li>
<li>-o <file> 将输出放入<file>中。</li>
</ul>
<p><strong>C++源代码的编译过程</strong></p>
<ol>
<li><p><strong>预处理</strong>：在预处理阶段，C++源代码中的预处理指令会被处理，包括宏展开和条件编译等。在此阶段，需要添加所有头文件的引用路径。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将xx.cpp源文件预处理为xx.i文件（文本文件）</span></span><br><span class="line">g++ -E main.cpp -o main.i</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编译</strong>：编译阶段会对预处理后的代码进行语法检查和编译，将代码翻译为汇编语言文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将xx.i文件编译为xx.s的汇编文件（文本文件）</span></span><br><span class="line">g++ -S main.i -o main.s</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>汇编</strong>：汇编阶段将汇编语言文件转换为二进制格式的目标文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将xx.s文件汇编为xx.o的二进制目标文件</span></span><br><span class="line">g++ -c main.s -o main.o</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>链接</strong>：链接阶段将目标文件与所依赖的库文件进行关联或组装，生成可执行文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将目标文件进行链接，生成可执行程序</span></span><br><span class="line">g++ main.o -o main</span><br><span class="line">```</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="1-2-静态链接库和动态链接库"><a href="#1-2-静态链接库和动态链接库" class="headerlink" title="1.2 静态链接库和动态链接库"></a>1.2 静态链接库和动态链接库</h2><p>静态链接库和动态链接库的区别在于链接的阶段不同。</p>
<p><strong>静态链接库</strong>的名称通常以<code>.a</code>结尾（表示archive library），它在编译阶段进行链接。如果一个工程依赖于静态链接库，那么生成的可执行文件或库会将静态链接库<code>.a</code>打包到输出文件中，因此生成的文件比较大。在运行时，不再需要单独的库文件。</p>
<p><strong>动态链接库</strong>的链接发生在程序的执行过程中，它在编译阶段仅进行链接检查，而不进行真正的链接过程。动态链接库的后缀名通常为<code>.so</code>（表示shared object，在Linux上）或<code>.dylib</code>（在macOS上）。动态链接库在加载后，在内存中只保存一份拷贝。多个程序依赖于它时，不会重复加载和拷贝，节省了内存空间。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/image-20230903175645024.png" alt="image-20230903175645024"></p>
<h2 id="1-3-为什么需要CMake"><a href="#1-3-为什么需要CMake" class="headerlink" title="1.3 为什么需要CMake"></a>1.3 为什么需要CMake</h2><h3 id="1-3-1-g-命令行编译"><a href="#1-3-1-g-命令行编译" class="headerlink" title="1.3.1 g++命令行编译"></a>1.3.1 g++命令行编译</h3><p>当编译hello_world.cpp&#96;文件时，可以使用以下命令进行编译和运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -o main</span><br></pre></td></tr></table></figure>

<p>如果需要引入外部库可以使用以下方法进行编译：</p>
<p>方法一：使用<code>-lgflags</code>参数进行链接**</p>
<p>首先，需要安装<code>gflags</code>库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libgflags-dev libgflags2.2</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">然后，使用以下命令进行编译：</span><br><span class="line"></span><br><span class="line">````bash</span><br><span class="line">g++ main.cpp -lgflags -o main</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>方法二：使用<code>pkg-config</code>进行库文件和头文件路径查找**</p>
<p>首先，需要安装<code>pkg-config</code>工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install pkg-config</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">然后，使用以下命令进行编译：</span><br><span class="line"></span><br><span class="line">````bash</span><br><span class="line">g++ main.cpp `pkg-config --cflags --libs gflags` -o main</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">这里，`pkg-config --cflags --libs gflags`命令用于查找`gflags`库的头文件和库文件路径。</span><br></pre></td></tr></table></figure>

<p>编译完成后，可以使用以下命令运行可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./main --age 31 --name alice</span><br></pre></td></tr></table></figure>

<p>有时候，在编译时不需要手动添加头文件或链接库路径，因为<code>g++</code>可以在默认的查询路径中找到这些库。然而，当项目文件和引入的外部库变得较多时，使用命令行编译会变得冗长且不便于调试和编辑。通常，在测试单个文件时可以使用命令行编译，但不推荐在实际项目中使用命令行编译方式。</p>
<h3 id="1-3-2-CMake简介"><a href="#1-3-2-CMake简介" class="headerlink" title="1.3.2 CMake简介"></a>1.3.2 CMake简介</h3><p>在实际工作中，推荐使用CMake来构建C++项目。CMake是一个开源的跨平台工具，用于构建、测试和软件打包。</p>
<p>CMake具有以下特性：</p>
<ul>
<li><strong>自动搜索依赖项</strong>：CMake具有自动搜索可能需要的程序、库和头文件的能力，可以简化依赖项的配置过程。</li>
<li><strong>独立的构建目录</strong>：CMake支持使用独立的构建目录（例如<code>build</code>目录），这样可以安全地清理构建产生的中间文件和输出文件，不会污染源代码目录。</li>
<li><strong>自定义命令</strong>：CMake支持定义复杂的自定义命令，例如下载文件、生成各种文件等，可以满足项目构建过程中的特定需求。</li>
<li><strong>自定义配置</strong>：CMake支持根据需求进行自定义配置，可以选择性地启用或禁用特定的组件或功能。</li>
<li><strong>文本文件生成工作区和项目</strong>：CMake使用简单的文本文件（<code>CMakeLists.txt</code>）来描述项目的配置和构建规则，可以根据这些文件自动生成工作区和项目。</li>
<li><strong>文件依赖项自动生成和并行构建</strong>：CMake可以在主流平台上自动生成文件之间的依赖关系，从而使构建过程更高效。同时，CMake支持并行构建，可以加快构建速度。</li>
<li><strong>支持多种IDE</strong>：CMake几乎支持所有主流的集成开发环境（IDE），包括Visual Studio、Xcode、Eclipse等，可以方便地在不同的开发环境中进行项目开发和调试。</li>
</ul>
<h1 id="二、CMake基础知识"><a href="#二、CMake基础知识" class="headerlink" title="二、CMake基础知识"></a>二、CMake基础知识</h1><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h2><p>在Ubuntu上安装CMake可以使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install cmake -y</span><br></pre></td></tr></table></figure>

<p>这将使用apt包管理器自动安装CMake。</p>
<p>如果你想编译安装特定版本的CMake，可以按照以下步骤操作：</p>
<p>克隆CMake的源代码库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b v3.25.1 https://github.com/Kitware/CMake.git</span><br><span class="line">cd CMake</span><br><span class="line"></span><br><span class="line">这里以安装版本3.25.1为例，你可以将`v3.25.1`替换为你想要安装的特定版本。</span><br></pre></td></tr></table></figure>

<p>配置和编译CMake：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bootstrap --prefix=&lt;安装路径&gt;</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">你可以使用`--prefix`选项来指定安装路径，或者省略`--prefix`以安装到默认路径。</span><br></pre></td></tr></table></figure>

<p>安装CMake：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">这将以管理员权限安装CMake到系统中。</span><br></pre></td></tr></table></figure>

<p>安装完成后，你可以验证CMake的安装版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure>

<p>该命令将显示CMake的版本信息，确认安装成功与否。</p>
<h2 id="2-2-第一个CMake例子"><a href="#2-2-第一个CMake例子" class="headerlink" title="2.2 第一个CMake例子"></a>2.2 第一个CMake例子</h2><p><strong>配置：</strong> 使用<code>cmake</code>命令进行配置，其中<code>-S</code>选项指定源码目录，<code>-B</code>选项指定构建目录。在终端中执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake -S . -B build</span><br><span class="line"></span><br><span class="line">这将在当前目录下执行CMake配置，并将生成的构建系统文件放在名为`build`的目录中。</span><br></pre></td></tr></table></figure>

<p><strong>生成：</strong> 使用<code>cmake --build</code>命令进行生成，其中<code>--build</code>选项指定构建目录。在终端中执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake --build build</span><br><span class="line"></span><br><span class="line">这将在`build`目录中执行构建步骤，生成可执行文件。</span><br></pre></td></tr></table></figure>

<p><strong>运行：</strong> 使用以下命令运行生成的可执行文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./build/first_cmake</span><br><span class="line"></span><br><span class="line">这将执行生成的可执行文件。</span><br></pre></td></tr></table></figure>

<h2 id="2-3-语法基础"><a href="#2-3-语法基础" class="headerlink" title="2.3 语法基础"></a>2.3 语法基础</h2><h3 id="2-3-1-指定版本"><a href="#2-3-1-指定版本" class="headerlink" title="2.3.1 指定版本"></a>2.3.1 指定版本</h3><p>在CMake中，可以使用<code>cmake_minimum_required</code>命令指定当前项目所需的最低CMake版本。它的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION &lt;version_number&gt;)</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;version_number&gt;</code>是所需的最低CMake版本号。在这个命令之后，CMake将会检查系统中安装的CMake版本是否满足这个要求，如果不满足则会产生错误。</p>
<p>例如，如果要指定最低的CMake版本为3.10，可以在CMakeLists.txt文件中添加以下命令：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br></pre></td></tr></table></figure>

<p>这样，CMake将会检查系统中的CMake版本是否大于等于3.10。</p>
<p>除了<code>cmake_minimum_required</code>命令，CMake中还有其他类似的命令，它们不区分大小写，并且有许多关键字来引导命令的参数输入，类似于函数的参数传递。这些命令使用的关键字在CMake中是不区分大小写的。</p>
<h3 id="2-3-2-设置项目"><a href="#2-3-2-设置项目" class="headerlink" title="2.3.2 设置项目"></a>2.3.2 设置项目</h3><p>在CMakeLists.txt文件的开头，通常会使用<code>project</code>命令来指定项目的名称、版本、描述和所使用的语言。<code>project</code>命令的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">project</span>(ProjectName</span><br><span class="line">    [VERSION &lt;version_number&gt;]</span><br><span class="line">    [DESCRIPTION <span class="string">&quot;project_description&quot;</span>]</span><br><span class="line">    [LANGUAGES &lt;language&gt;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>其中，<code>ProjectName</code>是项目的名称，在例子中使用的是”first_cmake”。<code>VERSION</code>关键字后面是项目的版本号，可以是任意格式的版本号，例如”1.0.0”。<code>DESCRIPTION</code>关键字后面是项目的描述，可以是一个字符串。<code>LANGUAGES</code>关键字后面是项目所使用的语言，这里使用的是”Cxx”，表示C++。</p>
<p>示例中的<code>project</code>命令：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">project</span>(first_cmake</span><br><span class="line">    VERSION <span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line">    DESCRIPTION <span class="string">&quot;项目描述&quot;</span></span><br><span class="line">    LANGUAGES Cxx</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这样，通过<code>project</code>命令，可以在CMakeLists.txt中指定项目的基本信息，方便管理和描述项目。</p>
<h3 id="2-3-3-添加可执行文件目标"><a href="#2-3-3-添加可执行文件目标" class="headerlink" title="2.3.3 添加可执行文件目标"></a>2.3.3 添加可执行文件目标</h3><p>使用了<code>add_executable</code>命令来定义一个可执行文件。该命令的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(&lt;target_name&gt; &lt;source_files&gt;)</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;target_name&gt;</code>是最终生成的可执行文件名，也是在CMake中定义的目标（Target）名。<code>&lt;source_files&gt;</code>是编译目标所使用的源文件。</p>
<p>在你提供的例子中，使用了<code>add_executable</code>命令来定义一个名为<code>first_cmake</code>的目标，并指定了一个源文件<code>main.cpp</code>。这意味着在编译时，会将<code>main.cpp</code>编译为一个可执行文件，该文件的名称将是<code>first_cmake</code>。</p>
<p>示例中的<code>add_executable</code>命令：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(first_cmake main.cpp)</span><br></pre></td></tr></table></figure>

<p>通过<code>add_executable</code>命令，可以在CMakeLists.txt中定义编译目标，并指定相应的源文件。这样，CMake将会根据这些定义生成相应的构建规则和编译指令。</p>
<h3 id="2-3-4-生成静态库并链接"><a href="#2-3-4-生成静态库并链接" class="headerlink" title="2.3.4 生成静态库并链接"></a>2.3.4 生成静态库并链接</h3><p>A. 生成静态库：</p>
<p>在<code>account_dir/CMakeLists.txt</code>中，使用<code>add_library</code>命令来生成静态库。该命令的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_library(&lt;library_name&gt; &lt;library_type&gt; &lt;source_files&gt;)</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;library_name&gt;</code>是最终生成的库文件名，例如在Linux下会生成<code>libAccount.a</code>。</p>
<p><code>&lt;library_type&gt;</code>用于指定链接库的类型，可以是动态链接库（<code>SHARED</code>）或静态链接库（<code>STATIC</code>）。</p>
<p><code>&lt;source_files&gt;</code>是需要用到的源文件。</p>
<p>例如，在<code>account_dir/CMakeLists.txt</code>中，使用<code>add_library</code>命令生成一个名为<code>Account</code>的静态库，其包含了<code>Account.cpp</code>和<code>Account.h</code>两个源文件。示例命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Account STATIC Account.cpp Account.h)</span><br></pre></td></tr></table></figure>

<p>这将生成一个静态库文件<code>libAccount.a</code>。</p>
<p>B. 链接：</p>
<p>在<code>test_account/CMakeLists.txt</code>中，可以通过<code>target_link_libraries</code>命令将生成的静态库链接到目标可执行文件中。该命令的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(&lt;target_name&gt; &lt;library_name&gt;)</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;target_name&gt;</code>是目标可执行文件的名称，<code>&lt;library_name&gt;</code>是要链接的库文件名。</p>
<p>例如，在<code>test_account/CMakeLists.txt</code>中，假设有一个目标可执行文件名为<code>test_account</code>，需要链接生成的静态库<code>Account</code>。示例命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(test_account Account)</span><br></pre></td></tr></table></figure>

<p>这样，生成的可执行文件<code>test_account</code>将会链接静态库<code>Account</code>。</p>
<h3 id="2-3-5-生成动态库并连接"><a href="#2-3-5-生成动态库并连接" class="headerlink" title="2.3.5 生成动态库并连接"></a>2.3.5 生成动态库并连接</h3><p>A. 生成动态库：</p>
<p>在<code>account_dir/CMakeLists.txt</code>中，使用<code>add_library</code>命令来生成动态库。与生成静态库不同的是，需要将<code>&lt;library_type&gt;</code>参数设置为<code>SHARED</code>，表示生成动态链接库。</p>
<p>示例命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Account SHARED Account.cpp Account.h)</span><br></pre></td></tr></table></figure>

<p>这将生成一个动态库文件<code>libAccount.so</code>。</p>
<p>B. 链接：</p>
<p>链接过程与生成静态库时的操作相同，使用<code>target_link_libraries</code>命令将动态库链接到目标可执行文件中。</p>
<p>示例命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(test_account Account)</span><br></pre></td></tr></table></figure>

<p>这样，生成的可执行文件<code>test_account</code>将会链接动态库<code>Account</code>。</p>
<h3 id="2-3-6-CMake中的PUBLIC、PRIVATE、INTERFACE"><a href="#2-3-6-CMake中的PUBLIC、PRIVATE、INTERFACE" class="headerlink" title="2.3.6 CMake中的PUBLIC、PRIVATE、INTERFACE"></a>2.3.6 CMake中的PUBLIC、PRIVATE、INTERFACE</h3><p>在CMake中，可以使用<code>target_...()</code>系列命令来操作目标（Target）。这些命令通常支持通过<code>PUBLIC</code>、<code>PRIVATE</code>、<code>INTERFACE</code>关键字来控制属性的传播。</p>
<p>以<code>target_link_libraries(A B)</code>为例，下面是对这些关键字的理解：</p>
<ul>
<li><code>PRIVATE</code>：依赖项B仅链接到目标A。如果有目标C链接了目标A，目标C不会链接目标B。</li>
<li><code>INTERFACE</code>：依赖项B并不链接到目标A。如果有目标C链接了目标A，目标C会链接目标B。</li>
<li><code>PUBLIC</code>：依赖项B链接到目标A。如果有目标C链接了目标A，目标C也会链接目标B。</li>
</ul>
<p>可以将其类比为一个散烟的比方：</p>
<ul>
<li><code>PRIVATE</code>：就是自己抽烟，不给别人抽。</li>
<li><code>INTERFACE</code>：就是自己不抽烟，给别人抽。</li>
<li><code>PUBLIC</code>：就是自己抽烟，也给别人抽。</li>
</ul>
<p>从使用的角度来看，假设有目标C链接了目标A：</p>
<ul>
<li>如果目标B仅用于目标A的实现，并且不在头文件中提供给目标C使用，可以使用<code>PRIVATE</code>。</li>
<li>如果目标B不用于目标A的实现，仅在头文件中作为接口给目标C使用，可以使用<code>INTERFACE</code>。</li>
<li>如果目标B既用于目标A的实现，也在头文件中提供给目标C使用，可以使用<code>PUBLIC</code>。</li>
</ul>
<p>以下是一个示例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建库</span></span><br><span class="line"><span class="keyword">add_library</span>(c c.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(D d.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(B b.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用target_link_libraries命令进行链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(A PRIVATE B)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(A INTERFACE C)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(A PUBLIC D)</span><br></pre></td></tr></table></figure>

<p>在上述示例中，目标<code>A</code>通过<code>target_link_libraries</code>命令链接了目标<code>B</code>、<code>C</code>和<code>D</code>，使用了不同的传播属性。具体属性的选择取决于目标之间的关系和使用需求。</p>
<h3 id="2-3-7-变量"><a href="#2-3-7-变量" class="headerlink" title="2.3.7 变量"></a>2.3.7 变量</h3><p>在CMake中，你可以使用<code>message</code>命令输出消息并进行变量的操作和设置。</p>
<p>以下是一些常见的用法：</p>
<p>1.输出消息：使用<code>message</code>命令可以输出消息到CMake的输出。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;输出消息&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>2.消息拼接：使用<code>message</code>命令可以将多个消息进行拼接输出。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;输出1&quot;</span> <span class="string">&quot;输出2&quot;</span> <span class="string">&quot;输出3&quot;</span>)  <span class="comment"># 会进行拼接输出</span></span><br></pre></td></tr></table></figure>

<p>3.设置变量：使用<code>set</code>命令可以设置变量的值。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(VAR1 <span class="string">&quot;变量1&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;VAR1=&quot;</span> <span class="variable">$&#123;VAR1&#125;</span>)  <span class="comment"># 外部访问</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;输出变量VAR1:$&#123;VAR1&#125;&quot;</span>)  <span class="comment"># 内部拼接</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;\$&#123;VAR1&#125;=$&#123;VAR1&#125;&quot;</span>)  <span class="comment"># 使用\转义</span></span><br></pre></td></tr></table></figure>

<p>4.删除变量：使用<code>unset</code>命令可以删除变量。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unset</span>(VAR1)  <span class="comment"># 删除变量</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;\$&#123;VAR1&#125;=$&#123;VAR1&#125;&quot;</span>)  <span class="comment"># 删除变量后，输出为空</span></span><br></pre></td></tr></table></figure>

<p>5.设置变量缓存：使用<code>set</code>命令的<code>CACHE</code>选项可以设置一个变量的缓存，可以通过命令行的<code>-D</code>参数来修改该变量的值。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CACHE_VARIABLE_TEST <span class="string">&quot;原始值&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;变量缓存的描述&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;变量缓存的值:$&#123;CACHE_VARIABLE_TEST&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>6.常见的内置变量：CMake提供了一些内置的变量，用于获取构建系统的信息和配置</p>
<p>第一类: 提供信息的变量</p>
<ul>
<li><code>PROJECT_NAME</code>：项目名称，表示当前CMake项目的名称。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;PROJECT_NAME&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMAKE_SOURCE_DIR</code>：源码目录，表示当前CMake项目的根源码目录。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMAKE_BINARY_DIR</code>：编译目录，表示当前CMake项目的编译输出目录。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMAKE_CURRENT_LIST_FILE</code>：当前CMakeLists.txt文件路径，表示当前正在处理的CMakeLists.txt文件的完整路径。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_FILE&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这些变量提供了与项目、目录结构和文件相关的信息。</p>
<hr>
<p>第二类: 控制CMake运行的变量</p>
<p>CMake中的变量通常是根据构建选项进行命名的，例如<code>BUILD_SHARED_LIBS</code>。这些变量用于控制CMake的运行和构建过程。</p>
<hr>
<p>第三类: 描述系统的变量</p>
<ul>
<li><code>WIN32</code>：表示当前操作系统是否为Windows。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;是否是Windows系统: $&#123;WIN32&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>UNIX</code>：表示当前操作系统是否为类Unix（包括Linux、macOS等）。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;是否是Unix系统: $&#123;UNIX&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMAKE_SYSTEM_NAME</code>：系统名称，表示当前操作系统的名称。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;系统名称: $&#123;CMAKE_SYSTEM_NAME&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这些变量用于描述当前操作系统的一些信息，以便在构建过程中进行条件判断和配置。</p>
<h3 id="2-3-8-include引入其他代码"><a href="#2-3-8-include引入其他代码" class="headerlink" title="2.3.8 include引入其他代码"></a>2.3.8 include引入其他代码</h3><h3 id="2-3-9-条件控制"><a href="#2-3-9-条件控制" class="headerlink" title="2.3.9 条件控制"></a>2.3.9 条件控制</h3><p>CMake提供了条件控制的语法和关键词，使得你可以根据条件来控制构建过程中的行为。以下是一些常用的条件控制关键词和语法：</p>
<ul>
<li><code>if (variable)</code>：当变量的值为真时，执行相应的代码块。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE为真时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>else()</code>：在if条件为假时执行的代码块。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE为真时执行的代码块</span></span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE为假时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>真值常量：<code>ON</code>、<code>YES</code>、<code>TRUE</code>、<code>Y</code>、<code>1</code>、非零数字等。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE <span class="keyword">STREQUAL</span> <span class="string">&quot;ON&quot;</span>)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE的值为真时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>假值常量：<code>OFF</code>、<code>NO</code>、<code>FALSE</code>、<code>N</code>、<code>0</code>、空字符串、<code>NOTFOUND</code>等。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE <span class="keyword">STREQUAL</span> <span class="string">&quot;OFF&quot;</span>)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE的值为假时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>关键词：<code>NOT</code>、<code>TARGET</code>、<code>EXISTS (file)</code>、<code>DEFINED</code>等，可以与条件一起使用。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> <span class="keyword">TARGET</span> MyTarget)</span><br><span class="line">    <span class="comment"># 当MyTarget不存在时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>逻辑运算符：<code>AND</code>、<code>OR</code>用于组合多个条件。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (CONDITION1 <span class="keyword">AND</span> CONDITION2)</span><br><span class="line">    <span class="comment"># 当CONDITION1和CONDITION2同时为真时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CONDITION1 <span class="keyword">OR</span> CONDITION2)</span><br><span class="line">    <span class="comment"># 当CONDITION1或CONDITION2至少一个为真时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>MATCHES (regular expression)</code>：使用正则表达式进行匹配。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE <span class="keyword">MATCHES</span> <span class="string">&quot;^prefix.*&quot;</span>)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE以&quot;prefix&quot;开头时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>VERSION LESS</code>、<code>VERSION LESS_EQUAL</code>：用于比较版本号。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VERSION VERSION <span class="keyword">LESS</span> <span class="number">2.0</span>)</span><br><span class="line">    <span class="comment"># 当MY_VERSION小于2.0时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>通过这些条件控制关键词和语法，你可以根据不同的条件来执行不同的代码块，从而实现更灵活和可配置的构建过程。你可以根据具体的需求选择适当的条件控制方式，并结合变量、关键词和运算符来编写CMake脚本。</p>
<h3 id="2-3-10-CMake分步编译"><a href="#2-3-10-CMake分步编译" class="headerlink" title="2.3.10 CMake分步编译"></a>2.3.10 CMake分步编译</h3><p>首先，你使用以下命令查看所有的目标：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --build . --target help</span><br></pre></td></tr></table></figure>

<p>这将列出项目中可用的目标列表，包括默认目标”all”、”clean”、”depend”、”rebuild_cache”、”edit_cache”以及其他一些目标。</p>
<p>接下来，你执行以下命令进行预处理：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --build . --target main.i</span><br></pre></td></tr></table></figure>

<p>这将对”main.cpp”源文件进行预处理，并将预处理结果保存在”CMakeFiles&#x2F;steps_demo.dir&#x2F;main.cpp.i”文件中。</p>
<p>然后，你执行以下命令进行编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --build . --target main.sI</span><br></pre></td></tr></table></figure>

<p>这将将”main.cpp”源文件编译为汇编代码，并将汇编代码保存在”CMakeFiles&#x2F;steps_demo.dir&#x2F;main.cpp.s”文件中。</p>
<p>接着，你执行以下命令进行汇编：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --build . --target main.o</span><br></pre></td></tr></table></figure>

<p>这将将汇编代码编译为目标文件，并将目标文件保存为”CMakeFiles&#x2F;steps_demo.dir&#x2F;main.cpp.o”。</p>
<p>最后，你执行以下命令进行链接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --build .</span><br></pre></td></tr></table></figure>

<p>这将扫描依赖项并链接生成最终的可执行文件”steps_demo”。</p>
<p>最后，你执行以下命令运行可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./steps_demo</span><br></pre></td></tr></table></figure>

<p>这将运行生成的可执行文件。</p>
<h3 id="2-3-11-生成器表达式"><a href="#2-3-11-生成器表达式" class="headerlink" title="2.3.11 生成器表达式"></a>2.3.11 生成器表达式</h3><p>生成器表达式是CMake中一种用于在生成构建系统时根据不同配置动态生成特定内容的表达式。它可以让代码更加精简和灵活。下面是几种常用的生成器表达式类型：</p>
<p>条件表达式：<code>$&lt;condition:true_string&gt;</code>。当条件为真时，返回<code>true_string</code>，否则返回空字符串。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">$&lt;<span class="number">0</span>:<span class="keyword">TEST</span>&gt;           <span class="comment"># 返回空字符串</span></span><br><span class="line">$&lt;<span class="number">1</span>:<span class="keyword">TEST</span>&gt;           <span class="comment"># 返回&quot;TEST&quot;</span></span><br><span class="line">$&lt;$&lt;BOOL:<span class="keyword">TRUE</span>&gt;:<span class="keyword">TEST</span>&gt;  <span class="comment"># 返回&quot;TEST&quot;</span></span><br></pre></td></tr></table></figure>

<p>变量查询（Variable-Query）：通过查询变量来获取动态的值。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">$&lt;TARGET_EXISTS:<span class="keyword">target</span>&gt;             <span class="comment"># 判断目标是否存在</span></span><br><span class="line">$&lt;CONFIG:Debug&gt;                     <span class="comment"># 判断当前构建类型是否为Debug</span></span><br></pre></td></tr></table></figure>

<p>目标查询（Target-Query）：通过查询目标来获取相关的信息。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">$&lt;TARGET_FILE:<span class="keyword">target</span>&gt;               <span class="comment"># 获取目标的文件路径</span></span><br><span class="line">$&lt;TARGET_FILE_NAME:<span class="keyword">target</span>&gt;          <span class="comment"># 获取目标的文件名</span></span><br></pre></td></tr></table></figure>

<p>输出相关表达式：用于在不同的构建环节使用不同的参数。比如，在<code>install</code>和<code>build</code>阶段使用不同的参数。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Foo ...)</span><br><span class="line"><span class="keyword">target_include_directories</span>(Foo</span><br><span class="line">    PUBLIC</span><br><span class="line">        $&lt;$&lt;CONFIG:Debug&gt;:<span class="variable">$&#123;DEBUG_INCLUDES&#125;</span>&gt;</span><br><span class="line">        $&lt;$&lt;CONFIG:Release&gt;:<span class="variable">$&#123;RELEASE_INCLUDES&#125;</span>&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在上述示例中，根据不同的构建配置（Debug或Release），生成器表达式选择性地包含不同的头文件路径。</p>
<p>需要注意的是，生成器表达式在生成构建系统时被展开，因此无法通过<code>message</code>命令直接打印。你可以使用类似<code>file(GENERATE OUTPUT &quot;./generator_test.txt&quot; CONTENT &quot;$&lt;$&lt;BOOL:TRUE&gt;:TEST&gt;&quot;)</code>的方式将生成器表达式的结果写入文件，以间接测试生成器表达式的值。</p>
<h3 id="2-3-12-函数和宏"><a href="#2-3-12-函数和宏" class="headerlink" title="2.3.12 函数和宏"></a>2.3.12 函数和宏</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个宏</span></span><br><span class="line"><span class="keyword">macro</span>(my_macro)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;宏内部的信息&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(macro_var <span class="string">&quot;宏内部变量test&quot;</span>)</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数</span></span><br><span class="line"><span class="keyword">function</span>(second_func arg1 arg2)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;第一个参数: $&#123;arg1&#125;，第二个参数: $&#123;arg2&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>my_macro</code>是一个没有参数的宏，它在宏内部输出一条信息，并设置了一个变量<code>macro_var</code>的值。</p>
<p><code>second_func</code>是一个函数，它有两个参数<code>arg1</code>和<code>arg2</code>。在函数内部，它输出了两个参数的值。</p>
<p>你可以在CMakeLists.txt文件中使用这些宏和函数，例如：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用宏</span></span><br><span class="line">my_macro()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">second_func(<span class="string">&quot;Hello&quot;</span> <span class="string">&quot;World&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当你运行CMake生成构建系统时，你将看到宏内部的信息输出，并且可以访问在宏或函数内部定义的变量。函数将输出参数的值。</p>
<p>请注意，宏和函数的定义需要在CMakeLists.txt文件的适当位置进行，并且在调用它们之前必须先定义它们。</p>
<h3 id="2-3-13-设置安装"><a href="#2-3-13-设置安装" class="headerlink" title="2.3.13 设置安装"></a>2.3.13 设置安装</h3><p><code>install</code>命令用于设置安装规则，将目标文件和文件夹安装到指定的位置。下面是你提供的代码的解释：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS instal_demo slib dlib</span><br><span class="line">    RUNTIME DESTINATION bin     <span class="comment"># 可执行文件安装路径</span></span><br><span class="line">    LIBRARY DESTINATION lib     <span class="comment"># 动态库安装路径</span></span><br><span class="line">    ARCHIVE DESTINATION lib     <span class="comment"># 静态库安装路径</span></span><br><span class="line">    PUBLIC_HEADER DESTINATION <span class="keyword">include</span>   <span class="comment"># 公共头文件安装路径</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>install</code>命令指定了要安装的目标文件列表，其中包括<code>instal_demo</code>、<code>slib</code>和<code>dlib</code>。</p>
<p>接下来，通过指定不同的<code>DESTINATION</code>参数，定义了目标文件在安装过程中的安装路径：</p>
<ul>
<li><code>RUNTIME DESTINATION bin</code>：指定可执行文件的安装路径为<code>bin</code>目录。</li>
<li><code>LIBRARY DESTINATION lib</code>：指定动态库的安装路径为<code>lib</code>目录。</li>
<li><code>ARCHIVE DESTINATION lib</code>：指定静态库的安装路径为<code>lib</code>目录。</li>
<li><code>PUBLIC_HEADER DESTINATION include</code>：指定公共头文件的安装路径为<code>include</code>目录。</li>
</ul>
<p>根据你的需求，这些目标文件将被安装到指定的目录中。</p>
<p>请注意，安装路径是相对于安装目录的，因此你需要确保安装目录在运行<code>make install</code>时正确设置。</p>
<p>要解决在安装后无法找到动态库的问题，可以使用<code>set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)</code>和<code>set(CMAKE_INSTALL_RPATH &quot;$&#123;CMAKE_INSTALL_PREFIX&#125;/lib&quot;)</code>来设置RPATH。</p>
<p>下面是相应的代码：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_WITH_INSTALL_RPATH <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_RPATH <span class="string">&quot;$&#123;CMAKE_INSTALL_PREFIX&#125;/lib&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)</code>指示在构建过程中使用与安装RPATH相同的RPATH。这样，在构建时就可以正确地查找和链接动态库。</p>
<p><code>set(CMAKE_INSTALL_RPATH &quot;$&#123;CMAKE_INSTALL_PREFIX&#125;/lib&quot;)</code>将安装RPATH设置为<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/lib</code>，其中<code>$&#123;CMAKE_INSTALL_PREFIX&#125;</code>是安装目录的路径。这将导致在安装时设置RPATH，使得安装后的可执行文件可以在<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/lib</code>目录中正确地查找和加载动态库。</p>
<p>通过使用这两个设置，你可以解决在安装后无法找到动态库的问题。确保将其放置在CMakeLists.txt文件中的合适位置，并根据实际情况调整<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/lib</code>路径，以匹配你的安装目录结构。</p>
<h3 id="2-3-14-寻找依赖find-package"><a href="#2-3-14-寻找依赖find-package" class="headerlink" title="2.3.14 寻找依赖find_package"></a>2.3.14 寻找依赖find_package</h3><p>对于大多数支持CMake的项目来说，可以使用<code>find_package</code>命令来查找对应的依赖库。通常情况下，如果找到了库，会设置以下变量（这些变量由库的作者设置）：</p>
<ul>
<li><code>&lt;LibaryName&gt;_FOUND</code>：表示是否找到库。</li>
<li><code>&lt;LibaryName&gt;_INCLUDE_DIR</code>：表示库的头文件目录。</li>
<li><code>&lt;LibaryName&gt;_LIBRARIES</code>：表示库的库文件目录。</li>
</ul>
<p>如果你编写了一个新的函数库，并希望其他项目可以通过<code>find_package</code>引用它，你可以使用以下两种方法：</p>
<ol>
<li><p>编写一个<code>Find&lt;LibraryName&gt;.cmake</code>文件：适用于导入非CMake安装的项目。</p>
<p>你可以编写一个名为<code>Find&lt;LibraryName&gt;.cmake</code>的文件，并将其放置在CMake的<code>Modules</code>目录或项目的特定目录中。该文件应包含查找和设置相关变量的逻辑。其他项目可以通过<code>find_package</code>命令来引用这个自定义的查找文件，从而找到并使用你的库。</p>
<p>附件: 15.custom_find</p>
</li>
<li><p>使用<code>install</code>安装并生成<code>&lt;LibraryName&gt;Config.cmake</code>文件：适用于导入你自己开发的CMake项目。</p>
<p>在你的库项目中，可以使用<code>install</code>命令将库文件安装到指定位置，并生成<code>&lt;LibraryName&gt;Config.cmake</code>文件。该文件应包含设置变量和导出目标的逻辑。其他项目可以通过<code>find_package</code>命令找到并使用你的库。</p>
</li>
</ol>
<p>&#x3D;&#x3D;现在只是简单的写了一下学习的内容，但是对于很多内容还并不是很熟悉，一切都要等到最后实战的时候&#x3D;&#x3D;</p>
]]></content>
      <categories>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>c++进阶语法 oop 智能指针 STL</title>
    <url>/2023/09/03/c-%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95-oop-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-STL/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-OOP面向对象开发"><a href="#1-OOP面向对象开发" class="headerlink" title="1 OOP面向对象开发"></a>1 OOP面向对象开发</h1><h2 id="1-1-类-class-和对象-objects"><a href="#1-1-类-class-和对象-objects" class="headerlink" title="1.1 类(class)和对象(objects)"></a>1.1 类(class)和对象(objects)</h2><pre><code>类(classes)和对象(objects)
</code></pre>
<p>C++类(classes)</p>
<ul>
<li>创建对象用的蓝图(blueprint)</li>
<li>用户自定义的数据类型</li>
<li>有成员属性(data)和成员方法(methods)</li>
<li>可以隐藏属性和方法(private)</li>
<li>可以提供公共接口(public)</li>
<li>示例:Account,Student,std:vector, std:string</li>
</ul>
<p>C++对象(objects)</p>
<ul>
<li>由类创建而来</li>
<li>表示类的一个具体的实例(lnstance)</li>
<li>可以有很多个实例，每个都有独立的身份·每个对象都可以使用类中定义的方法</li>
</ul>
<p>Account对象示例</p>
<ul>
<li>Jobs、Alice的apunt是Account类的实例</li>
<li>每个实例都有它的余额、可以提现、存钱</li>
</ul>
<p>声明一个类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span></span>; <span class="comment">// 存款</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span></span>; <span class="comment">// 取款</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建类的对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Account jobs_account;</span><br><span class="line">Account alice_account;</span><br><span class="line">Account* mary_account = <span class="keyword">new</span> <span class="built_in">Account</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> mary_account;</span><br></pre></td></tr></table></figure>



<p>示例1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> </span><br><span class="line">&#123;</span><br><span class="line">    string name &#123;<span class="string">&quot;None&quot;</span>&#125;;</span><br><span class="line">    <span class="type">double</span> balance &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Account a;</span><br><span class="line">    Account b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>获取类的属性或者方法</p>
<p>使用点操作符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Account jobs_account;</span><br><span class="line">jobs_account.balance;</span><br><span class="line">jobs_account.<span class="built_in">deposit</span>( <span class="number">10.00</span>);</span><br></pre></td></tr></table></figure>

<p>如果是一个指向对象的指针，可以解引用或者使用箭头操作符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Account* alice_account = <span class="keyword">new</span> <span class="built_in">Account</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解引用指针并访问成员</span></span><br><span class="line">(*alice_account).balance; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指针访问成员</span></span><br><span class="line">alice_account-&gt;<span class="built_in">deposit</span>(<span class="number">100.0</span>);</span><br><span class="line">alice_account-&gt;balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> alice_account;</span><br></pre></td></tr></table></figure>



<h2 id="1-2-public、private、protected访问权限"><a href="#1-2-public、private、protected访问权限" class="headerlink" title="1.2 public、private、protected访问权限"></a>1.2 public、private、protected访问权限</h2><p>public</p>
<p>可以被任何实体访问   </p>
<hr>
<p>private<br>只能被本类的方法访问</p>
<hr>
<p>protected</p>
<p>可以被本类和子类(继承)的方法访问\</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span></span>; <span class="comment">// 存款</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span></span>; <span class="comment">// 取款</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>在类中实现完整的成员方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="type">double</span> balance &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">setBalance</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        balance = amount;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在类外面实现需要特殊定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="type">double</span> balance &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">setBalance</span><span class="params">(<span class="type">double</span> amount)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBalance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Account::setBalance</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">    balance = amount;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Account::getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-3-构造函数-constructor"><a href="#1-3-构造函数-constructor" class="headerlink" title="1.3 构造函数(constructor)"></a>1.3 构造函数(constructor)</h2><ul>
<li>特殊的成员方法</li>
<li>对象创建的时候自动调用</li>
<li>适用于实例参数初始化</li>
<li>函数名和类的名称一致</li>
<li>无需设置返回类型</li>
<li>可以被重载(overload)</li>
</ul>
<h2 id="1-4-析构函数-destructor"><a href="#1-4-析构函数-destructor" class="headerlink" title="1.4 析构函数(destructor)"></a>1.4 析构函数(destructor)</h2><ul>
<li>特殊的成员方法</li>
<li>函数名和类的名称一致，前面跟着一个~波浪符号</li>
<li>对象销毁的时候自动调用</li>
<li>没有参数，没有返回类型</li>
<li>只有一个析构函数(不能重载)</li>
<li>适用于释放内存等资源</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    std::string name&#123;<span class="string">&quot;account&quot;</span>&#125;;</span><br><span class="line">    <span class="type">double</span> balance&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Account</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Account</span>(std::string name);</span><br><span class="line">    <span class="built_in">Account</span>(<span class="type">double</span> balance);</span><br><span class="line">    <span class="built_in">Account</span>(std::string name, <span class="type">double</span> balance);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Account</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​		</p>
<h2 id="1-5-构造函数初始化列表"><a href="#1-5-构造函数初始化列表" class="headerlink" title="1.5 构造函数初始化列表"></a>1.5 构造函数初始化列表</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，使用构造函数内部初始化参数</span></span><br><span class="line">    <span class="built_in">Account</span>(std::string name, <span class="type">double</span> balance) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，使用初始化列表初始化参数</span></span><br><span class="line">    <span class="built_in">Account</span>(std::string name, <span class="type">double</span> balance)</span><br><span class="line">        : name&#123;name&#125;, balance&#123;balance&#125; &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-代理构造函数"><a href="#1-6-代理构造函数" class="headerlink" title="1.6 代理构造函数"></a>1.6 代理构造函数</h2><ul>
<li>重载的构造函数很相似·冗余的代码可能会导致错误</li>
<li>使用代理构造函数</li>
<li>在一个构造函数初始化列表中调用另一个构造函数</li>
</ul>
<h2 id="1-7-拷贝构造函数"><a href="#1-7-拷贝构造函数" class="headerlink" title="1.7 拷贝构造函数"></a>1.7 拷贝构造函数</h2><p>当对象被拷贝时，C++必须从已存在的对象复制出一个新的对象</p>
<p>何时使用拷贝构造函数?</p>
<ul>
<li>以值传递方式传递对象给函数（作参数)</li>
<li>函数以值方式返回对象</li>
<li>使用已存在的对象复制新的对象</li>
</ul>
<p>如果不提供自己写的copy constructor,编译器会自动生成一个(可能不符合要</p>
<h2 id="1-9-浅拷贝和深拷贝"><a href="#1-9-浅拷贝和深拷贝" class="headerlink" title="1.9 浅拷贝和深拷贝"></a>1.9 浅拷贝和深拷贝</h2><p>如果不提供自己写的copy constructor.编译器会生成默认的<br>将目标对象的值逐个拷贝过来;<br>如果是指针，拷贝的是值（指向的地址)，而不是指向的对象（浅拷贝)在析构函数中释放内存时，其他对象中的指针可能还在指向被释放的资源</p>
<h2 id="1-10-在类中使用const"><a href="#1-10-在类中使用const" class="headerlink" title="1.10 在类中使用const"></a>1.10 在类中使用const</h2><p>在类中使用const常函数</p>
<p>函数名称后加const</p>
<ul>
<li>函数体内不可以修改类成员属性。常对象</li>
</ul>
<p>声明对象时前面加const</p>
<ul>
<li>不可以修改常对象的成员属性仅能调用常函数</li>
</ul>
<h2 id="1-11-在类中使用static"><a href="#1-11-在类中使用static" class="headerlink" title="1.11 在类中使用static"></a>1.11 在类中使用static</h2><p>静态成员变量</p>
<ul>
<li><p>所有对象共有同一份数据（数据共享)</p>
</li>
<li><p>在类中声明，类外初始化</p>
</li>
</ul>
<p>静态成员函数</p>
<p>所有对象共享同一个函数</p>
<ul>
<li>只能访问静态成员变量</li>
</ul>
<h2 id="1-12-struct和class区别"><a href="#1-12-struct和class区别" class="headerlink" title="1.12 struct和class区别"></a>1.12 struct和class区别</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    std::string name&#123;<span class="string">&quot;none&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认私有属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    std::string name&#123;<span class="string">&quot;none&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 默认公有属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Account aa;</span><br><span class="line">    <span class="comment">// aa.name = &quot;bob&quot;; // 报错，无法访问私有成员</span></span><br><span class="line"></span><br><span class="line">    Student ss;</span><br><span class="line">    ss.name = <span class="string">&quot;alice&quot;</span>; <span class="comment">// 可以访问公有成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-智能指针"><a href="#2-智能指针" class="headerlink" title="2 智能指针"></a>2 智能指针</h1><p>原始指针(raw pointer)的一些问题</p>
<p>1.c++提供了内存管理的绝对自由度</p>
<ul>
<li><p>分配</p>
</li>
<li><p>释放</p>
</li>
<li><p>声明周期管理</p>
</li>
</ul>
<p>2.一些潜在严重问题</p>
<ul>
<li><p>未初始化的指针(wild pointer)</p>
</li>
<li><p>内存泄漏(memory leak)</p>
</li>
<li><p>悬空指针(dangling pointer</p>
</li>
</ul>
<p>3.所有权(ownership)</p>
<ul>
<li>谁拥有指针?</li>
<li>何时可以删除指针?</li>
</ul>
<p>C++智能指针是一种用来管理动态分配的内存的工具，它们遵循RAII（资源获取即初始化）原则，可以自动释放内存，防止内存泄漏。</p>
<p>以下是几种常见的C++智能指针：</p>
<ol>
<li><code>unique_ptr</code>: <code>unique_ptr</code> 是一种独占所有权的智能指针，它指向堆上分配的对象，并负责在其生命周期结束时自动删除对象。每个 <code>unique_ptr</code> 只能拥有一个对象，并且不能进行拷贝，但可以进行移动。</li>
<li><code>shared_ptr</code>: <code>shared_ptr</code> 是一种共享所有权的智能指针，多个 <code>shared_ptr</code> 可以指向同一个对象。它使用引用计数来跟踪对象的所有者数量，并在最后一个所有者释放内存时删除对象。</li>
<li><code>weak_ptr</code>: <code>weak_ptr</code> 是一种弱引用指针，它可以与 <code>shared_ptr</code> 一起使用。<code>weak_ptr</code> 不会增加对象的引用计数，它允许对被 <code>shared_ptr</code> 管理的对象进行观测，但不拥有所有权。当 <code>shared_ptr</code> 删除对象后，<code>weak_ptr</code> 会自动失效。</li>
<li><code>auto_ptr</code>（已弃用）: <code>auto_ptr</code> 是C++98标准引入的智能指针，它类似于 <code>unique_ptr</code>，但具有一些问题和局限性，已被废弃，不推荐使用。</li>
</ol>
<p><code>unique_ptr&lt;T&gt;</code> 是一种独占所有权的智能指针，用于指向堆上的类型为 <code>T</code> 的对象。它保证在其生命周期结束时自动释放所指向的对象，确保资源的正确释放，避免内存泄漏。</p>
<p><code>unique_ptr</code> 的特点如下：</p>
<ul>
<li>它是唯一（unique）的，即一个 <code>unique_ptr</code> 对象拥有对应对象的唯一所有权。不能有多个 <code>unique_ptr</code> 指向同一个对象，这样可以避免多次释放同一块内存的问题。</li>
<li><code>unique_ptr</code> 不能进行复制或赋值，但可以通过移动语义来转移所有权。这意味着可以将所有权从一个 <code>unique_ptr</code> 转移到另一个 <code>unique_ptr</code>，从而实现对象所有权的转移而不进行内存复制。</li>
<li>当 <code>unique_ptr</code> 使用完毕或超出作用域时，它所指向的对象会自动释放和销毁，无需手动调用 <code>delete</code>。</li>
</ul>
<p>&#x3D;&#x3D;目前还没用过，等真正用过的时候再仔细看吧&#x3D;&#x3D;</p>
<h1 id="3-STL标准模板库"><a href="#3-STL标准模板库" class="headerlink" title="3 STL标准模板库"></a>3 STL标准模板库</h1><h2 id="3-1-STL简介"><a href="#3-1-STL简介" class="headerlink" title="3.1 STL简介"></a>3.1 STL简介</h2><p>一个强大的、可复用的、自适应的泛型类和函数集合</p>
<p>使用C++模板(templates)实现</p>
<p>实现了常见的数据结构(data struuctures)和算法(algorithms)</p>
<p>庞大的类库</p>
<p>俄裔美籍程序员:Alexander Step:anov 1994年开发</p>
<p>容器(containers)</p>
<ul>
<li>各种对象或原始类型的集合. array、vector、deque、stack、set、map等</li>
</ul>
<p>算法(algorithms)</p>
<ul>
<li>处理容器元素序列的各种函数find、max、count、accumulate、sort等</li>
</ul>
<p>迭代器(iterators)</p>
<ul>
<li>从容器中生成元素的序列. forward、reveise、by value、by constant等</li>
</ul>
<h2 id="3-2-STL容器的类别"><a href="#3-2-STL容器的类别" class="headerlink" title="3.2 STL容器的类别"></a>3.2 STL容器的类别</h2><p>序列式容器（Sequence Containers）：</p>
<ol>
<li><code>vector</code>：动态数组，支持快速随机访问，尾部插入和删除元素效率高，但在中间或头部插入和删除元素效率低。</li>
<li><code>list</code>：双向链表，支持在任意位置插入和删除元素，但随机访问效率较低。</li>
<li><code>forward_list</code>：单向链表，与 <code>list</code> 类似，但只支持单向遍历，没有双向遍历的能力。</li>
<li><code>deque</code>：双端队列，支持在头部和尾部高效地插入和删除元素，同时支持随机访问。</li>
</ol>
<p>关联式容器（Associative Containers）：</p>
<ol>
<li><code>set</code>：集合，存储唯一的元素，并按升序排序。</li>
<li><code>multi_set</code>：多重集合，可存储重复的元素，并按升序排序。</li>
<li><code>map</code>：映射，存储键值对，按键的升序排序。</li>
<li><code>multi_map</code>：多重映射，可存储重复的键值对，并按键的升序排序。</li>
</ol>
<p>容器适配器（Container Adapters）：</p>
<ol>
<li><code>stack</code>：栈，以 LIFO（后进先出）的方式存储元素，底层基于序列式容器实现，默认使用 <code>deque</code>。</li>
<li><code>queue</code>：队列，以 FIFO（先进先出）的方式存储元素，底层基于序列式容器实现，默认使用 <code>deque</code>。</li>
<li><code>priority_queue</code>：优先队列，按照优先级存储元素，底层基于序列式容器实现，默认使用 <code>vector</code>。</li>
</ol>
<h2 id="3-3-STL迭代器的类别"><a href="#3-3-STL迭代器的类别" class="headerlink" title="3.3 STL迭代器的类别"></a>3.3 STL迭代器的类别</h2><p>迭代器是一种用于遍历容器中元素的抽象概念，它提供了对容器中元素的访问和操作方式。C++中定义了多种类型的迭代器，每种迭代器具有不同的特性和功能。</p>
<ol>
<li>输入迭代器（Input Iterators）：从容器到程序，对数据进行只读访问。它允许逐个元素地读取容器中的数据，并且只能单向移动，不支持对容器进行修改。</li>
<li>输出迭代器（Output Iterators）：从程序到容器，对数据进行只写访问。它允许逐个元素地向容器中写入数据，并且只能单向移动，不支持读取容器中的数据。</li>
<li>前向迭代器（Forward Iterators）：向前推进迭代器，支持对容器进行读写操作。它具有输入迭代器和输出迭代器的所有功能，并且可以在容器中任意位置插入和删除元素，支持双向移动。</li>
<li>双向迭代器（Bidirectional Iterators）：向前、向后推进迭代器，支持对容器进行读写操作。它具有前向迭代器的所有功能，并且可以反向移动，即向前和向后移动。</li>
<li>随机访问迭代器（Random Access Iterators）：直接获取容器元素，支持对容器进行读写操作。它具有双向迭代器的所有功能，并且支持随机访问，可以通过偏移量直接访问容器中的任意元素。</li>
</ol>
<h2 id="3-4-STL算法的类别"><a href="#3-4-STL算法的类别" class="headerlink" title="3.4 STL算法的类别"></a>3.4 STL算法的类别</h2><p>非质变的算法（Non-modifying Algorithms）：</p>
<ol>
<li><code>std::all_of</code>：判断范围内的所有元素是否满足给定条件。</li>
<li><code>std::any_of</code>：判断范围内是否存在满足给定条件的元素。</li>
<li><code>std::none_of</code>：判断范围内是否所有元素都不满足给定条件。</li>
<li><code>std::for_each</code>：对范围内的每个元素执行指定的操作。</li>
<li><code>std::count</code>：计算范围内满足给定值的元素个数。</li>
<li><code>std::count_if</code>：计算范围内满足给定条件的元素个数。</li>
<li><code>std::find</code>：查找范围内第一个等于给定值的元素。</li>
<li><code>std::find_if</code>：查找范围内第一个满足给定条件的元素。</li>
<li><code>std::find_if_not</code>：查找范围内第一个不满足给定条件的元素。</li>
<li><code>std::find_end</code>：在范围内查找最后一次出现子序列的起始位置。</li>
<li><code>std::find_first_of</code>：在范围内查找第一次出现指定元素之一的位置。</li>
<li><code>std::adjacent_find</code>：在范围内查找第一对相邻重复元素的位置。</li>
<li><code>std::search</code>：在范围内查找第一次出现子序列的起始位置。</li>
<li><code>std::search_n</code>：在范围内查找第一次出现连续多个相等元素的起始位置。</li>
<li><code>std::equal</code>：判断两个范围内的元素是否相等。</li>
<li><code>std::mismatch</code>：找到两个范围内第一次不匹配的位置。</li>
<li><code>std::lexicographical_compare</code>：按字典顺序比较两个范围。</li>
<li><code>std::is_permutation</code>：判断两个范围内的元素是否是排列关系。</li>
<li><code>std::min_element</code>：找到范围内的最小元素的位置。</li>
<li><code>std::max_element</code>：找到范围内的最大元素的位置。</li>
<li><code>std::minmax_element</code>：同时找到范围内的最小和最大元素的位置。</li>
<li><code>std::clamp</code>：将给定值限制在指定范围内。</li>
<li><code>std::is_sorted</code>：判断范围内的元素是否按升序排序。</li>
<li><code>std::is_partitioned</code>：判断范围内的元素是否满足分区条件。</li>
<li><code>std::is_heap</code>：判断范围内的元素是否满足堆的条件。</li>
<li><code>std::is_sorted_until</code>：找到范围内的第一个无序位置。</li>
<li><code>std::is_partitioned_until</code>：找到范围内的第一个不满足分区条件的位置。</li>
<li><code>std::is_heap_until</code>：找到范围内的第一个不满足堆条件的位置。</li>
</ol>
<p>质变的算法（Modifying Algorithms）：</p>
<ol>
<li><code>std::copy</code>：复制范围内的元素到另一个容器。</li>
<li><code>std::copy_if</code>：复制满足给定条件的元素到另一个容器。</li>
<li><code>std::copy_n</code>：复制指定数量的元素到另一个容器。</li>
<li><code>std::copy_backward</code>：反向复制范围内的元素到另一个容器。</li>
<li><code>std::move</code>：将范围内的元素移动到另一个容器。</li>
<li><code>std::move_backward</code>：反向移动范围内的元素到另一个容器。</li>
<li><code>std::fill</code>：用给定值填充容器中的元素。</li>
<li><code>std::fill_n</code>：用给定值填充指定数量的元素。</li>
<li><code>std::generate</code>：使用生成器函数生成范围内的元素。</li>
<li><code>std::generate_n</code>：使用生成器函数生成指定数量的元素。</li>
<li><code>std::transform</code>：对范围内的元素应用指定的操作，并将结果存储到另一个容器。</li>
<li><code>std::replace</code>：将范围内的指定值替换为新值。</li>
<li><code>std::replace_if</code>：根据给定条件将范围内的元素替换为新值。</li>
<li><code>std::replace_copy</code>：将范围内的元素复制到另一个容器，并将指定值替换为新值。</li>
<li><code>std::replace_copy_if</code>：将范围内的元素复制到另一个容器，并根据给定条件替换为新值。</li>
<li><code>std::swap</code>：交换两个对象的值。</li>
<li><code>std::swap_ranges</code>：交换两个范围的元素。</li>
<li><code>std::iter_swap</code>：交换两个迭代器所指向的元素。</li>
<li><code>std::reverse</code>：反转范围内的元素顺序。</li>
<li><code>std::reverse_copy</code>：将范围内的元素反转后复制到另一个容器。</li>
<li><code>std::rotate</code>：将范围内的元素循环右移。</li>
<li><code>std::rotate_copy</code>：将范围内的元素循环右移后复制到另一个容器。</li>
<li><code>std::shuffle</code>：随机重排范围内的元素。</li>
<li><code>std::unique</code>：移除范围内的连续重复元素，只保留一个副本。</li>
<li><code>std::unique_copy</code>：将范围内的连续重复元素复制到另一个容器，只保留一个副本。</li>
<li><code>std::partition</code>：根据给定条件将范围内的元素分为满足条件和不满足条件的两部分。</li>
<li><code>std::stable_partition</code>：根据给定条件将范围内的元素稳定地分为满足条件和不满足条件的两部分。</li>
<li><code>std::sort</code>：对范围内的元素进行排序。</li>
<li><code>std::stable_sort</code>：对范围内的元素进行稳定排序。</li>
<li><code>std::partial_sort</code>：部分排序范围内的元素。</li>
<li><code>std::nth_element</code>：将范围内的第 n 小的元素移动到指定位置。</li>
<li><code>std::inplace_merge</code>：将两个已排序的范围合并为一个已排序的范围。</li>
<li><code>std::transform</code>：对范围内的元素应用指定的操作，并将结果存储到另一个容器。</li>
<li><code>std::generate</code>：使用生成器函数生成范围内的元素。</li>
<li><code>std::generate_n</code>：使用生成器函数生成指定数量的元素。</li>
<li><code>std::random_shuffle</code>：随机重排范围内的元素。</li>
<li><code>std::partition</code>：根据给定条件将范围内的元素分为满足条件和不满足条件的两部分。</li>
<li><code>std::sort</code>：对范围内的元素进行排序。</li>
<li><code>std::stable_sort</code>：对范围内的元素进行稳定排序。</li>
<li><code>std::partial_sort</code>：部分排序范围内的元素。</li>
<li><code>std::nth_element</code>：将范围内的第 n 小的元素移动到指定位置。</li>
<li><code>std::inplace_merge</code>：将两个已排序的范围合并为一个已排序的范围。</li>
<li><code>std::copy_backward</code>：反向复制范围内的元素到另一个容器。</li>
</ol>
<h2 id="3-5泛型编程和宏"><a href="#3-5泛型编程和宏" class="headerlink" title="3.5泛型编程和宏"></a>3.5泛型编程和宏</h2><h2 id="3-6函数模板"><a href="#3-6函数模板" class="headerlink" title="3.6函数模板"></a>3.6函数模板</h2><p>函数模板（Function Template）是C++中的一种特殊函数，用于定义通用的函数，可以适用于不同类型的参数。函数模板通过在函数定义中使用类型参数来实现通用性，这些类型参数可以在函数调用时被具体的类型替代。</p>
<p>以下是两个使用函数模板定义的求最大值函数的示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(a, b) &lt;&lt; std::endl;  <span class="comment">// 调用模板函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-7类模板"><a href="#3-7类模板" class="headerlink" title="3.7类模板"></a>3.7类模板</h2><p>类模板（Class Template）是C++中的一种特殊类，用于定义通用的类，可以适用于不同类型的成员变量和成员函数。类模板通过在类定义中使用类型参数来实现通用性，这些类型参数可以在类实例化时被具体的类型替代。</p>
<p>类模板的使用方式类似于函数模板，通过在类定义前面使用 <code>template&lt;typename T&gt;</code> 或 <code>template&lt;class T&gt;</code> 声明一个模板类，其中 <code>T</code> 是一个模板参数，可以在类内部的成员变量和成员函数中使用。</p>
<p>以下是一个使用类模板定义的通用的容器类的示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Container</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ 进阶 函数和指针</title>
    <url>/2023/09/03/c-%E8%BF%9B%E9%98%B6-%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-掌握C-函数基本概念用法"><a href="#1-掌握C-函数基本概念用法" class="headerlink" title="1.掌握C++函数基本概念用法"></a>1.掌握C++函数基本概念用法</h1><h2 id="1-1-函数定义"><a href="#1-1-函数定义" class="headerlink" title="1.1 函数定义"></a>1.1 函数定义</h2><p>什么是函数(function)</p>
<ul>
<li><p>C++程序</p>
</li>
<li><p>C++标准库(functions和clas;ses)</p>
</li>
<li><p>第三方库(functions和class</p>
</li>
<li><p>自定义的functions和classes</p>
</li>
</ul>
<p>函数让我们的程序更加模块化</p>
<ul>
<li>让代码解耦，分成按业务，</li>
<li>按逻辑的单元提高代码复用性</li>
</ul>
<p>函数名称参数列表</p>
<ul>
<li><p>传给函数的变量</p>
</li>
<li><p>变量类型需声明</p>
</li>
</ul>
<p>返回值类型</p>
<ul>
<li><p>函数体</p>
</li>
<li><p>函数被调用执行的部分，花括号{}内部</p>
<p>示例1：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI &#123;<span class="number">3.1415926</span>&#125;; <span class="comment">// 圆周率</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculate_area</span><span class="params">(<span class="type">double</span> radius)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PI * <span class="built_in">pow</span>(radius, <span class="number">2</span>); <span class="comment">// pow()函数用于计算幂</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">circle_area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入圆的半径：&quot;</span>;</span><br><span class="line">    <span class="type">double</span> radius &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    cin &gt;&gt; radius;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的面积为：&quot;</span> &lt;&lt; <span class="built_in">calculate_area</span>(radius) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">circle_area</span>(); <span class="comment">// 调用计算圆的面积的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="1-2-函数原型-prototype"><a href="#1-2-函数原型-prototype" class="headerlink" title="1.2 函数原型(prototype)"></a>1.2 函数原型(prototype)</h2><p>&#x3D;&#x3D;编译器要求:使用函数前必须“见过”这个函数&#x3D;&#x3D;</p>
<p>先定义函数再调用</p>
<ul>
<li>适用于小型程序，不适用于大型项目</li>
</ul>
<p>使用函数原型</p>
<ul>
<li><p>告诉编译器函数定义必要的信息</p>
</li>
<li><p>也称为前向声明(forward declaration)</p>
</li>
<li><p>放在程序开始的部分</p>
</li>
<li><p>或者放在头文件(header files.h)中</p>
</li>
</ul>
<h2 id="1-3参数"><a href="#1-3参数" class="headerlink" title="1.3参数"></a>1.3参数</h2><ol>
<li>当我们传递数据给函数时，其实用的是值传递(pass by value)</li>
<li>数据的拷贝会传给函数</li>
<li>函数内部的代码不会改变我们传给它的变量</li>
</ol>
<p>形参(formal parameters)与实参(actual parameters)<br>形参(formal parameters)</p>
<ul>
<li>函数定义语句中的参数</li>
</ul>
<p>实参(actual parameters</p>
<ul>
<li>调用函数时传递的参数(arguments)</li>
</ul>
<h2 id="1-4-重载"><a href="#1-4-重载" class="headerlink" title="1.4 重载"></a>1.4 重载</h2><p>一组函数具有相同函数名，不同参数列表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数原型，函数重载</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_numbers</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>; <span class="comment">// 两个 int 类型数字相加</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add_numbers</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>; <span class="comment">// 两个 double 类型数字相加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_numbers</span>(<span class="number">5</span>, <span class="number">10</span>) &lt;&lt; endl; <span class="comment">// int 类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_numbers</span>(<span class="number">1.23</span>, <span class="number">2.45</span>) &lt;&lt; endl; <span class="comment">// double 类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_numbers</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add_numbers</span><span class="params">(<span class="type">double</span> num1, <span class="type">double</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-5-函数传参-数组、引用"><a href="#1-5-函数传参-数组、引用" class="headerlink" title="1.5 函数传参(数组、引用)"></a>1.5 函数传参(数组、引用)</h2><ul>
<li><p>数组元素并没有复制</p>
</li>
<li><p>数组变量名称表示第一个元素在内存中的地址这个地址才被复制了</p>
</li>
<li><p>函数内部无法知道数组大小(数组大小需要额外传参)</p>
<p>·声明参数numbers是常量(只读read-only)</p>
</li>
</ul>
<p>		</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_array</span> <span class="params">(<span class="type">const</span> <span class="type">int</span> numbers[ ], <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_num</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换两个数字</span></span><br><span class="line">    <span class="type">int</span> x &#123;<span class="number">100</span>&#125;, y &#123;<span class="number">200</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y is: &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 100 200</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap_num</span>(x, y);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y is: &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 200 100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的是取地址，上面的函数和下面这个函数的作用相同：</p>
<p>传递地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_num</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换两个数字</span></span><br><span class="line">    <span class="type">int</span> x &#123;<span class="number">100</span>&#125;, y &#123;<span class="number">200</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y is: &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 100 200</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap_num</span>(&amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y is: &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 200 100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&#x3D;&#x3D;注意&#x3D;&#x3D;</p>
<p><code>int&amp;</code> 是 C++ 中的引用类型，它是一种特殊的类型，用于给一个已存在的变量起一个别名。可以将其理解为变量的一个别名或者另一个名称，与原变量共享同一块内存空间。</p>
<p>引用类型与指针类型有所不同。引用在声明时必须初始化，并且一旦初始化后，它就一直引用同一个对象，不能再引用其他对象。而指针可以在声明后重新指向不同的对象。</p>
<p>使用引用类型的主要目的是提供一种更简洁、更直观的方式来操作变量，同时避免了指针操作的一些繁琐性和潜在的错误。</p>
<p>在上述修正后的代码中，<code>int&amp;</code> 用于函数参数的声明，表示传递的参数是一个整数的引用。通过引用参数，可以直接修改原变量的值，而无需通过指针进行解引用。在函数内部，通过引用操作修改了 <code>a</code> 和 <code>b</code> 所指向的变量的值。</p>
<p>其实也就相当于传地址</p>
<h1 id="2-掌握C-指针基本概念、用法"><a href="#2-掌握C-指针基本概念、用法" class="headerlink" title="2.掌握C++指针基本概念、用法"></a>2.掌握C++指针基本概念、用法</h1><h2 id="2-1-什么是指针"><a href="#2-1-什么是指针" class="headerlink" title="2.1 什么是指针"></a>2.1 什么是指针</h2><p>指针是变量<br>变量的值是一个地址<br>指针的值可以存储哪些地址?</p>
<p>另一个变量</p>
<p>函数</p>
<hr>
<p>如果指针指向变量或函数，那么为什么不直接用他们?</p>
<p>可以，但不常用:</p>
<ul>
<li><p>函数内部，指针可以访问函数作用域外的数据</p>
</li>
<li><p>高效操作数组</p>
</li>
<li><p>在堆(heap)上动态分配内存空间</p>
<p>​      这些空间没有变量名称只能通过指针访问</p>
</li>
<li><p>可以获取内存中特殊地址</p>
</li>
</ul>
<p>​              如嵌入式系统、设备驱动等</p>
<hr>
<ul>
<li>&amp;地址操作符</li>
<li>指针也是一个变量(variable)，所以它的值可以改变</li>
<li>指针可以为null</li>
<li>指针可以不初始化</li>
</ul>
<h2 id="2-2-动态内存分配-dynami-allocation"><a href="#2-2-动态内存分配-dynami-allocation" class="headerlink" title="2.2 动态内存分配(dynami allocation)"></a>2.2 动态内存分配(dynami allocation)</h2><p>在堆(heap)上程序员自己分配内存空间;<br>数组(array)</p>
<ul>
<li>使用数组需要知道数组大小，并且数组大小是固定的;</li>
<li>Vector容器大小可以动态调整</li>
</ul>
<p>使用指针获取堆上刚分配的内存空间</p>
<hr>
<p>使用new[]为数组分配内存空间</p>
<p>使用delete[]释放内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* array_ptr &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr_size &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;你需要多少个整数: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; arr_size;</span><br><span class="line"></span><br><span class="line">    array_ptr = <span class="keyword">new</span> <span class="type">int</span>[arr_size]; <span class="comment">// 在堆上分配内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] array_ptr; <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-指针和数组的关系"><a href="#2-3-指针和数组的关系" class="headerlink" title="2.3 指针和数组的关系"></a>2.3 指针和数组的关系</h2><ul>
<li>数组变量名称的值是数组第一个元素的地址;</li>
<li>指针变量的的值是一个地址;</li>
<li>如果指针指向的类型和数组元素的类型一致，那么指针和数组名称几乎是等价的</li>
</ul>
<h2 id="2-4-const和指针一一指针本身和被指向的对象都是常量"><a href="#2-4-const和指针一一指针本身和被指向的对象都是常量" class="headerlink" title="2.4 const和指针一一指针本身和被指向的对象都是常量"></a>2.4 const和指针一一指针本身和被指向的对象都是常量</h2><p>指针可以操作:地址及被指向的对象</p>
<ul>
<li>被指向的对象是常量(povinters to constants)</li>
<li>指针本身是常量(constant pointers)</li>
<li>指针本身和被指向的对象都是常量(constant pointers to constants)</li>
</ul>
<p>示例1</p>
<ul>
<li>被指向的对象是常量，不可以通过指针改动·</li>
<li>指针本身可以改变</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> high_temp &#123;<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="type">int</span> low_temp &#123;<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* temp_ptr &#123;&amp;high_temp&#125;; <span class="comment">// 被指向的数据是常量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// *temp_ptr = 100; // 错误，不能通过解引用修改常量的值</span></span><br><span class="line"></span><br><span class="line">    temp_ptr = &amp;low_temp; <span class="comment">// 正确，可以通过指针修改指向的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例2</p>
<ul>
<li>被指向的对象可以通过指针改动</li>
<li>指针本身不可以改变</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> high_temp &#123;<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="type">int</span> low_temp &#123;<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> temp_ptr &#123;&amp;high_temp&#125;; <span class="comment">// 指针本身是常量，指向 high_temp</span></span><br><span class="line"></span><br><span class="line">    *temp_ptr = <span class="number">100</span>; <span class="comment">// 正确，通过指针解引用修改值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// temp_ptr = &amp;low_temp; // 错误，不能修改指针的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>示例3 </p>
<ul>
<li>被指向的对象不可以改动</li>
<li>指针本身不可以改变</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> high_temp &#123;<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="type">int</span> low_temp &#123;<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> temp_ptr &#123;&amp;high_temp&#125;; <span class="comment">// 指针和被指向对象都是常量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// *temp_ptr = 100; // 错误，不能修改指针指向的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// temp_ptr = &amp;low_temp; // 错误，不能修改指针的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-函数返回指针"><a href="#2-5-函数返回指针" class="headerlink" title="2.5 函数返回指针"></a>2.5 函数返回指针</h2><p>函数可以返回指针:</p>
<p> *function( );</p>
<p>返回哪些指针:</p>
<ul>
<li>函数内部动态分配的内存空间传入的数据</li>
<li>不能返回函数内的局部变量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">create_array</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> initial_value = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* new_storage &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    new_storage = <span class="keyword">new</span> <span class="type">int</span>[size]; <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i&#123;<span class="number">0</span>&#125;; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 初始化值</span></span><br><span class="line">        *(new_storage + i) = initial_value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_storage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> size &#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* array_ptr = <span class="built_in">create_array</span>(size, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数组元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i&#123;<span class="number">0</span>&#125;; i &lt; size; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; *(array_ptr + i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] array_ptr; <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 进阶</title>
    <url>/2023/09/03/hexo-%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-文章的分类和标签"><a href="#1-文章的分类和标签" class="headerlink" title="1 文章的分类和标签"></a>1 文章的分类和标签</h1><p>分类的话就是在最上方的状态栏中加入	categories:  属性即可</p>
<p>标签的话就是在最上方的状态栏中加入	tags:  属性即可</p>
<h1 id="2图床搭建教程"><a href="#2图床搭建教程" class="headerlink" title="2图床搭建教程"></a>2图床搭建教程</h1><p>根据这个教程来即可</p>
<p><a href="https://eryinote.com/post/105">图床</a></p>
<p>踩坑 picgo这个软件双击并不是直接打开，而是到了右下角的小菜单。。。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/image-20230903113402329.png" alt="image-20230903113402329"></p>
<p>然后在typora软件中进行简单的设置即可。如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/image-20230903114440776.png" alt="image-20230903114440776"></p>
<p>至此就搞完了，其他目前也没啥需求，继续学习C++</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>c++基本语法</title>
    <url>/2023/09/02/c-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-C-程序结构"><a href="#1-C-程序结构" class="headerlink" title="1.C++程序结构"></a>1.C++程序结构</h1><h2 id="1-1-C-程序的基本组成部分"><a href="#1-1-C-程序的基本组成部分" class="headerlink" title="1.1 C++程序的基本组成部分"></a>1.1 C++程序的基本组成部分</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> favorites_num;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入0~10中你最喜欢的数字: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; favorites_num;</span><br><span class="line">    std::cout &lt;&lt; favorites_num &lt;&lt; <span class="string">&quot;也是我喜欢的数字！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标识符(identifiers)：</p>
<p>​	main favorites_num  cout cin</p>
<p>操作符(operators)：</p>
<p>​	&lt;&lt;    &gt;&gt; </p>
<p>标点(punctuation：</p>
<p>​	；}</p>
<h2 id="1-2-预处理指令-Preprocessor-Directives"><a href="#1-2-预处理指令-Preprocessor-Directives" class="headerlink" title="1.2 预处理指令(Preprocessor Directives)"></a>1.2 预处理指令(Preprocessor Directives)</h2><ul>
<li>它指示编译器在实际编译开始之前预处理信息·以#开头，不以分号(;)结尾</li>
<li>并不理解C++语法</li>
</ul>
<h2 id="1-3-注释"><a href="#1-3-注释" class="headerlink" title="1.3 注释"></a>1.3 注释</h2><p>​	跟C相同，双斜杠的单行注释和、&#x2F;**&#x2F;多行注释</p>
<h2 id="1-4-main函数"><a href="#1-4-main函数" class="headerlink" title="1.4 main函数"></a>1.4 main函数</h2><p>​	例程1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>#include &lt;iostream&gt;</code>：这是一个预处理指令，用于包含输入输出流库（iostream），以便在程序中使用输入输出功能。</li>
<li><code>using namespace std;</code>：这是一个命名空间的声明，使用了<code>std</code>命名空间。命名空间<code>std</code>包含了C++标准库的函数和对象，使我们可以直接使用其中的成员，而无需在每个标识符前添加<code>std::</code>前缀。</li>
<li><code>int main()</code>：这是程序的主函数，也是程序的入口点。在C++中，每个程序都必须有一个<code>main</code>函数作为程序的起点。</li>
<li><code>&#123;</code> 和 <code>&#125;</code>：这对花括号之间的代码块是<code>main</code>函数的主体，包含了程序要执行的代码。</li>
<li><code>cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;</code>：这是一个输出语句，使用了<code>cout</code>对象，它是标准输出流。<code>&lt;&lt;</code>是输出运算符，用于将字符串常量”hello world”输出到控制台。<code>endl</code>是一个特殊的输出控制符，表示换行。</li>
</ol>
<p>例程2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//argc表示参数数量，argc表示输入的参数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;参数数量&quot;</span> &lt;&lt; argc &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;参数名称&quot;</span> &lt;&lt; argv &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	 </p>
<h2 id="1-5-命名空间namespace"><a href="#1-5-命名空间namespace" class="headerlink" title="1.5 命名空间namespace"></a>1.5 命名空间namespace</h2><p>在C++中，命名空间是一种用来组织程序中的标识符（例如变量名、函数名、类名等）的机制。命名空间可以避免标识符之间的名称冲突，使得不同库、模块或代码段中的标识符可以拥有相同的名称而不会发生冲突。</p>
<p><code>std</code> 是C++标准库中的命名空间，包含了大量的标准函数和类型定义。例如，<code>std::cout</code> 是用于标准输出的对象，<code>std::cin</code> 是用于标准输入的对象，<code>std::string</code> 是用于处理字符串的类，<code>std::vector</code> 是用于动态数组的类等等。这些标准库的功能都封装在 <code>std</code> 命名空间中。</p>
<p>使用 <code>using namespace std;</code> 声明后，就可以在代码中直接使用 <code>std</code> 命名空间中的成员，而无需在每个标识符前添加 <code>std::</code> 前缀。例如，可以直接使用 <code>cout</code> 来表示 <code>std::cout</code>，使用 <code>endl</code> 来表示 <code>std::endl</code>，以及使用 <code>string</code> 来表示 <code>std::string</code> 等等。</p>
<p>需要注意的是，尽管 <code>using namespace std;</code> 可以简化代码，但也可能引发命名冲突问题。如果程序中使用了不同命名空间中具有相同名称的标识符，可能会导致编译错误或意想不到的行为。因此，在大型项目中或与其他库进行交互时，最好明确指定使用的命名空间，而不是使用 <code>using namespace</code> 全局声明。</p>
<h1 id="2-C-变量和常量"><a href="#2-C-变量和常量" class="headerlink" title="2. C++变量和常量"></a>2. C++变量和常量</h1><h2 id="2-1-变量-variable"><a href="#2-1-变量-variable" class="headerlink" title="2.1 变量(variable)"></a>2.1 变量(variable)</h2><p>变量是内存地址的抽象变量有2个重要的属性:<br>Type:变量类型( integer、real nurber、string、Student)<br>Value:变量值(1,3.14,”computer”)</p>
<h2 id="2-2-基本类型-primitive-types"><a href="#2-2-基本类型-primitive-types" class="headerlink" title="2.2 基本类型(primitive types)"></a>2.2 基本类型(primitive types)</h2><p>示例3：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;参数a=&quot;</span> &lt;&lt; a &lt;&lt; endl;	  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	上述示例运行打印为 a&#x3D;0，最好设置初值</p>
<p>示例4：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> width = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入房间宽度&quot;</span>;	  </span><br><span class="line">    cin &gt;&gt; width;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入房间长度&quot;</span>;	  </span><br><span class="line">    cin &gt;&gt; length;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;房间的面积为&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; width * length &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符型-character-char"><a href="#字符型-character-char" class="headerlink" title="字符型(character) : char"></a>字符型(character) : char</h3><p>作用︰用于表示单个字符，如I@’,’a’,’X’<br>只占用1个字节<br>语法:char c &#x3D;(a;<br>&#x3D;&#x3D;注意&#x3D;&#x3D;:<br>需要和字符串区分开，用单引号不是双引号<br>存储的是字符的ASCIl编码，而不是字符本身</p>
<h3 id="整型-integer-short、int、long、long-long"><a href="#整型-integer-short、int、long、long-long" class="headerlink" title="整型(integer) : short、int、long、long long"></a>整型(integer) : short、int、long、long long</h3><h3 id="浮点型-floating-point-float、double"><a href="#浮点型-floating-point-float、double" class="headerlink" title="浮点型(floating point) : float、double"></a>浮点型(floating point) : float、double</h3><h3 id="布尔型-Boolean-bool"><a href="#布尔型-Boolean-bool" class="headerlink" title="布尔型(Boolean) : bool"></a>布尔型(Boolean) : bool</h3><p>示例5</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a = &#123;<span class="string">&#x27;j&#x27;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符型参数a的值=&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符型参数a的ascll=&quot;</span> &lt;&lt; <span class="built_in">int</span>(a) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// short取值范围和溢出</span></span><br><span class="line">    <span class="type">short</span> overflow_num_1 = <span class="number">32768</span>;    <span class="comment">// 不会报错，但是值会溢出</span></span><br><span class="line">    <span class="type">short</span> overflow_num_2 &#123;<span class="number">32768</span>&#125;;    <span class="comment">// 会报错</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;短整型溢出：&quot;</span> &lt;&lt; overflow_num_1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;短整型溢出：&quot;</span> &lt;&lt; overflow_num_2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	&#x3D;&#x3D;注意&#x3D;&#x3D;:一般人们都是使用等于号进行赋值，但是对于一些超出范围的情况，编译器并不会报错，但是使用{}花括号的情况就会报错，所以建议大家之后使用花括号进行赋值.</p>
<h2 id="2-3-sizeof和climits"><a href="#2-3-sizeof和climits" class="headerlink" title="2.3 sizeof和climits"></a>2.3 sizeof和climits</h2><p>sizeof(int), &#x2F;&#x2F;确定int占用空间<br>sizeof(double), &#x2F;&#x2F;确定double占用空间<br>sizeof(变量名), &#x2F;&#x2F;确定具体某个变量占用空间<br>sizeof 变量名, &#x2F;&#x2F;不用括号</p>
<p>示例6：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a = &#123;<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符型变量a的大小为&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;整形变量b的大小为&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-4-常量-constant"><a href="#2-4-常量-constant" class="headerlink" title="2.4 常量(constant)"></a>2.4 常量(constant)</h2><p>作用:记录不可更改的数据，防止变量误修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预处理器定义</span></span><br><span class="line"><span class="comment">// 在老版本的C++中常用，现在不建议使用（预处理器不认识C++代码，不会做类型检查等工作)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pi 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const修饰方法</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> months = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pi = 3.5; 常量不可以再变更值，否则编译器会报错</span></span><br></pre></td></tr></table></figure>

<p>示例7：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> PI &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length &#123;<span class="number">10</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的面积为&quot;</span> &lt;&lt; length * length * PI &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-C-数组和容器"><a href="#3-C-数组和容器" class="headerlink" title="3. C++数组和容器"></a>3. C++数组和容器</h1><h2 id="3-1-数组"><a href="#3-1-数组" class="headerlink" title="3.1 数组"></a>3.1 数组</h2><p>·数组所有元素都是同一个数据类型。每个元素可以单独读取。</p>
<p>数组的特点：</p>
<ul>
<li>长度大小固定，且不可以再修改</li>
<li>所有元素是同一类型</li>
<li>元素在内存中是连续存储的</li>
<li>声明array时，内存中会分配一块区域来存储</li>
<li>可以使用存储的索引位置来获取元素（从0开始，最后一个元素索引为size -1)</li>
<li>不检查是否超出区域（超出长度获取元素可能会报错)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int student_scores[5] = &#123;92, 78, 100, 86, 65&#125;;  // 所有元素初始化</span><br><span class="line">int ages[10] = &#123;19, 23&#125;;                      // 前两个元素初始化对应值，其他元素为0</span><br><span class="line">const int days_in_year = 365;</span><br><span class="line">double hi_temperatures[days_in_year] = &#123;0&#125;;   // 所有元素初始化为0</span><br><span class="line">int another_array[] = &#123;1, 2, 3, 4, 5, 6&#125;;      // 数组大小自动计算</span><br></pre></td></tr></table></figure>

<p>​	数组如果只是定义，他是没有初值的最好在创建的过程中就加入初值。、只有加入一个初值，其他没赋予的值也会有，只是为0 </p>
<p>示例8：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> a[] &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[] &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a数组的第五个值为&quot;</span> &lt;&lt; a[<span class="number">4</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b数组名打印&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-容器"><a href="#3-2-容器" class="headerlink" title="3.2 容器"></a>3.2 容器</h2><p>假设需要存储整个学校所有学生的考试成绩无法知道具体的学生数量<br>解决办法:</p>
<ul>
<li><p>使用数组，数组大小设置的足够大</p>
</li>
<li><p>使用vector动态数组</p>
</li>
</ul>
<p>&#x3D;&#x3D;容器的特点&#x3D;&#x3D;：</p>
<ul>
<li><p>C++标准模板库STL中的容器(container)</p>
</li>
<li><p>长度大小可以随时缩放</p>
</li>
<li><p>和数组类似的语法用法</p>
</li>
<li><p>高性能越界检查</p>
</li>
<li><p>很多有用的函数:sort, reverrse, find等</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">vowels</span><span class="params">(<span class="number">5</span>)</span></span>;             <span class="comment">// 构造函数初始化方法，需要五个位置</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">student_scores</span><span class="params">(<span class="number">10</span>)</span></span>;     <span class="comment">// 大小为10，这10个数字会自动初始化为0</span></span><br></pre></td></tr></table></figure>

<p>赋予初值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">char</span>&gt; vowels &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; student_scores &#123;<span class="number">100</span>, <span class="number">99</span>, <span class="number">98</span>, <span class="number">97</span>, <span class="number">96</span>&#125;;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">hi_temperatures</span><span class="params">(<span class="number">365</span>, <span class="number">37.0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​	这里有些区别，第一个使用的是花括号进行的初值赋予，第二个跟第一个相同，但是第三个使用的是圆括号来进行的，第一个参数为365表示将会有365个元素，第二个参数为初始值，表示这365个元素都会被初始化为37.0</p>
<p>​	.at获取</p>
<p>​	.pushback进行追加</p>
<p>示例 9：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; vowel &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; vowel.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt;endl;</span><br><span class="line">    vowel.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; vowel.<span class="built_in">at</span>(<span class="number">5</span>) &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	需要注意的是上面的vector和&lt;类型&gt;必须连在一起，否则会报错。</p>
<p>​	容器的获取方式跟数组的获取方式相同，但也可以有更多的方式</p>
<h1 id="4-C-程序流程"><a href="#4-C-程序流程" class="headerlink" title="4. C++程序流程"></a>4. C++程序流程</h1><h2 id="4-1-if"><a href="#4-1-if" class="headerlink" title="4.1 if"></a>4.1 if</h2><p>示例 10：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lower_limit &#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> upper_limit &#123;<span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> input_num;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入一个介于&quot;</span> &lt;&lt; lower_limit &lt;&lt; <span class="string">&quot;和&quot;</span> &lt;&lt; upper_limit &lt;&lt; <span class="string">&quot;之间的整数：&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cin &gt;&gt; input_num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (input_num &gt;= lower_limit) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;===条件一满足===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; input_num &lt;&lt; <span class="string">&quot;大于等于&quot;</span> &lt;&lt; lower_limit &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; input_num &lt;&lt; <span class="string">&quot;比&quot;</span> &lt;&lt; lower_limit &lt;&lt; <span class="string">&quot;大&quot;</span> &lt;&lt; (input_num - lower_limit) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (input_num &lt;= upper_limit) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;===条件二满足===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; input_num &lt;&lt; <span class="string">&quot;小于等于&quot;</span> &lt;&lt; upper_limit &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; input_num &lt;&lt; <span class="string">&quot;比&quot;</span> &lt;&lt; upper_limit &lt;&lt; <span class="string">&quot;小&quot;</span> &lt;&lt; (upper_limit - input_num) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (input_num &gt; lower_limit &amp;&amp; input_num &lt; upper_limit) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;===条件三满足===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; input_num &lt;&lt; <span class="string">&quot;介于&quot;</span> &lt;&lt; lower_limit &lt;&lt; <span class="string">&quot;和&quot;</span> &lt;&lt; upper_limit &lt;&lt; <span class="string">&quot;之间&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-switch"><a href="#4-2-switch" class="headerlink" title="4.2 switch"></a>4.2 switch</h2><p>示例 11：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char input_grade = &#x27;0&#x27;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;请输入你的成绩：&quot;;</span><br><span class="line">    std::cin &gt;&gt; input_grade;</span><br><span class="line"></span><br><span class="line">    switch (input_grade)</span><br><span class="line">    &#123;</span><br><span class="line">        case &#x27;a&#x27;:</span><br><span class="line">        case &#x27;A&#x27;:</span><br><span class="line">            std::cout &lt;&lt; &quot;优秀&quot; &lt;&lt; std::endl;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;b&#x27;:</span><br><span class="line">        case &#x27;B&#x27;:</span><br><span class="line">            std::cout &lt;&lt; &quot;良好&quot; &lt;&lt; std::endl;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;c&#x27;:</span><br><span class="line">        case &#x27;C&#x27;:</span><br><span class="line">            std::cout &lt;&lt; &quot;中等&quot; &lt;&lt; std::endl;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-3循环-for、while、do-while"><a href="#4-3循环-for、while、do-while" class="headerlink" title="4.3循环: for、while、do-while"></a>4.3循环: for、while、do-while</h2><p>示例 11：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 简单的 for 循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次 i 增加 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面这种最简单的方式，for也支持基于范围的循环，类似于python：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> scores [ ] &#123;<span class="number">100</span>,<span class="number">99</span>,<span class="number">98</span>&#125; ;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> score: scores)</span><br><span class="line">	cout&lt;&lt; score &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>有时确定范围比较困难，所以可以使用auto这个类型，可以帮我们自动确认类型</p>
<p>while和do while就不重复了，还是很简单的</p>
<h1 id="5-C-字符和字符串"><a href="#5-C-字符和字符串" class="headerlink" title="5. C++字符和字符串"></a>5. C++字符和字符串</h1><h2 id="5-1C风格字符串"><a href="#5-1C风格字符串" class="headerlink" title="5.1C风格字符串"></a>5.1C风格字符串</h2><p>示例 12：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> first_name[<span class="number">20</span>] &#123;&#125;;</span><br><span class="line">    <span class="type">char</span> last_name[<span class="number">20</span>] &#123;&#125;;</span><br><span class="line">    <span class="type">char</span> full_name[<span class="number">50</span>] &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">50</span>] &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入你的姓：&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; first_name;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入你的名：&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; last_name;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;===============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;您的姓：&quot;</span> &lt;&lt; first_name &lt;&lt; <span class="string">&quot;，一共有&quot;</span> &lt;&lt; <span class="built_in">strlen</span>(first_name) &lt;&lt; <span class="string">&quot;个字符&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;您的名：&quot;</span> &lt;&lt; last_name &lt;&lt; <span class="string">&quot;，一共有&quot;</span> &lt;&lt; <span class="built_in">strlen</span>(last_name) &lt;&lt; <span class="string">&quot;个字符&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-2-C-风格字符串"><a href="#5-2-C-风格字符串" class="headerlink" title="5.2 C++风格字符串"></a>5.2 C++风格字符串</h2><ul>
<li><p>STL中一个类</p>
</li>
<li><p>使用前必须要导入#include <string></p>
</li>
<li><p>std namespace</p>
</li>
<li><p>内存中连续，动态大小</p>
</li>
<li><p>可转c-style字符串相互转化</p>
</li>
<li><p>更安全</p>
<p>示例 13：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string sl; <span class="comment">// 全部初始化为空</span></span><br><span class="line">    std::string s2 &#123; <span class="string">&quot;hello&quot;</span> &#125;; <span class="comment">// 初始化为 &quot;hello&quot;</span></span><br><span class="line">    std::string s3 &#123; s2 &#125;; <span class="comment">// 拷贝 s2</span></span><br><span class="line">    std::string s4 &#123; s3, <span class="number">0</span>, <span class="number">4</span> &#125;; <span class="comment">// 拷贝 s3 的前4个字符：&quot;hell&quot;</span></span><br><span class="line">    std::string s5 &#123; <span class="string">&quot;hello&quot;</span>, <span class="number">3</span> &#125;; <span class="comment">// 拷贝 &quot;hello&quot; 的前3个字符：&quot;hel&quot;</span></span><br><span class="line">    <span class="function">std::string <span class="title">s6</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>; <span class="comment">// 5个 &#x27;x&#x27;：&quot;xxxxx&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	c++字符串可以直接赋值，根据他的参数的数量可以划分不同的重定向函数</p>
<p>拼接</p>
<p>示例 14：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string part1 &#123; <span class="string">&quot;C++&quot;</span> &#125;;</span><br><span class="line">    std::string part2 &#123; <span class="string">&quot;是一门强大的&quot;</span> &#125;;</span><br><span class="line">    std::string sentence;</span><br><span class="line"></span><br><span class="line">    sentence = part1 + <span class="string">&quot; &quot;</span> + part2 + <span class="string">&quot;语言&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; sentence &lt;&lt; std::endl; <span class="comment">// 输出: C++ 是一门强大的语言</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sentence = &quot;C+++&quot; 是一门强大的语言&quot;; // 错误，不能将两个C风格字符串字面量相加</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo基本操作命令</title>
    <url>/2023/09/02/hexo%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://so.csdn.net/so/search?q=Hexo&spm=1001.2101.3001.7020">Hexo</a> 约有二十个命令，但普通用户经常使用的大概只有下列几个:</p>
<h2 id="hexo-s"><a href="#hexo-s" class="headerlink" title="hexo s"></a><strong>hexo s</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>启动本地服务器，用于预览主题。默认地址： <a href="http://localhost:4000/">http://localhost:4000/</a></p>
<ul>
<li>hexo s 是 hexo server 的缩写，命令效果一致；</li>
<li>预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；</li>
<li>对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果。</li>
</ul>
<h2 id="hexo-new"><a href="#hexo-new" class="headerlink" title="hexo new"></a><strong>hexo new</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;学习笔记  六&quot;</span><br></pre></td></tr></table></figure>

<p>新建一篇标题为 学习笔记 六 的文章，因为标题里有空格，所以加上了引号。</p>
<ul>
<li>文章标题可以在对应 md 文件里改，新建时标题可以写的简单些。</li>
</ul>
<h2 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a><strong>hexo d</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>自动生成网站静态文件，并部署到设定的仓库。</p>
<ul>
<li>hexo d 是 hexo deploy 的缩写，命令效果一致。</li>
</ul>
<h2 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a><strong>hexo clean</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p>清除缓存文件 db.json 和已生成的静态文件 public 。</p>
<ul>
<li>网站显示异常时可以执行这条命令试试。</li>
</ul>
<h2 id="hexo-g"><a href="#hexo-g" class="headerlink" title="hexo g"></a><strong>hexo g</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>生成网站静态文件到默认设置的 public 文件夹。</p>
<ul>
<li>便于查看网站生成的静态文件或者手动部署网站；</li>
<li>如果使用自动部署，不需要先执行该命令；</li>
<li>hexo g 是 hexo generate 的缩写，命令效果一致。</li>
</ul>
<h2 id="hexo-new-page"><a href="#hexo-new-page" class="headerlink" title="hexo new page"></a><strong>hexo new page</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page aboutme</span><br></pre></td></tr></table></figure>

<p>新建一个标题为 aboutme 的页面，默认链接地址为 主页地址&#x2F;aboutme&#x2F;</p>
<ul>
<li>标题可以为中文，但一般习惯用英文；</li>
<li>页面标题和文章一样可以随意修改；</li>
<li>页面不会出现在首页文章列表和归档中，也不支持设置分类和标签。</li>
</ul>
<p>hexo n “我的博客” 等价于 hexo new “我的博客” 还等价于 hexo new post “我的博客” #新建一篇文章<br>hexo p 等价于 hexo publish<br>hexo g 等价于 hexo generate<br>hexo s等价于 hexo server<br>hexo d 等价于 hexo deploy<br>hexo deploy -g 等价于 hexo deploy –generate<br>hexo generate -d等价于hexo generate –deploy</p>
<p>一般只需要四个命令，</p>
<p>hexo n 创建一个新的博客</p>
<p>hexo s 开启一个新的服务</p>
<p>hexo g 生成一个静态的网页</p>
<p>hexo d 将生成的静态网页推到服务器github</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>ayer 主题熟悉</title>
    <url>/2023/09/02/ayer-%E4%B8%BB%E9%A2%98%E7%86%9F%E6%82%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-整体介绍"><a href="#1-整体介绍" class="headerlink" title="1 整体介绍"></a>1 整体介绍</h1><p><a href="https://github.com/Shen-Yu/hexo-theme-ayer">Ayer</a> 是一个干净且优雅的 Hexo 主题，自带响应式，加载速度很快，该有的功能都有，可配置项很多，非常适合作为你的博客主题，主题内还附送了 6 张精美的高清壁纸。欢迎使用和 Star 支持，如果你在使用过程中有任何疑问或者建议，欢迎联系我！如果你的博客采用了本主题，欢迎在下面评论区留下地址~</p>
<p><a href="https://github.com/Shen-Yu/hexo-theme-ayer">Ayer</a> 在马来语中是“水”的意思，在西班牙语中是“昨天”的意思。</p>
<h1 id="2-特性"><a href="#2-特性" class="headerlink" title="2. 特性"></a>2. 特性</h1><ol>
<li>干净且优雅，文章内容美观易读</li>
<li>首页封面全屏平铺，扁平化设计，简洁又不失高大上</li>
<li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li>
<li>首页封面和文案可以任意更换，主题内附送 6 张精美高清壁纸</li>
<li>时间轴式的归档页</li>
<li>支持 <code>黑夜阅读</code> 模式</li>
<li>侧边栏可以点击显示或隐藏</li>
<li>支持文章置顶和文章打赏</li>
<li>支持文章字数和阅读时长统计</li>
<li>支持网易云音乐播放</li>
<li>支持  <code>MathJax</code> 和 <code>Katex</code> 数学公式</li>
<li>支持 <code>Mermaid</code> 流程图、状态图、时序图、甘特图</li>
<li><code>TOC</code> 目录在文章页悬浮，跳转更方便</li>
<li>集成了博客加密访问的功能</li>
<li>可设置阅读文章时做密码验证<a href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md">hexo-blog-encrypt</a></li>
<li><a href="https://valine.js.org/">Valine</a>和<a href="https://gitalk.github.io/">Gitalk</a>评论模块（推荐配合<code>leancloud</code>使用  <code>Valine</code>）</li>
<li>集成了<a href="http://busuanzi.ibruce.info/">不蒜子</a>、百度统计、Google Analytics、CNZZ 等统计功能</li>
<li>支持 Github Ribbons</li>
</ol>
<h1 id="3-主题配置"><a href="#3-主题配置" class="headerlink" title="3.主题配置"></a>3.主题配置</h1><p>以下是 ayer 主题目录下的 <code>_config.yml</code> 文件配置，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 侧边栏菜单</span><br><span class="line">menu:</span><br><span class="line">  主页: /</span><br><span class="line">  归档: /archives</span><br><span class="line">  分类: /categories</span><br><span class="line">  标签: /tags</span><br><span class="line">  摄影: http://shenyu-vip.lofter.com</span><br><span class="line">  旅行: /tags/旅行/</span><br><span class="line">  关于我: /2019/about</span><br><span class="line"></span><br><span class="line"># 站点次标题和打字动效</span><br><span class="line"># https://github.com/mattboldt/typed.js</span><br><span class="line">subtitle:</span><br><span class="line">  enable: true # 是否开启动效</span><br><span class="line">  text: 面朝大海，春暖花开 # 显示的文字</span><br><span class="line">  text2: 愿你一生努力，一生被爱 # 滚动播放，如果不需要可以留空</span><br><span class="line">  text3: 想要的都拥有，得不到的都释怀 # 最多支持三段文字</span><br><span class="line">  startDelay: 0 # 延迟时间</span><br><span class="line">  typeSpeed: 200 # 打字速度</span><br><span class="line">  loop: true # 是否循环</span><br><span class="line">  backSpeed: 100 # 回退速度</span><br><span class="line">  showCursor: true # 是否显示光标</span><br><span class="line"></span><br><span class="line"># 网站图标和侧边栏logo</span><br><span class="line">favicon: /favicon.ico</span><br><span class="line">logo: /images/ayer-side.svg</span><br><span class="line"></span><br><span class="line"># 封面配置</span><br><span class="line"># enable-是否启用封面；path-封面背景图；logo-封面logo</span><br><span class="line">cover:</span><br><span class="line">  enable: true</span><br><span class="line">  path: /images/cover1.jpg # /source/images目录下附送多张精美壁纸，可任意更换</span><br><span class="line">  logo: /images/ayer.svg # 如果不要直接设置成false</span><br><span class="line"></span><br><span class="line"># 页面顶部进度条</span><br><span class="line">progressBar: true</span><br><span class="line"></span><br><span class="line"># 告示板模块</span><br><span class="line">broadcast:</span><br><span class="line">  enable: true # true开启，false关闭</span><br><span class="line">  type: 2 # 1：自定义输入，2：一言api(https://hitokoto.cn/)</span><br><span class="line">  text: 一个安静优雅的hexo主题，快速且响应式。 # type为1时有效</span><br><span class="line"></span><br><span class="line"># 文章配置</span><br><span class="line"># 文章太长，截断按钮文字(在需要截断的行增加此标记：&lt;!--more--&gt;)</span><br><span class="line">excerpt_link: 阅读更多...</span><br><span class="line"># 如果你嫌每篇文章手动加more标记比较麻烦，又不想在首页全文显示，可以把excerpt_all设置成true，这样首页只会显示文章归档</span><br><span class="line">excerpt_all: false</span><br><span class="line"></span><br><span class="line"># 是否开启代码复制按钮</span><br><span class="line">copy_btn: true</span><br><span class="line"># 是否开启文章分享按钮</span><br><span class="line">share_enable: true</span><br><span class="line"># 国内的社交平台(If you are not in China, maybe you prefer to set:false)</span><br><span class="line">share_china: true</span><br><span class="line"># 文章分享文字</span><br><span class="line">share_text: 分享</span><br><span class="line"></span><br><span class="line"># 分页文字</span><br><span class="line">nav_text:</span><br><span class="line">  page_prev: 上一页</span><br><span class="line">  page_next: 下一页</span><br><span class="line">  post_prev: 上一篇</span><br><span class="line">  post_next: 下一篇</span><br><span class="line"></span><br><span class="line"># 文章页是否显示目录</span><br><span class="line">toc: true</span><br><span class="line"></span><br><span class="line"># 文章中的图片是否支持点击放大</span><br><span class="line">image_viewer: true</span><br><span class="line"></span><br><span class="line"># https://github.com/willin/hexo-wordcount</span><br><span class="line"># 是否开启字数统计(关闭请设置enable为false)</span><br><span class="line"># 也可以单独在md文件里Front-matter设置`no_word_count: true`属性，来自定义关闭字数统计</span><br><span class="line">word_count:</span><br><span class="line">  enable: true</span><br><span class="line">  # 只在文章详情显示(不在首页显示)</span><br><span class="line">  only_article_visit: true</span><br><span class="line"></span><br><span class="line"># 打赏</span><br><span class="line"># 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-默认开启所有文章均有打赏，如果有些文章你不需要，请在文章对应的md文件里设置no_reward:true</span><br><span class="line">reward_type: 2</span><br><span class="line"># 打赏wording</span><br><span class="line">reward_wording: &quot;请我喝杯咖啡吧~&quot;</span><br><span class="line"># 支付宝二维码图片地址，跟你设置logo的方式一样。比如：/images/alipay.jpg</span><br><span class="line">alipay: /images/alipay.jpg</span><br><span class="line"># 微信二维码图片地址</span><br><span class="line">weixin: /images/wechat.jpg</span><br><span class="line"></span><br><span class="line"># 版权声明</span><br><span class="line"># 版权声明type设定：0-关闭版权声明； 1-文章对应的md文件里有copyright: true属性，才有版权声明； 2-所有文章均有版权声明</span><br><span class="line">copyright_type: 2</span><br><span class="line"></span><br><span class="line"># 是否启用搜索</span><br><span class="line">search: true</span><br><span class="line"></span><br><span class="line"># RSS订阅(先安装hexo-generator-feed插件，再去博客根目录config进行配置)</span><br><span class="line"># 不想显示可以直接留空</span><br><span class="line">rss: /atom.xml</span><br><span class="line"></span><br><span class="line"># 是否启用黑夜模式开关</span><br><span class="line">darkmode: true</span><br><span class="line"></span><br><span class="line"># 动态背景效果: 0-关闭，1-动态线条(跟随鼠标)</span><br><span class="line">canvas_bg: 0</span><br><span class="line"></span><br><span class="line"># 自定义鼠标样式，直接替换/images/mouse.cur文件</span><br><span class="line">mouse:</span><br><span class="line">  enable: false</span><br><span class="line">  path: /images/mouse.cur</span><br><span class="line"></span><br><span class="line"># 鼠标点击效果：0-关闭，1-爱心，2-爆炸烟花，3-粒子烟花</span><br><span class="line">click_effect: 0</span><br><span class="line"></span><br><span class="line"># 页面宽度自定义（不建议修改，可能造成布局混乱），article_width文章宽度，sidebar_width侧边栏宽度</span><br><span class="line">layout:</span><br><span class="line">  article_width: 80rem</span><br><span class="line">  sidebar_width: 8rem</span><br><span class="line"></span><br><span class="line"># GitHub Ribbons-封面右上角的forkme，换样式直接在source/images目录下替换forkme图片</span><br><span class="line">github:</span><br><span class="line">  # (关闭请设置为false)</span><br><span class="line">  enable: true</span><br><span class="line">  url: https://github.com/Shen-Yu/hexo-theme-ayer</span><br><span class="line"></span><br><span class="line"># 网易云音乐插件</span><br><span class="line">music:</span><br><span class="line">  enable: false</span><br><span class="line">  # 播放器尺寸类型(1：小尺寸、2：大尺寸)</span><br><span class="line">  type: 1</span><br><span class="line">  id: 22707008 # 网易云分享的音乐ID(更换音乐请更改此配置项)</span><br><span class="line">  autoPlay: true # 是否开启自动播放</span><br><span class="line"></span><br><span class="line"># 访问量统计(不蒜子)</span><br><span class="line">busuanzi:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line"># 友盟cnzz统计(url填js代码src链接)</span><br><span class="line">cnzz:</span><br><span class="line">  enable: true</span><br><span class="line">  url: #</span><br><span class="line"></span><br><span class="line"># Google Analytics</span><br><span class="line">google_analytics: &quot;&quot;</span><br><span class="line"># 百度统计</span><br><span class="line">baidu_analytics: &quot;&quot;</span><br><span class="line"></span><br><span class="line"># Mathjax数学公式</span><br><span class="line">mathjax: true</span><br><span class="line"></span><br><span class="line"># Katex数学公式(allpost设置为false时只有头部设置math:true的文章才开启)</span><br><span class="line"># 需要更换hexo渲染器，npm un hexo-renderer-marked -S &amp;&amp; npm i hexo-renderer-markdown-it-katex -S</span><br><span class="line">katex:</span><br><span class="line">  enable: false # true</span><br><span class="line">  allpost: true</span><br><span class="line">  copy_tex: false</span><br><span class="line"></span><br><span class="line"># mermaid流程图 三个选项缺一不可(https://mermaid-js.github.io/mermaid/#/)</span><br><span class="line">mermaid:</span><br><span class="line">  enable: false</span><br><span class="line">  cdn: https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js</span><br><span class="line">  theme: forest</span><br><span class="line"></span><br><span class="line"># 网站成立年份(默认为 2019，若填入年份小于当前年份，则显示为 2018-2019 类似的格式)</span><br><span class="line">since: 2019</span><br><span class="line"></span><br><span class="line"># ICP备案信息尾部显示</span><br><span class="line">icp:</span><br><span class="line">  enable: false</span><br><span class="line">  url: &quot;http://www.beian.miit.gov.cn/&quot; # 备案链接</span><br><span class="line">  text: &quot;浙ICP备88888888&quot; # 备案信息</span><br><span class="line"># 公安备案信息尾部显示</span><br><span class="line">gongan:</span><br><span class="line">  enable: true</span><br><span class="line">  img: /images/beian.png #公安备案图片</span><br><span class="line">  url: &quot;http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=01234567890123&quot; #公安备案链接</span><br><span class="line">  text: &quot;浙公网安备01234567890123号&quot; #公安备案信息</span><br><span class="line"></span><br><span class="line"># 友情链接</span><br><span class="line">friends_link:</span><br><span class="line">  Ayer主题: #网站名称</span><br><span class="line">    #网站地址</span><br><span class="line">    url: https://github.com/Shen-Yu/hexo-theme-ayer</span><br><span class="line">    #网站图片(可忽略不写)</span><br><span class="line">    img: /images/ayer.png</span><br><span class="line">  GitHub:</span><br><span class="line">    url: https://github.com/Shen-Yu</span><br><span class="line">    img: https://i.loli.net/2020/09/07/indb4PRYDA98EkN.png</span><br><span class="line">  码云:</span><br><span class="line">    url: https://gitee.com/shen-yu</span><br><span class="line">    img: https://i.loli.net/2020/09/07/K3AqO7h6krQFlRX.png</span><br><span class="line">  Hexo官网:</span><br><span class="line">    url: https://hexo.io</span><br><span class="line">    img: https://i.loli.net/2020/09/07/UYGzjo7h68CRWny.png</span><br><span class="line">  Hexo图表插件:</span><br><span class="line">    url: https://github.com/Shen-Yu/hexo-tag-chart</span><br><span class="line">    img: https://i.loli.net/2020/09/07/GIXBYE5SoylhR1r.png</span><br><span class="line"></span><br><span class="line"># 评论：1、Valine(推荐)；2、Gitalk；3、Twikoo; 4.MiniValine</span><br><span class="line"></span><br><span class="line"># 1、Valine[一款快速、简洁且高效的无后端评论系统](https://github.com/xCss/Valine)</span><br><span class="line"># 启用Valine必须先创建leancloud应用， 获取 id|key 填入即可</span><br><span class="line">leancloud:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: #</span><br><span class="line">  app_key: #</span><br><span class="line"># Valine配置</span><br><span class="line">valine:</span><br><span class="line">  enable: true # 是否启用</span><br><span class="line">  avatar: monsterid # 头像样式(https://valine.js.org/avatar.html)</span><br><span class="line">  placeholder: 给我的文章加点评论吧~ # placeholder</span><br><span class="line"></span><br><span class="line"># 2、Gitalk(https://github.com/gitalk/gitalk)</span><br><span class="line">gitalk:</span><br><span class="line">  enable: false # true</span><br><span class="line">  clientID: # GitHub Application Client ID</span><br><span class="line">  clientSecret: # Client Secret</span><br><span class="line">  repo: # Repository name</span><br><span class="line">  owner: # GitHub ID</span><br><span class="line">  admin: # GitHub ID</span><br><span class="line"></span><br><span class="line"># 3、Twikoo(https://github.com/imaegoo/twikoo)</span><br><span class="line">twikoo:</span><br><span class="line">  enable: false</span><br><span class="line">  envId: #</span><br><span class="line"></span><br><span class="line"># 4、MiniValine</span><br><span class="line"># See: https://github.com/MiniValine/MiniValine</span><br><span class="line">minivaline:</span><br><span class="line">  enable: false</span><br><span class="line">  serverURL: https://minivaline.your-domain.com</span><br><span class="line"></span><br><span class="line"># 首页广告配置</span><br><span class="line"># 可以根据需要自行增加ad_3，ad_4...，留空则不显示</span><br><span class="line">ads:</span><br><span class="line">  ad_1:</span><br><span class="line">    title: vultr优惠vps</span><br><span class="line">    img: https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/vultr.png</span><br><span class="line">    url: https://www.vultr.com/?ref=8630075</span><br><span class="line">    width: 300</span><br><span class="line">  ad_2:</span><br><span class="line">    title: 云服务器全球购低至2折</span><br><span class="line">    img: https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/ad_2.jpg</span><br><span class="line">    url: https://curl.qcloud.com/kvO7hb43</span><br><span class="line">    width: 300</span><br><span class="line"></span><br><span class="line"># 网站开启加密访问，密码可设置任何字符</span><br><span class="line">lock:</span><br><span class="line">  enable: false</span><br><span class="line">  password: 123456</span><br></pre></td></tr></table></figure>

<h2 id="4-插件-可选"><a href="#4-插件-可选" class="headerlink" title="4 插件(可选)"></a>4 插件(可选)</h2><ul>
<li><a href="https://github.com/netcan/hexo-generator-index-pin-top">hexo-generator-index-pin-top</a> 用于文章置顶</li>
<li><a href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md">hexo-blog-encrypt</a> 用于文章加密</li>
<li><a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md">hexo-tag-aplayer</a> 用于播放音乐</li>
<li><a href="https://github.com/MoePlayer/hexo-tag-dplayer">hexo-tag-dplayer</a> 用于播放视频</li>
<li><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md">hexo-helper-live2d</a> 二次元看板娘</li>
</ul>
<h2 id="5-分类"><a href="#5-分类" class="headerlink" title="5.分类"></a>5.分类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>然后将以下复制到 &#x2F;source&#x2F;categories&#x2F;index.md 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="6-标签"><a href="#6-标签" class="headerlink" title="6.标签"></a>6.标签</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>配置同分类一样</p>
<h2 id="7-友情链接"><a href="#7-友情链接" class="headerlink" title="7. 友情链接"></a>7. 友情链接</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page friends</span><br></pre></td></tr></table></figure>

<p>然后将以下复制到 &#x2F;source&#x2F;friends&#x2F;index.md 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: friends</span><br><span class="line">type: friends</span><br><span class="line">layout: &quot;friends&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>然后在 ayer 主题目录下的 <code>_config.yml</code> 中自定义 <code>friends_link</code> 配置项即可</p>
<h2 id="8-相册"><a href="#8-相册" class="headerlink" title="8.相册"></a>8.相册</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page photos</span><br></pre></td></tr></table></figure>

<p>然后将以下复制到 &#x2F;source&#x2F;photos&#x2F;index.md 文件，<code>img_url</code> 替换成图片路径，<code>caption</code> 替换成图片名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Gallery</span><br><span class="line"></span><br><span class="line">albums: [[&quot;img_url&quot;, &quot;img_caption&quot;], [&quot;img_url&quot;, &quot;img_caption&quot;]]</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h2><p>用 Tocbot 解析文章标题并生成目录</p>
<ul>
<li>将以下配置复制到你 ayer 主题目录下的 <code>_config.yml</code> 里：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Toc</span><br><span class="line">toc: true</span><br></pre></td></tr></table></figure>

<ul>
<li>当然你可能并不想所有文章都生成悬浮目录，你可以在文章顶部的配置中加一行来进行关闭：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">no_toc: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ 环境搭建</title>
    <url>/2023/09/02/c-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-课程所需运行环境配置"><a href="#1-课程所需运行环境配置" class="headerlink" title="1 课程所需运行环境配置"></a>1 课程所需运行环境配置</h1><p>​		ubuntu + windows双系统 4070ti 13900K 32G </p>
<h1 id="2-VS-Code配置"><a href="#2-VS-Code配置" class="headerlink" title="2 VS Code配置"></a>2 VS Code配置</h1><h2 id="2-1-安装vscode"><a href="#2-1-安装vscode" class="headerlink" title="2.1 安装vscode"></a>2.1 安装vscode</h2><h2 id="2-2-安装插件"><a href="#2-2-安装插件" class="headerlink" title="2.2 安装插件"></a>2.2 安装插件</h2><ol>
<li>chinese</li>
<li>remote ssh</li>
<li>c++</li>
<li>python</li>
<li>tabnine  github.copilot</li>
<li>run</li>
<li>C&#x2F;C++ Extension Pack</li>
</ol>
<h1 id="3-下载MinGw编译器"><a href="#3-下载MinGw编译器" class="headerlink" title="3 下载MinGw编译器"></a>3 下载MinGw编译器</h1><p><a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/">MinGw官网</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/545908287">知乎配置教程</a></p>
<h2 id="4-配置C-C"><a href="#4-配置C-C" class="headerlink" title="4.配置C\C++"></a>4.配置C\C++</h2><p>重启vscode就好了</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown 语法学习</title>
    <url>/2023/09/02/markdown-%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第1节-标题"><a href="#第1节-标题" class="headerlink" title="第1节 标题"></a>第1节 标题</h1><p>markdown 里面总共有六级标题，可以使用#号的多少来来引用，现在使用的是typora也可以直接使用ctrl+1-6的快捷按键来进行设置</p>
<h1 id="第2节-列表"><a href="#第2节-列表" class="headerlink" title="第2节 列表"></a>第2节 列表</h1><h2 id="2-1-有序列表"><a href="#2-1-有序列表" class="headerlink" title="2.1 有序列表"></a>2.1 有序列表</h2><p>​	顾名思义，有序列表就是有小标号的列表，同样也是两种方式英⽂输⼊法下，数字后⾯加⼀点，然后空格即可，或者使用快捷按键ctrl + shift + [即可</p>
<p>1. </p>
<p>1. </p>
<h2 id="2-2-无序列表"><a href="#2-2-无序列表" class="headerlink" title="2.2 无序列表"></a>2.2 无序列表</h2><p>​	跟上面的有序列表相反，无序列表就是没有标号，有四种方法、</p>
<ul>
<li>aaa - aaa</li>
</ul>
<ul>
<li>aaa + aaa</li>
</ul>
<ul>
<li>aaa *aaa</li>
</ul>
<ul>
<li>aaa ctrl+shift+]</li>
</ul>
<h1 id="第3节-字体标记"><a href="#第3节-字体标记" class="headerlink" title="第3节 字体标记"></a>第3节 字体标记</h1><h2 id="3-1-加粗"><a href="#3-1-加粗" class="headerlink" title="3.1 加粗"></a>3.1 加粗</h2><p><strong>加粗</strong> **   内容**在typora中可以使用ctrl+b</p>
<h2 id="3-2-删除"><a href="#3-2-删除" class="headerlink" title="3.2 删除"></a>3.2 删除</h2><p><del>删除</del> ~~ 内容~~</p>
<h2 id="3-3-斜体"><a href="#3-3-斜体" class="headerlink" title="3.3 斜体"></a>3.3 斜体</h2><p><em>斜体</em> * 内容 *</p>
<h2 id="3-4-高亮"><a href="#3-4-高亮" class="headerlink" title="3.4 高亮"></a>3.4 高亮</h2><p>&#x3D;&#x3D;高亮&#x3D;&#x3D; &#x3D;&#x3D;内容  &#x3D;&#x3D;需要打开pytora的高亮功能之后才行</p>
<h1 id="第4节-段落相关"><a href="#第4节-段落相关" class="headerlink" title="第4节 段落相关"></a>第4节 段落相关</h1><h2 id="4-1-引用"><a href="#4-1-引用" class="headerlink" title="4.1 引用"></a>4.1 引用</h2><blockquote>
<p>这是一段引用 &gt; 大于号加内容引用</p>
</blockquote>
<h2 id="4-2-分割线"><a href="#4-2-分割线" class="headerlink" title="4.2 分割线"></a>4.2 分割线</h2><hr>
<p>三个横杠或者更多的横杠表示分割线</p>
<h1 id="第5节-代码"><a href="#第5节-代码" class="headerlink" title="第5节 代码"></a>第5节 代码</h1><h2 id="5-1-行内代码"><a href="#5-1-行内代码" class="headerlink" title="5.1 行内代码"></a>5.1 行内代码</h2><p><code>这是一个行内代码</code> 1旁边那个特殊按键</p>
<h2 id="5-2-代码块"><a href="#5-2-代码块" class="headerlink" title="5.2 代码块"></a>5.2 代码块</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    三个```然后回车即可，然后在右下角的选择框中进行代码的选择</span><br></pre></td></tr></table></figure>



<h1 id="第6节-超链接"><a href="#第6节-超链接" class="headerlink" title="第6节 超链接"></a>第6节 超链接</h1><blockquote>
<p>格式 ：[⽹址标题] [变量01]</p>
</blockquote>
<p><a href="www.baidu.com">百度</a></p>
<ul>
<li><p>在⽂稿起草阶段，还没确定具体⽹址，但可以先给出⽹址标题</p>
</li>
<li><p>同⼀篇⽂章需要重复出现同⼀个⽹址时</p>
</li>
</ul>
<h1 id="第7节-脚注"><a href="#第7节-脚注" class="headerlink" title="第7节 脚注"></a>第7节 脚注</h1><p>这是一个脚注<a href="%E8%BF%99%E4%B8%AA%E6%98%AF%E6%94%BE%E5%9C%A8%E6%96%87%E7%AB%A0%E5%B0%BE%E9%83%A8%E7%9A%84%EF%BC%8C%E7%94%A8%E4%BA%8E%E6%89%BF%E6%8E%A5%E4%B8%8A%E9%9D%A2%E7%9A%84%E8%84%9A%E6%B3%A8">^01</a></p>
<h1 id="第8节-图片"><a href="#第8节-图片" class="headerlink" title="第8节 图片"></a>第8节 图片</h1><p><img src="/"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本格式：![](图⽚链接)</span><br></pre></td></tr></table></figure>

<p><img src="D:\hexo\blog\source_posts\image-20230902075316489.png" alt="image-20230902075316489"></p>
<p>图⽚链接可以是本地链接，也可以是在线链接</p>
<p>但这个图片是本地路径，很有问题，所以你可能需要一个图床，用来无视地点，目前先不学呢，具体链接如下所示：</p>
<p><a href="https://eryinote.com/post/105">图床搭建教程</a></p>
<h1 id="第9节-表格"><a href="#第9节-表格" class="headerlink" title="第9节 表格"></a>第9节 表格</h1><p>在typora中可以使用快捷按键进行表格的创建  ctrl+t</p>
<p>通用的语法为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| 表头 | 表头 |</span><br><span class="line">| ---- | ---- |</span><br><span class="line">| 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>typora简单使用</title>
    <url>/2023/09/01/%E4%BB%80%E4%B9%88%E6%98%AFmarkdown/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>MarkDown是什么<br>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p>
<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>
<p>Markdown 编写的文档后缀为 .md, .markdown。</p>
<h1 id="1-如何自动生成目录"><a href="#1-如何自动生成目录" class="headerlink" title="1.如何自动生成目录"></a>1.如何自动生成目录</h1><p>点击【视图】——【大纲】</p>
<p>说明：但是此步骤生成的目录，并不是折叠的目录，折叠起来会更美观一些</p>
<p>设置折叠目录</p>
<p>点击【文件】——【偏好设置】——【外观】——侧边栏选择打钩，此时已经折叠成功</p>
<h1 id="2-快捷键"><a href="#2-快捷键" class="headerlink" title="2.快捷键"></a>2.快捷键</h1><p> Ctrl+1 ——设置一级标题</p>
<p>Ctrl+2 ——设置二级标题</p>
<p>Ctrl+3 ——设置三级标题</p>
<p>Ctrl+4 ——设置四级标题</p>
<p>Ctrl+5 ——设置五级标题</p>
<p>Ctrl+6 ——设置六级标题</p>
<p>空格 ——引用</p>
<p>回车、shift + tab ——退出引用</p>
<p>Ctrl + Shift + ] ——无序列表</p>
<p>Ctrl + Shift + [ ——有序列</p>
<p>Ctrl + Shift + ] 、tab——子列表</p>
<p>Shift + tab ——返回上一级列表、</p>
<p>Ctrl + B —— 加粗</p>
<p>Ctrl + T —— 表格</p>
<p>~ ~ 要删除的内容 ~ ~ ——删除线</p>
<h1 id="3-创建链接"><a href="#3-创建链接" class="headerlink" title="3.创建链接"></a>3.创建链接</h1><p>格式为[] ()，其中[]内为要展示的内容，()为链接。</p>
<h1 id="4-图片路径管理"><a href="#4-图片路径管理" class="headerlink" title="4.图片路径管理"></a>4.图片路径管理</h1><p>Typora默认将所有文档的图片都放在一起，但是我们更想每一个文档都有属于自己的一个文件夹，文档中的图片也最好可以自动保存在该文件夹内。解决方法如下：</p>
<p>点击【文件】——【偏好设置】——【图像】——将该界面内容设置如下:</p>
<p> 此时，该文档所在文件夹中会自动生成一个img文件，该路径为本文档中的图片路径。</p>
<p><img src="D:\hexo\blog\source_posts\image-20230902072149501.png"></p>
<h1 id="5-划重点–高亮"><a href="#5-划重点–高亮" class="headerlink" title="5.划重点–高亮"></a>5.划重点–高亮</h1><p>高亮</p>
<p>点击【文件】——【偏好设置】——【Markdown】——高亮处打钩</p>
<p>编辑高亮内容格式如下：</p>
<p>&#x3D;&#x3D; 内容&#x3D;&#x3D; —— 高亮</p>
<p>&#x3D;&#x3D; chai&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;cccc&#x3D;&#x3D; </p>
<p>&#x3D;&#x3D; key&#x3D;&#x3D;</p>
<p> &#x3D;&#x3D;内容&#x3D;&#x3D; </p>
<p><strong>cha</strong></p>
<p>重启Typora，此时内容处会变成高亮的效果.</p>
<h1 id="6-导入代码块"><a href="#6-导入代码块" class="headerlink" title="6.导入代码块"></a>6.导入代码块</h1><p><strong>~~~</strong> ——代码块，点击代码框可选择语言</p>
<h1 id="7-不使用自动拼写检查"><a href="#7-不使用自动拼写检查" class="headerlink" title="7.不使用自动拼写检查"></a>7.不使用自动拼写检查</h1><p>点击右下角[【Spell Check】勾选【不使用拼写检查】</p>
<h1 id="8设置自动保存"><a href="#8设置自动保存" class="headerlink" title="8设置自动保存"></a>8设置自动保存</h1><p>其实Typora 对文件修改之后并不能自动保存，解决方法：</p>
<p>点击【文件】——【偏好设置】——【通用】——自动保存处打钩</p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
