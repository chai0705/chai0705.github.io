<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="永远年轻，永远热泪盈眶" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>嵌入式Linux入门篇 |  热爱学习的未来酱</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="热爱学习的未来酱" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-03_Linux学习/3 嵌入式Linux入门篇"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  嵌入式Linux入门篇
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/06/25/03_Linux%E5%AD%A6%E4%B9%A0/3%20%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%85%A5%E9%97%A8%E7%AF%87/" class="article-date">
  <time datetime="2024-06-24T22:50:19.000Z" itemprop="datePublished">2024-06-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux%E5%AD%A6%E4%B9%A0/">Linux学习</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">32.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">114 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1初识linux"><a class="markdownIt-Anchor" href="#1初识linux"></a> 1.初识Linux</h1>
<h2 id="11-unix的诞生"><a class="markdownIt-Anchor" href="#11-unix的诞生"></a> 1.1 unix的诞生</h2>
<p>相信大家肯定听过这样的描述，Linux是一个类Unix的操作系统，Linux的创作者林纳斯·托瓦兹（Linus Torvalds）正是借鉴了UNIX的设计原则和功能（==并不是直接使用UNIX的源代码==）设计开发出来了Linux，所以在学习Linux之前，有必要先来讲解一下Unix的发展历史。</p>
<p>上个世纪60年代，美国贝尔实验室的工程师开始开发一个多用户、多任务的操作系统，旨在提供更好的资源管理和程序开发环境，这个操作系统被称为Multics（Multiplexed Information and Computing Service）即多路传输信息和计算服务。然而，由于Multics项目过于复杂，项目进展缓慢，贝尔实验室就退出了该项目。</p>
<p>贝尔实验室的肯·汤姆森（Ken Thompson）和丹尼斯·里奇（Dennis Ritchie），决定开始重新设计一个更简单、更实用的操作系统。最终于1969年成功开发出了一种新的操作系统，最初被称为Unics（Uniplexed Information and Computing System）。后来，因为有一个与之同名的操作系统，所以该系统就被修改成了UNIX。</p>
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401081759380.jpg" alt="download-2" style="zoom:200%;" />
<p>20世纪70年代，由于半导体和集成电路技术的普及，拉低了内存的制造成本，从而促使C语言等高级语言的应用成为了可能。丹尼斯·里奇又着手B语言的改进，就这样我们现在熟知的C语言就诞生了，于是在此基础上肯·汤姆森和丹尼斯·里奇又对unix不断更新迭代，最终于1975年发布了Unix第6版本，第6版本的unix内核由9000行的C语言和700行的汇编语言所实现，让Unix系统的维护和修改变的容易，也让其更方便的移植到不同的计算机上，打破了不同架构计算机操作系统互不兼容的局面。</p>
<h2 id="12-gnu和linux的发展"><a class="markdownIt-Anchor" href="#12-gnu和linux的发展"></a> 1.2 GNU和Linux的发展</h2>
<p>在20世纪70年代末，贝尔实验室的总公司AT&amp;T对UNIX操作系统源代码的使用做出了限制，禁止将其提供给学生群体使用。AT&amp;T收回了UNIX的版权，并不再将其开源。由于这一限制，广大用户和学校面临着没有操作系统可用的困境。</p>
<p>理查德·斯托曼（Richard Stallman）对当时UNIX操作系统的私有化和限制使用感到担忧，于是决定创建一个完全由免费软件组成的类Unix计算机操作系统，这就是GNU项目。GNU项目始于1983年，GNU它是一个递归写法，意味着&quot;GNU’s Not UNIX&quot;（GNU不是UNIX），强调了GNU操作系统与UNIX的区别。</p>
<p>GNU项目的核心是开发一系列自由软件工具，如GNU编译器套件（GCC）、GNU调试器（GDB）、命令行解释器GNU Bash等。然而，GNU项目的发展遇到了一个重要的挑战，它缺少操作系统内核这一核心组件。而在1991年一个名叫林纳斯·托瓦兹（Linus Torvalds）的芬兰大学生发布了一个名为Linux的操作系统内核，Linux内核采用了类似UNIX的设计理念，具有高度的可移植性和可扩展性。所以，Linux内核最终与GNU项目相结合，为用户提供了一个完整而自由的操作系统，也就是我们所熟知的GNU/Linux操作系统。</p>
<p>Linux可以分为内核版本和发行版本，内核是操作系统的核心，负责管理硬件资源和提供操作系统的核心功能。而发行版本是基于GNU/Linux构建的完整操作系统，包含了内核、源代码及相关应用程序。常见的发行版本有Ubuntu、Red Hat、Fedora、opensUSE、Linux Mint、Debian、Manjaro、Mageia、CentOS和Arch等。这些发行版本提供了一个在裸设备与应用程序间的抽象层，让一般用户可以简便地安装和使用Linux操作系统，而由于Ubuntu的图形化界面相对于初学者更加友好，所以本套课程讲解时选用的发行版就选择ubuntu。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401091006088.png" alt="img" /></p>
<p>在早期的时候Linux只适用于386处理器，后来经过全世界的网友的帮助，最终能够兼容多种架构，包括x86、ARM、PowerPC等，据统计，Linux服务器占据着整个服务器市场的高达85% – 90%的份额，而数以十亿计个人手机所运行的安卓系统使用的也是Linux内核。GNU/Linux操作系统的成功得益于GNU项目和Linux内核的共同努力。随着时间的推移，GNU/Linux操作系统逐渐发展壮大，并在不同领域得到广泛应用，包括个人计算机、服务器、移动设备以及嵌入式系统等。它成为了开源软件运动的重要代表之一，也促进了自由软件和开放源代码的发展。</p>
<h2 id="13-linux的优势"><a class="markdownIt-Anchor" href="#13-linux的优势"></a> 1.3 Linux的优势</h2>
<ol>
<li>开源免费：Linux是开源软件，用户可以免费获取和使用，无需支付额外的费用。同时，用户可以自由地修改和定制Linux的源代码，满足个性化需求。</li>
<li>稳定性、可靠性和安全性：由于Linux的开源特性，Linux得到了广泛的测试、审查和改进，可以长时间运行而且不容易崩溃或故障，并且具有极高的安全性。</li>
<li>硬件兼容性：Linux可以运行在多种硬件平台上，具有很好的硬件兼容性。与传统的UNIX系统相比，Linux更容易安装和运行在各种硬件设备上。</li>
<li>高度可定制性：Linux操作系统具有高度的可定制性，用户可以根据自己的需求和偏好进行自定义配置。这使得Linux适用于各种不同的应用场景，无论是服务器、嵌入式设备还是个人桌面。</li>
<li>应用生态系统和支持：Linux拥有庞大而活跃的应用生态系统，提供了各种开源软件和工具。用户可以充分利用已有的软件资源，无需从头开发。同时，Linux社区提供了广泛的支持和文档，用户可以轻松获取帮助和解决问题。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">优势</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">开源免费</td>
<td style="text-align:left">Linux是开源软件，用户可以免费获取和使用，无需支付额外的费用。同时，用户可以自由地修改和定制Linux的源代码，满足个性化需求。</td>
</tr>
<tr>
<td style="text-align:left">稳定性和可靠性</td>
<td style="text-align:left">由于开源的特性，Linux得到了广泛的测试、审查和改进，可以长时间运行而且不容易崩溃或故障。</td>
</tr>
<tr>
<td style="text-align:left">硬件兼容性</td>
<td style="text-align:left">Linux可以运行在多种硬件平台上，具有很好的硬件兼容性。与传统的UNIX系统相比，Linux更容易安装和运行在各种硬件设备上。</td>
</tr>
<tr>
<td style="text-align:left">安全性</td>
<td style="text-align:left">Linux操作系统具有强大的安全性。开源的特性使得安全漏洞可以更快地被发现和修补，同时Linux社区提供了广泛的安全工具和功能，帮助用户保护系统和数据的安全性。</td>
</tr>
<tr>
<td style="text-align:left">高度可定制性</td>
<td style="text-align:left">用户可以根据自己的需求和偏好进行自定义配置。这使得Linux适用于各种不同的应用场景，无论是服务器、嵌入式设备还是个人桌面。</td>
</tr>
<tr>
<td style="text-align:left">应用生态系统和支持</td>
<td style="text-align:left">Linux拥有庞大而活跃的应用生态系统，提供了各种开源软件和工具。用户可以充分利用已有的软件资源，无需从头开发。同时，Linux社区提供了广泛的支持和文档，用户可以轻松获取帮助和解决问题。</td>
</tr>
</tbody>
</table>
<h1 id="2虚拟机介绍"><a class="markdownIt-Anchor" href="#2虚拟机介绍"></a> 2.虚拟机介绍</h1>
<h2 id="21-什么是虚拟机"><a class="markdownIt-Anchor" href="#21-什么是虚拟机"></a> 2.1 什么是虚拟机？</h2>
<p>虚拟机(virtual machine)顾名思义就是一台虚拟出来的机器，与虚拟机对应的就是我们正在使用的物理计算机，在一台物理计算机上可以通过虚拟机软件模拟出多台虚拟计算机，每台虚拟的计算机拥有自己的 CPU、内存、操作系统（如 Windows、Linux、macOS）等，虚拟机所拥有的功能与物理计算机没有任何区别。</p>
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401031329277.png" alt="image-20240103132951233" style="zoom:50%;" />
<h2 id="22-为什么使用虚拟机"><a class="markdownIt-Anchor" href="#22-为什么使用虚拟机"></a> 2.2 为什么使用虚拟机？</h2>
<p>由于Windows操作系统凭借其简单易用的特点，占据了桌面端绝大多数的市场，所以绝大多数同学更习惯windwos操作系统，并且一些特定软件只能在windows上进行使用，所以我们绝大多少的工作其实都是在windows上完成的，一台装有windows操作系统的物理计算机是前必须的，那如何在这个前提下拥有一个装有Linux操作系统的机器呢？</p>
<p>最简单的方法是有两台物理计算机，一台装windwos操作系统，另一台装Linux操作系统。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401091036821.png" alt="image-20240109103604797" /></p>
<p>但无论对于学生还是初学者来说，使用两台机器是不现实的，这时候可能就有人会提到双系统，也就是在同一个物理计算机装上两个不同的系统，在开机的时候手动进行系统的切换，但在实际使用中两个系统之间的切换是非常消耗时间的，其工作效率远远比不上windows系统+Linux虚拟机。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401091037674.png" alt="image-20240109103754655" /></p>
<p>综上，当前嵌入式开发最合适的选择就是物理机安装windows操作系统，然后通过虚拟机软件在该系统上安装运行Linux操作系统的虚拟机，这里的Linux操作系统因为ui和易用性选择ubuntu操作系统。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401091044167.png" alt="image-20240109104406141" /></p>
<p>当前我们安装Linux操作系统的首要目的就是学习Linux基础，除此之外，Linux系统另一重要作用可以为我们提供编译环境。无论是开发板要烧写的一系列镜像(uboot、内核、文件系统),还是要放到开发板运行的可执行程序，都需要经过编译的步骤才能生成。而编译通常需要特定的编译工具链和依赖项，例如 gcc编译工具链、make工具等，而在 Linux 操作系统中，通常使用包管理器来管理软件包，所以可以很方便的进行编译环境的搭建。此外，由于开发板运行的也是Linux操作系统，所以许多芯片厂商提供的 SDK 和开发工具也是针对 Linux 环境设计的，源码编译通常依赖于底层操作系统的特性和接口，所以必须选择Linux操作系统进行编译。</p>
<h1 id="3下载和安装虚拟机软件vmware-workstation-pro"><a class="markdownIt-Anchor" href="#3下载和安装虚拟机软件vmware-workstation-pro"></a> 3.下载和安装虚拟机软件：Vmware Workstation pro</h1>
<p>Vmware Workstation官方网址为 <a target="_blank" rel="noopener" href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html">Vmware Workstation pro下载地址</a></p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312281659287.png" alt="image-20231228165957097" /></p>
<p>进入Vmware Workstation官方网站之后，在该网页的最下方可以找到Vmware Workstation pro17的下载，对于虚拟机软件的版本来说，建议是越新越好，一般情况下虚拟机软件的版本都会向下兼容，等待安装包下载完成。</p>
<p>安装包下载完成之后，双击该安装包，进入安装界面，然后点击下一步，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312281711363.png" alt="image-20231228171131333" /></p>
<p>然后勾选接受条款，继续点击下一步，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312281712473.png" alt="image-20231228171240441" /></p>
<p>然后更改软件的安装路径，这里建议放到C盘意外的地方，修改完成之后，点击进行下一步：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312281721698.png" alt="image-20231228172112672" /></p>
<p>接下来的产品更新和客户体验计划勾选不勾选都行，这里保持默认即可，然后点击下一步：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312281726317.png" alt="image-20231228172625295" /></p>
<p>创建桌面快捷方式和开始菜单程序文件夹也保持默认勾选，然后点击下一步：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312281728591.png" alt="image-20231228172813571" /></p>
<p>最后点击安装，等待安装完成即可：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312281728697.png" alt="image-20231228172834674" /></p>
<p>安装完成之后，如果有许可证可以输入许可证，没有许可证点击完成即可。没有许可证只能有30天的试用期，如果想要进行后续的使用，大家自行后续操作就行，懂得都懂。到这里vmware workstation pro 虚拟机软件的安装就完成了。</p>
<h1 id="4-获取并安装ubuntu操作系统"><a class="markdownIt-Anchor" href="#4-获取并安装ubuntu操作系统"></a> 4 获取并安装ubuntu操作系统</h1>
<p>ubuntu操作系统镜像下载地址：<a target="_blank" rel="noopener" href="https://cn.ubuntu.com/download/desktop">ubuntu下载地址</a></p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312281758024.png" alt="image-20231228175853669" /></p>
<p>然后点击右下角的“下载22.04.3”即可进行下载，但ubuntu官网的镜像下载可能会比较慢，所以在一般情况下都是通过国内的一些镜像网站进行下载，就比如<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/"> 清华大学开源软件镜像站</a>或者<a target="_blank" rel="noopener" href="https://mirrors.ustc.edu.cn/">中科大的开源软件镜像站</a>，这里就以清华大学开源镜像站为例进行下载演示：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312290922735.png" alt="image-20231229092202662" />	从这里可以看到，最新的ubuntu版本为23.10.1，但23版本并非长期支持版本，所以我们仍旧选择22.04.03版本，点击进入之后可以看到有desktop桌面版和server服务器版两个版本供我们选择，考虑到大家都是刚接触Linux，需要图形化界面来进行简单的过度，所以这里选择desktop桌面版进行下载。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312290926976.png" alt="image-20231229092620936" /></p>
<p>然后来讲解一下ubuntu系统的版本选择：</p>
<blockquote>
<p>对于入门学习阶段，我们的首要目的是熟悉和了解Linux的一些常用操作和相关命令。所以选择最新版本的Ubuntu镜像即可。</p>
</blockquote>
<blockquote>
<p>然而，在某些情况下，最新版本的Ubuntu系统并不能满足我们的需求，在第一节也提到过，我们使用ubuntu的核心目的就是为了编译，编译会用到许多的工具和依赖，但是不同版本的ubuntu相应工具和依赖的版本也不同，这里以瑞芯微提供的RK3568 Linux sdk进行举例，因为工具版本的差异，瑞芯微提供的源码包只能在Ubuntu18和Ubuntu20编译成功，而如果使用Ubuntu22编译则会出现很多版本相关的错误，需要花费大量的时间来根据打印逐一解决报错。</p>
</blockquote>
<blockquote>
<p>除此之外，还有一种更好的解决办法，那就是使用Docker容器来进行编译。但对目前来说，Docker相关的知识距离我们还比较遥远，后续有机会的话可能会提到docker容器。</p>
</blockquote>
<p>ubuntu系统的iso镜像下载完成之后，接下来使用Vmware workstation虚拟机软件来安装ubuntu。</p>
<p>首先打开vmware workstation pro软件，然后点击“创建新的虚拟机”，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291024587.png" alt="image-20231229102449559" /></p>
<p>点击之后会进入新建虚拟机向导，这里有两个选项，一个是典型、一个是自定义，自定义里面的一些选项会更细致，所以我们这里选择自定义，然后点击下一步，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291027934.png" alt="image-20231229102753910" /></p>
<p>点击之后需要选择硬件兼容性，这里保持默认最新的即可，然后点击下一步，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291032857.png" alt="image-20231229103233835" /></p>
<p>点击之后会进入操作系统映像文件的选择，这里的映像文件就是刚刚下载完成的ubuntu iso文件，然后点击下一步，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291035142.png" alt="image-20231229103523122" /></p>
<p>点击之后会进入安装信息设置界面，需要设置Linux系统的用户名和密码，后面在系统安装的过程中还需要再进行设置一次，设置完成之后点击下一步，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291034727.png" alt="image-20231229103435705" /></p>
<p>点击之后会进入虚拟机名称和位置设置界面，修改完成之后，继续点击下一步，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291042739.png" alt="image-20231229104216716" /></p>
<p>点击之后会进入处理器配置界面，这里的处理器数量和内核数量需要根据个人电脑CPU的型号来进行设置，这里填写的越高，虚拟机相应的性能也越高，当然这里的数量不能超过你实际物理机的逻辑处理器数量，可以通过任务管理器来查看自己电脑的逻辑处理器数量，设置完成之后点击下一步，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291047251.png" alt="image-20231229104728228" /></p>
<p>接下来进行虚拟机内存的配置，这里的内存配置不建议超过物理机内存的百分之八十，否则会有明显的卡顿，设置完成之后点击下一步，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291100846.png" alt="image-20231229110058812" /></p>
<p>点击之后会进入网络类型配置界面，这里有四种模式供我们选择，分别为桥接模式、NAT模式、仅主机模式和无网络模式，作为入门学习用户，目前我们肯定是需要虚拟机正常上网的，所以只能选择第一个桥接模式或者第二个NAT模式，两种模式的区别在于桥接模式下虚拟机会跟物理主机所在的局域网处于同一网段下，可以ping通局域网内的其他主机，而nat模式相当于将主机和虚拟机又接到了一个新的路由器上，使用一个新的网段，这时候虚拟机不能同局域网内的其他主机进行通信，当然无论是桥接模式还是nat模式都可以正常上网，目前大家只需要保证虚拟机正常上网即可，两种模式可以自由选择，作者这里先选择桥接模式，然后点击下一步，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291103083.png" alt="image-20231229110310060" /></p>
<p>接下来的IO控制器类型和磁盘类型保持默认即可，磁盘选择这里选择第一个创建新虚拟机磁盘，然后点击下一步，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291122757.png" alt="image-20231229112248737" /></p>
<p>点击之后会进入磁盘容量设置界面，如果仅仅是为了学习Linux基础，30G的空间也就够了，但是如果想要进行后续的开发，就比如源码的编译，就需要更大的空间，看个人计算机的空间大小来分配容量即可，然后为了提高读写性能，下面选择存储为单个文件，然后点击下一步，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291125375.png" alt="image-20231229112553353" /></p>
<p>接下来的磁盘文件名保持默认即可，然后点击下一步，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291130347.png" alt="image-20231229113025325" /></p>
<p>至此，关于虚拟机的配置就完成了，最后点击完成即可，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291130782.png" alt="image-20231229113042754" /></p>
<p>然后就会进入系统安装界面，首先是键盘布局的选择，这里保持默认的英文键盘布局即可，然后点击continue继续，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291311798.png" alt="image-20231229131145667" /></p>
<p>接下来是软件的安装，我们并不需要办公软件、游戏、游戏、播放器等一系列软件，所以这里选择第二个精简系统安装，只安装web服务器和一些基础工具即可，然后点击continue继续，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291316381.png" alt="image-20231229131622247" /></p>
<p>点击之后会进入，安装类型选择界面，保持默认的第一个选项即可，由于是虚拟机安装，所以这里并不会对实际的物理磁盘进行清空，点击 install now进行安装即可，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291320021.png" alt="image-20231229132057998" /></p>
<p>安装过程会选择地区，这里选择上海即可，然后点击 continue继续，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291322451.png" alt="image-20231229132204424" /></p>
<p>然后设置用户名称、电脑名称以及密码相关的内容，大家根据喜好自行设置即可，然后设置为自动登录，自动登录可以省去每次开机输入密码的步骤，然后点击continue继续安装，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291323105.png" alt="image-20231229132342079" /></p>
<p>​	安装完成之后，会出现重启计算机的弹窗，重新启动系统之后，ubuntu就安装完成了。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291328742.png" alt="image-20231229132822687" /></p>
<h1 id="5修改ubuntu系统语言"><a class="markdownIt-Anchor" href="#5修改ubuntu系统语言"></a> 5.修改ubuntu系统语言</h1>
<p>对于刚刚接触Linux的我们来说，还是更习惯于中文界面，换成中文之后一些系统的打印信息也会更容易理解，所以在安装完ubuntu之后要进行的第一个操作就是将ubuntu系统默认语言从英文修改为中文。</p>
<p>首先点击右上角的开关机按钮，找到setting设置，点击就会进入设置界面，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291337649.png" alt="image-20231229133754632" /></p>
<p>​	然后找到“Region &amp; Language”地区和语言，可以看到目前的语言为英文，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291339916.png" alt="image-20231229133937888" /></p>
<p>​	然后点击“Manage Installed Languages”管理安装的语言，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291355244.png" alt="image-20231229135518215" /></p>
<p>首先需要安装一些语言支持包，这里直接点击安装即可，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291356837.png" alt="image-20231229135602820" /></p>
<p>将汉语从最后一位拖动到第一位，然后点击应用到整个系统，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291357315.png" alt="image-20231229135712299" /></p>
<p>然后重启虚拟机，虚拟机重新启动之后之后就会发现整个系统已经变成了中文了，系统启动之后会弹出”是否保留旧名称“的弹窗，这里大家根据个人喜好设置即可，我这里选择保留旧的名称。到这里，ubuntu虚拟机就从默认的英文环境修改为了中文环境。</p>
<h1 id="6tabby终端软件的安装和使用"><a class="markdownIt-Anchor" href="#6tabby终端软件的安装和使用"></a> 6.tabby终端软件的安装和使用</h1>
<p>虽然在前面的章节中安装的是带有桌面的ubuntu系统，但在真正的工作以及学习中，无论要远程连接的服务器还是调试开发板，很多情况下是没有图形化界面的，只能使用终端用来进行交互，那什么是终端呢？最终要使用哪一个终端软件呢？让我们进入本章节的学习吧。</p>
<h2 id="61-什么是终端"><a class="markdownIt-Anchor" href="#61-什么是终端"></a> 6.1 什么是终端？</h2>
<p>根据冯·诺依曼的观点，计算机由运算器、控制器、存储器、输入设备和输出设备五个核心组件构成。其中，运算器、控制器和存储器是计算机实现计算功能的关键部分，而输入输出设备则负责与外界进行数据交换。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402220857373.png" alt="image-20240222062257689" /></p>
<blockquote>
<p>​	运算器是负责执行算术和逻辑运算的部件，它处理计算任务并提供结果。</p>
<p>​	控制器负责指导计算机的操作，根据程序中的指令来协调各个组件的工作。</p>
<p>​	存储器用于存储程序和数据，包括内存RAM和硬盘ROM。</p>
<p>​	输入设备用于将外部信息输入到计算机中，例如键盘、鼠标等。</p>
<p>​	输出设备用于将计算机处理的结果呈现给用户，例如显示器、打印机、扬声器等。</p>
</blockquote>
<p>尽管键盘、鼠标和显示器等输入输出设备在人机交互中起着重要的作用，但它们并非计算机运行的核心组件，就算没有键盘、鼠标和显示器，仍然可以开机，只有在需要操作和显示时才需要连接这些输入输出设备。</p>
<p>​	对于而今的台式机来说，键鼠显示器是基本的标配，而在计算机发展的早期，人们使用一种叫“计算机终端机”（Computer Terminal 简称“终端”Terminal）的输入输出集成设备与计算机的运算核心进行交互。</p>
<p>​	终端：==是一种计算机输入输出设备，用于与计算机的运算核心进行交互。==</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402220857307.png" alt="image-20240222064040255" /></p>
<p>因为早期的计算机都是大型机，造假昂贵并且占地面积非常大，所以在那时候一台大型机需要同时连接多台终端机，从而实现多人的共同使用，但是随着科技的发展，个人电脑已经成为了标配，人们也不再需要终端机这种单纯的输入输出设备，而是将主机、键盘、鼠标、显示器配套出售，一套个人计算机的显示器和键盘往往就专供一个主机使用。</p>
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402220857358.jpeg" alt="16e7c427cd3c2e3cbb339e5dcc65cc39" style="zoom: 25%;" />
<p>​	从功能上来看，一套个人电脑其实就相当于终端机的加强版，只是多了主机可以独立完成运算，而通过网线或者串口线就可以让个人电脑实现终端机的功能，所以随着个人计算机和网络的普及，越来越多人通过个人电脑和网络连接大型机或者嵌入式设备，终端机就失去了市场，虽然终端机这个产品消失了，但是对计算机的影响并未消失，尤其是在Linux操作系统上使用终端通过命令交互的效率实际上是远远大于图形化界面的，这里大家在后续的学习中回体会到，除此之外，在实际的工作中，无论是开发板的调试还是远程连接服务器，都不会直接使用图形化界面，而是使用终端软件通过串口和SSH进行连接。</p>
<p>在ubuntu中打开虚拟终端的三种方法：</p>
<blockquote>
<p>方法1：ctrl + alt + t  快捷键 打开终端</p>
<p>方法2：鼠标右击，选择“在终端中打开”</p>
<p>方法3：在应用栏中选择终端进行打开。</p>
</blockquote>
<h2 id="62-tabby的获取和安装"><a class="markdownIt-Anchor" href="#62-tabby的获取和安装"></a> 6.2 tabby的获取和安装</h2>
<p>tabby是一个无限可定制的跨平台终端应用程序，适用于本地的 shell终端、串口终端、SSH终端的连接，tabby终端具有更美观的窗口分割以及字体设置，相较于其他终端软件看起来更舒服。</p>
<p>tabby软件的下载地址：<a target="_blank" rel="noopener" href="https://github.com/Eugeny/tabby/releases/tag/v1.0.205">https://github.com/Eugeny/tabby/releases/tag/v1.0.205</a></p>
<p><a target="_blank" rel="noopener" href="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312101539329.png"><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291434245.png" alt="image-20231210153958212" /></a></p>
<p>由于我们要在windows环境进行安装，所以这里需要选择windowd对应的exe安装包进行下载，下载完成之后进行安装，tabby第一次启动会进入基本设置界面，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401051542289.png" alt="img" /></p>
<p>首先将语言选择为中文，设置之后如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401051543264.png" alt="img" /></p>
<p>至于配色方案大家根据自己的喜好设置即可，关闭退出之后就会进入软件界面如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401051543356.png" alt="img" /></p>
<p>至此，关于tabby的安装就完成了。</p>
<h2 id="63-ssh远程连接ubuntu"><a class="markdownIt-Anchor" href="#63-ssh远程连接ubuntu"></a> 6.3 ssh远程连接ubuntu</h2>
<p>一般情况下，连接远程主机使用的都是SSH，SSH（Secure Shell，安全外壳）是一种网络安全协议，通过加密和认证机制实现安全的访问和文件传输，而要想使用ssh连接到虚拟机ubuntu，还需要虚拟机ubuntu有ssh 的server服务，默认情况下ubuntu是没有ssh的server服务的，所以需要在ubuntu终端输入下面的命令来安装openssh-server和网络工具：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-server net-tools</span><br></pre></td></tr></table></figure>
<p>这个命令是我们接触到的第一个命令，下面是对于该命令的解释：</p>
<blockquote>
<ul>
<li><code>sudo</code>：用于以超级用户或管理员权限来执行后续的命令。</li>
<li><code>apt-get</code>：这是一个用于管理 Ubuntu和Debian 系统软件包的命令行工具。它可以用来搜索、安装、更新和删除软件包。Advanced Package Tool</li>
<li><code>install</code>：这是 <code>apt-get</code> 命令的一个参数，指示它要执行的操作是安装软件包。</li>
<li><code>openssh-server</code>：这是要安装的软件包的名称。在这个例子中，<code>openssh-server</code> 是一个用于安装 OpenSSH 服务器的软件包。OpenSSH 是一个用于安全远程登录和文件传输的工具，它允许您通过网络远程连接到系统，并进行安全的数据传输。</li>
<li><code>net-tools</code>：这是另一个要安装的软件包的名称。<code>net-tools</code> 包含了一些用于网络配置和诊断的工具，比如 <code>ifconfig</code> 和 <code>netstat</code>。</li>
</ul>
</blockquote>
<p>终端可以通过右击里的“==在终端中打开==”进入，也可以通过快捷键“ctrl + alt +t”打开，打开之后如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401061346217.png" alt="image-20240106134641162" /></p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401061348013.png" alt="image-20240106134835970" /></p>
<p>可以通过ctrl+shift+“+”进行字体的放大，通过ctrl + “-”进行字体的缩小，但是如果要重新启动了终端字体又会变回之前的大小，如果想要永久配置可以通过修改终端右击里面的“==配置文件首选项==”来实现，首先选择自定义字体，然后调整字体的大小即可，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401061356372.png" alt="image-20240106135621342" /></p>
<p>字体大小设置完成之后，继续回到openssh-server和网络工具的安装，具体安装过程如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291454799.png" alt="image-20231229145414777" /></p>
<p>而要想通过ssh连接到虚拟机ubuntu，还需要获取ubuntu系统的IP地址,那ubuntu的ip地址是如何获取的呢？这时候上一步安装的net-tools工具的作用就出现了，可以在终端输入&quot;==ifconfig==&quot;命令查看虚拟机ubuntu的ip地址，而ifconfig命令就包含在net-tools工具之中，具体打印如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291455846.png" alt="image-20231229145510821" /></p>
<p>根据打印信息可以看到目前有两个网卡，一个是ens33，一个是lo，其中ens33是ubuntu系统的网卡，lo是系统的本地回环，而ens33的IP地址为192.168.1.154，得到这个条件之后就可以返回tabby终端软件进行ssh远程连接了。首先进入“配置和连接”，找到ssh，点击ssh右侧小箭头中的克隆，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291501496.png" alt="image-20231229150157469" /></p>
<p>然后会弹出一个配置框，这里的名称大家随意，我这里填写ubuntu22，右边的主机填写刚刚从虚拟机ubuntu得到的ip地址192.168.1.154，这里的用户名称就是ubuntu安装时创建的用户名称，然后点击保存</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291506820.png" alt="image-20231229150651787" /></p>
<p>可以看到在未分组中多出了一个名为ubuntu22的ssh选项，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291511780.png" alt="image-20231229151144764" /></p>
<p>然后点击箭头进行连接即可，首先需要输入topeet用户的密码，如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291513383.png" alt="image-20231229151309367" /></p>
<p>然后点击接受并记住密钥</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291513910.png" alt="image-20231229151355890" /></p>
<p>连接成功如下所示：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291515332.png" alt="image-20231229151529274" />	后面会尽可能的使用SSH远程连接ubuntu，而不是在图形化界面进行操作，从开始学习的阶段就培养大家不使用图形化界面的习惯。</p>
<h2 id="64-串口连接开发板"><a class="markdownIt-Anchor" href="#64-串口连接开发板"></a> 6.4 串口连接开发板</h2>
<p>首先点击tabby软件的右上角的齿轮进入配置界面，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402221315216.png" alt="image-20240222131528186" /></p>
<p>然后找到配置和连接，在该界面中找到自己电脑的串口设备（==作者这里是串口5，这里根据自己电脑的端口来即可==）：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402221318333.png" alt="image-20240222131800211" /></p>
<p>选择之后进行波特率的设置，作者开发板的波特率为115200，所以选择115200如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402221311871.png" alt="image-20231210163634527" /></p>
<p>​	启动开发板，打印信息如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402221319673.png" alt="image-20240222131936517" /></p>
<h2 id="65-字体设置"><a class="markdownIt-Anchor" href="#65-字体设置"></a> 6.5 字体设置</h2>
<p>现在的字体特别小，观赏性仍旧不是很高，字体的大小可以通过ctrl + 和 ctrl - 进行调节，但这样修改之后也不是永久性的，如果想要永久修改可以通过设置中的外观进行修改，进入外观修改界面之后如下所示：<br />
<a target="_blank" rel="noopener" href="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312101648741.png"><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312291446361.png" alt="image-20231210164841697" /></a></p>
<p>这里的字体可以根据自己的喜好进行设置，个人推荐Cascadia Code SemiBold，而字体大小设置为20即可</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401061420822.png" alt="img" /></p>
<p>最后的显示效果如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401061421327.png" alt="img" /></p>
<p>至此，关于tabby的简单使用就讲解完成了，tabby除了可以连接ssh之外、还可以启用串口终端或者windows本地终端，等后面用到了之后再进行更详细的讲解。</p>
<h1 id="7-linux目录相关命令"><a class="markdownIt-Anchor" href="#7-linux目录相关命令"></a> 7 Linux目录相关命令</h1>
<h2 id="71-命令的基本格式"><a class="markdownIt-Anchor" href="#71-命令的基本格式"></a> 7.1 命令的基本格式</h2>
<p>在Linux中，命令的格式通常遵循以下结构：</p>
<blockquote>
<p>command [options] [arguments]</p>
</blockquote>
<ol>
<li>命令（command）：表示要执行的具体命令或程序。命令可以是系统自带的内置命令，也可以是可执行程序或脚本文件。</li>
<li>选项（options）：表示对命令的配置或修改。选项通常以短格式（单个字母前缀，如 <code>-a</code>）或长格式（完整的单词前缀，如 <code>--all</code>）提供。选项可以用来控制命令的行为、修改默认设置或提供额外的功能。</li>
<li>参数（arguments）：用于命令的输入或操作对象。参数是命令的操作数，可以是文件、目录、文本、数字等。命令的参数通常紧跟在选项之后。</li>
</ol>
<p>==注：这里的选项和参数用[]进行描述，表示可选、非必填==</p>
<p><strong>示例1：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -la /home/topeet</span><br></pre></td></tr></table></figure>
<ul>
<li>命令：ls</li>
<li>选项：-la</li>
<li>参数：/home/topeet</li>
</ul>
<p>这个命令的含义是列出<code>/home/topeet</code>目录下的所有文件和目录和隐藏文件，并显示它们的详细信息。</p>
<p><strong>示例2：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /home/topeet</span><br></pre></td></tr></table></figure>
<ul>
<li>命令：cd</li>
<li>参数：/home/topeet</li>
</ul>
<p>这个命令的含义是将当前工作目录切换到<code>/home/topeet</code>目录。<code>cd</code>是一个内置命令，用于改变当前工作目录到指定的目录路径。在这个例子中，<code>/home/topeet</code>是要切换的目标目录路径。</p>
<h2 id="72-列出文件和目录ls命令"><a class="markdownIt-Anchor" href="#72-列出文件和目录ls命令"></a> 7.2 列出文件和目录：ls命令</h2>
<p><code>ls</code> 命令是 Linux 系统中非常常用的命令之一，可以看作是list英文的简写，用于列出指定目录下的文件和子目录。它的基本格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [options] [file(s) or directory]</span><br></pre></td></tr></table></figure>
<p>下面是对 <code>ls</code> 命令的详细解释：</p>
<ul>
<li><code>options</code>：选项用于控制 <code>ls</code> 命令的行为和输出格式。以下是常用的选项：
<ul>
<li><code>-l</code>：以长格式（详细信息）显示文件和目录。输出包括文件的权限、所属用户和组、大小、创建日期等详细信息。</li>
<li><code>-a</code>：显示所有文件和目录，包括以 <code>.</code> 开头的隐藏文件（默认情况下，隐藏文件不会显示）。</li>
<li><code>-h</code>：以人类可读的格式显示文件大小，例如以 KB、MB、GB 等单位显示。</li>
<li><code>-r</code>：以相反的顺序显示文件和目录。</li>
<li><code>-t</code>：按修改时间排序，最近修改的文件或目录显示在前面。</li>
</ul>
</li>
<li><code>file(s) or directory</code>：可以指定一个或多个文件或目录作为参数。如果不指定参数，则默认为当前目录。</li>
</ul>
<p>下面是一些 <code>ls</code> 命令的示例用法：</p>
<ol>
<li>
<p>列出当前目录下的文件和目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402291119241.png" alt="image-20240229111934212" /></p>
</li>
<li>
<p>列出指定目录下的文件和目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /path/to/directory</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402291120905.png" alt="image-20240229112020881" /></p>
</li>
<li>
<p>以长格式显示当前目录下的文件和目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402291120979.png" alt="image-20240229112054937" /></p>
</li>
<li>
<p>列出所有文件和目录，包括隐藏文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402291121942.png" alt="image-20240229112111913" /></p>
</li>
<li>
<p>以人类可读的格式显示文件大小：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lh</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402291122883.png" alt="image-20240229112218845" /></p>
</li>
<li>
<p>按修改时间排序，显示最近修改的文件或目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lt</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402291123707.png" alt="image-20240229112308672" /></p>
<p>除了以上常用选项之外，<code>ls</code> 还有许多其他选项和用法，可以通过 <code>man ls</code> 命令来查看完整的 <code>ls</code> 命令的手册页，其中包含了更详细的信息和用法示例。</p>
<h2 id="73-打印当前工作目录pwd命令"><a class="markdownIt-Anchor" href="#73-打印当前工作目录pwd命令"></a> 7.3 打印当前工作目录：pwd命令</h2>
<p><code>pwd</code> 命令是 Linux 系统中常用的命令之一，用于显示当前工作目录的路径。<code>pwd</code> 是 “print working directory” 的缩写。使用 <code>pwd</code> 命令可以帮助你确定当前所在的目录位置，以便了解你在文件系统中的具体位置。其基本格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>
<p>执行 <code>pwd</code> 命令后，它会将当前工作目录的完整路径输出到终端。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402291306586.png" alt="image-20240229130654561" /></p>
<p>可以看到当前终端所在的路径为<code>/home/topeet/</code>,下面对这个路径进行恰当的解释：</p>
<blockquote>
<ol>
<li><code>/</code>：第一个斜杠代表根目录，根目录是 Linux 文件系统的最顶层目录，所有其他目录和文件都是从根目录开始的（==关于根目录后面也会进行详细的讲解==）</li>
<li><code>home</code>：<code>home</code> 是根目录下的一个目录，用于存放用户的主目录。</li>
<li><code>/</code>：第二个斜杠代表层次结构，代表<code>topeet</code> 是 <code>home</code> 目录下的一个子目录。</li>
<li><code>topeet</code>：表示一个用户名或用户帐户。它可能是某个用户在系统中的登录名。每个用户都有一个主目录，通常以其用户名命名，用于存放用户的个人文件和配置。</li>
</ol>
</blockquote>
<p>需要注意的是，<code>pwd</code> 命令只是显示当前工作目录的路径，它不会改变当前工作目录。如果你需要切换到其他目录，可以使用 <code>cd</code> 命令。</p>
<h2 id="74-切换目录cd命令"><a class="markdownIt-Anchor" href="#74-切换目录cd命令"></a> 7.4 切换目录：cd命令</h2>
<p><code>cd</code> 命令是 Linux 系统中非常常用的命令之一，<code>cd</code> 是“change directory”的缩写，用于切换当前工作目录。它的基本格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd [directory]</span><br></pre></td></tr></table></figure>
<p>下面是对 <code>cd</code> 命令的详细解释：</p>
<p>directory：要切换到的目录。可以是绝对路径（从根目录开始的完整路径）或相对路径（相对于当前目录的路径）。</p>
<p>​	相对路径：是相对于当前工作目录或参考位置的路径。</p>
<p>​	绝对路径：是从文件系统的根目录（通常是 <code>/</code>）开始的完整路径。</p>
<p>常见的特殊目录表示如下：</p>
<ul>
<li><code>.</code>：表示当前目录。</li>
<li><code>..</code>：表示当前目录的父目录。</li>
<li><code>~</code>：表示当前用户的主目录。</li>
</ul>
<p>下面是一些 <code>cd</code> 命令的示例用法：</p>
<ol>
<li>
<p>切换到当前用户的主目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402291310424.png" alt="image-20240229131016395" /></p>
</li>
<li>
<p>切换到指定的目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /path/to/directory</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402291310360.png" alt="image-20240229131047334" /></p>
</li>
<li>
<p>切换到当前目录的父目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>切换到当前目录下的子目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd subdirectory</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ./subdirectory</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注：==相对路径和绝对路径是用于定位文件或目录在文件系统中位置的两种方式。==</p>
<p>相对路径（Relative Path）：相对路径是相对于当前工作目录或参考位置的路径。它描述了如何从当前位置导航到目标文件或目录。相对路径不包含根目录（/）作为起点，而是从当前位置开始计算。</p>
<p>例如，在当前工作目录为 <code>/home/topeet</code> 的情况下：</p>
<ul>
<li>相对路径 <code>documents/report.txt</code> 表示当前目录下的 <code>documents</code> 目录中的 <code>report.txt</code> 文件。</li>
<li>相对路径 <code>../photos/pic.jpg</code> 表示当前目录的父目录中的 <code>photos</code> 目录中的 <code>pic.jpg</code> 文件。</li>
</ul>
<p>相对路径的优势在于它们相对简洁，更具可移植性，因为它们不依赖于特定的根目录。</p>
<p>绝对路径（Absolute Path）：绝对路径是从文件系统的根目录（通常是 <code>/</code>）开始的完整路径。它提供了从根目录到目标文件或目录的完整路径，不依赖于当前工作目录，例如，在当前工作目录为 <code>/home/topeet</code> 的情况下：</p>
<p>相对路径 <code>documents/report.txt</code> 表示当前目录下的 <code>documents</code> 目录中的 <code>report.txt</code> 文件，使用绝对路径可以表示为：<code>/home/topeet/documents/report.txt</code></p>
<h2 id="75-linux目录结构"><a class="markdownIt-Anchor" href="#75-linux目录结构"></a> 7.5 Linux目录结构</h2>
<p>Linux 的目录结构是一个层次化的树状结构，用于组织和管理文件和目录。它是 Linux 文件系统的基础，为用户和系统提供了一种标准化的方式来访问和管理文件。在Linux目录的最上层是根目录，根目录是整个目录结构的起点，所有其他目录和文件都是从根目录开始的,根目录可以通过<code>/</code>来表示，在命令行中可以通过以下命令进入根目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402291318630.png" alt="image-20240229131813599" /></p>
<p>然后在根目录下使用“ls”命令查看根目录内容，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402291320622.png" alt="image-20240229132056586" /></p>
<p>每个文件及文件夹所具有的作用如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">目录</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">/bin</td>
<td style="text-align:left">存放基本命令的二进制文件</td>
</tr>
<tr>
<td style="text-align:left">/boot</td>
<td style="text-align:left">包含系统引导相关的文件</td>
</tr>
<tr>
<td style="text-align:left">/cdrom</td>
<td style="text-align:left">光盘设备的挂载点（可能在一些系统中不使用）</td>
</tr>
<tr>
<td style="text-align:left">/dev</td>
<td style="text-align:left">存放设备文件，用于与硬件设备进行通信</td>
</tr>
<tr>
<td style="text-align:left">/etc</td>
<td style="text-align:left">包含系统的配置文件</td>
</tr>
<tr>
<td style="text-align:left">/home</td>
<td style="text-align:left">用户的主目录所在位置</td>
</tr>
<tr>
<td style="text-align:left">/lib</td>
<td style="text-align:left">存放系统所需的共享库文件</td>
</tr>
<tr>
<td style="text-align:left">/lib32</td>
<td style="text-align:left">存放32位系统共享库文件</td>
</tr>
<tr>
<td style="text-align:left">/lib64</td>
<td style="text-align:left">存放64位系统共享库文件</td>
</tr>
<tr>
<td style="text-align:left">/libx32</td>
<td style="text-align:left">存放x32 ABI系统共享库文件</td>
</tr>
<tr>
<td style="text-align:left">/lost+found</td>
<td style="text-align:left">由文件系统恢复工具保留的文件和目录</td>
</tr>
<tr>
<td style="text-align:left">/media</td>
<td style="text-align:left">用于挂载可移动媒体设备</td>
</tr>
<tr>
<td style="text-align:left">/mnt</td>
<td style="text-align:left">用于挂载临时文件系统</td>
</tr>
<tr>
<td style="text-align:left">/opt</td>
<td style="text-align:left">用于安装可选的第三方软件</td>
</tr>
<tr>
<td style="text-align:left">/proc</td>
<td style="text-align:left">包含有关系统和进程的动态信息</td>
</tr>
<tr>
<td style="text-align:left">/root</td>
<td style="text-align:left">系统管理员的主目录</td>
</tr>
<tr>
<td style="text-align:left">/run</td>
<td style="text-align:left">存放在系统引导过程中创建的临时文件和运行时数据</td>
</tr>
<tr>
<td style="text-align:left">/sbin</td>
<td style="text-align:left">存放系统管理员使用的系统命令</td>
</tr>
<tr>
<td style="text-align:left">/snap</td>
<td style="text-align:left">存放基于 Snap 包管理器安装的应用程序</td>
</tr>
<tr>
<td style="text-align:left">/srv</td>
<td style="text-align:left">存放系统提供的服务数据</td>
</tr>
<tr>
<td style="text-align:left">/swapfile</td>
<td style="text-align:left">交换文件，用于虚拟内存的扩展</td>
</tr>
<tr>
<td style="text-align:left">/sys</td>
<td style="text-align:left">提供与内核和硬件相关的信息</td>
</tr>
<tr>
<td style="text-align:left">/tmp</td>
<td style="text-align:left">存放临时文件</td>
</tr>
<tr>
<td style="text-align:left">/usr</td>
<td style="text-align:left">包含系统的大部分应用程序和文件</td>
</tr>
<tr>
<td style="text-align:left">/var</td>
<td style="text-align:left">包含经常变化的文件和目录，如日志文件、缓存文件、临时文件等</td>
</tr>
</tbody>
</table>
<p>Linux的目录结构图如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202402291405639.png" alt="image-20240229140508591" /></p>
<h1 id="8-文件和文件夹操作命令"><a class="markdownIt-Anchor" href="#8-文件和文件夹操作命令"></a> 8 文件和文件夹操作命令</h1>
<h2 id="81创建目录mkdir-命令"><a class="markdownIt-Anchor" href="#81创建目录mkdir-命令"></a> 8.1创建目录：mkdir 命令</h2>
<p><code>mkdir</code> 是 Linux 中用于创建目录的命令，英文为“make make directory”，<code>mkdir</code> 命令可以创建单个目录或多级目录，下面是对 <code>mkdir</code> 命令的详细解释和使用方法：</p>
<p>命令语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [选项] 目录名...</span><br></pre></td></tr></table></figure>
<p>常用选项：</p>
<ul>
<li><code>-p</code>：创建多级目录，如果上级目录不存在，则一并创建。</li>
<li><code>-m</code>：设置目录的权限模式。</li>
<li><code>-v</code>：显示创建过程中的详细信息。</li>
</ul>
<p>使用示例：</p>
<ol>
<li>
<p>创建单个目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir 目录名</span><br></pre></td></tr></table></figure>
<p>这将在当前工作目录下创建一个名为 <code>目录名</code> 的目录。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403010925922.png" alt="image-20240301092550872" /></p>
</li>
<li>
<p>创建多级目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p 目录1/目录2/目录3</span><br></pre></td></tr></table></figure>
<p>使用 <code>-p</code> 选项可以创建多级目录。如果上级目录不存在，则会一并创建。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403010926779.png" alt="image-20240301092645712" /></p>
</li>
<li>
<p>创建目录并设置权限：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -m 模式 目录名</span><br></pre></td></tr></table></figure>
<p>使用 <code>-m</code> 选项可以设置创建的目录的权限模式。模式可以使用数字形式（如 <code>755</code>）或符号形式（如 <code>rwxr-xr-x</code>）来指定。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403010927573.png" alt="image-20240301092748510" /></p>
</li>
<li>
<p>创建目录并显示详细信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -v 目录名</span><br></pre></td></tr></table></figure>
<p>使用 <code>-v</code> 选项可以显示创建过程中的详细信息，包括每个创建的目录的名称。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403010928211.png" alt="image-20240301092818159" /></p>
</li>
</ol>
<p>需要注意的是，<code>mkdir</code> 命令默认在当前工作目录下创建目录。如果想要在其他目录下创建目录，可以在目录名前加上路径描述。</p>
<h2 id="82-创建文件touch命令"><a class="markdownIt-Anchor" href="#82-创建文件touch命令"></a> 8.2 创建文件：touch命令</h2>
<p><code>touch</code> 是一个在 Linux 系统中用于创建空文件或更新文件时间戳的命令。尽管它的主要功能是创建文件，但也可以用于更新现有文件的访问和修改时间。下面是对 <code>touch</code> 命令的详细解释和使用方法：</p>
<p>命令语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch [选项] 文件名...</span><br></pre></td></tr></table></figure>
<p>常用选项：</p>
<ul>
<li><code>-a</code>：仅更新访问时间。</li>
<li><code>-c</code>：不创建文件。</li>
<li><code>-m</code>：仅更新修改时间。</li>
<li><code>-r, --reference=参考文件</code>：使用参考文件的时间戳。</li>
<li><code>-t, --time=时间</code>：使用指定的时间戳。</li>
</ul>
<p>使用示例：</p>
<ol>
<li>
<p>创建单个文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch 文件名</span><br></pre></td></tr></table></figure>
<p>这将在当前工作目录下创建一个名为 <code>文件名</code> 的空文件。如果文件已存在，则仅更新其访问和修改时间戳。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403010936923.png" alt="image-20240301093629874" /></p>
</li>
<li>
<p>创建多个文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch 文件1 文件2 文件3</span><br></pre></td></tr></table></figure>
<p>使用多个文件名作为参数，可以一次性创建多个文件。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403010937024.png" alt="image-20240301093702975" /></p>
</li>
<li>
<p>创建文件并设置时间戳：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch -t 时间戳 文件名</span><br></pre></td></tr></table></figure>
<p>使用 <code>-t</code> 选项可以自定义文件的时间戳。时间戳格式为 <code>[[CC]YY]MMDDhhmm[.ss]</code>，可以指定年、月、日、小时、分钟和秒。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403010945640.png" alt="image-20240301094505552" /></p>
</li>
<li>
<p>使用参考文件设置时间戳：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch -r 参考文件 文件名</span><br></pre></td></tr></table></figure>
<p>使用 <code>-r</code> 选项可以使用参考文件的时间戳来设置目标文件的时间戳。目标文件将获得参考文件的访问和修改时间。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403010946385.png" alt="image-20240301094607300" /></p>
</li>
<li>
<p>仅更新访问时间或修改时间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch -a 文件名</span><br><span class="line">touch -m 文件名</span><br></pre></td></tr></table></figure>
<p>使用 <code>-a</code> 选项可以仅更新文件的访问时间，使用 <code>-m</code> 选项可以仅更新文件的修改时间。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403010954018.png" alt="image-20240301095400945" /></p>
</li>
</ol>
<h2 id="83-删除目录和文件rm-命令"><a class="markdownIt-Anchor" href="#83-删除目录和文件rm-命令"></a> 8.3 删除目录和文件：rm 命令</h2>
<p><code>rm</code> 是 Linux 系统中用于删除文件和目录的命令。<code>rm</code> 命令可以用来删除单个文件、多个文件以及整个目录。下面是对 <code>rm</code> 命令的详细解释和使用方法：</p>
<p>命令语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [选项] 文件名...</span><br></pre></td></tr></table></figure>
<p>常用选项：</p>
<ul>
<li><code>-f, --force</code>：强制删除文件而不提示。</li>
<li><code>-i, --interactive</code>：交互式地询问是否删除文件。</li>
<li><code>-r, --recursive</code>：递归地删除目录及其内容。</li>
<li><code>-v, --verbose</code>：显示删除过程中的详细信息。</li>
</ul>
<p>使用示例：</p>
<ol>
<li>
<p>删除单个文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm 文件名</span><br></pre></td></tr></table></figure>
<p>这将删除当前工作目录下的一个名为 <code>文件名</code> 的文件。如果文件不存在，将出现错误提示。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011033037.png" alt="image-20240301103317979" /></p>
</li>
<li>
<p>删除多个文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm 文件1 文件2 文件3</span><br></pre></td></tr></table></figure>
<p>使用多个文件名作为参数，可以一次性删除多个文件。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011033894.png" alt="image-20240301103341837" /></p>
</li>
<li>
<p>强制删除文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f 文件名</span><br></pre></td></tr></table></figure>
<p>使用 <code>-f</code> 选项可以强制删除文件而不提示确认。这可以用于删除受保护或只读文件。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011046190.png" alt="image-20240301104600134" /></p>
</li>
<li>
<p>交互式地删除文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -i 文件名</span><br></pre></td></tr></table></figure>
<p>使用 <code>-i</code> 选项可以以交互方式询问是否删除每个文件。在删除之前，命令会提示用户确认。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011047777.png" alt="image-20240301104736725" /></p>
</li>
<li>
<p>删除目录及其内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r 目录名</span><br></pre></td></tr></table></figure>
<p>使用 <code>-r</code> 选项可以递归地删除目录及其内容。该选项用于删除非空目录。在删除过程中，命令会显示每个删除的文件和子目录。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011048117.png" alt="image-20240301104807063" /></p>
<p>注意：如果该目录是只读权限，跟文件删除相同，也需要确认，所以有些时候为了避免麻烦，可以直接使用-rf参数来进行删除。</p>
</li>
<li>
<p>删除目录及其内容并显示详细信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rv 目录名</span><br></pre></td></tr></table></figure>
<p>使用 <code>-rv</code> 选项可以递归地删除目录及其内容，并显示删除过程中的详细信息。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011050674.png" alt="image-20240301105029624" /></p>
</li>
</ol>
<p>需要注意的是，<code>rm</code> 命令默认不会删除目录。如果要删除目录，请使用 <code>-r</code> 或 <code>-rf</code> 选项。</p>
<h2 id="84-复制文件和目录cp命令"><a class="markdownIt-Anchor" href="#84-复制文件和目录cp命令"></a> 8.4 复制文件和目录：cp命令</h2>
<p><code>cp</code> 是 Linux 统中用于复制文件和目录的命令。对应的英文为copy，<code>cp</code> 命令可以用来复制单个文件、多个文件以及整个目录。下面是对 <code>cp</code> 命令的详细解释和使用方法：</p>
<p>命令语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [选项] 源文件 目标文件</span><br></pre></td></tr></table></figure>
<p>常用选项：</p>
<ul>
<li><code>-r, --recursive</code>：递归地复制目录及其内容。</li>
<li><code>-i, --interactive</code>：交互式地询问是否覆盖已存在的目标文件。</li>
<li><code>-v, --verbose</code>：显示复制过程中的详细信息。</li>
<li><code>-u, --update</code>：仅复制比目标文件新或不存在的文件。</li>
</ul>
<p>使用示例：</p>
<ol>
<li>
<p>复制单个文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp 源文件 目标文件</span><br></pre></td></tr></table></figure>
<p>这将复制一个名为 <code>源文件</code> 的文件到名为 <code>目标文件</code> 的位置。如果目标文件已存在，它将被覆盖。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011055383.png" alt="image-20240301105536329" />**</p>
</li>
<li>
<p>复制多个文件到目标目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp 文件1 文件2 目标目录</span><br></pre></td></tr></table></figure>
<p>使用多个文件名作为参数，可以一次性将多个文件复制到目标目录中。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011056408.png" alt="image-20240301105615367" /></p>
</li>
<li>
<p>交互式地复制文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -i 源文件 目标文件</span><br></pre></td></tr></table></figure>
<p>使用 <code>-i</code> 选项可以以交互方式询问是否覆盖已存在的目标文件。在复制过程中，命令会提示用户进行确认。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011057887.png" alt="image-20240301105727845" /></p>
</li>
<li>
<p>递归地复制目录及其内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r 源目录 目标目录</span><br></pre></td></tr></table></figure>
<p>使用 <code>-r</code> 选项可以递归地复制目录及其内容。该选项用于复制整个目录树结构。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011058410.png" alt="image-20240301105804369" /></p>
</li>
<li>
<p>复制目录及其内容并显示详细信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -rv 源目录 目标目录</span><br></pre></td></tr></table></figure>
<p>使用 <code>-rv</code> 选项可以递归地复制目录及其内容，并显示复制过程中的详细信息。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011058084.png" alt="image-20240301105838034" /></p>
</li>
</ol>
<h2 id="85-移动文件和目录mv命令"><a class="markdownIt-Anchor" href="#85-移动文件和目录mv命令"></a> 8.5 移动文件和目录：mv命令</h2>
<p><code>mv</code> 是 Linux系统中用于移动文件和目录的命令。英文为mv，除了移动文件和目录，<code>mv</code> 命令还可以用于重命名文件和目录。下面是对 <code>mv</code> 命令的详细解释和使用方法：</p>
<p>命令语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [选项] 源文件 目标文件</span><br></pre></td></tr></table></figure>
<p>常用选项：</p>
<ul>
<li><code>-i, --interactive</code>：交互式地询问是否覆盖已存在的目标文件。</li>
<li><code>-u, --update</code>：仅移动比目标文件新或不存在的文件。</li>
<li><code>-v, --verbose</code>：显示移动过程中的详细信息。</li>
</ul>
<p>使用示例：</p>
<ol>
<li>
<p>移动文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 源文件 目标文件</span><br></pre></td></tr></table></figure>
<p>这将移动一个名为 <code>源文件</code> 的文件到名为 <code>目标文件</code> 的位置。如果目标文件已存在，它将被覆盖。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011108439.png" alt="image-20240301110851392" /></p>
</li>
<li>
<p>交互式地移动文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv -i 源文件 目标文件</span><br></pre></td></tr></table></figure>
<p>使用 <code>-i</code> 选项可以以交互方式询问是否覆盖已存在的目标文件。在移动过程中，命令会提示用户进行确认。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011103490.png" alt="image-20240301110317444" /></p>
</li>
<li>
<p>重命名文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 源文件 新文件名</span><br></pre></td></tr></table></figure>
<p>这将对一个名为 <code>源文件</code> 的文件进行重命名，新的文件名为 <code>新文件名</code>。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011109426.png" alt="image-20240301110932378" /></p>
</li>
<li>
<p>移动目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 源目录 目标目录</span><br></pre></td></tr></table></figure>
<p>这将移动一个名为 <code>源目录</code> 的目录及其内容到名为 <code>目标目录</code> 的位置。如果目标目录已存在，源目录将成为目标目录的子目录。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011112581.png" alt="image-20240301111232538" /></p>
</li>
<li>
<p>移动文件并显示详细信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv -v 源文件 目标文件</span><br></pre></td></tr></table></figure>
<p>使用 <code>-v</code> 选项可以显示移动过程中的详细信息。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011113883.png" alt="image-20240301111337840" /></p>
</li>
</ol>
<p>以上是 <code>mv</code> 命令的详细说明和使用方法。使用 <code>mv</code> 命令可以方便地移动文件和目录，同时还可以实现文件和目录的重命名。通过选择合适的选项，可以实现不同的移动操作，如交互式移动和仅移动更新的文件。</p>
<h1 id="9vim编辑器的使用"><a class="markdownIt-Anchor" href="#9vim编辑器的使用"></a> 9.vim编辑器的使用</h1>
<p>在上一章节中我们学习了文件和目录的创建、删除、拷贝和移动，但是使用touch命令创建的只是空文件，要想实现文件内容的添加和修改就需要使用编辑器了。就比如在windows系统下创建一个文本文件，这里也只是创建了一个空白文件，如果想要对这个文件的内容进行修改，则需要使用记事本打开该文件才行，而本节视频要学习的vim编辑器，就相当于Linux终端界面里的记事本，无论是在嵌入式设备中还是需要远程连接的设备，如果想要对设备上的文件进行修改，那就必然绕不开vim编辑器，在讲解vim之前先来了解一下它的前身vi编辑器。</p>
<p>Vi编辑器是所有Unix及Linux系统下标准的编辑器。在任何Unix及Linux系统中，都可以使用vi进行文件的编辑，而Vim（Vi IMproved 可视化界面增强版）是Vi编辑器的增强版本，在保留Vi快速和高效的操作方式前提下，提供了更多的功能和改进。</p>
<h2 id="91-vim的安装"><a class="markdownIt-Anchor" href="#91-vim的安装"></a> 9.1 vim的安装</h2>
<p>ubuntu默认是没有安装vim的，所以需要先输入以下命令安装vim</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401091615697.png" alt="image-20240109161559508" /></p>
<h2 id="92-vim的三种模式"><a class="markdownIt-Anchor" href="#92-vim的三种模式"></a> 9.2 vim的三种模式</h2>
<p>Vim中有三种常用的工作模式，分别为命令模式、编辑模式和末行模式。</p>
<p>（1）命令模式: 使用vim打开文件之后默认进入的就是命令模式，在命令模式可以通过一些快捷键来完成光标移动、插入、删除、复制、粘贴等操作；</p>
<p>（2）编辑模式: 在命令模式下通过i、a、A、o等按键进入编辑模式，进入编辑模式之后会在左下角显示“插入”，在该模式下可以对文件的内容进行编辑;</p>
<p>==在编辑模式可以通过esc按键退回到命令模式==</p>
<p>（3）末行模式: 在命令模式下通过输入冒号：进入末行模式，在末行模式下通过输入命令可以进行搜索、替换、保存、退出、窗口分割等操作;</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401091655654.png" alt="image-20240109165549582" /></p>
<h2 id="93-vim光标移动"><a class="markdownIt-Anchor" href="#93-vim光标移动"></a> 9.3 vim光标移动</h2>
<p>在vim中有两种基础光标移动方式：</p>
<ul>
<li>
<p>第一种方式是使用键盘上的方向键来进行光标的移动，这种方式无论是在命令模式还是在编辑模式都可以命令的移动光标。</p>
</li>
<li>
<p>第二种方式是在命令模式下使用h、j、k、l四个字母来进行移动，具体匹配如下所示：</p>
<pre><code>                          ^
                          k              提示： h 的键位于左边，每次按下就会向左移动。
            &lt; h              l &gt;           l 的键位于右边，每次按下就会向右移动。
                     j                     j 键看起来很象一支尖端方向朝下的箭头。    
                     v
    ** 作者更喜欢使用上下左右方向键。**	
</code></pre>
</li>
</ul>
<p>==作者更喜欢使用方向按键来控制光标的移动==</p>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">单词之间的跳转</td>
<td style="text-align:left">w</td>
<td style="text-align:left">将光标移动到下一个单词的开头。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">b</td>
<td style="text-align:left">将光标移动到前一个单词的开头。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">e</td>
<td style="text-align:left">将光标移动到下一个单词的词末。</td>
</tr>
<tr>
<td style="text-align:left">行内定位</td>
<td style="text-align:left">$</td>
<td style="text-align:left">将光标移动到当前行的行尾。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">0</td>
<td style="text-align:left">将光标移动到当前行的行首。</td>
</tr>
<tr>
<td style="text-align:left">行之间的跳转</td>
<td style="text-align:left">ctrl + g</td>
<td style="text-align:left">显示当前光标位置及文件状态。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">gg</td>
<td style="text-align:left">将光标移动到文件的开头。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">G</td>
<td style="text-align:left">将光标移动到文件的末尾。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">行号+gg/G</td>
<td style="text-align:left">将光标跳转到指定行。</td>
</tr>
<tr>
<td style="text-align:left">括号匹配</td>
<td style="text-align:left">%</td>
<td style="text-align:left">匹配大括号、小括号、中括号，让光标跳转到相应的匹配括号处。</td>
</tr>
<tr>
<td style="text-align:left">半屏滚动</td>
<td style="text-align:left">ctrl+u</td>
<td style="text-align:left">向上滚动半屏。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">ctrl+d</td>
<td style="text-align:left">向下滚动半屏。</td>
</tr>
<tr>
<td style="text-align:left">全屏滚动</td>
<td style="text-align:left">ctrl+f</td>
<td style="text-align:left">向下滚动一屏。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">ctrl+b</td>
<td style="text-align:left">向上滚动一屏。</td>
</tr>
<tr>
<td style="text-align:left">定位光标的位置</td>
<td style="text-align:left">zz</td>
<td style="text-align:left">将光标置于屏幕的中间。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">zt</td>
<td style="text-align:left">将光标移动到屏幕的顶部。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">zb</td>
<td style="text-align:left">将光标移动到屏幕的底部。</td>
</tr>
</tbody>
</table>
<h2 id="94-vim文本插入"><a class="markdownIt-Anchor" href="#94-vim文本插入"></a> 9.4 vim文本插入</h2>
<table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">i</td>
<td style="text-align:left">将光标定位到当前位置，并进入插入模式，在当前位置之前插入文本。</td>
</tr>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">将光标定位到当前字符的下一个位置，并进入插入模式，在当前位置之后插入文本。</td>
</tr>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:left">将光标定位到当前行的行尾，并进入插入模式，在行尾插入文本。</td>
</tr>
<tr>
<td style="text-align:left">o</td>
<td style="text-align:left">在当前行的下方插入一个新行，并进入插入模式，在新行中输入文本。</td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">在当前行的上方插入一个新行，并进入插入模式，在新行中输入文本。</td>
</tr>
</tbody>
</table>
<h2 id="95-vim的保存和退出"><a class="markdownIt-Anchor" href="#95-vim的保存和退出"></a> 9.5 vim的保存和退出</h2>
<table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">q</td>
<td style="text-align:left">未修改内容的情况下，在末行模式下输入 q &lt;回车&gt; 退出 Vim。</td>
</tr>
<tr>
<td style="text-align:left">q!</td>
<td style="text-align:left">在修改内容之后，如果想不保存修改内容并退出，输入 q! &lt;回车&gt; 退出 Vim，表示强制退出。</td>
</tr>
<tr>
<td style="text-align:left">w</td>
<td style="text-align:left">当文件为非只读文件时，在末行模式下输入 w &lt;回车&gt; 保存修改的内容。</td>
</tr>
<tr>
<td style="text-align:left">w!</td>
<td style="text-align:left">当文件为只读文件时，在末行模式下输入 w! &lt;回车&gt; 保存修改的内容，表示强制写入。</td>
</tr>
</tbody>
</table>
<h2 id="96-vim文本删除"><a class="markdownIt-Anchor" href="#96-vim文本删除"></a> 9.6 vim文本删除</h2>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">删除单个字符</td>
<td style="text-align:left">x</td>
<td style="text-align:left">在命令模式下，删除光标所在位置的字符。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">Backspace</td>
<td style="text-align:left">在插入模式下，删除光标所在位置的字符。</td>
</tr>
<tr>
<td style="text-align:left">删除单词</td>
<td style="text-align:left">dw</td>
<td style="text-align:left">删除一个单词（从光标处到下一个空格）。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">dnw</td>
<td style="text-align:left">删除从当前光标开始处的 n 个单词（n 为任意数字）。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">d0</td>
<td style="text-align:left">删除从光标到一行开头的所有字符（包括空白字符）。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">d$</td>
<td style="text-align:left">删除从光标到本行末尾的所有字符。</td>
</tr>
<tr>
<td style="text-align:left">删除行</td>
<td style="text-align:left">dd</td>
<td style="text-align:left">删除当前光标所在行。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">数字n + dd</td>
<td style="text-align:left">删除从光标开始处的后 n 行代码。</td>
</tr>
<tr>
<td style="text-align:left">删除文本范围</td>
<td style="text-align:left">dgg</td>
<td style="text-align:left">删除从光标到文本开头的所有字符。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">dG</td>
<td style="text-align:left">删除从光标到文本结尾的所有字符。</td>
</tr>
</tbody>
</table>
<h2 id="97-vim的复制-粘贴和剪切"><a class="markdownIt-Anchor" href="#97-vim的复制-粘贴和剪切"></a> 9.7 vim的复制、粘贴和剪切</h2>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">复制文本</td>
<td style="text-align:left">yy</td>
<td style="text-align:left">复制当前行。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">数字n + yy</td>
<td style="text-align:left">复制当前行及其下面的 n 行。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">y$</td>
<td style="text-align:left">复制从光标位置到当前行末尾的文本。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">yiw</td>
<td style="text-align:left">复制当前光标所在单词。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">v</td>
<td style="text-align:left">进入可视模式，通过移动光标选择要复制的文本，然后按下 y 进行复制。</td>
</tr>
<tr>
<td style="text-align:left">粘贴文本</td>
<td style="text-align:left">p</td>
<td style="text-align:left">粘贴剪贴板中的文本在光标的下方（行粘贴）。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">P</td>
<td style="text-align:left">粘贴剪贴板中的文本在光标的上方（行粘贴）。</td>
</tr>
<tr>
<td style="text-align:left">剪切（删除）文本</td>
<td style="text-align:left">dd</td>
<td style="text-align:left">剪切（删除）当前行。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">数字n + dd</td>
<td style="text-align:left">剪切（删除）当前行及其下面的 n 行。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">d$</td>
<td style="text-align:left">剪切（删除）从光标位置到当前行末尾的文本。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">diw</td>
<td style="text-align:left">剪切（删除）当前光标所在单词。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">v</td>
<td style="text-align:left">进入可视模式，使用光标键选择要剪切（删除）的文本，然后按下 d。</td>
</tr>
</tbody>
</table>
<h2 id="98-撤消类命令"><a class="markdownIt-Anchor" href="#98-撤消类命令"></a> 9.8 撤消类命令</h2>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">撤销上一次编辑操作</td>
<td style="text-align:left">u</td>
<td style="text-align:left">按下 u 键会撤销最近的编辑操作，将文本恢复到上一个状态。</td>
</tr>
<tr>
<td style="text-align:left">恢复撤销的操作</td>
<td style="text-align:left">Ctrl + r</td>
<td style="text-align:left">按下 Ctrl 键和 r 键组合可以恢复上一次撤销的操作，将文本恢复到撤销之前的状态。</td>
</tr>
</tbody>
</table>
<h2 id="99-搜索类命令"><a class="markdownIt-Anchor" href="#99-搜索类命令"></a> 9.9 搜索类命令</h2>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">向前搜索</td>
<td style="text-align:left">/pattern</td>
<td style="text-align:left">在正文中向前搜索与指定模式匹配的文本。例如，/example 将搜索下一个出现的 “example”。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">n</td>
<td style="text-align:left">按下 n 键可以跳到下一个匹配项。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left">按下 N 键可以跳到上一个匹配项。</td>
</tr>
<tr>
<td style="text-align:left">向后搜索</td>
<td style="text-align:left">?pattern</td>
<td style="text-align:left">在正文中向后搜索与指定模式匹配的文本。例如，?example 将搜索上一个出现的 “example”。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">n</td>
<td style="text-align:left">按下 n 键可以跳到下一个匹配项。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left">按下 N 键可以跳到上一个匹配项。</td>
</tr>
<tr>
<td style="text-align:left">搜索时忽略大小写和设置高亮</td>
<td style="text-align:left">:set ignorecase</td>
<td style="text-align:left">在末行模式下输入 <code>set ignorecase</code> 命令可以设置搜索时忽略大小写。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">:set hlsearch</td>
<td style="text-align:left">在末行模式下输入 <code>set hlsearch</code> 命令可以设置搜索内容高亮显示。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">:set number</td>
<td style="text-align:left">在末行模式下输入 <code>set number</code>命令可以显示行号</td>
</tr>
</tbody>
</table>
<h2 id="910-替换类命令"><a class="markdownIt-Anchor" href="#910-替换类命令"></a> 9.10 替换类命令</h2>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">快捷键/命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">替换单个匹配项</td>
<td style="text-align:left">😒/old/new/g</td>
<td style="text-align:left">在末行模式下，通过输入 <code>s/old/new/g</code> 可以替换当前行中的所有匹配项 old 为 new。</td>
</tr>
<tr>
<td style="text-align:left">替换全部匹配项</td>
<td style="text-align:left">:%s/old/new/g</td>
<td style="text-align:left">在末行模式下，通过输入 <code>%s/old/new/g</code> 可以替换整个文件中的每个匹配项 old 为 new。</td>
</tr>
<tr>
<td style="text-align:left">替换全部匹配项并要求确认</td>
<td style="text-align:left">:%s/old/new/gc</td>
<td style="text-align:left">在末行模式下，通过输入 <code>%s/old/new/gc</code> 可以找到整个文件中的每个匹配项 old，并且对每个匹配项进行提示是否进行替换。</td>
</tr>
</tbody>
</table>
<h1 id="10-文件内容查看和搜索"><a class="markdownIt-Anchor" href="#10-文件内容查看和搜索"></a> 10 文件内容查看和搜索</h1>
<h2 id="101-终端打印输出echo命令"><a class="markdownIt-Anchor" href="#101-终端打印输出echo命令"></a> 10.1 终端打印输出：echo命令</h2>
<p>当在命令行中使用 <code>echo</code> 命令时，它用于将文本或字符串输出到标准输出（通常是终端窗口）。<code>echo</code> 是一个简单而常用的命令，可以用于打印文本、变量值和其他字符串。</p>
<p>以下是对 <code>echo</code> 命令的详细解释：</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo [选项] [字符串]</span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li><code>-n</code>：不换行。默认情况下，<code>echo</code> 输出完指定的字符串后会自动换行，使用 <code>-n</code> 选项可以禁止换行，使输出保持在同一行上。</li>
</ul>
<p>字符串：<br />
要输出的文本或字符串。可以是纯文本，也可以是包含变量的字符串。</p>
<p>示例用法：</p>
<ol>
<li>
<p>输出纯文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo Hello, World!</span><br></pre></td></tr></table></figure>
<p>这将在终端窗口中打印出 “Hello, World!”。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011310897.png" alt="image-20240301131005850" /></p>
</li>
<li>
<p>输出变量的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name=&quot;Alice&quot;</span><br><span class="line">echo My name is $name</span><br></pre></td></tr></table></figure>
<p>这将打印出 “My name is Alice”。在字符串中使用 <code>$</code> 可以引用变量的值。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011310800.png" alt="image-20240301131043755" /></p>
</li>
<li>
<p>输出多行文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Line 1</span><br><span class="line">Line 2</span><br><span class="line">Line 3&quot;</span><br></pre></td></tr></table></figure>
<p>这将打印出三行文本，每行一个。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011312183.png" alt="image-20240301131205132" /></p>
</li>
<li>
<p>不换行输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -n &quot;Hello, World!&quot;</span><br></pre></td></tr></table></figure>
<p>这将在同一行上输出 “Hello, World!”，因为使用了 <code>-n</code> 选项来禁止换行。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011320351.png" alt="image-20240301132045304" /></p>
<p>当将 <code>echo</code> 命令与重定向符号 (<code>&gt;&gt;</code> 和 <code>&gt;</code>) 结合使用时，可以将 <code>echo</code> 命令的输出内容追加到文件中或覆盖文件的内容。以下是这些组合命令的示例：</p>
<ol>
<li>
<p>追加内容到文件 (<code>&gt;&gt;</code>)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;This is some text.&quot; &gt;&gt; file.txt</span><br></pre></td></tr></table></figure>
<p>这将将文本 “This is some text.” 追加到名为 <code>file.txt</code> 的文件末尾。如果文件不存在，则会创建该文件，并将文本追加到其中。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011321703.png" alt="image-20240301132122652" /></p>
</li>
<li>
<p>覆盖文件内容 (<code>&gt;</code>)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;This is some text.&quot; &gt; file.txt</span><br></pre></td></tr></table></figure>
<p>这将创建或覆盖名为 <code>file.txt</code> 的文件，并将文本 “This is some text.” 写入其中。如果文件已经存在，它的内容将被替换为新的文本。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011321969.png" alt="image-20240301132142923" /></p>
</li>
</ol>
<p>这是对 <code>echo</code> 命令的详细解释和示例用法。希望这些信息能帮助你更好地理解和使用 <code>echo</code> 命令。</p>
</li>
</ol>
<h2 id="102-文件内容查看cat命令"><a class="markdownIt-Anchor" href="#102-文件内容查看cat命令"></a> 10.2 文件内容查看：cat命令</h2>
<p>在 Linux 和 Unix 系统中，<code>cat</code> 命令是一个常用的文件内容查看工具。它的名称来自于 “concatenate”（连接）的缩写，它的主要功能是将一个或多个文件的内容连接起来并输出到标准输出。除了连接文件，<code>cat</code> 命令还可以用于显示单个文件的内容和创建新文件。</p>
<p>下面是对 <code>cat</code> 命令的详细解释：</p>
<ol>
<li>
<p>显示单个文件的内容：<br />
最常见的用法是通过提供文件名作为参数来查看单个文件的内容。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt</span><br></pre></td></tr></table></figure>
<p>这将在终端上显示名为 <code>file.txt</code> 的文件的内容。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011326196.png" alt="image-20240301132602149" /></p>
</li>
<li>
<p>连接多个文件的内容：<br />
<code>cat</code> 命令还可以用于连接多个文件的内容并输出到标准输出。例如，要连接两个文件 <code>file1.txt</code> 和 <code>file2.txt</code> 的内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1.txt file2.txt</span><br></pre></td></tr></table></figure>
<p>这将按顺序连接两个文件的内容并输出到终端。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011328228.png" alt="image-20240301132817180" /></p>
</li>
<li>
<p>创建新文件：<br />
<code>cat</code> 命令还可以用于创建新文件。可以将一个或多个文件的内容重定向到一个新文件中。例如，要将文件 <code>file1.txt</code> 和 <code>file2.txt</code> 的内容合并到一个新文件 <code>newfile.txt</code> 中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1.txt file2.txt &gt; newfile.txt</span><br></pre></td></tr></table></figure>
<p>这将创建一个名为 <code>newfile.txt</code> 的新文件，并将 <code>file1.txt</code> 和 <code>file2.txt</code> 的内容连接起来写入新文件。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011328678.png" alt="image-20240301132848629" /></p>
</li>
<li>
<p>显示行号：<br />
使用 <code>-n</code> 选项，<code>cat</code> 命令可以显示每一行的行号。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n file.txt</span><br></pre></td></tr></table></figure>
<p>这将显示名为 <code>file.txt</code> 的文件的内容，并在每一行前显示行号。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011329476.png" alt="image-20240301132911428" /></p>
</li>
</ol>
<p>以上是对 <code>cat</code> 命令的详细解释。它是一个简单而强大的工具，用于查看文件内容、连接文件以及创建新文件。除了基本的文件内容查看外，<code>cat</code> 命令还支持一些选项，如显示行号和非打印字符，以及从标准输入读取数据。</p>
<h2 id="103-文件内容搜索grep命令"><a class="markdownIt-Anchor" href="#103-文件内容搜索grep命令"></a> 10.3 文件内容搜索：grep命令</h2>
<p>在 Linux 系统中，<code>grep</code> 命令是一个强大的文件内容搜索工具，全称为Global Regular Expression Print，表示全局正则表达式。它用于在文本文件中查找符合特定模式的行，并将匹配的行输出到标准输出。<code>grep</code> 命令支持使用正则表达式进行模式匹配，可以用于快速定位和筛选文件中的关键信息。</p>
<p>grep命令格式：grep [选项] 模式 [文件]</p>
<p>常用选项：</p>
<ul>
<li><code>-i</code>：不区分大小写地匹配模式。</li>
<li><code>-v</code>：显示不匹配模式的行。</li>
<li><code>-n</code>：显示匹配模式的行及其行号。</li>
<li><code>-r</code>：递归地搜索指定目录及其子目录下的文件。</li>
<li><code>-c</code>：统计匹配模式的行数。</li>
</ul>
<p>正则表达式相关选项：</p>
<ul>
<li><code>-E</code>：启用扩展正则表达式。</li>
<li><code>-F</code>：将模式视为固定字符串而不是正则表达式。</li>
</ul>
<p>其他常用选项：</p>
<ul>
<li><code>-w</code>：匹配整个单词而不是部分匹配。</li>
<li><code>-l</code>：只显示匹配模式的文件名。</li>
<li><code>-q</code>：静默模式，不显示任何输出。</li>
</ul>
<ol>
<li>
<p>基本用法：<br />
最简单的用法是通过提供要搜索的模式和文件名作为参数来查找匹配的行。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep pattern file.txt</span><br></pre></td></tr></table></figure>
<p>这将在名为 <code>file.txt</code> 的文件中搜索匹配 <code>pattern</code> 的行，并将匹配的行输出到终端。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011332180.png" alt="image-20240301133208134" /></p>
</li>
<li>
<p>正则表达式匹配：<br />
<code>grep</code> 命令支持使用正则表达式进行模式匹配。正则表达式可以用于更灵活和复杂的模式匹配。例如，要查找以 “apple” 开头的单词，可以使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;^this&#x27; file.txt</span><br></pre></td></tr></table></figure>
<p>这将匹配以 “this” 开头的行。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011333773.png" alt="image-20240301133313732" /></p>
</li>
<li>
<p>不区分大小写匹配：<br />
默认情况下，<code>grep</code> 命令是区分大小写的。使用 <code>-i</code> 选项可以进行不区分大小写的匹配。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i pattern file.txt</span><br></pre></td></tr></table></figure>
<p>这将在不区分大小写的情况下搜索匹配 <code>pattern</code> 的行。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011334075.png" alt="image-20240301133419032" /></p>
</li>
<li>
<p>显示匹配行数：<br />
使用 <code>-n</code> 选项，<code>grep</code> 命令可以显示匹配行的行号。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n pattern file.txt</span><br></pre></td></tr></table></figure>
<p>这将显示匹配 <code>pattern</code> 的行以及它们的行号。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011334150.png" alt="image-20240301133458111" /></p>
</li>
<li>
<p>反向匹配：<br />
使用 <code>-v</code> 选项，<code>grep</code> 命令可以查找不匹配模式的行。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v pattern file.txt</span><br></pre></td></tr></table></figure>
<p>这将显示不匹配 <code>pattern</code> 的行。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011335096.png" alt="image-20240301133525057" /></p>
</li>
<li>
<p>递归搜索：<br />
使用 <code>-r</code> 选项，<code>grep</code> 命令可以递归地搜索指定目录及其子目录下的文件。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r pattern directory/</span><br></pre></td></tr></table></figure>
<p>这将在 <code>directory/</code> 目录及其子目录下的文件中搜索匹配 <code>pattern</code> 的行。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011335813.png" alt="image-20240301133558773" /></p>
</li>
<li>
<p>统计匹配数量：<br />
使用 <code>-c</code> 选项，<code>grep</code> 命令可以统计匹配模式的行数。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -c pattern file.txt</span><br></pre></td></tr></table></figure>
<p>这将输出匹配 <code>pattern</code> 的行数。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011336330.png" alt="image-20240301133656289" /></p>
</li>
</ol>
<h2 id="104-查找文件find命令"><a class="markdownIt-Anchor" href="#104-查找文件find命令"></a> 10.4 查找文件：find命令</h2>
<p><code>find</code> 命令是在 Linux 系统中用于查找文件和目录的强大工具。它可以按照指定的条件在指定的路径下递归地搜索文件，并根据条件对搜索结果进行操作。<code>find</code> 命令提供了丰富的选项和表达式，用于满足各种查找需求。</p>
<p>下面是对 <code>find</code> 命令的详细解释：</p>
<ol>
<li>
<p>基本用法：<br />
最简单的用法是通过指定路径来查找文件。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/search</span><br></pre></td></tr></table></figure>
<p>这将在 <code>/path/to/search</code> 目录下递归地搜索所有文件和目录，并将它们的路径输出到标准输出。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011343076.png" alt="image-20240301134308034" /></p>
</li>
<li>
<p>按文件名查找：<br />
可以使用 <code>-name</code> 选项按文件名进行查找。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/search -name filename.txt</span><br></pre></td></tr></table></figure>
<p>这将在 <code>/path/to/search</code> 目录下查找名为 <code>filename.txt</code> 的文件。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011343221.png" alt="image-20240301134345183" /></p>
<p>注：如果不带路径默认就是从当前目录开始查找，举例如下所示：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011345521.png" alt="image-20240301134507481" /></p>
</li>
<li>
<p>按类型查找：<br />
可以使用 <code>-type</code> 选项按文件类型进行查找。常用的类型包括普通文件 (<code>f</code>)、目录 (<code>d</code>)、符号链接 (<code>l</code>) 等。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/search -type f</span><br></pre></td></tr></table></figure>
<p>这将在 <code>/path/to/search</code> 目录下查找所有普通文件。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011347033.png" alt="image-20240301134758986" /></p>
</li>
<li>
<p>按时间戳查找：<br />
可以使用 <code>-mtime</code>、<code>-ctime</code> 和 <code>-atime</code> 选项按文件的修改时间、创建时间和访问时间进行查找。可以使用指定天数的固定值或带有符号的值来指定时间范围。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/search -mtime -7</span><br></pre></td></tr></table></figure>
<p>这将在 <code>/path/to/search</code> 目录下查找在最近 7 天内修改过的文件。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011350328.png" alt="image-20240301135038282" /></p>
</li>
</ol>
<p>以上是对 <code>find</code> 命令的详细解释。它是一个功能强大且灵活的文件搜索工具，可用于按文件名、类型、大小、时间戳等条件进行搜索。通过灵活运用选项和表达式，可以满足各种不同的查找需求。<code>find</code> 命令还支持在搜索结果上执行各种操作，如执行命令、删除文件等。掌握了 <code>find</code> 命令，您可以高效地查找和操作文件和目录。</p>
<h1 id="11-链接命令ln"><a class="markdownIt-Anchor" href="#11-链接命令ln"></a> 11 链接命令:ln</h1>
<p><code>ln</code> 是 Linux 系统中的一个命令，用于创建链接（link）或符号链接（symbolic link）。链接是文件系统中的一个概念，它允许一个文件或目录引用另一个文件或目录，使得多个文件名指向同一个实际的文件或目录。<code>ln</code> 命令提供了创建硬链接和符号链接的功能。</p>
<p><strong>硬链接（Hard Link）：</strong><br />
硬链接是文件系统中的一个条目，它指向一个文件的索引节点（inode）。硬链接与原始文件有相同的 inode 号，它们共享文件的内容和属性。因此，对于用户来说，硬链接看起来就像是原始文件的另一个名称。删除原始文件不会影响硬链接，只有当所有指向该文件的硬链接和原始文件都被删除时，文件的内容才会被释放。</p>
<p><strong>符号链接（Symbolic Link）：</strong><br />
符号链接，也称为软链接或符号连接，是一个特殊类型的文件，它包含了指向另一个文件或目录的路径。符号链接实际上是一个指向目标文件或目录的快捷方式，类似于 Windows 系统中的快捷方式。通过符号链接，可以在不同的位置引用同一个文件或目录。删除原始文件或目录不会影响符号链接，但如果删除了符号链接所指向的目标文件或目录，则符号链接将变为坏链接。</p>
<p><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln [选项] &lt;目标文件&gt; [链接文件]</span><br></pre></td></tr></table></figure>
<p>**常用选项：**l是</p>
<ul>
<li><code>-s</code>：创建符号链接。如果不指定该选项，则创建硬链接。</li>
</ul>
<p><strong>示例用法：</strong></p>
<p>创建一个硬链接：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln 文件 目标链接文件</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403091611817.png" alt="image-20240309161111764" /></p>
<p>创建一个符号链接：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s 目标文件 目标链接文件</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403091611041.png" alt="image-20240309161131980" /></p>
<p>创建一个目录的符号链接：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s test_04 test_05</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403091612952.png" alt="image-20240309161238887" /></p>
<p>需要注意的是，硬链接不能链接目录，只能链接文件。</p>
<p>总结来说，<code>ln</code> 命令可以创建硬链接和符号链接，用于在文件系统中创建文件或目录之间的链接关系。硬链接共享文件的内容和属性，符号链接是一个指向目标的快捷方式。</p>
<h1 id="12-用户和权限管理"><a class="markdownIt-Anchor" href="#12-用户和权限管理"></a> 12 用户和权限管理</h1>
<h2 id="121-普通用户和root用户"><a class="markdownIt-Anchor" href="#121-普通用户和root用户"></a> 12.1 普通用户和root用户</h2>
<p>普通用户:指在Linux 系统中具有有限权限和资源访问权限的用户。普通用户在登录时会获得一个独立的用户账号，该账号有一个用户名和密码。普通用户可以在自己的主目录中创建和管理文件，运行属于自己的进程，但无法修改系统级别的配置文件和进行敏感操作，如安装软件、更改系统设置等。普通用户通常使用命令行终端或图形界面登录，并使用自己的用户名和密码进行身份验证。<br />
root用户: 指Linux 系统中具有完全访问权限和控制权的特殊用户。root 用户(也称系统管理员用户 )具有对系统的完全控制权，可以执行系统级别的操作，如修改配置文件、安装软件包、创建和删除用户账号等。</p>
<p>==注意：由于 root 用户具有如此高的权限，因此应该小心谨慎地使用，以免意外破坏系统或引发安全问题。==</p>
<h2 id="122-获取root权限sudo-命令"><a class="markdownIt-Anchor" href="#122-获取root权限sudo-命令"></a> 12.2 获取root权限：sudo 命令</h2>
<p>在 Linux 系统中，root 权限代表着最高的系统管理员权限，可以执行系统中的任何操作。然而，为了确保系统的安全性，直接以 root 用户身份登录并在此权限下工作是不被推荐的。相反，Linux 提供了一种安全的方法来获取 root 权限，即使用 <code>sudo</code> 命令。</p>
<p><code>sudo</code> 是 Linux 系统中的一个命令，允许普通用户以临时的方式获取 root 权限执行特权操作。下面是关于 <code>sudo</code> 命令的详细解释：</p>
<p>sudo 使用方法：<br />
在终端中，可以使用以下格式来运行需要 root 权限的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo command</span><br></pre></td></tr></table></figure>
<p>其中 <code>command</code> 是您要执行的命令。执行此命令后，系统会要求您输入当前用户的密码（而不是 root 用户的密码）。输入密码后，如果您的用户被授权使用 sudo，命令将以 root 权限执行。<br />
通过使用 <code>sudo</code> 命令，普通用户可以在 Linux 系统中临时获取 root 权限执行特权操作。通过编辑 sudoers 文件，可以定义哪些用户或用户组被授权使用 sudo。使用 <code>sudo</code> 命令时，用户需要输入当前用户的密码来验证身份。这种方法提供了一种安全的方式来获取 root 权限，同时限制了对系统的潜在风险。</p>
<h2 id="123-用户切换su-和exit命令"><a class="markdownIt-Anchor" href="#123-用户切换su-和exit命令"></a> 12.3 用户切换：su 和exit命令</h2>
<p>如果我们并没有设置过root用户的密码，如果想要登录root用户需要先使用以下命令设置一下root用户密码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011433137.png" alt="image-20240301143353097" /></p>
<ol>
<li>
<p><code>su</code> 命令切换用户：<br />
在 Linux 系统中，可以使用 <code>su</code> 命令（代表 “switch user”）以系统管理员身份切换到其他用户。<code>su</code> 命令允许一个用户以另一个用户的身份登录，前提是输入正确的目标用户密码。</p>
<p>使用 <code>su</code> 命令切换到系统管理员用户（即 root 用户）时，不需要指定目标用户。只需输入以下命令并输入 root 用户的密码即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -</span><br></pre></td></tr></table></figure>
<p>这将立即切换到 root 用户。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011435813.png" alt="image-20240301143513777" /></p>
<p>要以系统管理员身份切换到其他用户，可以使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - target_user</span><br></pre></td></tr></table></figure>
<p>其中 <code>target_user</code> 是您要切换到的目标用户的用户名。执行此命令后，您将被要求输入目标用户的密码。如果输入的密码正确，您将切换到目标用户，并进入其主目录。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011435883.png" alt="image-20240301143530847" /></p>
<p>==注：也可以不加-进行用户之间的切换，两者的区别在于会不会重新加载环境变量==</p>
</li>
<li>
<p><code>exit</code> 命令退出用户：<br />
在 Linux 系统中，使用 <code>exit</code> 命令可以退出当前用户并返回到上一个用户或登录界面。这对于从系统管理员用户切换回普通用户非常有用。</p>
<p>要退出当前用户，只需在命令行终端中输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>
<p>执行此命令后，您将退出当前用户，并返回到上一个用户。如果当前用户是系统管理员用户（root 用户），则退出后将返回到上一个用户，通常是上一个普通用户或登录界面。</p>
<p>请注意，使用 <code>exit</code> 命令退出系统管理员用户时，不会关闭整个系统或终端窗口，只是将您切换回先前的用户身份。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011440003.png" alt="image-20240301144034957" /></p>
</li>
</ol>
<p>总结：<br />
在 Linux 系统中，普在Linux系统中，普通用户和系统管理员用户（也称为超级用户）是两种不同的用户角色，具有不同的权限和访问级别。下面我将详细解释Linux系统中的普通用户和系统管理员用户，并说明如何使用<code>su</code>用户切换和<code>exit</code>命令退出。</p>
<h2 id="124-文件权限介绍"><a class="markdownIt-Anchor" href="#124-文件权限介绍"></a> 12.4 文件权限介绍</h2>
<p>在 Linux 系统中，文件权限是用于控制对文件或目录的访问权限的机制。文件权限由三个基本权限组成：所有者权限、组权限和其他用户权限。每个权限组都可以设置为读取（r）、写入（w）和执行（x）的状态。如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403121356899.png" alt="image-20240312135548743" /></p>
<p>下面是对 Linux 中文件权限的详细介绍：</p>
<ol>
<li>
<p>文件权限表示方式：<br />
Linux 中的文件权限可以使用符号表示法或数字表示法来表示。</p>
<ul>
<li>符号表示法：使用字符 <code>r</code>、<code>w</code> 和 <code>x</code> 表示读、写和执行权限，使用 <code>-</code> 表示没有相应的权限。一组完整的文件权限为：<code>rwxrwxrwx</code>，分别表示所有者权限、组权限和其他用户权限。</li>
<li>数字表示法：使用 3 位八进制数字来表示权限。每个权限组有一个数字，分别对应读（4）、写（2）和执行（1）权限的值。将所需权限的值相加，即可表示权限组的数字。例如，<code>rwxr-xr--</code> 的数字表示为 754。</li>
</ul>
</li>
<li>
<p>文件权限组：</p>
<ul>
<li>所有者权限：所有者权限适用于文件或目录的所有者。文件的所有者通常是创建该文件的用户。所有者权限控制着对文件的读、写和执行操作。</li>
<li>组权限：组权限适用于文件或目录所属的用户组。用户组是一组用户的集合，可以在创建文件时指定。组权限控制着属于同一用户组的成员对文件的读、写和执行操作。</li>
<li>其他用户权限：其他用户权限适用于除了文件所有者和所属用户组之外的其他用户。其他用户权限控制着非所有者和非所属用户组成员对文件的读、写和执行操作。</li>
</ul>
</li>
<li>
<p>文件权限状态：</p>
<ul>
<li>读权限（r）：允许用户查看文件内容、目录中的文件列表和文件属性。</li>
<li>写权限（w）：允许用户修改文件内容、创建、重命名或删除文件。</li>
<li>执行权限（x）：对于文件，允许用户执行文件（如果是脚本或可执行程序）。对于目录，允许用户进入目录并访问其中的文件。</li>
</ul>
</li>
<li>
<p>示例：<br />
以下是一些示例，展示了不同文件权限组合的含义：</p>
<ul>
<li><code>-rw-r--r--</code>：文件所有者具有读写权限，组成员和其他用户具有只读权限。</li>
<li><code>drwxr-xr-x</code>：目录所有者具有读、写和执行权限，组成员和其他用户具有读和执行权限。</li>
<li><code>-rw-rw----</code>：文件所有者和组成员具有读写权限，其他用户没有任何权限。</li>
</ul>
<p>​        Linux 中的文件权限是用于控制对文件或目录的访问权限的机制。它由所有者权限、组权限和其他用户权限组成，每个权限组可以设置为读、写和执行的状态。文件权限可以使用符号表示法或数字表示法来表示，并可以使用 <code>chmod</code> 命令进行更改。了解和正确设置文件权限是保护文件和系统安全的重要步骤。</p>
</li>
</ol>
<h2 id="125-权限修改chmod命令"><a class="markdownIt-Anchor" href="#125-权限修改chmod命令"></a> 12.5 权限修改：chmod命令</h2>
<p><code>chmod</code> 是一个在 Linux系统中的常用命令，用于更改文件或目录的读取、写入和执行权限。下面是对 <code>chmod</code> 命令的详细解释：</p>
<ol>
<li>
<p>基本语法：<br />
<code>chmod</code> 命令的基本语法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod options permissions filename</span><br></pre></td></tr></table></figure>
<ul>
<li><code>options</code>：用于指定不同的选项，比如递归修改权限、使用符号链接等。</li>
<li><code>permissions</code>：表示要设置的权限，可以使用符号表示法或数字表示法。</li>
<li><code>filename</code>：要修改权限的文件或目录的名称。</li>
</ul>
</li>
<li>
<p>符号表示法：<br />
<code>chmod</code> 命令可以使用符号表示法来指定要设置的权限，符号表示法由三部分组成分别为要操作的权限组、操作符以及要指定的权限，具体如下所示：</p>
<p><strong>权限组：</strong></p>
<ul>
<li><code>u</code>：表示文件所有者。</li>
<li><code>g</code>：表示文件所属用户组。</li>
<li><code>o</code>：表示其他用户。</li>
<li><code>a</code>：表示所有用户，相当于 <code>u + g + o</code>。</li>
</ul>
<p><strong>操作符：</strong></p>
<ul>
<li><code>+</code>：添加指定权限。</li>
<li><code>-</code>：移除指定权限。</li>
<li><code>=</code>：设置指定权限，覆盖所有其他权限。</li>
</ul>
<p><strong>指定权限：</strong></p>
<ul>
<li><code>r</code>：读权限</li>
<li><code>w</code>：写权限</li>
<li><code>x</code>：执行权限</li>
</ul>
<p>例如，以下命令将给文件所有者添加写权限：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+w filename</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>数字表示法：<br />
<code>chmod</code> 命令也可以使用数字表示法来指定权限。每个权限用一个数字表示，读权限为 4，写权限为 2，执行权限为 1。将所需权限的数字相加，即可表示权限组的数字。</p>
<table>
<thead>
<tr>
<th style="text-align:left">权限项</th>
<th style="text-align:left">字符表示</th>
<th style="text-align:left">数字表示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">读权限</td>
<td style="text-align:left">r</td>
<td style="text-align:left">4</td>
</tr>
<tr>
<td style="text-align:left">写权限</td>
<td style="text-align:left">w</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">执行权限</td>
<td style="text-align:left">x</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">没有权限</td>
<td style="text-align:left">-</td>
<td style="text-align:left">0</td>
</tr>
</tbody>
</table>
<p>例如，以下命令将给文件所有者读、写和执行权限（4 + 2 + 1 = 7）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 filename</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>递归修改权限：<br />
使用 <code>-R</code> 选项，可以递归地修改目录及其子目录中的文件和目录的权限。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 755 directory</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例：</p>
<ul>
<li><code>chmod u+w file.txt</code>：给文件所有者添加写权限。</li>
<li><code>chmod go-rwx file.txt</code>：移除组和其他用户的读、写和执行权限。</li>
<li><code>chmod 644 file.txt</code>：将文件权限设置为 <code>-rw-r--r--</code>。</li>
<li><code>chmod -R 755 directory</code>：递归地将目录及其子目录中的文件和目录权限设置为 <code>-rwxr-xr-x</code>。</li>
<li><code>chmod 4755 executable</code>：设置可执行文件的 SUID 位。</li>
</ul>
</li>
</ol>
<p>总结：<br />
<code>chmod</code> 命令是用于修改文件或目录权限的命令。它支持符号表示法和数字表示法来指定权限。通过添加、移除或设置权限，可以控制谁可以读取、写入和执行文件。此外，<code>chmod</code> 命令还支持递归修改权限和设置特殊权限如 SUID、SGID 和粘滞位。正确设置文件权限是保护文件和系统安全的重要措施。</p>
<h1 id="13-压缩和解压缩"><a class="markdownIt-Anchor" href="#13-压缩和解压缩"></a> 13 压缩和解压缩</h1>
<h2 id="131-zip-unzip命令"><a class="markdownIt-Anchor" href="#131-zip-unzip命令"></a> 13.1 zip unzip命令</h2>
<p><code>zip</code> 和 <code>unzip</code> 是常用的命令行工具。它们用于创建和提取 ZIP 格式的归档文件，这是一种常见的跨平台压缩格式。下面是对 <code>zip</code> 和 <code>unzip</code> 命令的详细解释：</p>
<p><strong>1. zip 命令：</strong></p>
<p><code>zip</code> 命令用于创建 ZIP 归档文件。下面是 <code>zip</code> 命令的基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip [选项] 归档文件 文件...</span><br></pre></td></tr></table></figure>
<ul>
<li><code>[选项]</code>：可以使用不同的选项来自定义 <code>zip</code> 命令的行为，例如压缩级别、密码保护等。</li>
<li><code>归档文件</code>：指定要创建的 ZIP 归档文件的名称。</li>
<li><code>文件...</code>：指定要添加到归档文件中的文件列表。</li>
</ul>
<p>下面是一些常见的 <code>zip</code> 命令选项：</p>
<ul>
<li><code>-r</code>：递归地将目录和其内容添加到归档文件中。</li>
</ul>
<p>示例用法：</p>
<ul>
<li>
<p>创建名为 <code>archive.zip</code> 的归档文件，将 <code>file1.txt</code> 和 <code>file2.txt</code> 添加到其中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip archive.zip file1.txt file2.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403141550949.png" alt="image-20240314155010875" /></p>
</li>
<li>
<p>递归地创建名为 <code>archive.zip</code> 的归档文件，将 <code>dir1</code> 目录及其内容添加到其中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r archive.zip dir1</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403141551588.png" alt="image-20240314155127533" /></p>
</li>
</ul>
<p><strong>2. unzip 命令：</strong></p>
<p><code>unzip</code> 命令用于从 ZIP 归档文件中提取文件。下面是 <code>unzip</code> 命令的基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip [选项] 归档文件 [-d 目标目录]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>[选项]</code>：可以使用不同的选项来自定义 <code>unzip</code> 命令的行为，例如解压到指定目录、覆盖文件等。</li>
<li><code>归档文件</code>：指定要提取文件的 ZIP 归档文件的名称。</li>
<li><code>-d 目标目录</code>：可选参数，指定要解压到的目标目录。</li>
</ul>
<p>示例用法：</p>
<ul>
<li>
<p>解压名为 <code>archive.zip</code> 的归档文件到当前目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip archive.zip</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403141552123.png" alt="image-20240314155210070" /></p>
</li>
<li>
<p>解压名为 <code>archive.zip</code> 的归档文件到指定目录 <code>target_dir</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip archive.zip -d target_dir</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403141552756.png" alt="image-20240314155250695" /></p>
</li>
</ul>
<h2 id="132-tar命令"><a class="markdownIt-Anchor" href="#132-tar命令"></a> 13.2 tar命令</h2>
<p><code>tar</code> 命令在Linux系统中是一个常用的文件压缩和归档工具。它可以将多个文件和目录打包成一个单独的文件，也可以从归档文件中提取文件和目录。<code>tar</code> 命令支持多种压缩和解压缩算法，如无压缩的 tar 归档、gzip 压缩的 tar 归档、bzip2 压缩的 tar 归档等。</p>
<p>下面是对 <code>tar</code> 命令的详细解释：</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar [选项] [归档文件] [文件/目录列表]</span><br></pre></td></tr></table></figure>
<p>选项：</p>
<p>(1):通用选项</p>
<p>​	<code>-v</code>：显示详细的操作过程。</p>
<p>​	<code>-f</code>：指定归档文件的名称。</p>
<p>(2):压缩选项</p>
<p>​	<code>-c</code>：创建归档文件。</p>
<p>​	<code>-z</code>：使用 gzip 压缩/解压缩归档文件。</p>
<p>​	<code>-j</code>：使用 bzip2 压缩/解压缩归档文件。</p>
<p>​	<code>-J</code>：使用 xz 压缩/解压缩归档文件。</p>
<p>(3):解压选项</p>
<p>​	<code>-x</code>：从归档文件中提取文件。</p>
<p>​	<code>-C</code>：切换到指定的目录后执行操作。</p>
<p>归档文件：要创建、提取或操作的目标归档文件的名称。</p>
<p>文件/目录列表：要包含在归档文件中的文件或目录的列表。</p>
<p>示例用法：</p>
<ol>
<li>
<p>创建归档文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf archive.tar file1.txt file2.txt directory/</span><br></pre></td></tr></table></figure>
<p>这将创建名为 <code>archive.tar</code> 的归档文件，并将 <code>file1.txt</code>、<code>file2.txt</code> 和 <code>directory</code> 目录添加到归档文件中。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011451516.png" alt="image-20240301145124464" /></p>
</li>
<li>
<p>提取归档文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf archive.tar</span><br></pre></td></tr></table></figure>
<p>这将从名为 <code>archive.tar</code> 的归档文件中提取所有文件和目录。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011452415.png" alt="image-20240301145219361" /></p>
</li>
<li>
<p>列出归档文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tvf archive.tar</span><br></pre></td></tr></table></figure>
<p>这将列出名为 <code>archive.tar</code> 的归档文件中包含的所有文件和目录。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011456093.png" alt="image-20240301145617049" /></p>
</li>
<li>
<p>创建并压缩归档文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf archive.tar.gz file1.txt file2.txt directory/</span><br></pre></td></tr></table></figure>
<p>这将创建名为 <code>archive.tar.gz</code> 的 gzip 压缩的归档文件，并将指定的文件和目录添加到其中。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011459893.png" alt="image-20240301145957842" /></p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011501878.png" alt="image-20240301150107829" /></p>
</li>
<li>
<p>解压缩并提取归档文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf archive.tar.gz</span><br></pre></td></tr></table></figure>
<p>这将解压缩并从名为 <code>archive.tar.gz</code> 的 gzip 压缩的归档文件中提取所有文件和目录。</p>
</li>
</ol>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011505129.png" alt="image-20240301150558077" /></p>
<p>而默认情况下tar 的-x归档提取选项可以自动识别并解压各种，所以无论是解压何种格式的归档压缩包如gzip、bzip2或xz，其实都可以直接使用tar -vxf 来进行解压，如下所示：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403011513761.png" alt="image-20240301151326708" /></p>
<h1 id="14-磁盘管理和挂载"><a class="markdownIt-Anchor" href="#14-磁盘管理和挂载"></a> 14 磁盘管理和挂载</h1>
<h2 id="141-磁盘空间使用情况df命令"><a class="markdownIt-Anchor" href="#141-磁盘空间使用情况df命令"></a> 14.1 磁盘空间使用情况：df命令</h2>
<p><code>df</code>（磁盘空间使用情况）是一个常用的Linux命令，用于显示文件系统的磁盘空间使用情况。它可以列出文件系统的大小、已用空间、可用空间和使用百分比等信息。</p>
<p>以下是<code>df</code>命令的详细用法及选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df [选项] [文件或目录]</span><br></pre></td></tr></table></figure>
<p>常用的选项包括：</p>
<ul>
<li><code>-h</code>：以人类可读的格式显示磁盘空间，例如以K、M、G为单位，更易于阅读。</li>
<li><code>-T</code>：显示文件系统类型。</li>
</ul>
<p>如果不指定文件或目录参数，<code>df</code>命令将显示系统中所有已挂载文件系统的磁盘空间使用情况。</p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>
<p>这将以人类可读的格式显示所有已挂载文件系统的磁盘空间使用情况。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161404493.png" alt="image-20240316140428427" /></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h /dev/sda3</span><br></pre></td></tr></table></figure>
<p>这将以人类可读的格式显示<code>/dev/sda3</code>文件系统的磁盘空间使用情况。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161404934.png" alt="image-20240316140457891" /></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -T</span><br></pre></td></tr></table></figure>
<p>这将显示所有已挂载文件系统的磁盘空间使用情况，并显示文件系统的类型。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161405909.png" alt="image-20240316140529845" /></p>
<h2 id="142-磁盘使用情况du命令"><a class="markdownIt-Anchor" href="#142-磁盘使用情况du命令"></a> 14.2 磁盘使用情况：du命令</h2>
<p><code>du</code>（磁盘使用情况）是一个常用的Linux命令，用于显示目录或文件的磁盘使用情况。它可以递归地计算目录及其子目录的大小，并提供各个目录和文件的磁盘空间使用情况。</p>
<p>以下是 <code>du</code> 命令的详细用法及选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du [选项] [目录或文件]</span><br></pre></td></tr></table></figure>
<p>常用的选项包括：</p>
<ul>
<li><code>-h</code>：以人类可读的格式显示磁盘使用情况，例如以K、M、G为单位，更易于阅读。</li>
<li><code>-s</code>：仅显示总计信息，而不显示每个目录和文件的详细情况。</li>
<li><code>--max-depth=&lt;深度&gt;</code>：限制递归显示的目录深度。</li>
</ul>
<p>如果不指定目录或文件参数，默认情况下 <code>du</code> 命令将显示当前目录的磁盘使用情况。</p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h</span><br></pre></td></tr></table></figure>
<p>这将以人类可读的格式显示当前目录及其子目录的磁盘使用情况。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161407970.png" alt="image-20240316140713925" /></p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161410855.png" alt="image-20240316141046815" /></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h /path/to/directory</span><br></pre></td></tr></table></figure>
<p>这将以人类可读的格式显示指定目录及其子目录的磁盘使用情况。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161410167.png" alt="image-20240316141025129" /></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh /path/to/directory</span><br></pre></td></tr></table></figure>
<p>这将仅显示指定目录的总计磁盘使用情况，而不显示每个目录和文件的详细情况。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161412338.png" alt="image-20240316141207289" /></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h --max-depth=1</span><br></pre></td></tr></table></figure>
<p>这将以人类可读的格式显示当前目录的直接子目录的磁盘使用情况。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161412325.png" alt="image-20240316141229244" /></p>
<p><code>du</code> 命令对于查看目录和文件的磁盘使用情况非常有用，有助于识别磁盘空间消耗最高的目录和文件，并进行磁盘空间管理和优化。它还可以用于监控特定目录或文件的磁盘使用情况的变化，并用于识别磁盘空间不断增长的问题。</p>
<h2 id="143-磁盘分区fdisk命令"><a class="markdownIt-Anchor" href="#143-磁盘分区fdisk命令"></a> 14.3 磁盘分区：fdisk命令</h2>
<p><code>fdisk</code>命令是一个用于分区磁盘的命令行工具，可用于创建、修改和删除磁盘分区。它在Linux系统中被广泛使用，是管理磁盘和分区的重要工具之一。</p>
<p>以下是<code>fdisk</code>命令的详细用法及选项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk [选项] &lt;设备&gt;</span><br></pre></td></tr></table></figure>
<p>常用的选项包括：</p>
<ul>
<li><code>-l</code>：列出指定设备的分区表信息，而不进行修改。可以使用<code>fdisk -l</code>来查看系统中所有磁盘和分区的信息。</li>
<li><code>-n</code>：创建一个新的分区。使用该选项可以进入分区创建模式，按照提示逐步创建新的分区。</li>
<li><code>-d</code>：删除指定的分区。根据提示选择要删除的分区序号，然后确认删除操作。</li>
<li><code>-p</code>：打印指定设备的分区表信息，包括分区的起始扇区、大小、文件系统类型等。</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l /dev/sda</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161356278.png" alt="image-20240316135627211" /></p>
<p><code>fdisk</code>命令提供了一种交互式的方式来管理磁盘分区。它允许用户创建、修改和删除磁盘分区，以及查看磁盘分区的信息。在使用<code>fdisk</code>命令时要非常小心，因为错误的操作可能导致数据丢失或磁盘不可用。在对重要数据进行分区操作之前，务必备份数据，并仔细阅读并理解<code>fdisk</code>命令的使用文档或相关指南。</p>
<h2 id="144-磁盘挂载和移除mount-和umount-命令"><a class="markdownIt-Anchor" href="#144-磁盘挂载和移除mount-和umount-命令"></a> 14.4 磁盘挂载和移除：mount 和umount 命令</h2>
<p><strong>(1) mount:</strong></p>
<p><code>mount</code>命令用于将磁盘或文件系统挂载到指定的挂载点（目录）上，使得磁盘中的数据可在该挂载点处访问。它是Linux系统中常用的命令之一，对于管理文件系统和挂载点非常重要。</p>
<p><code>mount</code>命令的详细用法及选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [选项] &lt;设备&gt; &lt;挂载点&gt;</span><br></pre></td></tr></table></figure>
<p>常用选项：</p>
<ul>
<li><code>-t &lt;文件系统类型&gt;</code>：指定要挂载的文件系统类型，如ext4、ntfs、vfat等。如果未指定该选项，则<code>mount</code>命令会尝试自动检测文件系统类型。</li>
<li><code>-o &lt;选项列表&gt;</code>：指定文件系统的挂载选项，如读写权限、访问控制等。选项列表以逗号分隔，常见的选项包括<code>ro</code>（只读）、<code>rw</code>（读写）、<code>noexec</code>（禁止执行程序）等。具体的选项取决于文件系统类型和操作系统。</li>
</ul>
<p>如果不指定任何选项，<code>mount</code>命令会尝试按照默认设置进行挂载。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdb /mnt</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161447219.png" alt="image-20240316144751163" /></p>
<p>挂载成功之后，使用<code>df -h</code>命令查看系统磁盘挂载情况，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161448820.png" alt="image-20240316144852726" /></p>
<p><code>mount</code>命令在管理文件系统和挂载点时非常有用，它允许将不同类型的文件系统挂载到指定的目录上，使得这些文件系统中的数据可以在相应的挂载点处访问。它还可以用于自动挂载在系统启动时需要挂载的文件系统，以确保系统正常运行所需的文件系统可用。</p>
<p><strong>(2) umount:</strong></p>
<p><code>umount</code>命令用于卸载（解除挂载）已挂载的磁盘和文件系统。当文件系统不再需要访问或需要卸载磁盘驱动器以安全地移除设备时，就可以使用<code>umount</code>命令将其从挂载点上卸载。</p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount [选项] &lt;挂载点&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount /mnt</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161453232.png" alt="image-20240316145300164" /></p>
<p><code>umount</code>命令在管理文件系统和挂载点时非常有用，它允许安全地卸载已挂载的文件系统，确保数据的完整性和文件系统的一致性。在卸载文件系统之前，应确保文件系统不再被访问或使用，并且没有任何打开的文件或进程正在使用该文件系统。</p>
<h1 id="15-软件包管理apt命令"><a class="markdownIt-Anchor" href="#15-软件包管理apt命令"></a> 15 软件包管理：apt命令</h1>
<p><code>apt</code>（Advanced Package Tool）是Ubuntu中的高级包管理工具。它是一个命令行工具，用于管理软件包，包括安装、升级、删除和搜索软件包，以及处理软件包之间的依赖关系。<code>apt</code>命令是<code>apt-get</code>和<code>apt-cache</code>两个工具的替代品，提供了更简洁和用户友好的界面。</p>
<p>apt命令格式：apt &lt;命令&gt;   [选项] [软件包]</p>
<p>常用的命令包括：</p>
<ul>
<li>
<p><code>update</code>：更新本地软件包列表。它会从软件源中获取最新的软件包信息，以便后续的软件包管理操作。</p>
</li>
<li>
<p><code>upgrade</code>：升级系统中所有已安装的软件包到最新版本。</p>
</li>
<li>
<p><code>install</code>：安装一个或多个软件包。可以同时安装多个软件包，软件包的名称由空格分隔。</p>
</li>
<li>
<p><code>remove</code>：移除一个或多个已安装的软件包。与<code>install</code>命令类似，可以同时移除多个软件包。</p>
</li>
<li>
<p><code>autoremove</code>：自动移除不再被其他软件包所依赖的已安装软件包。</p>
</li>
</ul>
<h2 id="151-更换软件源"><a class="markdownIt-Anchor" href="#151-更换软件源"></a> 15.1 更换软件源</h2>
<p>ubuntu系统安装成功之后，默认会使用ubuntu的官方源，可以通过<code>cat /etc/apt/sources.list</code>对当前源进行查看，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161528695.png" alt="image-20240316152819594" /></p>
<p>然而ubuntu的官方源可能基于地理位置或网络环境的原因，导致下载速度较慢，从而影响软件包的更新和安装速度，部分ubuntu国内源地址如下所示：</p>
<p>阿里云ubuntu源：<a target="_blank" rel="noopener" href="https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.3e221b11TblmXK">https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.3e221b11TblmXK</a></p>
<p>清华大学ubuntu源：<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</a></p>
<p>华为云ubuntu源：<a target="_blank" rel="noopener" href="https://mirrors.huaweicloud.com/mirrorDetail/5ea14ecab05943f36fb75ee7?mirrorName=ubuntu&amp;catalog=os">https://mirrors.huaweicloud.com/mirrorDetail/5ea14ecab05943f36fb75ee7?mirrorName=ubuntu&amp;catalog=os</a></p>
<p>这里以阿里云ubuntu源为例进行演示替换，首先打开上面的阿里云ubuntu源网址，进入网站之后如下所示：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161601959.png" alt="image-20240316160106808" />	然后找到ubuntu 22.04 LTS的源如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161601001.png" alt="image-20240316160144947" /></p>
<p>然后在终端输入以下命令打开apt的软件源配置文件如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161613601.png" alt="image-20240316161302514" /></p>
<p>然后将上面获取得到的阿里云ubuntu 22.04 LTS源覆盖掉当前内容，覆盖完成如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161615305.png" alt="image-20240316161543237" /></p>
<p>​	保存退出之后，使用以下命令更新软件源信息，如下图所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161625732.png" alt="image-20240316162533662" /></p>
<p>至此，软件源就替换成功了。软件源替换完成之后，可以输入以下命令升级系统中所有已安装的软件包到最新版本，如下图所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161656747.png" alt="image-20240316165606558" /></p>
<h2 id="152-软件安装"><a class="markdownIt-Anchor" href="#152-软件安装"></a> 15.2 软件安装</h2>
<p><code>apt install</code>命令是在Ubuntu及其衍生版本中用于安装软件包的命令。它可以从软件仓库中下载并安装指定的软件包及其依赖项。</p>
<p>命令结构：apt install [选项] 软件包</p>
<p>常用选项：</p>
<ul>
<li><code>-y</code>或<code>--yes</code>：自动回答&quot;是&quot;，省去确认安装的提示，适合自动化脚本。</li>
</ul>
<p>安装单个软件包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nfs-kernel-server </span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161707811.png" alt="image-20240316170713744" /></p>
<p>安装多个软件包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install package1 package2 package3</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161717435.png" alt="image-20240316171706340" /></p>
<p>自动回答&quot;是&quot;并安装软件包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y package</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161717043.png" alt="image-20240316171727951" /></p>
<h2 id="153-软件卸载"><a class="markdownIt-Anchor" href="#153-软件卸载"></a> 15.3 软件卸载</h2>
<p><code>apt remove</code>命令用于在Ubuntu及其衍生版本中卸载已安装的软件包。它可以从系统中移除指定的软件包及其相关的配置文件。</p>
<p>命令结构：apt remove [选项] 软件包</p>
<p>常用选项：</p>
<ul>
<li><code>-y</code>或<code>--yes</code>：自动回答&quot;是&quot;，省去确认卸载的提示，适合自动化脚本。</li>
</ul>
<p>具体示例：</p>
<p>卸载单个软件包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove nfs-kernel-server</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161718767.png" alt="image-20240316171857713" /></p>
<p>卸载多个软件包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove package1 package2 package3</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161719754.png" alt="image-20240316171923664" /></p>
<p>自动回答&quot;是&quot;并卸载软件包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove -y package</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403161719947.png" alt="image-20240316171943847" /></p>
<h1 id="16-认识shell编程"><a class="markdownIt-Anchor" href="#16-认识shell编程"></a> 16 认识shell编程</h1>
<h2 id="161-什么是shell"><a class="markdownIt-Anchor" href="#161-什么是shell"></a> 16.1 什么是shell？</h2>
<p>Shell（外壳）是Linux操作系统的一种命令行解释器，它提供了用户与操作系统内核进行交互的接口。通过 Shell，用户可以输入命令并与操作系统进行通信，执行各种操作，如运行程序、管理文件、配置系统等。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403261646565.png" alt="image-20240326164647520" /></p>
<p>Shell 是一个程序，它接受用户输入的命令，并将这些命令解释为操作系统可以理解和执行的指令。Shell 有两种工作模式：交互式模式和批处理模式。</p>
<ol>
<li>
<p>交互式模式（Interactive Mode）：在交互式模式下，用户可以直接在终端与 Shell 进行交互。用户可以逐行输入命令，并立即查看和处理命令的输出结果。Shell 在接收到用户输入后会立即解释和执行相应的命令，并将结果输出到终端。</p>
<p>交互式模式适用于用户需要直接与 Shell 进行互动、执行单个命令或进行实时操作的情况。用户可以在终端中逐步输入命令，根据输出结果进行进一步的操作或决策。</p>
</li>
<li>
<p>批处理模式（Batch Mode）：在批处理模式下，Shell 从一个脚本文件中逐行读取并执行命令，而不需要用户的实时输入和交互。用户事先编写好一系列的命令，并将它们保存在一个脚本文件中。然后，用户可以通过执行脚本文件来自动运行其中的命令。</p>
<p>批处理模式适用于用户需要自动化执行一系列命令、进行批量处理或重复性任务的情况。用户可以编写包含一系列命令的脚本文件，并通过运行脚本文件来批量执行这些命令，无需手动逐个输入。</p>
</li>
</ol>
<h2 id="162-更改默认的-shell"><a class="markdownIt-Anchor" href="#162-更改默认的-shell"></a> 16.2 更改默认的 Shell</h2>
<p>可以在终端输入<code>echo $SHELL</code>来打印当前系统使用的shell解析器。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403261649151.png" alt="image-20240326164930112" /></p>
<p>查看系统中全部的shell解析器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403271438419.png" alt="image-20240327143825358" /></p>
<p>可以看到除了bash之外还有sh rbash dash，除了这些之外也可也自行下载其他shell，就比如可以通过以下命令安卓现在非常流行的zsh，如下图所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zsh</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403271448669.png" alt="image-20240327144814524" /></p>
<p>chsh（Change Shell）命令用于更改用户的默认登录 Shell（解析器）。它允许用户选择不同于默认 Shell 的替代 Shell，以满足其个人偏好或特定需求。</p>
<p><strong>命令格式：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh [选项] [用户名]</span><br></pre></td></tr></table></figure>
<p><strong>常用选项：</strong></p>
<ul>
<li><code>-s, --shell SHELL</code>: 指定要更改为的新 Shell。可以提供 Shell 的完整路径或简单的 Shell 名称。例如，<code>-s /bin/zsh</code> 或 <code>-s zsh</code>。</li>
</ul>
<p>Bash（Bourne Again Shell）作为默认解释器被广泛使用的原因有以下几点：</p>
<ol>
<li><strong>广泛的兼容性：</strong> Bash 是 Bourne Shell（sh）的增强版本，它在语法和功能上向后兼容。这意味着大多数编写为 Bourne Shell 脚本的程序可以在 Bash 中无需或仅需少量修改就能运行。因此，Bash 具有广泛的兼容性，可以运行许多旧有的脚本和程序。</li>
<li><strong>广泛的支持和社区：</strong> Bash 是使用最广泛的 Shell 解释器之一，因此拥有一个庞大的用户社区和支持系统。用户可以轻松地找到文档、教程和解决方案，以解决他们在使用 Bash 过程中遇到的问题。此外，由于其流行性，许多第三方工具和软件都提供了对 Bash 的良好支持和集成。</li>
<li><strong>强大的功能和灵活性：</strong> Bash 提供了许多功能和特性，使得在命令行下的交互和脚本编写变得更加方便和强大。例如，Bash 支持通配符和通配符扩展、命令替换、条件语句和循环结构等。这些功能使得用户能够更高效地操作文件和目录、进行条件判断和控制流程，以及编写复杂的脚本来完成特定的任务。</li>
<li><strong>跨平台支持：</strong> Bash 不仅在 Linux 系统中广泛使用，还可以在其他操作系统（如 macOS 和 Windows）上运行。这种跨平台支持使得开发人员可以编写一次脚本，并在不同的操作系统上使用相同的解释器运行，无需进行大量的修改和适配。</li>
<li><strong>默认安装和使用便捷性：</strong> Bash 通常作为许多 Linux 发行版和 macOS 的默认 Shell 解释器安装。这意味着用户可以直接使用 Bash，无需额外的安装步骤。对于初学者来说，这种默认安装可以提供一个直接开始学习和使用 Shell 的平台，降低了使用门槛。</li>
</ol>
<h2 id="163-shell内置命令"><a class="markdownIt-Anchor" href="#163-shell内置命令"></a> 16.3 Shell内置命令</h2>
<p>在Shell中，存在两种类型的命令：内置命令（Built-in Commands）和外部命令（External Commands）。</p>
<p><strong>内置命令</strong>是直接嵌入在 Shell 解释器中的命令。这意味着 Shell 解释器本身提供了这些命令的实现，无需调用外部程序。由于内置命令直接在 Shell 解释器中执行，因此它们的执行速度通常比外部命令更快。内置命令提供了一些常见的功能和操作，例如改变当前工作目录、设置环境变量、控制脚本流程等。</p>
<p>一些常见的 Shell 内置命令包括：</p>
<ul>
<li><code>cd</code>：用于改变当前工作目录。</li>
<li><code>pwd</code>：用于显示当前工作目录的路径。</li>
<li><code>echo</code>：用于在终端中打印文本或变量的值。</li>
<li><code>export</code>：用于设置环境变量。</li>
<li><code>alias</code>：用于创建命令别名。</li>
<li><code>unset</code>：用于删除环境变量或函数。</li>
<li><code>exit</code>：用于退出当前的 Shell 终端会话。</li>
</ul>
<p>要查看Shell内建命令的详细信息，可以使用<code>man bash-builtins</code>命令（对于Bash Shell）。这将显示有关Shell内建命令的手册页面，包括命令的用法、选项和示例。</p>
<p><strong>外部命令</strong>是由独立的可执行程序提供的命令。这些命令不是 Shell 解释器的一部分，而是作为独立的二进制文件存在于文件系统中。在 Shell 中执行外部命令时，Shell 解释器会创建一个新的进程，并加载并执行相应的可执行文件。外部命令提供了更广泛的功能和操作，例如执行系统命令、调用其他程序等。</p>
<p>外部命令可以是系统自带的工具，也可以是用户自己安装的软件。在执行外部命令时，Shell 会搜索系统的可执行文件路径，以找到并执行相应的命令。用户可以通过指定命令的完整路径或将可执行文件所在的目录添加到 PATH 环境变量中来执行外部命令。</p>
<p>一些常见的外部命令包括：</p>
<ul>
<li><code>ls</code>：用于列出目录内容。</li>
<li><code>grep</code>：用于在文件中搜索指定模式。</li>
<li><code>cat</code>：用于显示文件内容。</li>
<li><code>rm</code>：用于删除文件或目录。</li>
<li><code>cp</code>：用于复制文件或目录。</li>
<li><code>mv</code>：用于移动或重命名文件或目录。</li>
</ul>
<p>区分内置命令和外部命令的一个简单方法是使用 <code>type</code> 命令。例如，<code>type cd</code> 将显示 “cd is a shell builtin”，而 <code>type ls</code> 将显示 “ls is /bin/ls”，表明 <code>cd</code> 是一个内置命令，而 <code>ls</code> 是一个外部命令。</p>
<p>在日常使用 Shell 进行命令行操作和脚本编写时，内置命令和外部命令一起提供了丰富的功能和灵活性。通过合理地使用这两种类型的命令，可以更高效地管理文件和目录、操作系统资源以及执行各种任务。</p>
<h1 id="17-shell脚本的执行"><a class="markdownIt-Anchor" href="#17-shell脚本的执行"></a> 17 Shell脚本的执行</h1>
<h2 id="171-shell脚本格式"><a class="markdownIt-Anchor" href="#171-shell脚本格式"></a> 17.1 shell脚本格式</h2>
<blockquote>
<p>（1）脚本文件命名规范</p>
<p>​	shell脚本文件就是一个文本文件, 后缀名建议使用 <code>.sh</code> 结尾，例如01_first.sh</p>
<p>（2）首行格式规范</p>
<p>​	在脚本文件的第一行通常需要添加脚本文件的声明，指定使用哪种 Shell 解释器执行该脚本。例如，使用 Bash 解释器的声明为：<code>#!/bin/bash</code>。这个声明称为 shebang，用于告诉系统应该使用指定的解释器来执行脚本。</p>
<p>（3）注释格式</p>
<p>​	注释用于提供对脚本的说明和解释，不会被解释器执行。在 Shell 脚本中，注释可以以 <code>#</code> 开头。</p>
</blockquote>
<h2 id="172-运行脚本的四种方式"><a class="markdownIt-Anchor" href="#172-运行脚本的四种方式"></a> 17.2 运行脚本的四种方式</h2>
<p><a target="_blank" rel="noopener" href="http://xn--helloworld-pf2pypwgz43bp6cz1kq93cjq2q.sh">首先创建一个名为helloworld.sh</a>，具体内容如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">echo hello world</span><br><span class="line">cd ..</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<p>这是一个简单的Shell脚本示例，使用了Shebang（#!）来指定解释器为<code>/bin/sh</code>。脚本的功能是输出&quot;HelloWorld&quot;并尝试切换到上一级目录。</p>
<p>要执行这个脚本，可以通过以下方式之一：</p>
<p>（1）给脚本文件添加可执行权限,通过绝对路径或者相对路径执行脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x helloworld.sh</span><br><span class="line">./helloworld.sh</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403281450164.png" alt="image-20240328145010096" /></p>
<p>这样Shell会fork一个子进程并调用exec执行<code>./test.sh</code>，由于指定了Shebang，子进程会用<code>/bin/bash</code>解释器的代码段替换当前进程，并从解释器的开始执行。因此，脚本中的命令会被执行。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403281404351.png" alt="image-20240328140424273" /></p>
<p>（2）直接使用解释器执行脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash helloworld.sh</span><br></pre></td></tr></table></figure>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240328133615230.png" alt="image-20240328133615230" />	这种方式不需要脚本文件具有可执行权限，直接通过指定解释器执行脚本。</p>
<p>（3）使用source 命令执行脚本：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403281336575.png" alt="image-20240328133637519" /></p>
<p>使用source`命令来执行Shell脚本。这种方式不会创建子Shell，而是直接在当前交互式Shell中逐行执行脚本中的命令。</p>
<p>（4）使用. 命令执行脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. test.sh</span><br></pre></td></tr></table></figure>
<p>使用.和source的作用,不会创建子Shell，而是直接在当前交互式Shell中逐行执行脚本中的命令。</p>
<h1 id="18-shell变量"><a class="markdownIt-Anchor" href="#18-shell变量"></a> 18 Shell变量</h1>
<h2 id="181-变量的组成和使用"><a class="markdownIt-Anchor" href="#181-变量的组成和使用"></a> 18.1 变量的组成和使用</h2>
<p>在Shell中，变量是用于存储和表示数据的一种命名实体。变量可以包含各种类型的数据，如字符串、数字、命令输出等。可以通过给变量赋值来创建和初始化变量，然后可以在脚本中使用变量来引用和操作存储的数据。</p>
<p>在Shell中，变量必须以字母或下划线开头，并由字母、数字和下划线组成，并对大小写敏感</p>
<p>变量的定义或赋值可以使用等号（=）进行，例如<code>VARNAME=value</code>。需要注意的是，等号两边不能有空格，否则空格会被解释成命令和参数的一部分。</p>
<p>在使用变量时，可以使用美元符号（$）加上变量名来引用变量的值，例如<code>echo $VARNAME</code>。如果变量名后面紧跟着其他字符（例如后缀），为了避免将变量名和后缀当作一个整体，可以使用花括号将变量名分隔出来，例如<code>echo $&#123;VARNAME&#125;suffix</code>。</p>
<p>在Shell脚本中，单引号（'）和双引号（&quot;）都用作字符串的界定符，但它们有不同的行为方式。</p>
<p><strong>（1）单引号（'）：</strong></p>
<p>单引号用于创建保持字符串的字面值的字符串。在单引号字符串中，所有字符都被视为普通字符，不进行变量扩展、命令替换或特殊字符转义。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;SHELL&#x27;</span></span><br><span class="line"><span class="comment"># 输出：SHELL</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;ABC\&#x27;</span></span><br><span class="line"><span class="comment"># 输出：ABC\</span></span><br></pre></td></tr></table></figure>
<p>在单引号字符串中，无法直接嵌入单引号字符。如果需要在单引号字符串中使用单引号，可以通过拼接字符串或转义字符的方式实现。</p>
<p><strong>（2）双引号（&quot;）：</strong></p>
<p>双引号用于创建字符串，并支持变量扩展和特殊字符转义。</p>
<p>在双引号字符串中，变量会被展开为其对应的值，命令替换会执行替换操作，而特殊字符可以通过转义字符进行转义。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VAR=<span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$VAR</span>!&quot;</span></span><br><span class="line"><span class="comment"># 输出：Hello, World!</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ABC\$&quot;</span></span><br><span class="line"><span class="comment"># 输出：ABC$</span></span><br></pre></td></tr></table></figure>
<p>在双引号字符串中，变量会被展开为其对应的值（通过<code>$</code>进行标识），而特殊字符可以通过反斜杠进行转义。</p>
<h2 id="182-变量的分类"><a class="markdownIt-Anchor" href="#182-变量的分类"></a> 18.2 变量的分类</h2>
<p>可以将Shell中的变量分为两种不同的分类：</p>
<p><strong>（1）本地变量：</strong></p>
<p>本地变量是在Shell脚本中定义和使用的变量。它们仅在当前Shell会话中可见，对其他Shell会话或进程不可见。</p>
<p><strong>全局变量</strong>:在Shell的解析环境中存在的变量，不需要任何修饰符进行声明。无论是在函数内部还是函数外部，全局变量的作用范围都是整个Shell进程。全局变量的生命周期从声明语句开始，一直持续到bash进程结束。</p>
<p><strong>局部变量</strong>:使用<code>local</code>关键字进行修饰，只能在函数内部声明。局部变量的作用范围仅限于声明它的函数内部，在函数结束后，局部变量将不再可用。局部变量的生命周期从声明语句开始，一直持续到函数执行结束。</p>
<p>Shell内部变量只能在当前Shell进程中使用，如果跨越了进程边界，例如在子进程中或从子进程返回到父进程，那么变量的可见性将受到限制。</p>
<p><strong>（2）环境变量：</strong></p>
<p>环境变量是操作系统自带的变量，每个进程都有自己的环境变量集合。当启动一个子进程时，子进程会从父进程继承一份相同的环境变量副本。这意味着子进程拥有与父进程相同的初始环境变量。</p>
<p>子进程对环境变量的修改不会影响父进程的环境变量。环境变量是单向传递的，子进程可以修改自己的环境变量，但不会影响到父进程或其他兄弟进程的环境变量。</p>
<p>在Shell中，可以使用env命令查看当前bash进程的环境变量，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202404011735783.png" alt="image-20240401173503707" /></p>
<p>可以使用<code>export</code>命令将一个变量导出为环境变量，例如<code>export varname=value</code>。另外，也可以直接在当前Shell进程中定义一个变量，并将其同时导出为环境变量，例如<code>varname=value</code>和<code>export varname</code>两个命令组合使用。</p>
<p><strong>（3）特殊变量</strong></p>
<p>特殊变量是一组预定义的变量，具有特殊的含义和用途。它们是环境变量中的一种特殊类型。特殊变量提供了对脚本执行环境、命令行参数、退出状态等信息的访问。</p>
<ol>
<li><code>$0</code>：表示当前脚本的名称。在脚本中使用<code>$0</code>可以获取脚本的名称，包括路径。</li>
<li><code>$1</code>、<code>$2</code>、<code>$3</code>…：表示脚本的位置参数或命令行参数。当脚本被调用时，可以通过<code>$1</code>、<code>$2</code>等来获取传递给脚本的参数值。<code>$1</code>表示第一个参数，<code>$2</code>表示第二个参数，以此类推。</li>
<li><code>$#</code>：表示命令行参数的个数。<code>$#</code>用于获取传递给脚本的参数的总数。</li>
<li><code>$*</code>：表示所有命令行参数的列表。<code>$*</code>将所有命令行参数作为单个字符串返回。</li>
<li><code>$@</code>：表示所有命令行参数的列表。与<code>$*</code>不同，<code>$@</code>将命令行参数作为多个独立的字符串返回。</li>
<li><code>$?</code>：表示上一个命令的退出状态。当命令执行完毕后，可以使用<code>$?</code>来获取其退出状态。通常，如果命令成功执行，则<code>$?</code>的值为0，否则为非零值。</li>
</ol>
<p><strong>（4）变量的删除</strong><br />
使用<code>unset</code>命令来删除Shell中的变量，无论是环境变量还是普通的Shell内部变量。</p>
<p>使用<code>unset</code>命令的语法是：<code>unset 变量名</code>。</p>
<p>例如，如果要删除一个环境变量，可以执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset VARNAME</span><br></pre></td></tr></table></figure>
<p>如果要删除一个普通的Shell内部变量，同样可以使用<code>unset</code>命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset varname</span><br></pre></td></tr></table></figure>
<p>执行<code>unset</code>命令后，相应的变量将被从当前Shell进程中移除，不再可用。</p>
<p>需要注意的是，<code>unset</code>命令只能删除当前Shell进程中的变量，不会影响其他Shell进程或操作系统级别的环境变量。</p>
<h2 id="183-命令代换"><a class="markdownIt-Anchor" href="#183-命令代换"></a> 18.3 命令代换</h2>
<p>命令代换指将命令的输出作为字符串嵌入到变量中。在Shell中，可以使用反引号（`）或美元符号加圆括号（$()）来表示命令代换。</p>
<p>以下是一些示例说明如何使用命令代换：</p>
<p>使用反引号（`）表示命令代换：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DATE=`<span class="built_in">date</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$DATE</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>date</code>命令被执行，并将其输出结果赋给变量<code>DATE</code>。然后，使用<code>echo</code>命令打印出<code>DATE</code>变量的值，即当前的日期和时间。</p>
<p>使用美元符号加圆括号（$()）表示命令代换：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DATE=$(<span class="built_in">date</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$DATE</span></span><br></pre></td></tr></table></figure>
<p>这个示例与前一个示例的功能相同，只是使用了不同的语法形式。<code>$(date)</code>会执行<code>date</code>命令，并将输出结果赋给变量<code>DATE</code>。</p>
<h1 id="19-条件判断"><a class="markdownIt-Anchor" href="#19-条件判断"></a> 19 条件判断</h1>
<h2 id="191-条件测试"><a class="markdownIt-Anchor" href="#191-条件测试"></a> 19.1 条件测试</h2>
<p>方括号 <code>[</code> 是 shell 中用于进行条件测试的内建命令，也被称为 <code>test</code> 命令的等效形式。它通常用于 if 语句、while 循环和其他需要进行条件判断的地方。</p>
<p>方括号的基本语法为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 条件表达式 ]</span><br></pre></td></tr></table></figure>
<p>test的基本语法为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test 条件表达式</span><br></pre></td></tr></table></figure>
<p>​	条件表达式可以包含各种比较运算符、逻辑运算符和文件测试运算符，用于比较数值、字符串或检查文件属性。</p>
<p><strong>字符串比较：</strong></p>
<p>方括号和 test 命令支持用于字符串比较的运算符。常用的字符串比较运算符包括：</p>
<ul>
<li><code>=</code>：判断两个字符串是否相等。</li>
<li><code>!=</code>：判断两个字符串是否不相等。</li>
<li><code>-z</code>：判断字符串是否为空。</li>
<li><code>-n</code>：判断字符串长度是否非零。</li>
</ul>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ STRING1 = STRING2 ]     # 判断 STRING1 和 STRING2 是否相等</span><br><span class="line">[ STRING1 != STRING2 ]    # 判断 STRING1 和 STRING2 是否不相等</span><br><span class="line">[ -z STRING ]             # 判断 STRING 是否为空</span><br><span class="line">[ -n STRING ]             # 判断 STRING 的长度是否非零</span><br></pre></td></tr></table></figure>
<p><strong>整数比较</strong>：</p>
<p>方括号和 test 命令还支持用于整数比较的运算符。常用的整数比较运算符包括：</p>
<ul>
<li><code>-eq</code>：判断两个整数是否相等。</li>
<li><code>-ne</code>：判断两个整数是否不相等。</li>
<li><code>-gt</code>：判断第一个整数是否大于第二个整数。</li>
<li><code>-lt</code>：判断第一个整数是否小于第二个整数。</li>
<li><code>-ge</code>：判断第一个整数是否大于等于第二个整数。</li>
<li><code>-le</code>：判断第一个整数是否小于等于第二个整数。</li>
</ul>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ INTEGER1 -eq INTEGER2 ]   # 判断 INTEGER1 是否等于 INTEGER2</span><br><span class="line">[ INTEGER1 -ne INTEGER2 ]   # 判断 INTEGER1 是否不等于 INTEGER2</span><br><span class="line">[ INTEGER1 -gt INTEGER2 ]   # 判断 INTEGER1 是否大于 INTEGER2</span><br><span class="line">[ INTEGER1 -lt INTEGER2 ]   # 判断 INTEGER1 是否小于 INTEGER2</span><br><span class="line">[ INTEGER1 -ge INTEGER2 ]   # 判断 INTEGER1 是否大于等于 INTEGER2</span><br><span class="line">[ INTEGER1 -le INTEGER2 ]   # 判断 INTEGER1 是否小于等于 INTEGER2</span><br></pre></td></tr></table></figure>
<p><strong>文件属性和权限判断</strong>：</p>
<p>方括号和 test 命令还用于检查文件的属性和权限。常用的文件测试运算符包括：</p>
<ul>
<li><code>-e</code>：判断文件是否存在。</li>
<li><code>-f</code>：判断文件是否为普通文件。</li>
<li><code>-d</code>：判断文件是否为目录。</li>
<li><code>-r</code>：判断文件是否可读。</li>
<li><code>-w</code>：判断文件是否可写。</li>
<li><code>-x</code>：判断文件是否可执行。</li>
</ul>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ -e FILE ]    # 判断 FILE 是否存在</span><br><span class="line">[ -f FILE ]    # 判断 FILE 是否为普通文件</span><br><span class="line">[ -d FILE ]    # 判断 FILE 是否为目录</span><br><span class="line">[ -r FILE ]    # 判断 FILE 是否可读</span><br><span class="line">[ -w FILE ]    # 判断 FILE 是否可写</span><br><span class="line">[ -x FILE ]    # 判断 FILE 是否可执行</span><br></pre></td></tr></table></figure>
<p>方括号 <code>[</code> 和 <code>test</code> 是 shell 中用于进行条件测试的关键字。它们可以用于比较字符串、比较整数、检查文件属性和权限等。根据条件的结果，我们可以在 shell 脚本中执行不同的操作。请注意，在使用方括号和 test 命令时，要确保正确的语法和使用适当的运算符。</p>
<h2 id="192-if分支结构"><a class="markdownIt-Anchor" href="#192-if分支结构"></a> 19.2 if分支结构</h2>
<p>​	<code>if</code> 分支结构适用于根据条件的真假执行不同的代码块。它使用条件表达式来做判断，并根据条件的结果选择执行相应的代码块。<code>if</code> 分支结构适用于处理复杂的条件逻辑和数值/字符串比较。</p>
<p>if语句的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="comment"># 代码块1，条件为真时执行的代码</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># 代码块2，条件为假时执行的代码（可选）</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>​	在这个语法中，<code>condition</code>是一个条件表达式，用于判断真假。如果<code>condition</code>为真，则执行<code>then</code>后的代码块1，否则执行可选的<code>else</code>后的代码块2。</p>
<p>​	另一种形式的if语句是使用elif（即else if）来实现多个条件判断，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="comment"># 代码块1，条件1为真时执行的代码</span></span><br><span class="line"><span class="keyword">elif</span> condition2</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="comment"># 代码块2，条件2为真时执行的代码</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># 代码块3，以上条件都为假时执行的代码（可选）</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>​	在这个语法中，首先判断<code>condition1</code>，如果为真则执行代码块1；如果为假，则继续判断<code>condition2</code>，如果为真则执行代码块2；如果以上条件都为假，则执行可选的代码块3。</p>
<p>​	下面是一个示例，演示了if语句的使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">score=80</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$score</span> -ge 90 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;优秀&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$score</span> -ge 80 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;良好&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$score</span> -ge 60 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;及格&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;不及格&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>​	在这个示例中，根据变量<code>score</code>的值进行成绩判断。根据条件的真假，分别输出不同的结果。</p>
<p>​	在if语句中，条件表达式可以使用各种比较运算符（如<code>-eq</code>、<code>-ne</code>、<code>-lt</code>、<code>-gt</code>、<code>-le</code>、<code>-ge</code>）来比较数字，也可以使用字符串比较运算符（如<code>=</code>、<code>!=</code>）来比较字符串。此外，还可以使用逻辑运算符（如<code>-a</code>、<code>-o</code>）进行多个条件的组合。</p>
<p>​	需要注意的是，if语句的每个代码块都需要以关键字<code>then</code>开头，并以关键字<code>fi</code>结尾。<code>then</code>和<code>fi</code>之间的代码块可以是单行语句，也可以是多行语句。另外，if语句中的方括号<code>[]</code>用于表示条件判断，需要注意在方括号内外使用适当的空格。</p>
<h2 id="193-case-分支结构"><a class="markdownIt-Anchor" href="#193-case-分支结构"></a> 19.3 case 分支结构</h2>
<p>​	在Shell编程中，<code>case</code>语句用于根据模式匹配执行不同的操作。<code>case</code>语句类似于其他编程语言中的<code>switch</code>语句，可以根据不同的条件执行不同的代码块。</p>
<p><code>case</code>语句通常具有以下结构：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">case expression in</span><br><span class="line">    pattern1)</span><br><span class="line">        # 执行 pattern1 匹配的操作</span><br><span class="line">        ;;</span><br><span class="line">    pattern2)</span><br><span class="line">        # 执行 pattern2 匹配的操作</span><br><span class="line">        ;;</span><br><span class="line">    pattern3)</span><br><span class="line">        # 执行 pattern3 匹配的操作</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        # 如果没有匹配任何模式，则执行默认操作</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<p>​	在 <code>case</code> 分支结构中，<code>expression</code> 是需要匹配的表达式或变量。每个 <code>pattern</code> 是一个模式，用于与 <code>expression</code> 进行匹配。如果 <code>expression</code> 匹配了某个 <code>pattern</code>，则执行对应的代码块。如果没有匹配到任何 <code>pattern</code>，则执行 <code>*</code> 对应的代码块（默认情况）。</p>
<p>​	在每个 <code>pattern</code> 的代码块中，使用 <code>;;</code> 表示代码块的结束。<code>;;</code> 是必需的，用于告诉解释器该分支的代码块已经执行完毕，终止当前分支。</p>
<p>​	<code>case</code> 分支结构可以根据需要进行嵌套，以实现更复杂的条件判断和流程控制。可以根据具体的模式匹配需要，编写适当的模式和相应的代码块。</p>
<p>下面是一个示例，演示如何使用<code>case</code>语句根据不同的条件执行不同的操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">fruit=$1</span><br><span class="line"></span><br><span class="line">case $fruit in</span><br><span class="line">    &quot;apple&quot;)</span><br><span class="line">        echo &quot;选择的水果为苹果&quot;</span><br><span class="line">        ;;</span><br><span class="line">    &quot;banana&quot;)</span><br><span class="line">        echo &quot;选择的水果为香蕉&quot;</span><br><span class="line">        ;;</span><br><span class="line">    &quot;orange&quot;)</span><br><span class="line">        echo &quot;选择的水果为橙子&quot;</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo &quot;选择了其他的水果&quot;</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<p>​	在上述示例中，根据变量<code>fruit</code>的值，<code>case</code>语句进行模式匹配。如果<code>fruit</code>的值是&quot;apple&quot;，则执行第一个模式下的操作，输出&quot;Selected fruit is apple&quot;。如果<code>fruit</code>的值是&quot;banana&quot;，则执行第二个模式下的操作，输出&quot;Selected fruit is banana&quot;。如果<code>fruit</code>的值是&quot;orange&quot;，则执行第三个模式下的操作，输出&quot;Selected fruit is orange&quot;。如果<code>fruit</code>的值不匹配任何模式，则执行默认操作，输出&quot;Unknown fruit&quot;。</p>
<p><code>case</code>语句还支持使用模式匹配的特殊符号和正则表达式，使匹配更加灵活和强大。您可以在模式中使用通配符（<code>*</code>、<code>?</code>）和正则表达式来进行更复杂的匹配。</p>
<h1 id="20-循环结构"><a class="markdownIt-Anchor" href="#20-循环结构"></a> 20 循环结构</h1>
<h2 id="201-for循环"><a class="markdownIt-Anchor" href="#201-for循环"></a> 20.1 for循环</h2>
<p>在Shell脚本中，<code>for</code>循环用于遍历列表或范围，并执行一系列的操作。它是一种常用的控制流程结构，用于重复执行相同或类似的任务。</p>
<p>Shell中的<code>for</code>循环有多种语法形式，包括遍历列表、遍历范围和遍历命令输出等。下面将详细介绍这些形式。</p>
<p><strong>（1）遍历列表：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 值列表</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 执行循环体操作</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>在这种形式中，值列表是由空格分隔的一系列值，可以是字符串、变量、命令的输出结果等。循环将迭代<code>list</code>中的每个值，每次迭代将把当前值赋给<code>变量</code>，然后执行循环体中的操作。</p>
<p>示例1：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用for循环遍历fruits字符串中的值</span></span><br><span class="line">fruits=<span class="string">&quot;apple orange banana&quot;</span></span><br><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> <span class="variable">$fruits</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$fruit</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>fruits</code>变量包含了三个水果名称。<code>for</code>循环遍历<code>fruits</code>中的每个水果，将当前水果赋值给<code>fruit</code>变量，并输出&quot;&lt;水果名称&gt;&quot;。</p>
<p><strong>（2）遍历范围：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> &#123;start..end&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 执行循环体操作</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>这种形式中，<code>start</code> 和 <code>end</code> 是起始和结束的整数值。循环将从<code>start</code>值迭代到<code>end</code>值（包括边界值），每次迭代将把当前值赋给<code>variable</code>，然后执行循环体中的操作。</p>
<p>示例2：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用for循环遍历1-5范围</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> &#123;&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$num</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，循环将从1到5迭代，将当前数字赋值给<code>num</code>变量，并输出&quot;Number: &lt;当前数字&gt;&quot;。</p>
<p><strong>（3）遍历命令输出：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> $(<span class="built_in">command</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 执行循环体操作</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>在这种形式中，<code>command</code> 是一个命令或命令序列，它的输出将作为循环的列表。循环将迭代命令输出中的每个值，每次迭代将把当前值赋给<code>variable</code>，然后执行循环体中的操作。</p>
<p>示例3：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> $(<span class="built_in">ls</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Processing file: <span class="variable">$file</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>$(ls)</code> 执行了一个列出当前目录下所有文件的命令，并将文件列表作为循环的输入。循环遍历文件列表，将当前文件名赋值给<code>file</code>变量，并输出&quot;Processing file: &lt;文件名&gt;&quot;。</p>
<p><code>for</code>循环还支持使用<code>continue</code>和<code>break</code>语句来控制循环的执行流程。<code>continue</code>语句用于跳过当前迭代并继续下一次迭代，而<code>break</code>语句用于提前终止循环。</p>
<p>注意，在Shell脚本中，<code>for</code>循环的变量是局部变量，只在循环体内部有效。如果需要在循环外部使用循环变量的值，可以在循环外部定义相应的变量，并在循环内部赋值。</p>
<h2 id="202-while-循环"><a class="markdownIt-Anchor" href="#202-while-循环"></a> 20.2 while 循环</h2>
<p>在Shell脚本中，<code>while</code>循环用于重复执行一系列操作，直到给定的条件不再满足为止。<code>while</code>循环是一种常见的控制流程结构，用于处理需要基于条件进行迭代的任务。</p>
<p>Shell中的<code>while</code>循环有以下语法形式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while 条件表达式</span><br><span class="line">do</span><br><span class="line">    # 执行循环体操作</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>条件表达式用来判断循环是否继续执行，只要<code>条件表达式</code>的结果为真，循环体就会被执行；一旦<code>条件表达式</code>的结果为假，循环就会终止。循环体中的操作将被重复执行，直到<code>条件表达式</code>的结果为假。在每次循环迭代时，会先判断<code>条件表达式</code>的值，然后根据判断结果决定是否执行循环体。</p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">count变量赋予初值1，在<span class="keyword">while</span>循环中累加count变量值，累加到5后停止</span></span><br><span class="line">count=1</span><br><span class="line">while [ $count -le 5 ]</span><br><span class="line">do</span><br><span class="line">        echo $count</span><br><span class="line">        count=$((count+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>在上述示例中，循环从1开始，每次迭代输出当前的计数值，并将计数器<code>count</code>递增。循环将持续执行，直到<code>count</code>的值大于5，此时条件<code>$count -le 5</code>不再满足，循环终止。</p>
<p><code>while</code>循环还支持使用<code>continue</code>和<code>break</code>语句来控制循环的执行流程。<code>continue</code>语句用于跳过当前迭代并继续下一次迭代，而<code>break</code>语句用于提前终止循环。</p>
<p>需要注意的是，在<code>while</code>循环中，如果循环条件一开始就为假，循环体内的操作将不会执行，即循环体可能根本不执行。</p>
<h1 id="21-函数"><a class="markdownIt-Anchor" href="#21-函数"></a> 21 函数</h1>
<p>​		函数是一种用于封装一组相关操作的代码块。函数可以被调用多次，并且可以接受参数和返回值，通过合理地使用函数，可以将复杂的脚本逻辑分解为可重用和可维护的模块，提高Shell脚本的可读性、可维护性和可扩展性。</p>
<h2 id="211-函数定义和调用"><a class="markdownIt-Anchor" href="#211-函数定义和调用"></a> 21.1 函数定义和调用</h2>
<p>​	函数定义的一般语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">name</span></span>() &#123;</span><br><span class="line">    <span class="comment"># 函数体，包含一系列的命令和逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	函数名可以由字母、数字和下划线组成，但不能以数字开头。</p>
<p>​	要调用函数，只需使用函数名即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name</span><br></pre></td></tr></table></figure>
<p>​	举例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构造函数，通过函数打印hello world</span></span><br><span class="line">function hello()</span><br><span class="line">&#123;</span><br><span class="line">        echo &quot;hello world&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<h2 id="212-函数参数"><a class="markdownIt-Anchor" href="#212-函数参数"></a> 21.2 函数参数</h2>
<p>​		函数可以接受参数，以便在函数内部使用。在函数定义中使用<code>$1</code>、<code>$2</code>等特殊变量来引用传递给函数的参数。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印函数传递的第一个、第二个参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hello</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">echo</span> 传入的第一个参数为<span class="variable">$1</span></span><br><span class="line">        <span class="built_in">echo</span> 传入的第一个参数为<span class="variable">$2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello 1 2 </span><br></pre></td></tr></table></figure>
<p>​	在上述示例中，函数<code>hello</code>接受两个参数，并在函数体中使用<code>$1</code>和<code>$2</code>引用该参数的值。</p>
<h2 id="213-函数返回值"><a class="markdownIt-Anchor" href="#213-函数返回值"></a> 21.3 函数返回值</h2>
<p>​	函数可以通过<code>return</code>语句返回一个退出状态码，范围为0-255。在函数中使用<code>return</code>语句后，将退出函数并返回指定的状态码，可以通过$?得到返回值，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印函数的返回值</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hello</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">return</span> 10</span><br><span class="line">&#125;</span><br><span class="line">hello</span><br><span class="line"><span class="built_in">echo</span> 函数返回值为$?</span><br></pre></td></tr></table></figure>
<p>​	在上述示例中，函数<code>add</code>接受两个参数，并返回它们的和。在函数体中，使用<code>return</code>语句返回计算结果。</p>
<h2 id="214-局部变量"><a class="markdownIt-Anchor" href="#214-局部变量"></a> 21.4 局部变量</h2>
<p>​	在函数内部定义的变量默认是全局的，可以在函数外部访问。如果希望在函数内部创建局部变量，可以使用<code>local</code>关键字。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 演示局部变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hello</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">local</span> var=topeet</span><br><span class="line">    <span class="built_in">echo</span> 局部变量值为<span class="variable">$var</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello  </span><br><span class="line"><span class="built_in">echo</span> 局部变量值为<span class="variable">$var</span></span><br></pre></td></tr></table></figure>
<p>​	在上述示例中，变量<code>name</code>使用<code>local</code>关键字在函数内部定义，成为局部变量。该变量无法在函数外部直接访问。</p>
<h1 id="一些常见用法"><a class="markdownIt-Anchor" href="#一些常见用法"></a> 一些常见用法</h1>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202403261721882.png" alt="image-20240319170500405" /></p>
<p>&amp;&amp;：逻辑与运算符</p>
<ul>
<li><code>command1 &amp;&amp; command2</code>：表示如果 <code>command1</code> 成功执行（退出状态为零），则执行 <code>command2</code>。</li>
<li><code>command1</code> 和 <code>command2</code> 可以是任意的命令或命令序列。</li>
<li>如果 <code>command1</code> 的退出状态为非零（表示执行失败），则 <code>command2</code> 不会被执行，并且整个命令序列的退出状态也将是非零。</li>
<li><code>&amp;&amp;</code> 具有 short-circuit 特性，即如果前一个命令返回非零退出状态，后续的命令将被跳过。</li>
<li><code>&amp;&amp;</code> 可以用于串联多个命令，只有前一个命令成功执行后，才会执行后续的命令。</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean &amp;&amp; make</span><br></pre></td></tr></table></figure>
<p>如果 <code>make clean</code> 成功执行（退出状态为零），则执行 <code>make</code> 命令。</p>
<p>||：逻辑或运算符</p>
<ul>
<li><code>command1 || command2</code>：表示如果 <code>command1</code> 执行失败（退出状态非零），则执行 <code>command2</code>。</li>
<li><code>command1</code> 和 <code>command2</code> 可以是任意的命令或命令序列。</li>
<li>如果 <code>command1</code> 的退出状态为零（表示执行成功），则 <code>command2</code> 不会被执行，并且整个命令序列的退出状态也将是零。</li>
<li><code>||</code> 也具有 short-circuit 特性，即如果前一个命令返回零退出状态，后续的命令将被跳过。</li>
<li><code>||</code> 可以用于根据命令执行结果选择不同的处理路径。</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install || echo &quot;Installation failed&quot;</span><br></pre></td></tr></table></figure>
<p>如果 <code>make install</code> 执行失败（退出状态非零），则输出 “Installation failed”。</p>
<p>这些逻辑运算符可以帮助您根据命令执行的成功或失败状态来控制命令之间的执行流程。它们常用于自动化脚本和条件执行的场景中，以便根据命令执行结果采取相应的操作。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2024/06/25/03_Linux%E5%AD%A6%E4%B9%A0/3%20%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%85%A5%E9%97%A8%E7%AF%87/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/06/25/03_Linux%E5%AD%A6%E4%B9%A0/4%20%E6%BC%94%E7%A4%BA%E5%86%85%E5%AE%B9/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            嵌入式Linux入门篇演示内容
          
        </div>
      </a>
    
    
      <a href="/2024/06/04/06_%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/18_%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95(%E5%85%AD%E6%9C%88%E7%AC%AC4%E4%B8%AA%E6%98%9F%E6%9C%9F)/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">工作记录((6月第4个星期)</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2024
        <i class="ri-heart-fill heart_icon"></i> chai
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="热爱学习的未来酱"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E7%94%9F%E6%B4%BB">生活</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E7%91%9E%E8%8A%AF%E5%BE%AE">瑞芯微</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/Linux%E5%AD%A6%E4%B9%A0">Linux学习</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E8%AF%BB%E4%B9%A6">读书</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/C%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E5%AD%A6%E4%B9%A0">C语言高级学习</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95">工作记录</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7">小技巧</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/shell%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0">shell编程学习</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/PCB%E5%AD%A6%E4%B9%A0">PCB学习</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0">音视频学习</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=0&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>