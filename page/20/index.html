<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="永远年轻，永远热泪盈眶" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 热爱学习的未来酱</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="热爱学习的未来酱" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover3.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">热爱学习的未来酱</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '向上的路，并不拥挤。拥挤是因为，大部分人选择了安逸', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-3-7-链接过程-1-地址空间分配与链接脚本"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/3-7-%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B-1-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E4%B8%8E%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC/"
    >3.7-链接过程(1)-地址空间分配与链接脚本</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/3-7-%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B-1-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E4%B8%8E%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC/" class="article-date">
  <time datetime="2023-09-04T23:47:01.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">c高级编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="3-7-1-链接的重要性"><a href="#3-7-1-链接的重要性" class="headerlink" title="3.7.1 链接的重要性"></a>3.7.1 链接的重要性</h1><p>链接（Linking）是将多个可重定位目标文件合并、组装成可执行目标文件或共享库的过程。链接器（Linker）是执行链接操作的工具或程序。</p>
<p>链接的主要目的是解决多个目标文件之间的符号引用和地址重定位问题，使得程序能够正确地执行。</p>
<p>链接过程包括以下主要步骤：</p>
<ol>
<li>地址空间分配：链接器将可执行目标文件加载到内存中的适当地址空间中。这涉及到分配代码段、数据段、堆栈等内存区域，并为每个目标文件分配适当的地址范围。</li>
<li>符号解析：在链接过程中，符号解析是一个重要的步骤。符号解析的目的是解决符号的引用关系，将符号引用与符号定义进行匹配。在符号解析阶段，链接器会根据符号的绑定属性（如全局、局部、弱符号）来确定符号的可见性和重复定义规则。<ul>
<li>强符号（Strong Symbols）：具有全局绑定属性的符号，优先级高于弱符号。如果存在多个强符号同名定义，链接器会报错。</li>
<li>弱符号（Weak Symbols）：具有弱绑定属性的符号，允许在多个目标文件中重复定义。如果存在多个弱符号同名定义，并且没有对应的强符号，链接器会选择其中一个定义。</li>
</ul>
</li>
<li>重定位（Relocation）：重定位是将目标文件中的地址引用转换为最终可执行文件中的实际地址的过程。在链接过程中，由于目标文件中的地址是相对于各自的节（Section）的起始地址的偏移量，因此需要进行重定位操作，将这些相对地址转换为绝对地址。重定位过程涉及到修正目标文件中的跳转、调用和数据访问等指令，使得它们指向正确的地址。</li>
</ol>
<h1 id="3-7-2-地址空间分配"><a href="#3-7-2-地址空间分配" class="headerlink" title="3.7.2 地址空间分配"></a>3.7.2 地址空间分配</h1><p>地址空间分配是链接过程中的一项重要任务，它确定了各个目标文件中不同段（如代码段、数据段、bss段）在最终可执行目标文件中的位置和大小。</p>
<p>以下是地址空间分配的一般步骤：</p>
<ol>
<li>扫描所有目标文件：链接器会逐个扫描所有目标文件，包括主程序文件和库文件。对于每个目标文件，链接器会读取其文件头部和段表等信息。</li>
<li>获取段信息：链接器从各个目标文件的段表中获取各个段的信息，包括段的类型（如代码段、数据段、bss段）、大小和对齐等属性。每个目标文件中的段表记录了该文件中各个段的位置和长度。</li>
<li>确定链接地址：链接器会指定一个链接地址（linkaddr）作为起始地址，用于存放最终可执行目标文件的各个段。</li>
<li>合并同类型段：链接器按照段的类型（代码段、数据段、bss段）顺序，将各个目标文件中相同类型的段进行合并。对于代码段和数据段，链接器会根据链接地址和各个段的偏移量（offset）计算出最终的段地址。</li>
<li>重新计算段长度和位置：合并后，链接器会重新计算各个段的长度和位置。对于代码段和数据段，它们的长度是各个段的长度之和；而对于bss段，它的长度通常为0，因为bss段存放的是未初始化的全局变量和静态变量。</li>
<li>处理库文件：链接器还会处理库文件，将库文件中的目标模块合并到最终的可执行目标文件中。这涉及到符号解析、重定位和符号表的更新等操作。</li>
</ol>
<h1 id="3-7-3-创建全局符号表"><a href="#3-7-3-创建全局符号表" class="headerlink" title="3.7.3 创建全局符号表"></a>3.7.3 创建全局符号表</h1><p>创建全局符号表是链接过程的一项关键任务，它的目的是将各个目标文件中的符号收集起来，并统一保存在一个全局符号表中。</p>
<p>以下是创建全局符号表的一般步骤：</p>
<ol>
<li>扫描所有目标文件：链接器会逐个扫描所有目标文件，包括主程序文件和库文件。对于每个目标文件，链接器会读取其符号表信息。</li>
<li>收集符号：链接器从每个目标文件的符号表中收集符号信息。符号表中包含了各个目标文件中定义和引用的符号的名称、属性和地址等信息。</li>
<li>统一放入全局符号表：链接器将从各个目标文件中收集到的符号统一放入一个全局符号表中。全局符号表是链接器维护的一个数据结构，用于保存所有目标文件中的符号信息。</li>
<li>相对零地址偏移：在创建全局符号表时，符号的地址仍然是相对于零地址的偏移量。这是因为在链接过程的后续阶段，还需要进行重定位操作，将符号的地址转换为最终可执行目标文件中的实际地址。</li>
</ol>
<h1 id="3-7-4-链接脚本"><a href="#3-7-4-链接脚本" class="headerlink" title="3.7.4 链接脚本"></a>3.7.4 链接脚本</h1><p>不同的代码段在链接过程中的组装是由链接脚本（Linker Script）来规定的。链接脚本是一个文本文件，其中包含了链接器的指令和规则，用于指导链接器如何组装各个代码段。</p>
<p>链接脚本通常包含以下信息：</p>
<ol>
<li>组装顺序：链接脚本规定了各个代码段的组装顺序。根据链接脚本的指定顺序，链接器会按照代码段的顺序将它们组装到最终可执行目标文件中。</li>
<li>起始地址：链接脚本指定了各个代码段在最终可执行目标文件中的起始地址。链接器会根据链接脚本中的地址规定，将各个代码段放置到相应的地址位置。</li>
<li>位置对齐：链接脚本还规定了代码段的位置对齐要求。根据链接脚本中指定的对齐规则，链接器会确保代码段在最终可执行目标文件中按照规定的对齐边界进行放置。</li>
<li>输出格式和运行平台：链接脚本可以指定输出可执行文件的格式和运行平台。这些信息对于生成符合特定格式和平台要求的可执行目标文件非常重要。</li>
<li>入口地址：链接脚本可以指定可执行目标文件的入口地址。入口地址是程序执行的起始点，在加载和执行可执行文件时，操作系统会将控制权转移到指定的入口地址处开始执行程序。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">oUTPUT_FORMAT( <span class="string">&quot;elf32-littlearm”</span></span><br><span class="line"><span class="string">&quot;</span>elf32-bigarm”</span><br><span class="line"><span class="string">&quot;elf32-littlearm”)</span></span><br><span class="line"><span class="string">;输出ELF麻件格式</span></span><br><span class="line"><span class="string">OUTPUT_ARCH( “arm”)</span></span><br><span class="line"><span class="string">;输出可执行文件的运行平台为arm</span></span><br><span class="line"><span class="string">ENTRY(_start)</span></span><br><span class="line"><span class="string">;程序入口地址</span></span><br><span class="line"><span class="string">SECTIONS</span></span><br><span class="line"><span class="string">;各段描述</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">.= Ox60000000;</span></span><br><span class="line"><span class="string">;代码段起始地址</span></span><br><span class="line"><span class="string">.text:&#123;*(.text)&#125;</span></span><br><span class="line"><span class="string">;代码段描述:所有.o文件的. text</span></span><br><span class="line"><span class="string">.= Ox60200000;</span></span><br><span class="line"><span class="string">;数据段的起始地址</span></span><br><span class="line"><span class="string">.data: &#123;*(. data)&#125;</span></span><br><span class="line"><span class="string">;数据段描述</span></span><br><span class="line"><span class="string">.bss :&#123;*(. bss)&#125;</span></span><br><span class="line"><span class="string">; BSS段描述</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>在SECTIONS部分，代码段的起始地址为0x60000000，紧接着是代码段的描述；数据段的起始地址为0x60200000，后面是数据段的描述；最后是BSS段的描述。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BF%90%E8%A1%8C/" rel="tag">程序的编译、链接和运行</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-3-6-编译过程-3-符号表"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/3-6-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B-3-%E7%AC%A6%E5%8F%B7%E8%A1%A8/"
    >3.6-编译过程(3)-符号表</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/3-6-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B-3-%E7%AC%A6%E5%8F%B7%E8%A1%A8/" class="article-date">
  <time datetime="2023-09-04T23:46:59.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">c高级编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="3-6-1-符号表"><a href="#3-6-1-符号表" class="headerlink" title="3.6.1 符号表"></a>3.6.1 符号表</h1><p>符号表在编译过程中起到了重要的作用，主要用来保存源程序中各种符号（如变量、函数、类、常量等）的相关信息，如地址值、类型、占用空间的大小等。</p>
<p>符号表的主要作用如下：</p>
<ol>
<li>辅助语义检查：符号表可以用于辅助编译器进行语义检查。编译器通过符号表来验证标识符的合法性、类型匹配等语义规则，以确保源程序的语义正确性。例如，编译器在进行类型检查时可以通过符号表中记录的类型信息来判断赋值操作是否合法。</li>
<li>辅助代码生成：符号表在代码生成阶段发挥重要作用。编译器通过符号表来进行地址和空间的分配，以确定变量和函数在内存中的位置。符号表中记录的地址信息可以用于生成汇编代码或机器代码时的地址计算。例如，编译器可以根据符号表中的地址信息为变量分配栈空间或静态数据区空间。</li>
<li>符号决议：符号表用于解析标识符的引用，即在程序中使用某个标识符时，找到该标识符的定义位置。编译器通过符号表中记录的定义位置信息来处理标识符的引用，以确保标识符在使用前已经被定义。符号决议阶段还包括解决标识符的作用域和命名空间等问题。</li>
<li>重定位：符号表用于链接器进行符号重定位。在多个目标文件进行链接时，链接器需要解析和处理目标文件中的符号引用。链接器通过符号表中记录的地址信息，将符号引用链接到正确的地址上，以确保最终生成的可执行文件能够正确地访问和使用各个目标文件中的符号。</li>
</ol>
<h1 id="3-6-2-elf文件和bin文件"><a href="#3-6-2-elf文件和bin文件" class="headerlink" title="3.6.2 elf文件和bin文件"></a>3.6.2 elf文件和bin文件</h1><p>ELF文件和BIN文件是两种不同的可执行文件格式。</p>
<p>BIN文件是一种纯粹的二进制文件，只包含机器码，没有附加的元数据信息。它通常被称为raw binary文件或镜像文件。BIN文件中的机器码是直接按照内存中的布局排列的，没有分节或分段的概念。常见的BIN文件格式还包括HEX文件，它以十六进制形式表示机器码。</p>
<p>而ELF文件（Executable and Linkable Format）是一种更为复杂的可执行文件格式。除了包含机器码之外，ELF文件还包含了一些额外的元数据信息，用于描述程序的结构、加载地址、运行地址等。ELF文件具有分节（Section）和分段（Segment）的概念，不同的节和段存储了不同的信息，如代码段、数据段、符号表、重定位表等。</p>
<p>ELF文件的结构包括以下几个重要的部分：</p>
<ol>
<li>ELF头（ELF Header）：位于文件的开头，包含了对整个ELF文件的描述信息，如文件类型、目标体系结构、入口地址等。</li>
<li>节表（Section Table）：记录了ELF文件中各个节的信息。每个节存储了特定类型的数据，例如代码、数据、符号表、重定位表等。节表中的每个表项描述了一个节的名称、大小、偏移量等信息。</li>
<li>段表（Segment Table）：记录了ELF文件中各个段的信息。段是逻辑上一组相关的节的集合，用于定义程序的内存布局。段表中的每个表项描述了一个段的类型、虚拟地址、文件偏移量等信息。</li>
<li>符号表（Symbol Table）：记录了程序中定义和引用的符号（如变量、函数、类等）的信息。符号表中的每个表项描述了一个符号的名称、类型、地址等信息。符号表在链接过程中用于解析符号引用和进行符号重定位。</li>
<li>重定位表（Relocation Table）：记录了需要进行符号重定位的位置和相关信息。重定位表在链接过程中用于调整代码和数据的位置，确保程序能够正确访问和使用符号。</li>
</ol>
<h1 id="3-6-3-readelf-s-和readelf-S-的区别"><a href="#3-6-3-readelf-s-和readelf-S-的区别" class="headerlink" title="3.6.3 readelf -s 和readelf -S 的区别"></a>3.6.3 readelf -s 和readelf -S 的区别</h1><p><code>readelf -s</code>和<code>readelf -S</code>是<code>readelf</code>命令的两个不同的选项，它们用于显示ELF文件中的不同部分信息。</p>
<ol>
<li><code>readelf -s</code>：该选项用于显示ELF文件的符号表（Symbol Table）。符号表记录了程序中定义和引用的符号（如变量、函数、类等）的信息。使用<code>readelf -s</code>命令可以列出符号表中的所有符号，包括符号的名称、类型、绑定属性、地址等信息。这对于进行符号分析、调试和动态链接等操作非常有用。</li>
<li><code>readelf -S</code>：该选项用于显示ELF文件的节表（Section Table）。节表记录了ELF文件中各个节的信息，每个节存储了特定类型的数据，如代码、数据、符号表、重定位表等。使用<code>readelf -S</code>命令可以列出节表中的所有节，包括节的名称、类型、大小、偏移量、虚拟地址等信息。这对于了解程序的内存布局、代码和数据段的大小以及节之间的关系非常有帮助。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/topeet/demo# readelf -s sub.o </span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 13 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS sub.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    2 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     9: 0000000000000000    24 FUNC    GLOBAL DEFAULT    1 add</span><br><span class="line">    10: 0000000000000018    22 FUNC    GLOBAL DEFAULT    1 sub</span><br><span class="line">    11: 000000000000002e    23 FUNC    GLOBAL DEFAULT    1 mul</span><br><span class="line">    12: 0000000000000045    23 FUNC    GLOBAL DEFAULT    1 div</span><br><span class="line">root@ubuntu:/home/topeet/demo# readelf -S sub.o </span><br><span class="line">There are 12 section headers, starting at offset 0x398:</span><br><span class="line"></span><br><span class="line">节头：</span><br><span class="line">  [号] 名称              类型             地址              偏移量</span><br><span class="line">       大小              全体大小          旗标   链接   信息   对齐</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000005c  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .data             PROGBITS         0000000000000000  0000009c</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 3] .bss              NOBITS           0000000000000000  0000009c</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .comment          PROGBITS         0000000000000000  0000009c</span><br><span class="line">       000000000000002c  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 5] .note.GNU-stack   PROGBITS         0000000000000000  000000c8</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 6] .note.gnu.propert NOTE             0000000000000000  000000c8</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 7] .eh_frame         PROGBITS         0000000000000000  000000e8</span><br><span class="line">       0000000000000098  0000000000000000   A       0     0     8</span><br><span class="line">  [ 8] .rela.eh_frame    RELA             0000000000000000  000002d0</span><br><span class="line">       0000000000000060  0000000000000018   I       9     7     8</span><br><span class="line">  [ 9] .symtab           SYMTAB           0000000000000000  00000180</span><br><span class="line">       0000000000000138  0000000000000018          10     9     8</span><br><span class="line">  [10] .strtab           STRTAB           0000000000000000  000002b8</span><br><span class="line">       0000000000000017  0000000000000000           0     0     1</span><br><span class="line">  [11] .shstrtab         STRTAB           0000000000000000  00000330</span><br><span class="line">       0000000000000067  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br><span class="line">root@ubuntu:/home/topeet/demo# </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3-6-3-符号类型和绑定属性"><a href="#3-6-3-符号类型和绑定属性" class="headerlink" title="3.6.3 符号类型和绑定属性"></a>3.6.3 符号类型和绑定属性</h1><p>符号类型和绑定属性是符号表中的两个重要概念，用于描述符号的特性和可见性。</p>
<ol>
<li>符号类型（Symbol Type）：符号类型描述了符号关联的实体类型，即符号表示的是什么。在符号表中常见的符号类型包括：</li>
</ol>
<ul>
<li>OBJECT（对象）：符号关联的是一个数据对象，如变量、数组或指针。</li>
<li>FUNC（函数）：符号关联到一个函数或过程。</li>
<li>SECTION（节）：符号关联到一个节的名字。</li>
<li>FILE（文件）：符号关联一个文件名。</li>
<li>NOTYPE（未指定类型）：符号的类型未指定，它常用于未定义的引用。</li>
</ul>
<p>2.绑定属性（Binding Attribute）：绑定属性描述了符号的可见性和重复定义的规则。在符号表中常见的绑定属性包括：</p>
<ul>
<li>LOCAL（局部）：局部符号只在目标文件内可见，多个目标文件可以有相同的局部符号名而不会冲突。</li>
<li>GLOBAL（全局）：全局符号在目标文件内部可见，也可以被其他文件引用。全局符号在整个程序中是可见的，但是不同文件中的全局符号名称不能重复。</li>
<li>WEAK（弱）：弱符号是一种特殊的全局符号，它可以在多个文件中重复定义。即使弱符号未定义，链接过程也不会报错，而是将其符号值设置为0。弱符号可以被强符号覆盖。</li>
</ul>
<h1 id="3-6-4-节索引"><a href="#3-6-4-节索引" class="headerlink" title="3.6.4 节索引"></a>3.6.4 节索引</h1><p>节索引（Section Index）是在符号表中使用的一个索引值，用于指示每个符号所在的节（Section）。</p>
<p>在目标文件中，包含了多个节（如代码节、数据节、符号表节等），用于存储不同类型的数据和信息。而符号表（Symbol Table）中保存了所有节的符号信息。</p>
<p>为了确定每个符号所在的具体节，符号表中的每个符号都使用一个节索引来表示其所在的节。节索引是一个非负整数，它对应着目标文件中节头表（Section Header Table）中的表项序号。</p>
<p>节头表是目标文件中的一部分，用于描述每个节的属性和位置等信息。每个节头表的表项都包含了该节的名称、类型、大小、偏移量等信息。通过符号表中的节索引，可以找到符号所属的具体节，并将该符号绑定到该节上。</p>
<p>在符号表中，还有几个特殊的节索引值：</p>
<ul>
<li>ABS：表示符号的绝对值，不需要进行重定位，即该符号的地址是绝对的。</li>
<li>UNDEF：表示未定义符号，即在当前模块中引用了该符号，但在其他地方定义。</li>
<li>COMMON：表示尚未分配位置的未初始化数据，通常用于全局未初始化的变量。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BF%90%E8%A1%8C/" rel="tag">程序的编译、链接和运行</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-3-5-编译过程-2-汇编过程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/3-5-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B-2-%E6%B1%87%E7%BC%96%E8%BF%87%E7%A8%8B/"
    >3.5-编译过程(2)-汇编过程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/3-5-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B-2-%E6%B1%87%E7%BC%96%E8%BF%87%E7%A8%8B/" class="article-date">
  <time datetime="2023-09-04T23:46:58.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">c高级编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="3-5-1-汇编过程"><a href="#3-5-1-汇编过程" class="headerlink" title="3.5.1 汇编过程"></a>3.5.1 汇编过程</h1><p>汇编过程的基本流程如下：</p>
<ol>
<li>词法分析：在这个阶段，汇编器将输入的源文件（通常以.s为后缀，如main.s）进行词法分析。词法分析器将源代码分解为一个个的词法单元，如指令、寄存器、标识符等，并生成词法单元流。</li>
<li>语法分析：在语法分析阶段，汇编器使用词法单元流进行语法分析。语法分析器根据语法规则将词法单元流解析为语法结构，并构建相应的语法树。语法分析过程中还会生成符号表，用于记录和管理标识符、变量和常量等信息。</li>
<li>组装：在组装阶段，汇编器将语法树转换为可执行的目标文件。这个过程包括将汇编指令转换为机器指令、填充符号表、生成重定位表等。组装器的主要任务是将汇编代码转换为机器代码，并生成可执行目标文件。</li>
<li>代码生成：在代码生成阶段，汇编器根据语法树和符号表生成目标文件的指令。这个阶段涉及指令的翻译和生成各种表信息，如重定位表、赋值信息等。指令的翻译过程将汇编指令转化为目标机器的机器指令，生成的表信息用于链接和重定位等操作。</li>
<li>主要工作：汇编过程的主要工作包括词法分析、语法分析、组装、代码生成和生成各种表信息。这些工作协同完成，最终生成可重定位目标文件（通常以.o为后缀，如main.o）。</li>
</ol>
<h1 id="3-5-2-符号表（Symbol-Table）"><a href="#3-5-2-符号表（Symbol-Table）" class="headerlink" title="3.5.2 符号表（Symbol Table）"></a>3.5.2 符号表（Symbol Table）</h1><p>​	符号表（Symbol Table）是编译器和链接器中存储程序中符号信息的数据结构。它记录了源代码中定义和引用的变量、函数、类、常量等标识符的相关信息，如名称、类型、内存地址等。符号表在编译和链接过程中起着重要的作用，用于解析符号引用、符号重定位和符号解析等任务。</p>
<p>符号表通常包含以下信息：</p>
<ol>
<li>符号名称（Symbol Name）：记录标识符的名称，如变量名、函数名等。</li>
<li>符号类型（Symbol Type）：指示标识符的类型，如整型、浮点型、函数等。</li>
<li>符号属性（Symbol Attributes）：记录标识符的属性，如是否为全局变量、局部变量、静态变量等。</li>
<li>内存地址（Memory Address）：记录标识符在内存中的地址或偏移量。</li>
<li>作用域（Scope）：指示标识符的作用域范围，如全局作用域、局部作用域等。</li>
<li>定义位置（Definition Location）：记录标识符的定义位置，用于解析符号引用。</li>
<li>引用位置（Reference Locations）：记录标识符的引用位置，用于解析符号引用。</li>
</ol>
<p>符号表在编译过程中起着重要的作用：</p>
<ol>
<li>语法分析：在语法分析阶段，编译器将标识符添加到符号表中，并记录其名称、类型和定义位置等信息。</li>
<li>符号解析：在编译器的符号解析阶段，通过符号表来解析标识符的引用。编译器会检查符号表，找到标识符的定义位置，并进行类型检查和语义分析。</li>
<li>重复定义检查：符号表可以检查是否存在重复定义的标识符，如重复的变量名或函数名。</li>
<li>作用域管理：符号表中的作用域信息可以帮助编译器正确处理局部变量和全局变量的作用域范围。</li>
<li>符号重定位：在链接过程中，符号表用于解析符号引用和进行符号重定位。链接器会根据符号表中的地址信息，将各个目标文件中的符号引用链接到正确的地址上。</li>
</ol>
<h1 id="3-5-3-重定位表（Relocation-Table）"><a href="#3-5-3-重定位表（Relocation-Table）" class="headerlink" title="3.5.3 重定位表（Relocation Table）"></a>3.5.3 重定位表（Relocation Table）</h1><p>​	重定位表（Relocation Table）是链接器生成的一种表格，用于记录需要进行符号重定位的位置和相关信息。在目标文件中，由于代码和数据的位置是相对于起始地址的偏移量，因此在链接时需要对这些位置进行调整，以确保最终生成的可执行文件能够正确地访问和使用这些代码和数据。</p>
<p>重定位表通常包含以下信息：</p>
<ol>
<li>符号名称（Symbol Name）：记录需要进行重定位的符号的名称。</li>
<li>重定位类型（Relocation Type）：指示需要进行的重定位类型，如绝对重定位、相对重定位等。</li>
<li>位置（Location）：记录需要进行重定位的位置或偏移量。</li>
<li>目标地址（Target Address）：记录需要重定位到的目标地址。</li>
</ol>
<p>重定位表在链接过程中起着重要的作用：</p>
<ol>
<li>符号解析与重定位：链接器通过重定位表中的信息，对目标文件中的符号引用进行解析和重定位。它会根据目标文件的符号表和重定位表，将符号引用链接到正确的地址上。</li>
<li>位置调整：重定位表中记录了需要进行重定位的位置和目标地址，链接器根据这些信息对目标文件中的代码和数据位置进行调整，使其能够正确地访问和使用。</li>
<li>符号冲突解决：如果存在多个目标文件中相同名称的符号，重定位表可以帮助链接器解决符号冲突的问题。通过重定位表中的符号名称和目标地址，链接器可以确定每个符号应该链接到的具体地址，从而避免冲突。</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BF%90%E8%A1%8C/" rel="tag">程序的编译、链接和运行</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-3-4-编译过程-1-从源程序到汇编文件"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/3-4-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B-1-%E4%BB%8E%E6%BA%90%E7%A8%8B%E5%BA%8F%E5%88%B0%E6%B1%87%E7%BC%96%E6%96%87%E4%BB%B6/"
    >3.4-编译过程(1)-从源程序到汇编文件</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/3-4-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B-1-%E4%BB%8E%E6%BA%90%E7%A8%8B%E5%BA%8F%E5%88%B0%E6%B1%87%E7%BC%96%E6%96%87%E4%BB%B6/" class="article-date">
  <time datetime="2023-09-04T23:46:56.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">c高级编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="3-4-1-编译输入输出"><a href="#3-4-1-编译输入输出" class="headerlink" title="3.4.1 编译输入输出"></a>3.4.1 编译输入输出</h1><p>编译过程主要是将高级语言（如C语言）的源代码转换为低级语言（如汇编语言或机器语言），以便计算机可以理解和执行。</p>
<p>在编译过程中，主要的步骤包括：</p>
<ol>
<li>词法分析（Lexical Analysis）：将源代码划分为词法单元（tokens），例如关键字、标识符、运算符和常量等。词法分析器（也称为扫描器）会扫描源代码，并生成词法单元流。</li>
<li>语法分析（Syntax Analysis）：根据语法规则，将词法单元流组织成语法树（Parse Tree）或抽象语法树（Abstract Syntax Tree，AST）。语法分析器（也称为解析器）会检查语法的正确性，并生成语法树或AST。</li>
<li>语义分析（Semantic Analysis）：对语法树或AST进行语义检查，包括类型检查、语义规则验证等。语义分析器会确保程序在语义上是合法的，并生成相应的符号表（Symbol Table）来记录变量、函数等的信息。</li>
<li>中间代码生成（Intermediate Code Generation）：将语法树或AST转换为中间表示形式，通常是一种类似于三地址码的中间代码。中间代码是一种抽象的表示形式，它更接近于底层的机器语言，但仍保留了高级语言的结构特点。</li>
<li>代码优化（Code Optimization）：对中间代码进行优化，以改善程序的性能、减少代码的执行时间或空间占用。代码优化技术包括常量传播、循环展开、公共子表达式消除等，旨在生成更高效的目标代码。</li>
<li>目标代码生成（Code Generation）：将优化后的中间代码转换为目标机器的机器代码或汇编代码。目标代码生成器会根据目标机器的体系结构和指令集生成对应的机器代码或汇编代码。</li>
<li>链接（Linking）：如果程序包含多个源文件或库文件，链接器会将它们合并为一个可执行文件。链接过程包括符号解析、重定位等步骤，以确保程序中引用的函数和变量正确地连接到对应的定义。</li>
</ol>
<h1 id="3-4-2-词法分析"><a href="#3-4-2-词法分析" class="headerlink" title="3.4.2 词法分析"></a>3.4.2 词法分析</h1><p>词法分析是编译过程中的一项关键任务，它将源代码作为输入，并将其划分为一系列记号（tokens）。</p>
<p>在词法分析过程中，主要的步骤包括：</p>
<ol>
<li>从左到右读取源程序：词法分析器按顺序逐个字符地读取源代码，从左到右进行扫描。</li>
<li>扫描和分解记号：词法分析器根据语言的词法规则，将源程序的字符流分解成一系列记号。记号可以是关键字、标识符、字面量（数字、字符串等）、特殊字符（运算符等）和分界符（分号、逗号等）等。</li>
<li>构建记号流：词法分析器将分解出的记号按顺序构建记号流，以便后续的语法分析和语义分析等阶段使用。</li>
<li>符号表：在词法分析过程中，识别到的标识符（如函数名、变量名、标号等）会被记录在符号表中。符号表是编译器维护的一张表格，用于存储标识符的属性信息（如类型、作用域等）。</li>
<li>字符串表：识别到的数字、字符串等字面量会被存放在字符串表中。字符串表是一个存储字符串字面量的表格，编译器可以使用索引来引用字符串表中的内容，以减少内存占用和提高效率。</li>
</ol>
<h1 id="3-4-3-语法分析"><a href="#3-4-3-语法分析" class="headerlink" title="3.4.3 语法分析"></a>3.4.3 语法分析</h1><p>语法分析是编译过程中的一个重要阶段，它根据语法规则检查词法分析器生成的记号流，以确定是否构成一个语法上正确的程序，并将其分解为语法短语（如程序、语句、表达式等）。语法分析器将记号流转化为语法树（Parse Tree），它是一种树形结构，表示了程序的语法结构。</p>
<p>在语法分析过程中，主要的步骤包括：</p>
<ol>
<li>语法规则：语法分析器使用预定义的语法规则来判断记号流是否符合语法要求。语法规则描述了语言的语法结构，包括语句的组成、表达式的形式等。</li>
<li>语法树构建：语法分析器根据语法规则，将记号流转化为语法树。语法树是一种树形结构，它以记号为节点，将程序的语法结构表示为树的分支和叶子节点。</li>
<li>语法分析工具：为了简化语法分析的实现，可以使用专门的语法分析工具，如Yacc（Yet Another Compiler Compiler）。这些工具提供了一种形式化的方式来描述语法规则，并自动生成语法分析器的代码。</li>
<li>通用性：由于语法规则是与编程语言相关的，不同的编程语言具有不同的语法规则。但幸运的是，对于常见的编程语言，不需要为每个编译器编写一个新的语法分析器。相同的语法分析技术和工具可以用于不同的编程语言，只需要提供相应的语法规则。</li>
<li>语法错误：如果记号流不能按照语法规则进行正确的匹配，就会发生语法错误（syntax error）。语法分析器会检测这些错误并生成相应的错误信息，指示程序中存在哪些语法错误以及其位置。</li>
</ol>
<h1 id="3-4-4-语义分析"><a href="#3-4-4-语义分析" class="headerlink" title="3.4.4 语义分析"></a>3.4.4 语义分析</h1><p>语义分析是编译过程中的一个关键阶段，它在语法分析的基础上对语句、程序、表达式等进行进一步检查，以确定其语义是否正确。语义分析器会检查静态语义和动态语义，并对整个语法树的表达式进行类型标注。</p>
<p>在语义分析过程中，主要的任务包括：</p>
<ol>
<li>静态语义：静态语义分析在编译期间进行，它关注的是在编译期能够确定的语义。静态语义包括函数实参与形参的类型匹配和转换、变量的声明和使用、类型检查等。例如，语义分析器会检查函数调用时实参与形参的类型是否匹配，是否存在未声明的变量等。</li>
<li>动态语义：动态语义分析在运行期间进行，它关注的是在运行时才能确定的语义。动态语义包括除数为零、数组越界访问等。例如，语义分析器会检查除法表达式中除数是否为零，以避免发生运行时错误。</li>
<li>类型标注：语义分析器会对整个语法树的表达式进行类型标注，即为每个表达式确定其类型信息。这可以帮助后续的代码生成和优化阶段进行类型检查和优化操作。</li>
<li>语义分析器：语义分析器是执行语义分析的工具或组件。它接收语法分析器生成的语法树作为输入，并根据语义规则进行分析和检查。语义分析器会发现并报告语义错误，如类型不匹配、未声明的变量等。</li>
</ol>
<h1 id="3-4-5-第四阶段"><a href="#3-4-5-第四阶段" class="headerlink" title="3.4.5 第四阶段"></a>3.4.5 第四阶段</h1><p>第四阶段是编译器的中间代码生成阶段。在这个阶段，编译器将语法树转换为中间代码，以便进行后续的优化和目标代码生成。</p>
<p>中间代码是一种抽象的表示形式，它通常比源代码更接近于目标代码，但仍具有较高的可移植性和可理解性。中间代码使得编译器可以对程序进行统一的优化处理，而不受目标机器的限制。</p>
<p>现代编译器的构造通常包括以下三个主要组成部分：</p>
<ol>
<li>前端：前端负责词法分析、语法分析和语义分析等任务。它将源代码转换为中间表示形式（如语法树或中间代码），并进行基本的语法和语义检查。前端确保源代码在语法和语义上是正确的，并为后续的优化和代码生成阶段提供准确的输入。</li>
<li>优化器：优化器是编译器的重要组成部分，它对中间代码进行优化。优化器通过分析和重写中间代码，以提高程序的执行效率、减少代码大小或改进其他性能指标。优化器使用各种技术，如常量传播、循环优化、数据流分析等，来改进程序的质量和性能。</li>
<li>后端：后端负责将优化后的中间代码转换为目标机器的汇编代码或机器代码。后端包括指令选择（将中间代码转换为适合目标机器的指令序列）、寄存器分配（为变量选择寄存器）、代码布局、代码生成等任务。后端将优化后的中间代码转化为目标机器能够执行的代码。</li>
</ol>
<p>中间代码是一维线性序列，更容易生成和处理。它可以在后续的优化和代码生成阶段中进行处理和转换。</p>
<p>生成中间代码的过程通常在语义分析阶段之后，在优化器之前。语义分析器将源代码转换为语法树，然后通过对语法树进行遍历和转换，生成中间代码表示。这个过程包括将每个语法结构转换为相应的中间代码指令，并保留必要的信息来保证后续的优化和代码生成。</p>
<p>中间代码具有一些特点，如：</p>
<ol>
<li>接近目标代码：中间代码的表示形式类似于目标代码，它更接近于实际的机器指令。这使得后续的代码生成阶段更容易进行，因为中间代码已经具有了一定的目标机器相关性。</li>
<li>容易生成和转换：中间代码的生成过程相对简单，通常是基于语法树的遍历和转换。中间代码的线性结构使得对其进行处理和转换更加方便，例如进行优化和目标代码生成。</li>
</ol>
<h1 id="3-4-6-为什么需要中间代码"><a href="#3-4-6-为什么需要中间代码" class="headerlink" title="3.4.6 为什么需要中间代码"></a>3.4.6 为什么需要中间代码</h1><p>使用中间代码有以下几个主要原因：</p>
<ol>
<li>可移植性：中间代码是一种与具体目标机器无关的表示形式。通过生成中间代码，编译器可以将源代码与目标机器解耦，使得编译器更加可移植。中间代码可以在不同的目标平台上进行后续的优化和代码生成，从而实现源代码在不同平台上的跨平台执行。</li>
<li>优化：中间代码提供了一个高层次的表示形式，使得编译器可以在这个层次上进行各种优化操作。编译器可以利用中间代码的结构和语义信息，进行常量传播、死代码消除、循环优化、内联函数等优化操作，以提高程序的执行效率和性能。</li>
<li>简化代码生成：中间代码更接近于目标代码的表示形式，因此在后续的代码生成阶段，可以更轻松地将中间代码转换为目标机器的汇编代码或机器代码。中间代码的生成和转换过程相对简单，可以通过一系列的规则和转换操作来实现。</li>
<li>可读性和可理解性：中间代码通常使用一种高级语言或伪代码的形式表示，相对于目标机器的汇编代码来说，更容易阅读和理解。中间代码使得编译器的工作更加透明和可追踪，同时也有助于开发人员理解编译器的工作过程。</li>
</ol>
<h2 id="3-4-6从中间代码到汇编"><a href="#3-4-6从中间代码到汇编" class="headerlink" title="3.4.6从中间代码到汇编"></a>3.4.6从中间代码到汇编</h2><p>编译器的第五阶段是生成汇编代码，该阶段将中间代码翻译为汇编文件，并最终生成目标文件。这个阶段涉及到指令选择、控制流分析、数据流分析、寄存器分配等过程。</p>
<p>以下是生成汇编代码的一般过程：</p>
<ol>
<li>指令选择：在这个过程中，编译器将中间代码转换为汇编语言指令。指令选择的目标是选择合适的汇编指令，使得它们能够实现中间代码所描述的操作。这个过程通常会根据目标机器的架构和指令集来进行，以生成与目标机器兼容的汇编代码。</li>
<li>控制流分析：控制流分析用于确定程序中的基本块和控制流图。基本块是一段连续的指令序列，没有分支或跳转。控制流图记录了程序中的基本块之间的控制流关系，包括条件分支、循环等。控制流分析是进行优化和寻找代码转换机会的基础。</li>
<li>数据流分析：数据流分析用于分析程序中的数据依赖关系。它可以确定变量的定义和使用位置，以及数据传递和转换的路径。数据流分析对于进行寄存器分配和优化非常重要，因为它提供了变量的生命周期和使用信息。</li>
<li>寄存器分配：寄存器分配是将变量和临时值映射到物理寄存器的过程。寄存器分配可以基于静态或动态策略进行。静态寄存器分配在编译时确定寄存器的分配方案，而动态寄存器分配在运行时根据需要进行寄存器分配。寄存器分配的目标是最大程度地利用寄存器，减少内存访问。</li>
<li>汇编语言生成：在这个过程中，编译器将经过指令选择、控制流分析、数据流分析和寄存器分配的中间代码转换为汇编语言。汇编语言是一种与目标机器相关的低级表示形式，它使用特定的汇编指令和寄存器来描述程序的操作和数据。生成的汇编代码将被进一步处理以生成目标文件。</li>
<li>汇编器：汇编器是一个独立工具，它将汇编语言代码转换为可执行的目标文件。汇编器接受汇编语言作为输入，根据目标机器的指令集和格式，将汇编语言翻译为机器代码，并生成目标文件。</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BF%90%E8%A1%8C/" rel="tag">程序的编译、链接和运行</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-3-3-预处理过程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/3-3-%E9%A2%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/"
    >3.3-预处理过程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/3-3-%E9%A2%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/" class="article-date">
  <time datetime="2023-09-04T23:46:55.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">c高级编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="3-3-1-预处理的过程"><a href="#3-3-1-预处理的过程" class="headerlink" title="3.3.1 预处理的过程"></a>3.3.1 预处理的过程</h1><p>预处理是编译过程中的第一步，它对源代码进行一系列的处理，包括头文件展开、宏展开、条件编译、删除注释、添加行号和文件名标识等。下面是预处理过程的主要步骤：</p>
<ol>
<li>头文件展开：将所有<code>#include</code>指令包含的文件插入到指令所在的位置。这样可以将头文件的内容插入到源代码中，使得源代码中可以使用头文件中定义的函数、变量和宏等。</li>
<li>宏展开：对所有的宏定义进行展开，并删除<code>#define</code>指令。预处理器会查找源代码中使用的宏，并将其替换为宏定义中的内容。这样可以将宏定义的代码在预处理阶段进行替换，减少了函数调用的开销。</li>
<li>条件编译：处理所有的条件预编译指令，例如<code>#if</code>、<code>#ifdef</code>、<code>#else</code>等。根据条件的真假，选择性地编译或排除部分代码。这样可以根据不同的条件编译选项，编译不同的代码分支。</li>
<li>删除注释：去除源代码中的注释部分。注释对于程序的理解和阅读很重要，但在编译过程中并不需要注释，因此预处理阶段会将注释删除，减少后续编译的工作量。</li>
<li>添加行号和文件名标识：为了方便编译调试和错误定位，预处理阶段会为每一行源代码添加行号和文件名标识。这样在编译出错时，可以准确地定位错误所在的行和文件。</li>
<li>保留#pragma命令：预处理阶段会保留<code>#pragma</code>指令。<code>#pragma</code>指令是编译器提供的一些特定功能的扩展，用于控制编译器的行为或实现特定的功能。</li>
<li>宏命令展开和文本替换：预处理阶段最后一步是对源代码进行宏命令展开和文本替换。在宏展开过程中，预处理器会查找源代码中使用的宏，并将其展开为宏定义中的内容。同时，还会进行一些文本替换的操作，例如替换宏参数、替换宏函数调用等。</li>
</ol>
<h1 id="3-3-2-为什么要进行预处理"><a href="#3-3-2-为什么要进行预处理" class="headerlink" title="3.3.2 为什么要进行预处理"></a>3.3.2 为什么要进行预处理</h1><p>预处理过程在编译过程中起着重要的作用，原因如下：</p>
<ol>
<li>宏定义：预处理阶段允许使用宏定义，宏可以将一段代码或表达式替换为预定义的文本。通过使用宏定义，可以简化代码编写，提高代码的可读性和可维护性。</li>
<li>方便条件编译：条件编译指令（如<code>#if</code>、<code>#ifdef</code>、<code>#else</code>）允许根据不同的编译条件选择性地编译或排除代码块。这对于实现跨平台兼容性或针对不同的编译配置进行调试和优化非常有用。</li>
<li>兼容各个平台和处理器架构：预处理过程可以根据不同的平台和处理器架构进行编译选项的设置。通过使用条件编译指令，可以编写适用于不同平台和处理器的代码，提高代码的可移植性和兼容性。</li>
<li>最大程度复用公用代码：通过使用头文件，可以将公用的函数、结构体和宏等定义保存在独立的文件中，并在需要的地方进行引用。这样可以实现代码的模块化和复用，减少代码的冗余和重复编写。</li>
<li>头文件包含：预处理过程中的头文件展开允许将其他文件中的代码插入到源文件中。这样可以将相关的代码组织在一起，提高代码的可读性和可维护性，并减少代码中的重复内容。</li>
<li>模块化编程：预处理过程可以通过定义和使用宏来实现模块化编程。模块化编程将代码划分为独立的功能模块，使代码更易于理解、测试和维护。</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BF%90%E8%A1%8C/" rel="tag">程序的编译、链接和运行</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-3-2-GCC命令参数"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/3-2-GCC%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0/"
    >3.2 GCC命令参数</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/3-2-GCC%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0/" class="article-date">
  <time datetime="2023-09-04T23:44:56.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">c高级编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="3-2-1-什么是GCC"><a href="#3-2-1-什么是GCC" class="headerlink" title="3.2.1 什么是GCC ?"></a>3.2.1 什么是GCC ?</h1><p>GCC指的是GNU编译器套件（GNU Compiler Collection），它是一个开源的编译器集合。GCC包括预处理器、编译器、汇编器和链接器等工具，它能够将源代码转换为可执行文件。GCC支持多种编程语言，如C、C++、Objective-C、Fortran、Ada等，并且可在多个操作系统上使用，包括Linux、Unix、Windows等。</p>
<p>除了编译器本身，GCC还提供了一些文件处理工具，如objdump、objcopy、nm、readelf和strip等，用于处理目标文件、库文件和可执行文件。此外，GCC也提供了一套标准的库文件和头文件，供开发者在编译程序时使用。</p>
<h1 id="3-2-2-gcc-参数"><a href="#3-2-2-gcc-参数" class="headerlink" title="3.2.2 gcc 参数"></a>3.2.2 gcc 参数</h1><p>通过在GCC命令行中使用不同的参数，可以调用GCC工具集中的不同工具。以下是一些常用的参数和对应的工具：</p>
<ul>
<li><code>-E</code>：预处理，调用cpp预处理器，将源代码中的宏定义展开、包含头文件等操作。</li>
<li><code>-S</code>：生成汇编文件，GCC将合并预处理后的代码，并将其转换为汇编语言。</li>
<li><code>-c</code>：生成目标文件，调用汇编器as，将汇编代码转换为机器代码，但不进行链接操作。</li>
<li><code>-o &lt;output&gt;</code>：指定输出文件的名称，可以用于指定生成的目标文件或可执行文件的名称。</li>
<li><code>--verbose</code>：显示详细的编译信息，包括调用的工具和执行的步骤。</li>
</ul>
<p>gcc -E main.c<br>该命令会直接将预处理的内容打印到终端并不会生成一个文件，所以需要指定一下输出文件，重定向，如下所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309050822386.png" alt="image-20230905082213343"></p>
<p>同样的gcc -S main.c 也是如此</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309050822178.png" alt="image-20230905082250151"></p>
<p>更多参数的详细介绍</p>
<ol>
<li><p><strong>控制编译过程的参数</strong>：</p>
<ul>
<li><code>-c</code>：只编译源文件，生成目标文件而不进行链接。</li>
<li><code>-S</code>：生成汇编代码文件，不进行编译和链接。</li>
<li><code>-E</code>：只进行预处理，生成预处理后的源代码。</li>
<li><code>-o &lt;output&gt;</code>：指定输出文件的名称。</li>
<li><code>-I &lt;dir&gt;</code>：指定头文件搜索路径。</li>
<li><code>-L &lt;dir&gt;</code>：指定库文件搜索路径。</li>
<li><code>-M</code>：生成文件依赖关系。使用该选项时，GCC会分析源文件中的<code>#include</code>指令，输出每个源文件及其所包含的头文件之间的依赖关系。输出结果通常以makefile规则的格式呈现。</li>
<li><code>-MD</code>：与<code>-M</code>相同，但是将输出导入到<code>.d</code>文件中。生成的<code>.d</code>文件通常包含了源文件及其所包含的头文件之间的依赖关系，可以在makefile中引用这些<code>.d</code>文件来自动化编译过程。</li>
<li><code>-MM</code>：与<code>-M</code>相似，但忽略<code>#include &lt;file.h&gt;</code>产生的依赖关系。这意味着只生成自定义头文件（使用双引号<code>#include &quot;file.h&quot;</code>）的依赖关系，而不包括系统头文件（使用尖括号<code>#include &lt;file.h&gt;</code>）。</li>
<li></li>
</ul>
</li>
<li><p><strong>编译选项的设置</strong>：</p>
<ul>
<li><p><code>-std=&lt;standard&gt;</code>：指定使用的语言标准，如<code>-std=c11</code>表示使用C11标准。</p>
</li>
<li><p><code>-Wall</code>：开启所有警告信息。</p>
</li>
<li><p><code>-Werror</code>：将警告视为错误，编译过程中遇到警告将中止。</p>
</li>
<li><p><code>-Wextra</code>：开启额外的警告选项。</p>
</li>
<li><p><code>-pedantic</code>：严格遵循语言标准，显示更多警告信息。</p>
</li>
<li><p><code>-g</code>：在编译过程中生成调试信息，用于调试程序。这些调试信息可以被调试器（如GDB）使用。</p>
</li>
<li><p><code>-static</code>：禁止使用动态库，强制链接静态库。这意味着编译后的可执行文件将不依赖于系统上已安装的动态库，而是包含了所有必要的库的副本。</p>
</li>
<li><p><code>-shared</code>：生成共享目标文件，也称为共享库或动态库。共享库可以在运行时被不同的程序加载和使用。</p>
</li>
<li><p><code>-L&lt;dir&gt;</code>：指定库搜索路径。使用该选项可以告诉编译器在指定的目录中搜索库文件。</p>
</li>
<li><p><code>-l&lt;libname&gt;</code>：指定编译时使用的库。例如，<code>-lmath</code>将链接数学库。编译器会在标准库搜索路径和使用<code>-L</code>选项指定的路径中查找库文件。</p>
</li>
<li><p><code>-I&lt;dir&gt;</code>：指定头文件搜索路径。使用该选项可以告诉编译器在指定的目录中搜索头文件。</p>
</li>
<li><p><code>-w</code>：禁止生成任何警告信息。编译器将不会显示任何警告。</p>
</li>
<li><p><code>-std=c99</code>：指定使用C99标准进行编译。GCC默认采用GNU C标准。</p>
</li>
</ul>
</li>
<li><p><strong>编译器优化选项</strong>：</p>
<ul>
<li><code>-O0</code>、<code>-O1</code>、<code>-O2</code>、<code>-O3</code>：控制编译器的优化级别，从无优化到高级优化。</li>
<li><code>-Os</code>：优化代码大小。</li>
<li><code>-Ofast</code>：最大程度地优化代码执行速度，可能牺牲一些标准的符合性。</li>
<li><code>-march=&lt;arch&gt;</code>：指定目标处理器架构，优化代码以适应特定处理器。</li>
</ul>
</li>
</ol>
<h1 id="3-2-3-交叉编译"><a href="#3-2-3-交叉编译" class="headerlink" title="3.2.3 交叉编译"></a>3.2.3 交叉编译</h1><p>交叉编译是指在一种平台上进行编译，生成能够在另一种不同平台上运行的可执行文件或镜像。在交叉编译中，编译器和工具链被配置为目标平台的编译器和工具，以便生成与目标平台兼容的代码和可执行文件。</p>
<p>例如，如果你正在运行的是 x86 架构的电脑，但你想要编译一个在 ARM 架构的嵌入式设备上运行的程序，就需要进行交叉编译。在这种情况下，你需要使用针对 ARM 架构的交叉编译器和工具链，例如 <code>arm-linux-gnueabi-gcc</code>。</p>
<p>安装交叉编译器和工具链时，你可以使用适合你的发行版的包管理器。在这个例子中，你可以使用 <code>apt</code> 包管理器来安装 ARM 架构的交叉编译器和工具链，命令如下：</p>
<p>Copy</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install gcc-arm-linux-gnueabi</span><br></pre></td></tr></table></figure>

<p>安装完成后，你就可以使用 <code>arm-linux-gnueabi-gcc</code> 命令来进行 ARM 架构的交叉编译了。这样你就能够生成适用于 ARM 架构设备的可执行文件或镜像。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BF%90%E8%A1%8C/" rel="tag">程序的编译、链接和运行</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-3-1-程序的编译与可执行文件"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/04/3-1-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"
    >程序的编译与可执行文件</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/3-1-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/" class="article-date">
  <time datetime="2023-09-04T13:19:52.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">c高级编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="3-1-程序的编译与可执行文件"><a href="#3-1-程序的编译与可执行文件" class="headerlink" title="3.1 程序的编译与可执行文件"></a>3.1 程序的编译与可执行文件</h1><h2 id="3-1-1-可执行文件的组装"><a href="#3-1-1-可执行文件的组装" class="headerlink" title="3.1.1 可执行文件的组装"></a>3.1.1 可执行文件的组装</h2><p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042146452.png" alt="image-20230904214608380"></p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042146097.png" alt="image-20230904214623995"></p>
<p>编译过程的特点可以总结如下：</p>
<p>非一步到位：编译过程不是一次性完成的，而是分为多个阶段逐步完成的。</p>
<p>环环相扣：每个阶段的输出作为下一个阶段的输入，各个阶段之间有着紧密的联系和依赖关系。</p>
<p>分为预编译、编译、汇编、链接阶段：编译过程可以划分为预处理、编译、汇编和链接几个主要阶段。</p>
<p>调用不同的工具：每个阶段都调用不同的工具或编译器来完成特定的任务。</p>
<ul>
<li><p>预处理：在预处理阶段，预处理器将源文件进行处理，如宏展开、头文件包含等，生成处理后的源文件。</p>
</li>
<li><p>编译：在编译阶段，编译器将处理后的源文件转换为汇编语言代码，进行语法分析、语义分析、优化等操作。</p>
</li>
<li><p>汇编：在汇编阶段，汇编器将生成的汇编语言代码转换为机器语言指令，并生成目标文件。</p>
</li>
<li><p>链接：在链接阶段，链接器将多个目标文件和库文件进行链接，解析符号引用，生成可执行目标文件（如ELF格式）。</p>
</li>
</ul>
<p>生成可执行文件是编译过程中的最终目标，但为什么编译过程中不直接生成可执行文件，而是分为多个阶段呢？</p>
<p>首先是GNU的思想，即”一个工具只干一件事情”。GNU工具链以及许多其他编译工具都遵循这个原则。将编译过程分为多个阶段，每个阶段有专门的工具来处理，可以使得每个工具更加专注于自己的任务。例如，预处理器负责处理宏展开、头文件包含等，编译器负责将源代码转换为汇编代码，汇编器负责将汇编代码转换为机器代码，链接器负责将目标文件链接为可执行文件。这样的分工可以简化每个工具的实现和复杂度，使得工具更加可靠、可维护，并提高了工具的复用性。</p>
<p>其次是计算机工业思维中的标准接口和分层原则。将编译过程分为多个阶段，每个阶段的输入和输出都有明确定义的接口，使得每个阶段都可以独立进行开发和优化。这样的分层结构可以适配更多的平台、CPU架构和指令集，使得编译器可以在不同的系统上使用相同的前端和中间表示，通过后端进行特定平台的代码生成。这种模块化和分层的设计使得编译器更加灵活、可扩展，并能够适应不断变化的计算机体系结构和需求。</p>
<h2 id="3-1-2-从源程序到可执行文件"><a href="#3-1-2-从源程序到可执行文件" class="headerlink" title="3.1.2 从源程序到可执行文件"></a>3.1.2 从源程序到可执行文件</h2><p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042152389.png" alt="image-20230904215208244"></p>
<ol>
<li>预处理：源程序中的 <code>#include&lt;stdio.h&gt;</code> 被预处理器处理，将对应的头文件内容插入到源程序中，生成处理后的源程序。</li>
<li>编译：编译器将处理后的源程序进行语法分析、语义分析、优化等操作，生成目标文件。在目标文件中，包括以下部分：<ul>
<li>ELF header：ELF（可执行与可链接格式）头部，包含关于文件格式的信息。</li>
<li>Program header table：程序头表，描述程序的段（段包含代码、数据等）。</li>
<li>.text 段：包含程序的机器代码。</li>
<li>.rodata 段：包含只读数据，如字符串常量。</li>
<li>.data 段：包含已初始化的全局和静态变量。</li>
<li>.bss 段：包含未初始化的全局和静态变量。</li>
</ul>
</li>
<li>链接：链接器将目标文件进行链接，生成可执行文件。在可执行文件中，包括以下部分：<ul>
<li>ELF header：与目标文件相同，包含关于文件格式的信息。</li>
<li>Program header table：与目标文件相同，描述程序的段。</li>
<li>.text 段：与目标文件相同，包含程序的机器代码。</li>
<li>.rodata 段：与目标文件相同，包含只读数据。</li>
<li>.data 段：与目标文件相同，包含已初始化的全局和静态变量。</li>
<li>.bss 段：与目标文件相同，包含未初始化的全局和静态变量。</li>
<li>符号表（.symtab）：包含程序中定义的全局和静态符号的信息。</li>
<li>字符串表（.strtab）：保存符号表中的字符串。</li>
<li>调试信息（.debug）：包含调试器使用的信息。</li>
<li>行号信息（.line）：包含源代码的行号信息。</li>
</ul>
</li>
</ol>
<p>最终生成的可执行文件包含了程序的机器代码、数据、符号表等信息，可以在计算机上执行。编译过程中的中间文件和信息都嵌入到最终的可执行文件中，以便在运行时进行处理和调试。</p>
<h2 id="3-1-3-目标文件"><a href="#3-1-3-目标文件" class="headerlink" title="3.1.3 目标文件"></a>3.1.3 目标文件</h2><p>目标文件（Object file）是编译器生成的中间文件，它包含了编译后的机器代码、数据和符号信息，用于最终生成可执行文件或共享目标文件。目标文件的类型可以通过命令 <code>file</code> 进行查看。</p>
<p>常见的目标文件类型包括：</p>
<ul>
<li>可重定位目标文件（Relocatable files）：这种类型的目标文件包含了编译后的机器代码、数据和符号信息，但是它们的内部地址是相对于起始地址的偏移量，还没有进行最终的地址分配和链接。可重定位目标文件可以作为其他可重定位目标文件或可执行目标文件的输入，用于生成最终的可执行文件或共享目标文件。</li>
<li>可执行目标文件（Executable files）：这种类型的目标文件是经过链接的最终可执行文件，包含了所有的机器代码、数据和符号信息，可以直接在操作系统上执行。</li>
<li>可被共享目标文件（Shared object file）：也被称为动态链接库（Dynamic Linking Library）或共享库（Shared Library）。这种类型的目标文件包含了可被多个可执行文件或其他共享库共享使用的代码和数据，可以在运行时动态加载到内存中，并与其他程序共享使用。</li>
<li>可执行文件（ELF，Executable and Linkable Format）：这是一种可执行文件的格式，广泛用于类UNIX系统。可执行文件可以直接在操作系统上执行，包含了机器代码、数据和符号信息，以及其他与执行相关的信息（如程序入口点等）。</li>
</ul>
<h2 id="3-1-4-ELF可执行文件的结构"><a href="#3-1-4-ELF可执行文件的结构" class="headerlink" title="3.1.4 ELF可执行文件的结构"></a>3.1.4 ELF可执行文件的结构</h2><ol>
<li>ELF header（ELF 头）：包含了关于文件格式的信息，如文件类型、目标体系结构、入口点地址等。</li>
<li>Program header table（程序头表）：描述了可执行文件的段（segment）信息，每个段对应一个或多个节（section），包括代码段、只读数据段、可读写数据段等。程序头表记录了每个段的起始地址、大小、访问权限等信息。</li>
<li>.init 段：包含了可执行文件在加载到内存后需要执行的初始化代码，如全局变量的初始化和动态链接器的初始化等。</li>
<li>.text、.rodata、.data、.bss 等段：这些段包含了实际的代码和数据。<ul>
<li>.text 段：包含了可执行代码的机器指令，也就是程序的代码段。</li>
<li>.rodata 段：包含了只读数据，如字符串常量等。</li>
<li>.data 段：包含了已初始化的全局和静态变量。</li>
<li>.bss 段：包含了未初始化的全局和静态变量，这些变量在运行时会被初始化为 0。</li>
</ul>
</li>
<li>符号表（.symtab）：记录了程序中定义和引用的全局和静态符号的信息，如函数和变量。符号表中包含了符号的名称、类型、大小、地址等信息。</li>
<li>调试信息（.debug）：包含了调试器使用的信息，如源代码的行号信息、变量和函数的调试信息等。</li>
<li>行号信息（.line）：包含了源代码的行号信息，用于将机器代码映射回源代码的行号。</li>
<li>字符串表（.strtab）：保存了符号表和调试信息中使用的字符串。</li>
<li>Section header table（节头表）：描述了各个节的信息，包括名称、类型、偏移量、大小等。</li>
</ol>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_val = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> uninit_val;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> local_val = <span class="number">2</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> uninit_local_val;</span><br><span class="line">    </span><br><span class="line">    a = add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    b = sub(<span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sub.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用以下命令编译成目标文件，但是不进行链接</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c main.c sub.c</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042209197.png" alt="image-20230904220907171"></p>
<p>使用以下命令读取ELF header</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -h main.o</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042211626.png" alt="image-20230904221103590"></p>
<p>然后使用以下命令查看节头表（section heads）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -S main.o</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042213386.png" alt="image-20230904221310333"></p>
<p>最后使用以下命令进行链接,生成可执行文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.o sub.o</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042215351.png" alt="image-20230904221504326"></p>
<p>重新读取elf头和section heads</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">topeet@ubuntu:~/demo$ readelf -h a.out </span><br><span class="line">ELF 头：</span><br><span class="line">  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  类别:                              ELF64</span><br><span class="line">  数据:                              2 补码，小端序 (little endian)</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          0</span><br><span class="line">  类型:                              DYN (共享目标文件)</span><br><span class="line">  系统架构:                          Advanced Micro Devices X86-64</span><br><span class="line">  版本:                              0x1</span><br><span class="line">  入口点地址：               0x1060</span><br><span class="line">  程序头起点：          64 (bytes into file)</span><br><span class="line">  Start of section headers:          15016 (bytes into file)</span><br><span class="line">  标志：             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         13</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         31</span><br><span class="line">  Section header string table index: 30</span><br><span class="line">topeet@ubuntu:~/demo$ read</span><br><span class="line">read         readarray    readelf      readlink     readonly     readprofile  </span><br><span class="line">topeet@ubuntu:~/demo$ readelf -S a.out </span><br><span class="line">There are 31 section headers, starting at offset 0x3aa8:</span><br><span class="line"></span><br><span class="line">节头：</span><br><span class="line">  [号] 名称              类型             地址              偏移量</span><br><span class="line">       大小              全体大小          旗标   链接   信息   对齐</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .interp           PROGBITS         0000000000000318  00000318</span><br><span class="line">       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">  [ 2] .note.gnu.propert NOTE             0000000000000338  00000338</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE             0000000000000358  00000358</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .note.ABI-tag     NOTE             000000000000037c  0000037c</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 5] .gnu.hash         GNU_HASH         00000000000003a0  000003a0</span><br><span class="line">       0000000000000028  0000000000000000   A       6     0     8</span><br><span class="line">  [ 6] .dynsym           DYNSYM           00000000000003c8  000003c8</span><br><span class="line">       00000000000000c0  0000000000000018   A       7     1     8</span><br><span class="line">  [ 7] .dynstr           STRTAB           0000000000000488  00000488</span><br><span class="line">       0000000000000088  0000000000000000   A       0     0     1</span><br><span class="line">  [ 8] .gnu.version      VERSYM           0000000000000510  00000510</span><br><span class="line">       0000000000000010  0000000000000002   A       6     0     2</span><br><span class="line">  [ 9] .gnu.version_r    VERNEED          0000000000000520  00000520</span><br><span class="line">       0000000000000020  0000000000000000   A       7     1     8</span><br><span class="line">  [10] .rela.dyn         RELA             0000000000000540  00000540</span><br><span class="line">       00000000000000c0  0000000000000018   A       6     0     8</span><br><span class="line">  [11] .rela.plt         RELA             0000000000000600  00000600</span><br><span class="line">       0000000000000018  0000000000000018  AI       6    24     8</span><br><span class="line">  [12] .init             PROGBITS         0000000000001000  00001000</span><br><span class="line">       000000000000001b  0000000000000000  AX       0     0     4</span><br><span class="line">  [13] .plt              PROGBITS         0000000000001020  00001020</span><br><span class="line">       0000000000000020  0000000000000010  AX       0     0     16</span><br><span class="line">  [14] .plt.got          PROGBITS         0000000000001040  00001040</span><br><span class="line">       0000000000000010  0000000000000010  AX       0     0     16</span><br><span class="line">  [15] .plt.sec          PROGBITS         0000000000001050  00001050</span><br><span class="line">       0000000000000010  0000000000000010  AX       0     0     16</span><br><span class="line">  [16] .text             PROGBITS         0000000000001060  00001060</span><br><span class="line">       0000000000000225  0000000000000000  AX       0     0     16</span><br><span class="line">  [17] .fini             PROGBITS         0000000000001288  00001288</span><br><span class="line">       000000000000000d  0000000000000000  AX       0     0     4</span><br><span class="line">  [18] .rodata           PROGBITS         0000000000002000  00002000</span><br><span class="line">       0000000000000014  0000000000000000   A       0     0     4</span><br><span class="line">  [19] .eh_frame_hdr     PROGBITS         0000000000002014  00002014</span><br><span class="line">       0000000000000064  0000000000000000   A       0     0     4</span><br><span class="line">  [20] .eh_frame         PROGBITS         0000000000002078  00002078</span><br><span class="line">       0000000000000188  0000000000000000   A       0     0     8</span><br><span class="line">  [21] .init_array       INIT_ARRAY       0000000000003db8  00002db8</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [22] .fini_array       FINI_ARRAY       0000000000003dc0  00002dc0</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [23] .dynamic          DYNAMIC          0000000000003dc8  00002dc8</span><br><span class="line">       00000000000001f0  0000000000000010  WA       7     0     8</span><br><span class="line">  [24] .got              PROGBITS         0000000000003fb8  00002fb8</span><br><span class="line">       0000000000000048  0000000000000008  WA       0     0     8</span><br><span class="line">  [25] .data             PROGBITS         0000000000004000  00003000</span><br><span class="line">       0000000000000018  0000000000000000  WA       0     0     8</span><br><span class="line">  [26] .bss              NOBITS           0000000000004018  00003018</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     4</span><br><span class="line">  [27] .comment          PROGBITS         0000000000000000  00003018</span><br><span class="line">       000000000000002b  0000000000000001  MS       0     0     1</span><br><span class="line">  [28] .symtab           SYMTAB           0000000000000000  00003048</span><br><span class="line">       00000000000006f0  0000000000000018          29    49     8</span><br><span class="line">  [29] .strtab           STRTAB           0000000000000000  00003738</span><br><span class="line">       0000000000000255  0000000000000000           0     0     1</span><br><span class="line">  [30] .shstrtab         STRTAB           0000000000000000  0000398d</span><br><span class="line">       000000000000011a  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br><span class="line">topeet@ubuntu:~/demo$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-1-5-动态库和静态库的生成"><a href="#3-1-5-动态库和静态库的生成" class="headerlink" title="3.1.5 动态库和静态库的生成"></a>3.1.5 动态库和静态库的生成</h2><p>使用以下命令可以生成静态库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libsub.a sub.o</span><br></pre></td></tr></table></figure>

<p>其中库的名字必须以lib开头，使用readelf重新读取以下该库的elf头，如下所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042226316.png" alt="image-20230904222640273"></p>
<p>使用以下命令生成动态库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC -o libsub.so sub.c</span><br></pre></td></tr></table></figure>

<p>然后使用readelf 读取elf头如下所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042227936.png" alt="image-20230904222725900"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BF%90%E8%A1%8C/" rel="tag">程序的编译、链接和运行</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-10-6 cmake-基础课"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/03/10-6%20cmake-%E5%9F%BA%E7%A1%80%E8%AF%BE/"
    >cmake 基础课</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/03/10-6%20cmake-%E5%9F%BA%E7%A1%80%E8%AF%BE/" class="article-date">
  <time datetime="2023-09-03T09:50:19.000Z" itemprop="datePublished">2023-09-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/3588-npu/">3588 npu</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="一、准备知识"><a href="#一、准备知识" class="headerlink" title="一、准备知识"></a>一、准备知识</h1><h2 id="1-1-C-的编译过程"><a href="#1-1-C-的编译过程" class="headerlink" title="1.1 C++的编译过程"></a>1.1 C++的编译过程</h2><ul>
<li>-E 仅预处理；不编译、汇编或链接。</li>
<li>-S 仅编译；不汇编或链接。</li>
<li>-c 编译和汇编，但不链接。</li>
<li>-o <file> 将输出放入<file>中。</li>
</ul>
<p><strong>C++源代码的编译过程</strong></p>
<ol>
<li><p><strong>预处理</strong>：在预处理阶段，C++源代码中的预处理指令会被处理，包括宏展开和条件编译等。在此阶段，需要添加所有头文件的引用路径。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将xx.cpp源文件预处理为xx.i文件（文本文件）</span></span><br><span class="line">g++ -E main.cpp -o main.i</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编译</strong>：编译阶段会对预处理后的代码进行语法检查和编译，将代码翻译为汇编语言文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将xx.i文件编译为xx.s的汇编文件（文本文件）</span></span><br><span class="line">g++ -S main.i -o main.s</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>汇编</strong>：汇编阶段将汇编语言文件转换为二进制格式的目标文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将xx.s文件汇编为xx.o的二进制目标文件</span></span><br><span class="line">g++ -c main.s -o main.o</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>链接</strong>：链接阶段将目标文件与所依赖的库文件进行关联或组装，生成可执行文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将目标文件进行链接，生成可执行程序</span></span><br><span class="line">g++ main.o -o main</span><br><span class="line">```</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="1-2-静态链接库和动态链接库"><a href="#1-2-静态链接库和动态链接库" class="headerlink" title="1.2 静态链接库和动态链接库"></a>1.2 静态链接库和动态链接库</h2><p>静态链接库和动态链接库的区别在于链接的阶段不同。</p>
<p><strong>静态链接库</strong>的名称通常以<code>.a</code>结尾（表示archive library），它在编译阶段进行链接。如果一个工程依赖于静态链接库，那么生成的可执行文件或库会将静态链接库<code>.a</code>打包到输出文件中，因此生成的文件比较大。在运行时，不再需要单独的库文件。</p>
<p><strong>动态链接库</strong>的链接发生在程序的执行过程中，它在编译阶段仅进行链接检查，而不进行真正的链接过程。动态链接库的后缀名通常为<code>.so</code>（表示shared object，在Linux上）或<code>.dylib</code>（在macOS上）。动态链接库在加载后，在内存中只保存一份拷贝。多个程序依赖于它时，不会重复加载和拷贝，节省了内存空间。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/image-20230903175645024.png" alt="image-20230903175645024"></p>
<h2 id="1-3-为什么需要CMake"><a href="#1-3-为什么需要CMake" class="headerlink" title="1.3 为什么需要CMake"></a>1.3 为什么需要CMake</h2><h3 id="1-3-1-g-命令行编译"><a href="#1-3-1-g-命令行编译" class="headerlink" title="1.3.1 g++命令行编译"></a>1.3.1 g++命令行编译</h3><p>当编译hello_world.cpp&#96;文件时，可以使用以下命令进行编译和运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -o main</span><br></pre></td></tr></table></figure>

<p>如果需要引入外部库可以使用以下方法进行编译：</p>
<p>方法一：使用<code>-lgflags</code>参数进行链接**</p>
<p>首先，需要安装<code>gflags</code>库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libgflags-dev libgflags2.2</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">然后，使用以下命令进行编译：</span><br><span class="line"></span><br><span class="line">````bash</span><br><span class="line">g++ main.cpp -lgflags -o main</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>方法二：使用<code>pkg-config</code>进行库文件和头文件路径查找**</p>
<p>首先，需要安装<code>pkg-config</code>工具：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install pkg-config</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">然后，使用以下命令进行编译：</span><br><span class="line"></span><br><span class="line">````bash</span><br><span class="line">g++ main.cpp `pkg-config --cflags --libs gflags` -o main</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">这里，`pkg-config --cflags --libs gflags`命令用于查找`gflags`库的头文件和库文件路径。</span><br></pre></td></tr></table></figure>

<p>编译完成后，可以使用以下命令运行可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main --age 31 --name alice</span><br></pre></td></tr></table></figure>

<p>有时候，在编译时不需要手动添加头文件或链接库路径，因为<code>g++</code>可以在默认的查询路径中找到这些库。然而，当项目文件和引入的外部库变得较多时，使用命令行编译会变得冗长且不便于调试和编辑。通常，在测试单个文件时可以使用命令行编译，但不推荐在实际项目中使用命令行编译方式。</p>
<h3 id="1-3-2-CMake简介"><a href="#1-3-2-CMake简介" class="headerlink" title="1.3.2 CMake简介"></a>1.3.2 CMake简介</h3><p>在实际工作中，推荐使用CMake来构建C++项目。CMake是一个开源的跨平台工具，用于构建、测试和软件打包。</p>
<p>CMake具有以下特性：</p>
<ul>
<li><strong>自动搜索依赖项</strong>：CMake具有自动搜索可能需要的程序、库和头文件的能力，可以简化依赖项的配置过程。</li>
<li><strong>独立的构建目录</strong>：CMake支持使用独立的构建目录（例如<code>build</code>目录），这样可以安全地清理构建产生的中间文件和输出文件，不会污染源代码目录。</li>
<li><strong>自定义命令</strong>：CMake支持定义复杂的自定义命令，例如下载文件、生成各种文件等，可以满足项目构建过程中的特定需求。</li>
<li><strong>自定义配置</strong>：CMake支持根据需求进行自定义配置，可以选择性地启用或禁用特定的组件或功能。</li>
<li><strong>文本文件生成工作区和项目</strong>：CMake使用简单的文本文件（<code>CMakeLists.txt</code>）来描述项目的配置和构建规则，可以根据这些文件自动生成工作区和项目。</li>
<li><strong>文件依赖项自动生成和并行构建</strong>：CMake可以在主流平台上自动生成文件之间的依赖关系，从而使构建过程更高效。同时，CMake支持并行构建，可以加快构建速度。</li>
<li><strong>支持多种IDE</strong>：CMake几乎支持所有主流的集成开发环境（IDE），包括Visual Studio、Xcode、Eclipse等，可以方便地在不同的开发环境中进行项目开发和调试。</li>
</ul>
<h1 id="二、CMake基础知识"><a href="#二、CMake基础知识" class="headerlink" title="二、CMake基础知识"></a>二、CMake基础知识</h1><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h2><p>在Ubuntu上安装CMake可以使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install cmake -y</span><br></pre></td></tr></table></figure>

<p>这将使用apt包管理器自动安装CMake。</p>
<p>如果你想编译安装特定版本的CMake，可以按照以下步骤操作：</p>
<p>克隆CMake的源代码库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone -b v3.25.1 https://github.com/Kitware/CMake.git</span><br><span class="line">cd CMake</span><br><span class="line"></span><br><span class="line">这里以安装版本3.25.1为例，你可以将`v3.25.1`替换为你想要安装的特定版本。</span><br></pre></td></tr></table></figure>

<p>配置和编译CMake：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./bootstrap --prefix=&lt;安装路径&gt;</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">你可以使用`--prefix`选项来指定安装路径，或者省略`--prefix`以安装到默认路径。</span><br></pre></td></tr></table></figure>

<p>安装CMake：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">这将以管理员权限安装CMake到系统中。</span><br></pre></td></tr></table></figure>

<p>安装完成后，你可以验证CMake的安装版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure>

<p>该命令将显示CMake的版本信息，确认安装成功与否。</p>
<h2 id="2-2-第一个CMake例子"><a href="#2-2-第一个CMake例子" class="headerlink" title="2.2 第一个CMake例子"></a>2.2 第一个CMake例子</h2><p><strong>配置：</strong> 使用<code>cmake</code>命令进行配置，其中<code>-S</code>选项指定源码目录，<code>-B</code>选项指定构建目录。在终端中执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake -S . -B build</span><br><span class="line"></span><br><span class="line">这将在当前目录下执行CMake配置，并将生成的构建系统文件放在名为`build`的目录中。</span><br></pre></td></tr></table></figure>

<p><strong>生成：</strong> 使用<code>cmake --build</code>命令进行生成，其中<code>--build</code>选项指定构建目录。在终端中执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake --build build</span><br><span class="line"></span><br><span class="line">这将在`build`目录中执行构建步骤，生成可执行文件。</span><br></pre></td></tr></table></figure>

<p><strong>运行：</strong> 使用以下命令运行生成的可执行文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./build/first_cmake</span><br><span class="line"></span><br><span class="line">这将执行生成的可执行文件。</span><br></pre></td></tr></table></figure>

<h2 id="2-3-语法基础"><a href="#2-3-语法基础" class="headerlink" title="2.3 语法基础"></a>2.3 语法基础</h2><h3 id="2-3-1-指定版本"><a href="#2-3-1-指定版本" class="headerlink" title="2.3.1 指定版本"></a>2.3.1 指定版本</h3><p>在CMake中，可以使用<code>cmake_minimum_required</code>命令指定当前项目所需的最低CMake版本。它的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION &lt;version_number&gt;)</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;version_number&gt;</code>是所需的最低CMake版本号。在这个命令之后，CMake将会检查系统中安装的CMake版本是否满足这个要求，如果不满足则会产生错误。</p>
<p>例如，如果要指定最低的CMake版本为3.10，可以在CMakeLists.txt文件中添加以下命令：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br></pre></td></tr></table></figure>

<p>这样，CMake将会检查系统中的CMake版本是否大于等于3.10。</p>
<p>除了<code>cmake_minimum_required</code>命令，CMake中还有其他类似的命令，它们不区分大小写，并且有许多关键字来引导命令的参数输入，类似于函数的参数传递。这些命令使用的关键字在CMake中是不区分大小写的。</p>
<h3 id="2-3-2-设置项目"><a href="#2-3-2-设置项目" class="headerlink" title="2.3.2 设置项目"></a>2.3.2 设置项目</h3><p>在CMakeLists.txt文件的开头，通常会使用<code>project</code>命令来指定项目的名称、版本、描述和所使用的语言。<code>project</code>命令的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(ProjectName</span><br><span class="line">    [VERSION &lt;version_number&gt;]</span><br><span class="line">    [DESCRIPTION <span class="string">&quot;project_description&quot;</span>]</span><br><span class="line">    [LANGUAGES &lt;language&gt;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>其中，<code>ProjectName</code>是项目的名称，在例子中使用的是”first_cmake”。<code>VERSION</code>关键字后面是项目的版本号，可以是任意格式的版本号，例如”1.0.0”。<code>DESCRIPTION</code>关键字后面是项目的描述，可以是一个字符串。<code>LANGUAGES</code>关键字后面是项目所使用的语言，这里使用的是”Cxx”，表示C++。</p>
<p>示例中的<code>project</code>命令：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(first_cmake</span><br><span class="line">    VERSION <span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line">    DESCRIPTION <span class="string">&quot;项目描述&quot;</span></span><br><span class="line">    LANGUAGES Cxx</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这样，通过<code>project</code>命令，可以在CMakeLists.txt中指定项目的基本信息，方便管理和描述项目。</p>
<h3 id="2-3-3-添加可执行文件目标"><a href="#2-3-3-添加可执行文件目标" class="headerlink" title="2.3.3 添加可执行文件目标"></a>2.3.3 添加可执行文件目标</h3><p>使用了<code>add_executable</code>命令来定义一个可执行文件。该命令的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(&lt;target_name&gt; &lt;source_files&gt;)</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;target_name&gt;</code>是最终生成的可执行文件名，也是在CMake中定义的目标（Target）名。<code>&lt;source_files&gt;</code>是编译目标所使用的源文件。</p>
<p>在你提供的例子中，使用了<code>add_executable</code>命令来定义一个名为<code>first_cmake</code>的目标，并指定了一个源文件<code>main.cpp</code>。这意味着在编译时，会将<code>main.cpp</code>编译为一个可执行文件，该文件的名称将是<code>first_cmake</code>。</p>
<p>示例中的<code>add_executable</code>命令：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(first_cmake main.cpp)</span><br></pre></td></tr></table></figure>

<p>通过<code>add_executable</code>命令，可以在CMakeLists.txt中定义编译目标，并指定相应的源文件。这样，CMake将会根据这些定义生成相应的构建规则和编译指令。</p>
<h3 id="2-3-4-生成静态库并链接"><a href="#2-3-4-生成静态库并链接" class="headerlink" title="2.3.4 生成静态库并链接"></a>2.3.4 生成静态库并链接</h3><p>A. 生成静态库：</p>
<p>在<code>account_dir/CMakeLists.txt</code>中，使用<code>add_library</code>命令来生成静态库。该命令的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_library(&lt;library_name&gt; &lt;library_type&gt; &lt;source_files&gt;)</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;library_name&gt;</code>是最终生成的库文件名，例如在Linux下会生成<code>libAccount.a</code>。</p>
<p><code>&lt;library_type&gt;</code>用于指定链接库的类型，可以是动态链接库（<code>SHARED</code>）或静态链接库（<code>STATIC</code>）。</p>
<p><code>&lt;source_files&gt;</code>是需要用到的源文件。</p>
<p>例如，在<code>account_dir/CMakeLists.txt</code>中，使用<code>add_library</code>命令生成一个名为<code>Account</code>的静态库，其包含了<code>Account.cpp</code>和<code>Account.h</code>两个源文件。示例命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Account STATIC Account.cpp Account.h)</span><br></pre></td></tr></table></figure>

<p>这将生成一个静态库文件<code>libAccount.a</code>。</p>
<p>B. 链接：</p>
<p>在<code>test_account/CMakeLists.txt</code>中，可以通过<code>target_link_libraries</code>命令将生成的静态库链接到目标可执行文件中。该命令的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(&lt;target_name&gt; &lt;library_name&gt;)</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;target_name&gt;</code>是目标可执行文件的名称，<code>&lt;library_name&gt;</code>是要链接的库文件名。</p>
<p>例如，在<code>test_account/CMakeLists.txt</code>中，假设有一个目标可执行文件名为<code>test_account</code>，需要链接生成的静态库<code>Account</code>。示例命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(test_account Account)</span><br></pre></td></tr></table></figure>

<p>这样，生成的可执行文件<code>test_account</code>将会链接静态库<code>Account</code>。</p>
<h3 id="2-3-5-生成动态库并连接"><a href="#2-3-5-生成动态库并连接" class="headerlink" title="2.3.5 生成动态库并连接"></a>2.3.5 生成动态库并连接</h3><p>A. 生成动态库：</p>
<p>在<code>account_dir/CMakeLists.txt</code>中，使用<code>add_library</code>命令来生成动态库。与生成静态库不同的是，需要将<code>&lt;library_type&gt;</code>参数设置为<code>SHARED</code>，表示生成动态链接库。</p>
<p>示例命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Account SHARED Account.cpp Account.h)</span><br></pre></td></tr></table></figure>

<p>这将生成一个动态库文件<code>libAccount.so</code>。</p>
<p>B. 链接：</p>
<p>链接过程与生成静态库时的操作相同，使用<code>target_link_libraries</code>命令将动态库链接到目标可执行文件中。</p>
<p>示例命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(test_account Account)</span><br></pre></td></tr></table></figure>

<p>这样，生成的可执行文件<code>test_account</code>将会链接动态库<code>Account</code>。</p>
<h3 id="2-3-6-CMake中的PUBLIC、PRIVATE、INTERFACE"><a href="#2-3-6-CMake中的PUBLIC、PRIVATE、INTERFACE" class="headerlink" title="2.3.6 CMake中的PUBLIC、PRIVATE、INTERFACE"></a>2.3.6 CMake中的PUBLIC、PRIVATE、INTERFACE</h3><p>在CMake中，可以使用<code>target_...()</code>系列命令来操作目标（Target）。这些命令通常支持通过<code>PUBLIC</code>、<code>PRIVATE</code>、<code>INTERFACE</code>关键字来控制属性的传播。</p>
<p>以<code>target_link_libraries(A B)</code>为例，下面是对这些关键字的理解：</p>
<ul>
<li><code>PRIVATE</code>：依赖项B仅链接到目标A。如果有目标C链接了目标A，目标C不会链接目标B。</li>
<li><code>INTERFACE</code>：依赖项B并不链接到目标A。如果有目标C链接了目标A，目标C会链接目标B。</li>
<li><code>PUBLIC</code>：依赖项B链接到目标A。如果有目标C链接了目标A，目标C也会链接目标B。</li>
</ul>
<p>可以将其类比为一个散烟的比方：</p>
<ul>
<li><code>PRIVATE</code>：就是自己抽烟，不给别人抽。</li>
<li><code>INTERFACE</code>：就是自己不抽烟，给别人抽。</li>
<li><code>PUBLIC</code>：就是自己抽烟，也给别人抽。</li>
</ul>
<p>从使用的角度来看，假设有目标C链接了目标A：</p>
<ul>
<li>如果目标B仅用于目标A的实现，并且不在头文件中提供给目标C使用，可以使用<code>PRIVATE</code>。</li>
<li>如果目标B不用于目标A的实现，仅在头文件中作为接口给目标C使用，可以使用<code>INTERFACE</code>。</li>
<li>如果目标B既用于目标A的实现，也在头文件中提供给目标C使用，可以使用<code>PUBLIC</code>。</li>
</ul>
<p>以下是一个示例：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建库</span></span><br><span class="line"><span class="keyword">add_library</span>(c c.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(D d.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(B b.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用target_link_libraries命令进行链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(A PRIVATE B)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(A INTERFACE C)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(A PUBLIC D)</span><br></pre></td></tr></table></figure>

<p>在上述示例中，目标<code>A</code>通过<code>target_link_libraries</code>命令链接了目标<code>B</code>、<code>C</code>和<code>D</code>，使用了不同的传播属性。具体属性的选择取决于目标之间的关系和使用需求。</p>
<h3 id="2-3-7-变量"><a href="#2-3-7-变量" class="headerlink" title="2.3.7 变量"></a>2.3.7 变量</h3><p>在CMake中，你可以使用<code>message</code>命令输出消息并进行变量的操作和设置。</p>
<p>以下是一些常见的用法：</p>
<p>1.输出消息：使用<code>message</code>命令可以输出消息到CMake的输出。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;输出消息&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>2.消息拼接：使用<code>message</code>命令可以将多个消息进行拼接输出。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;输出1&quot;</span> <span class="string">&quot;输出2&quot;</span> <span class="string">&quot;输出3&quot;</span>)  <span class="comment"># 会进行拼接输出</span></span><br></pre></td></tr></table></figure>

<p>3.设置变量：使用<code>set</code>命令可以设置变量的值。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(VAR1 <span class="string">&quot;变量1&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;VAR1=&quot;</span> <span class="variable">$&#123;VAR1&#125;</span>)  <span class="comment"># 外部访问</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;输出变量VAR1:$&#123;VAR1&#125;&quot;</span>)  <span class="comment"># 内部拼接</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;\$&#123;VAR1&#125;=$&#123;VAR1&#125;&quot;</span>)  <span class="comment"># 使用\转义</span></span><br></pre></td></tr></table></figure>

<p>4.删除变量：使用<code>unset</code>命令可以删除变量。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unset</span>(VAR1)  <span class="comment"># 删除变量</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;\$&#123;VAR1&#125;=$&#123;VAR1&#125;&quot;</span>)  <span class="comment"># 删除变量后，输出为空</span></span><br></pre></td></tr></table></figure>

<p>5.设置变量缓存：使用<code>set</code>命令的<code>CACHE</code>选项可以设置一个变量的缓存，可以通过命令行的<code>-D</code>参数来修改该变量的值。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CACHE_VARIABLE_TEST <span class="string">&quot;原始值&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;变量缓存的描述&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;变量缓存的值:$&#123;CACHE_VARIABLE_TEST&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>6.常见的内置变量：CMake提供了一些内置的变量，用于获取构建系统的信息和配置</p>
<p>第一类: 提供信息的变量</p>
<ul>
<li><code>PROJECT_NAME</code>：项目名称，表示当前CMake项目的名称。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;PROJECT_NAME&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMAKE_SOURCE_DIR</code>：源码目录，表示当前CMake项目的根源码目录。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMAKE_BINARY_DIR</code>：编译目录，表示当前CMake项目的编译输出目录。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMAKE_CURRENT_LIST_FILE</code>：当前CMakeLists.txt文件路径，表示当前正在处理的CMakeLists.txt文件的完整路径。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_FILE&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这些变量提供了与项目、目录结构和文件相关的信息。</p>
<hr>
<p>第二类: 控制CMake运行的变量</p>
<p>CMake中的变量通常是根据构建选项进行命名的，例如<code>BUILD_SHARED_LIBS</code>。这些变量用于控制CMake的运行和构建过程。</p>
<hr>
<p>第三类: 描述系统的变量</p>
<ul>
<li><code>WIN32</code>：表示当前操作系统是否为Windows。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;是否是Windows系统: $&#123;WIN32&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>UNIX</code>：表示当前操作系统是否为类Unix（包括Linux、macOS等）。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;是否是Unix系统: $&#123;UNIX&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMAKE_SYSTEM_NAME</code>：系统名称，表示当前操作系统的名称。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;系统名称: $&#123;CMAKE_SYSTEM_NAME&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这些变量用于描述当前操作系统的一些信息，以便在构建过程中进行条件判断和配置。</p>
<h3 id="2-3-8-include引入其他代码"><a href="#2-3-8-include引入其他代码" class="headerlink" title="2.3.8 include引入其他代码"></a>2.3.8 include引入其他代码</h3><h3 id="2-3-9-条件控制"><a href="#2-3-9-条件控制" class="headerlink" title="2.3.9 条件控制"></a>2.3.9 条件控制</h3><p>CMake提供了条件控制的语法和关键词，使得你可以根据条件来控制构建过程中的行为。以下是一些常用的条件控制关键词和语法：</p>
<ul>
<li><code>if (variable)</code>：当变量的值为真时，执行相应的代码块。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE为真时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>else()</code>：在if条件为假时执行的代码块。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE为真时执行的代码块</span></span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE为假时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>真值常量：<code>ON</code>、<code>YES</code>、<code>TRUE</code>、<code>Y</code>、<code>1</code>、非零数字等。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE <span class="keyword">STREQUAL</span> <span class="string">&quot;ON&quot;</span>)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE的值为真时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>假值常量：<code>OFF</code>、<code>NO</code>、<code>FALSE</code>、<code>N</code>、<code>0</code>、空字符串、<code>NOTFOUND</code>等。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE <span class="keyword">STREQUAL</span> <span class="string">&quot;OFF&quot;</span>)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE的值为假时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>关键词：<code>NOT</code>、<code>TARGET</code>、<code>EXISTS (file)</code>、<code>DEFINED</code>等，可以与条件一起使用。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> <span class="keyword">TARGET</span> MyTarget)</span><br><span class="line">    <span class="comment"># 当MyTarget不存在时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>逻辑运算符：<code>AND</code>、<code>OR</code>用于组合多个条件。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (CONDITION1 <span class="keyword">AND</span> CONDITION2)</span><br><span class="line">    <span class="comment"># 当CONDITION1和CONDITION2同时为真时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CONDITION1 <span class="keyword">OR</span> CONDITION2)</span><br><span class="line">    <span class="comment"># 当CONDITION1或CONDITION2至少一个为真时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>MATCHES (regular expression)</code>：使用正则表达式进行匹配。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE <span class="keyword">MATCHES</span> <span class="string">&quot;^prefix.*&quot;</span>)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE以&quot;prefix&quot;开头时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>VERSION LESS</code>、<code>VERSION LESS_EQUAL</code>：用于比较版本号。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VERSION VERSION <span class="keyword">LESS</span> <span class="number">2.0</span>)</span><br><span class="line">    <span class="comment"># 当MY_VERSION小于2.0时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>通过这些条件控制关键词和语法，你可以根据不同的条件来执行不同的代码块，从而实现更灵活和可配置的构建过程。你可以根据具体的需求选择适当的条件控制方式，并结合变量、关键词和运算符来编写CMake脚本。</p>
<h3 id="2-3-10-CMake分步编译"><a href="#2-3-10-CMake分步编译" class="headerlink" title="2.3.10 CMake分步编译"></a>2.3.10 CMake分步编译</h3><p>首先，你使用以下命令查看所有的目标：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target help</span><br></pre></td></tr></table></figure>

<p>这将列出项目中可用的目标列表，包括默认目标”all”、”clean”、”depend”、”rebuild_cache”、”edit_cache”以及其他一些目标。</p>
<p>接下来，你执行以下命令进行预处理：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target main.i</span><br></pre></td></tr></table></figure>

<p>这将对”main.cpp”源文件进行预处理，并将预处理结果保存在”CMakeFiles&#x2F;steps_demo.dir&#x2F;main.cpp.i”文件中。</p>
<p>然后，你执行以下命令进行编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target main.sI</span><br></pre></td></tr></table></figure>

<p>这将将”main.cpp”源文件编译为汇编代码，并将汇编代码保存在”CMakeFiles&#x2F;steps_demo.dir&#x2F;main.cpp.s”文件中。</p>
<p>接着，你执行以下命令进行汇编：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target main.o</span><br></pre></td></tr></table></figure>

<p>这将将汇编代码编译为目标文件，并将目标文件保存为”CMakeFiles&#x2F;steps_demo.dir&#x2F;main.cpp.o”。</p>
<p>最后，你执行以下命令进行链接：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build .</span><br></pre></td></tr></table></figure>

<p>这将扫描依赖项并链接生成最终的可执行文件”steps_demo”。</p>
<p>最后，你执行以下命令运行可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./steps_demo</span><br></pre></td></tr></table></figure>

<p>这将运行生成的可执行文件。</p>
<h3 id="2-3-11-生成器表达式"><a href="#2-3-11-生成器表达式" class="headerlink" title="2.3.11 生成器表达式"></a>2.3.11 生成器表达式</h3><p>生成器表达式是CMake中一种用于在生成构建系统时根据不同配置动态生成特定内容的表达式。它可以让代码更加精简和灵活。下面是几种常用的生成器表达式类型：</p>
<p>条件表达式：<code>$&lt;condition:true_string&gt;</code>。当条件为真时，返回<code>true_string</code>，否则返回空字符串。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&lt;<span class="number">0</span>:<span class="keyword">TEST</span>&gt;           <span class="comment"># 返回空字符串</span></span><br><span class="line">$&lt;<span class="number">1</span>:<span class="keyword">TEST</span>&gt;           <span class="comment"># 返回&quot;TEST&quot;</span></span><br><span class="line">$&lt;$&lt;BOOL:<span class="keyword">TRUE</span>&gt;:<span class="keyword">TEST</span>&gt;  <span class="comment"># 返回&quot;TEST&quot;</span></span><br></pre></td></tr></table></figure>

<p>变量查询（Variable-Query）：通过查询变量来获取动态的值。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&lt;TARGET_EXISTS:<span class="keyword">target</span>&gt;             <span class="comment"># 判断目标是否存在</span></span><br><span class="line">$&lt;CONFIG:Debug&gt;                     <span class="comment"># 判断当前构建类型是否为Debug</span></span><br></pre></td></tr></table></figure>

<p>目标查询（Target-Query）：通过查询目标来获取相关的信息。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&lt;TARGET_FILE:<span class="keyword">target</span>&gt;               <span class="comment"># 获取目标的文件路径</span></span><br><span class="line">$&lt;TARGET_FILE_NAME:<span class="keyword">target</span>&gt;          <span class="comment"># 获取目标的文件名</span></span><br></pre></td></tr></table></figure>

<p>输出相关表达式：用于在不同的构建环节使用不同的参数。比如，在<code>install</code>和<code>build</code>阶段使用不同的参数。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Foo ...)</span><br><span class="line"><span class="keyword">target_include_directories</span>(Foo</span><br><span class="line">    PUBLIC</span><br><span class="line">        $&lt;$&lt;CONFIG:Debug&gt;:<span class="variable">$&#123;DEBUG_INCLUDES&#125;</span>&gt;</span><br><span class="line">        $&lt;$&lt;CONFIG:Release&gt;:<span class="variable">$&#123;RELEASE_INCLUDES&#125;</span>&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在上述示例中，根据不同的构建配置（Debug或Release），生成器表达式选择性地包含不同的头文件路径。</p>
<p>需要注意的是，生成器表达式在生成构建系统时被展开，因此无法通过<code>message</code>命令直接打印。你可以使用类似<code>file(GENERATE OUTPUT &quot;./generator_test.txt&quot; CONTENT &quot;$&lt;$&lt;BOOL:TRUE&gt;:TEST&gt;&quot;)</code>的方式将生成器表达式的结果写入文件，以间接测试生成器表达式的值。</p>
<h3 id="2-3-12-函数和宏"><a href="#2-3-12-函数和宏" class="headerlink" title="2.3.12 函数和宏"></a>2.3.12 函数和宏</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个宏</span></span><br><span class="line"><span class="keyword">macro</span>(my_macro)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;宏内部的信息&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(macro_var <span class="string">&quot;宏内部变量test&quot;</span>)</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数</span></span><br><span class="line"><span class="keyword">function</span>(second_func arg1 arg2)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;第一个参数: $&#123;arg1&#125;，第二个参数: $&#123;arg2&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>my_macro</code>是一个没有参数的宏，它在宏内部输出一条信息，并设置了一个变量<code>macro_var</code>的值。</p>
<p><code>second_func</code>是一个函数，它有两个参数<code>arg1</code>和<code>arg2</code>。在函数内部，它输出了两个参数的值。</p>
<p>你可以在CMakeLists.txt文件中使用这些宏和函数，例如：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用宏</span></span><br><span class="line">my_macro()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">second_func(<span class="string">&quot;Hello&quot;</span> <span class="string">&quot;World&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当你运行CMake生成构建系统时，你将看到宏内部的信息输出，并且可以访问在宏或函数内部定义的变量。函数将输出参数的值。</p>
<p>请注意，宏和函数的定义需要在CMakeLists.txt文件的适当位置进行，并且在调用它们之前必须先定义它们。</p>
<h3 id="2-3-13-设置安装"><a href="#2-3-13-设置安装" class="headerlink" title="2.3.13 设置安装"></a>2.3.13 设置安装</h3><p><code>install</code>命令用于设置安装规则，将目标文件和文件夹安装到指定的位置。下面是你提供的代码的解释：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS instal_demo slib dlib</span><br><span class="line">    RUNTIME DESTINATION bin     <span class="comment"># 可执行文件安装路径</span></span><br><span class="line">    LIBRARY DESTINATION lib     <span class="comment"># 动态库安装路径</span></span><br><span class="line">    ARCHIVE DESTINATION lib     <span class="comment"># 静态库安装路径</span></span><br><span class="line">    PUBLIC_HEADER DESTINATION <span class="keyword">include</span>   <span class="comment"># 公共头文件安装路径</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>install</code>命令指定了要安装的目标文件列表，其中包括<code>instal_demo</code>、<code>slib</code>和<code>dlib</code>。</p>
<p>接下来，通过指定不同的<code>DESTINATION</code>参数，定义了目标文件在安装过程中的安装路径：</p>
<ul>
<li><code>RUNTIME DESTINATION bin</code>：指定可执行文件的安装路径为<code>bin</code>目录。</li>
<li><code>LIBRARY DESTINATION lib</code>：指定动态库的安装路径为<code>lib</code>目录。</li>
<li><code>ARCHIVE DESTINATION lib</code>：指定静态库的安装路径为<code>lib</code>目录。</li>
<li><code>PUBLIC_HEADER DESTINATION include</code>：指定公共头文件的安装路径为<code>include</code>目录。</li>
</ul>
<p>根据你的需求，这些目标文件将被安装到指定的目录中。</p>
<p>请注意，安装路径是相对于安装目录的，因此你需要确保安装目录在运行<code>make install</code>时正确设置。</p>
<p>要解决在安装后无法找到动态库的问题，可以使用<code>set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)</code>和<code>set(CMAKE_INSTALL_RPATH &quot;$&#123;CMAKE_INSTALL_PREFIX&#125;/lib&quot;)</code>来设置RPATH。</p>
<p>下面是相应的代码：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_WITH_INSTALL_RPATH <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_RPATH <span class="string">&quot;$&#123;CMAKE_INSTALL_PREFIX&#125;/lib&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)</code>指示在构建过程中使用与安装RPATH相同的RPATH。这样，在构建时就可以正确地查找和链接动态库。</p>
<p><code>set(CMAKE_INSTALL_RPATH &quot;$&#123;CMAKE_INSTALL_PREFIX&#125;/lib&quot;)</code>将安装RPATH设置为<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/lib</code>，其中<code>$&#123;CMAKE_INSTALL_PREFIX&#125;</code>是安装目录的路径。这将导致在安装时设置RPATH，使得安装后的可执行文件可以在<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/lib</code>目录中正确地查找和加载动态库。</p>
<p>通过使用这两个设置，你可以解决在安装后无法找到动态库的问题。确保将其放置在CMakeLists.txt文件中的合适位置，并根据实际情况调整<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/lib</code>路径，以匹配你的安装目录结构。</p>
<h3 id="2-3-14-寻找依赖find-package"><a href="#2-3-14-寻找依赖find-package" class="headerlink" title="2.3.14 寻找依赖find_package"></a>2.3.14 寻找依赖find_package</h3><p>对于大多数支持CMake的项目来说，可以使用<code>find_package</code>命令来查找对应的依赖库。通常情况下，如果找到了库，会设置以下变量（这些变量由库的作者设置）：</p>
<ul>
<li><code>&lt;LibaryName&gt;_FOUND</code>：表示是否找到库。</li>
<li><code>&lt;LibaryName&gt;_INCLUDE_DIR</code>：表示库的头文件目录。</li>
<li><code>&lt;LibaryName&gt;_LIBRARIES</code>：表示库的库文件目录。</li>
</ul>
<p>如果你编写了一个新的函数库，并希望其他项目可以通过<code>find_package</code>引用它，你可以使用以下两种方法：</p>
<ol>
<li><p>编写一个<code>Find&lt;LibraryName&gt;.cmake</code>文件：适用于导入非CMake安装的项目。</p>
<p>你可以编写一个名为<code>Find&lt;LibraryName&gt;.cmake</code>的文件，并将其放置在CMake的<code>Modules</code>目录或项目的特定目录中。该文件应包含查找和设置相关变量的逻辑。其他项目可以通过<code>find_package</code>命令来引用这个自定义的查找文件，从而找到并使用你的库。</p>
<p>附件: 15.custom_find</p>
</li>
<li><p>使用<code>install</code>安装并生成<code>&lt;LibraryName&gt;Config.cmake</code>文件：适用于导入你自己开发的CMake项目。</p>
<p>在你的库项目中，可以使用<code>install</code>命令将库文件安装到指定位置，并生成<code>&lt;LibraryName&gt;Config.cmake</code>文件。该文件应包含设置变量和导出目标的逻辑。其他项目可以通过<code>find_package</code>命令找到并使用你的库。</p>
</li>
</ol>
<p>&#x3D;&#x3D;现在只是简单的写了一下学习的内容，但是对于很多内容还并不是很熟悉，一切都要等到最后实战的时候&#x3D;&#x3D;</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/3588-npu/" rel="tag">3588 npu</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-10-5 c-进阶语法-oop-智能指针-STL"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/03/10-5%20c-%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95-oop-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-STL/"
    >c++进阶语法 oop 智能指针 STL</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/03/10-5%20c-%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95-oop-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-STL/" class="article-date">
  <time datetime="2023-09-03T05:42:43.000Z" itemprop="datePublished">2023-09-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/3588-npu/">3588 npu</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-OOP面向对象开发"><a href="#1-OOP面向对象开发" class="headerlink" title="1 OOP面向对象开发"></a>1 OOP面向对象开发</h1><h2 id="1-1-类-class-和对象-objects"><a href="#1-1-类-class-和对象-objects" class="headerlink" title="1.1 类(class)和对象(objects)"></a>1.1 类(class)和对象(objects)</h2><pre><code>类(classes)和对象(objects)
</code></pre>
<p>C++类(classes)</p>
<ul>
<li>创建对象用的蓝图(blueprint)</li>
<li>用户自定义的数据类型</li>
<li>有成员属性(data)和成员方法(methods)</li>
<li>可以隐藏属性和方法(private)</li>
<li>可以提供公共接口(public)</li>
<li>示例:Account,Student,std:vector, std:string</li>
</ul>
<p>C++对象(objects)</p>
<ul>
<li>由类创建而来</li>
<li>表示类的一个具体的实例(lnstance)</li>
<li>可以有很多个实例，每个都有独立的身份·每个对象都可以使用类中定义的方法</li>
</ul>
<p>Account对象示例</p>
<ul>
<li>Jobs、Alice的apunt是Account类的实例</li>
<li>每个实例都有它的余额、可以提现、存钱</li>
</ul>
<p>声明一个类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span></span>; <span class="comment">// 存款</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span></span>; <span class="comment">// 取款</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建类的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Account jobs_account;</span><br><span class="line">Account alice_account;</span><br><span class="line">Account* mary_account = <span class="keyword">new</span> <span class="built_in">Account</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> mary_account;</span><br></pre></td></tr></table></figure>



<p>示例1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> </span><br><span class="line">&#123;</span><br><span class="line">    string name &#123;<span class="string">&quot;None&quot;</span>&#125;;</span><br><span class="line">    <span class="type">double</span> balance &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Account a;</span><br><span class="line">    Account b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>获取类的属性或者方法</p>
<p>使用点操作符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Account jobs_account;</span><br><span class="line">jobs_account.balance;</span><br><span class="line">jobs_account.<span class="built_in">deposit</span>( <span class="number">10.00</span>);</span><br></pre></td></tr></table></figure>

<p>如果是一个指向对象的指针，可以解引用或者使用箭头操作符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Account* alice_account = <span class="keyword">new</span> <span class="built_in">Account</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解引用指针并访问成员</span></span><br><span class="line">(*alice_account).balance; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指针访问成员</span></span><br><span class="line">alice_account-&gt;<span class="built_in">deposit</span>(<span class="number">100.0</span>);</span><br><span class="line">alice_account-&gt;balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> alice_account;</span><br></pre></td></tr></table></figure>



<h2 id="1-2-public、private、protected访问权限"><a href="#1-2-public、private、protected访问权限" class="headerlink" title="1.2 public、private、protected访问权限"></a>1.2 public、private、protected访问权限</h2><p>public</p>
<p>可以被任何实体访问   </p>
<hr>
<p>private<br>只能被本类的方法访问</p>
<hr>
<p>protected</p>
<p>可以被本类和子类(继承)的方法访问\</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span></span>; <span class="comment">// 存款</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span></span>; <span class="comment">// 取款</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>在类中实现完整的成员方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="type">double</span> balance &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">setBalance</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        balance = amount;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在类外面实现需要特殊定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="type">double</span> balance &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">setBalance</span><span class="params">(<span class="type">double</span> amount)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBalance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Account::setBalance</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">    balance = amount;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Account::getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-3-构造函数-constructor"><a href="#1-3-构造函数-constructor" class="headerlink" title="1.3 构造函数(constructor)"></a>1.3 构造函数(constructor)</h2><ul>
<li>特殊的成员方法</li>
<li>对象创建的时候自动调用</li>
<li>适用于实例参数初始化</li>
<li>函数名和类的名称一致</li>
<li>无需设置返回类型</li>
<li>可以被重载(overload)</li>
</ul>
<h2 id="1-4-析构函数-destructor"><a href="#1-4-析构函数-destructor" class="headerlink" title="1.4 析构函数(destructor)"></a>1.4 析构函数(destructor)</h2><ul>
<li>特殊的成员方法</li>
<li>函数名和类的名称一致，前面跟着一个~波浪符号</li>
<li>对象销毁的时候自动调用</li>
<li>没有参数，没有返回类型</li>
<li>只有一个析构函数(不能重载)</li>
<li>适用于释放内存等资源</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    std::string name&#123;<span class="string">&quot;account&quot;</span>&#125;;</span><br><span class="line">    <span class="type">double</span> balance&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Account</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Account</span>(std::string name);</span><br><span class="line">    <span class="built_in">Account</span>(<span class="type">double</span> balance);</span><br><span class="line">    <span class="built_in">Account</span>(std::string name, <span class="type">double</span> balance);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Account</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​		</p>
<h2 id="1-5-构造函数初始化列表"><a href="#1-5-构造函数初始化列表" class="headerlink" title="1.5 构造函数初始化列表"></a>1.5 构造函数初始化列表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，使用构造函数内部初始化参数</span></span><br><span class="line">    <span class="built_in">Account</span>(std::string name, <span class="type">double</span> balance) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，使用初始化列表初始化参数</span></span><br><span class="line">    <span class="built_in">Account</span>(std::string name, <span class="type">double</span> balance)</span><br><span class="line">        : name&#123;name&#125;, balance&#123;balance&#125; &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-代理构造函数"><a href="#1-6-代理构造函数" class="headerlink" title="1.6 代理构造函数"></a>1.6 代理构造函数</h2><ul>
<li>重载的构造函数很相似·冗余的代码可能会导致错误</li>
<li>使用代理构造函数</li>
<li>在一个构造函数初始化列表中调用另一个构造函数</li>
</ul>
<h2 id="1-7-拷贝构造函数"><a href="#1-7-拷贝构造函数" class="headerlink" title="1.7 拷贝构造函数"></a>1.7 拷贝构造函数</h2><p>当对象被拷贝时，C++必须从已存在的对象复制出一个新的对象</p>
<p>何时使用拷贝构造函数?</p>
<ul>
<li>以值传递方式传递对象给函数（作参数)</li>
<li>函数以值方式返回对象</li>
<li>使用已存在的对象复制新的对象</li>
</ul>
<p>如果不提供自己写的copy constructor,编译器会自动生成一个(可能不符合要</p>
<h2 id="1-9-浅拷贝和深拷贝"><a href="#1-9-浅拷贝和深拷贝" class="headerlink" title="1.9 浅拷贝和深拷贝"></a>1.9 浅拷贝和深拷贝</h2><p>如果不提供自己写的copy constructor.编译器会生成默认的<br>将目标对象的值逐个拷贝过来;<br>如果是指针，拷贝的是值（指向的地址)，而不是指向的对象（浅拷贝)在析构函数中释放内存时，其他对象中的指针可能还在指向被释放的资源</p>
<h2 id="1-10-在类中使用const"><a href="#1-10-在类中使用const" class="headerlink" title="1.10 在类中使用const"></a>1.10 在类中使用const</h2><p>在类中使用const常函数</p>
<p>函数名称后加const</p>
<ul>
<li>函数体内不可以修改类成员属性。常对象</li>
</ul>
<p>声明对象时前面加const</p>
<ul>
<li>不可以修改常对象的成员属性仅能调用常函数</li>
</ul>
<h2 id="1-11-在类中使用static"><a href="#1-11-在类中使用static" class="headerlink" title="1.11 在类中使用static"></a>1.11 在类中使用static</h2><p>静态成员变量</p>
<ul>
<li><p>所有对象共有同一份数据（数据共享)</p>
</li>
<li><p>在类中声明，类外初始化</p>
</li>
</ul>
<p>静态成员函数</p>
<p>所有对象共享同一个函数</p>
<ul>
<li>只能访问静态成员变量</li>
</ul>
<h2 id="1-12-struct和class区别"><a href="#1-12-struct和class区别" class="headerlink" title="1.12 struct和class区别"></a>1.12 struct和class区别</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    std::string name&#123;<span class="string">&quot;none&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认私有属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    std::string name&#123;<span class="string">&quot;none&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 默认公有属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Account aa;</span><br><span class="line">    <span class="comment">// aa.name = &quot;bob&quot;; // 报错，无法访问私有成员</span></span><br><span class="line"></span><br><span class="line">    Student ss;</span><br><span class="line">    ss.name = <span class="string">&quot;alice&quot;</span>; <span class="comment">// 可以访问公有成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-智能指针"><a href="#2-智能指针" class="headerlink" title="2 智能指针"></a>2 智能指针</h1><p>原始指针(raw pointer)的一些问题</p>
<p>1.c++提供了内存管理的绝对自由度</p>
<ul>
<li><p>分配</p>
</li>
<li><p>释放</p>
</li>
<li><p>声明周期管理</p>
</li>
</ul>
<p>2.一些潜在严重问题</p>
<ul>
<li><p>未初始化的指针(wild pointer)</p>
</li>
<li><p>内存泄漏(memory leak)</p>
</li>
<li><p>悬空指针(dangling pointer</p>
</li>
</ul>
<p>3.所有权(ownership)</p>
<ul>
<li>谁拥有指针?</li>
<li>何时可以删除指针?</li>
</ul>
<p>C++智能指针是一种用来管理动态分配的内存的工具，它们遵循RAII（资源获取即初始化）原则，可以自动释放内存，防止内存泄漏。</p>
<p>以下是几种常见的C++智能指针：</p>
<ol>
<li><code>unique_ptr</code>: <code>unique_ptr</code> 是一种独占所有权的智能指针，它指向堆上分配的对象，并负责在其生命周期结束时自动删除对象。每个 <code>unique_ptr</code> 只能拥有一个对象，并且不能进行拷贝，但可以进行移动。</li>
<li><code>shared_ptr</code>: <code>shared_ptr</code> 是一种共享所有权的智能指针，多个 <code>shared_ptr</code> 可以指向同一个对象。它使用引用计数来跟踪对象的所有者数量，并在最后一个所有者释放内存时删除对象。</li>
<li><code>weak_ptr</code>: <code>weak_ptr</code> 是一种弱引用指针，它可以与 <code>shared_ptr</code> 一起使用。<code>weak_ptr</code> 不会增加对象的引用计数，它允许对被 <code>shared_ptr</code> 管理的对象进行观测，但不拥有所有权。当 <code>shared_ptr</code> 删除对象后，<code>weak_ptr</code> 会自动失效。</li>
<li><code>auto_ptr</code>（已弃用）: <code>auto_ptr</code> 是C++98标准引入的智能指针，它类似于 <code>unique_ptr</code>，但具有一些问题和局限性，已被废弃，不推荐使用。</li>
</ol>
<p><code>unique_ptr&lt;T&gt;</code> 是一种独占所有权的智能指针，用于指向堆上的类型为 <code>T</code> 的对象。它保证在其生命周期结束时自动释放所指向的对象，确保资源的正确释放，避免内存泄漏。</p>
<p><code>unique_ptr</code> 的特点如下：</p>
<ul>
<li>它是唯一（unique）的，即一个 <code>unique_ptr</code> 对象拥有对应对象的唯一所有权。不能有多个 <code>unique_ptr</code> 指向同一个对象，这样可以避免多次释放同一块内存的问题。</li>
<li><code>unique_ptr</code> 不能进行复制或赋值，但可以通过移动语义来转移所有权。这意味着可以将所有权从一个 <code>unique_ptr</code> 转移到另一个 <code>unique_ptr</code>，从而实现对象所有权的转移而不进行内存复制。</li>
<li>当 <code>unique_ptr</code> 使用完毕或超出作用域时，它所指向的对象会自动释放和销毁，无需手动调用 <code>delete</code>。</li>
</ul>
<p>&#x3D;&#x3D;目前还没用过，等真正用过的时候再仔细看吧&#x3D;&#x3D;</p>
<h1 id="3-STL标准模板库"><a href="#3-STL标准模板库" class="headerlink" title="3 STL标准模板库"></a>3 STL标准模板库</h1><h2 id="3-1-STL简介"><a href="#3-1-STL简介" class="headerlink" title="3.1 STL简介"></a>3.1 STL简介</h2><p>一个强大的、可复用的、自适应的泛型类和函数集合</p>
<p>使用C++模板(templates)实现</p>
<p>实现了常见的数据结构(data struuctures)和算法(algorithms)</p>
<p>庞大的类库</p>
<p>俄裔美籍程序员:Alexander Step:anov 1994年开发</p>
<p>容器(containers)</p>
<ul>
<li>各种对象或原始类型的集合. array、vector、deque、stack、set、map等</li>
</ul>
<p>算法(algorithms)</p>
<ul>
<li>处理容器元素序列的各种函数find、max、count、accumulate、sort等</li>
</ul>
<p>迭代器(iterators)</p>
<ul>
<li>从容器中生成元素的序列. forward、reveise、by value、by constant等</li>
</ul>
<h2 id="3-2-STL容器的类别"><a href="#3-2-STL容器的类别" class="headerlink" title="3.2 STL容器的类别"></a>3.2 STL容器的类别</h2><p>序列式容器（Sequence Containers）：</p>
<ol>
<li><code>vector</code>：动态数组，支持快速随机访问，尾部插入和删除元素效率高，但在中间或头部插入和删除元素效率低。</li>
<li><code>list</code>：双向链表，支持在任意位置插入和删除元素，但随机访问效率较低。</li>
<li><code>forward_list</code>：单向链表，与 <code>list</code> 类似，但只支持单向遍历，没有双向遍历的能力。</li>
<li><code>deque</code>：双端队列，支持在头部和尾部高效地插入和删除元素，同时支持随机访问。</li>
</ol>
<p>关联式容器（Associative Containers）：</p>
<ol>
<li><code>set</code>：集合，存储唯一的元素，并按升序排序。</li>
<li><code>multi_set</code>：多重集合，可存储重复的元素，并按升序排序。</li>
<li><code>map</code>：映射，存储键值对，按键的升序排序。</li>
<li><code>multi_map</code>：多重映射，可存储重复的键值对，并按键的升序排序。</li>
</ol>
<p>容器适配器（Container Adapters）：</p>
<ol>
<li><code>stack</code>：栈，以 LIFO（后进先出）的方式存储元素，底层基于序列式容器实现，默认使用 <code>deque</code>。</li>
<li><code>queue</code>：队列，以 FIFO（先进先出）的方式存储元素，底层基于序列式容器实现，默认使用 <code>deque</code>。</li>
<li><code>priority_queue</code>：优先队列，按照优先级存储元素，底层基于序列式容器实现，默认使用 <code>vector</code>。</li>
</ol>
<h2 id="3-3-STL迭代器的类别"><a href="#3-3-STL迭代器的类别" class="headerlink" title="3.3 STL迭代器的类别"></a>3.3 STL迭代器的类别</h2><p>迭代器是一种用于遍历容器中元素的抽象概念，它提供了对容器中元素的访问和操作方式。C++中定义了多种类型的迭代器，每种迭代器具有不同的特性和功能。</p>
<ol>
<li>输入迭代器（Input Iterators）：从容器到程序，对数据进行只读访问。它允许逐个元素地读取容器中的数据，并且只能单向移动，不支持对容器进行修改。</li>
<li>输出迭代器（Output Iterators）：从程序到容器，对数据进行只写访问。它允许逐个元素地向容器中写入数据，并且只能单向移动，不支持读取容器中的数据。</li>
<li>前向迭代器（Forward Iterators）：向前推进迭代器，支持对容器进行读写操作。它具有输入迭代器和输出迭代器的所有功能，并且可以在容器中任意位置插入和删除元素，支持双向移动。</li>
<li>双向迭代器（Bidirectional Iterators）：向前、向后推进迭代器，支持对容器进行读写操作。它具有前向迭代器的所有功能，并且可以反向移动，即向前和向后移动。</li>
<li>随机访问迭代器（Random Access Iterators）：直接获取容器元素，支持对容器进行读写操作。它具有双向迭代器的所有功能，并且支持随机访问，可以通过偏移量直接访问容器中的任意元素。</li>
</ol>
<h2 id="3-4-STL算法的类别"><a href="#3-4-STL算法的类别" class="headerlink" title="3.4 STL算法的类别"></a>3.4 STL算法的类别</h2><p>非质变的算法（Non-modifying Algorithms）：</p>
<ol>
<li><code>std::all_of</code>：判断范围内的所有元素是否满足给定条件。</li>
<li><code>std::any_of</code>：判断范围内是否存在满足给定条件的元素。</li>
<li><code>std::none_of</code>：判断范围内是否所有元素都不满足给定条件。</li>
<li><code>std::for_each</code>：对范围内的每个元素执行指定的操作。</li>
<li><code>std::count</code>：计算范围内满足给定值的元素个数。</li>
<li><code>std::count_if</code>：计算范围内满足给定条件的元素个数。</li>
<li><code>std::find</code>：查找范围内第一个等于给定值的元素。</li>
<li><code>std::find_if</code>：查找范围内第一个满足给定条件的元素。</li>
<li><code>std::find_if_not</code>：查找范围内第一个不满足给定条件的元素。</li>
<li><code>std::find_end</code>：在范围内查找最后一次出现子序列的起始位置。</li>
<li><code>std::find_first_of</code>：在范围内查找第一次出现指定元素之一的位置。</li>
<li><code>std::adjacent_find</code>：在范围内查找第一对相邻重复元素的位置。</li>
<li><code>std::search</code>：在范围内查找第一次出现子序列的起始位置。</li>
<li><code>std::search_n</code>：在范围内查找第一次出现连续多个相等元素的起始位置。</li>
<li><code>std::equal</code>：判断两个范围内的元素是否相等。</li>
<li><code>std::mismatch</code>：找到两个范围内第一次不匹配的位置。</li>
<li><code>std::lexicographical_compare</code>：按字典顺序比较两个范围。</li>
<li><code>std::is_permutation</code>：判断两个范围内的元素是否是排列关系。</li>
<li><code>std::min_element</code>：找到范围内的最小元素的位置。</li>
<li><code>std::max_element</code>：找到范围内的最大元素的位置。</li>
<li><code>std::minmax_element</code>：同时找到范围内的最小和最大元素的位置。</li>
<li><code>std::clamp</code>：将给定值限制在指定范围内。</li>
<li><code>std::is_sorted</code>：判断范围内的元素是否按升序排序。</li>
<li><code>std::is_partitioned</code>：判断范围内的元素是否满足分区条件。</li>
<li><code>std::is_heap</code>：判断范围内的元素是否满足堆的条件。</li>
<li><code>std::is_sorted_until</code>：找到范围内的第一个无序位置。</li>
<li><code>std::is_partitioned_until</code>：找到范围内的第一个不满足分区条件的位置。</li>
<li><code>std::is_heap_until</code>：找到范围内的第一个不满足堆条件的位置。</li>
</ol>
<p>质变的算法（Modifying Algorithms）：</p>
<ol>
<li><code>std::copy</code>：复制范围内的元素到另一个容器。</li>
<li><code>std::copy_if</code>：复制满足给定条件的元素到另一个容器。</li>
<li><code>std::copy_n</code>：复制指定数量的元素到另一个容器。</li>
<li><code>std::copy_backward</code>：反向复制范围内的元素到另一个容器。</li>
<li><code>std::move</code>：将范围内的元素移动到另一个容器。</li>
<li><code>std::move_backward</code>：反向移动范围内的元素到另一个容器。</li>
<li><code>std::fill</code>：用给定值填充容器中的元素。</li>
<li><code>std::fill_n</code>：用给定值填充指定数量的元素。</li>
<li><code>std::generate</code>：使用生成器函数生成范围内的元素。</li>
<li><code>std::generate_n</code>：使用生成器函数生成指定数量的元素。</li>
<li><code>std::transform</code>：对范围内的元素应用指定的操作，并将结果存储到另一个容器。</li>
<li><code>std::replace</code>：将范围内的指定值替换为新值。</li>
<li><code>std::replace_if</code>：根据给定条件将范围内的元素替换为新值。</li>
<li><code>std::replace_copy</code>：将范围内的元素复制到另一个容器，并将指定值替换为新值。</li>
<li><code>std::replace_copy_if</code>：将范围内的元素复制到另一个容器，并根据给定条件替换为新值。</li>
<li><code>std::swap</code>：交换两个对象的值。</li>
<li><code>std::swap_ranges</code>：交换两个范围的元素。</li>
<li><code>std::iter_swap</code>：交换两个迭代器所指向的元素。</li>
<li><code>std::reverse</code>：反转范围内的元素顺序。</li>
<li><code>std::reverse_copy</code>：将范围内的元素反转后复制到另一个容器。</li>
<li><code>std::rotate</code>：将范围内的元素循环右移。</li>
<li><code>std::rotate_copy</code>：将范围内的元素循环右移后复制到另一个容器。</li>
<li><code>std::shuffle</code>：随机重排范围内的元素。</li>
<li><code>std::unique</code>：移除范围内的连续重复元素，只保留一个副本。</li>
<li><code>std::unique_copy</code>：将范围内的连续重复元素复制到另一个容器，只保留一个副本。</li>
<li><code>std::partition</code>：根据给定条件将范围内的元素分为满足条件和不满足条件的两部分。</li>
<li><code>std::stable_partition</code>：根据给定条件将范围内的元素稳定地分为满足条件和不满足条件的两部分。</li>
<li><code>std::sort</code>：对范围内的元素进行排序。</li>
<li><code>std::stable_sort</code>：对范围内的元素进行稳定排序。</li>
<li><code>std::partial_sort</code>：部分排序范围内的元素。</li>
<li><code>std::nth_element</code>：将范围内的第 n 小的元素移动到指定位置。</li>
<li><code>std::inplace_merge</code>：将两个已排序的范围合并为一个已排序的范围。</li>
<li><code>std::transform</code>：对范围内的元素应用指定的操作，并将结果存储到另一个容器。</li>
<li><code>std::generate</code>：使用生成器函数生成范围内的元素。</li>
<li><code>std::generate_n</code>：使用生成器函数生成指定数量的元素。</li>
<li><code>std::random_shuffle</code>：随机重排范围内的元素。</li>
<li><code>std::partition</code>：根据给定条件将范围内的元素分为满足条件和不满足条件的两部分。</li>
<li><code>std::sort</code>：对范围内的元素进行排序。</li>
<li><code>std::stable_sort</code>：对范围内的元素进行稳定排序。</li>
<li><code>std::partial_sort</code>：部分排序范围内的元素。</li>
<li><code>std::nth_element</code>：将范围内的第 n 小的元素移动到指定位置。</li>
<li><code>std::inplace_merge</code>：将两个已排序的范围合并为一个已排序的范围。</li>
<li><code>std::copy_backward</code>：反向复制范围内的元素到另一个容器。</li>
</ol>
<h2 id="3-5泛型编程和宏"><a href="#3-5泛型编程和宏" class="headerlink" title="3.5泛型编程和宏"></a>3.5泛型编程和宏</h2><h2 id="3-6函数模板"><a href="#3-6函数模板" class="headerlink" title="3.6函数模板"></a>3.6函数模板</h2><p>函数模板（Function Template）是C++中的一种特殊函数，用于定义通用的函数，可以适用于不同类型的参数。函数模板通过在函数定义中使用类型参数来实现通用性，这些类型参数可以在函数调用时被具体的类型替代。</p>
<p>以下是两个使用函数模板定义的求最大值函数的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(a, b) &lt;&lt; std::endl;  <span class="comment">// 调用模板函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-7类模板"><a href="#3-7类模板" class="headerlink" title="3.7类模板"></a>3.7类模板</h2><p>类模板（Class Template）是C++中的一种特殊类，用于定义通用的类，可以适用于不同类型的成员变量和成员函数。类模板通过在类定义中使用类型参数来实现通用性，这些类型参数可以在类实例化时被具体的类型替代。</p>
<p>类模板的使用方式类似于函数模板，通过在类定义前面使用 <code>template&lt;typename T&gt;</code> 或 <code>template&lt;class T&gt;</code> 声明一个模板类，其中 <code>T</code> 是一个模板参数，可以在类内部的成员变量和成员函数中使用。</p>
<p>以下是一个使用类模板定义的通用的容器类的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Container</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/3588-npu/" rel="tag">3588 npu</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-10-4 c-进阶-函数和指针"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/03/10-4%20c-%E8%BF%9B%E9%98%B6-%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88/"
    >c++ 进阶 函数和指针</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/03/10-4%20c-%E8%BF%9B%E9%98%B6-%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88/" class="article-date">
  <time datetime="2023-09-03T03:48:33.000Z" itemprop="datePublished">2023-09-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/3588-npu/">3588 npu</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-掌握C-函数基本概念用法"><a href="#1-掌握C-函数基本概念用法" class="headerlink" title="1.掌握C++函数基本概念用法"></a>1.掌握C++函数基本概念用法</h1><h2 id="1-1-函数定义"><a href="#1-1-函数定义" class="headerlink" title="1.1 函数定义"></a>1.1 函数定义</h2><p>什么是函数(function)</p>
<ul>
<li><p>C++程序</p>
</li>
<li><p>C++标准库(functions和clas;ses)</p>
</li>
<li><p>第三方库(functions和class</p>
</li>
<li><p>自定义的functions和classes</p>
</li>
</ul>
<p>函数让我们的程序更加模块化</p>
<ul>
<li>让代码解耦，分成按业务，</li>
<li>按逻辑的单元提高代码复用性</li>
</ul>
<p>函数名称参数列表</p>
<ul>
<li><p>传给函数的变量</p>
</li>
<li><p>变量类型需声明</p>
</li>
</ul>
<p>返回值类型</p>
<ul>
<li><p>函数体</p>
</li>
<li><p>函数被调用执行的部分，花括号{}内部</p>
<p>示例1：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI &#123;<span class="number">3.1415926</span>&#125;; <span class="comment">// 圆周率</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculate_area</span><span class="params">(<span class="type">double</span> radius)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PI * <span class="built_in">pow</span>(radius, <span class="number">2</span>); <span class="comment">// pow()函数用于计算幂</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">circle_area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入圆的半径：&quot;</span>;</span><br><span class="line">    <span class="type">double</span> radius &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    cin &gt;&gt; radius;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的面积为：&quot;</span> &lt;&lt; <span class="built_in">calculate_area</span>(radius) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">circle_area</span>(); <span class="comment">// 调用计算圆的面积的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="1-2-函数原型-prototype"><a href="#1-2-函数原型-prototype" class="headerlink" title="1.2 函数原型(prototype)"></a>1.2 函数原型(prototype)</h2><p>&#x3D;&#x3D;编译器要求:使用函数前必须“见过”这个函数&#x3D;&#x3D;</p>
<p>先定义函数再调用</p>
<ul>
<li>适用于小型程序，不适用于大型项目</li>
</ul>
<p>使用函数原型</p>
<ul>
<li><p>告诉编译器函数定义必要的信息</p>
</li>
<li><p>也称为前向声明(forward declaration)</p>
</li>
<li><p>放在程序开始的部分</p>
</li>
<li><p>或者放在头文件(header files.h)中</p>
</li>
</ul>
<h2 id="1-3参数"><a href="#1-3参数" class="headerlink" title="1.3参数"></a>1.3参数</h2><ol>
<li>当我们传递数据给函数时，其实用的是值传递(pass by value)</li>
<li>数据的拷贝会传给函数</li>
<li>函数内部的代码不会改变我们传给它的变量</li>
</ol>
<p>形参(formal parameters)与实参(actual parameters)<br>形参(formal parameters)</p>
<ul>
<li>函数定义语句中的参数</li>
</ul>
<p>实参(actual parameters</p>
<ul>
<li>调用函数时传递的参数(arguments)</li>
</ul>
<h2 id="1-4-重载"><a href="#1-4-重载" class="headerlink" title="1.4 重载"></a>1.4 重载</h2><p>一组函数具有相同函数名，不同参数列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型，函数重载</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_numbers</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>; <span class="comment">// 两个 int 类型数字相加</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add_numbers</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>; <span class="comment">// 两个 double 类型数字相加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_numbers</span>(<span class="number">5</span>, <span class="number">10</span>) &lt;&lt; endl; <span class="comment">// int 类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_numbers</span>(<span class="number">1.23</span>, <span class="number">2.45</span>) &lt;&lt; endl; <span class="comment">// double 类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_numbers</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add_numbers</span><span class="params">(<span class="type">double</span> num1, <span class="type">double</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-5-函数传参-数组、引用"><a href="#1-5-函数传参-数组、引用" class="headerlink" title="1.5 函数传参(数组、引用)"></a>1.5 函数传参(数组、引用)</h2><ul>
<li><p>数组元素并没有复制</p>
</li>
<li><p>数组变量名称表示第一个元素在内存中的地址这个地址才被复制了</p>
</li>
<li><p>函数内部无法知道数组大小(数组大小需要额外传参)</p>
<p>·声明参数numbers是常量(只读read-only)</p>
</li>
</ul>
<p>		</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_array</span> <span class="params">(<span class="type">const</span> <span class="type">int</span> numbers[ ], <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_num</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换两个数字</span></span><br><span class="line">    <span class="type">int</span> x &#123;<span class="number">100</span>&#125;, y &#123;<span class="number">200</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y is: &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 100 200</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap_num</span>(x, y);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y is: &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 200 100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的是取地址，上面的函数和下面这个函数的作用相同：</p>
<p>传递地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_num</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换两个数字</span></span><br><span class="line">    <span class="type">int</span> x &#123;<span class="number">100</span>&#125;, y &#123;<span class="number">200</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y is: &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 100 200</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap_num</span>(&amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y is: &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 200 100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&#x3D;&#x3D;注意&#x3D;&#x3D;</p>
<p><code>int&amp;</code> 是 C++ 中的引用类型，它是一种特殊的类型，用于给一个已存在的变量起一个别名。可以将其理解为变量的一个别名或者另一个名称，与原变量共享同一块内存空间。</p>
<p>引用类型与指针类型有所不同。引用在声明时必须初始化，并且一旦初始化后，它就一直引用同一个对象，不能再引用其他对象。而指针可以在声明后重新指向不同的对象。</p>
<p>使用引用类型的主要目的是提供一种更简洁、更直观的方式来操作变量，同时避免了指针操作的一些繁琐性和潜在的错误。</p>
<p>在上述修正后的代码中，<code>int&amp;</code> 用于函数参数的声明，表示传递的参数是一个整数的引用。通过引用参数，可以直接修改原变量的值，而无需通过指针进行解引用。在函数内部，通过引用操作修改了 <code>a</code> 和 <code>b</code> 所指向的变量的值。</p>
<p>其实也就相当于传地址</p>
<h1 id="2-掌握C-指针基本概念、用法"><a href="#2-掌握C-指针基本概念、用法" class="headerlink" title="2.掌握C++指针基本概念、用法"></a>2.掌握C++指针基本概念、用法</h1><h2 id="2-1-什么是指针"><a href="#2-1-什么是指针" class="headerlink" title="2.1 什么是指针"></a>2.1 什么是指针</h2><p>指针是变量<br>变量的值是一个地址<br>指针的值可以存储哪些地址?</p>
<p>另一个变量</p>
<p>函数</p>
<hr>
<p>如果指针指向变量或函数，那么为什么不直接用他们?</p>
<p>可以，但不常用:</p>
<ul>
<li><p>函数内部，指针可以访问函数作用域外的数据</p>
</li>
<li><p>高效操作数组</p>
</li>
<li><p>在堆(heap)上动态分配内存空间</p>
<p>​      这些空间没有变量名称只能通过指针访问</p>
</li>
<li><p>可以获取内存中特殊地址</p>
</li>
</ul>
<p>​              如嵌入式系统、设备驱动等</p>
<hr>
<ul>
<li>&amp;地址操作符</li>
<li>指针也是一个变量(variable)，所以它的值可以改变</li>
<li>指针可以为null</li>
<li>指针可以不初始化</li>
</ul>
<h2 id="2-2-动态内存分配-dynami-allocation"><a href="#2-2-动态内存分配-dynami-allocation" class="headerlink" title="2.2 动态内存分配(dynami allocation)"></a>2.2 动态内存分配(dynami allocation)</h2><p>在堆(heap)上程序员自己分配内存空间;<br>数组(array)</p>
<ul>
<li>使用数组需要知道数组大小，并且数组大小是固定的;</li>
<li>Vector容器大小可以动态调整</li>
</ul>
<p>使用指针获取堆上刚分配的内存空间</p>
<hr>
<p>使用new[]为数组分配内存空间</p>
<p>使用delete[]释放内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* array_ptr &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr_size &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;你需要多少个整数: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; arr_size;</span><br><span class="line"></span><br><span class="line">    array_ptr = <span class="keyword">new</span> <span class="type">int</span>[arr_size]; <span class="comment">// 在堆上分配内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] array_ptr; <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-指针和数组的关系"><a href="#2-3-指针和数组的关系" class="headerlink" title="2.3 指针和数组的关系"></a>2.3 指针和数组的关系</h2><ul>
<li>数组变量名称的值是数组第一个元素的地址;</li>
<li>指针变量的的值是一个地址;</li>
<li>如果指针指向的类型和数组元素的类型一致，那么指针和数组名称几乎是等价的</li>
</ul>
<h2 id="2-4-const和指针一一指针本身和被指向的对象都是常量"><a href="#2-4-const和指针一一指针本身和被指向的对象都是常量" class="headerlink" title="2.4 const和指针一一指针本身和被指向的对象都是常量"></a>2.4 const和指针一一指针本身和被指向的对象都是常量</h2><p>指针可以操作:地址及被指向的对象</p>
<ul>
<li>被指向的对象是常量(povinters to constants)</li>
<li>指针本身是常量(constant pointers)</li>
<li>指针本身和被指向的对象都是常量(constant pointers to constants)</li>
</ul>
<p>示例1</p>
<ul>
<li>被指向的对象是常量，不可以通过指针改动·</li>
<li>指针本身可以改变</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> high_temp &#123;<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="type">int</span> low_temp &#123;<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* temp_ptr &#123;&amp;high_temp&#125;; <span class="comment">// 被指向的数据是常量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// *temp_ptr = 100; // 错误，不能通过解引用修改常量的值</span></span><br><span class="line"></span><br><span class="line">    temp_ptr = &amp;low_temp; <span class="comment">// 正确，可以通过指针修改指向的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例2</p>
<ul>
<li>被指向的对象可以通过指针改动</li>
<li>指针本身不可以改变</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> high_temp &#123;<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="type">int</span> low_temp &#123;<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> temp_ptr &#123;&amp;high_temp&#125;; <span class="comment">// 指针本身是常量，指向 high_temp</span></span><br><span class="line"></span><br><span class="line">    *temp_ptr = <span class="number">100</span>; <span class="comment">// 正确，通过指针解引用修改值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// temp_ptr = &amp;low_temp; // 错误，不能修改指针的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>示例3 </p>
<ul>
<li>被指向的对象不可以改动</li>
<li>指针本身不可以改变</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> high_temp &#123;<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="type">int</span> low_temp &#123;<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> temp_ptr &#123;&amp;high_temp&#125;; <span class="comment">// 指针和被指向对象都是常量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// *temp_ptr = 100; // 错误，不能修改指针指向的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// temp_ptr = &amp;low_temp; // 错误，不能修改指针的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-函数返回指针"><a href="#2-5-函数返回指针" class="headerlink" title="2.5 函数返回指针"></a>2.5 函数返回指针</h2><p>函数可以返回指针:</p>
<p> *function( );</p>
<p>返回哪些指针:</p>
<ul>
<li>函数内部动态分配的内存空间传入的数据</li>
<li>不能返回函数内的局部变量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">create_array</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> initial_value = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* new_storage &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    new_storage = <span class="keyword">new</span> <span class="type">int</span>[size]; <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i&#123;<span class="number">0</span>&#125;; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 初始化值</span></span><br><span class="line">        *(new_storage + i) = initial_value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_storage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> size &#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* array_ptr = <span class="built_in">create_array</span>(size, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数组元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i&#123;<span class="number">0</span>&#125;; i &lt; size; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; *(array_ptr + i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] array_ptr; <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/3588-npu/" rel="tag">3588 npu</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/19/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="page-number" href="/page/19/">19</a><span class="page-number current">20</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/21/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="热爱学习的未来酱"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>