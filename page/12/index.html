<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="永远年轻，永远热泪盈眶" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 热爱学习的未来酱</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="热爱学习的未来酱" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover3.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">热爱学习的未来酱</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '向上的路，并不拥挤。拥挤是因为，大部分人选择了安逸', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-rk3568-驱动开发第六篇-平台总线"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E5%85%AD%E7%AF%87-%E5%B9%B3%E5%8F%B0%E6%80%BB%E7%BA%BF/"
    >rk3568 驱动开发第六篇 平台总线</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E5%85%AD%E7%AF%87-%E5%B9%B3%E5%8F%B0%E6%80%BB%E7%BA%BF/" class="article-date">
  <time datetime="2023-09-04T12:56:12.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第50章-平台总线模型介绍"><a href="#第50章-平台总线模型介绍" class="headerlink" title="第50章 平台总线模型介绍"></a>第50章 平台总线模型介绍</h1><p>在前面所有章节中，无论要完成何种需求，我们都编写了一个独立的驱动程序，但这样编写出来的驱动程序在重用性和可移植性上是很低的，无论之后要编写一个同类型的驱动还是将该驱动更换一个平台，都要花费时间重新修改驱动代码，而驱动的分离和分层这一软件思路的提出（即本章节要讲解的平台总线模型），就是为了解决这个问题，下面让我们一起进入平台总线模型的学习吧。</p>
<h2 id="50-1-什么是平台总线？"><a href="#50-1-什么是平台总线？" class="headerlink" title="50.1 什么是平台总线？"></a>50.1 什么是平台总线？</h2><p>平台总线（Platform bus）是Linux内核中提供的一种虚拟总线，用于管理和组织与特定硬件平台相关的设备和驱动。它充当了平台设备（platform device）和平台驱动（platform driver）之间的桥梁，负责将它们进行匹配和绑定。</p>
<p>当系统注册一个平台设备时，平台总线会寻找与之匹配的平台驱动。它会遍历已注册的平台驱动列表，尝试与每个平台驱动进行匹配，直到找到与平台设备匹配的驱动为止。一旦找到匹配的驱动，平台总线会将平台设备与平台驱动进行绑定，使得设备可以被正确地初始化和操作。</p>
<p>同样地，当系统注册一个平台驱动时，平台总线会寻找与之匹配的平台设备。它会遍历已注册的平台设备列表，尝试与每个平台设备进行匹配，直到找到与平台驱动匹配的设备为止。一旦找到匹配的设备，平台总线会将平台设备与平台驱动进行绑定，使得驱动可以管理和控制与该设备相关的操作。</p>
<p>设备、平台总线、驱动的关系如下图（图 50-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps1.jpg" alt="img"> </p>
<p>图 50-1</p>
<p>通过引入平台总线，Linux内核提供了一种通用的机制来管理和组织与特定硬件平台相关的设备和驱动。它使得设备和驱动之间的匹配过程更加自动化和灵活，同时也提高了嵌入式系统的可移植性和可扩展性。</p>
<h2 id="50-2-平台总线的优势"><a href="#50-2-平台总线的优势" class="headerlink" title="50.2 平台总线的优势"></a>50.2 平台总线的优势</h2><p>在前面的章节中，我们编写的驱动程序将驱动和设备相关的内容放在一起，但是当涉及到多个相同类型的设备时，这种方法会引发一系列问题。举个例子，假设我们有一个硬件平台，该硬件平台上存在了500个模块，这些模块都使用了LED灯。如果我们使用杂项设备来编写驱动，虽然相比字符设备，杂项设备的代码量较少，但我们仍旧需要编写500份类似的代码，从而生成相应的设备节点，以供上层应用在不同模块上控制LED灯。</p>
<p>编写500份重复的代码会带来两个问题。首先，会造成大量重复劳动。其次，代码的重用性较差。如果我们需要将这些驱动从一个平台移植到另一个平台，就需要逐个修改驱动代码，尽管只需修改与硬件相关的部分，但仍旧是一个很大的工作量</p>
<p>而在引入了平台总线模型后，这些问题就得到了很好地解决。通过使用平台总线模型，将设备驱动和平台设备进行了分离。这样一来，我们只需编写一份通用的驱动代码即可，然后针对不同的平台设备进行配置，这就大大减少了重复编写代码的工作量，并提高了驱动代码的重用性。当我们需要将驱动移植到不同的平台时，只需对硬件相关的部分进行适配即可，其他部分可以保持不变。</p>
<p>整理出来的平台总线优势如下所示：</p>
<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em>****设备与驱动的分离：****传统的设备驱动模型将设备和驱动代码合并在同一个文件中，导致代码冗余和可维护性差。而平台总线模型将设备代码和驱动代码分离，设备代码放在device.c文件中，驱动代码放在driver.c文件中。这种分离使得设备和驱动的职责更加清晰，提高了代码的可读性和可维护性。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em>****提高代码的重用性：****平台总线模型使得相同类型的设备可以共享相同的驱动代码。例如，在一个硬件平台上存在多个相同类型的设备，传统的驱动模型需要为每个设备编写独立的驱动代码。而使用平台总线模型，只需编写一个通用的驱动代码，然后为每个设备创建相应的device.c文件，将设备特定的代码放在其中。这样可以减少代码的重复性，提高了代码的重用性和可维护性。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em>****减少重复性代码：****在传统的设备驱动模型中，如果有多个相同类型的设备存在，就需要为每个设备编写独立的驱动代码。而使用平台总线模型，只需编写一个通用的驱动代码，然后为每个设备创建相应的device.c文件，将设备特定的代码放在其中。这样可以避免大量的重复性代码，简化了驱动开发过程。</p>
<p><em><strong>*（*</strong></em><em><strong>*4*</strong></em><em><strong>*）*</strong></em>****提高可移植性：****平台总线模型可以提高驱动的可移植性。开发者可以编写适应平台总线的平台驱动程序，从而支持特定的外设，而无需依赖于特定的标准总线。这使得驱动可以更容易地在不同的硬件平台之间进行移植和重用。</p>
<h1 id="第51章-注册platform设备实验"><a href="#第51章-注册platform设备实验" class="headerlink" title="第51章 注册platform设备实验"></a>第51章 注册platform设备实验</h1><h2 id="51-1-注册platform设备"><a href="#51-1-注册platform设备" class="headerlink" title="51.1 注册platform设备"></a>51.1 注册platform设备</h2><h3 id="51-1-1-platform-device-register-函数"><a href="#51-1-1-platform-device-register-函数" class="headerlink" title="51.1.1 platform_device_register 函数"></a>51.1.1 platform_device_register 函数</h3><p>platform_device_register函数用于将platform_device结构体描述的平台设备注册到内核中。下面是对platform_device_register函数的详细介绍：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int platform_device_register(struct platform_device *pdev);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;platform_device.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em><br>    platform_device_register函数用于将platform_device结构体描述的平台设备注册到内核中，使其能够参与设备的资源分配和驱动的匹配。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>pdev：指向platform_device结构体的指针，描述要注册的平台设备的信息。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>成功：返回0，表示设备注册成功。</p>
<p>失败：返回负数，表示设备注册失败，返回的负数值表示错误代码。</p>
<p>pdev参数是一个指向platform_device结构体的指针，其中包含了描述平台设备的各种属性和信息。platform_device结构体包含了设备名称、设备资源、设备ID等信息，用于描述和标识平台设备，会在接下来的小节对该结构体进行详细的介绍。</p>
<p>该函数在内核源码目录下的“&#x2F;include&#x2F;linux&#x2F;platform_device.h”文件中，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern int platform_device_register(struct platform_device *);</span><br></pre></td></tr></table></figure>

<p>函数声明中的extern关键字表示该函数在其他地方定义，而不是在当前文件中实现。这样的声明通常出现在头文件中，用于告诉编译器该函数的定义存在于其他源文件中，以便在编译时能够正确引用该函数。</p>
<p>而platform_device_register实际定义在“&#x2F;drivers&#x2F;base&#x2F;platform.c”文件中，相关定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int platform_device_register(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">	device_initialize(&amp;pdev-&gt;dev);</span><br><span class="line">	arch_setup_pdev_archdata(pdev);</span><br><span class="line">	return platform_device_add(pdev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数内部有三个主要的操作。</p>
<p>第3行：调用了device_initialize函数，用于对pdev-&gt;dev进行初始化。pdev-&gt;dev是struct platform_device结构体中的一个成员，它表示平台设备对应的struct device结构体。通过调用device_initialize函数，对pdev-&gt;dev进行一些基本的初始化工作，例如设置设备的引用计数、设备的类型等。</p>
<p>第4行：调用了arch_setup_pdev_archdata函数，用于根据平台设备的架构数据来设置pdev的架构相关数据。这个函数的具体实现可能与具体的架构相关，它主要用于在不同的架构下对平台设备进行特定的设置。</p>
<p>第5行：调用了platform_device_add函数，将平台设备pdev添加到内核中。platform_device_add函数会完成平台设备的添加操作，包括将设备添加到设备层级结构中、添加设备的资源等。它会返回一个int类型的结果，表示设备添加的结果。</p>
<p>platform_device_register函数的主要作用是将platform_device结构体描述的平台设备注册到内核中，包括设备的初始化、添加到platform总线和设备层级结构、添加设备资源等操作。通过该函数，平台设备被注册后，就能够参与设备的资源分配和驱动的匹配过程。函数的返回值可以用于判断设备注册是否成功。</p>
<h3 id="51-1-2-platform-device-unregister-函数"><a href="#51-1-2-platform-device-unregister-函数" class="headerlink" title="51.1.2 platform_device_unregister 函数"></a>51.1.2 platform_device_unregister 函数</h3><p>platform_device_unregister函数用于取消注册已经注册的平台设备，即从内核中移除设备。在设备不再需要时，调用该函数可以进行设备的清理和释放操作。</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>void platform_device_unregister(struct platform_device *pdev);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;platform_device.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em><br>    platform_device_unregister函数用于取消注册已经注册的平台设备，从内核中移除设备。</p>
<p>参数含义：</p>
<p>pdev：指向要取消注册的平台设备的platform_device结构体指针。</p>
<p>返回值：<br>无返回值。</p>
<p>该函数在内核源码目录下的“&#x2F;include&#x2F;linux&#x2F;platform_device.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">platform_device_unregister</span><span class="params">(<span class="keyword">struct</span> platform_device *)</span>;</span><br></pre></td></tr></table></figure>

<p>函数声明中的extern关键字表示该函数在其他地方定义，而不是在当前文件中实现。这样的声明通常出现在头文件中，用于告诉编译器该函数的定义存在于其他源文件中，以便在编译时能够正确引用该函数。</p>
<p>而platform_device_unregister实际定义在“&#x2F;drivers&#x2F;base&#x2F;platform.c”文件中，相关定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">platform_device_unregister</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	platform_device_del(pdev);</span><br><span class="line">	platform_device_put(pdev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数内部有两个主要的操作：</p>
<p>第3行：调用了platform_device_del函数，用于将设备从platform总线的设备列表中移除。它会将设备从设备层级结构中移除，停止设备的资源分配和驱动的匹配。</p>
<p>第4行：这一步调用了platform_device_put函数，用于减少对设备的引用计数。这个函数会检查设备的引用计数，如果引用计数减为零，则会释放设备结构体和相关资源。通过减少引用计数，可以确保设备在不再被使用时能够被释放。</p>
<p>platform_device_unregister函数的作用是取消注册已经注册的平台设备，从内核中移除设备。它先调用platform_device_del函数将设备从设备层级结构中移除，然后调用platform_device_put函数减少设备的引用计数，确保设备在不再被使用时能够被释放。</p>
<h3 id="51-1-3-platform-device结构体"><a href="#51-1-3-platform-device结构体" class="headerlink" title="51.1.3 platform_device结构体"></a>51.1.3 platform_device结构体</h3><p>platform_device结构体是用于描述平台设备的数据结构。它包含了平台设备的各种属性和信息，用于在内核中表示和管理平台设备。该结构体定义在内核的“&#x2F;include&#x2F;linux&#x2F;platform_device.h”文件中，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct platform_device &#123;</span><br><span class="line">	const char *name;  // 设备的名称，用于唯一标识设备</span><br><span class="line">	int	id;        // 设备的ID，可以用于区分同一种设备的不同实例</span><br><span class="line">	bool	 id_auto;  // 表示设备的ID是否自动生成</span><br><span class="line">	struct device dev;  // 表示平台设备对应的 struct device 结构体，用于设备的基本管理和操作</span><br><span class="line">	u32	num_resources;   // 设备资源的数量</span><br><span class="line">	struct resource	*resource;   // 指向设备资源的指针</span><br><span class="line"></span><br><span class="line">	const struct platform_device_id *id_entry; // 指向设备的ID表项的指针，用于匹配设备和驱动</span><br><span class="line">	char *driver_override; // 强制设备与指定驱动匹配的驱动名称</span><br><span class="line"></span><br><span class="line">	/* MFD cell pointer */</span><br><span class="line">	struct mfd_cell *mfd_cell;   // 指向多功能设备（MFD）单元的指针，用于多功能设备的描述</span><br><span class="line"></span><br><span class="line">	/* arch specific additions */</span><br><span class="line">	struct pdev_archdata	archdata;    // 用于存储特定于架构的设备数据</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面对于几个重要的参数和结构体进行讲解</p>
<p>const char *name：设备的名称，用于唯一标识设备。必须提供一个唯一的名称，以便内核能够正确识别和管理该设备。</p>
<p>int id：设备的ID，可以用于区分同一种设备的不同实例。这个参数是可选的，如果不需要使用ID进行区分，可以将其设置为-1，</p>
<p>struct device dev：表示平台设备对应的struct device结构体，用于设备的基本管理和操作。必须为该参数提供一个有效的struct device对象，该结构体的release方法必须要实现，否则在编译的时候会报错。</p>
<p>u32 num_resources：设备资源的数量。如果设备具有资源（如内存区域、中断等），则需要提供资源的数量。</p>
<p>struct resource *resource：指向设备资源的指针。如果设备具有资源，需要提供一个指向资源数组的指针，会在下个小节对该结构体进行详细的讲解。</p>
<h3 id="51-1-4-resource结构体"><a href="#51-1-4-resource结构体" class="headerlink" title="51.1.4 resource结构体"></a>51.1.4 resource结构体</h3><p>struct resource结构体用于描述系统中的设备资源，包括内存区域、I&#x2F;O 端口、中断等，该结构体定义在内核的“&#x2F;include&#x2F;linux&#x2F;ioport.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line">    <span class="type">resource_size_t</span> start;          <span class="comment">/* 资源的起始地址 */</span></span><br><span class="line">    <span class="type">resource_size_t</span> end;            <span class="comment">/* 资源的结束地址 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;               <span class="comment">/* 资源的名称 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;            <span class="comment">/* 资源的标志位 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> desc;             <span class="comment">/* 资源的描述信息 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>;</span>        <span class="comment">/* 指向父资源的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">sibling</span>;</span>       <span class="comment">/* 指向同级兄弟资源的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">child</span>;</span>         <span class="comment">/* 指向子资源的指针 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以下宏定义用于保留未使用的字段 */</span></span><br><span class="line">    ANDROID_KABI_RESERVE(<span class="number">1</span>);</span><br><span class="line">    ANDROID_KABI_RESERVE(<span class="number">2</span>);</span><br><span class="line">    ANDROID_KABI_RESERVE(<span class="number">3</span>);</span><br><span class="line">    ANDROID_KABI_RESERVE(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中最重要的是前四个参数，每个参数的具体介绍如下所示：</p>
<p>（1）resource_size_t start：资源的起始地址。它表示资源的起始位置或者起始寄存器的地址。</p>
<p>（2）resource_size_t end：资源的结束地址。它表示资源的结束位置或者结束寄存器的地址。</p>
<p>（3）const char *name：资源的名称。它是一个字符串，用于标识和描述资源。</p>
<p>（4）unsigned long flags：资源的标志位。它包含了一些特定的标志，用于表示资源的属性或者特征。例如，可以用标志位来指示资源的可用性、共享性、缓存属性等。flags参数的具体取值和含义可以根据系统和驱动的需求进行定义和解释，但通常情况下，它用于表示资源的属性、特征或配置选项。下面是一些常见的标志位及其可能的含义：</p>
<p><em><strong>*1. 资源类型相关标志位：*</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IORESOURCE_IO：表示资源是I/O端口资源。</span><br><span class="line">IORESOURCE_MEM：表示资源是内存资源。</span><br><span class="line">IORESOURCE_REG：表示资源是寄存器偏移量。</span><br><span class="line">IORESOURCE_IRQ：表示资源是中断资源。</span><br><span class="line">IORESOURCE_DMA：表示资源是DMA（直接内存访问）资源。</span><br></pre></td></tr></table></figure>

<p><em><strong>*2. 资源属性和特征相关标志位：*</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IORESOURCE_PREFETCH：表示资源是无副作用的预取资源。</span><br><span class="line">IORESOURCE_READONLY：表示资源是只读的。</span><br><span class="line">IORESOURCE_CACHEABLE：表示资源支持缓存。</span><br><span class="line">IORESOURCE_RANGELENGTH：表示资源的范围长度。</span><br><span class="line">IORESOURCE_SHADOWABLE：表示资源可以被影子资源替代。</span><br><span class="line">IORESOURCE_SIZEALIGN：表示资源的大小表示对齐。</span><br><span class="line">IORESOURCE_STARTALIGN：表示起始字段是对齐的。</span><br><span class="line">IORESOURCE_MEM_64：表示资源是64位内存资源。</span><br><span class="line">IORESOURCE_WINDOW：表示资源由桥接器转发。</span><br><span class="line">IORESOURCE_MUXED：表示资源是软件复用的。</span><br><span class="line">IORESOURCE_SYSRAM：表示资源是系统RAM（修饰符）。</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> <em><strong>*其他状态和控制标志位：*</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IORESOURCE_EXCLUSIVE：表示用户空间无法映射此资源。</span><br><span class="line">IORESOURCE_DISABLED：表示资源当前被禁用。</span><br><span class="line">IORESOURCE_UNSET：表示尚未分配地址给资源。</span><br><span class="line">IORESOURCE_AUTO：表示地址由系统自动分配。</span><br><span class="line">IORESOURCE_BUSY：表示驱动程序将此资源标记为繁忙。</span><br></pre></td></tr></table></figure>

<h2 id="51-2-实验程序的编写"><a href="#51-2-实验程序的编写" class="headerlink" title="51.2 实验程序的编写"></a>51.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\40_platform_device\。</p>
<p>本实验将注册一个名为 “my_platform_device” 的平台设备，当注册平台设备时，该驱动程序提供了两个资源：一个内存资源和一个中断资源。这些资源被定义在名为 my_resources 的结构体数组中,具体内容如下：</p>
<p><em><strong>*内存资源：*</strong></em></p>
<p>起始地址：MEM_START_ADDR（0xFDD60000）</p>
<p>结束地址：MEM_END_ADDR（0xFDD60004）</p>
<p>标记：IORESOURCE_MEM</p>
<p><em><strong>*中断资源：*</strong></em></p>
<p>中断资源号：IRQ_NUMBER（101）</p>
<p>标记：IORESOURCE_IRQ</p>
<p>编写完成的platform_device.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_START_ADDR 0xFDD60000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_END_ADDR   0xFDD60004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_NUMBER     101</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">my_resources</span>[] =</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .start = MEM_START_ADDR,    <span class="comment">// 内存资源起始地址</span></span><br><span class="line">        .end = MEM_END_ADDR,        <span class="comment">// 内存资源结束地址</span></span><br><span class="line">        .flags = IORESOURCE_MEM,    <span class="comment">// 标记为内存资源</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .start = IRQ_NUMBER,        <span class="comment">// 中断资源号</span></span><br><span class="line">        .end = IRQ_NUMBER,          <span class="comment">// 中断资源号</span></span><br><span class="line">        .flags = IORESOURCE_IRQ,    <span class="comment">// 标记为中断资源</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_platform_device_release</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 释放资源的回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">my_platform_device</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_platform_device&quot;</span>,                  <span class="comment">// 设备名称</span></span><br><span class="line">    .id = <span class="number">-1</span>,                                      <span class="comment">// 设备ID</span></span><br><span class="line">    .num_resources = ARRAY_SIZE(my_resources),     <span class="comment">// 资源数量</span></span><br><span class="line">    .resource = my_resources,                      <span class="comment">// 资源数组</span></span><br><span class="line">    .dev.release = my_platform_device_release,     <span class="comment">// 释放资源的回调函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_device_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = platform_device_register(&amp;my_platform_device);   <span class="comment">// 注册平台设备</span></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Platform device registered\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_device_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_device_unregister(&amp;my_platform_device);   <span class="comment">// 注销平台设备</span></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Platform device unregistered\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_device_init);</span><br><span class="line">module_exit(my_platform_device_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="51-3-运行测试"><a href="#51-3-运行测试" class="headerlink" title="51.3 运行测试"></a>51.3 运行测试</h2><h3 id="51-3-1-编译驱动程序"><a href="#51-3-1-编译驱动程序" class="headerlink" title="51.3.1 编译驱动程序"></a>51.3.1 编译驱动程序</h3><p>在上一小节中的platform_device.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_device.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_device.c和Makefile文件目录下，如下图（图51-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps2.jpg" alt="img"> </p>
<p>图 51-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图51-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps3.jpg" alt="img"> </p>
<p>图 51-2</p>
<p>编译完生成platform_device.ko目标文件，如下图（图51-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps4.jpg" alt="img"> </p>
<p>图 51-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="51-3-2-运行测试"><a href="#51-3-2-运行测试" class="headerlink" title="51.3.2 运行测试"></a>51.3.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图51-4）所示：</p>
<p>insmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps5.jpg" alt="img"> </p>
<p>图 51-4</p>
<p>然后来到&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;devices目录下，可以看到我们创建的my_platform_device设备文件夹就成功生成了。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps6.jpg" alt="img"> </p>
<p>图 51-5</p>
<p>然后使用以下命令进行驱动模块的卸载，如下图（图51-6）所示：</p>
<p>rmmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps7.jpg" alt="img"> </p>
<p>图 51-6</p>
<p>至此，注册platform设备实验就完成了。</p>
<h1 id="第52章-注册platform驱动实验"><a href="#第52章-注册platform驱动实验" class="headerlink" title="第52章 注册platform驱动实验"></a>第52章 注册platform驱动实验</h1><p>在上个章节我们学习了如何注册platform设备，而本章节就要学习如何注册platform驱动了。</p>
<h2 id="52-1注册platform驱动"><a href="#52-1注册platform驱动" class="headerlink" title="52.1注册platform驱动"></a>52.1注册platform驱动</h2><h3 id="52-1-1-platform-driver-register-函数"><a href="#52-1-1-platform-driver-register-函数" class="headerlink" title="52.1.1 platform_driver_register 函数"></a>52.1.1 platform_driver_register 函数</h3><p>platform_driver_register 函数用于在 Linux 内核中注册一个平台驱动程序。下面是对该函数的详细介绍：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int platform_driver_register(struct platform_driver *driver);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;platform_device.h&gt;</p>
<p><em><strong>*函数作用*</strong></em><em><strong>*：*</strong></em></p>
<p>platform_driver_register 函数用于将一个平台驱动程序注册到内核中。通过注册平台驱动程序，内核可以识别并与特定的平台设备进行匹配，并在需要时调用相应的回调函数。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>driver：指向 struct platform_driver 结构体的指针，描述了要注册的平台驱动程序的属性和回调函数（会在下面的小节对该结构体进行详细的讲解）。</p>
<p>****返回值****：</p>
<p>返回一个整数值，表示函数的执行状态。如果注册成功，返回 0；如果注册失败，返回一个负数错误码。</p>
<p>该函数在内核源码目录下的“&#x2F;include&#x2F;linux&#x2F;platform_device.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> platform_driver_register(drv) \</span></span><br><span class="line"><span class="meta">	__platform_driver_register(drv, THIS_MODULE)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __platform_driver_register(<span class="keyword">struct</span> platform_driver *,					<span class="keyword">struct</span> module *);</span><br></pre></td></tr></table></figure>

<p>这个宏用于简化平台驱动程序的注册过程。它将实际的注册函数 __platform_driver_register 与当前模块（驱动程序）关联起来。宏的参数 drv 是一个指向 struct platform_driver 结构体的指针，描述了要注册的平台驱动程序的属性和回调函数。THIS_MODULE 是一个宏，用于获取当前模块的指针。</p>
<p>而__platform_driver_register实际定义在“&#x2F;drivers&#x2F;base&#x2F;platform.c”文件中，相关定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __platform_driver_register(<span class="keyword">struct</span> platform_driver *drv, <span class="keyword">struct</span> module *owner)</span><br><span class="line">&#123;</span><br><span class="line">    drv-&gt;driver.owner = owner;                   <span class="comment">// 将平台驱动程序的所有权设置为当前模块</span></span><br><span class="line">    drv-&gt;driver.bus = &amp;platform_bus_type;    <span class="comment">// 将平台驱动程序的总线类型设置为平台总线</span></span><br><span class="line">    drv-&gt;driver.probe = platform_drv_probe;      <span class="comment">// 设置平台驱动程序的探测函数</span></span><br><span class="line">    drv-&gt;driver.remove = platform_drv_remove;    <span class="comment">// 设置平台驱动程序的移除函数</span></span><br><span class="line">    drv-&gt;driver.shutdown = platform_drv_shutdown;<span class="comment">// 设置平台驱动程序的关机函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> driver_register(&amp;drv-&gt;driver);        <span class="comment">// 将平台驱动程序注册到内核</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第3行：将指向当前模块的指针 owner 赋值给平台驱动程序的 owner 成员。这样做是为了将当前模块与平台驱动程序关联起来，以确保模块的生命周期和驱动程序的注册和注销相关联。</p>
<p>第4行：将指向平台总线类型的指针 &amp;platform_bus_type 赋值给平台驱动程序的 bus 成员。这样做是为了指定该驱动程序所属的总线类型为平台总线，以便内核能够将平台设备与正确的驱动程序进行匹配。</p>
<p>第5行：将指向平台驱动程序探测函数 platform_drv_probe 的指针赋值给平台驱动程序的 probe 成员。这样做是为了指定当内核发现与驱动程序匹配的平台设备时，要调用的驱动程序探测函数。</p>
<p>第6行：将指向平台驱动程序移除函数 platform_drv_remove 的指针赋值给平台驱动程序的 remove 成员。这样做是为了指定当内核需要从系统中移除与驱动程序匹配的平台设备时，要调用的驱动程序移除函数。</p>
<p>第7行 &#x3D; platform_drv_shutdown;：将指向平台驱动程序关机函数 platform_drv_shutdown 的指针赋值给平台驱动程序的 shutdown 成员。这样做是为了指定当系统关机时，要调用的驱动程序关机函数。</p>
<p>第9行：调用 driver_register 函数，将平台驱动程序的 driver 成员注册到内核中。该函数负责将驱动程序注册到相应的总线上，并在注册成功时返回 0，注册失败时返回一个负数错误码。</p>
<p>通过这些操作，__platform_driver_register 函数将平台驱动程序与内核关联起来，并确保内核能够正确识别和调用驱动程序的各种回调函数，以实现与平台设备的交互和管理。函数的返回值表示注册过程的执行状态，以便在需要时进行错误处理。</p>
<h3 id="52-1-2-platform-device-unregister-函数"><a href="#52-1-2-platform-device-unregister-函数" class="headerlink" title="52.1.2 platform_device_unregister 函数"></a>52.1.2 platform_device_unregister 函数</h3><p>platform_device_unregister函数用于取消注册已经注册的平台设备，即从内核中移除设备。在设备不再需要时，调用该函数可以进行设备的清理和释放操作。</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>void platform_device_unregister(struct platform_device *pdev);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;platform_device.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em><br>    platform_device_unregister 函数用于从内核中注销平台设备。通过调用该函数，可以将指定的平台设备从系统中移除。</p>
<p>****参数含义****：</p>
<p>pdev：指向要注销的平台设备的指针。</p>
<p><em><strong>*返回值：*</strong></em><br>    无返回值。</p>
<p>该函数在内核源码目录下的“&#x2F;include&#x2F;linux&#x2F;platform_device.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">platform_driver_unregister</span><span class="params">(<span class="keyword">struct</span> platform_driver *)</span>;</span><br></pre></td></tr></table></figure>

<p>函数声明中的extern关键字表示该函数在其他地方定义，而不是在当前文件中实现。这样的声明通常出现在头文件中，用于告诉编译器该函数的定义存在于其他源文件中，以便在编译时能够正确引用该函数。</p>
<p>而platform_driver_unregister实际定义在“&#x2F;drivers&#x2F;base&#x2F;platform.c”文件中，相关定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">platform_driver_unregister</span><span class="params">(<span class="keyword">struct</span> platform_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">	driver_unregister(&amp;drv-&gt;driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数又调用了driver_unregister函数进行嵌套，追踪之后找到定义在“&#x2F;drivers&#x2F;base&#x2F;driver.c”目录下的driver_unregister函数，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">driver_unregister</span><span class="params">(<span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查传入的设备驱动程序指针和 p 成员是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (!drv || !drv-&gt;p) &#123;</span><br><span class="line">        WARN(<span class="number">1</span>, <span class="string">&quot;Unexpected driver unregister!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    driver_remove_groups(drv, drv-&gt;groups); <span class="comment">// 移除与设备驱动程序关联的属性组</span></span><br><span class="line">    bus_remove_driver(drv);    <span class="comment">// 从总线中移除设备驱动程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数内部有三个主要的操作：</p>
<p>第4-7行：检查传入的设备驱动程序指针 drv 是否为空，或者驱动程序的 p 成员是否为空。如果其中任何一个条件为真，表示传入的参数无效，会发出警告并返回。</p>
<p>第9行：调用 driver_remove_groups 函数，用于从内核中移除与设备驱动程序关联的属性组。drv-&gt;groups 是指向属性组的指针，指定了要移除的属性组列表。</p>
<p>第10行：调用 bus_remove_driver 函数，用于从总线中移除设备驱动程序。该函数会执行以下操作：</p>
<p>（1）从总线驱动程序列表中移除指定的设备驱动程序。</p>
<p>（2）调用与设备驱动程序关联的 remove 回调函数（如果有定义）。</p>
<p>（3）释放设备驱动程序所占用的资源和内存。</p>
<p>（4）最终销毁设备驱动程序的数据结构。</p>
<p>通过调用 driver_unregister 函数，可以正确地注销设备驱动程序，并在注销过程中进行必要的清理工作。这样可以避免资源泄漏和其他问题。在调用该函数后，应避免继续使用已注销的设备驱动程序指针，因为该驱动程序已不再存在于内核中。</p>
<h3 id="52-1-3-platform-driver结构体"><a href="#52-1-3-platform-driver结构体" class="headerlink" title="52.1.3 platform_driver结构体"></a>52.1.3 platform_driver结构体</h3><p>platform_driver 结构体是Linux内核中用于编写平台设备驱动程序的重要数据结构。它提供了与平台设备驱动相关的函数和数据成员，以便与平台设备进行交互和管理。该结构体定义在内核的“&#x2F;include&#x2F;linux&#x2F;platform_device.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*probe)(<span class="keyword">struct</span> platform_device *); <span class="comment">/* 平台设备的探测函数指针 */</span></span><br><span class="line">	<span class="type">int</span> (*remove)(<span class="keyword">struct</span> platform_device *); <span class="comment">/* 平台设备的移除函数指针 */</span></span><br><span class="line">	<span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> platform_device *);<span class="comment">/* 平台设备的关闭函数指针 */</span></span><br><span class="line">	<span class="type">int</span> (*suspend)(<span class="keyword">struct</span> platform_device *, <span class="type">pm_message_t</span> state);<span class="comment">/* 平台设备的挂起函数指针 */</span></span><br><span class="line">	<span class="type">int</span> (*resume)(<span class="keyword">struct</span> platform_device *);<span class="comment">/* 平台设备的恢复函数指针 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span><span class="comment">/* 设备驱动程序的通用数据 */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_table</span>;</span><span class="comment">/* 平台设备与驱动程序的关联关系表 */</span></span><br><span class="line">	<span class="type">bool</span> prevent_deferred_probe; <span class="comment">/* 是否阻止延迟探测 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>probe：平台设备的探测函数指针。当系统检测到一个平台设备与该驱动程序匹配时，该函数将被调用以初始化和配置设备。</p>
<p>remove：平台设备的移除函数指针。当平台设备从系统中移除时，该函数将被调用以执行清理和释放资源的操作。</p>
<p>shutdown：平台设备的关闭函数指针。当系统关闭时，该函数将被调用以执行与平台设备相关的关闭操作。</p>
<p>suspend：平台设备的挂起函数指针。当系统进入挂起状态时，该函数将被调用以执行与平台设备相关的挂起操作。</p>
<p>resume：平台设备的恢复函数指针。当系统从挂起状态恢复时，该函数将被调用以执行与平台设备相关的恢复操作。</p>
<p>driver：包含了与设备驱动程序相关的通用数据，它是 struct device_driver 类型的实例。其中包括驱动程序的名称、总线类型、模块拥有者、属性组数组指针等信息，该结构体的name参数需要与上个章节的platform_device的.name参数相同才能匹配成功，从而进入probe函数。</p>
<p>id_table：指向 struct platform_device_id 结构体数组的指针，用于匹配平台设备和驱动程序之间的关联关系。通过该关联关系，可以确定哪个平台设备与该驱动程序匹配，和.driver.name起到相同的作用，但是优先级高于.driver.name。</p>
<p>prevent_deferred_probe：一个布尔值，用于确定是否阻止延迟探测。如果设置为 true，则延迟探测将被禁用。</p>
<p>使用 struct platform_driver 结构体，开发人员可以定义平台设备驱动程序，并将其注册到内核中。当系统检测到与该驱动程序匹配的平台设备时，内核将调用相应的函数来执行设备的初始化、配置、操作和管理。驱动程序可以利用提供的函数指针和通用数据与平台设备进行交互，并提供必要的功能和服务。</p>
<p>需要注意的是，struct platform_driver 结构体继承了 struct device_driver 结构体，因此可以直接访问 struct device_driver 中定义的成员。这使得平台驱动程序可以利用通用的驱动程序机制，并与其他类型的设备驱动程序共享代码和功能。</p>
<h2 id="52-2-实验程序的编写"><a href="#52-2-实验程序的编写" class="headerlink" title="52.2 实验程序的编写"></a>52.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\41。</p>
<p>本小节的实验只是编写一个platform驱动的一个大体框架，在下一个章节中再讲解platform设备和platform驱动的匹配</p>
<p>编写完成的platform_driver.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的探测函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_probe: Probing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Removing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="52-3-运行测试"><a href="#52-3-运行测试" class="headerlink" title="52.3 运行测试"></a>52.3 运行测试</h2><h3 id="52-3-1-编译驱动程序"><a href="#52-3-1-编译驱动程序" class="headerlink" title="52.3.1 编译驱动程序"></a>52.3.1 编译驱动程序</h3><p>在上一小节中的platform_driver.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_driver.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_driver.c和Makefile文件目录下，如下图（图52-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps8.jpg" alt="img"> </p>
<p>图 52-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图52-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps9.jpg" alt="img"> </p>
<p>图 51-2</p>
<p>编译完生成platform_driver.ko目标文件，如下图（图52-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps10.jpg" alt="img"> </p>
<p>图 52-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="52-3-2-运行测试"><a href="#52-3-2-运行测试" class="headerlink" title="52.3.2 运行测试"></a>52.3.2 运行测试</h3><p>本小节的测试需要用到两个驱动ko文件，即上一章节的注册platform设备ko文件和本章节的注册platform驱动ko文件。</p>
<p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图21-7）所示：</p>
<p>insmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps11.jpg" alt="img"> </p>
<p>然后来到&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;drivers目录下，可以看到我们创建的my_platform_driver驱动文件夹就成功生成了。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps12.jpg" alt="img"> </p>
<p>然后使用以下命令加载注册platform设备ko文件，加载成功之后如下图所示：</p>
<p> insmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps13.jpg" alt="img"> </p>
<p>可以看到匹配成功之后就会进入probe函数，显示出了相应的打印（加载上述两个ko文件不分先后顺序）。然后使用以下命令进行驱动模块的卸载，如下图（图21-7）所示：</p>
<p>rmmod platform_driver.ko</p>
<p>rmmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps14.jpg" alt="img"> </p>
<p>至此，注册platform驱动实验就完成了。</p>
<h1 id="第53章-probe函数编写实验"><a href="#第53章-probe函数编写实验" class="headerlink" title="第53章 probe函数编写实验"></a>第53章 probe函数编写实验</h1><p>在上面的两个章节中分别注册了platform设备和platform驱动，匹配成功之后会进入在注册platform驱动程序中编写的probe函数，在上个章节只是为了验证是否匹配成功，所以只是在probe中加入了一句相关打印，而驱动是要控制硬件的，但是平台总线模型对硬件的描述写在了platform_device.c中,platform设备和platform驱动匹配成功之后，那我们如何在驱动platform_driver.c的probe函数中，得到platform_device.c中编写的硬件资源呢。下面开始本节课程的学习吧。</p>
<h2 id="53-1-获取device资源"><a href="#53-1-获取device资源" class="headerlink" title="53.1 获取device资源"></a>53.1 获取device资源</h2><p><em><strong>*方法*</strong></em><em><strong>*1*</strong></em><em><strong>*：直接访问 platform_device 结构体的资源数组*</strong></em></p>
<p>在上一章节的讲解中提到：struct platform_driver 结构体继承了 struct device_driver 结构体，因此可以直接访问 struct device_driver 中定义的成员。实例代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (pdev-&gt;num_resources &gt;= 2) &#123;</span><br><span class="line">      struct resource *res_mem = &amp;pdev-&gt;resource[0];</span><br><span class="line">      struct resource *res_irq = &amp;pdev-&gt;resource[1];</span><br><span class="line"></span><br><span class="line">      // 使用获取到的硬件资源进行处理</span><br><span class="line">      printk(&quot;Method 1: Memory Resource: start = 0x%lld, end = 0x%lld\n&quot;,</span><br><span class="line">              res_mem-&gt;start, res_mem-&gt;end);</span><br><span class="line">      printk(&quot;Method 1: IRQ Resource: number = %lld\n&quot;, res_irq-&gt;start);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在这种方法中，直接访问platform_device结构体的资源数组来获取硬件资源。pdev-&gt;resource是一个资源数组，其中存储了设备的硬件资源信息。通过访问数组的不同索引，可以获取到特定的资源。</p>
<p>在这个示例中，假设资源数组的第一个元素是内存资源，第二个元素是中断资源。所以我们将第一个元素的指针赋值给res_mem，第二个元素的指针赋值给res_irq。</p>
<p><em><strong>*方法*</strong></em><em><strong>*2*</strong></em><em><strong>*：使用 platform_get_resource() 获取硬件资源*</strong></em></p>
<p>platform_get_resource()函数用于获取设备的资源信息。它的声明位于&lt;linux&#x2F;platform_device.h&gt;头文件中，与平台设备（platform_device）相关。</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>struct resource *platform_get_resource(struct platform_device *pdev,                    unsigned int type, unsigned int num);</p>
<p><em><strong>*参数说明：*</strong></em></p>
<p>pdev：指向要获取资源的平台设备（platform_device）结构体的指针。</p>
<p>type：指定资源的类型，可以是以下值之一：</p>
<p>IORESOURCE_MEM：表示内存资源。</p>
<p>IORESOURCE_IO：表示I&#x2F;O资源。</p>
<p>IORESOURCE_IRQ：表示中断资源。</p>
<p>其他资源类型的宏定义可在&lt;linux&#x2F;ioport.h&gt;和&lt;linux&#x2F;irq.h&gt;头文件中找到。</p>
<p>num：指定要获取的资源的索引。在一个设备中可能存在多个相同类型的资源，通过索引可以选择获取特定的资源。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>如果成功获取资源，则返回指向资源（struct resource）的指针。</p>
<p>如果获取资源失败，或者指定的资源不存在，则返回NULL。</p>
<p>platform_get_resource()函数用于从平台设备的资源数组中获取指定类型和索引的资源。在平台设备的资源数组中，每个元素都是一个struct resource结构体，描述了一个资源的信息，如起始地址、结束地址、中断号等。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line"></span><br><span class="line">res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!res) &#123;</span><br><span class="line">    <span class="comment">// 处理获取内存资源失败的情况</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用获取到的内存资源进行处理</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> start = res-&gt;start;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> end = res-&gt;end;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在上述示例中，首先通过platform_get_resource()函数获取平台设备的第一个内存资源（索引为0）。如果获取资源失败（返回NULL），则可以根据实际情况进行错误处理。如果获取资源成功，则可以使用返回的资源指针来访问资源的信息，如起始地址和结束地址。</p>
<p>通过platform_get_resource()函数，可以方便地在驱动程序中获取平台设备的资源信息，并根据这些信息进行后续的操作和配置。</p>
<h2 id="53-2-实验程序的编写"><a href="#53-2-实验程序的编写" class="headerlink" title="53.2 实验程序的编写"></a>53.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\42_probe。</p>
<p>在上一章程序的基础上，添加第一小节两种获取设备资源的方式并打印出来。</p>
<p>编写完成的probe.c代码如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_driver_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res_mem</span>, *<span class="title">res_irq</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法1：直接访问 platform_device 结构体的资源数组</span></span><br><span class="line">    <span class="keyword">if</span> (pdev-&gt;num_resources &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res_mem</span> =</span> &amp;pdev-&gt;resource[<span class="number">0</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res_irq</span> =</span> &amp;pdev-&gt;resource[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用获取到的硬件资源进行处理</span></span><br><span class="line">        printk(<span class="string">&quot;Method 1: Memory Resource: start = 0x%llx, end = 0x%llx\n&quot;</span>,</span><br><span class="line">                res_mem-&gt;start, res_mem-&gt;end);</span><br><span class="line">        printk(<span class="string">&quot;Method 1: IRQ Resource: number = %lld\n&quot;</span>, res_irq-&gt;start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法2：使用 platform_get_resource() 获取硬件资源</span></span><br><span class="line">    res_mem = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!res_mem) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get memory resource\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res_irq = platform_get_resource(pdev, IORESOURCE_IRQ, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!res_irq) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get IRQ resource\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用获取到的硬件资源进行处理</span></span><br><span class="line">    printk(<span class="string">&quot;Method 2: Memory Resource: start = 0x%llx, end = 0x%llx\n&quot;</span>,</span><br><span class="line">            res_mem-&gt;start, res_mem-&gt;end);</span><br><span class="line">    printk(<span class="string">&quot;Method 2: IRQ Resource: number = %lld\n&quot;</span>, res_irq-&gt;start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_driver_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设备移除操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>, <span class="comment">// 与 platform_device.c 中的设备名称匹配</span></span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = my_platform_driver_probe,</span><br><span class="line">    .remove = my_platform_driver_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver); <span class="comment">// 注册平台驱动</span></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;Platform driver registered\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver); <span class="comment">// 注销平台驱动</span></span><br><span class="line">    printk(<span class="string">&quot;Platform driver unregistered\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="53-3-运行测试"><a href="#53-3-运行测试" class="headerlink" title="53.3 运行测试"></a>53.3 运行测试</h2><h3 id="53-3-1-编译驱动程序"><a href="#53-3-1-编译驱动程序" class="headerlink" title="53.3.1 编译驱动程序"></a>53.3.1 编译驱动程序</h3><p>在上一小节中的probe.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += probe.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放probe.c和Makefile文件目录下，如下图（图53-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps15.jpg" alt="img"> </p>
<p>图 53-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图53-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps16.jpg" alt="img"> </p>
<p>图 53-2</p>
<p>编译完生成probe.ko目标文件，如下图（图53-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps17.jpg" alt="img"> </p>
<p>图 53-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="53-3-2-运行测试"><a href="#53-3-2-运行测试" class="headerlink" title="53.3.2 运行测试"></a>53.3.2 运行测试</h3><p>本小节的测试要使用两个ko文件，第一个ko文件为第53章编译出来的platform_device.ko驱动，第二个ko文件为在上一小节编译出的probe.ko驱动文件。</p>
<p>开发板启动之后，首先使用以下命令进行platform设备的注册，如下图（图53-4）所示：</p>
<p>insmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps18.jpg" alt="img"> </p>
<p>图 53-4</p>
<p>然后继续使用以下命令加载probe.ko驱动，打印如下图（53-5）所示：</p>
<p>insmod probe.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps19.jpg" alt="img"> </p>
<p>图 53-5</p>
<p>在上图中，打印了两种方式下获取得到的内存信息和中断信息，最后可以使用以下命令进行驱动的卸载，如下图（图53-6）所示：</p>
<p>rmmod  probe.ko</p>
<p>rmmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps20.jpg" alt="img"> </p>
<p>图 53-6</p>
<h1 id="第54章-点亮LED灯实验（平台总线）"><a href="#第54章-点亮LED灯实验（平台总线）" class="headerlink" title="第54章 点亮LED灯实验（平台总线）"></a>第54章 点亮LED灯实验（平台总线）</h1><p>在上个章节中，我们成功在platform驱动程序中读取到了设备资源信息，在本章节将进行具体的项目实践，要求在上节platform驱动程序的基础上，加入控制LED灯相关的代码（这部分代码可以参考“第18章 点亮LED灯实验”）。</p>
<h2 id="54-1-实验程序的编写"><a href="#54-1-实验程序的编写" class="headerlink" title="54.1 实验程序的编写"></a>54.1 实验程序的编写</h2><h3 id="54-1-1-驱动程序编写"><a href="#54-1-1-驱动程序编写" class="headerlink" title="54.1.1 驱动程序编写"></a>54.1.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\43_platform_led\module。</p>
<p>编写完成的platform_led.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *vir_gpio_dr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(test_dev-&gt;kbuf[<span class="number">0</span>]==<span class="number">1</span>)&#123;   <span class="comment">//如果应用层传入的数据是1，则打开灯</span></span><br><span class="line">            *(test_dev-&gt;vir_gpio_dr) = <span class="number">0x8000c040</span>;   <span class="comment">//设置数据寄存器的地址</span></span><br><span class="line">              printk(<span class="string">&quot;test_dev-&gt;kbuf [0]  is %d\n&quot;</span>,test_dev-&gt;kbuf[<span class="number">0</span>]);  <span class="comment">//打印传入的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(test_dev-&gt;kbuf[<span class="number">0</span>]==<span class="number">0</span>)  <span class="comment">//如果应用层传入的数据是0，则关闭灯</span></span><br><span class="line">    &#123;</span><br><span class="line">            *(test_dev-&gt;vir_gpio_dr) = <span class="number">0x80004040</span>; <span class="comment">//设置数据寄存器的地址</span></span><br><span class="line">            printk(<span class="string">&quot;test_dev-&gt;kbuf [0]  is %d\n&quot;</span>,test_dev-&gt;kbuf[<span class="number">0</span>]); <span class="comment">//打印传入的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_driver_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res_mem</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!res_mem) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get memory resource\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line">    dev1.vir_gpio_dr=ioremap(res_mem-&gt;start,<span class="number">4</span>);  <span class="comment">//将物理地址转化为虚拟地址</span></span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.vir_gpio_dr))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.vir_gpio_dr);  <span class="comment">//PTR_ERR()来返回错误代码</span></span><br><span class="line">        <span class="keyword">goto</span> err_ioremap;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_ioremap:</span><br><span class="line">        iounmap(dev1.vir_gpio_dr);</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_driver_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设备移除操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>, <span class="comment">// 与 platform_device.c 中的设备名称匹配</span></span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = my_platform_driver_probe,</span><br><span class="line">    .remove = my_platform_driver_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver); <span class="comment">// 注册平台驱动</span></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;Platform driver registered\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">	platform_driver_unregister(&amp;my_platform_driver); <span class="comment">// 注销平台驱动</span></span><br><span class="line">    printk(<span class="string">&quot;Platform driver unregistered\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="54-1-2-编写测试-APP"><a href="#54-1-2-编写测试-APP" class="headerlink" title="54.1.2 编写测试 APP"></a>54.1.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\43_platform_led\app。</p>
<p>编写测试app,led驱动加载成功之后会生成&#x2F;dev&#x2F;test节点，应用程序APP通过操作&#x2F;dev&#x2F;test文件来完成对LED设备的控制。向&#x2F;dev&#x2F;test文件写入0表示关闭LED灯，写入1表示打开LED灯。编写完成的应用程序app.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开led驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// atoi()将字符串转为整型，这里将第一个参数转化为整型后，存放在 buf[0]中</span></span><br><span class="line">buf[<span class="number">0</span>] =atoi(argv[<span class="number">1</span>]);  </span><br><span class="line">write(fd,buf,<span class="keyword">sizeof</span>(buf));  <span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="54-2-运行测试"><a href="#54-2-运行测试" class="headerlink" title="54.2 运行测试"></a>54.2 运行测试</h2><h3 id="54-2-1-编译驱动程序"><a href="#54-2-1-编译驱动程序" class="headerlink" title="54.2.1 编译驱动程序"></a>54.2.1 编译驱动程序</h3><p>在上一小节中的platform_led.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_led.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_led.c和Makefile文件目录下，如下图（图54-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps21.jpg" alt="img"> </p>
<p>图 54-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图54-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps22.jpg" alt="img"> </p>
<p>图 54-2</p>
<p>编译完生成platform_led.ko目标文件，如下图（图54-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps23.jpg" alt="img"> </p>
<p>图 54-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="54-2-2-编译应用程序"><a href="#54-2-2-编译应用程序" class="headerlink" title="54.2.2 编译应用程序"></a>54.2.2 编译应用程序</h3><p>下面进行应用程序编译，因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图54-4）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps24.jpg" alt="img"> </p>
<p>图 54-4</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="54-2-3-运行测试"><a href="#54-2-3-运行测试" class="headerlink" title="54.2.3 运行测试"></a>54.2.3 运行测试</h3><p>本小节的测试要使用两个ko文件和一个测试应用程序，第一个ko文件为第53章编译出来的platform_device.ko驱动，第二个ko文件为在上一小节编译出的probe.ko驱动文件，应用程序为上一小节编译出来的app。</p>
<p>开发板启动之后，首先使用以下命令进行platform设备的注册，如下图（图54-5）所示：</p>
<p>insmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps25.jpg" alt="img"> </p>
<p>图 54-5</p>
<p>然后继续使用以下命令加载platform_led.ko驱动，打印如下图（54-6）所示：</p>
<p>insmod platform_led.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps26.jpg" alt="img"> </p>
<p>图 54-6</p>
<p>可以看到led字符设备成功注册了，主设备号为236，次设备号为0，相应的test节点也成功创建了，如下图（54-7）所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps27.jpg" alt="img"></p>
<p>图 54-7</p>
<p>默认情况下led灯的状态为常亮，然后输入“.&#x2F;app 0”命令LED灯熄灭，如下图（图 54-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps28.jpg" alt="img"> </p>
<p>图 54-8</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps29.jpg" alt="img"> </p>
<p>图 54-9</p>
<p>然后输入“.&#x2F;app 0”，LED灯点亮，如下图（图 54-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps30.jpg" alt="img"> </p>
<p>图 54-10</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps31.jpg" alt="img"> </p>
<p>图 54-11</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图54-12）所示：</p>
<p>rmmod platform_led.ko</p>
<p>rmmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps32.jpg" alt="img"> </p>
<p>图 54-12</p>
<p>至此，使用平台总线的点亮LCD灯实验就完成了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B3%E5%8F%B0%E6%80%BB%E7%BA%BF/" rel="tag">平台总线</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-rk3568-驱动开发第五篇-中断"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%94%E7%AF%87-%E4%B8%AD%E6%96%AD/"
    >rk3568 驱动开发第五篇 中断</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%94%E7%AF%87-%E4%B8%AD%E6%96%AD/" class="article-date">
  <time datetime="2023-09-04T12:55:48.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第39章-中断实验"><a href="#第39章-中断实验" class="headerlink" title="第39章 中断实验"></a>第39章 中断实验</h1><p>在前面的课程中，我们深入学习了高级字符设备的进阶知识，包括IO模型、定时器原理、llseek设备定位和通过ioctl传递参数等。通过这些课程，我们对高级字符设备有了深入的理解，并掌握了一些实用的技术和编程方法。从今天开始，我们就进入中断课程的学习了。中断是操作系统中至关重要的机制，它能够显著提高系统的响应性能和并发处理能力。</p>
<h2 id="39-1什么是中断？"><a href="#39-1什么是中断？" class="headerlink" title="39.1什么是中断？"></a>39.1什么是中断？</h2><h3 id="39-1-1-中断的概念"><a href="#39-1-1-中断的概念" class="headerlink" title="39.1.1 中断的概念"></a>39.1.1 中断的概念</h3><p>中断是指在CPU正常运行期间，由外部或内部事件引起的一种机制。当中断发生时，CPU会停止当前正在执行的程序，并转而执行触发该中断的中断处理程序。处理完中断处理程序后，CPU会返回到中断发生的地方，继续执行被中断的程序。中断机制允许CPU在实时响应外部或内部事件的同时，保持对其他任务的处理能力。</p>
<p>可以想象这样一幅画面，你正在烹饪一顿美味的晚餐，准备了各种食材，点燃了炉灶，开始了幸福的烹饪过程，突然，你的手机响起，有人打来了一个紧急电话，打破了你正常的烹饪流程，这时候你需要立刻停止手中的工作，迅速接起电话，与对方进行交流，在接完电话之后，再回到厨房继续之前的烹饪流程。这就是一个在实际生活中的中断案例，中断的概念流程图如下（39-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps33.jpg" alt="img"> </p>
<p>图 39-1</p>
<h3 id="39-1-2-中断的重要性"><a href="#39-1-2-中断的重要性" class="headerlink" title="39.1.2 中断的重要性"></a>39.1.2 中断的重要性</h3><p>在上面的场景中，作为唯一具有处理能力的主体，我们一次只能专注于一个任务，可以等待水烧开、看电视等等。然而，当我们专心致志地完成一项任务时，常常会有紧迫或不紧迫的其他事情突然出现，需要我们关注和处理。有些情况甚至要求我们立即停下手头的工作来应对。只有在处理完这些中断事件之后，我们才能回到先前的任务。</p>
<p>中断机制赋予了我们处理意外情况的能力，而且如果我们能充分利用这个机制，就能够同时完成多个任务。回到烧水的例子，无论我们是否在厨房，煤气灶都会将水烧开。我们只需要在水烧开后及时关掉煤气。为了避免在厨房等待的时间，而水烧开时产生的声音就是中断信号，提醒我们炉子上的水已经烧开。这样，我们就可以在等待的时间里做其他事情，比如看电视。当水壶烧开发出声音之后，它会打断当前的任务，提醒水已经烧开，这时只需要前往厨房关掉煤气即可。</p>
<p>中断机制使我们能够有条不紊地同时处理多个任务，从而提高了并发处理能力。类似地，计算机系统中也使用中断机制来应对各种外部事件。例如，在键盘输入时，会发送一个中断信号给CPU，以便及时响应用户的操作。这样，CPU就不必一直轮询键盘的状态，而可以专注于其他任务。中断机制还可以用于处理硬盘读写完成、网络数据包接收等事件，提高了系统的资源利用率和并发处理能力。</p>
<h3 id="39-1-3-中断的上下半部"><a href="#39-1-3-中断的上下半部" class="headerlink" title="39.1.3 中断的上下半部"></a>39.1.3 中断的上下半部</h3><p>中断的执行需要快速响应，但并不是所有中断都能迅速完成。此外，Linux中的中断不支持嵌套，意味着在正式处理中断之前会屏蔽其他中断，直到中断处理完成后再重新允许接收中断，如果中断处理时间过长，将会引发问题。</p>
<p>这里仍旧以烹饪的过程中接电话进行举例：当你正在烹饪一顿美味的晚餐时，所有的食材都准备好了，炉灶上的火焰跳跃着，你正享受着烹饪的乐趣。突然，你的手机响起，发出紧急电话的铃声，打破了你正常的烹饪流程，接电话的时间很短并不会对烹饪产生很大的影响，而接电话的时候可能就有问题了，水烧开之后可能会煮干、错过了最好的添加调味料的时间等等。</p>
<p>而为了让系统可以更好地处理中断事件，提高实时性和响应能力，将中断服务程序划分为上下文两部分：</p>
<p>中断上文是中断服务程序的第一部分，它主要处理一些紧急且需要快速响应的任务。中断上文的特点是执行时间较短，旨在尽快完成对中断的处理。这些任务可能包括保存寄存器状态、更新计数器等，以便在中断处理完成后能够正确地返回到中断前的执行位置。</p>
<p>中断下文是中断服务程序的第二部分，它主要处理一些相对耗时的任务。由于中断上文需要尽快完成，因此中断下文负责处理那些不能立即完成的、需要更多时间的任务。这些任务可能包括复杂的计算、访问外部设备或进行长时间的数据处理等。</p>
<h2 id="39-2中断子系统框架"><a href="#39-2中断子系统框架" class="headerlink" title="39.2中断子系统框架"></a>39.2中断子系统框架</h2><p>一个完整的中断子系统框架可以分为四个层次，由上到下分别为用户层、通用层、硬件相关层和硬件层，每个层相关的介绍如下（图39-2）所示：</p>
<p>****用户层：****用户层是中断的使用者，主要包括各类设备驱动。这些驱动程序通过中断相关的接口进行中断的申请和注册。当外设触发中断时，用户层驱动程序会进行相应的回调处理，执行特定的操作。</p>
<p>****通用层：****通用层也可称为框架层，它是硬件无关的层次。通用层的代码在所有硬件平台上都是通用的，不依赖于具体的硬件架构或中断控制器。通用层提供了统一的接口和功能，用于管理和处理中断，使得驱动程序能够在不同的硬件平台上复用。</p>
<p>****硬件相关层：****硬件相关层包含两部分代码。一部分是与特定处理器架构相关的代码，比如ARM64处理器的中断处理相关代码。这些代码负责处理特定架构的中断机制，包括中断向量表、中断处理程序等。另一部分是中断控制器的驱动代码，用于与中断控制器进行通信和配置。这些代码与具体的中断控制器硬件相关。</p>
<p>****硬件层：****硬件层位于最底层，与具体的硬件连接相关。它包括外设与SoC（系统片上芯片）的物理连接部分。中断信号从外设传递到中断控制器，由中断控制器统一管理和路由到处理器。硬件层的设计和实现决定了中断信号的传递方式和硬件的中断处理能力。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps34.jpg" alt="img"> </p>
<p>图 39-2</p>
<p>本小节的重点会聚集在硬件层各部分的详细讲解以及用户层编写驱动程序所用到的接口函数。</p>
<h3 id="39-2-1-中断控制器GIC"><a href="#39-2-1-中断控制器GIC" class="headerlink" title="39.2.1 中断控制器GIC"></a>39.2.1 中断控制器GIC</h3><p>中断控制器GIC（Generic Interrupt Controller）是中断子系统框架硬件层中的一个关键组件，用于管理和控制中断。它接收来自各种中断源的中断请求，并根据预先配置的中断优先级、屏蔽和路由规则，将中断请求分发给适当的处理器核心或中断服务例程。</p>
<p>GIC是由ARM公司提出设计规范，当前有四个版本，GIC V1-v4。设计规范中最常用的，有3个版本V2.0、V3.1、V4.1，GICv3版本设计主要运行在Armv8-A, Armv9-A等架构上。ARM公司并给出一个实际的控制器设计参考，比如GIC-400(支持GIC v2架构)、gic500(支持GIC v3架构)、GIC-600(支持GIC v3和GIC v4架构)。最终芯片厂商可以自己实现GIC或者直接购买ARM提供的设计。</p>
<p>每个GIC版本及相应特性如下表（表 39-3）所示：</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>关键特性</th>
<th>常用核心</th>
</tr>
</thead>
<tbody><tr>
<td>GICv1</td>
<td>-支持最多八个处理器核心（PE）- 支持最多1020个中断ID</td>
<td>ARM Cortex-A5 MPCoreARM Cortex-A9 MPCoreARM Cortex-R7 MPCore</td>
</tr>
<tr>
<td>GICv2</td>
<td>- GICv1的所有关键特性-支持虚拟化</td>
<td>ARM Cortex-A7 MPCoreARM Cortex-A15 MPCoreARM Cortex-A53 MPCoreARM Cortex-A57 MPCore</td>
</tr>
<tr>
<td>GICv3</td>
<td>- GICv2的所有关键特性-支持超过8个处理器核心-支持基于消息的中断-支持超过1020个中断ID- CPU接口寄存器的系统寄存器访问-增强的安全模型，分离安全和非安全的Group 1中断</td>
<td>ARM Cortex-A53MPCoreARM Cortex-A57MPCoreARM Cortex-A72 MPCore</td>
</tr>
<tr>
<td>GICv4</td>
<td>- GICv3的所有关键特性-虚拟中断的直接注入</td>
<td>ARM Cortex-A53 MPCoreARMCortex-A57MPCoreARM Cortex-A72 MPCore</td>
</tr>
</tbody></table>
<p>表 39-3</p>
<p>在RK3568上使用的GIC版本为GICv3，相应的中断控制器模型如下（图 39-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps35.jpg" alt="img"> </p>
<p>图 39-4</p>
<p>GIC中断控制器可以分为Distributor接口、Redistributor接口和CPU接口，下面是每个部分的说明：</p>
<p><em><strong>*Distributor*</strong></em><em><strong>*中断仲裁器：*</strong></em></p>
<p>包含影响所有处理器核心中断的全局设置。包含以下编程接口：</p>
<p>●启用和禁用SPI。</p>
<p>●设置每个SPI的优先级级别。</p>
<p>●每个SPI的路由信息。</p>
<p>●将每个SPI设置为电平触发或边沿触发。</p>
<p>●生成基于消息的SPI。</p>
<p>●控制SPI的活动和挂起状态。</p>
<p>●用于确定在每个安全状态中使用的程序员模型的控制（亲和性路由或遗留模型）。</p>
<p>****Redistributor重新分配器****：</p>
<p>对于每个连接的处理器核心（PE），都有一个重新分配器（Redistributor）。重新分配器提供以下编程接口：</p>
<p>●启用和禁用SGI（软件生成的中断）和PPI（处理器专用中断）。</p>
<p>●设置SGI和PPI的优先级级别。</p>
<p>●将每个PPI设置为电平触发或边沿触发。</p>
<p>●将每个SGI和PPI分配给一个中断组。</p>
<p>●控制SGI和PPI的状态。</p>
<p>●对支持关联LPI（低功耗中断）的中断属性和挂起状态的内存中的数据结构进行基址控制。</p>
<p>●支持与连接的处理器核心的电源管理。</p>
<p><em><strong>*CPU接口*</strong></em><em><strong>*：*</strong></em></p>
<p>每个重新分配器都连接到一个CPU接口。CPU接口提供以下编程接口：</p>
<p>●通用控制和配置，用于启用中断处理。</p>
<p>●确认中断。</p>
<p>●执行中断的优先级降低和停用。</p>
<p>●为处理器核心设置中断优先级屏蔽。</p>
<p>●定义处理器核心的抢占策略。</p>
<p>●确定处理器核心最高优先级的挂起中断。</p>
<h3 id="39-2-2-中断类型"><a href="#39-2-2-中断类型" class="headerlink" title="39.2.2 中断类型"></a>39.2.2 中断类型</h3><p>GIC-V3支持四种类型的中断，分别是SGI、PPI、SPI和LPI，每个中断类型的介绍如下：</p>
<p>SGI（Software Generated Interrupt，软件生成中断）：SGI 是通过向 GIC 中的 SGI 寄存器写入来生成的中断。它通常用于处理器之间的通信，允许一个 PE 发送中断给一个或多个指定的 PE，中断号ID0 - ID15用于SGI。</p>
<p>PPI（Private Peripheral Interrupt，私有外设中断）：针对特定 PE 的外设中断。不与其他 PE 共享，中断号ID16 - ID31用于PPI。</p>
<p>SPI（Shared Peripheral Interrupt，共享外设中断）：全局外设中断，可以路由到指定的处理器核心（PE）或一组 PE，它允许多个 PE 接收同一个中断。中断号ID32 - ID1019用于SPI，</p>
<p>LPI（Locality-specific Peripheral Interrupt，特定局部外设中断）：LPI 是 GICv3 中引入的一种中断类型，与其他类型的中断有几个不同之处。LPI 总是基于消息的中断，其配置存储在内存表中，而不是寄存器中。</p>
<table>
<thead>
<tr>
<th>INTID范围</th>
<th>中断类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>0 - 15</td>
<td>SGI（软件生成中断）</td>
<td>每个核心分别存储</td>
</tr>
<tr>
<td>16 - 31</td>
<td>PPI（私有外设中断）</td>
<td>每个核心分别存储</td>
</tr>
<tr>
<td>32 - 1019</td>
<td>SPI（共享外设中断）</td>
<td></td>
</tr>
<tr>
<td>1020 - 1023</td>
<td>特殊中断号</td>
<td>用于表示特殊情况</td>
</tr>
<tr>
<td>1024 - 8191</td>
<td>保留</td>
<td></td>
</tr>
<tr>
<td>8192及更大</td>
<td>LPI（特定局部外设中断）</td>
<td>上限由实现定义</td>
</tr>
</tbody></table>
<p>表 39-5</p>
<p>中断处理的状态机如下图（图 39-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps36.jpg" alt="img"> </p>
<p>图 39-6</p>
<p>Inactive（非活动状态）：中断源当前未被触发。</p>
<p>Pending（等待状态）：中断源已被触发，但尚未被处理器核心确认。</p>
<p>Active（活动状态）：中断源已被触发，并且已被处理器核心确认。</p>
<p>Active and Pending（活动且等待状态）：已确认一个中断实例，同时另一个中断实例正在等待处理。</p>
<p>每个外设中断可以是以下两种类型之一：<br><em><strong>*边沿触发（Edge-triggered）*</strong></em><em><strong>*：*</strong></em><br>    这是一种在检测到中断信号上升沿时触发的中断，然后无论信号状态如何，都保持触发状态，直到满足本规范定义的条件来清除中断。</p>
<p><em><strong>*电平触发（Level-sensitive）*</strong></em><em><strong>*：*</strong></em><br>    这是一种在中断信号电平处于活动状态时触发的中断，并且在电平不处于活动状态时取消触发。</p>
<h3 id="39-2-3-中断号"><a href="#39-2-3-中断号" class="headerlink" title="39.2.3 中断号"></a>39.2.3 中断号</h3><p>在linux 内核中，我们使用IRQ number和HW interrupt ID两个ID来标识一个来自外设的中断：</p>
<p>****IRQ number****：CPU需要为每一个外设中断编号，我们称之IRQ Number。这个IRQ number是一个虚拟的interrupt ID，和硬件无关，仅仅是被CPU用来标识一个外设中断。</p>
<p>****HW interrupt ID：****对于GIC中断控制器而言，它收集了多个外设的interrupt request line并向上传递，因此，GIC中断控制器需要对外设中断进行编码。GIC中断控制器用HW interrupt ID来标识外设的中断。如果只有一个GIC中断控制器，那IRQ number和HW interrupt ID是可以一一对应的，如下图（图 39-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps37.jpg" alt="img"> </p>
<p>图 39-7</p>
<p>但如果是在GIC中断控制器级联的情况下，仅仅用HW interrupt ID就不能唯一标识一个外设中断，还需要知道该HW interrupt ID所属的GIC中断控制器（HW interrupt ID在不同的Interrupt controller上是会重复编码的）。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps38.jpg" alt="img"> </p>
<p>图 39-8</p>
<p>这样，CPU和中断控制器在标识中断上就有了一些不同的概念，但是，对于驱动工程师而言，我们和CPU视角是一样的，我们只希望得到一个IRQ number，而不关系具体是那个GIC中断控制器上的那个HW interrupt ID。这样一个好处是在中断相关的硬件发生变化的时候，驱动软件不需要修改。因此，linux kernel中的中断子系统需要提供一个将HW interrupt ID映射到IRQ number上来的机制，也就是irq domain。</p>
<h3 id="39-2-4-中断申请函数"><a href="#39-2-4-中断申请函数" class="headerlink" title="39.2.4 中断申请函数"></a>39.2.4 中断申请函数</h3><h4 id="（1）-request-irq"><a href="#（1）-request-irq" class="headerlink" title="（1）****request_irq"></a><strong>（<strong><strong>1</strong></strong>）****request_irq</strong></h4><p>request_irq 函数是在 Linux 内核中用于注册中断处理程序的函数。它用于请求一个中断号（IRQ number）并将一个中断处理程序与该中断关联起来。下面是对 request_irq 函数的详细介绍：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>  int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev);</p>
<p>****头文件****：</p>
<p>  #include &lt;linux&#x2F;interrupt.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>request_irq 函数的主要功能是请求一个中断号，并将一个中断处理程序与该中断号关联起来。当中断事件发生时，与该中断号关联的中断处理程序会被调用执行。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>irq：要请求的中断号（IRQ number）。</p>
<p>handler：指向中断处理程序的函数指针。</p>
<p>flags：标志位，用于指定中断处理程序的行为和属性，如中断触发方式、中断共享等。</p>
<p>name：中断的名称，用于标识该中断。</p>
<p>dev：指向设备或数据结构的指针，可以在中断处理程序中使用。</p>
<p>返回值：</p>
<p>成功：0 或正数，表示中断请求成功。</p>
<p>失败：负数，表示中断请求失败，返回的负数值表示错误代码。</p>
<p>irq参数用来指定要请求的中断号，中断号需要通过gpio_to_irq 函数映射 GPIO 引脚来获得（gpio_to_irq 函数接下来会进行介绍）。</p>
<p>irq_handler_t handler参数是一个函数指针，指向了中断处理程序的函数。中断处理程序是在中断事件发生时调用的函数，用于处理中断事件（关于中断处理程序会在下个小节进行详细的讲解）。</p>
<p>unsigned long flags：中断处理程序的标志位</p>
<p>这个参数用于指定中断处理程序的行为和属性，如中断触发方式、中断共享等。可以使用不同的标志位进行位运算来组合多个属性。常用的标志位包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IRQF_TRIGGER_NONE：无触发方式，表示中断不会被触发。</span><br><span class="line">IRQF_TRIGGER_RISING：上升沿触发方式，表示中断在信号上升沿时触发。</span><br><span class="line">IRQF_TRIGGER_FALLING：下降沿触发方式，表示中断在信号下降沿时触发。</span><br><span class="line">IRQF_TRIGGER_HIGH：高电平触发方式，表示中断在信号为高电平时触发。</span><br><span class="line">IRQF_TRIGGER_LOW：低电平触发方式，表示中断在信号为低电平时触发。</span><br><span class="line">IRQF_SHARED：中断共享方式，表示中断可以被多个设备共享使用。</span><br></pre></td></tr></table></figure>



<h4 id="（2）-gpio-to-irq"><a href="#（2）-gpio-to-irq" class="headerlink" title="（2）****gpio_to_irq"></a><strong>（2）****gpio_to_irq</strong></h4><p>gpio_to_irq 函数用于将 GPIO 引脚的编号（GPIO pin number）转换为对应的中断请求号（interrupt request number）。</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>unsigned int gpio_to_irq(unsigned int gpio);</p>
<p>****头文件****：</p>
<p>#include &lt;linux&#x2F;gpio.h&gt;</p>
<p><em><strong>*函数功能：*</strong></em><br>    gpio_to_irq 是一个用于将 GPIO 引脚映射到对应中断号的函数。它的作用是根据给定的 GPIO 引脚号，获取与之关联的中断号。</p>
<p><em><strong>*参数说明：*</strong></em></p>
<p>gpio：要映射的 GPIO 引脚号。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>成功：返回值为该 GPIO 引脚所对应的中断号。</p>
<p>失败：返回值为负数，表示映射失败或无效的 GPIO 引脚号。</p>
<h4 id="（3）free-irq"><a href="#（3）free-irq" class="headerlink" title="（3）free_irq"></a>（3）<strong>free_irq</strong></h4><p>free_irq 函数用于释放之前通过 request_irq 函数注册的中断处理程序。它的作用是取消对中断的注册并释放相关的系统资源。下面是关于该函数的详细解释：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>void free_irq(unsigned int irq, void *dev_id);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;interrupt.h&gt;</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>free_irq 函数用于释放之前通过 request_irq 函数注册的中断处理程序。它会取消对中断的注册并释放相关的系统资源，包括中断号、中断处理程序和设备标识等。</p>
<p><em><strong>*参数说明：*</strong></em></p>
<p>irq：要释放的中断号。</p>
<p>dev_id：设备标识，用于区分不同的中断请求。它通常是在 request_irq 函数中传递的设备特定数据指针。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>free_irq 函数没有返回值。</p>
<h3 id="39-2-5-中断服务函数"><a href="#39-2-5-中断服务函数" class="headerlink" title="39.2.5 中断服务函数"></a>39.2.5 中断服务函数</h3><p>中断处理程序是在中断事件发生时自动调用的函数。它负责处理与中断相关的操作，例如读取数据、清除中断标志、更新状态等。</p>
<p>irqreturn_t handler(int irq, void *dev_id) 是一个典型的中断服务函数的函数原型。下面对该函数原型及其参数进行详细解释：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>irqreturn_t handler(int irq, void *dev_id);</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>handler 函数是一个中断服务函数，用于处理特定中断事件。它在中断事件发生时被操作系统或硬件调用，执行必要的操作来响应和处理中断请求。</p>
<p><em><strong>*参数说明：*</strong></em></p>
<p>irq：表示中断号或中断源的标识符。它指示引发中断的硬件设备或中断控制器。</p>
<p>dev_id：是一个 void 类型的指针，用于传递设备特定的数据或标识符。它通常用于在中断处理程序中区分不同的设备或资源。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>irqreturn_t 是一个特定类型的枚举值，用于表示中断服务函数的返回状态。它可以有以下几种取值：</p>
<p>IRQ_NONE：表示中断服务函数未处理该中断，中断控制器可以继续处理其他中断请求。</p>
<p>IRQ_HANDLED：表示中断服务函数已成功处理该中断，中断控制器无需进一步处理。</p>
<p>IRQ_WAKE_THREAD：表示中断服务函数已处理该中断，并且请求唤醒一个内核线程来继续执行进一步的处理。这在一些需要长时间处理的中断情况下使用。</p>
<p>在处理程序中，通常需要注意以下几个方面：</p>
<p>（1）处理程序应该尽可能地快速执行，以避免中断丢失或过多占用 CPU 时间。</p>
<p>（2）如果中断源是共享的，处理程序需要处理多个设备共享同一个中断的情况。</p>
<p>（3）处理程序可能需要与其他部分的代码进行同步，例如访问共享数据结构或使用同步机制来保护临界区域。</p>
<p>（4）处理程序可能需要与其他线程或进程进行通信，例如唤醒等待的线程或发送信号给其他进程。</p>
<h2 id="39-3实验程序编写"><a href="#39-3实验程序编写" class="headerlink" title="39.3实验程序编写"></a>39.3实验程序编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\30_interrupt\03_中断驱动例程。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中会打印申请的GPIO号和This is irq_handler。</p>
<p>iTOP-RK3568有 5 组 GPIO bank：GPIO0<del>GPIO4，每组又以 A0</del>A7, B0<del>B7, C0</del>C7, D0~D7 作为编号区分,常用以下公式计算引脚：</p>
<ul>
<li>GPIO pin脚计算公式：pin <strong>&#x3D;</strong> bank ***** 32 <strong>+</strong> number   &#x2F;&#x2F;bank为组号，number为小组编号</li>
<li>GPIO 小组编号计算公式：number <strong>&#x3D;</strong> group ***** 8 <strong>+</strong> X</li>
</ul>
<p>LCD触摸屏对应的中断引脚标号为TP_INT_L_GPIO3_A5，对应的计算过程如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bank = <span class="number">3</span>;       <span class="comment">//GPIO3_A5=&gt; 3, bank ∈ [0,4]</span></span><br><span class="line">group = <span class="number">0</span>;      <span class="comment">//GPIO3_A5 =&gt; 0, group ∈ &#123;(A=0), (B=1), (C=2), (D=3)&#125;</span></span><br><span class="line">X = <span class="number">5</span>;         <span class="comment">//GPIO3_A5 =&gt; 5, X ∈ [0,7]</span></span><br><span class="line">number = group * <span class="number">8</span> + X = <span class="number">0</span> * <span class="number">8</span> + <span class="number">5</span> =<span class="number">5</span></span><br><span class="line">pin = bank*<span class="number">32</span> + number= <span class="number">3</span> * <span class="number">32</span> + <span class="number">5</span> = <span class="number">101</span>;</span><br></pre></td></tr></table></figure>

<p> 得到中断引脚的引脚标号后，下面开始编写对应的驱动程序，编写完成的interrupt.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN 101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_irq_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt occurred on GPIO %d\n&quot;</span>, GPIO_PIN);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;This is irq_handler\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">interrupt_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> irq_num;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Initializing GPIO Interrupt Driver\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将GPIO引脚映射到中断号</span></span><br><span class="line">    irq_num = gpio_to_irq(GPIO_PIN);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;GPIO %d mapped to IRQ %d\n&quot;</span>, GPIO_PIN, irq_num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求中断</span></span><br><span class="line">    <span class="keyword">if</span> (request_irq(irq_num, gpio_irq_handler, IRQF_TRIGGER_RISING, <span class="string">&quot;irq_test&quot;</span>, <span class="literal">NULL</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to request IRQ %d\n&quot;</span>, irq_num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求中断失败，释放GPIO引脚</span></span><br><span class="line">        gpio_free(GPIO_PIN);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">interrupt_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;                                                                                                                                                                                                                                     </span><br><span class="line">    <span class="type">int</span> irq_num = gpio_to_irq(GPIO_PIN);</span><br><span class="line">    <span class="comment">// 释放中断</span></span><br><span class="line">    free_irq(irq_num, <span class="literal">NULL</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;GPIO Interrupt Driver exited successfully\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(interrupt_init);</span><br><span class="line">module_exit(interrupt_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="39-4-运行测试"><a href="#39-4-运行测试" class="headerlink" title="39.4 运行测试"></a>39.4 运行测试</h2><h3 id="39-4-1-编译驱动程序"><a href="#39-4-1-编译驱动程序" class="headerlink" title="39.4.1 编译驱动程序"></a>39.4.1 编译驱动程序</h3><p>在上一小节中的timer_mod.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m +=interrupt.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图(图 39-9)所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps39.jpg" alt="img"> </p>
<p>图 39-9</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 39-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps40.jpg" alt="img"> </p>
<p>图 39-10</p>
<p>编译完生成 interrupt.ko目标文件，如下图（图 39-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps41.jpg" alt="img"> </p>
<p>图 39-11</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="39-4-2-运行测试"><a href="#39-4-2-运行测试" class="headerlink" title="39.4.2 运行测试"></a>39.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 39-12）所示：</p>
<p>insmod interrupt.ko </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps42.jpg" alt="img"> </p>
<p>图 39-12</p>
<p>可以看到驱动加载之后，打印了“Initializing GPIO Interrupt Driver”表示程序加载成功了，在后面又打印了gpio映射后的中断请求号为113，然后触摸LCD屏，触发中断服务程序，打印如下图（图 39-13）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps43.jpg" alt="img"> </p>
<p>图 39-13</p>
<p>成功打印了GPIO的引脚编号以及“This is irq_handler”，证明编写的驱动程序没有问题，最后使用以下命令卸载相应的驱动，如下图（图 39-14）所示：</p>
<p>rmmod  interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps44.jpg" alt="img"> </p>
<p>图 39-14</p>
<h1 id="第40章-中断申请流程"><a href="#第40章-中断申请流程" class="headerlink" title="第40章 中断申请流程"></a>第40章 中断申请流程</h1><p>在上一章中，我们简单的认识了一下中断以及中断子系统框架，最后编写了中断申请和中断服务函数的实验，大家会发现虽然前面讲解的只是点很多，但实际用起来只需要两三个函数就可以了，但中断的具体申请流程是怎样的呢，大家就不是很清楚了，在本章节将带领大家研究中断的申请流程。</p>
<h2 id="40-1-request-irq函数"><a href="#40-1-request-irq函数" class="headerlink" title="40.1 request_irq函数"></a>40.1 request_irq函数</h2><p>中断申请使用的是request_irq 函数，它用于请求一个中断号（IRQ number）并将一个中断处理程序与该中断关联起来，它定义在内核源码的“&#x2F;include&#x2F;linux&#x2F;interrupt.h”目录下，具体定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">request_irq(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span><br><span class="line">	    <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的内容可以得到request_irq()函数实际上是调用了request_threaded_irq()函数来完成中断申请的过程。request_threaded_irq()函数提供了线程化的中断处理方式，可以在中断上下文中执行中断处理函数。</p>
<h2 id="40-2-request-threaded-irq函数"><a href="#40-2-request-threaded-irq函数" class="headerlink" title="40.2 request_threaded_irq函数"></a>40.2 request_threaded_irq函数</h2><p>request_threaded_irq 函数是 Linux 内核提供的一个功能强大的函数，用于请求分配一个中断，并将中断处理程序与该中断关联起来。该函数的主要作用是在系统中注册中断处理函数，以响应对应中断的发生。以下是 request_threaded_irq 函数的功能和作用的详细介绍：</p>
<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em>****中断请求****：request_threaded_irq 函数用于请求一个中断。它会向内核注册对应中断号的中断处理函数，并为该中断分配必要的资源。中断号是标识特定硬件中断的唯一标识符。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em>****中断处理函数关联：****通过 handler 参数，将中断处理函数与中断号关联起来。中断处理函数是一个预定义的函数，用于处理中断事件。当中断发生时，内核将调用该函数来处理中断事件。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em>****线程化中断处理****：request_threaded_irq 函数还支持使用线程化中断处理函数。通过指定 thread_fn 参数，可以在一个内核线程上下文中异步执行较长时间的中断处理或延迟敏感的工作。这有助于避免在中断上下文中阻塞时间过长。</p>
<p><em><strong>*（*</strong></em><em><strong>*4*</strong></em><em><strong>*）*</strong></em>****中断属性设置：****通过 irqflags 参数，可以设置中断处理的各种属性和标志。例如，可以指定中断触发方式（上升沿、下降沿、边沿触发等）、中断类型（边沿触发中断、电平触发中断等）以及其他特定的中断行为。</p>
<p><em><strong>*（*</strong></em><em><strong>*5*</strong></em><em><strong>*）*</strong></em>****设备标识关联：****通过 dev_id 参数，可以将中断处理与特定设备关联起来。这样可以在中断处理函数中访问与设备相关的数据。设备标识符可以是指向设备结构体或其他与设备相关的数据的指针。</p>
<p><em><strong>*（*</strong></em><em><strong>*6*</strong></em><em><strong>*）*</strong></em>****错误处理：****request_threaded_irq 函数会返回一个整数值，用于指示中断请求的结果。如果中断请求成功，返回值为 0；如果中断请求失败，则返回一个负数错误代码，表示失败的原因。</p>
<p>request_threaded_irq 函数定义在内核源码目录下的“&#x2F;kernel&#x2F;irq&#x2F;manage.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span>  <span class="comment">// 中断动作结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span>  <span class="comment">// 中断描述符指针</span></span><br><span class="line">	<span class="type">int</span> retval;  <span class="comment">// 返回值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查中断号是否为未连接状态</span></span><br><span class="line">	<span class="keyword">if</span> (irq == IRQ_NOTCONNECTED)</span><br><span class="line">		<span class="keyword">return</span> -ENOTCONN;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查中断标志的有效性</span></span><br><span class="line">	<span class="keyword">if</span> (((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id) ||</span><br><span class="line">	    (!(irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)) ||</span><br><span class="line">	    ((irqflags &amp; IRQF_NO_SUSPEND) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据中断号获取中断描述符</span></span><br><span class="line">	desc = irq_to_desc(irq);</span><br><span class="line">	<span class="keyword">if</span> (!desc)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查中断设置是否可以进行中断请求，以及是否为每个CPU分配唯一设备ID</span></span><br><span class="line">	<span class="keyword">if</span> (!irq_settings_can_request(desc) ||</span><br><span class="line">	    WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果未指定中断处理函数，则使用默认的主处理函数</span></span><br><span class="line">	<span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!thread_fn)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		handler = irq_default_primary_handler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配并初始化中断动作数据结构</span></span><br><span class="line">	action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!action)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	action-&gt;handler = handler;  <span class="comment">// 中断处理函数</span></span><br><span class="line">	action-&gt;thread_fn = thread_fn;  <span class="comment">// 线程处理函数</span></span><br><span class="line">	action-&gt;flags = irqflags;  <span class="comment">// 中断标志</span></span><br><span class="line">	action-&gt;name = devname;  <span class="comment">// 设备名称</span></span><br><span class="line">	action-&gt;dev_id = dev_id;  <span class="comment">// 设备ID</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取中断的电源管理引用计数</span></span><br><span class="line">	retval = irq_chip_pm_get(&amp;desc-&gt;irq_data);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		kfree(action);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置中断并将中断动作与中断描述符关联</span></span><br><span class="line">	retval = __setup_irq(irq, desc, action);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理中断设置失败的情况</span></span><br><span class="line">	<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">		irq_chip_pm_put(&amp;desc-&gt;irq_data);</span><br><span class="line">		kfree(action-&gt;secondary);</span><br><span class="line">		kfree(action);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SHIRQ_FIXME</span></span><br><span class="line">	<span class="keyword">if</span> (!retval &amp;&amp; (irqflags &amp; IRQF_SHARED)) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">		disable_irq(irq);</span><br><span class="line">		local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">		handler(irq, dev_id);</span><br><span class="line"></span><br><span class="line">		local_irq_restore(flags);</span><br><span class="line">		enable_irq(irq);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> retval;  <span class="comment">// 返回设置中断的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em><em><strong>*声明变量和初始化：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span>  <span class="comment">// 中断动作结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span>  <span class="comment">// 中断描述符指针</span></span><br><span class="line"><span class="type">int</span> retval;  <span class="comment">// 返回值</span></span><br></pre></td></tr></table></figure>

<p>第5行：用于存储中断动作结构体的指针（会在下面的小节进行详细的讲解）。</p>
<p>第6行：用于存储中断描述符的指针（会在下面的小节进行详细的讲解）。</p>
<p>第7行：用于存储函数的返回值。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em><em><strong>*参数检查：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查中断号是否为未连接状态</span></span><br><span class="line"><span class="keyword">if</span> (irq == IRQ_NOTCONNECTED)</span><br><span class="line">	<span class="keyword">return</span> -ENOTCONN;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查中断标志的有效性</span></span><br><span class="line"><span class="keyword">if</span> (((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id) ||</span><br><span class="line">    (!(irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)) ||</span><br><span class="line">    ((irqflags &amp; IRQF_NO_SUSPEND) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)))</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br></pre></td></tr></table></figure>

<p>第10行：检查中断号是否为未连接状态（IRQ_NOTCONNECTED）。</p>
<p>第14-17行：检查中断标志的有效性，包括共享标志与设备ID的关联性，条件挂起标志的有效性，以及无挂起标志与条件挂起标志的关联性。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em><em><strong>*获取中断描述符：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据中断号获取中断描述符</span></span><br><span class="line">desc = irq_to_desc(irq);</span><br><span class="line"><span class="keyword">if</span> (!desc)</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br></pre></td></tr></table></figure>

<p>第20行：根据中断号调用irq_to_desc函数获取对应的中断描述符。</p>
<p>第21行：如果获取中断描述符失败，则返回-EINVAL表示无效的参数。</p>
<p><em><strong>*（*</strong></em><em><strong>*4*</strong></em><em><strong>*）*</strong></em><em><strong>*检查中断设置：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查中断设置是否可以进行中断请求，以及是否为每个CPU分配唯一设备ID</span></span><br><span class="line"><span class="keyword">if</span> (!irq_settings_can_request(desc) ||</span><br><span class="line">    WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br></pre></td></tr></table></figure>

<p>第25-26行：检查中断设置是否可以进行中断请求，以及是否为每个CPU分配唯一设备ID。如果中断设置不满足要求，则返回-EINVAL表示无效的参数。</p>
<p><em><strong>*（*</strong></em><em><strong>*5*</strong></em><em><strong>*）*</strong></em><em><strong>*处理中断处理函数和线程处理函数：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果未指定中断处理函数，则使用默认的主处理函数</span></span><br><span class="line"><span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!thread_fn)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	handler = irq_default_primary_handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果未指定中断处理函数，则将默认的主处理函数（irq_default_primary_handler）赋值给handler。</p>
<p><em><strong>*（*</strong></em><em><strong>*6*</strong></em><em><strong>*）*</strong></em><em><strong>*分配并初始化中断动作数据结构：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配并初始化中断动作数据结构</span></span><br><span class="line">action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!action)</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">action-&gt;handler = handler;  <span class="comment">// 中断处理函数</span></span><br><span class="line">action-&gt;thread_fn = thread_fn;  <span class="comment">// 线程处理函数</span></span><br><span class="line">action-&gt;flags = irqflags;  <span class="comment">// 中断标志</span></span><br><span class="line">action-&gt;name = devname;  <span class="comment">// 设备名称</span></span><br><span class="line">action-&gt;dev_id = dev_id;  <span class="comment">// 设备ID</span></span><br></pre></td></tr></table></figure>

<p>第37行：调用kzalloc函数分配内存空间，大小为sizeof(struct irqaction)。	</p>
<p>第38行：如果分配内存失败，则返回-ENOMEM表示内存不足。</p>
<p>第41行-第45行：将中断处理函数、线程处理函数、中断标志、设备名称和设备ID赋值给相应的字段。</p>
<p><em><strong>*（*</strong></em><em><strong>*7*</strong></em><em><strong>*）*</strong></em><em><strong>*获取中断的电源管理引用计数：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取中断的电源管理引用计数</span></span><br><span class="line">retval = irq_chip_pm_get(&amp;desc-&gt;irq_data);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	kfree(action);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第48行：调用irq_chip_pm_get函数获取中断的电源管理引用计数。</p>
<p>第49行：如果获取失败，则释放先前分配的内存空间，并返回获取失败的结果。</p>
<p><em><strong>*（*</strong></em><em><strong>*8*</strong></em><em><strong>*）*</strong></em><em><strong>*设置中断并关联中断动作：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置中断并将中断动作与中断描述符关联</span></span><br><span class="line">retval = __setup_irq(irq, desc, action);</span><br></pre></td></tr></table></figure>

<p>第55行：调用__setup_irq函数设置中断并将中断动作与中断描述符关联。</p>
<p><em><strong>*（*</strong></em><em><strong>*9*</strong></em><em><strong>*）*</strong></em><em><strong>*处理设置中断失败的情况：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理中断设置失败的情况</span></span><br><span class="line"><span class="keyword">if</span> (retval) &#123;</span><br><span class="line">	irq_chip_pm_put(&amp;desc-&gt;irq_data);</span><br><span class="line">	kfree(action-&gt;secondary);</span><br><span class="line">	kfree(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第59行：调用irq_chip_pm_put函数释放中断的电源管理引用计数。</p>
<p>第60行：释放次要中断动作的内存空间。</p>
<p>第61行：释放中断动作的内存空间。</p>
<p><em><strong>*（*</strong></em><em><strong>*10*</strong></em><em><strong>*）*</strong></em><em><strong>*可选的共享中断处理：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SHIRQ_FIXME</span></span><br><span class="line">	<span class="keyword">if</span> (!retval &amp;&amp; (irqflags &amp; IRQF_SHARED)) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">		disable_irq(irq);</span><br><span class="line">		local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">		handler(irq, dev_id);</span><br><span class="line"></span><br><span class="line">		local_irq_restore(flags);</span><br><span class="line">		enable_irq(irq);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>第65行：如果设置中断成功且中断标志中包含共享标志（IRQF_SHARED），则执行以下操作：</p>
<p>第68行：禁用中断。</p>
<p>第69行：保存当前中断状态并禁用本地中断。</p>
<p>第70行：调用主处理函数处理中断。</p>
<p>第73行：恢复中断状态。</p>
<p>第74行）：重新使能中断。</p>
<h2 id="40-3-irq-desc结构体"><a href="#40-3-irq-desc结构体" class="headerlink" title="40.3 irq_desc结构体"></a>40.3 irq_desc结构体</h2><p>irq_desc 结构体是 Linux 内核中用于描述中断的数据结构之一。每个硬件中断都有一个对应的 irq_desc 实例，它用于记录与该中断相关的各种信息和状态。该结构体的主要功能是管理中断处理函数、中断行为以及与中断处理相关的其他数据。</p>
<p>以下是 irq_desc 结构体的主要作用和功能：</p>
<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em>****中断处理函数管理****：irq_desc 结构体中的 handle_irq 字段保存中断处理函数的指针。当硬件触发中断时，内核会调用该函数来处理中断事件。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em>****中断行为管理：****irq_desc 结构体中的 action 字段是一个指向中断行为列表的指针。中断行为是一组回调函数，用于注册、注销和处理与中断相关的事件。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em>****中断统计信息：****irq_desc 结构体中的 kstat_irqs 字段是一个指向中断统计信息的指针。该信息用于记录中断事件的发生次数和处理情况，可以帮助分析中断的性能和行为。</p>
<p><em><strong>*（*</strong></em><em><strong>*4*</strong></em><em><strong>*）*</strong></em>****中断数据管理：****irq_desc 结构体中的 irq_data 字段保存了与中断相关的数据，如中断号、中断类型等。这些数据用于识别和管理中断。</p>
<p><em><strong>*（*</strong></em><em><strong>*5*</strong></em><em><strong>*）*</strong></em>****通用中断数据管理：****irq_desc 结构体中的 irq_common_data 字段保存了与中断处理相关的通用数据，如中断控制器、中断屏蔽等。这些数据用于处理和控制中断的行为。</p>
<p><em><strong>*（*</strong></em><em><strong>*6*</strong></em><em><strong>*）*</strong></em>****中断状态管理：****irq_desc 结构体中的其他字段用于管理中断的状态，如嵌套中断禁用计数、唤醒使能计数等。这些状态信息帮助内核跟踪和管理中断的状态变化。</p>
<p>通过使用 irq_desc 结构体，内核可以有效地管理和处理系统中的硬件中断。它提供了一个统一的接口，用于注册和处理中断处理函数、管理中断行为，并提供了必要的信息和数据结构来监视和控制中断的行为和状态。</p>
<p> irq_desc 结构体定义在内核源码目录的“include&#x2F;linux&#x2F;irqdesc.h”文件，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_common_data</span>	<span class="title">irq_common_data</span>;</span>    <span class="comment">/* 通用中断数据 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span>		<span class="title">irq_data</span>;</span>  <span class="comment">/* 中断数据 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> __percpu	*kstat_irqs;  <span class="comment">/* 中断统计信息 */</span></span><br><span class="line">	<span class="type">irq_flow_handler_t</span>	handle_irq;    <span class="comment">/* 中断处理函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IRQ_PREFLOW_FASTEOI</span></span><br><span class="line">	<span class="type">irq_preflow_handler_t</span>	preflow_handler;   <span class="comment">/* 预处理中断处理函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">action</span>;</span>   * IRQ action <span class="built_in">list</span> */</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		status_use_accessors;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		core_internal_state__do_not_mess_with_it; <span class="comment">/* 内核内部状态标志位，请勿修改 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		depth;     <span class="comment">/* 嵌套中断禁用计数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		wake_depth;   <span class="comment">/* 嵌套唤醒使能计数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		tot_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq_count;     <span class="comment">/* 用于检测损坏的IRQ计数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		last_unhandled;  <span class="comment">/* 未处理计数的老化计时器 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irqs_unhandled; <span class="comment">/* 未处理的中断计数 */</span></span><br><span class="line">	<span class="type">atomic_t</span>		threads_handled;   <span class="comment">/* 处理中断的线程计数 */</span></span><br><span class="line">	<span class="type">int</span>			threads_handled_last;</span><br><span class="line">	<span class="type">raw_spinlock_t</span>		lock;        <span class="comment">/* 自旋锁 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>		*<span class="title">percpu_enabled</span>;</span>      <span class="comment">/* 指向每个CPU的使能掩码 */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>	*<span class="title">percpu_affinity</span>;</span>     <span class="comment">/* 指向每个CPU亲和性掩码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>	*<span class="title">affinity_hint</span>;</span>   <span class="comment">/* CPU亲和性提示 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_affinity_notify</span> *<span class="title">affinity_notify</span>;</span>  <span class="comment">/* CPU亲和性变化通知 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PENDING_IRQ</span></span><br><span class="line">	<span class="type">cpumask_var_t</span>		pending_mask;          <span class="comment">/* 等待处理的中断掩码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		threads_oneshot;</span><br><span class="line">	<span class="type">atomic_t</span>		threads_active;    <span class="comment">/* 活动中的线程计数 */</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span>       wait_for_threads;   <span class="comment">/* 等待线程的等待队列头 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		nr_actions;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		no_suspend_depth;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		cond_suspend_depth;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		force_resume_depth;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>	*<span class="title">dir</span>;</span>       <span class="comment">/* proc文件系统目录项 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_IRQ_DEBUGFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>		*<span class="title">debugfs_file</span>;</span>    <span class="comment">/* 调试文件系统文件 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*dev_name;           <span class="comment">/* 设备名称 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSE_IRQ</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		<span class="title">kobj</span>;</span>  <span class="comment">/* 内核对象 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">request_mutex</span>;</span>   <span class="comment">/* 请求互斥锁 */</span></span><br><span class="line">	<span class="type">int</span>			parent_irq;     <span class="comment">/* 父中断号 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span>        <span class="comment">/* 模块拥有者 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*name;          <span class="comment">/* 中断名称 */</span></span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<p>在irq_desc 结构体中最重要的就是 action 字段，会在下个小节对action 字段进行详细的讲解。</p>
<h2 id="40-4-irqaction-结构体"><a href="#40-4-irqaction-结构体" class="headerlink" title="40.4 irqaction 结构体"></a>40.4 irqaction 结构体</h2><p>irqaction 结构体是 Linux 内核中用于描述中断行为的数据结构之一。它用于定义中断处理过程中的回调函数和相关属性。irqaction 结构体的主要功能是管理与特定中断相关的行为和处理函数。</p>
<p>以下是 irqaction 结构体的主要作用和功能：</p>
<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em>****中断处理函数管理****：irqaction 结构体中的 handler 字段保存中断处理函数的指针。该函数在中断发生时被调用，用于处理中断事件。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em>****中断处理标志管理：****irqaction 结构体中的 flags 字段用于指定中断处理的各种属性和标志。这些标志控制中断处理的行为，例如触发方式、中断类型等。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em>****设备标识符管理****：irqaction 结构体中的 dev_id 字段用于保存与中断处理相关的设备标识符。它可以是指向设备结构体或其他与设备相关的数据的指针，用于将中断处理与特定设备关联起来。</p>
<p><em><strong>*（*</strong></em><em><strong>*4*</strong></em><em><strong>*）*</strong></em>****中断行为链表管理****：irqaction 结构体中的 next 字段是一个指向下一个 irqaction 结构体的指针，用于构建中断行为的链表。这样可以将多个中断处理函数链接在一起，以便在中断发生时按顺序调用它们。</p>
<p>通过使用 irqaction 结构体，内核可以灵活地定义和管理与特定中断相关的行为和处理函数。它提供了一个统一的接口，用于注册和注销中断处理函数，并提供了必要的属性和数据结构来控制中断处理的行为和顺序。</p>
<p>irqaction 体定义在内核源码的“include&#x2F;linux&#x2F;interrupt.h”文件中如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> &#123;</span></span><br><span class="line">	<span class="type">irq_handler_t</span>		handler;          <span class="comment">// 中断处理函数</span></span><br><span class="line">	<span class="type">void</span>			*dev_id;          <span class="comment">// 设备ID</span></span><br><span class="line">	<span class="type">void</span> __percpu		*percpu_dev_id;   <span class="comment">// 每个CPU的设备ID</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">next</span>;</span>            <span class="comment">// 下一个中断动作结构体</span></span><br><span class="line">	<span class="type">irq_handler_t</span>		thread_fn;        <span class="comment">// 线程处理函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">thread</span>;</span>          <span class="comment">// 线程结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">secondary</span>;</span>       <span class="comment">// 次要中断动作结构体</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq;              <span class="comment">// 中断号</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		flags;            <span class="comment">// 中断标志</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		thread_flags;     <span class="comment">// 线程标志</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		thread_mask;      <span class="comment">// 线程掩码</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*name;            <span class="comment">// 设备名称</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>	*<span class="title">dir</span>;</span>             <span class="comment">// proc文件系统目录项指针</span></span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<h1 id="第41章-中断下文tasklet实验"><a href="#第41章-中断下文tasklet实验" class="headerlink" title="第41章 中断下文tasklet实验"></a>第41章 中断下文tasklet实验</h1><p>在上一个章节中，我们申请GPIO中断，使用的是request_irq,但是request_irq绑定的中断服务程序指的是中断上文。在之前的中断视频中讲解了：中断分为俩个部分——中断上文和中断下文。本章节我们来学习中断下文的一种实现方式——tasklet。</p>
<h2 id="41-1-什么是tasklet"><a href="#41-1-什么是tasklet" class="headerlink" title="41.1 什么是tasklet"></a>41.1 什么是tasklet</h2><p>在Linux内核中，tasklet是一种特殊的软中断机制，被广泛用于处理中断下文相关的任务。它是一种常见且有效的方法，在多核处理系统上可以避免并发问题。Tasklet绑定的函数在同一时间只能在一个CPU上运行，因此不会出现并发冲突。然而，需要注意的是，tasklet绑定的函数中不能调用可能导致休眠的函数，否则可能引起内核异常。</p>
<p>在Linux内核中，tasklet结构体的定义位于include&#x2F;linux&#x2F;interrupt.h头文件中。其原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> state;</span><br><span class="line">    <span class="type">atomic_t</span> count;</span><br><span class="line">    <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet_t</span>;</span></span><br></pre></td></tr></table></figure>

<p>tasklet_struct结构体包含以下成员：</p>
<p>l next:指向下一个tasklet的指针，用于形成链表结构，以便内核中可以同时管理多个tasklet。</p>
<p>l state:表示tasklet的当前状态。</p>
<p>l count:用于引用计数，用于确保tasklet在多个地方调度或取消调度时的正确处理。</p>
<p>l func:指向tasklet绑定的函数的指针，该函数将在tasklet执行时被调用。</p>
<p>l data:传递给tasklet绑定函数的参数</p>
<p>此外，为了方便，还定义了tasklet_t类型作为struct tasklet_struct的别名。这样我们可以使用tasklet_t来声明tasklet变量，而不是直接使用struct tasklet_struct。</p>
<h2 id="41-2-tasklet相关接口函数"><a href="#41-2-tasklet相关接口函数" class="headerlink" title="41.2 tasklet相关接口函数"></a>41.2 tasklet相关接口函数</h2><h3 id="41-2-1-静态初始化函数"><a href="#41-2-1-静态初始化函数" class="headerlink" title="41.2.1 静态初始化函数"></a>41.2.1 静态初始化函数</h3><p>在Linux内核中，有一个用于静态初始化tasklet的宏函数：DECLARE_TASKLET。这个宏函数可以帮助我们更方便地进行tasklet的静态初始化。</p>
<p>宏函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，name是tasklet的名称，func是tasklet的处理函数，data是传递给处理函数的参数。</p>
<p>初始化状态为使能状态。</p>
<p>如果tasklet初始化函数为非使能状态，使用以下宏定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，name是tasklet的名称，func是tasklet的处理函数，data是传递给处理函数的参数。</p>
<p>初始化状态为非使能状态。</p>
<p>下面是一个示例，展示了如何使用DECLARE_TASKLET宏函数进行tasklet的静态初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，my_tasklet是tasklet的名称，my_tasklet_handler是tasklet的处理函数，0是传递给处理函数的参数。但是需要注意的是，使用DECLARE_TASKLET静态初始化的tasklet无法在运行时动态销毁，因此在不需要tasklet时，应该避免使用此方法。如果需要在运行时销毁tasklet，应使用tasklet_init和tasklet_kill函数进行动态初始化和销毁，接下来我们来学习动态初始化函数。</p>
<h3 id="41-2-2-动态初始化函数"><a href="#41-2-2-动态初始化函数" class="headerlink" title="41.2.2 动态初始化函数"></a>41.2.2 动态初始化函数</h3><p> 在Linux内核中，可以使用tasklet_init函数对tasklet进行动态初始化。该函数原型为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，t是指向tasklet结构体的指针，func是tasklet的处理函数，data是传递给处理函数的参数</p>
<p>以下是一个示例，tasklet_init函数进行动态初始化如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在示例中，我们首先定义了my_tasklet_handler作为tasklet的处理函数。然后，声明了一个名为my_tasklet的tasklet结构体。接下来，通过调用tasklet_init函数，进行动态初始化。</p>
<p>通过使用tasklet_init函数，我们可以在运行时动态创建和初始化tasklet。这样，我们可以根据需要灵活地管理和控制tasklet的生命周期。在不再需要tasklet时，可以使用tasklet_kill函数进行销毁，以释放相关资源。</p>
<h3 id="41-2-3-关闭函数"><a href="#41-2-3-关闭函数" class="headerlink" title="41.2.3 关闭函数"></a>41.2.3 关闭函数</h3><p>在Linux内核中，可以使用tasklet_disabled函数来关闭一个已经初始化的tasklet。该函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，t是指向tasklet结构体的指针。</p>
<p>以下是一个示例，使用tasklet_disable函数来关闭tasklet。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先定义了my_tasklet_handler作为tasklet的处理函数。然后，声明了一个名为my_tasklet的tasklet结构体，并使用tasklet_init函数对其进行初始化。最后，通过调用tasklet_disable函数，我们关闭了my_tasklet。</p>
<p>关闭tasklet后，即使调用tasklet_schedule函数触发tasklet，tasklet的处理函数也不会再被执行。这可以用于临时暂停或停止tasklet的执行，直到再次启用（通过调用tasklet_enable函数）。</p>
<p>需要注意的是，关闭tasklet并不会销毁tasklet结构体，因此可以随时通过调用tasklet_enable函数重新启用tasklet，或者调用tasklet_kill函数来销毁tasklet。</p>
<h3 id="41-2-4-使能函数"><a href="#41-2-4-使能函数" class="headerlink" title="41.2.4 使能函数"></a>41.2.4 使能函数</h3><p>在Linux内核中，可以使用tasklet_enable函数来使能（启用）一个已经初始化的tasklet。该函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，t是指向tasklet结构体的指针。</p>
<p>以下是一个示例，展示如何使用tasklet_enable函数来使能tasklet：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先定义了my_tasklet_handler作为tasklet的处理函数。然后，声明了一个名为my_tasklet的tasklet结构体，并使用tasklet_init函数对其进行初始化。最后，通过调用tasklet_enable函数，我们使能（启用）了my_tasklet。</p>
<p>使能tasklet后，如果调用tasklet_schedule函数触发tasklet，则tasklet的处理函数将会被执行。这样，tasklet将开始按计划执行其处理逻辑。</p>
<p>需要注意的是，使能tasklet并不会自动触发tasklet的执行，而是通过调用tasklet_schedule函数来触发。同时，可以使用tasklet_disable函数来临时暂停或停止tasklet的执行。如果需要永久停止tasklet的执行并释放相关资源，则应调用tasklet_kill函数来销毁tasklet。</p>
<h3 id="41-2-5-调度函数"><a href="#41-2-5-调度函数" class="headerlink" title="41.2.5 调度函数"></a>41.2.5 调度函数</h3><p>在Linux内核中，可以使用tasklet_schedule函数来调度（触发）一个已经初始化的tasklet执行。该函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	其中，t是指向tasklet结构体的指针。</p>
<p>以下是一个示例，展示如何使用tasklet_schedule函数来调度tasklet执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先定义了my_tasklet_handler作为tasklet的处理函数。然后，声明了一个名为my_tasklet的tasklet结构体，并使用tasklet_init函数对其进行初始化。最后，通过调用tasklet_schedule函数，我们调度（触发）了my_tasklet的执行。</p>
<p>需要注意的是，调度tasklet只是将tasklet标记为需要执行，并不会立即执行tasklet的处理函数。实际的执行时间取决于内核的调度和处理机制。</p>
<h3 id="41-2-6-销毁函数"><a href="#41-2-6-销毁函数" class="headerlink" title="41.2.6 销毁函数"></a>41.2.6 销毁函数</h3><p>​	在Linux内核中，可以使用tasklet_kill函数来销毁一个已经初始化的tasklet，释放相关资源。该函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，t是指向tasklet结构体的指针。</p>
<p>以下是一个示例，展示如何使用tasklet_kill函数来销毁tasklet：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先定义了my_tasklet_handler作为tasklet的处理函数。然后，声明了一个名为my_tasklet的tasklet结构体，并使用tasklet_init函数对其进行初始化。最后，通过调用tasklet_kill函数，我们销毁了my_tasklet。</p>
<p>调用tasklet_kill函数会释放tasklet所占用的资源，并将tasklet标记为无效。因此，销毁后的tasklet不能再被使用。</p>
<p>需要注意的是，在销毁tasklet之前，应该确保该tasklet已经被停止（通过调用tasklet_disable函数）。否则，销毁一个正在执行的tasklet可能导致内核崩溃或其他错误。</p>
<p>一旦销毁了tasklet，如果需要再次使用tasklet，需要重新进行初始化（通过调用tasklet_init函数）。在下一小节中我们将使用上述tasklet函数相关接口函数进行相应的实验。</p>
<h2 id="41-3-实验程序的编写"><a href="#41-3-实验程序的编写" class="headerlink" title="41.3 实验程序的编写"></a>41.3 实验程序的编写</h2><h3 id="41-3-1-驱动程序编写"><a href="#41-3-1-驱动程序编写" class="headerlink" title="41.3.1 驱动程序编写"></a>41.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\32_tasklet\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中调度中断下文tasklet处理函数，打印“This id test_interrupt”和“<em><strong>*data is*</strong></em> ****1****”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO转换为中断号，并使用request_irq函数请求中断，然后对tasklet进行初始化。在中断处理函数中，我们调度tasklet执行，使得当中断触发时，tasklet会被调度执行。在模块退出函数中，我们释放中断资源，并使能tasklet销毁tasklet。</p>
<p>编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="41-4-运行测试"><a href="#41-4-运行测试" class="headerlink" title="41.4 运行测试"></a>41.4 运行测试</h2><h3 id="41-4-1-编译驱动程序"><a href="#41-4-1-编译驱动程序" class="headerlink" title="41.4.1 编译驱动程序"></a>41.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图41-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps45.jpg" alt="img"></p>
<p>图 41-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图41-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps46.jpg" alt="img"></p>
<p>图 41-2</p>
<p>编译完生成interrupt.ko目标文件，如下图（图41-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps47.jpg" alt="img"></p>
<p>图 41-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="41-4-2-运行测试"><a href="#41-4-2-运行测试" class="headerlink" title="41.4.2 运行测试"></a>41.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 41-4）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps48.jpg" alt="img"> </p>
<p>图 41-4</p>
<p>看到驱动加载之后，可以看到申请的中断号（113）被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，触发中断服务程序，打印如下图（41-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps49.jpg" alt="img"></p>
<p>图 41-5</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”和tasklet处理函数中添加的打印“data is 1”，说明成功执行了中断下文tasklet处理函数。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图图 41-6）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps50.jpg" alt="img"></p>
<p>图 41-6</p>
<p>之前的理论章节我们强调说tasklet函数中不能调用休眠的函数，在此我们在上述驱动实验的基础上实验一下，驱动文件中添加休眠函数，如下（图 41-7）所示：</p>
<p>​	<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps51.png" alt="img"></p>
<p>图 41-7</p>
<p>同理，进行编译驱动模块，卸载掉之前的驱动模块后，加载新编译的驱动模块，如下图（图 41-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps52.jpg" alt="img"></p>
<p>图 41-8</p>
<p>然后用手触摸连接的LVDS 7寸屏幕，打印如下图（41-9）所示，内核会崩溃。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps53.jpg" alt="img"></p>
<p>图 41-9</p>
<p>至此，中断下文tasklet实验就完成了。</p>
<h1 id="第42章-软中断实验"><a href="#第42章-软中断实验" class="headerlink" title="第42章 软中断实验"></a>第42章 软中断实验</h1><p>在上个章节我们学习了中断下文的一种实验方式——tasklet，本章节我们来学习中断下文的另一种实现方式——软中断。软中断的资料有限，对应的中断号不多，一般用在网络设备驱动，块设备驱动当中。这时本章节要学习的软中断就闪耀登场了。</p>
<h2 id="42-1-什么是软中断"><a href="#42-1-什么是软中断" class="headerlink" title="42.1 什么是软中断"></a>42.1 什么是软中断</h2><p>打开Linux源码linux_sdk&#x2F;kernel&#x2F;include&#x2F;linux&#x2F;interrupt.h文件，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上代码定义了一个枚举类型，用于标识软中断的不同类型或优先级。每个枚举常量对应一个特定的软中断类型。</p>
<p>以下是每个枚举常量的含义：</p>
<p>HI_SOFTIRQ：高优先级软中断</p>
<p>TIMER_SOFTIRQ：定时器软中断</p>
<p>NET_TX_SOFTIRQ：网络传输发送软中断</p>
<p>NET_RX_SOFTIRQ：网络传输接收软中断</p>
<p>BLOCK_SOFTIRQ：块设备软中断</p>
<p>IRQ_POLL_SOFTIRQ：中断轮询软中断</p>
<p>TASKLET_SOFTIRQ：任务软中断</p>
<p>SCHED_SOFTIRQ：调度软中断</p>
<p>HRTIMER_SOFTIRQ, &#x2F;* Unused, but kept as tools rely on the numbering. Sigh! *&#x2F;</p>
<p>RCU_SOFTIRQ,   &#x2F;* Preferable RCU should always be the last softirq *&#x2F;</p>
<p>NR_SOFTIRQS：表示软中断的总数，用于指示软中断类型的数据</p>
<p>中断号的优先级越小，代表优先级越高。在驱动代码中，我们可以使用Linux驱动代码中上述的软中断，当然我们也可以自己添加软中断。我们添加一个自定义的软中断，如下所示，TEST_SOFTIRQ为自定义添加的软中断。</p>
<p>enum</p>
<p>{</p>
<p>​	HI_SOFTIRQ&#x3D;0,</p>
<p>​	TIMER_SOFTIRQ,</p>
<p>​	NET_TX_SOFTIRQ,</p>
<p>​	NET_RX_SOFTIRQ,</p>
<p>​	BLOCK_SOFTIRQ,</p>
<p>​	IRQ_POLL_SOFTIRQ,</p>
<p>​	TASKLET_SOFTIRQ,</p>
<p>​	SCHED_SOFTIRQ,</p>
<p>​	HRTIMER_SOFTIRQ, &#x2F;* Unused, but kept as tools rely on the</p>
<p>​			  numbering. Sigh! *&#x2F;</p>
<p>​	RCU_SOFTIRQ,   &#x2F;* Preferable RCU should always be the last softirq *&#x2F;</p>
<p>​	TEST_SOFTIRQ, &#x2F;&#x2F;添加的自定义软中断</p>
<p>​	NR_SOFTIRQS</p>
<p>};</p>
<p>这里要注意：尽管我们添加一个自定义的软中断非常简单，但是Linux内核的开发者并不希望我们这样去做，如果我们要用软中断，建议使用tasklet。虽然Linux内核开发者不建议自定义软中断，但是我们抱着学习的态度，了解学习下软中断还是很有必要的。上述修改之后，重新编译内核源码，接下来我们来学习下软中断的使用方法。</p>
<h2 id="42-2-软中断接口函数"><a href="#42-2-软中断接口函数" class="headerlink" title="42.2 软中断接口函数"></a>42.2 软中断接口函数</h2><p>软中断的接口函数非常简单，介绍如下所示：</p>
<p>1 注册软中断，使用open_softirq函数，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数的参数如下所示：</p>
<p>nr: 软中断的编号或优先级。它是一个整数，表示要注册的软中断的标识符。</p>
<p>action: 指向一个函数的指针，这个函数将作为软中断的处理程序。该函数接受一个struct softirq_action类型的参数。</p>
<p>2 触发软中断，使用 raise_softirq函数，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数的参数如下所示：</p>
<p>nr: 软中断的编号或优先级。它是一个整数，表示要注册的软中断的标识符。</p>
<p>3 在禁用硬件中断的情况下，触发软中断使用raise_softirq_irqoff函数，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数的参数如下所示：</p>
<p>nr: 软中断的编号或优先级。它是一个整数，表示要注册的软中断的标识符。</p>
<p>在下一小节中将使用上述软中断API进行相应的实验。</p>
<h2 id="42-3-实验程序的编写"><a href="#42-3-实验程序的编写" class="headerlink" title="42.3 实验程序的编写"></a>42.3 实验程序的编写</h2><h3 id="42-3-1-驱动程序编写"><a href="#42-3-1-驱动程序编写" class="headerlink" title="42.3.1 驱动程序编写"></a>42.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\33_softirq\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中触发软中断，打印“This id test_interrupt”和“****This is testsoft_func****”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO转换为中断号，并使用request_irq函数请求中断，然后注册软中断函数。在中断处理函数中，我们触发软中断，使得当中断触发时，软中断处理函数会被调度执行。</p>
<p>接下来我们编写驱动代码，使用软中断来实现中断的下半部分。编写完成的interrupt.c代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="42-4-运行测试"><a href="#42-4-运行测试" class="headerlink" title="42.4 运行测试"></a>42.4 运行测试</h2><h3 id="42-4-1-编译驱动程序"><a href="#42-4-1-编译驱动程序" class="headerlink" title="42.4.1 编译驱动程序"></a>42.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图42-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps54.jpg" alt="img"></p>
<p>图 42-1</p>
<p>然后使用命令“make”进行驱动的编译，编译如下图（图42-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps55.jpg" alt="img"></p>
<p>图 42-2</p>
<p>上图中提示open_softirq和raise_softirq没有被定义，但是为什么还会提示这样的错误呢？</p>
<p>这是因为Linux内核开发者不希望驱动工程师擅自在枚举类型中添加软中断。我们将这俩个函数导出到符号表，修改linux_sdk&#x2F;kernel&#x2F;kernel&#x2F;softirq.c，修改内容如下（图42-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps56.jpg" alt="img"></p>
<p>图42-3</p>
<p>修改完成后，重新编译内核源码，编译源码通过后，再次编译驱动模块，如下图（图 42-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps57.jpg" alt="img"></p>
<p>图 42-4</p>
<p>编译完生成interrupt.ko目标文件，如下图（图42-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps58.jpg" alt="img"></p>
<p>图 42-5</p>
<h3 id="42-4-2-运行测试"><a href="#42-4-2-运行测试" class="headerlink" title="42.4.2 运行测试"></a>42.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图42-6）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps59.jpg" alt="img"></p>
<p>图42-6</p>
<p>驱动加载成功之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，触发中断服务程序，打印如下图（42-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps60.jpg" alt="img"></p>
<p>图 42-7</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”和软中断处理函数中添加的打印“This is testsoft_func”</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图42-8）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps61.jpg" alt="img"></p>
<p>图 42-8</p>
<p>至此，软中断实验就完成了。</p>
<h1 id="第43章-特殊的软中断tasklet分析实验"><a href="#第43章-特殊的软中断tasklet分析实验" class="headerlink" title="第43章 特殊的软中断tasklet分析实验"></a>第43章 特殊的软中断tasklet分析实验</h1><p>Tasklet是Linux内核中的一种软中断机制，它可以被看作是一种轻量级的延迟处理机制。它是通过软中断控制结构来实现的，因此也被称为软中断。本章节我们来从代码层面分析一下为什么tasklet是一个特殊的软中断呢？</p>
<p>软中断处理函数的定义内核源码kernel&#x2F;kernel&#x2F;softirq.c文件中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面开始对上述代码详细解释：</p>
<p>l for_each_possible_cpu(cpu)：遍历每个可能的CPU。在多核系统中，此循环用于初始化每个CPU的tasklet_vec和tasklet_hi_vec。</p>
<p>l per_cpu(tasklet_vec, cpu).tail &#x3D; &amp;per_cpu(tasklet_vec, cpu).head;：将每个CPU的tasklet_vec的tail指针设置为对应的head指针的初始位置。这样做是为了确保tasklet_vec的初始状态是空的。</p>
<p>l per_cpu(tasklet_hi_vec, cpu).tail &#x3D; &amp;per_cpu(tasklet_hi_vec, cpu).head;：将每个CPU的tasklet_hi_vec的tail指针设置为对应的head指针的初始位置。这样做是为了确保tasklet_hi_vec的初始状态是空的。</p>
<p>l open_softirq(TASKLET_SOFTIRQ, tasklet_action);：注册TASKLET_SOFTIRQ软中断，并指定对应的处理函数为tasklet_action。这样，在TASKLET_SOFTIRQ被触发时，将会调用tasklet_action函数来处理相应的任务。</p>
<p>l open_softirq(HI_SOFTIRQ, tasklet_hi_action);：注册HI_SOFTIRQ软中断，并指定对应的处理函数为tasklet_hi_action。这样，在HI_SOFTIRQ被触发时，将会调用tasklet_hi_action函数来处理相应的任务。</p>
<p>在执行__init softirq_init函数时，会触发TASKLET_SOFTIRQ，然后会调用tasklet_action函数，tasklet_action函数如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述函数中调用了tasklet_action_common函数，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>tasklet_action_common函数，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>在上面的代码中，tasklet_action_common()函数对任务链表中的每个tasklet进行处理。它首先禁用本地中断，获取任务链表头指针，清空任务链表，并重新设置尾指针。然后它循环遍历任务链表，对每个tasklet进行处理。如果tasklet的锁获取成功，并且计数器为0，它将执行tasklet的处理函数，并清除状态标志位。如果锁获取失败或计数不为0，它将tasklet添加到任务链表的尾部，并触发指定的软中断。最后，它启用本地中断，完成任务处理过程。</p>
<p>那么tasklet在什么时候加到链表里面的呢？tasklet是通__tasklet_schedule_common()函数加入到链表中的。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过上述代码，__tasklet_schedule_common()函数将tasklet成功添加到链表的末尾。当软中断被触发时，系统会遍历链表并处理每个tasklet。因此，在添加到链表后，tasklet将在适当的时机被系统调度和执行。</p>
<p>经过上述分析，所以说tasklet是一个特殊的软中断。</p>
<p>内核开发者不希望我们去添加软中断的软中断号，更希望我们使用tasklet。那么tasklet相比自己添加软中断有哪些优点和缺点呢？</p>
<p>使用Tasklet相比自己添加软中断有一些优点和缺点。以下是它们的比较：</p>
<p>优点：</p>
<p>\1. 简化的接口和编程模型：Tasklet提供了一个简单的接口和编程模型，使得在内核中处理延迟工作变得更加容易。相比自己添加软中断，Tasklet提供了更高级的抽象。</p>
<p>\2. 低延迟：Tasklet在软中断上下文中执行，避免了内核线程的上下文切换开销，因此具有较低的延迟。这对于需要快速响应的延迟敏感任务非常重要。</p>
<p>\3. 自适应调度：Tasklet具有自适应调度的特性，当多个Tasklet处于等待状态时，内核会合并它们以减少不必要的上下文切换。这种调度机制可以提高系统的效率。</p>
<p>缺点：</p>
<p>\1. 无法处理长时间运行的任务：Tasklet适用于短时间运行的延迟工作，如果需要处理长时间运行的任务，可能会阻塞其他任务的执行。对于较长的操作，可能需要使用工作队列或内核线程来处理。</p>
<p>\2. 缺乏灵活性：Tasklet的执行受限于软中断的上下文，不适用于所有类型的延迟工作。某些情况下，可能需要更灵活的调度和执行机制，这时自定义软中断可能更加适合。</p>
<p>\3. 资源限制：Tasklet的数量是有限的，系统中可用的Tasklet数量取决于架构和内核配置。如果需要大量的延迟工作处理，可能会受到Tasklet数量的限制。</p>
<p>综上所述，Tasklet提供了一种简单且低延迟的延迟工作处理机制，适用于短时间运行的任务和对响应时间敏感的场景。然而，对于长时间运行的任务和需要更灵活调度的情况，自定义软中断可能更合适。在选择使用Tasklet还是自定义软中断时，需要根据具体的需求和系统特性进行权衡和决策。</p>
<h1 id="第44章-共享工作队列实验"><a href="#第44章-共享工作队列实验" class="headerlink" title="第44章 共享工作队列实验"></a>第44章 共享工作队列实验</h1><p>在上个章节我们学习了中断下文的一种实验方式——软中断，本章节我们来学习中断下文的另一种实现方式——工作队列。工作队列是操作系统中管理和调度异步任务执行的一种机制，接下来开始学习工作队列吧。	</p>
<h2 id="44-1-什么是工作队列"><a href="#44-1-什么是工作队列" class="headerlink" title="44.1 什么是工作队列"></a>44.1 什么是工作队列</h2><p>工作队列是实现中断下半部分的机制之一，是一种用于管理任务的数据结构或机制。它通常用于多线程，多进程或分布式系统中，用于协调和分配****待处理的任务*<em><strong>给</strong></em>*可用的工作线程或工作进程****。</p>
<p>工作队列的基本原理是将需要执行的任务按顺序排列在队列中，并提供一组工作线程或者工作进程来处理队列中的任务。当有新的任务到达时，它们会被添加到队列的末尾，工作线程或工作进程从队列的头部获取任务，并执行相应的处理操作。</p>
<p>工作队列和之前学习的tasklet有什么不同呢？tasklet也是实现中断下半部分的机制之一。他们最主要的区别是tasklet不能休眠，而工作队列是可以休眠的，所以tasklet可以用来处理比较耗时间的事情，而工作队列可以处理更耗时间的事情。</p>
<p>工作队列将工作推后以后，会交给内核线程去执行。Linux在启动过程中会创建一个工作者内核线程，这个线程创建以后处于sleep状态。当有工作需要处理的时候，会唤醒这个线程去处理工作。</p>
<p>在内核中，工作队列包括共享工作队列和自定义工作队列这俩种类型。这两种类型的工作队列具有不同的特点和用途。</p>
<p>1  共享队列是由****内核管理****的全局工作队列，用于处理内核中一些系统级任务。共享工作队列是内核中一个默认工作队列，可以由多个内核组件和驱动程序共享使用。</p>
<p>2 自定义工作队列是由****内核或驱动程序创建的****特定工作队列，用于处理特定的任务。自定义工作队列通常与特定的内核模块或驱动程序相关联，用于执行该模块或驱动程序相关的任务。</p>
<p> 本章节我们先来学习共享工作队列相关的知识。 </p>
<p>在Linux 内核中，使用 work_struct 结构体表示一个工作项，这些工作组织成工作队列，工作队列使用 workqueue_struct 结构体表示，如下图所示，流水线相当于工作队列，流水线上一个个等待处理的物料相当于一个个工作。机器相当于内核线程或进程。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps62.jpg" alt="img"> </p>
<p>图 44-1</p>
<p>work_struct 结构体表示一个工作项，定义在include&#x2F;linux&#x2F;workqueue.h中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		</p>
<h2 id="44-2-工作队列相关接口函数"><a href="#44-2-工作队列相关接口函数" class="headerlink" title="44.2 工作队列相关接口函数"></a>44.2 工作队列相关接口函数</h2><h3 id="44-2-1-初始化函数"><a href="#44-2-1-初始化函数" class="headerlink" title="44.2.1 初始化函数"></a>44.2.1 初始化函数</h3><p>在实际的驱动开发中，我们只需要定义工作项(work_struct)即可，关于工作队列和工作者线程我们基本不用去管。简单创建工作很简单，直接定义一个 work_struct 结构体变量即可，然后使用 INIT_WORK 宏来初始化工作，INIT_WORK 宏定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>INIT_WORK 宏接受两个参数：_work 和 _func，分别表示要初始化的工作项和工作项的处理函数。</p>
<p>也可以使用 DECLARE_WORK 宏一次性完成工作的创建和初始化，宏定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数n 表示定义的工作(work_struct)，f 表示工作对应的处理函数。</p>
<h3 id="44-2-2-调度-取消调度工作队列函数"><a href="#44-2-2-调度-取消调度工作队列函数" class="headerlink" title="44.2.2 调度&#x2F;取消调度工作队列函数"></a>44.2.2 调度&#x2F;取消调度工作队列函数</h3><p>和 tasklet 一样，工作也是需要调度才能运行的，工作的调度函数为 schedule_work，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数是指向工作项的指针。这个函数作用是将工作项提交到工作队列中，并请求调度器在合适的时机执行工作项。该函数会返回一个布尔值，表示工作项是否成功被提交到工作队列。</p>
<p>如果想要取消该工作项的调度，使用以下函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数是指向工作项的指针。这个函数的作用是取消该工作项的调度。如果工作项已经在工作队列中，它将被从队列中移除。如果工作项已经在工作队列中，它将被从队列中移除，并等待工作项执行完成。函数返回一个布尔值，表示工作项是否成功取消。</p>
<h2 id="44-3-实验程序的编写"><a href="#44-3-实验程序的编写" class="headerlink" title="44.3 实验程序的编写"></a>44.3 实验程序的编写</h2><h3 id="44-3-1-驱动程序编写"><a href="#44-3-1-驱动程序编写" class="headerlink" title="44.3.1 驱动程序编写"></a>44.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\34_workqueue\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中提交工作项到共享工作队列中，打印“This id test_interrupt”和“****This is test_work****”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO转换为中断号，并使用request_irq函数请求中断，然后初始化工作项。当中断被触发时，中断处理函数被调用，并将工作项提交到共享工作队列中，最终由工作项处理函数异步执行。编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="44-4-运行测试"><a href="#44-4-运行测试" class="headerlink" title="44.4 运行测试"></a>44.4 运行测试</h2><h3 id="44-4-1-编译驱动程序"><a href="#44-4-1-编译驱动程序" class="headerlink" title="44.4.1 编译驱动程序"></a>44.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图44-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps63.jpg" alt="img"></p>
<p>图 44-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图44-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps64.jpg" alt="img"> </p>
<p>图 44-3</p>
<p>编译完生成interrupt.ko目标文件，如下图（图44-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps65.jpg" alt="img"> </p>
<p>图 44-4</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="44-4-2-运行测试"><a href="#44-4-2-运行测试" class="headerlink" title="44.4.2 运行测试"></a>44.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图44-5）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps66.jpg" alt="img"></p>
<p>图44-5</p>
<p>加载驱动之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（44-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps67.jpg" alt="img"></p>
<p>图 44-6</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”被多次打印，说明触发了好几次中断上文，那么中断上文会多次调度中断下文，所以也会打印工作项处理函数中添加的打印“This is test_work”。但是为什么只会打印俩次“This is test_work”呢？这是因为在中断上文调度工作项处理函数之后，内核没有来得及去执行工作项处理函数，没有执行相当于无效操作，有效的执行则打印了俩次“This is test_work”。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图44-7）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps68.jpg" alt="img"></p>
<p>图 44-7</p>
<p>至此，共享工作队列实验就完成了。	</p>
<h1 id="第45章-自定义工作队列实验"><a href="#第45章-自定义工作队列实验" class="headerlink" title="第45章 自定义工作队列实验"></a>第45章 自定义工作队列实验</h1><p>在上一章节中对工作队列以及共享工作队列知识进行了学习，并使用共享队列进行了实验。共享队列是由****内核管理*<em><strong>的全局工作队列，自定义工作队列是由</strong></em>*内核或驱动程序创建的****特定工作队列，用于处理特定的任务。下面就让我们一起来进行自定义工作队列的学习吧。</p>
<h2 id="45-1-工作队列相关结构体"><a href="#45-1-工作队列相关结构体" class="headerlink" title="45.1 工作队列相关结构体"></a>45.1 工作队列相关结构体</h2><p>在Linux内核中，结构体struct work_struct描述的是要延迟执行的工作项，定义在include&#x2F;linux&#x2F;workqueue.h当中，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>  这些工作组织成工作队列，内核使用struct workqueue_struct结构体描述一个工作队列，定义在include&#x2F;linux&#x2F;workqueue.h 当中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="45-2-工作队列相关接口函数"><a href="#45-2-工作队列相关接口函数" class="headerlink" title="45.2 工作队列相关接口函数"></a>45.2 工作队列相关接口函数</h2><p>在Linux内核中，create_workqueue函数用于创建一个工作队列，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数name是创建的工作队列的名字。使用这个函数可以给每个CPU都创建一个CPU相关的工作队列。创建成功返回一个struct workqueue_struct类型指针，创建失败返回NULL。</p>
<p>如果只给一个CPU创建一个CPU相关的工作队列，使用以下函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数name是创建的工作队列的名字。使用这个函数只会给一个CPU创建一个CPU相关的工作队列。创建成功之后返回一个struct workqueue_struct 类型指针，创建失败返回NULL。 </p>
<p>当工作队列创建好之后，需要将要延迟执行的工作项放在工作队列上，调度工作队列，使用queue_work_on函数，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>  该函数有三个参数，第一个参数是一个整数cpu，第二个参数是一个指向struct workqueue_struct的指针wq，第三个参数是一个指向struct work_struct的指针work。</p>
<p>该函数的返回类型是布尔值，表示是否成功调度工作队列。 queue_work_on函数还有其他变种，比如queue_work函数，这里略过，其实思路是一致的，用于将定义好的工作项立即添加到工作队列中，并在工作队列可用时立即执行。</p>
<p>​	如果要取消一个已经调度的工作，使用函数bool cancel_work_sync，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>  函数的作用是取消一个已经调度的工作，如果被取消的工作已经正在执行，则会等待他执行完成再返回。</p>
<p>在Linux 内核中，使用flush_workqueue函数将刷新该工作队列中所有已提交但未执行的工作项。函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p> 该函数参数是一个指向struct workqueue_struct类型的指针wq。函数的作用是刷新工作队列，告诉内核尽快处理工作队列上的工作。</p>
<p>如果要删除自定义的工作队列，使用destroy_workqueue函数，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>  该函数参数是一个指向struct workqueue_struct类型的指针wq。</p>
<p>在下一小节中将使用上述工作队列API函数进行相应的实验。</p>
<h2 id="45-3-实验程序的编写"><a href="#45-3-实验程序的编写" class="headerlink" title="45.3 实验程序的编写"></a>45.3 实验程序的编写</h2><h3 id="45-3-1-驱动程序编写"><a href="#45-3-1-驱动程序编写" class="headerlink" title="45.3.1 驱动程序编写"></a>45.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\35_workqueue_share\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中提交工作项到工作队列中，打印“This id test_interrupt”和“****This is test_work****”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO转换为中断号，并使用request_irq函数请求中断，然后创建自定义工作队列，初始化工作项。当中断被触发时，中断处理函数被调用，并将工作项提交到自定义工作队列中，最终由工作项处理函数异步执行。编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="45-4-运行测试"><a href="#45-4-运行测试" class="headerlink" title="45.4 运行测试"></a>45.4 运行测试</h2><h3 id="45-4-1-编译驱动程序"><a href="#45-4-1-编译驱动程序" class="headerlink" title="45.4.1 编译驱动程序"></a>45.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图45-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps69.jpg" alt="img"> </p>
<p>图 45-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图45-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps70.jpg" alt="img"></p>
<p>图 45-2</p>
<p>编译完生成interrupt.ko目标文件，如下图（图45-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps71.jpg" alt="img"></p>
<p>图 45-3</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="45-4-2-运行测试"><a href="#45-4-2-运行测试" class="headerlink" title="45.4.2 运行测试"></a>45.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图45-4）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps72.jpg" alt="img"> </p>
<p>图45-4</p>
<p>加载驱动之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（45-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps73.jpg" alt="img"> </p>
<p>图 45-5</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”被打印了俩次，说明触发了2次中断上文，那么中断上文会调度2次中断下文，所以也会打印2次工作项处理函数中添加的打印“This is test_work”。</p>
<p>在按屏幕之后，立即输入ps -aux|grep test_workqueue命令可以查看自己创建的工作队列，如下（图 45-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps74.jpg" alt="img"></p>
<p>图 45-6</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图45-7）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps75.jpg" alt="img"></p>
<p>图 45-7</p>
<p>至此，自定义工作队列实验就完成了。</p>
<h1 id="第46章-延迟工作实验"><a href="#第46章-延迟工作实验" class="headerlink" title="第46章 延迟工作实验"></a>第46章 延迟工作实验</h1><p>在之前的章节中，我们学习了共享工作队列和自定义工作队列，为了更形象地理解学习，将流水线比作工作队列，流水线上一个个等待处理的物料比作一个个工作。机器比作内核线程或进程。本章节我们即将学习的延迟工作，可以类比为将物料延迟一定时间，再放到生产线上加工。延迟工作不仅可以在自定义工作队列中实现 也可以在共享工作队列上实现。现在，我们对延迟工作有了一个感性的认识，接下来详细的学习下延迟工作吧。</p>
<h2 id="46-1-什么是延迟工作"><a href="#46-1-什么是延迟工作" class="headerlink" title="46.1 什么是延迟工作"></a>46.1 什么是延迟工作</h2><p>延迟工作是一种将工作的执行延迟到稍后时间点进行处理的技术。通常情况下，当某个任务需要花费较长时间，不需要立即执行或需要按时执行时，延迟工作就会派上用场。</p>
<p>延迟工作的基本思想是将任务放入一个队列中，然后由后台的工作进程会任务调度程序来处理队列中的任务。任务可以在指定的延迟时间后执行，也可以根据优先级，任务类型或者其他条件进行排序和处理。</p>
<p>延迟工作在许多应用场景中都非常有用，尤其是在需要处理大量任务，提供系统性能和可靠性的情况下。以下是一些常用的应用场景：</p>
<p>1 延迟工作常用于处理那些需要花费较长时间的任务，比如发送电子邮件，处理图像等。通过将这些任务放入队列中并延迟执行，可以避免阻塞应用程序的主线程，提高系统的响应速度。</p>
<p>2 延迟工作可以用来执行定时任务，比如定时备份数据库，通过将任务设置为在未来的某个时间点执行，提高系统的可靠性和效率。</p>
<p>为了方便大家理解，我们再举个形象点的例子，比如说开发板上的按键，现在我们想通过驱动程序读取按键的状态，那么只需要读取这个按键所连接的GPIO的状态就可以了。</p>
<p>理想型的按键电压变化过程如图（图 46-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps76.png" alt="img"> </p>
<p>图 46-1</p>
<p>在上图中，按键没有按下的时候按键值为 1，当按键在 t1 时刻按键被按下以后按键值就变为 0，这是最理想的状态。但是实际的按键是机械结构，加上刚按下去的一瞬间人手可能也有抖动，实际的按键电压变化过程如下图（图 46-2）所示：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\ksohtml17816\wps77.png" alt="img"> </p>
<p>图 46-2</p>
<p>在上图中，t1 时刻按键被按下，但是由于抖动的原因，直到 t2 时刻才稳定下来，t1 到t2 这段时间就是抖动。一般这段时间就是十几 ms 左右，从上图中可以看出在抖动期间会有多次触发，如果不消除这段抖动的话软件就会误判，本来按键就按下了一次，结果软件读取IO 值发现电平多次跳变以为按下了多次。所以我们需要跳过这段抖动时间再去读取按键的 IO值，也就是至少要在 t2 时刻以后再去读 IO 值。在之前的驱动视频中，我们使用了定时器来实现消抖。按键采用中断驱动方式，当按键按下以后触发按键中断，在按键中断中开启一个定时器，定时周期为 10ms，当定时时间到了以后就会触发定时器中断，最后在定时器中断处理函数中读取按键的值，如果按键值还是按下状态那就表示这是一次有效的按键。定时器按键消抖如下图（图 46-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps78.png" alt="img"> </p>
<p>图 46-3</p>
<p>在上图中t1<del>t3 这一段时间就是按键抖动，是需要消除的。设置按键为下降沿触发，因此会在 t1、t2 和 t3 这三个时刻会触发按键中断，每次进入中断处理函数都会重新开器定时器中断，所以会在 t1、t2 和 t3 这三个时刻开器定时器中断。但是 t1</del>t2 和 t2~t3 这两个时间段是小于我们设置的定时器中断周期(也就是消抖时间，比如 10ms)，所以虽然 t1 开启了定时器，但是定时器定时时间还没到呢 t2 时刻就重置了定时器，最终只有 t3 时刻开启的定时器能完整的完成整个定时周期并触发中断，我们就可以在中断处理函数里面做按键处理了，这就是定时器实现按键防抖的原理，Linux 里面的按键驱动用的就是这个原理！</p>
<p>除了使用定时器方式进行消抖，也可以使用本章节讲述的延迟工作。在中断下文中将工作延迟3秒之后，再去读GPIO电平状态。</p>
<p>在Linux内核中，使用struct delayed_work来描述延迟工作，定义在include&#x2F;linux&#x2F;workqueue.h当中，原型定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>struct delayed_work结构体包含了两个成员：</p>
<p>1  work：这是一个struct work_struct类型的成员，用于表示延迟工作的基本工作结构。struct work_struct是表示工作的常见数据结构，用于定义要执行的工作内容。</p>
<p>2  timer：这是一个struct timer_list类型的成员，用于管理延迟工作的定时器。struct timer_list是Linux内核中的定时器结构，用于设置延迟时间和触发工作执行的时机。</p>
<p>  使用struct delayed_work结构体，可以将需要执行的工作封装成一个延迟工作，并使用定时器来控制工作的延迟执行。通过设置定时器的延迟时间，可以指定工作在一定时间后执行。</p>
<p>接下来我们学习下延迟工作相关的接口函数吧。</p>
<h2 id="46-2-延迟工作相关接口函数"><a href="#46-2-延迟工作相关接口函数" class="headerlink" title="46.2 延迟工作相关接口函数"></a>46.2 延迟工作相关接口函数</h2><h3 id="46-2-1-初始化延迟工作函数"><a href="#46-2-1-初始化延迟工作函数" class="headerlink" title="46.2.1 初始化延迟工作函数"></a>46.2.1 初始化延迟工作函数</h3><p>静态定义并初始化延迟工作使用宏DECLARE_DELAYED_WORK，函数原型如下所示：	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用宏定义后，可以将上述代码简化为#define DECLARE_DELAYED_WORK(n,f)，n代表延迟工作的变量名，f是延迟工作的处理函数。</p>
<p>动态定义并初始化延迟工作使用宏INIT_DELAYED_WORK，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用宏定义后，可以将上述代码简化为#define INIT_DELAYED_WORK(_work, _func)， n代表延迟工作的变量名，f是延迟工作的处理函数。</p>
<h3 id="46-2-2-调度-取消调度-延迟工作函数"><a href="#46-2-2-调度-取消调度-延迟工作函数" class="headerlink" title="46.2.2 调度&#x2F;取消调度 延迟工作函数"></a>46.2.2 调度&#x2F;取消调度 延迟工作函数</h3><p>如果是在共享工作队列上调度延迟工作，使用以下函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数是一个内联函数，用于在给定的延迟时间后调度延迟工作执行。</p>
<p>函数参数dwork:是指向延迟工作的指针，即要被调度的延迟工作。</p>
<p>delay:表示延迟的时间长度，以内核时钟节拍数jiffies为单位。</p>
<p>如果是在自定义工作队列上调度延迟工作，使用以下函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数是一个内联函数，用于将延迟工作加入工作队列后在指定的延迟时间后执行。</p>
<p>函数参数wq是指向工作队列结构的指针，即要将延迟工作加入的目标工作队列。</p>
<p>dwork:指向延迟工作的指针，也就是要被加入工作队列的延迟工作。</p>
<p>delay: 表示延迟的时间长度，以内核时钟节拍数jiffies为单位。</p>
<p>如果要取消调度函数，使用以下函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数是一个外部声明的函数，用于取消延迟工作并等待其完成。dwork参数是指向延迟工作的指针，也就是要被取消的延迟工作。函数如果返回true，说明成功取消延迟工作并等待其完成。函数如果返回false，说明无法取消延迟工作或等待其完成。</p>
<p>在下一小节中将在自定义工作队列实验的基础上修改驱动，进行延迟工作实验。</p>
<h2 id="46-3-实验程序的编写"><a href="#46-3-实验程序的编写" class="headerlink" title="46.3 实验程序的编写"></a>46.3 实验程序的编写</h2><h3 id="46-3-1-驱动程序编写"><a href="#46-3-1-驱动程序编写" class="headerlink" title="46.3.1 驱动程序编写"></a>46.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\36_workqueue_delay\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中提交延迟工作项到工作队列中，打印“This id test_interrupt”，并延迟打印“****This is test_work****”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO转换为中断号，并使用request_irq函数请求中断，然后创建自定义工作队列，初始化延迟工作项。当中断被触发时，中断处理函数被调用，并将延迟工作项提交到自定义工作队列中，最终由工作项处理函数异步执行。编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="46-4-运行测试"><a href="#46-4-运行测试" class="headerlink" title="46.4 运行测试"></a>46.4 运行测试</h2><h3 id="46-4-1-编译驱动程序"><a href="#46-4-1-编译驱动程序" class="headerlink" title="46.4.1 编译驱动程序"></a>46.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图46-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps79.jpg" alt="img"></p>
<p>图 46-4</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图46-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps80.jpg" alt="img"></p>
<p>图46-5</p>
<p>编译完生成interrupt.ko目标文件，如下图（图46-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps81.jpg" alt="img"></p>
<p>图 46-6</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="46-4-2-运行测试"><a href="#46-4-2-运行测试" class="headerlink" title="46.4.2 运行测试"></a>46.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图46-7）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps82.jpg" alt="img"></p>
<p>图46-7</p>
<p>加载驱动之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（46-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps83.jpg" alt="img"></p>
<p>图46-8</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”被打印了多次，说明触发了多次中断上文，在4秒之后，打印工作项处理函数中的“This is test_work”。4秒之后打印“This is test_work”是因为调度延迟工作函数写了延迟3秒，再加上工作项处理函数中延迟了一秒，所以一共是4秒。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图46-9）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps84.jpg" alt="img"></p>
<p>图 46-9</p>
<p>至此，延迟工作实验就完成了。</p>
<h1 id="第47章-工作队列传参实验"><a href="#第47章-工作队列传参实验" class="headerlink" title="第47章 工作队列传参实验"></a>第47章 工作队列传参实验</h1><p>在41章节中，我们使用tasklet来实现中断下文，并使用tasklet给中断下文传参，如果我们使用工作队列来实现中断的下半部分，那么如何用工作队列给中断下文传参呢？本章节我们来一探究竟！</p>
<h2 id="47-1-工作队列传参"><a href="#47-1-工作队列传参" class="headerlink" title="47.1 工作队列传参"></a>47.1 工作队列传参</h2><p>在Linux内核的工作队列中，可以通过使用工作项的方式向工作队列传递参数。工作项是一个抽象的结构，可以用于封装需要执行的工作及其相关的参数。</p>
<p>首先我们定义工作项结构，如下所示，在结构体struct work_data中定义了需要传递给工作项处理函数的参数a和b，然后定义一个类型为struct work_data 的变量test_workqueue_work。</p>
<p>struct work_data {</p>
<p> struct work_struct test_work;</p>
<p> int a;</p>
<p> int b;</p>
<p>};  </p>
<p>struct work_data test_workqueue_work;</p>
<p>接下来在模块初始化函数interrupt_irq_init 中创建了一个工作队列test_workqueue 和一个工作项 test_workqueue_work。</p>
<p>test_workqueue &#x3D; create_workqueue(“test_workqueue”); &#x2F;&#x2F; 创建工作队列</p>
<p>INIT_WORK(&amp;test_workqueue_work.test_work, test_work); &#x2F;&#x2F; 初始化工作项</p>
<p>然后在模块初始化函数中，为工作项的参数 a 和 b 赋值。</p>
<p>test_workqueue_work.a &#x3D; 1;</p>
<p>test_workqueue_work.b &#x3D; 2;</p>
<p>当中断触发时，在中断处理函数 test_interrupt 中，通过调用 queue_work 函数将工作项 test_workqueue_work.test_work 提交到工作队列 test_workqueue 中。</p>
<p>queue_work(test_workqueue, &amp;test_workqueue_work.test_work);</p>
<p>然后工作项处理函数 test_work 定义了一个指针 pdata，将工作项转换为 struct work_data 结构，并通过该结构访问参数 a 和 b。如下所示：</p>
<p>void test_work(struct work_struct *work)</p>
<p>{</p>
<p> struct work_data *pdata;</p>
<p> pdata &#x3D; container_of(work, struct work_data, test_work);</p>
<p> printk(“a is %d\n”, pdata-&gt;a);</p>
<p> printk(“b is %d\n”, pdata-&gt;b);</p>
<p>}</p>
<p>这样，当工作队列被调度执行时，工作项处理函数test_work将能够访问到传递给工作项的参数a和b,并在内核日志中打印他们的值。</p>
<p>注意，工作项处理函数中的 container_of 宏用于从工作项结构的指针获取整个 struct work_data 结构的指针。这样可以通过指针偏移来访问工作项结构中的其他字段，例如参数 a 和 b。</p>
<p>详细的驱动代码编写见下一小节。</p>
<h2 id="47-2实验程序的编写"><a href="#47-2实验程序的编写" class="headerlink" title="47.2实验程序的编写"></a>47.2实验程序的编写</h2><h3 id="47-2-1-驱动程序编写"><a href="#47-2-1-驱动程序编写" class="headerlink" title="47.2.1 驱动程序编写"></a>47.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\37_workqueue_data\module。</p>
<p>编写完成的interrupt.c代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="47-3-运行测试"><a href="#47-3-运行测试" class="headerlink" title="47.3 运行测试"></a>47.3 运行测试</h2><h3 id="47-3-1-编译驱动程序"><a href="#47-3-1-编译驱动程序" class="headerlink" title="47.3.1 编译驱动程序"></a>47.3.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>.对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图47-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps85.jpg" alt="img"></p>
<p>图 47-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图47-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps86.jpg" alt="img"></p>
<p>图 47-2</p>
<p>编译完生成interrupt.ko目标文件，如下图（图47-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps87.jpg" alt="img"></p>
<p>图 47-3</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="47-3-2-运行测试"><a href="#47-3-2-运行测试" class="headerlink" title="47.3.2 运行测试"></a>47.3.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图47-4）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps88.jpg" alt="img"> </p>
<p>图47-4</p>
<p>驱动加载之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（47-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps89.jpg" alt="img"> </p>
<p>图 47-5</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”和传递给工作项的参数a和b的值。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图47-6）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps90.jpg" alt="img"> </p>
<p>图 47-6</p>
<p>至此，工作队列传参实验就完成了。</p>
<h1 id="第48章-并发管理工作队列实验"><a href="#第48章-并发管理工作队列实验" class="headerlink" title="第48章 并发管理工作队列实验"></a>第48章 并发管理工作队列实验</h1><p>在现代的软件开发中，我们常常面临着需要同时处理多个任务的挑战。这些任务可能是并行的、独立的，或者需要以某种顺序进行处理。为了高效地管理这些并发任务，我们需要一种有效的机制来协调它们的执行。这就是并发管理工作队列发挥作用的地方。本章节我们来学习并发管理工作队列。</p>
<h2 id="48-1工作队列的实现"><a href="#48-1工作队列的实现" class="headerlink" title="48.1工作队列的实现"></a>48.1工作队列的实现</h2><p>在44章节和45章节，我们学习了共享工作队列和自定义工作队列，在使用工作队列时，我们首先定义一个work结构体，然后将work添加到workqueue(工作队列)中，最后worker thread 执行workqueue。当工作队列中有新work产生时，工作线程（worker thread）会执行工作队列中每个work。当执行完结束的时候，worker thread会睡眠，等到新的中断产生，work再继续添加到工作队列，然后工作线程执行每个工作，周而复始。</p>
<p>在单核线程的系统中，通常会为每个 CPU（核心）初始化一个工作线程并关联一个工作队列。这种默认设置确保每个CPU都有一个专门的线程来处理与其绑定的工作队列上的工作项。如下图（48-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps91.jpg" alt="img"> </p>
<p>图 48-1</p>
<p>在多核线程系统中，工作队列的设计与单核线程系统有所不同。在多核线程系统中，通常会存在多个工作队列，每个工作队列与一个工作线程（Worker Thread）绑定。这样可以充分利用多个核心的并行处理能力。如下图（48-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps92.jpg" alt="img"></p>
<p>图 48-2</p>
<p>当有新的工作项产生时，系统需要决定将其分配给哪个工作队列。一种常见的策略是使用负载均衡算法，根据工作队列的负载情况来平衡分配工作项，以避免某个工作队列过载而导致性能下降。每个工作队列独立管理自己的工作项。当有新的工作项添加到工作队列时，工作线程会从其关联的工作队列中获取待执行的工作项，并执行相应的处理函数。在多核线程系统中，多个工作线程可以同时执行各自绑定的工作队列中的工作项。这样可以实现并行处理，提高系统的整体性能和响应速度。</p>
<p>了解了工作队列是如何实现的，接下来我们看看传统的工作队列有什么弊端呢？</p>
<h2 id="48-2-workqueue队列弊端"><a href="#48-2-workqueue队列弊端" class="headerlink" title="48.2 workqueue队列弊端"></a>48.2 workqueue队列弊端</h2><p>假如说有三个work放到了同一个工作队列上，接下来CPU会启动工作线程去执行这三个work，如下图（48-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps93.jpg" alt="img"> </p>
<p>图 48-3</p>
<p>在上图中，工作项w0、w1、w2被排队到同一个CPU上的绑定工作队列上。w0工作项执行的时候，先工作 5毫秒，然后睡觉10毫秒，然后再工作CPU 5毫秒，然后完成。工作项w1和w2都是工作5ms，然后睡眠10 ms，然后完成。传统工作队列的弊端如下所示：</p>
<p>1 在工作项w0 工作甚至是睡眠时，工作项w1 w2是排队等待的，在繁忙的系统中，工作队列可能会积累大量的待处理工作项，导致任务调度的延迟，这可能会影响系统的响应性能，并增加工作项的处理时间。</p>
<p>2 在工作队列中，不同的工作项可能具有不同的处理时间和资源需求。如果工作项的处理时间差异很大，一些工作线程可能会一直忙于处理长时间的工作项，而其他工作线程则处于空闲状态，导致资源利用不均衡。</p>
<p>3 在多线程环境下，多个工作线程同时访问和修改工作队列可能会导致竞争条件的发生。为了确保数据的一致性和正确性，需要采用适当的同步机制，如锁或原子操作，来保护共享数据，但这可能会引入额外的同步开销。</p>
<p>4 工作队列通常按照先进先出（FIFO）的方式处理工作项，缺乏对工作项优先级的细粒度控制。在某些场景下，可能需要根据工作项的重要性或紧急程度进行优先级调度，而工作队列本身无法提供这种级别的优先级控制。</p>
<p>5 当工作线程从工作队列中获取工作项并执行时，可能需要频繁地进行上下文切换，将处理器的执行上下文从一个线程切换到另一个线程。这种上下文切换开销可能会影响系统的性能和效率。</p>
<h2 id="48-2-什么是并发管理工作队列"><a href="#48-2-什么是并发管理工作队列" class="headerlink" title="48.2 什么是并发管理工作队列"></a>48.2 什么是并发管理工作队列</h2><p>通过上一小节的学习，我们认识到传统的工作队列无论是单核系统还是多核系统上都是有缺陷的。比如无法充分利用多核处理器的计算能力以及对于不同优先级的工作项无法提供公平的调度。为了解决这些问题，Con Kolivas提出了CMWQ调度算法。</p>
<p>CMWQ 全称是concurrency Managed Workqueue，意为并发管理工作队列。并发管理工作队列是一种并发编程模式，用于有效地管理和调度待执行的任务或工作项。它通常用于多线程或多进程环境中，以实现并发执行和提高系统的性能。CMWQ 工作实现如下图（48-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps94.jpg" alt="img"> </p>
<p>图 48-4</p>
<p>当我们需要在一个系统中同时处理多个任务或工作时，使用并发管理工作队列是一种有效的方式。</p>
<p>想象一下，你是一个餐厅的服务员，有很多顾客同时来到餐厅用餐。为了提高效率，你需要将顾客的点菜请求放到一个队列中，这就是工作队列。然后，你和其他服务员可以从队列中获取顾客的点菜请求，每个服务员独立地为顾客提供服务。通过这种方式，你们可以并发地处理多个顾客的点菜请求，而不需要等待上一个顾客点完菜再去处理下一个顾客的请求。每个服务员可以独立地从队列中获取任务，并根据需要执行相应的服务。这种独立获取任务的过程就是从工作队列中取出任务并执行的过程。</p>
<p>通过并发管理工作队列，你们能够更高效地处理顾客的点菜请求，提高服务的速度和质量。同时，这种方式也能够更好地利用你们的工作能力，因为每个服务员都可以独立处理任务，而不会相互干扰或等待。</p>
<p>总的来说，通过并发管理工作队列，我们可以同时处理多个任务或工作，提高系统的并发性和性能。每个任务独立地从队列中获取并执行，这种解耦使得整个系统更加高效、灵活，并且能够更好地应对多任务的需求。</p>
<h2 id="48-3-并发管理工作队列接口函数"><a href="#48-3-并发管理工作队列接口函数" class="headerlink" title="48.3 并发管理工作队列接口函数"></a>48.3 并发管理工作队列接口函数</h2><p>​	alloc_workqueue是Linux内核中的一个函数，用于创建和分配一个工作队列。工作队列是一种用于管理和调度工作项的机制，可用于实现并发处理和异步任务处理。alloc_workqueue函数的原型如下：</p>
<p>struct workqueue_struct *alloc_workqueue(const char *fmt, unsigned int flags, int max_active);</p>
<p>参数说明：</p>
<p>****fmt：****指定工作队列的名称格式。</p>
<p>****flags****：指定工作队列的标志，可以控制工作队列的行为和属性，如WQ_UNBOUND表示无绑定的工作队列，WQ_HIGHPRI表示高优先级的工作队列等。</p>
<p>****max_active****：指定工作队列中同时活跃的最大工作项数量。</p>
<p>函数返回一个指向工作队列结构体（struct workqueue_struct）的指针，或者返回NULL表示创建失败。</p>
<p>在下一小节中将使用上述API进行相应的实验。</p>
<h2 id="48-4-实验程序的编写"><a href="#48-4-实验程序的编写" class="headerlink" title="48.4 实验程序的编写"></a>48.4 实验程序的编写</h2><h3 id="45-4-1-驱动程序编写"><a href="#45-4-1-驱动程序编写" class="headerlink" title="45.4.1 驱动程序编写"></a>45.4.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\38_CMWQ\module。</p>
<p>本实验在35自定义工作队列实验的基础上进行修改，使用alloc_workqueue函数创建和分配一个工作队列。编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="48-5-运行测试"><a href="#48-5-运行测试" class="headerlink" title="48.5 运行测试"></a>48.5 运行测试</h2><h3 id="48-5-1-编译驱动程序"><a href="#48-5-1-编译驱动程序" class="headerlink" title="48.5.1 编译驱动程序"></a>48.5.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图48-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps95.jpg" alt="img"> </p>
<p>图 48-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图48-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps96.jpg" alt="img"></p>
<p>图 48-6</p>
<p>编译完生成interrupt.ko目标文件，如下图（图48-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps97.jpg" alt="img"> </p>
<p>图 48-7</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="48-5-2-运行测试"><a href="#48-5-2-运行测试" class="headerlink" title="48.5.2 运行测试"></a>48.5.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图48-8）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps98.jpg" alt="img"></p>
<p>图48-8</p>
<p>驱动加载之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（48-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps99.jpg" alt="img"></p>
<p>图 48-9</p>
<p>我们按一下屏幕，立即输入“ps -aux | grep test_workqueue”,可以看到工作线程，如下图（48-10）所示，u代表无绑定的工作队列。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps100.jpg" alt="img"></p>
<p>图 48-10</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图48-11）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps101.jpg" alt="img"></p>
<p>图 48-11</p>
<p>至此，并发管理工作队列实验就完成了。	</p>
<h1 id="第49章-中断线程化实验"><a href="#第49章-中断线程化实验" class="headerlink" title="第49章 中断线程化实验"></a>第49章 中断线程化实验</h1><p>中断线程化是实时Linux项目开发的一个新特性，目的是降低中断处理对系统实时延迟的影响。本章节我们来一项新技术——中断线程化。</p>
<h2 id="49-1什么是中断线程化"><a href="#49-1什么是中断线程化" class="headerlink" title="49.1什么是中断线程化"></a>49.1什么是中断线程化</h2><p>中断线程化是一种优化技术，用于提高多线程程序的性能。</p>
<p>想象一下，你正在做一项任务，但是总是被别人的打扰所中断，每次都要停下手头的工作去处理别人的事情。这样频繁的中断会让你的工作效率变低，因为你需要反复切换任务，无法专心做好自己的工作。</p>
<p>在多线程程序中，也存在类似的问题。有时硬件或其他事件会发出中断信号，打断正在执行的线程，需要切换到中断处理程序去处理这些事件。这种频繁的中断切换会导致额外的开销和延迟，影响程序的性能。</p>
<p>为了解决这个问题，中断线程化提出了一种优化方案。它将中断处理程序从主线程中独立出来，创建一个专门的线程来处理这些中断事件。这样，主线程就不再受到中断的干扰，可以专注于自己的工作，不再频繁地被打断。</p>
<p>中断线程化的核心思想是将中断处理和主线程的工作分开，让它们可以并行执行。中断线程负责处理中断事件，而主线程负责执行主要的工作任务。这样一来，不仅可以减少切换的开销，还可以提高整个程序的响应速度和性能。</p>
<p>需要注意的是，中断线程化还需要处理线程之间的同步和数据共享问题。因为中断线程和主线程可能会同时访问和修改共享的数据，所以需要合理地进行同步操作，确保数据的一致性和正确性。</p>
<p>总而言之，中断线程化是一种优化技术，通过将中断处理和主线程的工作分开，提高多线程程序的性能。让主线程不再频繁被中断，可以专注于自己的工作，从而提高程序的效率和响应速度。</p>
<p>中断线程化的处理仍然可以看作是将原来的中断上半部分和中断下半部分。上半部分还是用来处理紧急的事情，下半部分也是出路比较耗时的操作，但是下半部分会交给一个专门的内核线程来处理。这个内核线程只用于这个中断。当发生中断的时候，会唤醒这个内核线程，然后由这个内核线程来执行中断下半部分的函数。</p>
<h2 id="49-2-中断线程化接口函数"><a href="#49-2-中断线程化接口函数" class="headerlink" title="49.2 中断线程化接口函数"></a>49.2 中断线程化接口函数</h2><p>request_threaded_irq 是 Linux 内核中用于请求并注册一个线程化的中断处理函数的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p><em><strong>*参数说明*</strong></em></p>
<p>****irq****：中断号，表示要请求的中断线路。</p>
<p>****handler****：是在发生中断时首先要执行的处理程序，非常类似于顶半部，该函数最后会返回IRQ_WAKE_THREAD来唤醒中断，一般handler设为NULL，用系统提供的默认处理。</p>
<p>****thread_fn****：线程化的中断处理函数，非常类似于底半部。如果此处设置为NULL 则表示没有使用中断线程化。</p>
<p>****irqflags****：中断标志，用于指定中断的属性和行为。</p>
<p>****devname****：中断的名称，用于标识中断请求的设备。</p>
<p>****dev_id****：设备标识符，用于传递给中断处理函数的参数。</p>
<p><em><strong>*函数返回值*</strong></em></p>
<p>  函数返回一个整数值，表示中断请求的结果。如果中断请求成功，返回值为0，否则返回一个负数错误代码。</p>
<p>在下一小节中将使用上述API进行相应的实验，利用中断线程化相关知识来对共享工作队列实验进行优化。</p>
<h2 id="49-3-实验程序的编写"><a href="#49-3-实验程序的编写" class="headerlink" title="49.3 实验程序的编写"></a>49.3 实验程序的编写</h2><h3 id="49-3-1-驱动程序编写"><a href="#49-3-1-驱动程序编写" class="headerlink" title="49.3.1 驱动程序编写"></a>49.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\39_request_threaded_irq\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中提交工作项到工作队列中，打印“This id test_interrupt”，并打印“****This is test_work****”。</p>
<p>我们要实现一个简单的中断处理的例子，用于展示中断的顶半部和底半部处理的概念，并通过线程化的工作队列实现了底半部的延时处理。编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="49-4-运行测试"><a href="#49-4-运行测试" class="headerlink" title="49.4 运行测试"></a>49.4 运行测试</h2><h3 id="49-4-1-编译驱动程序"><a href="#49-4-1-编译驱动程序" class="headerlink" title="49.4.1 编译驱动程序"></a>49.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图49-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps102.jpg" alt="img"></p>
<p>图 49-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图49-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps103.jpg" alt="img"></p>
<p>图 49-2</p>
<p>编译完生成interrupt.ko目标文件，如下图（图49-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps104.jpg" alt="img"></p>
<p>图 49-3</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="49-4-2-运行测试"><a href="#49-4-2-运行测试" class="headerlink" title="49.4.2 运行测试"></a>49.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图49-4）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps105.jpg" alt="img"></p>
<p>图49-4</p>
<p>可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（49-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps106.jpg" alt="img"></p>
<p>图 49-5</p>
<p>我们按一下屏幕，立即输入“ps -aux | grep test_workqueue”,可以看到工作线程，如下图（49-6）所示，u代表无绑定的工作队列。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps107.jpg" alt="img"></p>
<p>图 49-6</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图49-7）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps108.jpg" alt="img"></p>
<p>图 49-7</p>
<p>至此，中断线程化实验就完成了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD/" rel="tag">中断</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-rk3568-驱动开发第四篇-高级字符设备进阶"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E5%9B%9B%E7%AF%87-%E9%AB%98%E7%BA%A7%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E8%BF%9B%E9%98%B6/"
    >rk3568 驱动开发第四篇 高级字符设备进阶</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E5%9B%9B%E7%AF%87-%E9%AB%98%E7%BA%A7%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E8%BF%9B%E9%98%B6/" class="article-date">
  <time datetime="2023-09-04T12:55:36.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第25章-IO模型引入实验"><a href="#第25章-IO模型引入实验" class="headerlink" title="第25章 IO模型引入实验"></a>第25章 IO模型引入实验</h1><p>我们经常提到 IO、NIO 这些名词。那么，到底什么是 IO 呢？什么又是 NIO 呢？另外，我们平时又会听到两组很相似的概念：阻塞&#x2F;非阻塞、同步&#x2F;异步。那么，阻塞和非阻塞有什么区别呢？同步和异步的差别又在哪里呢？</p>
<p>为了更好的理解IO模型，在本章节将对IO的概念、IO的执行过程及IO模型的分类进行详细分析，下面就让我们一起进入IO的世界吧！</p>
<h2 id="25-1-IO的概念"><a href="#25-1-IO的概念" class="headerlink" title="25.1 IO的概念"></a>25.1 IO的概念</h2><p>IO是英文Input和Output的首字母，代表了输入和输出，当然这样的描述有一点点抽象，更直观的意思是计算机的输入与输出。在冯.诺依曼结构中，将计算机分成了5个部分，分别是运算器，控制器，存储器，输入设备，输出设备。如下图（图 25-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps173.jpg" alt="img"> </p>
<p>图 25-1</p>
<p>上图中的输入设备指的是鼠标和键盘等向计算机输入数据和信息的设备，输出设备指的是电脑显示器等用于计算机信息输出的设备，下面对计算机输入输出过程进行实际举例，当敲击键盘（输入设备）任意按键后，按键的数据会传递给计算机，计算机CPU会对数据进行运算，运算完成之后会将数据输出到显示器（输出设备）上，整个过程如下图（图 25-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps174.jpg" alt="img"> </p>
<p>图 25-2</p>
<p>上述事例中，鼠标、显示器只是输入输出的直观表现形式，而在计算机架构层面上，IO是涉及计算机核心与其他设备间数据迁移的过程。以磁盘IO为例，内存读取磁盘数据和将内存数据写入磁盘，就是一对输入输出的过程。</p>
<p>至此，对于IO的概念就讲解完成了，在下一小节中将对IO执行过程进行分析。</p>
<h2 id="25-2-IO执行过程"><a href="#25-2-IO执行过程" class="headerlink" title="25.2 IO执行过程"></a>25.2 IO执行过程</h2><p>操作系统（Linux）负责对计算机的资源进行管理和对进程进行调度，应用程序运行在操作系统上，处于用户空间。应用程序不能直接对硬件进行操作，只能通过操作系统提供的API来操作硬件。需要将进程切换到内核空间，才能进行IO操作，并且应用程序不能直接操作内核空间的数据，需要把内核空间的数据拷贝到用户空间。</p>
<p>应用程序运行在用户空间，它不存在实质的IO过程，真正的IO是在操作系统执行的。那么应用程序操作IO就会有两个动作：IO调用和IO执行。IO调用是应用程序向操作系统内核发起调用，IO执行是操作系统内核完成的IO操作。</p>
<p>一个完整的IO过程需要包含以下三个步骤，如下图（图25-3）所示：</p>
<p>（1） 用户空间的应用程序向内核发起IO调用请求(系统调用)</p>
<p>（2） 内核操作系统准备数据，把IO设备的数据加载到内核缓冲区</p>
<p>（3） 操作系统拷贝数据，把内核缓冲区的数据拷贝到用户进程缓冲区</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps175.jpg" alt="img"> </p>
<p>图 25-2</p>
<h2 id="25-3-IO模型的分类"><a href="#25-3-IO模型的分类" class="headerlink" title="25.3 IO模型的分类"></a>25.3 IO模型的分类</h2><p>假设有这样一个场景，从磁盘中循环读取100M的数据并处理，磁盘读取100M需要花费20秒的时间，CPU同样也需要20秒的时间处理完这些数据。如果采用传统的模式编写代码：读数据-&gt;等待数据读取完毕-&gt;数据处理，可以发现，数据的读取花费了一半的时间，而这就导致该任务的效率极其低下，那么能不能在等待数据的同时对数据进行处理呢？当然可以！这时候就轮到IO编程模型来出场了。</p>
<p>IO模型根据实现的功能可以划分为为阻塞IO、非阻塞IO、信号驱动IO， IO多路复用和异步IO。根据等待IO的执行结果进行划分，前四个IO模型又被称为同步IO，如下图（图 25-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps176.jpg" alt="img"> </p>
<p>图 25-4</p>
<p>所谓同步，即发出一个功能调用后，只有得到结果该调用才会返回。异步的概念和同步相对。当一个异步过程调用发出后，调用者并不能立刻得到结果，实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>
<p>以现实生活去餐馆吃饭为例，根据菜单进行点餐之后，这时会存在两个选择，第一个选择是在餐馆等待饭菜制作完毕，这就是同步IO的具体表现。第二个选择是，离开餐馆去做其他的事情，工作人员会在饭菜制作完成之后提醒你回餐馆取餐，这就是异步IO的具体表现。</p>
<p>下面让我们来认识一下这五种IO模型。</p>
<p><em><strong>*1 阻塞IO*</strong></em></p>
<p>以****阻塞读****为例：进程进行IO操作时(如read操作)，首先会发起一个系统调用，从而转到内核空间进行处理，内核空间的数据没有准备就绪时，进程会被阻塞，不会继续向下执行，直到内核空间的数据准备完成后，数据才会从内核空间拷贝到用户空间，最后返回用户进程，由用户空间进行数据的处理，如下图（图 25-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps177.jpg" alt="img"> </p>
<p>图 25-6</p>
<p>以现实生活中的钓鱼为例，在做好相应准备抛下鱼钩之后，需要耐心等待鱼儿的上钩，等待的过程中必须聚精会神的关注鱼竿的状态，鱼儿上钩之后立刻扬竿，这就是阻塞IO在实际生活中的事例。</p>
<p>通过上述例子可以总结出阻塞IO的优势与不足，首先可以及时的获取结果，并立刻对获取到的结果进行处理，然而在获取结果之前，无法去处理其他任务，需要时刻对结果进行监听。</p>
<p>阻塞IO比较有代表性的是C语言中的scanf()函数。编写好的io.c文件，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>,i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，scanf函数用于从键盘上接收数据，如果键盘不进行数据的输入，该任务会持续阻塞，只有键盘输入数据之后，才会有相应的输入值打印到系统终端上。输入以下命令进行可执行文件的编译，如下（图 25-7）所示</p>
<p>gcc io.c -o io</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps178.jpg" alt="img"> </p>
<p>图 25-8</p>
<p>编译完成之后，输入“.&#x2F;io”运行可执行文件，如下所示，键盘没有输入数据时，该任务会持续阻塞，当在键盘上输入“123”之后，输入的值才会被打印出来，如下（图 25-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps179.jpg" alt="img"> </p>
<p>图 25-9</p>
<p><em><strong>*2 非阻塞IO*</strong></em></p>
<p>和阻塞IO模型不同，非阻塞IO进行IO操作时，如果内核数据没有准备好，内核会立即向进程返回err，不会进行阻塞；如果内核空间数据准备就绪，内核会立即把数据返回给用户空间的进程，如下图（图 25-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps180.jpg" alt="img"> </p>
<p>图 25-10</p>
<p>仍旧以现实生活中钓鱼为例，在做好相应准备抛下鱼钩之后，这次并没有持续不断的关注鱼竿的状态，而是去做其他的事情（不阻塞等待结果），每隔几分钟对鱼竿的状态进行检查，如果没有鱼儿上钩，就继续去做其他事情，如果上钩了就把鱼钓上来,这就是非阻塞IO在实际生活中的事例。</p>
<p>从上述案例中可以看出非阻塞IO的优点是效率高，同样的时间可以做更多的事。但是缺点也很明显，需要不断对结果进行轮询查看，从而导致结果获取不及时（结果可能在两次轮询之间就已经准备完毕，但是只能在发起轮询的时候才能知道），如果要增加非阻塞IO的实时性，就要加快轮询的频率，但这样无疑也会增加CPU的负担。</p>
<p><em><strong>*3 IO多路复用*</strong></em></p>
<p>通常情况下使用select()、poll()、epoll()函数实现IO多路复用。这里以select函数为例进行讲解，使用时可以对select传入多个描述符，并设置超时时间。当执行select的时候，系统会发起一个系统调用，内核会遍历检查传入的描述符是否有事件发生（如可读、可写事件）。如有，立即返回，否则进入睡眠状态，使进程进入阻塞状态，直到任何一个描述符事件产生后（或者等待超时）立刻返回。此时用户空间需要对全部描述符进行遍历，以确认具体是哪个发生了事件，这样就能使用一个进程对多个IO进行管理，如下图（图 25-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps181.jpg" alt="img"> </p>
<p>图 25-11</p>
<p>继续以现实生活中的钓鱼为例，和之前案例只有一个鱼竿不同，这次会在十个不同的地方做好相应准备抛下鱼钩，并把十个鱼竿连在了一个铃铛上，这样只要铃铛响了就表示有鱼上钩，只需挨个检查到底是哪个鱼竿有鱼上钩即可。</p>
<p>这样的优点是一个进程&#x2F;线程可以同时监听和处理多路IO，效率成倍提高。但是IO多路复用并不是能医治百病的良药，虽然IO多路复用可以监听多个IO，但是实际上对结果的处理也只能依次进行，比较适合IO密集但是每一路IO数据量不多且到达时间分散的场合（如网络聊天）。</p>
<p>另外select监听的描述符有上限（一般描述符最大不超过1024），而且需要遍历究竟是哪一个IO产生了数据。因此IO较多时，效率不高（这个问题被epoll解决，感兴趣的读者可以自行了解）。</p>
<p><em><strong>*4 信号驱动*</strong></em></p>
<p>信号驱动IO顾名思义与信号相关。系统在一些事件发生之后，会对进程发出特定的信号，而信号与处理函数相绑定，当信号产生时就会调用绑定的处理函数。例如在Linux系统任务执行的过程中可以按下ctrl+C来对任务进行终止，系统实际上是对该进程发送一个SIGINT信号，该信号的默认处理函数就是退出当前程序。</p>
<p>具体到IO模型上，可以对SIGIO信号注册相应的信号处理函数，并打开对应描述符的信号驱动。每当有IO数据产生时，系统就会发送一个SIGIO信号，进而调用相应的信号处理函数，从而在这个处理函数中对数据进行读取，如下图（图 25-12）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps182.jpg" alt="img"> </p>
<p>图 25-12</p>
<p>仍旧以现实生活中的钓鱼为例，在做好相应准备抛下鱼钩之后，这次同样没有持续不断的关注鱼竿的状态，而是去做其他的事情（不阻塞等待结果），与之前不同的是，在鱼竿处绑定了一个提醒铃铛，当鱼咬钩之后，铃铛就会响(有SIGIO信号)，进而得知到鱼儿上钩的消息之，这样就可以及时把鱼钓上来了(调用处理函数)。</p>
<p><em><strong>*5 异步IO*</strong></em></p>
<p>aio_read函数常常用于异步IO，当进程使用aio_read读取数据时，如果数据尚未准备就绪就立即返回，不会阻塞。若数据准备就绪就会把数据从内核空间拷贝到用户空间的缓冲区中，然后执行定义好的回调函数对接收到的数据进行处理。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps183.jpg" alt="img"> </p>
<p>图 25-13</p>
<p>最后，还是以钓鱼为例。小马同学喜欢吃新鲜的鱼，但是不想自己钓，所以他请了一个助手来帮他钓鱼，他自己去忙其他的事情（进程不阻塞，立即返回）。如果有鱼上钩助手会帮忙钓上来（将数据拷贝到指定的缓冲区），并立即通知小马同学回来把鱼取走（处理数据）。</p>
<h1 id="第26章-阻塞IO实验"><a href="#第26章-阻塞IO实验" class="headerlink" title="第26章  阻塞IO实验"></a>第26章  阻塞IO实验</h1><p>在上一章节，对IO的相关概念和五种IO模型分类进行了学习，在接下来的章节中将分别对四种同步IO进行详细的讲解和实验，本章节要讲解的IO模型是阻塞IO，阻塞IO在Linux内核中是非常常用的IO模型，所依赖的机制是等待队列。下面让我们来开始阻塞IO的学习吧。</p>
<h2 id="26-1-什么是等待队列"><a href="#26-1-什么是等待队列" class="headerlink" title="26.1 什么是等待队列"></a>26.1 什么是等待队列</h2><p>在Linux驱动程序中，阻塞进程可以使用等待队列来实现。等待队列是内核实现阻塞和唤醒的内核机制，以双循环链表为基础结构，由链表头和链表项两部分组成，分别表示等待队列头和等待队列元素，如下图（图26-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps184.jpg" alt="img"> </p>
<p>图26-1</p>
<p>等待队列头使用结构体wait_queue_head_t 来表示，等待队列头是一个等待队列的头部，这个结构体定义在文件include&#x2F;linux&#x2F;wait.h里面，结构体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">wait_queue_head</span>&#123;</span></span><br><span class="line"><span class="type">spinlock_t</span> lock;    <span class="comment">//自旋锁</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span> //链表头</span></span><br><span class="line"><span class="class">&#125;；</span></span><br><span class="line"><span class="class"><span class="title">typefef</span> <span class="keyword">struct</span> _<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br></pre></td></tr></table></figure>

<p>等待队列项使用结构体wait_queue_t来表示，等待队列项是等待队列元素，该结构体同样定义在文件include&#x2F;linux&#x2F;wait.h里面，结构体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">wait_queue</span>&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">void</span> *private;</span><br><span class="line"><span class="type">wait_queue_func_t</span> func;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">wait_queue</span> <span class="title">wait_queue_t</span>;</span></span><br></pre></td></tr></table></figure>

<h2 id="26-2-等待队列API函数"><a href="#26-2-等待队列API函数" class="headerlink" title="26.2 等待队列API函数"></a>26.2 等待队列API函数</h2><p><em><strong>*1 定义并初始化等待队列头*</strong></em></p>
<p>等待队列要想被使用，第一步就是对等待队列头进行初始化，有俩种办法如下所示：</p>
<p>方法一：使用 DECLARE_WAIT_QUEUE_HEAD宏静态创建等待队列头，宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WAIT_QUEUE_HEAD(name) \</span></span><br><span class="line"><span class="meta">wait_queue_head_t name = __WAIT_QUEUE_HEAD_INITIALIZER(name)</span></span><br></pre></td></tr></table></figure>

<p>参数name表示要定义的队列头名字。通常以全局变量的方式定义,如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_WAIT_QUEUE_HEAD(head);</span><br></pre></td></tr></table></figure>

<p>方法二：使用init_waitqueue_head宏动态初始化等待队列头，宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> init_waitqueue_head(q)				\</span></span><br><span class="line"><span class="meta">	do &#123;						\</span></span><br><span class="line"><span class="meta">		static struct lock_class_key __key;	\</span></span><br><span class="line"><span class="meta">							\</span></span><br><span class="line"><span class="meta">		__init_waitqueue_head((q), #q, &amp;__key);	\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>参数q表示需要初始化的队列头指针。使用宏定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wait_queue_head_t</span> head;       <span class="comment">//等待队列头</span></span><br><span class="line">init_waitqueue_head(&amp;head);    <span class="comment">//初始化等待队列头指针</span></span><br></pre></td></tr></table></figure>



<p>然后再来学习如何创建等待队列元素，也就是等待队列项。</p>
<p><em><strong>*2 创建等待队列项*</strong></em></p>
<p>一般使用宏 DECLARE_WAITQUEUE(name,tsk)给当前正在运行的进程创建并初始化一个等待队列项，宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WAITQUEUE(name, tsk)						\</span></span><br><span class="line"><span class="meta">struct wait_queue_entry name = __WAITQUEUE_INITIALIZER(name, tsk)</span></span><br></pre></td></tr></table></figure>

<p>第一个参数name是等待队列项的名字，第二个参数tsk表示此等待队列项属于哪个任务（进程），一般设置为current。在Linux内核中current相当于一个全局变量，表示当前进程。创建等待队列项如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_WAITQUEUE(wait,current);  <span class="comment">//给当前正在运行的进程创建一个名为wait的等待队列项。</span></span><br><span class="line">add_wait_queue(wq,&amp;wait); <span class="comment">//将wait这个等待队列项加到wq这个等待队列当中</span></span><br></pre></td></tr></table></figure>

<p><em><strong>*3添加&#x2F;删除队列*</strong></em></p>
<p>当设备没有准备就绪（如没有可读数据）而需要进程阻塞的时候，就需要将进程对应的等待队列项添加到前面创建的等待队列中，只有添加到等待队列中以后进程才能进入休眠态。当设备可以访问时（如有可读数据），再将进程对应的****等待队列项****从等待队列中移除即可。</p>
<p>等待队列项添加队列函数如下所示：</p>
<p><em><strong>*函数原型:*</strong></em></p>
<p>  void add_wait_queue(wait_queue_head_t *q,wait_queue_t *wait)</p>
<p><em><strong>*函数功能:*</strong></em></p>
<p> (通过等待队列头)向等待队列中添加队列项</p>
<p><em><strong>*参数含义:*</strong></em></p>
<p> wq_head表示等待队列项要加入等待队列的等待队列头</p>
<p>wq_entry表示要加入的等待队列项</p>
<p><em><strong>*函数返回值*</strong></em>  </p>
<p>无</p>
<p>等待队列项移除队列函数如下所示：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>void remove_wait_queue(wait_queue_head_t *q,wait_queue_t *wait)</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>要删除的等待队列项所处的等待队列头</p>
<p><em><strong>*函数含义：*</strong></em></p>
<p>第一个参数q表示等待队列项要加入等待队列的等待队列头</p>
<p>第二个参数wait表示要加入的等待队列项</p>
<p><em><strong>*函数返回值：*</strong></em></p>
<p>无</p>
<p><em><strong>*4等待事件*</strong></em></p>
<p>除了主动唤醒以外，也可以设置等待队列等待某个事件，当这个事件满足以后就自动唤醒等待队列中的进程，使用如下所示的宏，是不可中断的阻塞等待。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __wait_event(wq_head, condition)					\</span></span><br><span class="line"><span class="meta">(void)___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 0, 0,	\</span></span><br><span class="line"><span class="meta">schedule())</span></span><br></pre></td></tr></table></figure>

<p><em><strong>*宏定义功能：*</strong></em></p>
<p>不可中断的阻塞等待，让调用进程进入不可中断的睡眠状态，在等待队列里面睡眠直到condition变成真，被内核唤醒。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>第一个参数wq: wait_queue_head_t 类型变量</p>
<p>第二个参数condition : 等待条件，为假时才可以进入休眠。如果condition为真，则不会休眠</p>
<p>除此之外，wait_event_interruptible的宏是可中断的阻塞等待。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __wait_event_interruptible(wq_head, condition)				\</span></span><br><span class="line"><span class="meta">___wait_event(wq_head, condition, TASK_INTERRUPTIBLE, 0, 0,		\</span></span><br><span class="line"><span class="meta">schedule())</span></span><br></pre></td></tr></table></figure>



<p><em><strong>*宏含义功能：*</strong></em></p>
<p>可中断的阻塞等待，让调用进程进入可中断的睡眠状态，直到condition变成真被内核唤醒或信号打断唤醒。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>第一个参数wq :wait_queue_head_t 类型变量</p>
<p>第二个参数condition :等待条件。为假时才可以进入休眠。如果condition为真，则不会休眠。</p>
<p>wait_event_timeout() 宏也与 wait_event()类似.不过如果所给的睡眠时间为负数则立即返回.如果在睡眠期间被唤醒,且condition 为真则返回剩余的睡眠时间,否则继续睡眠直到到达或超过给定的睡眠时间,然后返回 0。</p>
<p>wait_event_interruptible_timeout() 宏与 wait_event_timeout()类似,不过如果在睡眠期间被信号打断则返回 ERESTARTSYS 错误码。</p>
<p>wait_event_interruptible_exclusive() 宏同样和 wait_event_interruptible()一样,不过该睡眠的进程是一个互斥进程</p>
<p>注意：调用的时要确认 condition 值是真还是假，如果调用 condition 为真，则不会休眠。</p>
<p><em><strong>*5等待队列唤醒*</strong></em></p>
<p>当设备可以使用的时候就要唤醒进入休眠态的进程，唤醒可以使用如下俩个函数</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>wake_up(wait_queue_head_t *q)</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>唤醒所有休眠进程</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>q表示要唤醒的等待队列的等待队列头</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>wake_up_interruptible(wait_queue_head_t *q)</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>唤醒可中断的休眠进程</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>q表示要唤醒的等待队列的等待队列头</p>
<h2 id="26-3-等待队列使用方法"><a href="#26-3-等待队列使用方法" class="headerlink" title="26.3 等待队列使用方法"></a>26.3 等待队列使用方法</h2><p>步骤一：初始化等待队列头，并将条件置成假(condition&#x3D;0)。</p>
<p>步骤二：在需要阻塞的地方调用wait_event()，使进程进入休眠状态。</p>
<p>步骤三：当条件满足时，需要解除休眠，先将条件(condition&#x3D;1),然后调用wake_up函数唤醒等待队列中的休眠进程。</p>
<h2 id="26-4-实验程序编写"><a href="#26-4-实验程序编写" class="headerlink" title="26.4 实验程序编写"></a>26.4 实验程序编写</h2><h3 id="26-4-1-驱动程序编写"><a href="#26-4-1-驱动程序编写" class="headerlink" title="26.4.1 驱动程序编写"></a>26.4.1 驱动程序编写</h3><p>本实验对应的驱动网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\20\module。</p>
<p>接着编写等待队列的实验代码，在此代码中，按照上一小节等待队列使用方法的三个步骤进行编写，在read函数中调用wait_event_interruptible函数阻塞，使进程进入休眠状态。在write函数中唤醒等待队列中的休眠进程。编写好的驱动程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span>  flag;  <span class="comment">//标志位</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  </span><br><span class="line"></span><br><span class="line">DECLARE_WAIT_QUEUE_HEAD(read_wq); <span class="comment">//定义并初始化等待队列头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test_dev-&gt;flag=<span class="number">1</span>;<span class="comment">//将条件置1</span></span><br><span class="line">    wake_up_interruptible(&amp;read_wq); <span class="comment">//并使用wake_up_interruptible唤醒等待队列中的休眠进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    wait_event_interruptible(read_wq,test_dev-&gt;flag); <span class="comment">//可中断的阻塞等待，使进程进入休眠态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="26-4-2-编写测试-APP"><a href="#26-4-2-编写测试-APP" class="headerlink" title="26.4.2 编写测试 APP"></a>26.4.2 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\20\app。</p>
<p>接下来编写应用程序read.c，此程序实现了从设备读取数据的功能。编写好的应用程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开led驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read before \n&quot;</span>);</span><br><span class="line">    read(fd,buf1,<span class="keyword">sizeof</span>(buf1));  <span class="comment">//从/dev/test文件读取数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf is %s  \n&quot;</span>,buf1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read after \n&quot;</span>);</span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理 ，编写应用程序write.c，实现向设备写入数据的功能，编写好的应用程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开led驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write before \n&quot;</span>);</span><br><span class="line">    write(fd,buf2,<span class="keyword">sizeof</span>(buf2));  <span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;write after\n&quot;</span>);</span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-5运行测试"><a href="#26-5运行测试" class="headerlink" title="26.5运行测试"></a>26.5运行测试</h2><h3 id="26-5-1编译驱动程序"><a href="#26-5-1编译驱动程序" class="headerlink" title="26.5.1编译驱动程序"></a>26.5.1编译驱动程序</h3><p>在上一小节中的wq.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += wq.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放wq.c和Makefile文件目录下，如下图（图 26-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps185.jpg" alt="img"> </p>
<p>图 26-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 26-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps186.jpg" alt="img"> </p>
<p>图 26-3</p>
<p>编译完生成 wq.ko目标文件，如下图（图 26-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps187.jpg" alt="img"> </p>
<p>图 26-4</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="26-5-2-编译应用程序"><a href="#26-5-2-编译应用程序" class="headerlink" title="26.5.2 编译应用程序"></a>26.5.2 编译应用程序</h3><p>来到存放应用程序read.c和write.c的文件夹下，使用以下命令对read.c和write.c进行交叉编译，编译完成如下图（图 26-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o read read.c -static</p>
<p>aarch64-linux-gnu-gcc -o write write.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps188.jpg" alt="img"> </p>
<p>图 26-4</p>
<p>生成的read write文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="26-5-3-运行测试"><a href="#26-5-3-运行测试" class="headerlink" title="26.5.3 运行测试"></a>26.5.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 26-5）所示：</p>
<p>insmod wq.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps189.jpg" alt="img"></p>
<p>图 26-5</p>
<p>输入以下命令运行read可执行文件，如下图（图 26-6）所示，read应用程序进程阻塞</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps190.jpg" alt="img"></p>
<p>图 26-6</p>
<p>然后输入以下命令运行write可执行文件，如下图（图 26-7）所示，使用write函数向设备写入数据，唤醒等待队列中的休眠进程。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps191.jpg" alt="img"></p>
<p>图 26-7</p>
<p>在使用可执行程序write向缓冲区写入数据时，read可执行程序读取到了缓冲区的数据并打印。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps192.jpg" alt="img"></p>
<p>图 26-8</p>
<h1 id="第27章-非阻塞IO实验"><a href="#第27章-非阻塞IO实验" class="headerlink" title="第27章 非阻塞IO实验"></a>第27章 非阻塞IO实验</h1><p>上个章节中我们学习了阻塞IO，阻塞IO是通过等待队列来实现的，那么如何让驱动实现非阻塞呢？带着疑问，让我们开始本章节非阻塞IO的学习吧！</p>
<h2 id="27-1-非阻塞IO简介"><a href="#27-1-非阻塞IO简介" class="headerlink" title="27.1 非阻塞IO简介"></a>27.1 非阻塞IO简介</h2><p>应用程序可以使用如下所示示例代码来实现阻塞访问：</p>
<p>int fd;</p>
<p>int data &#x3D; 0;</p>
<p>fd &#x3D; open(“&#x2F;dev&#x2F;xxx_dev”, <em><strong>*O_RDWR*</strong></em>);  &#x2F;* 阻塞方式打开 *&#x2F;</p>
<p>ret &#x3D; read(fd, &amp;data, sizeof(data));   &#x2F;* 读取数据 *&#x2F;</p>
<p>可以看出对于设备驱动文件的默认读取方式就是阻塞式的，所以之前实验例程测试 APP 都是采用阻塞 IO。</p>
<p>如果应用程序要采用非阻塞的方式来访问驱动设备文件，可以使用如下所示代码：</p>
<p>int fd;</p>
<p>int data &#x3D; 0;</p>
<p>fd &#x3D; open(“&#x2F;dev&#x2F;xxx_dev”, <em><strong>*O_RDWR | O_NONBLOCK*</strong></em>); &#x2F;* 非阻塞方式打开 *&#x2F;</p>
<p>ret &#x3D; read(fd, &amp;data, sizeof(data)); &#x2F;* 读取数据 *&#x2F;</p>
<p>使用 open 函数打开“&#x2F;dev&#x2F;xxx_dev”设备文件的时候添加了参数“O_NONBLOCK”，表示以非阻塞方式打开设备，这样从设备中读取数据的时候是非阻塞方式了。</p>
<h2 id="27-2-实验程序编写"><a href="#27-2-实验程序编写" class="headerlink" title="27.2 实验程序编写"></a>27.2 实验程序编写</h2><h3 id="27-2-1-编写测试-APP"><a href="#27-2-1-编写测试-APP" class="headerlink" title="27.2.1 编写测试 APP"></a>27.2.1 编写测试 APP</h3><p>非阻塞IO实验需要应用程序和驱动配合，所以需要编写驱动代码和应用测试代码。</p>
<p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\21\app。</p>
<p>首先来编写应用测试代码read.c，在此代码中使用非阻塞的方式打开设备，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;  <span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//定义读取缓冲区buf</span></span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//定义读取缓冲区buf</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR| O_NONBLOCK);  <span class="comment">//打开/dev/test设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read before \n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         read(fd,buf1,<span class="keyword">sizeof</span>(buf1));  <span class="comment">//从/dev/test文件读取数据</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;buf is %s \n&quot;</span>,buf1);  <span class="comment">//打印读取的数据</span></span><br><span class="line">         sleep(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read after\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着编写应用程序write.c，用来向设备文件写入数据，编写好的应用程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR|O_NONBLOCK);  <span class="comment">//打开/dev/test设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write before \n&quot;</span>);</span><br><span class="line">    write(fd,buf2,<span class="keyword">sizeof</span>(buf2));  <span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;write after\n&quot;</span>);</span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="27-2-1-驱动程序编写"><a href="#27-2-1-驱动程序编写" class="headerlink" title="27.2.1 驱动程序编写"></a>27.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\21\module。</p>
<p> 编写好的驱动程序wq.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span>  flag;  <span class="comment">//标志位</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  </span><br><span class="line"></span><br><span class="line">DECLARE_WAIT_QUEUE_HEAD(read_wq); <span class="comment">//定义并初始化等待队列头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test_dev-&gt;flag=<span class="number">1</span>;    <span class="comment">//将条件置1，并使用wake_up_interruptible唤醒等待队列中的休眠进程</span></span><br><span class="line">    wake_up_interruptible(&amp;read_wq); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span>(file-&gt;f_flags &amp; O_NONBLOCK )&#123;</span><br><span class="line">        <span class="keyword">if</span> (test_dev-&gt;flag !=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    &#125;</span><br><span class="line">    wait_event_interruptible(read_wq,test_dev-&gt;flag); <span class="comment">//可中断的阻塞等待，使进程进入休眠态</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="27-3-运行测试"><a href="#27-3-运行测试" class="headerlink" title="27.3 运行测试"></a>27.3 运行测试</h2><h3 id="27-3-1-编译驱动程序"><a href="#27-3-1-编译驱动程序" class="headerlink" title="27.3.1 编译驱动程序"></a>27.3.1 编译驱动程序</h3><p>在上一小节中的wq.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += wq.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放wq.c和Makefile文件目录下，如下图（图 27-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps193.jpg" alt="img"> </p>
<p>图 27-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图27-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps194.jpg" alt="img"> </p>
<p>图 27-2</p>
<p>编译完生成 wq.ko目标文件，如下图（图 27-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps195.jpg" alt="img"> </p>
<p>图 27-3</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="27-3-2-编译应用程序"><a href="#27-3-2-编译应用程序" class="headerlink" title="27.3.2 编译应用程序"></a>27.3.2 编译应用程序</h3><p>来到存放应用程序read.c和write.c的文件夹下，使用以下命令对read.c和write.c进行交叉编译，编译完成如下图（图 27-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o read read.c -static</p>
<p>aarch64-linux-gnu-gcc -o write write.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps196.jpg" alt="img"> </p>
<p>图 27-4</p>
<p>生成的read write文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="27-3-3-测试"><a href="#27-3-3-测试" class="headerlink" title="27.3.3 测试"></a>27.3.3 测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 27-5）所示：</p>
<p>insmod wq.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps197.jpg" alt="img"></p>
<p>图 27-5</p>
<p>输入以下命令运行read可执行文件，如下图（图 27-6）所示，应用程序进程非阻塞，读取不到数据便返回，然后一直轮询查看是否有数据。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps198.jpg" alt="img"></p>
<p>图 27-6</p>
<p>然后输入以下命令运行write可执行文件向设备文件写入数据，如下图（图 27-7）所示:</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps199.jpg" alt="img"></p>
<p>图 27-7</p>
<p>在使用可执行程序write向缓冲区写入数据时，read可执行程序读取到了缓冲区的数据并打印。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps200.jpg" alt="img"></p>
<p>图 27-8</p>
<h1 id="第28章-IO多路复用实验"><a href="#第28章-IO多路复用实验" class="headerlink" title="第28章 IO多路复用实验"></a>第28章 IO多路复用实验</h1><p>在上俩个章节中，我们对阻塞IO和非阻塞IO进行了学习，本章节将学习第三种IO模型-多路复用IO。</p>
<h2 id="28-1-IO多路复用简介"><a href="#28-1-IO多路复用简介" class="headerlink" title="28.1 IO多路复用简介"></a>28.1 IO多路复用简介</h2><p>IO多路复用是一种同步的IO模型。IO多路复用可以实现一个进程监视多个文件描述符。一旦某个文件描述符准备就绪，就通知应用程序进行相应的读写操作。没有文件描述符就绪时就会阻塞应用程序，从而释放出CPU资源。</p>
<p>在第25章中，我们以钓鱼为例，对IO多路复用有了一个简单的认识。下面对钓鱼例子进行回顾：小李同时放置了十个鱼竿，并把十个鱼竿连在了一个铃铛上。这样小李就不必在岸边等待。当铃铛响了就表示有鱼上钩，再回来挨个检查到底是哪个鱼竿有鱼上钩即可。接着进一步体会IO多路复用。</p>
<p>在应用层Linux提供了三种实现IO多路复用的模型，分别是select、poll 和 epoll。在本驱动手册中主要偏重于对驱动的讲解，所以应用层中select、poll 和 epoll函数的使用在这里不做重点讲解。</p>
<p>首先来学习下select、poll 和 epoll函数有什么区别呢？poll函数和seslect函数都可以监听多个文件描述符，通过轮询来获取已经准备好的文件描述符。但是epoll函数将主动轮询变成了被动通知，当事件发生时被动接收通知。为了方便理解，举个形象的例子。假如poll和select是公司的前台，某天一位客户来公司找硬件工程师-小李，请求前台帮忙找人。于是poll和select前台带着这位客户挨个屋子寻找小李，直到找到小李为止。假如epoll是公司的前台，他提前统计了公司每个员工的工位。当客户来找小李的时候，不必像poll select一样，可以直接带着客户到硬件部门去找小李。从上面的俩个例子，明显对比epoll的效率更高。假如公司园区很大，那么poll select需要花费很长时间寻找小李，而epoll已经提前知道小李坐在哪个工位了，直接带客户去找小李即可。</p>
<p>select,poll,epoll有什么区别呢？在单个线程中，select函数最大可以监视1024个文件描述符，而poll函数和select函数并没有什么区别，只是poll函数没有最大文件描述符的限制。在本章节的实验中，以poll为例进行实验。在Linux应用程序中poll函数如下所示：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int poll(struct pollfd *fds,</p>
<p>nfds_t nfds,</p>
<p>int timeout);</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>监视并等待多个文件描述符的属性变化</p>
<p><em><strong>*函数参数：*</strong></em></p>
<p><em><strong>*第一个参数fds*</strong></em>: 要监视的文件描述符集合以及要监视的事件，为一个数组，数组元素都是结构体pollfd类型，pollfd结构体如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"><span class="type">int</span> fd;       <span class="comment">//被监视的文件描述符</span></span><br><span class="line"><span class="type">short</span> events;  <span class="comment">//等待的事件</span></span><br><span class="line"><span class="type">short</span> revents;  <span class="comment">//实际发生的事件</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>在pollfd结构体中，第一个成员fd是被监视的文件描述符。第二个成员events是要监视的事件，可监视的事件类型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POLLIN   有数据可以读取</span><br><span class="line">POLLPRI  有紧急的数据需要读取</span><br><span class="line">POLLOUT  可以写数据</span><br><span class="line">POLLERR   指定的文件描述符发生错误</span><br><span class="line">POLLHUP   指定的文件描述符挂起</span><br><span class="line">POLLNVAL  无效的请求</span><br><span class="line">POLLRDNORM  等同于POLLIN</span><br></pre></td></tr></table></figure>

<p>第三个成员是返回事件，由Linux内核设置具体的返回事件。</p>
<p><em><strong>*第二个参数nfds*</strong></em>: poll函数要监视的文件描述符数量</p>
<p><em><strong>*第三个参数timeout*</strong></em>:指定等待的时间，单位是ms。无论I&#x2F;O是否准备好，时间到POLL就会返回。如果timepoll大于0 等待指定的时间，如果timeout等于0，立即返回。如果timeout等于-1，事件发生以后才返回。</p>
<p><em><strong>*函数返回值：*</strong></em></p>
<p>失败返回-1，成功返回revents不为0的文件描述符个数。</p>
<p>当应用程序使用select或者poll函数对驱动程序进行非阻塞访问时，驱动程序中file_operations操作集的poll函数会执行。所以需要完善驱动中的poll函数。驱动中的poll函数原型如下所示：</p>
<p>unsigned int (*poll)(struct file *filp,struct poll_table_struct *wait);</p>
<p><em><strong>*函数参数：*</strong></em></p>
<p>filp:要打开的文件描述符</p>
<p>wait: 结构体poll_table_struct类型指针，此参数是由应用程序中传递的。一般此参数要传递给poll_wait函数。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>向应用程序返回资源状态，可以返回的资源状态如下：</p>
<p>POLLIN  有数据可以读取</p>
<p>POLLPRI  有紧急的数据需要读取</p>
<p>POLLOUT  可以写数据</p>
<p>POLLERR  指定的文件描述符发生错误</p>
<p>POLLHUP  指定的文件描述符挂起</p>
<p>POLLNVAL  无效的请求</p>
<p>POLLRDNORM 等同于POLLIN，普通数据可读。</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>这个函数要进行下面两项工作。首先，对可能引起设备文件状态变化的等待队列调用poll_wait(),将对应的等待队列头添加到poll_table.然后返回表示是否能对设备进行无阻塞读写访问的掩码。</p>
<p>驱动程序的poll函数中调用poll_wait函数，注意！poll_wait函数是不会引起阻塞的。poll_wait函数原型如下所示：</p>
<p>void poll_wait(struct file *filp,wait_queue_head_t *queue,poll_table *wait);</p>
<p>参数queue是要添加到poll_table中的等待队列头，参数wait是poll_table，也就是file_operations中poll函数的wait参数。</p>
<h2 id="28-2-实验程序编写"><a href="#28-2-实验程序编写" class="headerlink" title="28.2 实验程序编写"></a>28.2 实验程序编写</h2><h3 id="28-2-1-编写测试-APP"><a href="#28-2-1-编写测试-APP" class="headerlink" title="28.2.1 编写测试 APP"></a>28.2.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\22\app。</p>
<p>在应用层Linux提供了三种API函数，分别是select poll和epoll。本次实验使用poll函数进行实验，如果对select 和epoll函数感兴趣，可以查找一些系统编程课程学习。</p>
<p>编写好的应用程序read.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;  <span class="comment">//要监视的文件描述符</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>  <span class="title">fds</span>[1];</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开/dev/test设备，阻塞式访问</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//构造结构体</span></span><br><span class="line">    fds[<span class="number">0</span>] .fd =fd;</span><br><span class="line">    fds[<span class="number">0</span>].events = POLLIN; <span class="comment">//监视数据是否可以读取</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read before \n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = poll(fds,<span class="number">1</span>,<span class="number">3000</span>);  <span class="comment">//轮询文件是否可操作，超时3000ms</span></span><br><span class="line">    <span class="keyword">if</span>(!ret)&#123;  <span class="comment">//超时</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;time out !!\n,&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(fds[<span class="number">0</span>].revents == POLLIN) <span class="comment">//如果返回事件是有数据可读取</span></span><br><span class="line">    &#123;</span><br><span class="line">        read(fd,buf1,<span class="keyword">sizeof</span>(buf1));  <span class="comment">//从/dev/test文件读取数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf is %s \n,&quot;</span>,buf1); <span class="comment">//打印读取的数据</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read after\n&quot;</span>);</span><br><span class="line">close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码第16行，在打开设备节点时不使用非阻塞方式，要使用阻塞方式，所以改为O_RDWR。</p>
<p>在上述代码的第28行，使用poll函数监视并等待多个文件描述符的属性变化。poll函数第一个参数是被监视的文件描述符，是pollfd结构体类型的数组，所以在14行定义了pollfd结构体类型的数组fds。poll函数第2个参数是要监视的文件描述符数量，这里监视的文件描述符为1个。poll函数第3个参数是指定等待的时间 3000ms。</p>
<p>然后编写应用程序write.c，实现向设备文件写入数据的功能，编写好的write.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR);  <span class="comment">//打开/dev/test设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write before \n&quot;</span>);</span><br><span class="line">    write(fd,buf2,<span class="keyword">sizeof</span>(buf2));  <span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;write after\n&quot;</span>);</span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="28-2-2-驱动程序编写"><a href="#28-2-2-驱动程序编写" class="headerlink" title="28.2.2 驱动程序编写"></a>28.2.2 驱动程序编写</h3><p>本实验对应的驱动程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\22\module。</p>
<p>IO多路复用实验需要应用程序和驱动程序进行配合，接下来编写驱动程序。编写好的驱动程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span>  flag;  <span class="comment">//标志位</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  </span><br><span class="line">DECLARE_WAIT_QUEUE_HEAD(read_wq); <span class="comment">//定义并初始化等待队列头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test_dev-&gt;flag=<span class="number">1</span>;</span><br><span class="line">    wake_up_interruptible(&amp;read_wq);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span>(file-&gt;f_flags &amp; O_NONBLOCK )&#123;</span><br><span class="line">        <span class="keyword">if</span> (test_dev-&gt;flag !=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    &#125;</span><br><span class="line">    wait_event_interruptible(read_wq,test_dev-&gt;flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span>  <span class="type">__poll_t</span>  <span class="title function_">cdev_test_poll</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> poll_table_struct *p)</span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;  <span class="comment">//设置私有数据</span></span><br><span class="line">     <span class="type">__poll_t</span> mask=<span class="number">0</span>;    </span><br><span class="line">     poll_wait(file,&amp;read_wq,p);     <span class="comment">//应用阻塞</span></span><br><span class="line">     <span class="keyword">if</span> (test_dev-&gt;flag == <span class="number">1</span>)    </span><br><span class="line">     &#123;</span><br><span class="line">         mask |= POLLIN; </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> mask; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">    .poll = cdev_test_poll,  <span class="comment">//将poll字段指向chrdev_poll(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>首先在第9行代码添加&lt;linux&#x2F;poll.h&gt;头文件。然后在第94行将poll字段指向chrdev_poll(…)函数，最后在73行到84行编写这个函数。</p>
<h2 id="28-3-运行测试"><a href="#28-3-运行测试" class="headerlink" title="28.3 运行测试"></a>28.3 运行测试</h2><h3 id="28-3-1-编译驱动程序"><a href="#28-3-1-编译驱动程序" class="headerlink" title="28.3.1 编译驱动程序"></a>28.3.1 编译驱动程序</h3><p>在上一小节中的poll.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += poll.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放poll.c和Makefile文件目录下，如下图（图 28-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps201.jpg" alt="img"> </p>
<p>图 28-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 28-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps202.jpg" alt="img"> </p>
<p>图 28-2</p>
<p>编译完生成poll.ko目标文件，如下图（图 28-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps203.jpg" alt="img"></p>
<p>图 28-3</p>
<p>至此驱动模块就编译成功了，下面进行应用程序read.c和write.c的编译。</p>
<h3 id="28-3-2-编译应用程序"><a href="#28-3-2-编译应用程序" class="headerlink" title="28.3.2 编译应用程序"></a>28.3.2 编译应用程序</h3><p>来到存放应用程序read.c和write.c的文件夹下，使用以下命令对read.c和write.c进行交叉编译，编译完成如下图（图 28-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o read read.c -static</p>
<p>aarch64-linux-gnu-gcc -o write write.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps204.jpg" alt="img"> </p>
<p>图 28-4</p>
<p>生成的read write文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="28-3-3-测试"><a href="#28-3-3-测试" class="headerlink" title="28.3.3 测试"></a>28.3.3 测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 28-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps205.jpg" alt="img"></p>
<p>图 28-5</p>
<p>在加载驱动程序之后，会生成如下图（图 28-6）所示的设备节点，在应用程序中也是操作这个设备节点。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps206.jpg" alt="img"></p>
<p>图 28-6</p>
<p>首先运行read可执行程序，如下（图 28-7）所示，在三秒钟以后打印“time out”。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps207.jpg" alt="img"></p>
<p>图 28-7</p>
<p>然后运行write可执行程序写入数据，如下（图 28-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps208.jpg" alt="img"></p>
<p>图 28-8</p>
<p>接着可以看到read读取到了数据，如下（图 28-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps209.jpg" alt="img"></p>
<p>图 28-9</p>
<h1 id="第29章-信号驱动IO实验"><a href="#第29章-信号驱动IO实验" class="headerlink" title="第29章 信号驱动IO实验"></a>第29章 信号驱动IO实验</h1><p>本章节要讲解的信号驱动IO是最后一个IO模型，在第25章中我们已经对信号驱动IO有了基本的认识，本章节将对信号驱动IO进行深入的学习，最后通过相应的实验，来加深对信号驱动IO的理解。</p>
<h2 id="29-1-信号驱动IO简介"><a href="#29-1-信号驱动IO简介" class="headerlink" title="29.1 信号驱动IO简介"></a>29.1 信号驱动IO简介</h2><p>信号驱动IO不需要应用程序查询设备的状态，一旦设备准备就绪，会触发SIGIO信号，进而调用注册的处理函数。仍旧以钓鱼为例。小马同学喜欢吃新鲜的鱼，但是不想自己钓，所以他请了一个助手来帮他钓鱼，他自己去忙其他的事情（进程不阻塞，立即返回）。如果有鱼上钩助手会帮忙钓上来（将数据拷贝到指定的缓冲区），并立即通知小马同学回来把鱼取走（处理数据）。</p>
<p>如果要实现信号驱动IO，需要应用程序和驱动程序配合，应用程序使用信号驱动IO的步骤有三步：</p>
<p>步骤1 ：注册信号处理函数 应用程序使用signal函数来注册SIGIO信号的信号处理函数。</p>
<p>步骤2： 设置能够接收这个信号的进程</p>
<p>步骤3： 开启信号驱动IO 通常使用fcntl函数的F_SETFL命令打开FASYNC标志。</p>
<p>fcntl函数如下所示：</p>
<p>****函数原型****： </p>
<p>int fcntl(int fd,int cmd, …)</p>
<p>****函数功能****： </p>
<p>fcntl函数可以用来操作文件描述符</p>
<p><em><strong>*函数参数*</strong></em>:</p>
<p>fd: 被操作的文件描述符</p>
<p>cmd: 操作文件描述符的命令，cmd参数决定了要如何操作文件描述符fd</p>
<p>…: 根据cmd的参数来决定是不是需要使用第三个参数</p>
<p>操作文件描述符的命令如下表（表 29-1）所示：</p>
<table>
<thead>
<tr>
<th>命令名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>F_DUPFD</td>
<td>复制文件描述符</td>
</tr>
<tr>
<td>F_GETFD</td>
<td>获取文件描述符标志</td>
</tr>
<tr>
<td>F_SETFD</td>
<td>设置文件描述符标志</td>
</tr>
<tr>
<td>F_GETFL</td>
<td>获取文件状态标志</td>
</tr>
<tr>
<td>F_SETFL</td>
<td>设置文件状态标志</td>
</tr>
<tr>
<td>F_GETLK</td>
<td>获取文件锁</td>
</tr>
<tr>
<td>F_SETLK</td>
<td>设置文件锁</td>
</tr>
<tr>
<td>F_SETLKW</td>
<td>类似F_SETLK，但等待返回</td>
</tr>
<tr>
<td>F_GETOWN</td>
<td>获取当前接收SIGIO和SIGURG信号的进程ID和进程组ID</td>
</tr>
<tr>
<td>F_SETOWN</td>
<td>设置当前接收SIGIO和SIGURG信号的进程ID和进程组ID</td>
</tr>
</tbody></table>
<p>表 29-2</p>
<p>接下来学习驱动程序实现fasync方法</p>
<p>步骤1 </p>
<p>当应用程序开启信号驱动IO时，会触发驱动中的fasync函数。所以首先在file_operations结构体中实现fasync函数，函数原型如下：</p>
<p>int (*fasync) (int fd,struct file *filp,int on)</p>
<p>步骤2</p>
<p>在驱动中的fasync函数调用fasync_helper函数来操作fasync_struct结构体，fasync_helper函数原型如下：</p>
<p>int fasync_helper(int fd,struct file *filp,int on,struct fasync_struct **fapp)</p>
<p>步骤3：</p>
<p>当设备准备好的时候，驱动程序需要调用kill_fasync函数通知应用程序，此时应用程序的SIGIO信号处理函数就会被执行。kill_fasync负责发送指定的信号，函数原型如下：</p>
<p>void kill_fasync(struct fasync_struct **fp,int sig,int band)</p>
<p><em><strong>*函数参数：*</strong></em></p>
<p>fp: 要操作的fasync_struct</p>
<p>sig: 发送的信号</p>
<p>band: 可读的时候设置成POLLIN ，可写的时候设置成POLLOUT</p>
<h2 id="29-2-实验程序编写"><a href="#29-2-实验程序编写" class="headerlink" title="29.2 实验程序编写"></a>29.2 实验程序编写</h2><h3 id="29-2-1-编写测试-APP"><a href="#29-2-1-编写测试-APP" class="headerlink" title="29.2.1 编写测试 APP"></a>29.2.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\23\app。</p>
<p>编写应用程序write.c，在此代码中，调用write函数向&#x2F;dev&#x2F;test设备写入数据“nihao”。编写好的程序如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    char buf1[32] = &#123;0&#125;;   </span><br><span class="line">    char buf2[32] = &quot;nihao&quot;;</span><br><span class="line">    fd = open(&quot;/dev/test&quot;,O_RDWR);  //打开/dev/test设备</span><br><span class="line">    if (fd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;open error \n&quot;);</span><br><span class="line">        return fd;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;write before \n&quot;);</span><br><span class="line">    write(fd,buf2,sizeof(buf2));  //向/dev/test文件写入数据</span><br><span class="line">    printf(&quot;write after\n&quot;);</span><br><span class="line">    close(fd);     //关闭文件</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后来编写应用程序read.c，在此代码中要使用信号驱动IO读取数据。编写好的应用程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//SIGIO信号的信号处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> signum)</span></span><br><span class="line">&#123;</span><br><span class="line">    read(fd,buf1,<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;buf is %s\n&quot;</span>,buf1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">       fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开led驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signal(SIGIO,func);  <span class="comment">//步骤一：使用signal函数注册SIGIO信号的信号处理函数</span></span><br><span class="line">     <span class="comment">//步骤二：设置能接收这个信号的进程</span></span><br><span class="line">     <span class="comment">//fcntl函数用来操作文件描述符，</span></span><br><span class="line">     <span class="comment">//F_SETOWN 设置当前接收的SIGIO的进程ID</span></span><br><span class="line">     fcntl(fd,F_SETOWN,getpid()); </span><br><span class="line"></span><br><span class="line">    flags = fcntl(fd,F_GETFD); <span class="comment">//获取文件描述符标志</span></span><br><span class="line">    <span class="comment">//步骤三  开启信号驱动IO 使用fcntl函数的F_SETFL命令打开FASYNC标志</span></span><br><span class="line">    fcntl(fd,F_SETFL,flags| FASYNC);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);    </span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="29-2-2-驱动程序编写"><a href="#29-2-2-驱动程序编写" class="headerlink" title="29.2.2 驱动程序编写"></a>29.2.2 驱动程序编写</h3><p>本实验对应的驱动程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\23\module。</p>
<p>接下来编写驱动程序，在29.1小节中介绍了驱动程序中实现fasync方法的三个步骤，按照这个思路，依次实现这三步，编写好的驱动程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span>  flag;  <span class="comment">//标志位</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  </span><br><span class="line"></span><br><span class="line">DECLARE_WAIT_QUEUE_HEAD(read_wq); <span class="comment">//定义并初始化等待队列头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test_dev-&gt;flag=<span class="number">1</span>;</span><br><span class="line">    wake_up_interruptible(&amp;read_wq);</span><br><span class="line">    kill_fasync(&amp;test_dev-&gt;fasync,SIGIO,POLLIN);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span>(file-&gt;f_flags &amp; O_NONBLOCK )&#123;</span><br><span class="line">        <span class="keyword">if</span> (test_dev-&gt;flag !=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    &#125;</span><br><span class="line">    wait_event_interruptible(read_wq,test_dev-&gt;flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span>  <span class="type">__poll_t</span>  <span class="title function_">cdev_test_poll</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> poll_table_struct *p)</span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;  <span class="comment">//设置私有数据</span></span><br><span class="line">     <span class="type">__poll_t</span> mask=<span class="number">0</span>;    </span><br><span class="line">     poll_wait(file,&amp;read_wq,p);     <span class="comment">//应用阻塞</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (test_dev-&gt;flag == <span class="number">1</span>)    </span><br><span class="line">     &#123;</span><br><span class="line">         mask |= POLLIN;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> mask;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_fasync</span> <span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;  <span class="comment">//设置私有数据</span></span><br><span class="line">    <span class="keyword">return</span>  fasync_helper(fd,file,on,&amp;test_dev-&gt;fasync);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">    .poll = cdev_test_poll,  <span class="comment">//将poll字段指向chrdev_poll(...)函数</span></span><br><span class="line">    .fasync = cdev_test_fasync,   <span class="comment">//将fasync字段指向cdev_test_fasync(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="29-3-运行测试"><a href="#29-3-运行测试" class="headerlink" title="29.3 运行测试"></a>29.3 运行测试</h2><h3 id="29-3-1-编译程序"><a href="#29-3-1-编译程序" class="headerlink" title="29.3.1 编译程序"></a>29.3.1 编译程序</h3><p>在上一小节中的fasync.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m +=fasync.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放fasync.c.c和Makefile文件目录下，如下图（图 29-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps210.jpg" alt="img"> </p>
<p>图 29-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图29-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps211.jpg" alt="img"> </p>
<p>图 29-3</p>
<p>编译完生成fasync.ko目标文件，如下图（图 29-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps212.jpg" alt="img"> </p>
<p>图 29-4</p>
<p>至此驱动模块就编译成功了，下面进行交叉编译应用程序。</p>
<h3 id="29-3-2-编译应用程序"><a href="#29-3-2-编译应用程序" class="headerlink" title="29.3.2 编译应用程序"></a>29.3.2 编译应用程序</h3><p>来到存放应用程序read.c和write.c的文件夹下，使用以下命令对read.c和write.c进行交叉编译，编译完成如下图（图 29-5）所示：</p>
<p>aarch64-linux-gnu-gcc -o read read.c -static</p>
<p>aarch64-linux-gnu-gcc -o write write.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps213.jpg" alt="img"> </p>
<p>图 29-5</p>
<p>生成的read write文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="29-3-3-测试"><a href="#29-3-3-测试" class="headerlink" title="29.3.3 测试"></a>29.3.3 测试</h3><p>输入以下命令加载驱动程序。</p>
<p>insmod fasync.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps214.jpg" alt="img"></p>
<p>图 29-6</p>
<p>输入以下命令运行read应用程序，如下图（图 29-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps215.jpg" alt="img"></p>
<p>图 29-7</p>
<p>然后输入以下命令运行write应用程序，如下图（图 29-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps216.jpg" alt="img"></p>
<p>图 29-8</p>
<p>如下图（图29-9）所示，read程序窗口打印读取的数据。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps217.jpg" alt="img"></p>
<p>图 29-9</p>
<h1 id="第30章-定时器实验"><a href="#第30章-定时器实验" class="headerlink" title="第30章 定时器实验"></a>第30章 定时器实验</h1><p>在Linux内核中很多函数是基于定时器进行驱动的，所以时间管理在内核中占有非常重要的地位。本小节将对Linux中的时间管理相关知识进行学习.</p>
<h2 id="30-1-Linux定期器"><a href="#30-1-Linux定期器" class="headerlink" title="30.1 Linux定期器"></a>30.1 Linux定期器</h2><p>硬件为内核提供了一个系统定时器来计算流逝的时间（即基于未来时间点的计时方式，以当前时刻为计时开始的起点，以未来的某一时刻为计时的终点），内核只有在系统定时器的帮助下才能计算和管理时间，但是内核定时器的精度并不高，所以不能作为高精度定时器使用。并且内核定时器的运行没有周期性，到达计时终点后会自动关闭。如果要实现周期性定时，就要在定时处理函数中重新开启定时器。</p>
<p>Linux内核中使用timer_list 结构体表示内核定时器，该结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;timer.h”文件中，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct timer_list &#123;</span><br><span class="line">    struct hlist_node   entry;</span><br><span class="line">    unsigned long       expires;/* 定时器超时时间，单位是节拍数 */</span><br><span class="line">    void            (*function)(struct timer_list *);/* 定时处理函数 */</span><br><span class="line">    u32         flags;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_LOCKDEP</span><br><span class="line">    struct lockdep_map  lockdep_map;</span><br><span class="line">#endif</span><br><span class="line">    ANDROID_KABI_RESERVE(1);</span><br><span class="line">    ANDROID_KABI_RESERVE(2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用以下宏对timer_list结构体进行定义，_name为定义的结构体名称，_function为定时处理函数，该宏同样定义在文件 “内核源码&#x2F;include&#x2F;linux&#x2F;timer.h”文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_TIMER(_name, _function)              \</span></span><br><span class="line"><span class="meta">struct timer_list _name =               \</span></span><br><span class="line"><span class="meta">    __TIMER_INITIALIZER(_function, 0)     </span></span><br></pre></td></tr></table></figure>

<p>例如可以使用以下代码对定时器和相应的定时处理函数进行定义 </p>
<p>DEFINE_TIMER(timer_test,function_test);&#x2F;&#x2F;定义一个定时器</p>
<p>定时器定义完成之后还需要通过一系列的 API 函数来初始化此定时器，部分函数说明如下(表30-1)所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void add_timer(struct timer_list *timer)</td>
<td>向 Linux 内核注册定时器，使用 add_timer 函数向内核注册定时器以后，定时器就会开始运行</td>
</tr>
<tr>
<td>int del_timer(struct timer_list * timer)</td>
<td>删除一个定时器</td>
</tr>
<tr>
<td>int mod_timer(struct timer_list *timer,unsigned long expires)</td>
<td>修改定时值，如果定时器还没有激活的话，mod_timer 函数会激活定时器</td>
</tr>
</tbody></table>
<p>表 	30-1</p>
<p>在使用add_timer()函数向 Linux 内核注册定时器之前，还需要设置定时时间，定时时间由timer_list结构体中的expires参数所确定，单位为节拍数，可以通过图形化界面设置系统节拍的频率，具体路径如下图(图 30-2)所示：</p>
<p>-&gt; Kernel Features</p>
<p>-&gt; Timer frequency (<choice> [&#x3D;y])</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps218.jpg" alt="img"> </p>
<p>图 30-2</p>
<p>​	从上图可以看出可选的系统节拍率为 100Hz、250Hz、300Hz和 1000Hz，默认情况下选择 300Hz。</p>
<p>通过全局变量jiffies来记录自系统启动以来产生节拍的总数。启动时，内核将该变量初始化为0，此后，每次时钟中断处理程序都会增加该变量的值，一秒内jiffes增加的值为设置的系统节拍数，该变量定义在”内核源码&#x2F;include&#x2F;linux&#x2F;jiffies.h”文件中（timer.h文件中已经包含，不需要重复引用），具体定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern u64 __cacheline_aligned_in_smp jiffies_64;</span><br><span class="line">extern unsigned long volatile __cacheline_aligned_in_smp __jiffy_arch_data jiffies;</span><br></pre></td></tr></table></figure>

<p>​	其中jiffies_64用于64位系统，而jiffies用于 32 位系统。为了方便开发，Linux 内核还提供了几个jiffies和ms、us、ns之间的转换函数，如下(表 30-2)所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>int jiffies_to_msecs(const unsigned long j)</td>
<td>将 jiffies 类型的参数 j 分别转换为对应的毫秒</td>
</tr>
<tr>
<td>int jiffies_to_usecs(const unsigned long j)</td>
<td>将 jiffies 类型的参数 j 分别转换为对应的微秒</td>
</tr>
<tr>
<td>u64 jiffies_to_nsecs(const unsigned long j)</td>
<td>将 jiffies 类型的参数 j 分别转换为对应的纳秒</td>
</tr>
<tr>
<td>long msecs_to_jiffies(const unsigned int m)</td>
<td>将毫秒转换为 jiffies 类型</td>
</tr>
<tr>
<td>long usecs_to_jiffies(const unsigned int u)</td>
<td>将微秒转换为 jiffies 类型</td>
</tr>
<tr>
<td>unsigned long nsecs_to_jiffies(u64 n)</td>
<td>将纳秒转换为 jiffies 类型</td>
</tr>
</tbody></table>
<p>表 30-3</p>
<p>​	例如可以使用以下命令进行3秒钟的定时：</p>
<p>timer_test.expires &#x3D; jiffies_64 +msecs_to_jiffies(3000) </p>
<p>至此关于Linux定时器相关的知识就讲解完成了，在下个小节中将进行相应的实验。</p>
<h2 id="30-2-实验程序编写"><a href="#30-2-实验程序编写" class="headerlink" title="30.2 实验程序编写"></a>30.2 实验程序编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\24\module。</p>
<p>本实验将实现五秒钟的计时，五秒钟之后将打印“this is function test”相关字符，为了实现循环打印还需要在定时处理函数中使用mod_timer函数重新设置定时时间。</p>
<p> 编写好的驱动程序timer_mod.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">function_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span>;<span class="comment">//定义function_test定时功能函数</span></span><br><span class="line">DEFINE_TIMER(timer_test,function_test);<span class="comment">//定义一个定时器</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">function_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;this is function test \n&quot;</span>);</span><br><span class="line">	mod_timer(&amp;timer_test,jiffies_64 + msecs_to_jiffies(<span class="number">5000</span>));<span class="comment">//使用mod_timer函数将定时时间设置为五秒后</span></span><br><span class="line">&#125;	</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_mod_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">	timer_test.expires = jiffies_64 + msecs_to_jiffies(<span class="number">5000</span>);<span class="comment">//将定时时间设置为五秒后</span></span><br><span class="line">	add_timer(&amp;timer_test);<span class="comment">//添加一个定时器</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_mod_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">	del_timer(&amp;timer_test);<span class="comment">//删除一个定时器</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_mod_init);</span><br><span class="line">module_exit(timer_mod_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="30-3-运行测试"><a href="#30-3-运行测试" class="headerlink" title="30.3 运行测试"></a>30.3 运行测试</h2><h3 id="30-3-1-编译驱动程序"><a href="#30-3-1-编译驱动程序" class="headerlink" title="30.3.1 编译驱动程序"></a>30.3.1 编译驱动程序</h3><p>在上一小节中的timer_mod.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m += timer_mod.o    #此处要和你的驱动源文件同名</span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    #make操作</span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    #make clean操作</span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放timer_mod.c和Makefile文件目录下，如下图()所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps219.jpg" alt="img"> </p>
<p>图 30-4</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图30-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps220.jpg" alt="img"> </p>
<p>图30-5</p>
<p>编译完生成 timer_mod.ko目标文件，如下图（图 30-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps221.jpg" alt="img"> </p>
<p>图 30-6</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="30-3-2-运行测试"><a href="#30-3-2-运行测试" class="headerlink" title="30.3.2 运行测试"></a>30.3.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 30-7）所示：</p>
<p>insmod timer_mod.ko </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps222.jpg" alt="img"> </p>
<p>图 30-7</p>
<p>可以看到驱动加载之后，每隔五秒钟会打印“this is function test”相关打印，证明编写的驱动程序没有问题，最后使用以下命令卸载相应的驱动，如下图（图30-8）所示：</p>
<p>rmmod timer_mod.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps223.jpg" alt="img"> </p>
<p>图 30-8</p>
<h1 id="第31章-秒字符设备驱动实验"><a href="#第31章-秒字符设备驱动实验" class="headerlink" title="第31章 秒字符设备驱动实验"></a>第31章 秒字符设备驱动实验</h1><p>本章节将实现秒字符设备驱动，以此对之前学习到的知识进行巩固。本章节实验要实现的任务如下：</p>
<p>\1. 实现字符设备驱动框架，自动生成设备节点。</p>
<p>\2. 根据上一小节学到的知识，实现秒计时。</p>
<p>\3. 通过原子变量来记录递增的秒数，避免竞争的发生。</p>
<p>\4. 通过用户空间和内核空间的数据交换，将记录的秒数传递到应用空间，并通过应用程序打印出来。</p>
<h2 id="31-1-实验程序编写"><a href="#31-1-实验程序编写" class="headerlink" title="31.1 实验程序编写"></a>31.1 实验程序编写</h2><h3 id="31-1-1-编写测试-APP"><a href="#31-1-1-编写测试-APP" class="headerlink" title="31.1.1 编写测试 APP"></a>31.1.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\25\app。</p>
<p>首先来编写应用测试代码timer.c，在此代码中每隔一秒钟打印从用户空间传递来的秒数，具体代码内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符fd</span></span><br><span class="line">	<span class="type">int</span> count;<span class="comment">//定义int类型记录秒数的变量count</span></span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR);<span class="comment">//使用open()函数以可读可写的方式打开设备文件</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		read(fd,&amp;count,<span class="keyword">sizeof</span>(count));<span class="comment">//使用read函数读取内核传递来的秒数</span></span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;num is %d\n&quot;</span>,count);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="31-1-2-驱动程序编写"><a href="#31-1-2-驱动程序编写" class="headerlink" title="31.1.2 驱动程序编写"></a>31.1.2 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\25\module。</p>
<p> 编写好的驱动程序timer_dev.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">	<span class="type">int</span> sec; <span class="comment">//秒</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">atomic64_t</span> v = ATOMIC_INIT(<span class="number">0</span>);<span class="comment">//定义原子类型变量v，并定义为0</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">function_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span>;<span class="comment">//定义function_test定时功能函数</span></span><br><span class="line">DEFINE_TIMER(timer_test,function_test);<span class="comment">//定义一个定时器</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">function_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span></span><br><span class="line">&#123;</span><br><span class="line">	atomic64_inc(&amp;v);<span class="comment">//原子变量v自增</span></span><br><span class="line">	dev1.sec = <span class="type">atomic_read</span>(&amp;v);<span class="comment">//将读取到的原子变量v,赋值给sec</span></span><br><span class="line">	<span class="comment">//printk(&quot;the sec is %d\n&quot;,dev1.sec);</span></span><br><span class="line">	mod_timer(&amp;timer_test,jiffies_64 + msecs_to_jiffies(<span class="number">1000</span>));<span class="comment">//使用mod_timer函数将定时时间设置为一秒后</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">	add_timer(&amp;timer_test);	<span class="comment">//添加一个定时器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(copy_to_user(buf,&amp;dev1.sec,<span class="keyword">sizeof</span>(dev1.sec)))&#123;<span class="comment">//使用copy_to_user函数将sec传递到应用层</span></span><br><span class="line">		printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	del_timer(&amp;timer_test);<span class="comment">//删除一个定时器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_dev_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  	dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_dev_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_dev_init);</span><br><span class="line">module_exit(timer_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="31-2-运行测试"><a href="#31-2-运行测试" class="headerlink" title="31.2 运行测试"></a>31.2 运行测试</h2><h3 id="31-2-1-编译驱动程序"><a href="#31-2-1-编译驱动程序" class="headerlink" title="31.2.1 编译驱动程序"></a>31.2.1 编译驱动程序</h3><p>在上一小节中的timer_dev.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += timer_dev.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放timer_dev.c和Makefile文件目录下，如下图（图31-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps224.jpg" alt="img"> </p>
<p>图31-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 31-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps225.jpg" alt="img"> </p>
<p>图 31-2</p>
<p>编译完生成 timer_dev.ko目标文件，如下图（图 31-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps226.jpg" alt="img"> </p>
<p>图 31-3</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="31-2-2-编译应用程序"><a href="#31-2-2-编译应用程序" class="headerlink" title="31.2.2 编译应用程序"></a>31.2.2 编译应用程序</h3><p>然后来到存放应用程序timer.c的文件夹下，使用以下命令对timer.c进行交叉编译，编译完成如下图（图 31-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o timer timer.c</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps227.jpg" alt="img"> </p>
<p>图 31-4</p>
<p>生成的timer文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="31-2-3-运行测试"><a href="#31-2-3-运行测试" class="headerlink" title="31.2.3 运行测试"></a>31.2.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 31-5）所示：</p>
<p>insmod timer_dev.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps228.jpg" alt="img"> </p>
<p>图 31-5</p>
<p>然后输入以下命令进行可执行程序的运行，如下图（图 31-6）所示：</p>
<p>.&#x2F;timer</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps229.jpg" alt="img"> </p>
<p>图 31-6</p>
<p>可以看到每隔一秒钟就会打印由内核空间传递来的秒数，我们要实现的任务就完成了，最后使用以下命令卸载对应的驱动，如下图（图 31-7）所示：</p>
<p>rmmod timer_dev</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps230.jpg" alt="img"> </p>
<p>图 31-7</p>
<p>第32章 Linux内核打印实验 </p>
<p>本手册的实验都是在buildroot系统上完成的，由于buildroot系统已经设置了相应的打印等级，所以驱动的相关打印都能正常显示在串口终端上，如果将实验系统换成了ubuntu，然后加载同样的驱动，会发现打印信息不见了，这一现象的基本原因就是内核打印等级不同，那打印等级是如何修改的呢，查看打印等级的方式又有哪些呢，就让我们进入本章节的学习吧！</p>
<h2 id="32-1-方法一：dmseg-命令"><a href="#32-1-方法一：dmseg-命令" class="headerlink" title="32.1 方法一：dmseg 命令"></a>32.1 方法一：dmseg 命令</h2><p>在终端使用dmseg命令可以获取内核打印信息，该命令的具体使用方法如下所示：</p>
<p>dmesg命令</p>
<p>****英文全称：****display message（显示信息）</p>
<p><em><strong>*作用*</strong></em>****：****kernel 会将打印信息存储在 ring <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=buffer&spm=1001.2101.3001.7020">buffer</a> 中。可以利用 dmesg命令来查看内核打印信息。。</p>
<p><em><strong>*常用参数:*</strong></em></p>
<p>-C，–clear清除内核环形缓冲区</p>
<p>-c，—-read-clear读取并清除所有消息</p>
<p>-T，–显示时间戳</p>
<p>****提示：****dmesg命令也可以与grep命令组合使用。如查找待用usb关键字的打印信息，就可以使用如下命令:dmseg | grep usb</p>
<p>首先在串口终端使用“dmseg”命令，可以看见相应的内核打印信息已经加载了出来，如下图（图 32-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps231.jpg" alt="img"> </p>
<p>图 32-1</p>
<p>然后使用以下组合命令查找nfs相关的打印信息，如下图（图 32-2）所示：</p>
<p>dmesg | grep nfs</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps232.jpg" alt="img"> </p>
<p>图 32-2</p>
<p>至此关于dmesg命令就讲解演示完成了。</p>
<h2 id="32-2-方法二：查看kmsg文件"><a href="#32-2-方法二：查看kmsg文件" class="headerlink" title="32.2 方法二：查看kmsg文件"></a>32.2 方法二：查看kmsg文件</h2><p>内核所有的打印信息都会输出到循环缓冲区 ‘log_buf’，为了能够方便的在用户空间读取 内核打印信息，Linux内核驱动将该循环缓冲区映射到了&#x2F;proc目录下的文件节点kmsg。通过 cat或者其他应用程序读取Log Buffer的时候可以不断的等待新的log，所以访问&#x2F;proc&#x2F;kmsg 的方式适合长时间的读取log，一旦有新的log就可以被打印出来。</p>
<p>首先使用以下命令读取kmsg文件，在没有新的内核打印信息时会阻塞，如下图（图 32-3）所示：</p>
<p>cat &#x2F;proc&#x2F;kmsg</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps233.jpg" alt="img"> </p>
<p>图 32-3</p>
<p>然后在该设备的其他终端加载任意有打印信息的驱动文件（这里使用的是ssh），如下图（图 32-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps234.jpg" alt="img"> </p>
<p>图 32-4</p>
<p>在串口终端中可以看到对应驱动的打印信息就被打印了出来，如下图（图 32-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps235.jpg" alt="img"> </p>
<p>图 32-5</p>
<h2 id="32-3-方法三：调整内核打印等级"><a href="#32-3-方法三：调整内核打印等级" class="headerlink" title="32.3 方法三：调整内核打印等级"></a>32.3 方法三：调整内核打印等级</h2><p>内核的日志打印由相应的打印等级来控制，可以通过调整内核打印等级来控制打印日志的输出。使用以下命令查看当前默认打印等级，如下图（图 32-6）所示:</p>
<p>cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;printk</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps236.jpg" alt="img"> </p>
<p>图 32-6</p>
<p>可以看到内核打印等级由四个数字所决定，“7 4 1 7” 分别对应console_loglevel、default_message_loglevel、minimum_c onsole_loglevel、default_console_loglevel，具体类型说明如下表（表 32-7）所示：</p>
<table>
<thead>
<tr>
<th>终端打印类型</th>
<th>对应类型说明</th>
</tr>
</thead>
<tbody><tr>
<td>console_loglevel</td>
<td>只有当printk打印消息的log优先级高于console_loglevel时，才能输出到终端上</td>
</tr>
<tr>
<td>default_message_loglevel</td>
<td>printk打印消息时默认的log等级</td>
</tr>
<tr>
<td>minimum_console_loglevel</td>
<td>console_loglevel可以被设置的最小值</td>
</tr>
<tr>
<td>default_console_loglevel</td>
<td>console_loglevel的缺省值</td>
</tr>
</tbody></table>
<p>表 32-7</p>
<p>上面的“7 4 1 7”意味着只有优先级高于KERN_DEBUG(7)的打印消息才能输出到终端，在“内核源码&#x2F;include&#x2F;linux&#x2F;kern_levels.h”文件中对于文件打印等级进行了如下打印等级定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_EMERG  KERN_SOH <span class="string">&quot;0&quot;</span>    <span class="comment">/* system is unusable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ALERT  KERN_SOH <span class="string">&quot;1&quot;</span>    <span class="comment">/* action must be taken immediately */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_CRIT   KERN_SOH <span class="string">&quot;2&quot;</span>    <span class="comment">/* critical conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ERR    KERN_SOH <span class="string">&quot;3&quot;</span>    <span class="comment">/* error conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_WARNING    KERN_SOH <span class="string">&quot;4&quot;</span>    <span class="comment">/* warning conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_NOTICE KERN_SOH <span class="string">&quot;5&quot;</span>    <span class="comment">/* normal but significant condition */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_INFO   KERN_SOH <span class="string">&quot;6&quot;</span>    <span class="comment">/* informational */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_DEBUG  KERN_SOH <span class="string">&quot;7&quot;</span>    <span class="comment">/* debug-level messages */</span></span></span><br></pre></td></tr></table></figure>

<p>printk在打印信息前，可以加入相应的打印等级宏定义，具体格式如下所示：</p>
<p>printk(打印等级 “打印信息”)</p>
<p>接下来将使用以下驱动例程进行实际的打印等级测试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot; 0000 KERN_EMERG\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot; 1111 KERN_ALERT\n&quot;</span>);</span><br><span class="line">    printk(KERN_CRIT <span class="string">&quot; 2222 KERN_CRIT\n&quot;</span>);</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot; 3333 KERN_ERR\n&quot;</span>);</span><br><span class="line">    printk(KERN_WARNING <span class="string">&quot; 4444 KERN_WARNING\n&quot;</span>);</span><br><span class="line">    printk(KERN_NOTICE <span class="string">&quot; 5555 KERN_NOTICE\n&quot;</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot; 6666 KERN_INFO\n&quot;</span>);</span><br><span class="line">    printk(KERN_DEBUG <span class="string">&quot; 7777 KERN_DEBUG\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot; 8888 no_fix\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);</span><br><span class="line">module_exit(helloworld_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>加载该驱动之后，第5-11行0-6等级的打印信息就被打印了出来，第13行由于没有设置打印等级，所以会被赋予默认打印等级4，高于console_loglevel打印等级，所以也会被打印出来，最后只有第12行打印等级为7的信息，和console_loglevel打印等级相同，所以不会被打印出来，如下图（图 32-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps237.jpg" alt="img"> </p>
<p>图 32-8</p>
<p>然后使用以下命令将console_loglevel打印等级设置为4，如下图（图 32-9）所示：</p>
<p>echo 4 4 1 7 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;printk</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps238.jpg" alt="img"> </p>
<p>图 32-9</p>
<p>卸载驱动之后，再一次加载驱动，发现只有打印等级高于4的相关信息被打印了出来，如下图（图32-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps239.jpg" alt="img"> </p>
<p>图32-10</p>
<p>至此关于内核打印等级的实验就结束了。</p>
<h1 id="第33章llseek定位设备驱动实验"><a href="#第33章llseek定位设备驱动实验" class="headerlink" title="第33章llseek定位设备驱动实验"></a>第33章llseek定位设备驱动实验</h1><p>相信经过了前面章节的学习，大家已经对内核空间与用户空间的数据交互很是熟悉，但在之前的例子中都是对字符串的全部内容进行读写，假如现在有这样一个场景，将两个字符串依次进行写入，并对写入完成的字符串进行读取，如果仍采用之前的方式，第二次的写入值会覆盖第一次写入值，那要如何来实现上述功能呢？这就要轮到llseek出场了。</p>
<h2 id="33-1-定位设备llseek"><a href="#33-1-定位设备llseek" class="headerlink" title="33.1 定位设备llseek"></a>33.1 定位设备llseek</h2><h3 id="33-1-1-lseek函数的使用"><a href="#33-1-1-lseek函数的使用" class="headerlink" title="33.1.1 lseek函数的使用"></a>33.1.1 lseek函数的使用</h3><p>在应用程序中使用lseek函数进行读写位置的调整，该函数的具体使用说明如下所示：</p>
<p>lseek函数</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>​    off_t lseek(int fd, off_t offset, int whence);</p>
<p>****头文件****：</p>
<p>​    #include &lt;sys&#x2F;types.h&gt;</p>
<p>​    #include &lt;unistd.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>移动文件的读写位置。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>fd:	文件描述符；</p>
<p>off_t offset:	偏移量，单位是字节的数量，可以正负，如果是负值表示向前移动；如果是正值，表示向后移动。</p>
<p>whence：当前位置的基点，可以使用以下三组值。</p>
<p>​				SEEK_SET：相对于文件开头</p>
<p>​				SEEK_CUR:相对于当前的文件读写指针位置</p>
<p>​				SEEK_END:相对于文件末尾</p>
<p>****函数返回值：****成功返回当前位移大小，失败返回-1</p>
<p>函数使用示例：</p>
<p>把文件位置指针设置为5：	</p>
<p>lseek(fd,5,SEEK_SET);</p>
<p>把文件位置设置成文件末尾： </p>
<p>  lseek(fd,0,SEEK_END);</p>
<p>确定当前的文件位置：		</p>
<p>​	 lseek(fd,0,SEEK_CUR);</p>
<h3 id="33-1-2-驱动程序的完善"><a href="#33-1-2-驱动程序的完善" class="headerlink" title="33.1.2 驱动程序的完善"></a>33.1.2 驱动程序的完善</h3><p>上一小节中讲解的lseek函数如果要对设备文件生效，还需要完善相应的驱动程序。lseek函数会调用file_operation结构体中的llseek接口，所以需要对驱动中的llseek函数进行填充，并且完善read和write函数中偏移相关的部分。</p>
<p>下面对相关API接口函数进行填充：</p>
<p><em><strong>*llseek函数完善：*</strong></em></p>
<p>llseek填充完成的函数如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">loff_t</span> <span class="title function_">cdev_test_llseek</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">loff_t</span> offset, <span class="type">int</span> whence)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">loff_t</span> new_offset;<span class="comment">//定义loff_t类型的新的偏移值</span></span><br><span class="line">	<span class="keyword">switch</span>(whence)<span class="comment">//对lseek函数传递的whence参数进行判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> SEEK_SET:</span><br><span class="line">			<span class="keyword">if</span>(offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(offset &gt; BUFSIZE)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;	</span><br><span class="line">			&#125;</span><br><span class="line">			new_offset = offset;<span class="comment">//如果whence参数为SEEK_SET，则新偏移值为offset</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SEEK_CUR:</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &gt; BUFSIZE)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            new_offset = file-&gt;f_pos + offset;<span class="comment">//如果whence参数为SEEK_CUR，则新偏移值为file-&gt;f_pos + offset，file-&gt;f_pos为当前的偏移值</span></span><br><span class="line">			<span class="keyword">break</span>;			</span><br><span class="line">		<span class="keyword">case</span> SEEK_END:</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            new_offset = BUFSIZE + offset;<span class="comment">//如果whence参数为SEEK_END，则新偏移值为BUFSIZE + offset，BUFSIZE为最大偏移量</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	file-&gt;f_pos = new_offset;<span class="comment">//更新file-&gt;f_pos偏移值</span></span><br><span class="line">	<span class="keyword">return</span> new_offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第4行使用switch语句对传递的whence参数进行判断，whence在这里可以有三个取值，分别为SEEK_SET、SEEK_CUR和SEEK_END。</p>
<p>在6-16、17-28、29-38行代码中，分别对三个参数所代表的功能进行实现，其中需要注意的是file-&gt;f_pos指的是当前文件的偏移值。</p>
<p>在第40行和41行分别对f_pos偏移值进行更新，对新的偏移值进行返回。</p>
<p><em><strong>*read接口函数完善：*</strong></em></p>
<p>填充完成的read接口函数如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">loff_t</span> p = *off;<span class="comment">//将读取数据的偏移量赋值给loff_t类型变量p</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">size_t</span> count = size;</span><br><span class="line">	<span class="keyword">if</span>(p &gt; BUFSIZE)&#123;<span class="comment">//如果当前偏移值比最大偏移量大则返回错误</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(count &gt; BUFSIZE - p)&#123;</span><br><span class="line">		count  = BUFSIZE - p;<span class="comment">//如果要读取的偏移值超出剩余的空间，则读取到最后位置</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(copy_to_user(buf,mem+p,count))&#123;<span class="comment">//将mem中的值写入buf，并传递到用户空间</span></span><br><span class="line">		printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">		printk(<span class="string">&quot;buf[%d] is %c\n&quot;</span>,i,mem[i]);<span class="comment">//将mem中的值打印出来</span></span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;mem is %s,p is %llu,count is %d\n&quot;</span>,mem+p,p,count);</span><br><span class="line">	*off = *off + count;<span class="comment">//更新偏移值</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相较于之前的read接口函数，在第7行和第10行分别加入了对偏移值p和读取数量进行判定，在第13行通过偏移值p进行内核空间和用户空间数据的传递，最后在第21行对偏移值进行更新。</p>
<p><em><strong>*write接口函数完善：*</strong></em></p>
<p>write接口函数的完善和read接口函数相似，填充完成的write接口函数如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">loff_t</span> p = *off;<span class="comment">//将写入数据的偏移量赋值给loff_t类型变量p</span></span><br><span class="line">    <span class="type">size_t</span> count = size;</span><br><span class="line">    <span class="keyword">if</span>(p &gt; BUFSIZE)&#123;<span class="comment">//如果当前偏移值比最大偏移量大则返回错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &gt; BUFSIZE - p)&#123;</span><br><span class="line">        count  = BUFSIZE - p;<span class="comment">//如果要写入的偏移值超出剩余的空间，则写入到最后位置</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(copy_from_user(mem+p,buf,count))&#123;<span class="comment">//将buf中的值，从用户空间传递到内核空间</span></span><br><span class="line"> 		printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	printk(<span class="string">&quot;mem is %s,p is %llu\n&quot;</span>,mem+p,p);<span class="comment">//打印写入的值</span></span><br><span class="line">	*off = *off + count;<span class="comment">//更新偏移值</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相较于之前的write接口函数，在第7行和第10行分别加入了对偏移值p和读取数量进行判定，在第13行通过偏移值p进行内核空间和用户空间数据的传递，最后在第18行对偏移值进行更新。</p>
<p>至此，关于定位设备相关的API接口函数就都填充完成了，将在下一小节进行定位设备驱动实验代码的编写。</p>
<h2 id="33-2-实验程序编写"><a href="#33-2-实验程序编写" class="headerlink" title="33.2 实验程序编写"></a>33.2 实验程序编写</h2><h3 id="33-2-1-编写测试-APP"><a href="#33-2-1-编写测试-APP" class="headerlink" title="33.2.1 编写测试 APP"></a>33.2.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\26\app。</p>
<p>首先来编写应用测试代码llseek.c，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型文件描述符</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> off;<span class="comment">//定义读写偏移位置</span></span><br><span class="line">	<span class="type">char</span> readbuf[<span class="number">13</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区readbuf</span></span><br><span class="line">	<span class="type">char</span> readbuf1[<span class="number">19</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区readbuf1</span></span><br><span class="line"></span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR,<span class="number">666</span>);<span class="comment">//打开/dev/test设备</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	write(fd,<span class="string">&quot;hello world&quot;</span>,<span class="number">13</span>);<span class="comment">//向fd写入数据hello world</span></span><br><span class="line">	off = lseek(fd,<span class="number">0</span>,SEEK_CUR);<span class="comment">//读取当前位置的偏移量</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">    off = lseek(fd,<span class="number">0</span>,SEEK_SET);<span class="comment">//将偏移量设置为0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">	read(fd,readbuf,<span class="keyword">sizeof</span>(readbuf));<span class="comment">//将写入的数据读取到readbuf缓冲区</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;read is %s\n&quot;</span>,readbuf);</span><br><span class="line"></span><br><span class="line">    off = lseek(fd,<span class="number">0</span>,SEEK_CUR);<span class="comment">//读取当前位置的偏移量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">	off = lseek(fd,<span class="number">-1</span>,SEEK_CUR);<span class="comment">//将当前位置的偏移量向前挪动一位</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">    write(fd,<span class="string">&quot;Linux&quot;</span>,<span class="number">6</span>);<span class="comment">//向fd写入数据Linux</span></span><br><span class="line">    off = lseek(fd,<span class="number">0</span>,SEEK_CUR);<span class="comment">//读取当前位置的偏移量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">    off = lseek(fd,<span class="number">0</span>,SEEK_SET);<span class="comment">//将偏移量设置为0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">    read(fd,readbuf1,<span class="keyword">sizeof</span>(readbuf1));<span class="comment">//将写入的数据读取到readbuf1缓冲区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read is %s\n&quot;</span>,readbuf1);</span><br><span class="line"></span><br><span class="line">    off = lseek(fd,<span class="number">0</span>,SEEK_CUR);<span class="comment">//读取当前位置的偏移量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="33-2-2-驱动程序编写"><a href="#33-2-2-驱动程序编写" class="headerlink" title="33.2.2 驱动程序编写"></a>33.2.2 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\26\module。</p>
<p> 编写好的驱动程序llseek.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024<span class="comment">//设置最大偏移量为1024</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> mem[BUFSIZE] = &#123;<span class="number">0</span>&#125;;<span class="comment">//设置数据存储数组mem</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">loff_t</span> p = *off;<span class="comment">//将读取数据的偏移量赋值给loff_t类型变量p</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">size_t</span> count = size;</span><br><span class="line">	<span class="keyword">if</span>(p &gt; BUFSIZE)&#123;<span class="comment">//如果当前偏移值比最大偏移量大则返回错误</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(count &gt; BUFSIZE - p)&#123;</span><br><span class="line">		count  = BUFSIZE - p;<span class="comment">//如果要读取的偏移值超出剩余的空间，则读取到最后位置</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(copy_to_user(buf,mem+p,count))&#123;<span class="comment">//将mem中的值写入buf，并传递到用户空间</span></span><br><span class="line">		printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">		printk(<span class="string">&quot;buf[%d] is %c\n&quot;</span>,i,mem[i]);<span class="comment">//将mem中的值打印出来</span></span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;mem is %s,p is %llu,count is %d\n&quot;</span>,mem+p,p,count);</span><br><span class="line">	*off = *off + count;<span class="comment">//更新偏移值</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">loff_t</span> p = *off;<span class="comment">//将写入数据的偏移量赋值给loff_t类型变量p</span></span><br><span class="line">    <span class="type">size_t</span> count = size;</span><br><span class="line">    <span class="keyword">if</span>(p &gt; BUFSIZE)&#123;<span class="comment">//如果当前偏移值比最大偏移量大则返回错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &gt; BUFSIZE - p)&#123;</span><br><span class="line">        count  = BUFSIZE - p;<span class="comment">//如果要写入的偏移值超出剩余的空间，则写入到最后位置</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(copy_from_user(mem+p,buf,count))&#123;<span class="comment">//将buf中的值，从用户空间传递到内核空间</span></span><br><span class="line"> 		printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	printk(<span class="string">&quot;mem is %s,p is %llu\n&quot;</span>,mem+p,p);<span class="comment">//打印写入的值</span></span><br><span class="line">	*off = *off + count;<span class="comment">//更新偏移值</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">loff_t</span> <span class="title function_">cdev_test_llseek</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">loff_t</span> offset, <span class="type">int</span> whence)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">loff_t</span> new_offset;<span class="comment">//定义loff_t类型的新的偏移值</span></span><br><span class="line">	<span class="keyword">switch</span>(whence)<span class="comment">//对lseek函数传递的whence参数进行判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> SEEK_SET:</span><br><span class="line">			<span class="keyword">if</span>(offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(offset &gt; BUFSIZE)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;	</span><br><span class="line">			&#125;</span><br><span class="line">			new_offset = offset;<span class="comment">//如果whence参数为SEEK_SET，则新偏移值为offset</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SEEK_CUR:</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &gt; BUFSIZE)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            new_offset = file-&gt;f_pos + offset;<span class="comment">//如果whence参数为SEEK_CUR，则新偏移值为file-&gt;f_pos + offset，file-&gt;f_pos为当前的偏移值</span></span><br><span class="line">			<span class="keyword">break</span>;			</span><br><span class="line">		<span class="keyword">case</span> SEEK_END:</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            new_offset = BUFSIZE + offset;<span class="comment">//如果whence参数为SEEK_END，则新偏移值为BUFSIZE + offset，BUFSIZE为最大偏移量</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	file-&gt;f_pos = new_offset;<span class="comment">//更新file-&gt;f_pos偏移值</span></span><br><span class="line">	<span class="keyword">return</span> new_offset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">	.llseek = cdev_test_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_dev_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  	dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_dev_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_dev_init);</span><br><span class="line">module_exit(timer_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="33-3-运行测试"><a href="#33-3-运行测试" class="headerlink" title="33.3 运行测试"></a>33.3 运行测试</h2><h3 id="33-3-1-编译驱动程序"><a href="#33-3-1-编译驱动程序" class="headerlink" title="33.3.1 编译驱动程序"></a>33.3.1 编译驱动程序</h3><p>在上一小节中的llseek.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += llseek.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放llseek.c和Makefile文件目录下，如下图（图 33-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps240.jpg" alt="img"> </p>
<p>图 33-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 33-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps241.jpg" alt="img"> </p>
<p>图 33-2</p>
<p>编译完生成 llseek.ko目标文件，如下图（图 33-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps242.jpg" alt="img"> </p>
<p>图 33-3</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="33-3-2-编译应用程序"><a href="#33-3-2-编译应用程序" class="headerlink" title="33.3.2 编译应用程序"></a>33.3.2 编译应用程序</h3><p>来到存放应用程序llseek.c的文件夹下，使用以下命令对llseek.c进行交叉编译，编译完成如下图（图 33-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o read read.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps243.jpg" alt="img"> </p>
<p>图 33-4</p>
<p>生成的llseek文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="33-3-3-运行测试"><a href="#33-3-3-运行测试" class="headerlink" title="33.3.3 运行测试"></a>33.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 33-5）所示：</p>
<p>insmod llseek.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps244.jpg" alt="img"> </p>
<p>图 33-5</p>
<p>然后使用以下命令运行可执行文件llseek，运行结果如下图（图 33-6）所示：</p>
<p>.&#x2F;llseek</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps245.jpg" alt="img"> </p>
<p>图 33-6</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps246.jpg" alt="img"> </p>
<p>图 33-7</p>
<p>然后使用以下命令卸载对应的驱动，如下图（图 33-8）所示：</p>
<p>rmmod timer_dev</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps247.jpg" alt="img"> </p>
<p>图 33-8</p>
<h1 id="第34章-IOCTL驱动传参实验"><a href="#第34章-IOCTL驱动传参实验" class="headerlink" title="第34章 IOCTL驱动传参实验"></a>第34章 IOCTL驱动传参实验</h1><p>用户如果要对外设进行操作，对应的设备驱动不仅要具备读写的能力，还需要对硬件进行控制。以点亮LED灯驱动实验为例，应用程序通过向内核空间写入1和0从而控制LED灯的亮灭，但是读写操作主要是数据流对数据进行操作，而一些复杂的控制通常需要非数据操作，这时本章节要学习的ioctl函数就闪耀登场了。</p>
<h2 id="34-1-ioctl基础"><a href="#34-1-ioctl基础" class="headerlink" title="34.1 ioctl基础"></a>34.1 ioctl基础</h2><p>ioctl是设备驱动程序中用来控制设备的接口函数，一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87&spm=1001.2101.3001.7020">字符设备</a>驱动通常需要实现设备的打开、关闭、读取、写入等功能，而在一些需要细分的情况下，就需要扩展新的功能，通常以增设ioctl()命令的方式来实现。</p>
<p>下面将从应用层和驱动函数两个方面来对ioctl函数进行学习。</p>
<p><em><strong>*应用层：*</strong></em></p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>​    int ioctl(int fd, unsigned int cmd, unsigned long args);</p>
<p>****头文件****：</p>
<p>​    #include &lt;sys&#x2F;ioctl.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>用于向设备发送控制和配置命令。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>fd ：是用户程序打开设备时返回的文件描述符 </p>
<p>cmd ：是用户程序对设备的控制命令，</p>
<p>args：应用程序向驱动程序下发的参数，如果传递的参数为指针类型，则可以接收驱动向用户空间传递的数据（在下面的实验中会进行使用）</p>
<p>上述三个参数中，最重要的是第二个cmd参数，为unsigned int 类型，为了高效的使用cmd参数传递更多的控制信息，一个unsigned int cmd被拆分为了4段，每一段都有各自的意义，unsigned int cmd位域拆分如下：</p>
<p>cmd[31:30]—数据（args）的传输方向（读写）</p>
<p>​	cmd[29:16]—数据（args）的大小</p>
<p>​	cmd[15:8]—&gt;命令的类型，可以理解成命令的密钥，一般为ASCII码（0-255的一个字符，有部分字符已经被占用，每个字符的序号段可能部分被占用）</p>
<p>​	cmd[7:0] —&gt;命令的序号，是一个8bits的数字（序号，0-255之间）</p>
<p>cmd参数由ioctl合成宏定义得到，四个合成宏定义如下所示：</p>
<p>定义一个命令，但是不需要参数：</p>
<p>#define _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)</p>
<p>定义一个命令，应用程序从驱动程序读参数：</p>
<p>#define _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))</p>
<p>定义一个命令，应用程序向驱动程序写参数：</p>
<p>#define _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</p>
<p>定义一个命令，参数是双向传递的：</p>
<p>#define _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</p>
<p>宏定义参数说明如下所示：</p>
<p>type：命令的类型，一般为一个ASCII码值，一个驱动程序一般使用一个type</p>
<p>​	nr：该命令下序号。一个驱动有多个命令，一般他们的type，序号不同</p>
<p>​	size：args的类型</p>
<p>例如可以使用以下代码定义不需要参数、向驱动程序写参数、向驱动程序读参数三个宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST0 _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST1 _IOW(<span class="string">&#x27;L&#x27;</span>,1,int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST2 _IOR(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br></pre></td></tr></table></figure>

<p>至此，关于应用程序的ioctl相关知识就讲解完成了。</p>
<p><em><strong>*驱动函数：*</strong></em></p>
<p>应用程序中ioctl函数会调用file_operation结构体中的unlocked_ioctl接口，接口定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long (*unlocked_ioctl) (struct file *file , unsigned int cmd, unsigned long arg);</span><br></pre></td></tr></table></figure>

<p>参数说明如下所示：</p>
<p>file：文件描述符。</p>
<p>​	cmd：与应用程序的cmd参数对应，在驱动程序中对传递来的cmd参数进行判断从而做出不同的动作。</p>
<p>​	arg：与应用程序的arg参数对应，从而实现内核空间和用户空间参数的传递。</p>
<p>至此，关于驱动函数中的ioctl相关知识就讲解完成了。在下一小节中将进行ioctl驱动传参实验。</p>
<h2 id="34-2-实验程序编写"><a href="#34-2-实验程序编写" class="headerlink" title="34.2 实验程序编写"></a>34.2 实验程序编写</h2><h3 id="34-2-1-编写测试-APP"><a href="#34-2-1-编写测试-APP" class="headerlink" title="34.2.1 编写测试 APP"></a>34.2.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\27\app。</p>
<p>首先来编写应用测试代码ioctl.c，在此代码中使用非阻塞的方式打开设备，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST0 _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST1 _IOW(<span class="string">&#x27;L&#x27;</span>,1,int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST2 _IOR(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符fd</span></span><br><span class="line">	<span class="type">int</span> val;<span class="comment">//定义int类型的传递参数val</span></span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR);<span class="comment">//打开test设备节点</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open fail\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;write&quot;</span>))&#123;</span><br><span class="line">		ioctl(fd,CMD_TEST1,<span class="number">1</span>);<span class="comment">//如果第二个参数为write，向内核空间写入1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;read&quot;</span>))&#123;</span><br><span class="line">		ioctl(fd,CMD_TEST2,&amp;val);<span class="comment">//如果第二个参数为read，则读取内核空间传递向用户空间传递的值</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;val is %d\n&quot;</span>,val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="34-2-2-驱动程序编写"><a href="#34-2-2-驱动程序编写" class="headerlink" title="34.2.2 驱动程序编写"></a>34.2.2 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\27\module。</p>
<p> 编写好的驱动程序ioctl.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST0 _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST1 _IOW(<span class="string">&#x27;L&#x27;</span>,1,int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST2 _IOR(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">cdev_test_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> val;<span class="comment">//定义int类型向应用空间传递的变量val</span></span><br><span class="line">	<span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> CMD_TEST0:</span><br><span class="line">            printk(<span class="string">&quot;this is CMD_TEST0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;		</span><br><span class="line">        <span class="keyword">case</span> CMD_TEST1:</span><br><span class="line">            printk(<span class="string">&quot;this is CMD_TEST1\n&quot;</span>);</span><br><span class="line">			printk(<span class="string">&quot;arg is %ld\n&quot;</span>,arg);<span class="comment">//打印应用空间传递来的arg参数</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CMD_TEST2:</span><br><span class="line">			val = <span class="number">1</span>;<span class="comment">//将要传递的变量val赋值为1</span></span><br><span class="line">            printk(<span class="string">&quot;this is CMD_TEST2\n&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span>(copy_to_user((<span class="type">int</span> *)arg,&amp;val,<span class="keyword">sizeof</span>(val)) != <span class="number">0</span>)&#123;<span class="comment">//通过copy_to_user向用户空间传递数据</span></span><br><span class="line">				printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);	</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">break</span>;			</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	.unlocked_ioctl = cdev_test_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_dev_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  	dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_dev_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_dev_init);</span><br><span class="line">module_exit(timer_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="34-3-运行测试"><a href="#34-3-运行测试" class="headerlink" title="34.3 运行测试"></a>34.3 运行测试</h2><h3 id="34-3-1-编译驱动程序"><a href="#34-3-1-编译驱动程序" class="headerlink" title="34.3.1 编译驱动程序"></a>34.3.1 编译驱动程序</h3><p>在上一小节中的ioctl.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m += ioctl.o    #此处要和你的驱动源文件同名</span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    #make操作</span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    #make clean操作</span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放ioctl.c和Makefile文件目录下，如下图（图 34-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps248.jpg" alt="img"> </p>
<p>图 34-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 34-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps249.jpg" alt="img"> </p>
<p>图 34-2</p>
<p>编译完生成 ioctl.ko目标文件，如下图（图 34-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps250.jpg" alt="img"> </p>
<p>图 34-4</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="34-3-2-编译应用程序"><a href="#34-3-2-编译应用程序" class="headerlink" title="34.3.2 编译应用程序"></a>34.3.2 编译应用程序</h3><p>来到存放应用程序ioctl.c的文件夹下，使用以下命令对ioctl.c进行交叉编译，编译完成如下图（图 34-5）所示：</p>
<p>aarch64-linux-gnu-gcc -o ioctl ioctl.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps251.jpg" alt="img"> </p>
<p>图 34-5</p>
<p>生成的ioctl文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="34-3-3-运行测试"><a href="#34-3-3-运行测试" class="headerlink" title="34.3.3 运行测试"></a>34.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 34-6）所示：</p>
<p>insmod ioctl.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps252.jpg" alt="img"> </p>
<p>图 34-6</p>
<p>然后使用以下命令通过ioctl向内核空间传递arg参数，传递成功如下图（图 34-7）所示：</p>
<p>.&#x2F;ioctl write</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps253.jpg" alt="img"> </p>
<p>图 34-7</p>
<p>然后使用以下命令通过ioctl读取内核空间向用户空间传递的val值，读取成功如下图（图 34-8）所示：</p>
<p>.&#x2F;ioctl read</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps254.jpg" alt="img"> </p>
<p>图 34-8</p>
<p>至此关于iocto驱动传参实验就测试完成了，可以使用以下命令卸载对应的驱动，如下图（图 34-9）所示： </p>
<p>rmmod ioctl.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps255.jpg" alt="img"> </p>
<p>图 34-9</p>
<h1 id="第35章-IOCTL地址传参实验"><a href="#第35章-IOCTL地址传参实验" class="headerlink" title="第35章 IOCTL地址传参实验"></a>第35章 IOCTL地址传参实验</h1><p>在上一章节中对ioctl基础知识进行了学习，并通过ioctl进行了驱动传参实验，在本章节将以传递结构体为例，进行地址传参实验，从而加深大家对ioctl的认识。</p>
<h2 id="35-1-实验程序编写"><a href="#35-1-实验程序编写" class="headerlink" title="35.1 实验程序编写"></a>35.1 实验程序编写</h2><h3 id="35-1-1-编写测试-APP"><a href="#35-1-1-编写测试-APP" class="headerlink" title="35.1.1 编写测试 APP"></a>35.1.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\28\app。</p>
<p>首先编写应用程序ioctl.c，用来向设备文件写入数据，编写好的应用程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST0 _IOW(<span class="string">&#x27;L&#x27;</span>,0,int)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span>&#123;</span><span class="comment">//定义要传递的结构体</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型文件描述符</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">test</span>;</span><span class="comment">//定义args类型的结构体变量test</span></span><br><span class="line">	test.a = <span class="number">1</span>;</span><br><span class="line">	test.b = <span class="number">2</span>;</span><br><span class="line">	test.c = <span class="number">3</span>;</span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR,<span class="number">0777</span>);<span class="comment">//打开/dev/test设备</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ioctl(fd,CMD_TEST0,&amp;test);<span class="comment">//使用ioctl函数传递结构体变量test地址</span></span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="35-1-1-驱动程序编写"><a href="#35-1-1-驱动程序编写" class="headerlink" title="35.1.1 驱动程序编写"></a>35.1.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\28\module。</p>
<p> 编写好的驱动程序ioctl.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST0 _IOW(<span class="string">&#x27;L&#x27;</span>,0,int)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">cdev_test_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">test</span>;</span>  </span><br><span class="line">	<span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> CMD_TEST0:</span><br><span class="line">			<span class="keyword">if</span>(copy_from_user(&amp;test,(<span class="type">int</span> *)arg,<span class="keyword">sizeof</span>(test)) != <span class="number">0</span>)&#123;<span class="comment">//将用户空间传递来的arg赋值给test</span></span><br><span class="line">				printk(<span class="string">&quot;copy_from_user error\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			printk(<span class="string">&quot;a = %d\n&quot;</span>,test.a);<span class="comment">//对传递的值进行打印验证</span></span><br><span class="line">  			printk(<span class="string">&quot;b = %d\n&quot;</span>,test.b);</span><br><span class="line">  	  		printk(<span class="string">&quot;c = %d\n&quot;</span>,test.c);</span><br><span class="line">            <span class="keyword">break</span>;			</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	.unlocked_ioctl = cdev_test_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_dev_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line"> dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/*5  创建设备*/</span></span><br><span class="line"> 	dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_dev_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_dev_init);</span><br><span class="line">module_exit(timer_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="35-2-运行测试"><a href="#35-2-运行测试" class="headerlink" title="35.2 运行测试"></a>35.2 运行测试</h2><h3 id="35-2-1-编译驱动程序"><a href="#35-2-1-编译驱动程序" class="headerlink" title="35.2.1 编译驱动程序"></a>35.2.1 编译驱动程序</h3><p>在上一小节中的ioctl.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += ioctl.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放ioctl.c和Makefile文件目录下，如下图（图 35-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps256.jpg" alt="img"> </p>
<p>图 35-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 35-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps257.jpg" alt="img"> </p>
<p>图 35-2</p>
<p>编译完生成 wq.ko目标文件，如下图（图 35-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps258.jpg" alt="img"> </p>
<p>图 35-3</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="35-2-2-编译应用程序"><a href="#35-2-2-编译应用程序" class="headerlink" title="35.2.2 编译应用程序"></a>35.2.2 编译应用程序</h3><p>来到存放应用程序ioctl.c的文件夹下，使用以下命令对ioctl.c进行交叉编译，编译完成如下图（图 35-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o ioctl ioctl.c</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps259.jpg" alt="img"> </p>
<p>图 35-4</p>
<p>生成的ioctl文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="35-2-3-运行测试"><a href="#35-2-3-运行测试" class="headerlink" title="35.2.3 运行测试"></a>35.2.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 35-5）所示：</p>
<p>insmod ioctl.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps260.jpg" alt="img"> </p>
<p>图 35-5</p>
<p>然后使用以下命令运行可执行程序，运行成功如下图（图 35-6）所示：</p>
<p> .&#x2F;ioctl</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps261.jpg" alt="img"> </p>
<p>图 35-6</p>
<p>可以看到结构体类型变量test已经成功传递到了内核空间，a、b、c的值都被正确打印了出来，我们的ioctl地址传参实验就完成了。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps262.jpg" alt="img"> </p>
<p>图 35-7</p>
<h1 id="第36章-封装驱动API接口实验"><a href="#第36章-封装驱动API接口实验" class="headerlink" title="第36章 封装驱动API接口实验"></a>第36章 封装驱动API接口实验</h1><p>相信经过前面两个章节的学习已经能够熟练的使用ioctl函数了，在本章节会进行两个实验，每个实验的要完成的任务如下所示：</p>
<p>实验一：通过ioctl对定时器进行控制，分别实现打开定时器、关闭定时器和设置定时时间的功能。</p>
<p>实验二：对实验一的应用程序进行封装，从而让应用编程人员更好的对设备进行编程。</p>
<h2 id="36-1-ioctl控制定时器实验"><a href="#36-1-ioctl控制定时器实验" class="headerlink" title="36.1 ioctl控制定时器实验"></a>36.1 ioctl控制定时器实验</h2><p>首先进行ioctl控制定时器实验，通过该实验可以综合ioctl函数和定时器相关知识，从而进一步加深对ioctl的理解。</p>
<h3 id="36-1-1-编写测试-APP"><a href="#36-1-1-编写测试-APP" class="headerlink" title="36.1.1 编写测试 APP"></a>36.1.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\29\app1。</p>
<p>首先来编写应用测试代码ioctl.c，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_OPEN _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_CLOSE _IO(<span class="string">&#x27;L&#x27;</span>,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_SET _IOW(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR,<span class="number">0777</span>);<span class="comment">//打开test节点</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    ioctl(fd,TIME_SET,<span class="number">1000</span>);</span><br><span class="line">	ioctl(fd,TIME_OPEN);</span><br><span class="line">	sleep(<span class="number">3</span>);</span><br><span class="line">    ioctl(fd,TIME_SET,<span class="number">3000</span>);</span><br><span class="line">	sleep(<span class="number">7</span>);</span><br><span class="line">	ioctl(fd,TIME_CLOSE);</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第8-10行通过合成宏定义了三个ioctl命令，分别代表定时器打开、定时器关闭、定时时间设置。</p>
<p>第18行和第21行将定时时间分别设置为1秒和3秒。</p>
<p>第19行打开定时器。</p>
<p>第23行关闭定时器。</p>
<h3 id="36-1-2-驱动程序编写"><a href="#36-1-2-驱动程序编写" class="headerlink" title="36.1.2 驱动程序编写"></a>36.1.2 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\29\module。</p>
<p> 编写好的驱动程序ioctl_timer.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_OPEN _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_CLOSE _IO(<span class="string">&#x27;L&#x27;</span>,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_SET _IOW(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">	<span class="type">int</span> counter; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">fnction_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span>;<span class="comment">//定义function_test定时功能函数</span></span><br><span class="line">DEFINE_TIMER(timer_test,fnction_test);<span class="comment">//定义一个定时器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fnction_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;this is fnction_test\n&quot;</span>);</span><br><span class="line">    mod_timer(&amp;timer_test,jiffies_64 + msecs_to_jiffies(dev1.counter));<span class="comment">//使用mod_timer函数重新设置定时时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">cdev_test_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span> =</span> (<span class="keyword">struct</span> device_test *)file-&gt;private_data;<span class="comment">//设置私有数据</span></span><br><span class="line">	<span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> TIMER_OPEN:</span><br><span class="line">			add_timer(&amp;timer_test);<span class="comment">//添加一个定时器</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TIMER_CLOSE:</span><br><span class="line">			del_timer(&amp;timer_test);<span class="comment">//删除一个定时器</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TIMER_SET:</span><br><span class="line">			test_dev-&gt;counter = arg;</span><br><span class="line">			timer_test.expires = jiffies_64 + msecs_to_jiffies(test_dev-&gt;counter);<span class="comment">//设置定时时间</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	.open = cdev_test_open,</span><br><span class="line">	.release = cdev_test_release,</span><br><span class="line">	.unlocked_ioctl = cdev_test_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_dev_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line"> dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">&#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  	dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_dev_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_dev_init);</span><br><span class="line">module_exit(timer_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="36-2-运行测试"><a href="#36-2-运行测试" class="headerlink" title="36.2 运行测试"></a>36.2 运行测试</h2><h3 id="36-2-1-编译驱动程序"><a href="#36-2-1-编译驱动程序" class="headerlink" title="36.2.1 编译驱动程序"></a>36.2.1 编译驱动程序</h3><p>在上一小节中的ioctl_timer.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += ioctl_timer.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放ioctl_timer.c和Makefile文件目录下，如下图（图 36-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps263.jpg" alt="img"> </p>
<p>图 36-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 36-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps264.jpg" alt="img"> </p>
<p>图 36-2</p>
<p>编译完生成 ioctl_timer.ko目标文件，如下图（图 36-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps265.jpg" alt="img"> </p>
<p>图 36-3</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="36-2-2-编译应用程序"><a href="#36-2-2-编译应用程序" class="headerlink" title="36.2.2 编译应用程序"></a>36.2.2 编译应用程序</h3><p>来到存放应用程序ioctl.c的文件夹下，使用以下命令对ioctl.c进行交叉编译，编译完成如下图（图 36-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o ioctl ioctl.c</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps266.jpg" alt="img"> </p>
<p>图 36-4</p>
<p>生成的ioctl文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="36-2-3-运行测试"><a href="#36-2-3-运行测试" class="headerlink" title="36.2.3 运行测试"></a>36.2.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 36-5）所示：</p>
<p>insmod ioctl_timer.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps267.jpg" alt="img"> </p>
<p>图 36-5</p>
<p>输入以下命令运行可执行文件,运行成功如下图（图 36-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps268.jpg" alt="img"> </p>
<p>图 36-6</p>
<p>可以看到前面三个打印信息间隔为1秒钟，后面三个打印信息间隔为3秒钟，至此，实验一就结束了，然后使用以下命令卸载驱动模块，如下图（图 36-7）所示：</p>
<p>rmmod ioctl_timer.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps269.jpg" alt="img"> </p>
<p>图 36-7</p>
<h2 id="36-3-封装驱动API接口"><a href="#36-3-封装驱动API接口" class="headerlink" title="36.3 封装驱动API接口"></a>36.3 封装驱动API接口</h2><p>至此，随着ioctl练习的结束，字符设备驱动框架相关的知识也就完结了，相信细心的小伙伴在上一小节应用程序的编写中会发现问题，应用程序是从驱动的角度进行编写的，具体内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_OPEN _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_CLOSE _IO(<span class="string">&#x27;L&#x27;</span>,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_SET _IOW(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR,<span class="number">0777</span>);<span class="comment">//打开test节点</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    ioctl(fd,TIME_SET,<span class="number">1000</span>);</span><br><span class="line">	ioctl(fd,TIME_OPEN);</span><br><span class="line">	sleep(<span class="number">3</span>);</span><br><span class="line">    ioctl(fd,TIME_SET,<span class="number">3000</span>);</span><br><span class="line">	sleep(<span class="number">7</span>);</span><br><span class="line">	ioctl(fd,TIME_CLOSE);</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为驱动工程师的我们当然可以理解每一行代码所要完成的功能，而一般情况下，应用都是由专业的应用工程师来进行编写的，上述代码编写方式很不利于应用工程师的理解和程序的移植，所以对于应用程序API的封装是一件必然的事情。</p>
<p>封装好的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\29\app2。</p>
<p>首先来编写整体库文件timerlib.h，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TIMELIB_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TIMELIB_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_OPEN _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_CLOSE _IO(<span class="string">&#x27;L&#x27;</span>,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_SET _IOW(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_open</span><span class="params">()</span>;<span class="comment">//定义设备打开函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_open</span><span class="params">(<span class="type">int</span> fd)</span>;<span class="comment">//定义定时器打开函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_close</span><span class="params">(<span class="type">int</span> fd)</span>;<span class="comment">//定义定时器关闭函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_set</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> arg)</span>;<span class="comment">//定义设置计时时间函数</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在9-11行使用合成宏定义了三个ioctl命令，分别代表定时器打开、定时器关闭、定时时间设置。</p>
<p>在第12-15行定义了四个功能函数，所代表的功能分别为设备打开、定时器打开、定时器关闭、定时时间设置。</p>
<p>接下来将创建每个功能函数的c文件，最后编译为单独的库，首先编写dev_open.c文件，编写好的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;timerlib.h&quot;</span><br><span class="line">int dev_open()</span><br><span class="line">&#123;</span><br><span class="line">    int fd；</span><br><span class="line">    fd = open(&quot;/dev/test&quot;,O_RDWR,0777);</span><br><span class="line">    if(fd &lt; 0)&#123;</span><br><span class="line">        printf(&quot;file open error \n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写定时器打开函数timeropen.c文件，编写好的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;timerlib.h&quot;</span><br><span class="line">int timer_open(int fd)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	ret = ioctl(fd,TIMER_OPEN);</span><br><span class="line">	if(ret &lt; 0)&#123;</span><br><span class="line">		printf(&quot;ioctl open error \n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写定时器打开函数timerclose.c文件，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timerlib.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_close</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = ioctl(fd,TIMER_CLOSE);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ioctl  close error \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写定时器打开函数timerset.c文件，编写好的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;timerlib.h&quot;</span><br><span class="line">int timer_set(int fd,int arg)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	ret = ioctl(fd,TIMER_SET,arg);</span><br><span class="line">	if(ret &lt; 0)&#123;</span><br><span class="line">		printf(&quot;ioctl error \n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后编写测试要用到的应用程序ioctl.c文件，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timerlib.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	fd = dev_open();</span><br><span class="line">    timer_set(fd,<span class="number">1000</span>);</span><br><span class="line">	timer_open(fd);</span><br><span class="line">	sleep(<span class="number">3</span>);</span><br><span class="line">	timer_set(fd,<span class="number">3000</span>);</span><br><span class="line">	sleep(<span class="number">7</span>);</span><br><span class="line">	timer_close(fd);</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，要用到的文件就都编写完成了，会在下一小节进行库的制作，以及应用程序的编译。</p>
<h2 id="36-4-运行测试"><a href="#36-4-运行测试" class="headerlink" title="36.4 运行测试"></a>36.4 运行测试</h2><h3 id="36-4-1-编译应用程序"><a href="#36-4-1-编译应用程序" class="headerlink" title="36.4.1 编译应用程序"></a>36.4.1 编译应用程序</h3><p>首先使用以下命令将存放功能函数的c文件编译成.o文件，编译完成如下图（图 36-7）所示：</p>
<p>aarch64-linux-gnu-gcc -c dev_open.c</p>
<p>aarch64-linux-gnu-gcc -c timer*.c</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps270.jpg" alt="img"> </p>
<p>图 36-7</p>
<p>然后使用以下命令将相应的.o文件编译成.a静态库（这里要注意库的名称都以lib开头），编译完成如下图（图 36-8）所示：</p>
<p>aarch64-linux-gnu-ar rcs libtime.a timer*.o</p>
<p>aarch64-linux-gnu-ar rcs libopen.a dev_open.o</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps271.jpg" alt="img"> </p>
<p>图 36-8</p>
<p>最后使用以下命令对ioctl.c进行交叉编译，编译完成如下图（图 36-9）所示：</p>
<p>aarch64-linux-gnu-gcc -o ioctl ioctl.c -L.&#x2F; -ltime -lopen</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps272.jpg" alt="img"> </p>
<p>图 36-9</p>
<p>生成的ioctl文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="36-4-2-运行测试"><a href="#36-4-2-运行测试" class="headerlink" title="36.4.2 运行测试"></a>36.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 36-10）所示：</p>
<p>insmod ioctl_timer.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps273.jpg" alt="img"> </p>
<p>图 36-10</p>
<p>输入以下命令运行可执行文件,运行成功如下图（图 36-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps274.jpg" alt="img"> </p>
<p>图 36-11</p>
<p>可以看到前面三个打印信息间隔为1秒钟，后面三个打印信息间隔为3秒钟，至此，实验一就结束了，然后使用以下命令卸载驱动模块，如下图（图 36-12）所示：</p>
<p>rmmod ioctl_timer.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps275.jpg" alt="img"> </p>
<p>图 36-12</p>
<h1 id="第37章-优化驱动稳定性和效率实验"><a href="#第37章-优化驱动稳定性和效率实验" class="headerlink" title="第37章 优化驱动稳定性和效率实验"></a>第37章 优化驱动稳定性和效率实验</h1><p>在Linux中应用程序运行在用户空间，应用程序错误之后，并不会影响其他程序的运行，而驱动工作在内核层，是内核代码的一部分，当驱动出现问题之后，可能会导致整个系统的崩溃。所以在驱动中，需要对各种判断、预处理等进行排查等，在本小节将对如何优化驱动稳定性和提高驱动效率进行学习。</p>
<h2 id="37-1-方法一：检测ioctl命令"><a href="#37-1-方法一：检测ioctl命令" class="headerlink" title="37.1 方法一：检测ioctl命令"></a>37.1 方法一：检测ioctl命令</h2><p>ioctl的cmd命令是由合成宏合成得到的，也有相应的分解宏得到各个参数，四个分解宏如下所示：</p>
<p>分解cmd命令，得到命令的类型：</p>
<p>_IOC_TYPE(cmd)</p>
<p>分解cmd命令，得到数据（args）的传输方向：</p>
<p>_IOC_DIR(cmd)</p>
<p>分解cmd命令，得到命令的序号：</p>
<p>_IOC_NR(cmd)</p>
<p>分解cmd命令，得到数据（args）的大小：</p>
<p>_IOC_SIZE(cmd)</p>
<p>可以在驱动中通过上述分解宏对传入的ioctl命令类型等参数进行判断，从而得到判断传入的参数是否正确，以此优化驱动的稳定性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(_IOC_TYPE(cmd) != <span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">   printk(<span class="string">&quot;cmd type error \n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如可以通过上述代码对传入参数的类型进行判断，如果传入的参数类型不为“L”,就返回错误，其他参数的检测方法相同。</p>
<h2 id="37-2-方法二：检测传递地址是否合理"><a href="#37-2-方法二：检测传递地址是否合理" class="headerlink" title="37.2 方法二：检测传递地址是否合理"></a>37.2 方法二：检测传递地址是否合理</h2><p>access_ok()函数</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>​    access_ok(addr,size);</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>检查用户空间内存块是否可用</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>addr  :  用户空间的指针变量，其指向一个要检查的内存块开始处。</p>
<p>size   :  要检查内存块的大小。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>成功返回1，失败返回0</p>
<p>以第35章的ioctl地址传参实验为例，对传入的args地址进行判断，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">test</span>;</span></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">	<span class="keyword">case</span> CMD_TEST0:</span><br><span class="line">		len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> args);</span><br><span class="line">		<span class="keyword">if</span>(!access_ok(arg,len))&#123;</span><br><span class="line">			 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(copy_from_user(&amp;test,(<span class="type">int</span> *)arg,<span class="keyword">sizeof</span>(test)) != <span class="number">0</span>)&#123;</span><br><span class="line">			 printk(<span class="string">&quot;copy_from_user error\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>在第6行对传入的args参数地址进行判断，如果不合法则返回-1，从而保证了驱动运行的稳定性。</p>
<h2 id="37-3-方法三：分支预测优化"><a href="#37-3-方法三：分支预测优化" class="headerlink" title="37.3 方法三：分支预测优化"></a>37.3 方法三：分支预测优化</h2><p>现在的CPU都有ICache和流水线机制。即运行当前指令时，ICache会预读取后面的指令，从而提升效率。但是如果条件分支的结果是跳转到了其他指令，那预取下一条指令就浪费时间了。而本章节要用到的likely和unlikely宏，会让编译器总是将大概率执行的代码放在靠前的位置，从而提高驱动的效率。</p>
<p>likely和unlikely宏定义在“内核源码&#x2F;include&#x2F;linux&#x2F;compiler.h”文件中，具体定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define likely(x) __builtin_expect(!!(x), 1)</span><br><span class="line">#define unlikely(x) __builtin_expect(!!(x), 0)</span><br></pre></td></tr></table></figure>

<p>__builtin_expect的作用是告知编译器预期表达式exp等于c的可能性更大，编译器可以根据该因素更好的对代码进行优化，所以likely与unlikely的作用就是表达性x为真的可能性更大（likely）和更小（unlikely）。</p>
<p>这里以上一小节添加传递地址检测内容后的代码为例，对copy_from_user函数添加分支预测优化函数，添加完成如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">test</span>;</span></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">	<span class="keyword">case</span> CMD_TEST0:</span><br><span class="line">		len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> args);</span><br><span class="line">		<span class="keyword">if</span>(!access_ok(arg,len))&#123;</span><br><span class="line">			 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(unlikely(copy_from_user(&amp;test,(<span class="type">int</span> *)arg,<span class="keyword">sizeof</span>(test)) != <span class="number">0</span>))&#123;</span><br><span class="line">			 printk(<span class="string">&quot;copy_from_user error\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>传递地址检测成功之后才会使用执行copy_from_user函数，在传递地址正确的前提下copy_from_user函数运行失败为小概率事件，所以这里使用unlikely函数进行驱动效率的优化。</p>
<p>至此，关于分支预测优化相关的知识就讲解完成了。</p>
<h1 id="第38章-驱动调试方法实验"><a href="#第38章-驱动调试方法实验" class="headerlink" title="第38章 驱动调试方法实验"></a>第38章 驱动调试方法实验</h1><p>在之前编写的驱动程序中，通常都使用printk函数打印相应的提示信息从而对驱动进行调试，那有没有其他的方式来调试驱动呢，答案是肯定的，在本章节中将对不同驱动调试方法进行学习。</p>
<h2 id="38-1-方法1：dump-stack函数"><a href="#38-1-方法1：dump-stack函数" class="headerlink" title="38.1 方法1：dump_stack函数"></a>38.1 方法1：dump_stack函数</h2><p>作用:打印内核调用堆栈，并打印函数的调用关系。</p>
<p>这里以最简单的helloworld驱动为例进行dump_stack函数演示，实验代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>        </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">	dump_stack();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);    </span><br><span class="line">module_exit(helloworld_exit);   </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    </span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>和原helloworld驱动程序相比，在第6行添加了dump_stack()，驱动加载之后打印信息如下（图 38-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps276.jpg" alt="img"> </p>
<p>图 38-1</p>
<p>可以看到helloworld_init函数的调用关系就都打印了出来。</p>
<p>至此关于dump_stack函数的测试就完成了。</p>
<h2 id="38-2-方法2：WARN-ON-condition-函数"><a href="#38-2-方法2：WARN-ON-condition-函数" class="headerlink" title="38.2 方法2：WARN_ON(condition)函数"></a>38.2 方法2：WARN_ON(condition)函数</h2><p>WARN_ON (condition)函数作用:在括号中的条件成立时，内核会抛出栈回溯，打印函数的调用关系。通常用于内核抛出一个警告，暗示某种不太合理的事情发生了。</p>
<p>WARN_ON实际上也是调用dump_stack，只是多了参数condition判断条件是否成立，例如WARN_ON (1)则条件判断成功，函数会成功执行。</p>
<p>这里仍然以最简单的helloworld驱动为例进行WARN_ON函数演示，实验代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>        </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">	WARN_ON(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);    </span><br><span class="line">module_exit(helloworld_exit);   </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    </span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);c</span><br></pre></td></tr></table></figure>

<p>和原helloworld驱动程序相比，在第6行添加了WARN_ON(1)，驱动加载之后打印信息如下（图 38-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps277.jpg" alt="img"> </p>
<p>图 38-2</p>
<p>可以看到helloworld_init函数的调用关系以及寄存器值就都打印了出来。</p>
<p>至此关于WARN_ON函数的测试就完成了。</p>
<h2 id="38-3-方法3：BUG-ON-condition-函数"><a href="#38-3-方法3：BUG-ON-condition-函数" class="headerlink" title="38.3 方法3：BUG_ON (condition)函数"></a>38.3 方法3：BUG_ON (condition)函数</h2><p>内核中有许多地方调用类似BUG_ON()的语句，它非常像一个内核运行时的断言，意味着本来不该执行到BUG_ON()这条语句，一旦BUG_ON()执行内核就会立刻抛出oops，导致栈的回溯和错误信息的打印。大部分体系结构把BUG()和BUG_ON()定义成某种非法操作，这样自然会产生需要的oops。参数condition判断条件是否成立，例如BUG_ON (1)则条件判断成功，函数会成功执行。</p>
<p>这里仍然以最简单的helloworld驱动为例进行BUGON函数演示，实验代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>        </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">	BUGON(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);    </span><br><span class="line">module_exit(helloworld_exit);   </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    </span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>和原helloworld驱动程序相比，在第6行添加了BUGON(1)，驱动加载之后打印信息如下（图 38-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps278.jpg" alt="img"> </p>
<p>图 38-3</p>
<p>可以看到helloworld_init函数的调用关系以及寄存器值就都打印了出来。</p>
<p>至此关于BUGON(1)函数的测试就完成了。</p>
<h2 id="38-4-方法4：panic-fmt…-函数"><a href="#38-4-方法4：panic-fmt…-函数" class="headerlink" title="38.4 方法4：panic (fmt…)函数"></a>38.4 方法4：panic (fmt…)函数</h2><p>panic (fmt…)函数:输出打印会造成系统死机并将函数的调用关系以及寄存器值就都打印了出来。</p>
<p>这里仍然以最简单的helloworld驱动为例进行panic 函数的演示，实验代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>        </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">	panic(<span class="string">&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);    </span><br><span class="line">module_exit(helloworld_exit);   </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    </span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>和原helloworld驱动程序相比，在第6行添加了panic(“!!!!!!!!!!!!!!!!!!!!!!!!!!!!”)，驱动加载之后打印信息如下（图 38-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps279.jpg" alt="img"> </p>
<p>图 38-4</p>
<p>可以看到helloworld_init函数的调用关系以及寄存器值就都打印了出来，信息打印完成之后会发现系统已经崩溃了，终端已经无法再进行输入。</p>
<p>至此关于panic函数的测试就完成了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%AB%98%E7%BA%A7%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E8%BF%9B%E9%98%B6/" rel="tag">高级字符设备进阶</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-rk3568-驱动开发第三篇-并发与竞争"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%89%E7%AF%87-%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/"
    >rk3568 驱动开发第三篇 并发与竞争</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%89%E7%AF%87-%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/" class="article-date">
  <time datetime="2023-09-04T12:55:28.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第19章-并发与竞争实验"><a href="#第19章-并发与竞争实验" class="headerlink" title="第19章 并发与竞争实验"></a>第19章 并发与竞争实验</h1><p>在前面章节的学习中，相信大家已经对用户空间与内核空间数据传递进行了实验，假如要传递的数据被存放在了全局变量，该数据就可以作为共享资源被多个任务共同读写，从而造成数据的错误传输，多个程序同时访问一个共享资源产生的问题就叫做竞争。竞争产生的根本原因就是Linux系统的并发访问。</p>
<p>在本章节中首先会对并发与并行的概念进行讲解，随后对竞争产生的原因进行总结，最后以一个实际的竞争实验加深大家的理解。下面就让我们开始本章节的学习吧。</p>
<h2 id="19-1-并发与竞争"><a href="#19-1-并发与竞争" class="headerlink" title="19.1 并发与竞争"></a>19.1 并发与竞争</h2><h3 id="19-1-1并发"><a href="#19-1-1并发" class="headerlink" title="19.1.1并发"></a>19.1.1并发</h3><p>早期计算机大多只有一个CPU核心，一个CPU在同一时间只能执行一个任务，当系统中有多个任务等待执行时，CPU只能执行完一个再执行下一个。而计算机的很多指令会涉及I&#x2F;O操作，执行速度远远低于CPU内高速存储器的存取速度，这就导致CPU经常处于空闲状态，只能等待I&#x2F;O操作完成后才能继续执行后面的指令。为了提高CPU利用率，减少等待时间，提出了CPU并发工作理论。</p>
<p>所谓并发，就是通过算法将CPU资源合理地分配给多个任务，当一个任务执行 I&#x2F;O 操作时，CPU可以转而执行其它的任务，等到 I&#x2F;O 操作完成以后，或者新的任务遇到 I&#x2F;O 操作时，CPU再回到原来的任务继续执行。</p>
<p>下图（图19-1）展示了两个任务并发执行的过程（为了容易理解，这里以两个任务并发执行为例，当然一个CPU核心并不仅仅只能两个任务并发）：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps109.jpg" alt="img"> </p>
<p>图 19-1</p>
<p>虽然CPU在同一时刻只能执行一个任务，但是通过将CPU的使用权在恰当的时机分配给不同的任务，使得多个任务看起来是一起执行的（CPU的执行速度极快，多任务切换的时间也极短）。</p>
<p>至此关于并发的概念就讲解完成了。</p>
<h3 id="19-1-2并行"><a href="#19-1-2并行" class="headerlink" title="19.1.2并行"></a>19.1.2并行</h3><p>并发是针对单核CPU提出的，而并行则是针对多核CPU提出的。和单核CPU不同，多核CPU真正实现了“同时执行多个任务”。多核CPU的每个核心都可以独立地执行一个任务，而且多个核心之间不会相互干扰。在不同核心上执行的多个任务，是真正地同时运行，这种状态就叫做并行。双核CPU的工作状态如下图（图19-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps110.jpg" alt="img"> </p>
<p>图 19-2</p>
<p>双核CPU执行两个任务时，每个核心各自执行一个任务，和单核CPU在两个任务之间不断切换相比，它的执行效率更高。</p>
<p>至此对于并行的概念就讲解完成了。</p>
<h3 id="19-1-3并发-并行"><a href="#19-1-3并发-并行" class="headerlink" title="19.1.3并发+并行"></a>19.1.3并发+并行</h3><p>在并行的工作状态中，两个CPU分别执行两个任务，是一种理想状态。但是在实际场景中，处于运行状态的任务是非常多的，以实际办公电脑为例，windows系统在开机之后会运行几十个任务，而CPU往往只有4核、8核等，远远低于任务的数量，这个时候就会同时存在并发和并行两种情况，即所有核心在并行工作的同时，每个核心还要并发工作。</p>
<p>例如一个双核 CPU 要执行四个任务，它的工作状态如下图（图19-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps111.jpg" alt="img"> </p>
<p>图 19-3</p>
<p>为了容易理解，这里是以两个任务并发执行为例，当然一个CPU核心并不仅仅只能两个任务并发，并发任务的数量和操作系统的分配方式、以及每个任务的工作状态有关系。</p>
<p>至此，对于并发+并行的概念讲解就结束了。</p>
<p>并发可以看作是并行的理想状态，为了便于讲解和避免产生歧义，之后的章节无论是并发还是并行，都会统称为并发。</p>
<h3 id="19-1-4-竞争"><a href="#19-1-4-竞争" class="headerlink" title="19.1.4 竞争"></a>19.1.4 竞争</h3><p>并发可能会造成多个程序同时访问一个共享资源，这时候由并发同时访问一个共享资源产生的问题就叫做竞争。</p>
<p>竞争产生的原因如下所示：</p>
<p>（1）多线程的并发访问。由于Linux 是多任务操作系统，所以多线程访问是竞争产生的基本原因。</p>
<p>（2）中断程序的并发访问。中断任务产生后，CPU会立刻停止当前工作，从而去执行中断中的任务，如果中断任务对共享资源进行了修改，就会产生竞争。</p>
<p>（3）抢占式并发访问。linux2.6及更高版本引入了抢占式内核，高优先级的任务可以打断低优先级的任务。在线程访问共享资源的时候，另一个线程打断了现在正在访问共享资源的线程同时也对共享资源进行操作，从而造成了竞争。</p>
<p>（4）多处理器(SMP）并发访问。多核处理器之间存在核间并发访问。</p>
<h3 id="19-1-5-共享资源的保护"><a href="#19-1-5-共享资源的保护" class="headerlink" title="19.1.5 共享资源的保护"></a>19.1.5 共享资源的保护</h3><p>竞争是由并发访问同一个共享资源产生的。为了防止“竞争”的产生就要对共享资源进行保护，这里提到的共享资源又是什么呢？</p>
<p>以实际生活中的共享资源为例，可以是公共电话，也可以是共享单车、共享充电宝等公共物品，以上都属于共享资源的范畴，以公共电话为例，每个人都可以对它进行使用，但在同一时间内只能由一个人进行使用，如果两个人都要对电话进行使用，则产生了竞争。而在实际的驱动的代码中，共享资源可以是全局变量，也可以是驱动中的设备结构体等，需要根据具体的驱动程序来进行分析。在下一小节的实验中，会以全局变量为例，进行并发与竞争实验。</p>
<h2 id="19-2-实验程序的编写"><a href="#19-2-实验程序的编写" class="headerlink" title="19.2 实验程序的编写"></a>19.2 实验程序的编写</h2><h3 id="19-2-1-驱动程序编写"><a href="#19-2-1-驱动程序编写" class="headerlink" title="19.2.1 驱动程序编写"></a>19.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\14\module。</p>
<p>本实验将编写并发与竞争的驱动代码，首先完善字符设备驱动框架，然后通过copy_from_user(…)函数接收用户空间传递到内核空间的数据并进行判断，如果接收到的字符串数据为“topeet”会在睡眠4秒钟后打印接收到的数据，如果接收到的字符串数据为“itop”会在睡眠2秒钟后打印接收到的数据。</p>
<p>编写完成的example.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;\nthis is open_test \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//printk(&quot;\nthis is release_test \n&quot;);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对于重要逻辑部分已经加粗，后续章节的实验都是对上述并发与竞争实验的改进，以不同的方式来避免竞争的产生。</p>
<h3 id="19-2-2-编写测试-APP"><a href="#19-2-2-编写测试-APP" class="headerlink" title="19.2.2 编写测试 APP"></a>19.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\14\app。</p>
<p>本测试app较为简单，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="19-3-运行测试"><a href="#19-3-运行测试" class="headerlink" title="19.3 运行测试"></a>19.3 运行测试</h2><h3 id="19-3-1-编译驱动程序"><a href="#19-3-1-编译驱动程序" class="headerlink" title="19.3.1 编译驱动程序"></a>19.3.1 编译驱动程序</h3><p>在上一小节中的example.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += example.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放example.c和Makefile文件目录下，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps112.jpg" alt="img"> </p>
<p>图 19-4</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图19-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps113.jpg" alt="img"> </p>
<p>图 19-5</p>
<p>编译完生成example.ko目标文件，如下图（图19-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps114.jpg" alt="img"> </p>
<p>图 19-6</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h3 id="19-3-2-编译应用程序"><a href="#19-3-2-编译应用程序" class="headerlink" title="19.3.2 编译应用程序"></a>19.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图19-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps115.jpg" alt="img"> </p>
<p>图 19-7</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图19-8）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps116.jpg" alt="img"> </p>
<p>图 19-8</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="19-3-3-运行测试"><a href="#19-3-3-运行测试" class="headerlink" title="19.3.3 运行测试"></a>19.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图19-9）所示：</p>
<p>insmod example.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps117.jpg" alt="img"> </p>
<p>图 19-9</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图19-10）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps118.jpg" alt="img"> </p>
<p>图 19-10</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图19-11）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps119.jpg" alt="img"> </p>
<p>图 19-11</p>
<p>可以看到传递的buf值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图19-12）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet &amp;</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test itop &amp;</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps120.jpg" alt="img"> </p>
<p>图 19-12</p>
<p>在不存在竞争的情况下，传递的两个字符串数据应该是topeet和itop，而在上图中的打印信息为两个itop，原因是第二个app应用程序运行之后对共享资源进行了修改，两个app应用程序就产生了竞争关系，会在之后的章节中使用不同的方法对上述驱动程序进行改进，从而避免竞争的产生。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图19-13）所示：</p>
<p>rmmod  example.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps121.jpg" alt="img"> </p>
<p>图 19-13</p>
<p>至此，并发与竞争的实验就完成了。</p>
<h1 id="第20章-原子操作实验"><a href="#第20章-原子操作实验" class="headerlink" title="第20章 原子操作实验"></a>第20章 原子操作实验</h1><p>在上一章节的实验中，对并发与竞争进行了实验，两个app应用程序之间对共享资源的竞争访问引起了数据传输错误，而在Linux内核中，提供了四种处理并发与竞争的常见方法，分别是原子操作、自旋锁、信号量、互斥体，在之后的几个章节中会依次对上述四种方法进行讲解。</p>
<p>本章首先对四种常见方法中的原子操作进行讲解。</p>
<h2 id="20-1-原子操作"><a href="#20-1-原子操作" class="headerlink" title="20.1 原子操作"></a>20.1 原子操作</h2><p>“原子”是化学世界中不可再分的最小微粒，一切物质都由原子组成。在Linux内核中的原子操作可以理解为“不可被拆分的操作”，就是不能被更高等级中断抢夺优先的操作。在C语言中可以使用以下代码对一个整形变量赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> v;<span class="comment">//定义一个int类型的变量v</span></span><br><span class="line">v = <span class="number">1</span>;<span class="comment">//将int类型的变量v赋值为1</span></span><br></pre></td></tr></table></figure>

<p>而上述代码仍然不是“不可拆分的操作”，C语言程序仍然需要翻译成汇编指令，在汇编指令的执行过程中仍可能会有竞争的产生。而原子操作会将整形变量的操作当成一个整体，不可再进行分割。而原子操作又可以进一步细分为“整型原子操作”和“位原子操作”，这里首先对****整型原子操作****进行讲解。</p>
<p>在Linux内核中使用 atomic_t和atomic64_t结构体分别来完成32位系统和64位系统的整形数据原子操作，两个结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;types.h”文件中，具体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     <span class="type">int</span> counter;</span><br><span class="line"> &#125; <span class="type">atomic_t</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     <span class="type">long</span> counter;</span><br><span class="line">&#125; <span class="type">atomic64_t</span>;</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>例如可以使用以下代码定义一个64位系统的原子整形变量：</p>
<p>atomic64_t v;</p>
<p>在成功定义原子变量之后，必然要对原子变量进行读取、加减等动作，原子操作的部分常用API函数如下所示，定义在“内核源码&#x2F;include&#x2F;linux&#x2F;atomic.h”文件中，所以在接下来的实验中需要加入该头文件的引用。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ATOMIC_INIT(int i)</td>
<td>定义原子变量的时候对其初始化，赋值为i</td>
</tr>
<tr>
<td>int atomic_read(atomic_t *v)</td>
<td>读取v的值，并且返回。</td>
</tr>
<tr>
<td>void atomic_set(atomic_t *v, int i)</td>
<td>向原子变量v写入i值。</td>
</tr>
<tr>
<td>void atomic_add(int i, atomic_t *v)</td>
<td>原子变量v加上i值。</td>
</tr>
<tr>
<td>void atomic_sub(int i, atomic_t *v)</td>
<td>原子变量v减去i值。</td>
</tr>
<tr>
<td>void atomic_inc(atomic_t *v)</td>
<td>原子变量v加1</td>
</tr>
<tr>
<td>void atomic_dec(atomic_t *v)</td>
<td>原子变量v减1</td>
</tr>
<tr>
<td>int atomic_dec_return(atomic_t *v)</td>
<td>原子变量v减1，并返回v的值。</td>
</tr>
<tr>
<td>int atomic_inc_return(atomic_t *v)</td>
<td>原子变量v加 1，并返回v的值。</td>
</tr>
<tr>
<td>int atomic_sub_and_test(int i, atomic_t *v)</td>
<td>原子变量v减 i，如果结果为0就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_dec_and_test(atomic_t *v)</td>
<td>原子变量v减 1，如果结果为0就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_inc_and_test(atomic_t *v)</td>
<td>原子变量v加 1，如果结果为0就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_add_negative(int i, atomic_t *v)</td>
<td>原子变量v加 i，如果结果为负就返回真，否则返回假</td>
</tr>
</tbody></table>
<p>图表20- 1</p>
<p>至此，对于整型原子操作的相关API函数就讲解完成了，会在下一小节中使用上述原子整形操作API进行相应的实验。</p>
<p>下面对原子位操作进行讲解，和原子整形变量不同，原子位操作没有 atomic_t 的数据结构，原子位操作是直接对内存进行操作，原子位操作相关API函数如下（图表20-2）所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void set_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位置 1。</td>
</tr>
<tr>
<td>void clear_bit(int nr,void *p)</td>
<td>将 p 地址的第 nr 位清零。</td>
</tr>
<tr>
<td>void change_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位进行翻转。</td>
</tr>
<tr>
<td>int test_bit(int nr, void *p)</td>
<td>获取 p 地址的第 nr 位的值。</td>
</tr>
<tr>
<td>int test_and_set_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位置 1，并且返回 nr 位原来的值。</td>
</tr>
<tr>
<td>int test_and_clear_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位清零，并且返回 nr 位原来的值。</td>
</tr>
<tr>
<td>int test_and_change_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位翻转，并且返回 nr 位原来的值。</td>
</tr>
</tbody></table>
<p>图表20- 2</p>
<p>对于原子位操作的知识就不再深入讲解和实验，感兴趣的同学可以到相关网站上进行自主学习。</p>
<p>在下一小节中，将会使用原子整形操作对19章的并发与竞争实验进行改进。</p>
<h2 id="20-2-实验程序的编写"><a href="#20-2-实验程序的编写" class="headerlink" title="20.2 实验程序的编写"></a>20.2 实验程序的编写</h2><h3 id="20-2-1-驱动程序编写"><a href="#20-2-1-驱动程序编写" class="headerlink" title="20.2.1 驱动程序编写"></a>20.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\15\module。</p>
<p>为了解决第19章实验中并发与竞争的问题，本章节实验将加入原子整形操作相关实验代码，在open()函数和release()函数中加入原子整形变量v的赋值代码，并且在open()函数中加入原子整形变量v的判断代码，从而实现同一时间内只允许一个应用打开该设备节点，以此来防止共享资源竞争的产生。</p>
<p>编写完成的atomic.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">atomic64_t</span> v = ATOMIC_INIT(<span class="number">1</span>);<span class="comment">//初始化原子类型变量v,并设置为1</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(atomic64_read(&amp;v) != <span class="number">1</span>)&#123;<span class="comment">//读取原子类型变量v的值并判断是否等于1</span></span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line">	atomic64_set(&amp;v,<span class="number">0</span>);<span class="comment">//将原子类型变量v的值设置为0</span></span><br><span class="line">	<span class="comment">//printk(&quot;\nthis is open_test \n&quot;);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//printk(&quot;\nthis is release_test \n&quot;);</span></span><br><span class="line">	atomic64_set(&amp;v,<span class="number">1</span>);<span class="comment">//将原子类型变量v的值赋1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">	dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="20-2-2-编写测试-APP"><a href="#20-2-2-编写测试-APP" class="headerlink" title="20.2.2 编写测试 APP"></a>20.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\15\app。</p>
<p>本测试app代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-3-运行测试"><a href="#20-3-运行测试" class="headerlink" title="20.3 运行测试"></a>20.3 运行测试</h2><h3 id="20-3-1-编译驱动程序"><a href="#20-3-1-编译驱动程序" class="headerlink" title="20.3.1 编译驱动程序"></a>20.3.1 编译驱动程序</h3><p>在上一小节中的atomic.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += atomic.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放atomic.c和Makefile文件目录下，如下图（图20-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps122.jpg" alt="img"> </p>
<p>图 20-4</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图20-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps123.jpg" alt="img"> </p>
<p>图 20-5</p>
<p>编译完生成atomic.ko目标文件，如下图（图20-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps124.jpg" alt="img"> </p>
<p>图 20-6</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h3 id="20-3-2-编译应用程序"><a href="#20-3-2-编译应用程序" class="headerlink" title="20.3.2 编译应用程序"></a>20.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图20-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps125.jpg" alt="img"> </p>
<p>图 20-7</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图20-8）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps126.jpg" alt="img"> </p>
<p>图 20-8</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="20-3-3-运行测试"><a href="#20-3-3-运行测试" class="headerlink" title="20.3.3 运行测试"></a>20.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图20-9）所示：</p>
<p>insmod atomic.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps127.jpg" alt="img"> </p>
<p>图 20-9</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图20-10）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps128.jpg" alt="img"> </p>
<p>图 20-10</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图20-11）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps129.jpg" alt="img"> </p>
<p>图 20-11</p>
<p>可以看到传递的buf值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图20-12）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet &amp;</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test itop </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps130.jpg" alt="img"> </p>
<p>图 20-12</p>
<p>​	可以看到应用程序在打开第二次&#x2F;dev&#x2F;device_test 文件的时候，出现了“file open failed”打印，证明文件打开失败，只有在第一个应用关闭相应的文件之后，下一个应用才能打开，通过限制同一时间内设备访问数量，来对共享资源进行保护。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图20-13）所示：</p>
<p>rmmod flag.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps131.jpg" alt="img"> </p>
<p>图 20-13</p>
<p>至此，原子操作实验就完成了。</p>
<h1 id="第21章-自旋锁实验"><a href="#第21章-自旋锁实验" class="headerlink" title="第21章 自旋锁实验"></a>第21章 自旋锁实验</h1><p>在上一节中对原子操作进行了讲解，并使用原子整形操作对并发与竞争实验进行了改进，但是原子操作只能对整形变量或者位进行保护，而对于结构体或者其他类型的共享资源，原子操作就力不从心了，这时候就轮到自旋锁的出场了，下面就让我们一起来进行自旋锁的学习吧。</p>
<h2 id="21-1-自旋锁"><a href="#21-1-自旋锁" class="headerlink" title="21.1 自旋锁"></a>21.1 自旋锁</h2><p>自旋锁是为了保护共享资源提出的一种锁机制。自旋锁（spin lock）是一种非阻塞锁，也就是说，如果某线程需要获取锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取锁。</p>
<p>在有些场景中，同步资源(用来保持一致性的两个或多个资源)的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果计算机有多个CPU核心，能够让两个或以上的线程同时并行执行，这样我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，直到持有锁的线程释放锁，后面请求锁的线程才可以获取锁。</p>
<p>为了让后面那个请求锁的线程“稍等一下”，我们需让它进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么该线程便不必阻塞，并且直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。我们再举个形象生动的例子，以现实生活中银行ATM机办理业务为例，ATM机防护舱在同一时间内只允许一个人进入，当有人进入ATM机防护舱之后，两秒钟之后自动上锁，其他也想要存取款的人员，只能在外部等待，办理完相应的存取款业务之后，舱内人员需要手动打开防护锁，其他人才能进入其中，办理业务。而自旋锁在驱动中的使用和上述ATM机办理业务流程相同，当一个任务要访问某个共享资源之前需要先获取相应的自旋锁，自旋锁只能被一个任务持有，在该任务持有自旋锁的过程中，其他任务只能原地等待该自旋锁的释放，在等待过程中的任务同样会持续占用CPU，消耗CPU资源，所以临界区的代码不能太多。</p>
<p>如果自旋锁被错误使用可能会导致死锁的产生，对于自旋锁死锁会在下一章节进行详细说明，并进行相应的实验。</p>
<p>内核中以spinlock_t结构体来表示自旋锁，定义在“内核源码&#x2F;include&#x2F;linux&#x2F;spinlock_types.h”文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            u8 __padding[LOCK_PADSIZE];</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     &#125;;</span><br><span class="line">&#125; <span class="type">spinlock_t</span>;</span><br></pre></td></tr></table></figure>

<p>自旋锁相关API函数定义在“内核源码&#x2F;include&#x2F;linux&#x2F;spinlock.h”文件中，所以在本章节的实验中要加入该头文件（spinlock.h头文件包含spinlock_types.h等，所以只需加入spinlock.h头文件即可），部分API函数如下（表 21-1）所示，</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_SPINLOCK(spinlock_t lock)</td>
<td>定义并初始化自旋锁。</td>
</tr>
<tr>
<td>int spin_lock_init(spinlock_t *lock)</td>
<td>初始化自旋锁。</td>
</tr>
<tr>
<td>void spin_lock(spinlock_t *lock)</td>
<td>获取指定的自旋锁，也叫做加锁。</td>
</tr>
<tr>
<td>void spin_unlock(spinlock_t *lock)</td>
<td>释放指定的自旋锁。</td>
</tr>
<tr>
<td>int spin_trylock(spinlock_t *lock)</td>
<td>尝试获取指定的自旋锁，如果没有获取到就返回 0</td>
</tr>
<tr>
<td>int spin_is_locked(spinlock_t *lock)</td>
<td>检查指定的自旋锁是否被获取，如果没有被获取就返回非0，否则返回 0。</td>
</tr>
</tbody></table>
<p>表 21-1</p>
<p>除了上述API之外还有其他与终端相关的自旋锁API函数，会在接下来的自旋锁死锁章节进行讲解。</p>
<p>自旋锁的使用步骤：</p>
<p>1 在访问临界资源的时候先申请自旋锁</p>
<p>2 获取到自旋锁之后就进入临界区，获取不到自旋锁就“原地等待”。</p>
<p>3 退出临界区的时候要释放自旋锁。</p>
<p>在下一小节中将使用上述自旋锁API进行相应的实验，利用自旋锁相关知识来对第19章节的并发与竞争实验进行优化。</p>
<h2 id="21-2-实验程序的编写"><a href="#21-2-实验程序的编写" class="headerlink" title="21.2 实验程序的编写"></a>21.2 实验程序的编写</h2><h3 id="21-2-1-驱动程序编写"><a href="#21-2-1-驱动程序编写" class="headerlink" title="21.2.1 驱动程序编写"></a>21.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\16\module。</p>
<p>与上一章节使用原子整形操作避免并发与竞争逻辑相同，在驱动入口函数初始化自旋锁，然后在open函数中使用自旋锁实现对设备的互斥访问，最后在 release 函数中解锁，表示设备被释放了，可以被其他的应用程序使用。上述操作都将共享资源由自旋锁进行保护，从而实现同一时间内只允许一个应用打开该设备节点，以此来防止共享资源竞争的产生。</p>
<p>编写完成的spinlock.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">spinlock_t</span> spinlock_test;<span class="comment">//定义spinlock_t类型的自旋锁变量spinlock_test</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> flag = <span class="number">1</span>;<span class="comment">//定义flag标准为，flag等于1表示设备没有被打开，等于0则证明设备已经被打开了</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//printk(&quot;\nthis is open_test \n&quot;);</span></span><br><span class="line">	spin_lock(&amp;spinlock_test);<span class="comment">//自旋锁加锁</span></span><br><span class="line">	<span class="keyword">if</span>(flag != <span class="number">1</span>)&#123;<span class="comment">//判断标志位flag的值是否等于1</span></span><br><span class="line">spin_unlock(&amp;spinlock_test);<span class="comment">//自旋锁解锁</span></span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line">	 &#125;</span><br><span class="line">	flag = <span class="number">0</span>;<span class="comment">//将标志位的值设置为0</span></span><br><span class="line">	spin_unlock(&amp;spinlock_test);<span class="comment">//自旋锁解锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;\nthis is release_test \n&quot;</span>);</span><br><span class="line">	spin_lock(&amp;spinlock_test);<span class="comment">//自旋锁加锁</span></span><br><span class="line">	flag = <span class="number">1</span>;</span><br><span class="line">	spin_unlock(&amp;spinlock_test);<span class="comment">//自旋锁解锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	spin_lock_init(&amp;spinlock_test);</span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">	dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="21-2-2-编写测试-APP"><a href="#21-2-2-编写测试-APP" class="headerlink" title="21.2.2 编写测试 APP"></a>21.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\16\app。</p>
<p>本测试app代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="21-3-运行测试"><a href="#21-3-运行测试" class="headerlink" title="21.3 运行测试"></a>21.3 运行测试</h2><h3 id="21-3-1-编译驱动程序"><a href="#21-3-1-编译驱动程序" class="headerlink" title="21.3.1 编译驱动程序"></a>21.3.1 编译驱动程序</h3><p>在上一小节中的spinlock.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += spinlock.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放spinlock.c和Makefile文件目录下，如下图（图21-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps132.jpg" alt="img"> </p>
<p>图 21-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图21-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps133.jpg" alt="img"> </p>
<p>图 21-3</p>
<p>编译完生成spinlock.ko目标文件，如下图（图21-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps134.jpg" alt="img"> </p>
<p>图 21-4</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h3 id="21-3-2-编译应用程序"><a href="#21-3-2-编译应用程序" class="headerlink" title="21.3.2 编译应用程序"></a>21.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图21-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps135.jpg" alt="img"> </p>
<p>图 21-5</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图21-6）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps136.jpg" alt="img"> </p>
<p>图 21-6</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="21-3-3-运行测试"><a href="#21-3-3-运行测试" class="headerlink" title="21.3.3 运行测试"></a>21.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图21-7）所示：</p>
<p>insmod spinlock.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps137.jpg" alt="img"> </p>
<p>图21-7</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（21-8）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps138.jpg" alt="img"> </p>
<p>图 21-8</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图21-9）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps139.jpg" alt="img"> </p>
<p>图 21-9</p>
<p>可以看到传递的buf值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图21-10）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet &amp;</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test itop </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps140.jpg" alt="img"> </p>
<p>图 21-10</p>
<p>​	可以看到应用程序在打开第二次&#x2F;dev&#x2F;device_test 文件的时候，出现了“file open failed”打印，证明文件打开失败，只有在第一个应用关闭相应的文件之后，下一个应用才能打开。本次实验的自旋锁只是对标志位flag进行保护，flag用来表示设备的状态，确保同一时间内，该设备只能被一个应用程序打开。进而对共享资源进行保护。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图21-11）所示：</p>
<p>rmmod spinlock.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps141.jpg" alt="img"> </p>
<p>图 21-11</p>
<p>至此，自旋锁实验就完成了。</p>
<h1 id="第22章-自旋锁死锁实验"><a href="#第22章-自旋锁死锁实验" class="headerlink" title="第22章 自旋锁死锁实验"></a>第22章 自旋锁死锁实验</h1><p>在上一小节中，学习了内核中自旋锁的使用，而自旋锁若是使用不当就会产生死锁，在本章将会对自旋锁的特殊情况-死锁进行讲解。</p>
<h2 id="22-1-自旋锁死锁"><a href="#22-1-自旋锁死锁" class="headerlink" title="22.1 自旋锁死锁"></a>22.1 自旋锁死锁</h2><p>死锁是指两个或多个事物在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。当多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进，这种情况就是死锁。</p>
<p>自旋锁死锁发生存在两种情况：</p>
<p>（1）第一种情况是拥有自旋锁的进程A在内核态阻塞了，内核调度B进程，碰巧B进程也要获得自旋锁，此时B只能自旋转。而此时抢占已经关闭(在单核条件下)不会调度A进程了，B永远自旋，产生死锁，如下图（图 22-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps142.jpg" alt="img"> </p>
<p>图 22-1</p>
<p>相应的解决办法是，在自旋锁的使用过程中要尽可能短的时间内拥有自旋锁，而且不能在临界区中调用导致线程休眠的函数。</p>
<p>第二种情况是进程A拥有自旋锁，中断到来，CPU执行中断函数，中断处理函数，中断处理函数需要获得自旋锁，访问共享资源，此时无法获得锁，只能自旋，从而产生死锁，如下图（图22-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps143.jpg" alt="img"> </p>
<p>图 22-2</p>
<p>对于中断引发的死锁，最好的解决方法就是在获取锁之前关闭本地中断，Linux内核在“&#x2F;include&#x2F;linux&#x2F;spinlock.h”文件中提供了相应的API 函数，如下（图22-3）所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void spin_lock_irq(spinlock_t *lock)</td>
<td>禁止本地中断，并获取自旋锁。</td>
</tr>
<tr>
<td>void spin_unlock_irq(spinlock_t *lock)</td>
<td>激活本地中断，并释放自旋锁。</td>
</tr>
<tr>
<td>void spin_lock_irqsave(spinlock_t *lock, unsigned long flags)</td>
<td>恢复中断状态，关闭中断并获取自旋锁。</td>
</tr>
<tr>
<td>void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)</td>
<td>将中断状态恢复到以前的状态，打开中断并释放自旋锁</td>
</tr>
<tr>
<td>void spin_lock_bh(spinlock_t *lock)</td>
<td>关闭下半部，获取自旋锁</td>
</tr>
<tr>
<td>void spin_unlock_bh(spinlock_t *lock)</td>
<td>打开下半部，获取自旋锁</td>
</tr>
</tbody></table>
<p>表 22-3</p>
<p>由于Linux内核运行是非常复杂的，很难确定某个时刻的中断状态，因此建议使用 spin_lock_irqsave&#x2F;spin_unlock_irqrestore，因为这一组函数会保存中断状态，在释放锁的时候会恢复中断状态。</p>
<p>在下一小节中将进行自旋锁死锁实验，本次实验所采取的是第一种情况，即拥有自旋锁的进程A在内核态阻塞了，内核调度B进程，碰巧B进程也要获得自旋锁，依次产生死锁。</p>
<h2 id="22-2-实验程序的编写"><a href="#22-2-实验程序的编写" class="headerlink" title="22.2 实验程序的编写"></a>22.2 实验程序的编写</h2><h3 id="22-2-1-驱动程序编写"><a href="#22-2-1-驱动程序编写" class="headerlink" title="22.2.1 驱动程序编写"></a>22.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\17\module。</p>
<p>本章节实验以19章并发与竞争实验为基础，在open()函数中加入了自旋锁加锁，在close()函数中加入了自旋锁解锁，由于在write()函数中存在sleep()睡眠函数，所以会造成内核阻塞，睡眠期间如果使用另一个进程获取该自旋锁，就会造成死锁。</p>
<p>编写完成的dielock.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">spinlock_t</span> spinlock_test;<span class="comment">//定义spinlock_t类型的自旋锁变量spinlock_test</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//printk(&quot;\nthis is open_test \n&quot;);</span></span><br><span class="line">	spin_lock(&amp;spinlock_test);<span class="comment">//自旋锁加锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;\nthis is release_test \n&quot;</span>);</span><br><span class="line">	spin_unlock(&amp;spinlock_test);<span class="comment">//自旋锁解锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	spin_lock_init(&amp;spinlock_test);</span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">	dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="22-2-2-编写测试-APP"><a href="#22-2-2-编写测试-APP" class="headerlink" title="22.2.2 编写测试 APP"></a>22.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\17\app。</p>
<p>本测试app代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于本次测试的CPU为多核心CPU，其他核心仍旧可以调度其他进程，所以需要多次使用taskset函数指定CPU进行进程的运行，以此来产生死锁，在与app.c同级目录下创建名为app.sh的脚本文件，脚本内容如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">taskset -c 0 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 1 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 2 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 3 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 0 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 1 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 2 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 3 ./app /dev/device_test topeet &amp;</span><br></pre></td></tr></table></figure>

<p>保存退出之后，需要使用以下命令赋予脚本可执行权限，如下图（图22-4）所示：</p>
<p>chmod 777 app.sh</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps144.jpg" alt="img"> </p>
<p>图 22-4</p>
<p>至此测试程序app.c和运行脚本app.sh就编写完成了。</p>
<h2 id="22-3-运行测试"><a href="#22-3-运行测试" class="headerlink" title="22.3 运行测试"></a>22.3 运行测试</h2><h3 id="22-3-1-编译驱动程序"><a href="#22-3-1-编译驱动程序" class="headerlink" title="22.3.1 编译驱动程序"></a>22.3.1 编译驱动程序</h3><p>在上一小节中的dielock.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += dielock.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放dielock.c和Makefile文件目录下，如下图（图22-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps145.jpg" alt="img"> </p>
<p>图 22-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图22-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps146.jpg" alt="img"> </p>
<p>图 22-6</p>
<p>编译完生成dielock.ko目标文件，如下图（图22-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps147.jpg" alt="img"> </p>
<p>图 22-7</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h3 id="22-3-2-编译应用程序"><a href="#22-3-2-编译应用程序" class="headerlink" title="22.3.2 编译应用程序"></a>22.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图22-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps148.jpg" alt="img"> </p>
<p>图 22-8</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图22-9）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps149.jpg" alt="img"> </p>
<p>图 22-9</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="22-3-3-运行测试"><a href="#22-3-3-运行测试" class="headerlink" title="22.3.3 运行测试"></a>22.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图22-10）所示：</p>
<p>insmod dielock.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps150.jpg" alt="img"> </p>
<p>图 22-10</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图22-11）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps151.jpg" alt="img"> </p>
<p>图 22-11</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行app.sh脚本，该脚本会指定CPU在加锁之后进入内核休眠状态，如下图（图22-12）所示：</p>
<p>.&#x2F;app.sh</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps152.jpg" alt="img"> </p>
<p>图 22-12</p>
<p>​	在指令输入之后，串口终端无法输入，引发了死锁，进而造成了系统崩溃，所以在编写驱动的过程中，要尽可能的避免死锁的出现。</p>
<p>至此，自旋锁死锁驱动实验就完成了。</p>
<h1 id="第23章-信号量实验"><a href="#第23章-信号量实验" class="headerlink" title="第23章 信号量实验"></a>第23章 信号量实验</h1><p>在上面两个章节对自旋锁和自旋锁死锁进行了学习，自旋锁会让请求的任务原地“自旋”，在等待的过程中会循环检测自旋锁的状态，进而占用系统资源，而本章节要讲解的信号量也是解决竞争的一种常用方法，与自旋锁不同的是，信号量会使等待的线程进入休眠状态，适用于那些占用资源比较久的场合。下面对信号量相关知识的进行讲解。</p>
<h2 id="23-1-信号量"><a href="#23-1-信号量" class="headerlink" title="23.1 信号量"></a>23.1 信号量</h2><p>信号量是操作系统中最典型的用于同步和互斥的手段，本质上是一个全局变量，信号量的值表示控制访问资源的线程数，可以根据实际情况来自行设置，如果在初始化的时候将信号量量值设置为大于1，那么这个信号量就是计数型信号量，允许多个线程同时访问共享资源。如果将信号量量值设置为1，那么这个信号量就是二值信号量，同一时间内只允许一个线程访问共享资源，注意！信号量的值不能小于0。当信号量的值为0时，想访问共享资源的线程必须等待，直到信号量大于0时，等待的线程才可以访问。当访问共享资源时，信号量执行“减一”操作，访问完成后再执行“加一”操作。</p>
<p>相比于自旋锁，信号量具有休眠特性，因此适用长时间占用资源的场合，但由于信号量会引起休眠，所以不能用在中断函数中，最后如果共享资源的持有时间比较短，使用信号量的话会造成频繁的休眠，反而带来更多资源的消耗，使用自旋锁反而效果更好。再同时使用信号量和自旋锁的时候，要先获取信号量，再使用自旋锁，因为信号量会导致睡眠。</p>
<p>以现实生活中的银行办理业务为例，银行的业务办理窗口就是共享资源，业务办理窗口的数量就是信号量量值，进入银行之后，客户需要领取相应的排序码，然后在休息区进行等待，可以看作线程的睡眠阶段，当前面的客户办理完业务之后，相应的窗口会空闲出来，可以看作信号量的释放，之后银行会通过广播，提醒下一位客户到指定的窗口进行业务的办理，可以看作线程的唤醒并获取到信号量，访问共享资源的过程。</p>
<p>Linux 内核使用semaphore结构体来表示信号量，该结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;semaphore.h”文件内（所以在下一章节的信号量实验中需要加入该头文件），结构体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="type">raw_spinlock_t</span>      lock;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 与信号量相关的 API 函数同样定义在semaphore.h文件内，部分常用API函数如下（表23-1）所示： </p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_SEAMPHORE(name)</td>
<td>定义信号量，并且设置信号量的值为 1。</td>
</tr>
<tr>
<td>void sema_init(struct semaphore *sem, int val)</td>
<td>初始化信号量 sem，设置信号量值为 val。</td>
</tr>
<tr>
<td>void down(struct semaphore *sem)</td>
<td>获取信号量，不能被中断打断，如ctrl+c</td>
</tr>
<tr>
<td>int down_interruptible(struct semaphore *sem)</td>
<td>获取信号量，可以被中断打断，如ctrl+c</td>
</tr>
<tr>
<td>void up(struct semaphore *sem)</td>
<td>释放信号量</td>
</tr>
<tr>
<td>int down_trylock(struct semaphore *sem);</td>
<td>尝试获取信号量，如果能获取到信号量就获取，并且返回 0。如果不能就返回非 0</td>
</tr>
</tbody></table>
<p>表 23-1</p>
<p>至此，关于信号量相关的知识就讲解完成了，上述API函数会在下一小节的实验中用到。</p>
<h2 id="23-2-实验程序的编写"><a href="#23-2-实验程序的编写" class="headerlink" title="23.2 实验程序的编写"></a>23.2 实验程序的编写</h2><h3 id="23-2-1-驱动程序编写"><a href="#23-2-1-驱动程序编写" class="headerlink" title="23.2.1 驱动程序编写"></a>23.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\18\module。</p>
<p>与之前章节设置标志位，在同一时间内只允许一个任务对共享资源进行访问的方式所不同，本小节将采用信号量的方式避免竞争的产生。本实验设置的信号量量值为1，所以需要在open()函数中加入信号量获取函数，在release()函数中加入信号量释放函数即可。</p>
<p>编写完成的semaphore.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">semaphore_test</span>;</span><span class="comment">//定义一个semaphore类型的结构体变量semaphore_test</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;\nthis is open_test \n&quot;</span>);</span><br><span class="line">down(&amp;semaphore_test);<span class="comment">//信号量数量减1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">up(&amp;semaphore_test);<span class="comment">//信号量数量加1</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is release_test \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	sema_init(&amp;semaphore_test,<span class="number">1</span>);<span class="comment">//初始化信号量结构体semaphore_test，并设置信号量的数量为1</span></span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">	dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="23-2-2-编写测试-APP"><a href="#23-2-2-编写测试-APP" class="headerlink" title="23.2.2 编写测试 APP"></a>23.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\18\app。</p>
<p>本测试app代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="23-3-运行测试"><a href="#23-3-运行测试" class="headerlink" title="23.3 运行测试"></a>23.3 运行测试</h2><h3 id="23-3-1-编译驱动程序"><a href="#23-3-1-编译驱动程序" class="headerlink" title="23.3.1 编译驱动程序"></a>23.3.1 编译驱动程序</h3><p>在上一小节中的semaphore.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += semaphore.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放semaphore.c和Makefile文件目录下，如下图（图23-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps153.jpg" alt="img"> </p>
<p>图 23-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图23-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps154.jpg" alt="img"> </p>
<p>图 23-3</p>
<p>编译完生成semaphore.ko目标文件，如下图（图23-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps155.jpg" alt="img"> </p>
<p>图 23-4</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的安装。</p>
<h3 id="23-3-2-编译应用程序"><a href="#23-3-2-编译应用程序" class="headerlink" title="23.3.2 编译应用程序"></a>23.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图 23-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps156.jpg" alt="img"> </p>
<p>图 23-5</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图23-6）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps157.jpg" alt="img"> </p>
<p>图23-6</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="23-3-3-运行测试"><a href="#23-3-3-运行测试" class="headerlink" title="23.3.3 运行测试"></a>23.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 23-7）所示：</p>
<p>insmod semaphore.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps158.jpg" alt="img"> </p>
<p>图 23-7</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图23-8）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps159.jpg" alt="img"> </p>
<p>图 23-8</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图23-9）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps160.jpg" alt="img"> </p>
<p>图 23-9</p>
<p>可以看到传递的buf值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图23-10）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet &amp;</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test itop </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps161.jpg" alt="img"> </p>
<p>图 23-10</p>
<p>​	上述打印信息正常，证明数据被正确传递了，没有发生共享资源的竞争，第一个任务运行之后，由于设置的信号量量值为1，所以第二个任务会进入休眠状态，第一个任务执行完毕之后，会唤醒第二个任务去执行，所以避免了并发与竞争。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图 23-11）所示：</p>
<p>rmmod semaphore.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps162.jpg" alt="img"> </p>
<p>图 23-11</p>
<p>至此，信号量实验就完成了。</p>
<h1 id="第24章-互斥锁实验"><a href="#第24章-互斥锁实验" class="headerlink" title="第24章 互斥锁实验"></a>第24章 互斥锁实验</h1><p>在上一章节中对信号量进行了学习，而本章节要学习的互斥锁可以说是“量值”为 1 的信号量，最终实现的效果相同，既然有了信号量，那为什么还要有互斥锁呢，带着疑问，让我们来进行本章节的学习吧！</p>
<h2 id="24-1-互斥锁"><a href="#24-1-互斥锁" class="headerlink" title="24.1 互斥锁"></a>24.1 互斥锁</h2><p>在上一章节中，将信号量量值设置为1，最终实现的就是互斥效果，与本章节要学习的互斥锁功能相同，虽然两者功能相同但是具体的实现方式是不同的，但是使用互斥锁效率更高、更简洁，所以如果使用到的信号量“量值”为 1，一般将其修改为使用互斥锁实现。</p>
<p>当有多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制。线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。互斥锁为资源引入一个状态：锁定或者非锁定。某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性，能够保证多个线程访问共享数据不会出现资源竞争及数据错误。</p>
<p>为了方便大家理解，这里举个例子来说明。比如公司部门里，我在使用着打印机打印东西的同时（还没有打印完），别人刚好也在此刻使用打印机打印东西，如果不做任何处理的话，打印出来的东西肯定是错乱的。那么怎么解决这种情况呢？只要我在打印着的时候别人是不允许打印的，只有等我打印结束后别人才允许打印。这个过程有点类似于，把打印机放在一个房间里，给这个房间安把锁，这个锁默认是打开的。当 A 需要打印时，他先过来检查这把锁有没有锁着，没有的话就进去，同时上锁在房间里打印。而在这时，刚好 B 也需要打印，B 同样先检查锁，发现锁是锁住的，他就在门外等着。而当 A 打印结束后，他会开锁出来，这时候 B 才进去上锁打印。看了这个例子，相信大家已经理解了互斥锁。</p>
<p>互斥锁会导致休眠，所以在中断里面不能用互斥锁。同一时刻只能有一个线程持有互斥锁，并且只有持有者才可以解锁，并且不允许递归上锁和解锁。</p>
<p>内核中以mutex结构体来表示互斥体，定义在“内核源码&#x2F;include&#x2F;linux&#x2F;mutex.h”文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_long_t</span>       owner;</span><br><span class="line">    <span class="type">spinlock_t</span>      wait_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MUTEX_SPIN_ON_OWNER</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">optimistic_spin_queue</span> <span class="title">osq</span>;</span> <span class="comment">/* Spinner MCS lock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">    <span class="type">void</span>            *magic;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>  <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一些和互斥体相关的API函数也定义在mutex.h文件中，常用API函数如下（表24-1）所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_MUTEX(name)</td>
<td>定义并初始化一个 mutex 变量。</td>
</tr>
<tr>
<td>void mutex_init(mutex *lock)</td>
<td>初始化 mutex。</td>
</tr>
<tr>
<td>void mutex_lock(struct mutex *lock)</td>
<td>获取 mutex，也就是给 mutex 上锁。如果获取不到就进休眠。</td>
</tr>
<tr>
<td>void mutex_unlock(struct mutex *lock)</td>
<td>释放 mutex，也就给 mutex 解锁。</td>
</tr>
<tr>
<td>int mutex_is_locked(struct mutex *lock)</td>
<td>判断 mutex 是否被获取，如果是的话就返回1，否则返回 0。</td>
</tr>
</tbody></table>
<p>表 24-1</p>
<p>至此，关于互斥体相关的知识就讲解完成了，在下一小节的实验中会对上述API函数进行运用。</p>
<h2 id="24-2-实验程序的编写"><a href="#24-2-实验程序的编写" class="headerlink" title="24.2 实验程序的编写"></a>24.2 实验程序的编写</h2><h3 id="24-2-1-驱动程序编写"><a href="#24-2-1-驱动程序编写" class="headerlink" title="24.2.1 驱动程序编写"></a>24.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\19\module。</p>
<p>本小节实验将使用互斥体对19章的并发与竞争实验进行改进，由于互斥体在同一时间内只允许一个任务对共享资源进行，所以除了在atomic_init()函数内加入初始化互斥锁函数之外，只需要在open()函数中加入互斥锁加锁函数，在release()函数中加入互斥锁解锁函数即可。</p>
<p>编写完成的mutex.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex_test</span>;</span><span class="comment">//定义mutex类型的互斥锁结构体变量mutex_test</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;\nthis is open_test \n&quot;</span>);</span><br><span class="line">	mutex_lock(&amp;mutex_test);<span class="comment">//互斥锁加锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex_unlock(&amp;mutex_test);<span class="comment">//互斥锁解锁</span></span><br><span class="line">printk(<span class="string">&quot;\nthis is release_test \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex_init(&amp;mutex_test);<span class="comment">//对互斥体进行初始化</span></span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">	dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="24-2-2-编写测试-APP"><a href="#24-2-2-编写测试-APP" class="headerlink" title="24.2.2 编写测试 APP"></a>24.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\19\app。</p>
<p>本测试app代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24-3-运行测试"><a href="#24-3-运行测试" class="headerlink" title="24.3 运行测试"></a>24.3 运行测试</h2><h3 id="24-3-1-编译驱动程序"><a href="#24-3-1-编译驱动程序" class="headerlink" title="24.3.1 编译驱动程序"></a>24.3.1 编译驱动程序</h3><p>在上一小节中的mutex.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += mutex.c    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放mutex.c和Makefile文件目录下，如下图（图24-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps163.jpg" alt="img"> </p>
<p>图 24-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图24-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps164.jpg" alt="img"> </p>
<p>图24-3</p>
<p>编译完生成mutex.ko目标文件，如下图（图 24-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps165.jpg" alt="img"> </p>
<p>图 24-4</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h3 id="24-3-2-编译应用程序"><a href="#24-3-2-编译应用程序" class="headerlink" title="24.3.2 编译应用程序"></a>24.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图 24-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps166.jpg" alt="img"> </p>
<p>图 24-5</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图 24-6）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps167.jpg" alt="img"> </p>
<p>图 24-6</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="24-3-3-运行测试"><a href="#24-3-3-运行测试" class="headerlink" title="24.3.3 运行测试"></a>24.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图24-7）所示：</p>
<p>insmod mutex.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps168.jpg" alt="img"> </p>
<p>图 24-7</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图24-8）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps169.jpg" alt="img"> </p>
<p>图 24-8</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图24-9）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps170.jpg" alt="img"> </p>
<p>图 24-9</p>
<p>可以看到传递的buf值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图24-10）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet &amp;</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test itop </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps171.jpg" alt="img"> </p>
<p>图 24-10</p>
<p>​	与23章实验测试现象相同，两个app被同时运行，最终打印信息正常，证明数据被正确传递了，没有发生共享资源的竞争，证明互斥量就起到了作用。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图24-11）所示：</p>
<p>rmmod mutex.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps172.jpg" alt="img"> </p>
<p>图 24-11</p>
<p>至此，互斥体实验就完成了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/" rel="tag">并发与竞争</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-rk3568-驱动开发第二篇-字符设备基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%8C%E7%AF%87-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%9F%BA%E7%A1%80/"
    >rk3568 驱动开发第二篇 字符设备基础</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%8C%E7%AF%87-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2023-09-04T12:55:19.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第7章-menuconfig图形化配置实验"><a href="#第7章-menuconfig图形化配置实验" class="headerlink" title="第7章 menuconfig图形化配置实验"></a>第7章 menuconfig图形化配置实验</h1><p>Linux内核可以通过输入“make menuconfig”来打开图形化配置界面，menuconfig是一套图形化的配置工具，本章节来学习使用menuconfig配置内核。</p>
<h2 id="7-1图形化界面的操作"><a href="#7-1图形化界面的操作" class="headerlink" title="7.1图形化界面的操作"></a>7.1图形化界面的操作</h2><p>menuconfig图形化的配置工具需要 ncurses 库支持。ncurses库提供了一系列的API函数供调用者生成基于文本的图形界面，因此在使用menuconfig图形化配置界面之前需要先在 Ubuntu 中安装ncurses库，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line"></span><br><span class="line">sudo apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure>

<p>图形化配置界面主要有以下四种，在这四种方式中，最推荐的是 make menuconfig，它不依赖于 QT 或 GTK+，且非常直观。</p>
<p>make config （基于文本的最为传统的配置界面，不推荐使用）</p>
<p>make menuconfig （基于文本菜单的配置界面）</p>
<p>make xconfig （要求 QT 被安装）</p>
<p>make gconfig （要求 GTK+ 被安装）</p>
<p>如何打开menuconfig图形化配置界面呢？</p>
<p>以RK3568为例，在内核源码目录下输入以下命令，打开图形化配置界面。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm64</span><br><span class="line"></span><br><span class="line">make rockchip_linux_defconfig</span><br><span class="line"></span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps33.jpg" alt="img"> </p>
<p>图 7-1</p>
<p>打开后界面如下所（图7-2）示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps34.jpg" alt="img"> </p>
<p>图 7-2</p>
<p>打开menuconfig图形化配置界面以后，可以使用以下方式进行操作，如下表（表7-3）所示：</p>
<table>
<thead>
<tr>
<th>上下键</th>
<th>选择不同的行，即移动到不同的（每一行的）选项上</th>
</tr>
</thead>
<tbody><tr>
<td>空格键</td>
<td>用于在选择该选项，取消选择该选项之间来回切换</td>
</tr>
<tr>
<td>选择该（行所在的）选项</td>
<td>则对应的该选项前面就变成了 [ * ]，表示被选中了。把驱动编译编译成模块，用 M 来表示。把驱动编译到内核里面，用*来表示。</td>
</tr>
<tr>
<td>取消该选项</td>
<td>则对应的该选项变成了只有一个中括号，里面是空的，即：[ ]</td>
</tr>
<tr>
<td>左右键</td>
<td>用于在 Select&#x2F;Exit&#x2F;Help 之前切换</td>
</tr>
<tr>
<td>回车键</td>
<td>左右键切换到了某个键上，此时回车键，就执行相应的动作</td>
</tr>
<tr>
<td>Select</td>
<td>此时一般都是所在（的行的）选项，后面有三个短横线加上一个右箭头，即 —&gt;，表示此项下面还有子选项，即进入子菜单</td>
</tr>
<tr>
<td>Exit</td>
<td>直接退出当前的配置。所以，当你更改了一些配置，但是又没有去保存，此时一般都会询问你是否要保存当前（已修改后的最新的）配置，然后再退出。</td>
</tr>
<tr>
<td>Help</td>
<td>针对你当前所在某个（行的）选项，查看其帮助信息。一般来说，其帮助信息，都包含针对该选项的很详细的解释。换句话说：如果你对某个选项的功能，不是很清楚，那么就应该认真仔细的去看看其 Help，往往都会找到详细解释，以便你更加了解此配置的含义。另外一般也会写出，此选项所对应的宏。该宏，就是写出到配置文件中的那个宏，对于写 makefile 的人来说，往往也是利用此相关的宏，在 makefile 中，实现对应的不同的控制。</td>
</tr>
<tr>
<td>快捷键快速跳转到对应的选项</td>
<td>menuconfig 中的每一行的选项，都有一个用特殊颜色标记出来的字母，很明显，此字母，就是该行的快捷字母。注意：此类快捷字母，一般都是大写的，且是大小写区分的</td>
</tr>
<tr>
<td>&#x2F; 键</td>
<td>输入“&#x2F;”即可弹出搜索界面，然后输入我们想要搜索的内容即可。</td>
</tr>
</tbody></table>
<p>表 7-3</p>
<h2 id="7-2-Kconfig-语法简介"><a href="#7-2-Kconfig-语法简介" class="headerlink" title="7.2 Kconfig 语法简介"></a>7.2 Kconfig 语法简介</h2><p>上一小节我们打开的图形化配置界面是如何生成的呢？图形化配置界面中的每一个界面都会对应一个Kconfig文件。所以图形化配置界面的每一级菜单是由Kconfig文件来决定的。</p>
<p>图形化配置界面有很多菜单。所以就会有很多Kconfig文件，这也就是为什么我们会在内核源码的每个子目录下，都会看到Kconfig文件的原因，那掌握Kconfig文件相关的知识是不是就非常重要呢。</p>
<p>所以这一小节我们来看下如何编写Kconfig文件来生成图形化配置界面，也就是Kconfig文件的语法是什么。</p>
<p>\1. Mainmenu</p>
<p>mainmenu顾名思义就是主菜单，也就是我们输入完“make menuconfig”以后默认打开的界面，mainmenu用来设置主菜单的标题，如下所示：</p>
<p>mainmenu “Linux&#x2F;$(ARCH) $(KERNELVERSION) Kernel Configuration”</p>
<p>此行代码是设置菜单的名字为“Linux&#x2F;$(ARCH) $(KERNELVERSION) Kernel Configuration”。如下图（图7-4）所示，ARCH变量是通过“export ARCH&#x3D;arm64”设置的，内核版本KERNELVERSION为4.19.232。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps35.jpg" alt="img"> </p>
<p>图 7-4</p>
<p>2.source</p>
<p>source用于读取另一个Kconfig文件，比如“source “init&#x2F;Kconfig””就是读取init目录下的Kconfig文件。</p>
<p>3.menu&#x2F;endmenu</p>
<p>menu&#x2F;endmenu条目用于生成菜单，如下（图7-5）所示，生成了Watchdog Timer Support的菜单。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">menu <span class="string">&quot;Watchdog Timer Support&quot;</span></span><br><span class="line"> </span><br><span class="line">config HW_WATCHDOG</span><br><span class="line">	bool</span><br><span class="line"> </span><br><span class="line">config WDT</span><br><span class="line">	bool <span class="string">&quot;Enable driver model for watchdog timer drivers&quot;</span></span><br><span class="line">	depends on DM</span><br><span class="line">	help</span><br><span class="line">	  Enable driver model for watchdog timer. At the moment the API.</span><br><span class="line">......</span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure>

<p>图 7-5</p>
<p>menu之后的字符串是菜单名，“menu”是菜单开始的标志，“endmenu”是菜单结束的标志，这俩个是成对出现的。“menu”和“endmenu”之间有很多config条目。在kernel目录下输入make menuconfig，如下图（图7-6）所示，可以看到上述代码描述的”Watchdog Timer Support”菜单。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps36.jpg" alt="img"> </p>
<p>图 7-6</p>
<p>进入“ Watchdog Timer Support  —&gt; ”可以看到很多config定义的条目，如下（图7-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps37.jpg" alt="img"> </p>
<p>图 7-7</p>
<p>4.if&#x2F;endif</p>
<p>if&#x2F;endif 语句是一个条件判断，定义了一个 if 结构，Kconfig中代码如下（图7-8）所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">menu &quot;Hardware Drivers Config&quot;</span><br><span class="line">    menuconfig BSP_USING_CAN</span><br><span class="line">        bool &quot;Enable CAN&quot;</span><br><span class="line">        default n</span><br><span class="line">        select RT_USING_CAN</span><br><span class="line">        if BSP_USING_CAN</span><br><span class="line">            config BSP_USING_CAN1</span><br><span class="line">                bool &quot;Enable CAN1&quot;</span><br><span class="line">                default n</span><br><span class="line">        endif</span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure>

<p>图 7-8</p>
<p>当没有选中 “Enable CAN” 选项时，下面通过 if 判断的 Enable CAN1 选项并不会显示出来。当上一级菜单选中 “Enable CAN” 时，Enable CAN1 选项才会显示。</p>
<p>\5. choice&#x2F;endchooice</p>
<p>choice条目将多个类似的配置选项组合到一起，供用户选择，用户选择是从“choice”开始，从“endchoice”结束，“choice”和“endchoice”之间有很多的config条目，这些config条目是提供用户选择的，如下（图7-9）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">choice</span><br><span class="line">        bool <span class="string">&quot;Parade TrueTouch Gen5 MultiTouch Protocol&quot;</span></span><br><span class="line">        depends on TOUCHSCREEN_CYPRESS_CYTTSP5</span><br><span class="line">        default TOUCHSCREEN_CYPRESS_CYTTSP5_MT_B</span><br><span class="line">        help</span><br><span class="line">          This option controls which MultiTouch protocol will be used to</span><br><span class="line">          report the touch events.</span><br><span class="line">config TOUCHSCREEN_CYPRESS_CYTTSP5_MT_A</span><br><span class="line">        bool <span class="string">&quot;Protocol A&quot;</span></span><br><span class="line">        help</span><br><span class="line">          Select to enable MultiTouch touch reporting using protocol A</span><br><span class="line">          on Parade TrueTouch(tm) Standard Product Generation4 touchscreen</span><br><span class="line">          controller.</span><br><span class="line"> </span><br><span class="line">config TOUCHSCREEN_CYPRESS_CYTTSP5_MT_B</span><br><span class="line">        bool <span class="string">&quot;Protocol B&quot;</span></span><br><span class="line">        help</span><br><span class="line">          Select to enable MultiTouch touch reporting using protocol B</span><br><span class="line">          on Parade TrueTouch(tm) Standard Product Generation4 touchscreen</span><br><span class="line">          controller.</span><br><span class="line"> </span><br><span class="line">endchoice</span><br></pre></td></tr></table></figure>

<p>图 7-9</p>
<p>我们在内核目录下输入make menuconfig可以看到，如下（图7-10）所示，“Parade TrueTouch Gen5 MultiTouch Protocol”是choice选项名称，“Protocol B”是Kconfig里面默认选择的。“–&gt;”代表此菜单能进入，需要键盘操作进入。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps38.jpg" alt="img"> </p>
<p>图7-10</p>
<p>进入“Parade TrueTouch Gen5 MultiTouch Protocol”后，可以看到多选项提供给用户进行选择，如下（图7-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps39.jpg" alt="img"> </p>
<p>图7-11</p>
<p>6.comment</p>
<p>comment 语句出现在界面的第一行，用于定义一些提示信息。</p>
<p>comment “Compiler: $(CC_VERSION_TEXT)”</p>
<p>以上代码的配置界面如下（图7-12）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps40.jpg" alt="img"> </p>
<p>图7-12</p>
<p>7.config</p>
<p>使用关键字config来定义一个新的选项，如下（图7-13）所示</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config helloworld</span><br><span class="line">bool “hello world support”</span><br><span class="line">default y</span><br><span class="line">help</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>图7-13</p>
<p>如上所示，使用config关键字定义了一个“helloworld”选项，每个选项都必须指定类型，类型包括bool，tristate,string,hex,int。最常见的是bool,tristate,string这三个。</p>
<p>bool类型取值只有“y”和“n”</p>
<p>tristate类型的变量取值有3种：“y”,“n”,“m”</p>
<p>string类型取值为字符串</p>
<p>hex类型取值为十六进制的数据</p>
<p>int类型取值为十进制的数据</p>
<p>help表示帮助信息，当我们在图形化界面按下h按键，弹出来的就是help的内容。</p>
<p>8.depends on</p>
<p>Kconfig中depends on关键字用来指定依赖关系，当依赖的选项被选中时，当前的配置选项的信息才会在菜单中显示出来，才能操作该选项的内容。举例来说，如下所示，选项A依赖选项B，只有当选项B被选中时，选项A才可以被选中。</p>
<p>config A</p>
<p>depends on B</p>
<p>9.select</p>
<p>Kconfig中select关键字用来表示反向依赖关系，当指定当前选项被选中时，此时select后面的选项也会被自动选中。举个例子来说，如下所示，在选项A被选中的情况下，选项B自动被选中。</p>
<p>config A</p>
<p>select on B</p>
<p>\10. menuconfig</p>
<p>menuconfig可以认为是config 中的升级版。menuconfig也是一个正常的配置项，通过自己的配置值来决定另外一组配置项是否作为子菜单的形式显示出来并供用户配置。代码如下（图7-14）所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">menuconfig NETDEVICES</span><br><span class="line">	default y if UML</span><br><span class="line">	depends on NET</span><br><span class="line">	bool &quot;Network device support&quot;</span><br><span class="line">	---help---</span><br><span class="line">if NETDEVICES</span><br><span class="line">config MII</span><br><span class="line">	tristate</span><br><span class="line"></span><br><span class="line">config NET_CORE</span><br><span class="line">	default y</span><br><span class="line">	bool &quot;Network core driver support&quot;</span><br><span class="line">	---help---</span><br><span class="line">	  You can say N here if you do not intend to use any of the</span><br><span class="line">	  networking core drivers (i.e. VLAN, bridging, bonding, etc.)</span><br></pre></td></tr></table></figure>

<p>图7-14</p>
<p>以上代码中通过menuconfig配置了一个bool类型的配置项，在图形化配置界面中显示（图7-15）如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps41.jpg" alt="img"> </p>
<p>图7-15</p>
<p>当我们选中”Network device support”配置项时，其子菜单被显示出来，如下图（图7-16）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps42.jpg" alt="img"> </p>
<p>图7-16</p>
<h2 id="7-3-config配置文件介绍"><a href="#7-3-config配置文件介绍" class="headerlink" title="7.3 .config配置文件介绍"></a>7.3 .config配置文件介绍</h2><p>我们在图形化配置界面配置好了以后，会得到一个.config配置文件。在编译内核的时候会根据这个.config文件来编译内核。这样是不是就实现了通过图像化界面的配置来配置内核呀。用通俗的话来说，Kconfig就是饭店的菜单，.config就是客人点完的菜。然后厨师会根据客人点的菜，也就是.config来做菜，对应的操作就是编译内核。</p>
<p>那.config是如何产生的呢？对应上面的例子就是要有服务员给我们点菜呀。</p>
<p>当我们使用make menuconfig的时候，会通过mconf程序去解析Kconfig文件，然后生成对应的配置文件.config。所以这个mconf就是服务员。</p>
<p>mconf程序源码在内核源码scripts&#x2F;kconfig目录下，如下图所示，这里不对Kconfig文件的解析流程进行分析，感兴趣的同学可以自行分析下mconf的源码。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps43.jpg" alt="img"> </p>
<p>图7-18</p>
<p>有了.config配置文件以后，内核就可以根据这个配置文件来编译内核，比如控制某些驱动编译进内核，或者控制某些驱动不编译内核。那他是怎么实现的呢？</p>
<p>.config会通过syncconfig目标将.config作为输入然后输出需要文件，这里我们重点更关注auto.conf和autoconf.h。如下图（图7-19）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps44.jpg" alt="img"> </p>
<p>图7-19</p>
<p>在auto.conf文件中，存放的是配置信息。如下图（图7-20）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps45.jpg" alt="img"> </p>
<p>图7-20</p>
<p>在内核源码的顶层Makefile中会包含auto.conf文件，以此引用其中的变量来控制Makefile的动作，如哪些驱动编译，哪些驱动不编译。如：</p>
<p>auto.conf文件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include include/config/auto.conf</span><br><span class="line">CONFIG _A=y</span><br></pre></td></tr></table></figure>

<p>顶层Makefile中包含auto.conf文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifeq ($(dot-config),1)</span><br><span class="line">include include/config/auto.conf</span><br><span class="line">Endif</span><br></pre></td></tr></table></figure>



<p>内核源码下drivers&#x2F;A&#x2F;Makefile引用这个变量</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONFIG _A) +=A.o</span><br></pre></td></tr></table></figure>



<p>注：obj-y就是编译进内核，obj-m就是编译成ko文件。</p>
<p>在autoconf.h中，是C语言代码。用来配合编译时的条件选择。如下图（图7-21）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps46.jpg" alt="img"> </p>
<p>图7-21</p>
<h2 id="7-4-defconfig配置文件"><a href="#7-4-defconfig配置文件" class="headerlink" title="7.4 defconfig配置文件"></a>7.4 defconfig配置文件</h2><p>defconfig文件和.config文件都是linux内核的配置文件，defconfig文件在内核源码的arch&#x2F;$(ARCH)&#x2F;configs目录下，是Linux系统默认的配置文件。比如说瑞芯微平台Linux源码默认的配置文件为：kernel&#x2F;arch&#x2F;arm64&#x2F;configs&#x2F;rockchip_linux_defconfig。</p>
<p>.config文件位于Linux内核源码的顶层目录下，编译Linux内核时会使用.config文件里面的配置来编译内核镜像。</p>
<p>如果.config文件存在，make menuconfig界面的默认配置也就是当前.config文件的配置，如果修改了图形化配置界面的设置并保存，那么.config文件会被更新。</p>
<p>如果.config文件不存在，使用命令“make XXX_defconfig”命令会根据arch&#x2F;$(ARCH)&#x2F;configs目录下的XXX_defconfig自动生成.config。make menuconfig界面的默认配置则为defconfig文件中的默认配置，比如说瑞芯微平台Linux内核源码目录下输入“make rockchip_linux_defconfig”会自动生成.config文件。那么此时rockchip_linux_defconfig的配置项和.config的配置项是相同的。</p>
<h2 id="7-5-自定义菜单实验"><a href="#7-5-自定义菜单实验" class="headerlink" title="7.5 自定义菜单实验"></a>7.5 自定义菜单实验</h2><p>有了上面的理论基础后，我们就可以自己在图形化配置界面中来自定义一个菜单，要定义一个菜单，根据我们前面的分析，是不是就要从Kconfig文件入手呀。因为图形化配置界面是根据Kconfig文件来生成的！</p>
<p>1 在kernel目录下创建一个topeet的文件夹，如下（图7-22）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps47.jpg" alt="img"> </p>
<p>图7-22</p>
<p>2 打开kernel下的Kconfig文件，在里面加入以下代码：</p>
<p>source “topeet&#x2F;Kconfig”</p>
<p>添加完成后如下（图7-23）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps48.jpg" alt="img"> </p>
<p>图7-23</p>
<p>3 然后进入到topeet文件夹，在此文件夹下创建一个Kconfig文件，创建完成如下（图7-24）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps49.jpg" alt="img"> </p>
<p>图7-24</p>
<p>4 打开创建好的Kconfig文件，写入以下（图7-25）内容：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">menu <span class="string">&quot;test menu&quot;</span></span><br><span class="line">config TEST_CONFIG</span><br><span class="line">bool <span class="string">&quot;test&quot;</span></span><br><span class="line">default y</span><br><span class="line">help</span><br><span class="line">just test</span><br><span class="line">comment <span class="string">&quot;just test&quot;</span></span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure>

<p>图7-25</p>
<p>在上面的代码中，我们在主菜单中添加了一个名为 test menu 的子菜单，然后在这个子菜单里面我们添加了一个名为 TEST_CONFIG 的配置项，这个配置项变量类型为 bool，默认配置为 Y，帮助信息为 just test，注释为 just test。添加完成如下图（图7-26）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps50.jpg" alt="img"> </p>
<p>图7-26</p>
<p>5 添加完成以后，打开图形化配置界面，如下图（图7-27）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps51.jpg" alt="img"> </p>
<p>图7-27</p>
<p>6子菜单中的配置项，默认为 y，注释信息为 just test。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps52.jpg" alt="img"> </p>
<p>图7-28</p>
<p>7 在此界面输入？，显示帮助信息为 just test，如下（图7-29）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps53.jpg" alt="img"> </p>
<p>图7-29</p>
<p>8 保存退出后，打开内核源码目录下的.config 文件，如下图（图7-30）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps54.jpg" alt="img"> </p>
<p>图7-30</p>
<p>9 可以在这个.config 文件中找到添加的 TEST_CONFIG（注意，我们需要在 make menuconfig 中保存才可以看到，否则是看不到我们添加的这个选项的），这样在编译内核的时候就可以根据这个配置信息来执行对应的操作了，就是我们下一章节要给大家讲的把驱动编译进内核，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps55.jpg" alt="img"> </p>
<p>图7-31</p>
<h1 id="第8章-驱动模块编译进内核实验"><a href="#第8章-驱动模块编译进内核实验" class="headerlink" title="第8章 驱动模块编译进内核实验"></a>第8章 驱动模块编译进内核实验</h1><p>通过上一章的学习，我们学会了使用menuconfig图形化配置工具，以及了解了menuconfig相关的文件：Kconfig .config XXXdefconfig。本章节学习将helloworld驱动编译进内核。</p>
<p>输入“cd drivers&#x2F;char”进入到 drivers&#x2F;char 目录下，然后输入“mkdir hello”建立hello文件夹，并输入“cd hello”进入hello文件夹，如下（图8-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps56.jpg" alt="img"> </p>
<p>图8-1</p>
<p>然后将第三章编写的hello.c文件拷贝到hello文件夹内。如下（图8-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps57.jpg" alt="img"> </p>
<p>图8-2</p>
<p>输入“touch Kconfig”命令创建Kconfig文件，Kconfig文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config HELLO</span><br><span class="line">tristate &quot;hello world&quot;</span><br><span class="line">help</span><br><span class="line">hello hello</span><br></pre></td></tr></table></figure>

<p>然后“touch Makefile”命令创建Makefile文件,Makefile文件内容如下所示：</p>
<p>obj-$(CONFIG_HELLO)+&#x3D;helloworld.o</p>
<p>接下来修改上一级目录的Kconfig文件和Makefile文件，也就是driver&#x2F;char目录。Makefile添加如下图(图8-3)所示内容。</p>
<p>obj-y +&#x3D; hello&#x2F;</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps58.jpg" alt="img"> </p>
<p>图8-3</p>
<p>Kconfig添加如下图（图8-4）所示内容：</p>
<p>source “drivers&#x2F;char&#x2F;hello&#x2F;Kconfig”</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps59.jpg" alt="img"> </p>
<p>图8-4</p>
<p>最后打开menuconfig图形化配置工具，在配置界面选择helloworld驱动。把驱动编译进Linux内核，用 * 来表示，所以配置选项改为*。如果想要将驱动编译为模块，则用M来表示，配置选项改为M。这里我们选择成 * </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers ─&gt;</span><br><span class="line">    Character devices ---&gt;</span><br><span class="line">        &lt;*&gt; hello world或者&lt;M&gt; hello world</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps60.jpg" alt="img"> </p>
<p>图8-5</p>
<p>然后将光标移动到save，保存配置，如下图（图8-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps61.jpg" alt="img"> </p>
<p>图8-6</p>
<p>保存到.config文件，如下（图8-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps62.jpg" alt="img"> </p>
<p>图-7</p>
<p>退出配置界面，然后输入以下命令便可以编译源码了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make savedefconfig</span><br><span class="line">cp defconfig arch/arm64/configs/rockchip_linux_defconfig </span><br><span class="line">cd ../</span><br><span class="line">./build.sh kernel</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps63.jpg" alt="img"> </p>
<p>图8-8</p>
<p>编译成功之后，进入到drivers&#x2F;char&#x2F;hello目录下，可以看到会生成对应的.o文件。就说明已经成功将驱动编译进内核。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps64.jpg" alt="img"> </p>
<p>图8-9</p>
<p>将编译好的内核镜像烧写到开发板上后，在开发板系统启动的时候也可以成功看到加载helloworld驱动，如下图（图8-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps65.jpg" alt="img"> </p>
<p>图8-10</p>
<p>如果在图形化配置界面中选择的M，也就是编译成驱动模块，则生成helloworld.ko文件如下图（图8-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps66.jpg" alt="img"> </p>
<p>图8-11</p>
<h1 id="第9章-申请字符设备号实验"><a href="#第9章-申请字符设备号实验" class="headerlink" title="第9章 申请字符设备号实验"></a>第9章 申请字符设备号实验</h1><p>经过前面章节的学习，相信大家已经对驱动模块的基本框架、驱动模块传参等知识有了自己的认识，本章节开始就要进入字符设备的世界了。 字符设备是指在I&#x2F;O传输过程中以字符为单位进行传输的设备，可以使用与普通文件相同的文件操作命令（打开、关闭、读、写等）对字符设备进行操作，是Linux驱动中最基本的一类设备驱动，例如最常见的LED、按键、IIC、SPI，LCD等都属于字符设备的范畴。要想对字符设备进行操作，需要通过设备号来对相应的设备进行查找，在本章节将对设备号相关知识进行讲解。 </p>
<h2 id="9-1-申请驱动设备号"><a href="#9-1-申请驱动设备号" class="headerlink" title="9.1 申请驱动设备号"></a>9.1 申请驱动设备号</h2><h3 id="9-1-1-设备号申请"><a href="#9-1-1-设备号申请" class="headerlink" title="9.1.1 设备号申请"></a>9.1.1 设备号申请</h3><p>在Linux系统中每一个设备都有相应的设备号，通过该设备号查找对应的设备，从而进行之后的文件操作。设备号有主设备号与次设备号之分，主设备号用来表示一个特定的驱动，次设备号用来管理下面的设备。</p>
<p>在Linux驱动中可以使用以下两种方法进行设备号的申请：</p>
<p>1.通过register_chrdev_region(dev_t from, unsigned count, const char *name)函数进行静态申请设备号。</p>
<p>2.通过alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,const char *name)函数进行动态申请设备号。</p>
<p>两个函数在“内核源码&#x2F;include&#x2F;linux&#x2F;fs.h”文件中引用(在编写驱动程序的时候要加入该文件的引用)，如下（图9-1）所示： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *, <span class="type">unsigned</span>, <span class="type">unsigned</span>, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">register_chrdev_region</span><span class="params">(<span class="type">dev_t</span>, <span class="type">unsigned</span>, <span class="type">const</span> <span class="type">char</span> *)</span>;   </span><br></pre></td></tr></table></figure>

<p>图9-1</p>
<p>静态申请设备号：</p>
<p><strong>函数原型</strong>：</p>
<p>register_chrdev_region(dev_t from, unsigned count, const char *name)</p>
<p><strong>函数作用：</strong></p>
<p>静态申请设备号，对指定好的设备号进行申请。</p>
<p><strong>参数含义：</strong></p>
<p> from: 自定义的dev_t类型设备号</p>
<p> count: 申请设备的数量</p>
<p> name: 申请的设备名称</p>
<p><strong>函数返回值：</strong>申请成功返回0，申请失败返回负数</p>
<p>动态申请设备号：</p>
<p><strong>函数原型：</strong></p>
<p>alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,const char *name)</p>
<p><strong>函数作用</strong></p>
<p>动态申请设备号，内核会自动分配一个未使用的设备号，相较于静态申请设备号，动态申请会避免注册设备号相同引发冲突的问题。</p>
<p><strong>参数含义</strong></p>
<p>dev *: 会将申请完成的设备号保存在dev变量中</p>
<p>baseminor: 次设备号可申请的最小值</p>
<p>count: 申请设备的数量</p>
<p>name: 申请的设备名称</p>
<p>****函数返回值：****申请成功返回0，申请失败返回负数</p>
<p>对于申请设备号所用到的函数就讲解完成了，会在之后的测试小节对两个函数进行实际运用。</p>
<h3 id="9-1-2-设备号类型"><a href="#9-1-2-设备号类型" class="headerlink" title="9.1.2 设备号类型"></a>9.1.2 设备号类型</h3><p>申请的设备号类型为dev_t ，在“内核源码&#x2F;include&#x2F;linux&#x2F;types.h” 文件中定义如下（图9-2）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> u32 <span class="type">__kernel_dev_t</span>;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">__kernel_dev_t</span>      <span class="type">dev_t</span>;</span><br></pre></td></tr></table></figure>

<p>图 9-2</p>
<p>dev_t为u32类型，而u32 定义在文件 “内核源码&#x2F;include&#x2F;uapi&#x2F;asm-generic&#x2F;int-ll64.h”文件中，定义如下（图9-3）： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> __u32;</span><br></pre></td></tr></table></figure>

<p>图 9-3</p>
<p>__u32为unsigned int类型，所以dev_t是一个无符号的32位整形类型。其中高12位表示主设备号，低20位表示次设备号。在“内核源码&#x2F;include&#x2F;linux&#x2F;kdev_t.h”中提供了设备号相关的宏定义，如下（图9-4）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MINORBITS   20   <span class="comment">/*次设备号位数*/</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINORMASK   ((1U &lt;&lt; MINORBITS) - 1)  <span class="comment">/*次设备号掩码*/</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAJOR(dev)  ((unsigned int) ((dev) &gt;&gt; MINORBITS))<span class="comment">/*dev右移20位得到主设备号*/</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINOR(dev)  ((unsigned int) ((dev) &amp; MINORMASK))  <span class="comment">/*与次设备掩码与，得到次设备号*/</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MKDEV(ma,mi)    (((ma) &lt;&lt; MINORBITS) | (mi))<span class="comment">/*MKDEV宏将主设备号（ma）左移20位，然后与次设备号（mi）相与，得到设备号*/</span></span></span><br></pre></td></tr></table></figure>

<p>图 9-4</p>
<p>在稍后的实验中不论是静态申请设备号还是动态申请设备号都会用到上述宏，例如在静态申请设备号时需要将指定的主设备号和从设备号通过MKDEV(ma,mi)宏进行设备号的转换，在动态申请设备号时可以用MAJOR(dev) 和MINOR(dev)宏将动态申请的设备号转化为主设备号和从设备号。</p>
<p>至此，关于设备号相关的知识就结束了，在下一小节中将对申请设备号实验代码进行编写。</p>
<h2 id="9-2-实验程序的编写"><a href="#9-2-实验程序的编写" class="headerlink" title="9.2 实验程序的编写"></a>9.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\04。</p>
<p>本章节实验将编写Linux下申请字符设备号实例代码，如果在进行驱动模块加载时传入了major主设备号，则通过静态的方式进行设备号的申请，如果不传入任何参数进行驱动模块加载，则通过动态的方式进行设备号申请。</p>
<p>编写完成的dev_t.c代码如下（图9-5）所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>                                                                                                                                </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major;<span class="comment">//定义静态加载方式时的主设备号参数major</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> minor;<span class="comment">//定义静态加载方式时的次设备号参数minor</span></span><br><span class="line">module_param(major,<span class="type">int</span>,S_IRUGO);<span class="comment">//通过驱动模块传参的方式传递主设备号参数major</span></span><br><span class="line">module_param(minor,<span class="type">int</span>,S_IRUGO);<span class="comment">//通过驱动模块传参的方式传递次设备号参数minor</span></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型(32位大小)的变量dev_num</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">dev_t_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;<span class="comment">//定义int类型的变量ret，用来判断函数返回值</span></span><br><span class="line">    <span class="comment">/*以主设备号进行条件判断，即如果通过驱动传入了major参数则条件成立，进入以下分支*/</span></span><br><span class="line">    <span class="keyword">if</span>(major)&#123;</span><br><span class="line">        dev_num = MKDEV(major,minor);<span class="comment">//通过MKDEV函数将驱动传参的主设备号和次设备号转换成dev_t类型的设备号</span></span><br><span class="line">        printk(<span class="string">&quot;major is %d\n&quot;</span>,major);</span><br><span class="line">        printk(<span class="string">&quot;minor is %d\n&quot;</span>,minor);</span><br><span class="line">        ret = register_chrdev_region(dev_num,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>);<span class="comment">//通过静态方式进行设备号册</span></span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            printk(<span class="string">&quot;register_chrdev_region is error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        printk(<span class="string">&quot;register_chrdev_region is ok\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*如果没有通过驱动传入major参数，则条件成立，进入以下分支*/</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ret = alloc_chrdev_region(&amp;dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_num&quot;</span>);<span class="comment">//通过动态方式进行设备号注册</span></span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);</span><br><span class="line">        &#125;                                                                                                                                              </span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line">        major=MAJOR(dev_num);<span class="comment">//通过MAJOR()函数进行主设备号获取</span></span><br><span class="line">        minor=MINOR(dev_num);<span class="comment">//通过MINOR()函数进行次设备号获取</span></span><br><span class="line">        printk(<span class="string">&quot;major is %d\n&quot;</span>,major);</span><br><span class="line">        printk(<span class="string">&quot;minor is %d\n&quot;</span>,minor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">dev_t_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    unregister_chrdev_region(dev_num,<span class="number">1</span>);<span class="comment">//释放字符驱动设备号 </span></span><br><span class="line">    printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(dev_t_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(dev_t_exit);<span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);  <span class="comment">//作者信息  </span></span><br></pre></td></tr></table></figure>

<p>图 9-5</p>
<p>以上代码通过对传入参数的判断，从而进行设备号申请方式的选择，会在下一小节进行相应的驱动加载测试。</p>
<h2 id="9-3-运行测试"><a href="#9-3-运行测试" class="headerlink" title="9.3 运行测试"></a>9.3 运行测试</h2><h3 id="9-3-1-编译驱动程序"><a href="#9-3-1-编译驱动程序" class="headerlink" title="9.3.1 编译驱动程序"></a>9.3.1 编译驱动程序</h3><p>在上一小节中的dev_t.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图9-6）所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m += dev_c.o    #此处要和你的驱动源文件同名</span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    #make操作</span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    #make clean操作</span><br></pre></td></tr></table></figure>

<p>图 9-6</p>
<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放dev_t.c和Makefile文件目录下，如下图（图9-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps67.jpg" alt="img"> </p>
<p>图 9-7</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图9-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps68.jpg" alt="img"> </p>
<p>图 9-8</p>
<p>编译完生成dev_t.ko目标文件，如下图（图9-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps69.jpg" alt="img"> </p>
<p>图 9-9</p>
<p>至此我们的驱动模块就编译成功了，下面对驱动进行加载测试。</p>
<h3 id="9-3-2-运行测试"><a href="#9-3-2-运行测试" class="headerlink" title="9.3.2 运行测试"></a>9.3.2 运行测试</h3><p>开发板上电启动之后，使用以下命令加载dev_t.ko驱动，加载完成之后的打印信息如下图图（9-10）所示：</p>
<p>insmod dev_t.ko major&#x3D;200 minor&#x3D;0</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps70.jpg" alt="img"> </p>
<p>图 9-10</p>
<p>可以看到传入的主设备号和次设备号都被打印了出来，“register_chrdev_region is ok”也被成功打印了证明设备注册成功了，然后使用以下命令进行注册设备号的查看，如下图（图9-11）所示：</p>
<p> cat &#x2F;proc&#x2F;devices</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps71.jpg" alt="img"> </p>
<p>图 9-11</p>
<p>可以看到主设备号200的设备名为chrdev_name，和驱动程序中设置的相同，证明我们的设备号注册成功了，然后使用以下命令进行驱动的卸载，如下图（图9-12）所示：</p>
<p>rmmod dev_t.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps72.jpg" alt="img"> </p>
<p>图 9-12</p>
<p>下面进行动态申请设备号实验，使用以下命令进行驱动模块的加载，如下图（图9-13）所示：</p>
<p> insmod dev_t.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps73.jpg" alt="img"> </p>
<p>图 9-13</p>
<p>可以看到动态申请设备号成功了，主设备号为236，次设备号为0，然后使用以下命令进行注册设备号的查看，如下图（图9-14）所示：</p>
<p> cat &#x2F;proc&#x2F;devices</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps74.jpg" alt="img"> </p>
<p>图 9-14</p>
<p>可以看到主设备号236的设备名为chrdev_name，和驱动程序中设置的相同，证明我们的设备号注册成功了，最后可以输入以下命令对驱动进行卸载，卸载完成如下图（图9-15）所示：</p>
<p>rmmod dev_t.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps75.jpg" alt="img"> </p>
<p>图 9-15</p>
<h1 id="第10章-注册字符设备实验"><a href="#第10章-注册字符设备实验" class="headerlink" title="第10章 注册字符设备实验"></a>第10章 注册字符设备实验</h1><p>在上一小节中已经对设备号的相关知识进行了讲解，并成功申请到了设备号，那在Linux系统中，设备号是怎样与字符设备进行关联的呢？字符设备又是怎样注册的呢？带着疑问，让我们开始本章节的学习吧。</p>
<h2 id="10-1-注册字符设备"><a href="#10-1-注册字符设备" class="headerlink" title="10.1 注册字符设备"></a>10.1 注册字符设备</h2><p>注册字符设备可以分为两个步骤：</p>
<p>1.字符设备初始化</p>
<p>2.字符设备的添加</p>
<p>在本小节将对上述两个步骤所用到的函数和结构体进行讲解。</p>
<h3 id="10-1-1-字符设备初始化"><a href="#10-1-1-字符设备初始化" class="headerlink" title="10.1.1 字符设备初始化"></a>10.1.1 字符设备初始化</h3><p>字符设备初始化所用到的函数为cdev_init(…),在对该函数讲解之前，首先对cdev结构体进行介绍。</p>
<p>Linux 内核中将字符设备抽象成一个具体的数据结构 (struct cdev), 我们可以理解为字符设备对象，cdev 记录了字符设备号、内核对象、文件操作file_operations结构体（设备的打开、读写、关闭等操作接口）等信息，struct cdev 结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;cdev.h”文件中（在编写驱动程序的时候要加入该文件的引用），如下（图10-1）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>                  <span class="comment">//内嵌的内核对象.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>                 <span class="comment">//该字符设备所在的内核模块的对象指针.</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span>    <span class="comment">//该结构描述了字符设备所能实现的方法，是极为关键的一个结构体.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>                <span class="comment">//用来将已经向内核注册的所有字符设备形成链表.</span></span><br><span class="line">	<span class="type">dev_t</span> dev;                            <span class="comment">//字符设备的设备号，由主设备号和次设备号构成.</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> count;                   <span class="comment">//隶属于同一主设备号的次设备号的个数.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>图 10-1</p>
<p>关于该结构体参数的注释在上图已经添加，设备初始化所用到的函数为cdev_init(),该函数同样在“内核源码&#x2F;include&#x2F;linux&#x2F;cdev.h”文件中所引用如下（图10-2）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="type">const</span> <span class="keyword">struct</span> file_operations *)</span>;</span><br></pre></td></tr></table></figure>

<p> 图10-2</p>
<p>该函数的详细内容在“内核源码&#x2F;include&#x2F;fs&#x2F;char_dev.c”文件中定义，如下（图10-3）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cdev, <span class="number">0</span>, <span class="keyword">sizeof</span> *cdev);<span class="comment">//将整个结构体清零；</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);<span class="comment">//初始化list成员使其指向自身；</span></span><br><span class="line">    kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);<span class="comment">//初始化kobj成员；</span></span><br><span class="line">    cdev-&gt;ops = fops;<span class="comment">//初始化ops成员，建立cdev 和 file_operations之间的连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图 10-3</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>初始化传入的cdev 类型的结构体，并与自定义的file_operations * 类型的结构体进行链接。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p> cdev: 要传入的cdev类型结构体，为要初始化的字符设备。</p>
<p> fops：要传入的file_operations * 类型结构体，关于file_operations结构体的相关的知识会在下一章节进行讲解。</p>
<p>****函数返回值：****无返回值。</p>
<h3 id="10-1-2-字符设备的注册"><a href="#10-1-2-字符设备的注册" class="headerlink" title="10.1.2 字符设备的注册"></a>10.1.2 字符设备的注册</h3><p><em><strong>*字符设备的注册：*</strong></em>	</p>
<p>字符设备添加所用到的函数为cdev_add()，该函数在“内核源码&#x2F;include&#x2F;linux&#x2F;cdev.h”文件中所引用，如下（图10-4）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="type">dev_t</span>, <span class="type">unsigned</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>图 10-4</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int cdev_add(struct cdev *p, dev_t dev, unsigned count)   </p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>该函数向内核注册一个struct cdev结构体</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>(1)第一个参数为要添加的struct cdev 类型的结构体</p>
<p>(2)第二个参数为申请的字符设备号</p>
<p>(3)第三个参数为和该设备关联的设备编号的数量。</p>
<p>这两个参数直接赋值给struct cdev 的dev成员和count成员。</p>
<p>****函数返回值：****添加成功返回0，添加失败返回负数。</p>
<p><em><strong>*字符设备的注销：*</strong></em></p>
<p>字符设备删除所用到的函数为cdev_del()，该函数同样在“内核源码&#x2F;include&#x2F;linux&#x2F;cdev.h”文件中所引用，如下（图10-5）所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cdev_del(struct cdev *);</span><br></pre></td></tr></table></figure>

<p>图 10-5</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>void cdev_del(struct cdev *p)  </p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>该函数会向内核删除一个struct cdev 类型结构体</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>该函数只有一个参数，为要删除的struct cdev 类型的结构体</p>
<p>****函数返回值：****无返回值</p>
<p>至此，关于注册字符设备实验所用到的函数就讲解完成了，在下一小节中将编写注册字符设备代码。</p>
<h2 id="10-2-实验程序的编写"><a href="#10-2-实验程序的编写" class="headerlink" title="10.2 实验程序的编写"></a>10.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\05。</p>
<p>本实验采用动态申请设备号的方式进行设备号的申请，然后对设备进行注册，并将申请到的主设备号和次设备号以及设备注册情况打印到终端上。</p>
<p>编写完成的cdev.c代码如下（图10-6）所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型（32位大小）的变量dev_num,用来存放设备号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义cdev结构体类型的变量cdev_test</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_ops</span>&#123;</span></span><br><span class="line">	.owner=THIS_MODULE<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">&#125;;<span class="comment">//定义file_operations结构体类型的变量cdev_test_ops</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">module_cdev_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;<span class="comment">//定义int类型变量ret，进行函数返回值判断</span></span><br><span class="line">    <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>);<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_register_region is ok\n&quot;</span>);</span><br><span class="line">    major = MAJOR(dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">    minor = MINOR(dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">    printk(<span class="string">&quot;major is %d\n&quot;</span>,major);</span><br><span class="line">    printk(<span class="string">&quot;minor is %d\n&quot;</span>,minor);                                         </span><br><span class="line">cdev_init(&amp;cdev_test,&amp;cdev_test_ops);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到cdev_test_ops结构体</span></span><br><span class="line">cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块 </span></span><br><span class="line">    ret = cdev_add(&amp;cdev_test,dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        printk(<span class="string">&quot;cdev_add is error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;cdev_add is ok\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">module_cdev_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cdev_del(&amp;cdev_test);<span class="comment">//使用cdev_del()函数进行字符设备的删除</span></span><br><span class="line">    unregister_chrdev_region(dev_num,<span class="number">1</span>);<span class="comment">//释放字符驱动设备号 </span></span><br><span class="line">    printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(module_cdev_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(module_cdev_exit);<span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);  <span class="comment">//作者信息  </span></span><br></pre></td></tr></table></figure>

<p>图 10-6</p>
<p>相较于上一章节实验，本章节的代码去掉了静态申请设备号部分代码，并在申请设备号完成之后注册了相应的字符设备，并在驱动出口函数中添加了相应的字符设备删除代码（相关代码已加粗）。</p>
<p>需要注意的是，字符设备的注册要放在申请字符设备号之后，字符设备的删除要放在释放字符驱动设备号之前。</p>
<h2 id="10-3-运行测试"><a href="#10-3-运行测试" class="headerlink" title="10.3 运行测试"></a>10.3 运行测试</h2><h3 id="10-3-1-编译驱动程序"><a href="#10-3-1-编译驱动程序" class="headerlink" title="10.3.1 编译驱动程序"></a>10.3.1 编译驱动程序</h3><p>在上一小节中的cdev.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图10-7）所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m += cdev.o    #此处要和你的驱动源文件同名</span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    #make操作</span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    #make clean操作</span><br></pre></td></tr></table></figure>

<p>图 10-7</p>
<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放parameter.c和Makefile文件目录下，如下图（图10-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps76.jpg" alt="img"> </p>
<p>图 10-8</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图10-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps77.jpg" alt="img"> </p>
<p>图 10-9</p>
<p>编译完会生成 cdev.ko目标文件，如下图（图10-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps78.jpg" alt="img"> </p>
<p>图 10-10</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h3 id="10-3-2-运行测试"><a href="#10-3-2-运行测试" class="headerlink" title="10.3.2 运行测试"></a>10.3.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图10-11）所示：</p>
<p>insmod cdev.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps79.jpg" alt="img"> </p>
<p>图 10-11</p>
<p>可以看到动态申请设备号成功了，主设备号为236，次设备号为0，然后使用以下命令进行注册设备号的查看，如下图（图10-12）所示：</p>
<p> cat &#x2F;proc&#x2F;devices</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps80.jpg" alt="img"> </p>
<p>图 10-12</p>
<p>可以看到主设备号236的设备名为chrdev_name，和驱动程序中设置的设备名称相同，证明字符设备注册成功了，最后可以使用以下命令对驱动进行卸载，卸载完成如下图（10-13）所示：</p>
<p>rmmod cdev.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps81.jpg" alt="img"> </p>
<p>图 10-13</p>
<h1 id="第11章-创建设备节点实验"><a href="#第11章-创建设备节点实验" class="headerlink" title="第11章 创建设备节点实验"></a>第11章 创建设备节点实验</h1><p>在上两个章节的学习中，我们已经成功的申请了设备号并且注册了相应的字符设备。系统通过设备号对设备进行查找，而字符设备注册到内核之后，并不能直接进行设备文件操作命令（打开、关闭、读、写等），需要相应的设备文件作为桥梁以此来进行设备的访问，在本章节将对如何创建设备节点进行学习。 </p>
<h2 id="11-1-创建设备节点"><a href="#11-1-创建设备节点" class="headerlink" title="11.1 创建设备节点"></a>11.1 创建设备节点</h2><p>在Linux操作系统中一切皆文件，设备访问也是通过文件的方式来进行的，对于用来进行设备访问的文件称之为设备节点，设备节点被创建在&#x2F;dev目录下，将内核中注册的设备与用户层进行链接，这样应用程序才能对设备进行访问。</p>
<p>根据设备节点的创建方式不同，分为了手动创建设备节点和自动创建设备节点，下面对两种设备节点创建方式进行介绍。</p>
<h3 id="11-1-1-手动创建设备节点"><a href="#11-1-1-手动创建设备节点" class="headerlink" title="11.1.1 手动创建设备节点"></a>11.1.1 手动创建设备节点</h3><p>使用mknod命令手动创建设备节点，mknod 命令格式为：</p>
<p>mknod NAME TYPE MAJOR MINOR</p>
<p>参数含义：</p>
<p>NAME: 要创建的节点名称</p>
<p>TYPE: b表示块设备，c表示字符设备，p表示管道</p>
<p>MAJOR：要链接设备的主设备号</p>
<p>MINOR: 要链接设备的从设备号</p>
<p>例如使用以下命令创建一个名为device_test的字符设备节点，链接设备的主设备号和从设备号分别为236和0：</p>
<p>mknod &#x2F;dev&#x2F;device_test c 236 0 </p>
<h3 id="11-1-2-自动创建设备节点"><a href="#11-1-2-自动创建设备节点" class="headerlink" title="11.1.2 自动创建设备节点"></a>11.1.2 自动创建设备节点</h3><p>设备文件的自动创建是利用udev(mdev)机制来实现，多数情况下采用自动创建设备节点的方式。udev(mdev)可以检测系统中硬件设备状态，可以根据系统中硬件设备状态来创建或者删除设备文件。在驱动中首先使用class_create(…)函数对class进行创建，这个类存放于&#x2F;sys&#x2F;class&#x2F; 目录下，之后使用device_create(…)函数创建相应的设备，在进行模块加载时，用户空间中的udev会自动响应device_create()函数，寻找对应的类从而创建设备节点。</p>
<p>下面对于自动创建节点中所用到的函数进行解释说明：</p>
<p><em><strong>*class_create(…)函数*</strong></em></p>
<p>该函数在“内核源码&#x2F;include&#x2F;linux&#x2F;device.h”文件中所引用（由于上一小节中引用的cdev.h文件已包含device.h，所以不需要再重复引用），如下（图11-1）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> class_create(owner, name)       \</span></span><br><span class="line"><span class="meta">(&#123;                      \</span></span><br><span class="line"><span class="meta">   static struct lock_class_key __key; \</span></span><br><span class="line"><span class="meta">    __class_create(owner, name, &amp;__key);    \                                                                           </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>图 11-1</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>用于动态创建设备的逻辑类，并完成部分字段的初始化，然后将其添加进Linux内核系统。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>owner：struct module结构体类型的指针，指向函数即将创建的这个struct class的模块。一般赋值为THIS_MODULE。</p>
<p>name：char类型的指针，代表即将创建的struct class变量的名字。</p>
<p>返回值：struct class * 类型的结构体。 </p>
<p><em><strong>*class_destroy(…)函数*</strong></em></p>
<p>该函数在“内核源码&#x2F;include&#x2F;linux&#x2F;device.h”文件中所引用，如下（图11-2）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">class_destroy</span><span class="params">(<span class="keyword">struct</span> class *cls)</span>;  </span><br></pre></td></tr></table></figure>

<p>图 11-2</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>用于删除设备的逻辑类，即从Linux内核系统中删除设备的逻辑类。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>owner：struct module结构体类型的指针，指向函数即将创建的这个struct class的模块。一般赋值为THIS_MODULE。</p>
<p>name：char类型的指针，代表即将创建的struct class变量的名字。</p>
<p>返回值：无</p>
<p><em><strong>*device_create(…)函数*</strong></em></p>
<p>该函数在“内核源码&#x2F;include&#x2F;linux&#x2F;device.h”文件中所引用，如下（图11-3）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device *<span class="title function_">device_create</span><span class="params">(<span class="keyword">struct</span> class *cls, <span class="keyword">struct</span> device *parent,                                                  </span></span><br><span class="line"><span class="params">               <span class="type">dev_t</span> devt, <span class="type">void</span> *drvdata,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>图 11-3</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>用来在class类中下创建一个设备属性文件，udev会自动识别从而进行设备节点的创建。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>cls：指定所要创建的设备所从属的类。</p>
<p>parent:指定该设备的父设备，如果没有就指定为NULL。</p>
<p>devt:指定创建设备的设备号。</p>
<p>drvdata:被添加到该设备回调的数据，没有则指定为NULL。</p>
<p>fmt：添加到系统的设备节点名称。</p>
<p>****返回值：****struct device * 类型结构体</p>
<p><em><strong>*device_destroy(…)函数*</strong></em></p>
<p>在“内核源码&#x2F;include&#x2F;linux&#x2F;device.h”文件中所引用，如下（图11-4）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">device_destroy</span><span class="params">(<span class="keyword">struct</span> class *cls, <span class="type">dev_t</span> devt)</span>; </span><br></pre></td></tr></table></figure>

<p>图 11-4</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>用来删除class类中的设备属性文件，udev会自动识别从而进行设备节点的删除。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>cls：指定所要创建的设备所从属的类。</p>
<p>devt:指定创建设备的设备号。</p>
<p>返回值：无</p>
<p>至此，关于自动创建节点相关的函数就介绍完成了，会在下一小节中对于设备节点的自动创建进行相应实验程序的编写。</p>
<h2 id="11-2-实验程序的编写"><a href="#11-2-实验程序的编写" class="headerlink" title="11.2 实验程序的编写"></a>11.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\06。</p>
<p>本章实验将编写Linux下的自动创建设备节点实验代码，首先采用自动申请设备号的方式进行设备号的申请，并对获取的主设备号与次设备号进行打印，之后对字符设备进行注册(file_operations结构体只填充owner 字段即可，会在下个章节对file_operations结构体进行讲解)，最后自动对设备节点进行创建。</p>
<p>编写完成的chrdev_node.c代码如下（图11-5）所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_fops_test</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">&#125;;<span class="comment">//定义file_operations结构体类型的变量cdev_test_ops</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chrdev_fops_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;<span class="comment">//定义int类型的变量ret，用来对函数返回值进行判断</span></span><br><span class="line">    <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>);<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">    <span class="keyword">if</span> (ret  &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">    major = MAJOR(dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">    minor = MINOR(dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">    printk(<span class="string">&quot;major is %d\n minor is %d \n&quot;</span>,major,minor);</span><br><span class="line">    cdev_init(&amp;cdev_test,&amp;cdev_fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到cdev_test_ops结构&gt;体</span></span><br><span class="line">    cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    ret = cdev_add(&amp;cdev_test,dev_num,<span class="number">1</span>); <span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">         printk(<span class="string">&quot;cdev_add is error \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;cdev_add is ok \n&quot;</span>);</span><br><span class="line">    class_test  = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">    device_create(class_test,<span class="literal">NULL</span>,dev_num,<span class="literal">NULL</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chrdev_fops_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cdev_del(&amp;cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">    unregister_chrdev_region(dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">    device_destroy(class_test,dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">    class_destroy(class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">    printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(chrdev_fops_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(chrdev_fops_exit);<span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);<span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>图 11-5</p>
<p>相较于上一章节实验，本章节代码在入口函数中添加了自动创建设备节点相关代码，在驱动出口函数中添加了相应的删除设备节点相关代码(相关代码已加粗)。</p>
<p>需要注意的是，在进行设备节点添加时，类的创建要放在设备创建之前；在进行设备节点删除时，类的删除要放在设备删除之后。</p>
<h2 id="11-3-运行测试"><a href="#11-3-运行测试" class="headerlink" title="11.3 运行测试"></a>11.3 运行测试</h2><h3 id="11-3-1-编译驱动程序"><a href="#11-3-1-编译驱动程序" class="headerlink" title="11.3.1 编译驱动程序"></a>11.3.1 编译驱动程序</h3><p>在上一小节中的chrdev_node.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图11-6）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += chrdev_node.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>图 11-6</p>
<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放chrdev_node.c和Makefile文件目录下，如下图（图11-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps82.jpg" alt="img"> </p>
<p>图 11-7</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图11-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps83.jpg" alt="img"> </p>
<p>图 11-8</p>
<p>编译完生成 chrdev_node.ko目标文件，如下图（图11-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps84.jpg" alt="img"> </p>
<p>图 11-9</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h3 id="11-3-2-运行测试"><a href="#11-3-2-运行测试" class="headerlink" title="11.3.2 运行测试"></a>11.3.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图11-10）所示：</p>
<p>insmod cdev.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps85.jpg" alt="img"> </p>
<p>图 11-10</p>
<p>可以看到动态申请设备号成功了，主设备号为236，次设备号为0，然后使用以下命令进行注册设备号的查看，如下图（图11-11）所示：</p>
<p> cat &#x2F;proc&#x2F;devices</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps86.jpg" alt="img"> </p>
<p>图 11-11</p>
<p>可以看到主设备号236的设备名为chrdev_name，和驱动程序中设置的相同，证明我们的设备号注册成功了，然后使用以下命令对class目录进行查看，如下图（图11-12）所示：</p>
<p>ls &#x2F;sys&#x2F;class&#x2F;</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps87.jpg" alt="img"> </p>
<p>图 11-12</p>
<p>可以看到在驱动程序中创建的class_test 类已经被成功创建了，然后使用以下命令对class_test 目录进行查看，如下图（图11-12）所示：</p>
<p>ls &#x2F;sys&#x2F;class&#x2F;class_test&#x2F;</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps88.jpg" alt="img"> </p>
<p>图 11-12</p>
<p>可以看到在驱动程序中创建的名为device_test的设备属性文件夹也被创建了，然后使用命令“ls &#x2F;dev&#x2F;device_test”对&#x2F;dev目录进行查看，相应的设备节点也已经被自动创建了，如下图（图11-13）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps89.jpg" alt="img"> </p>
<p>图 11-13</p>
<p>最后可以使用以下命令进行驱动的卸载，卸载完成如下图（图11-14）所示：</p>
<p>rmmod chrdev_node.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps90.jpg" alt="img"> </p>
<p>图 11-14</p>
<h1 id="第12章-字符设备驱动框架实验"><a href="#第12章-字符设备驱动框架实验" class="headerlink" title="第12章 字符设备驱动框架实验"></a>第12章 字符设备驱动框架实验</h1><p>下面对前面三个章节进行总结，首先驱动向Linux内核进行设备号申请，之后的字符设备注册时，会对申请的设备号进行使用。而Linux 内核会将字符设备抽象成一个具体的struct cdev结构体，该结构体记录了字符设备的字符设备号、内核对象等信息，cdev_init(…)函数对结构体进行初始化之后，cdev_add(…)函数将设备号和cdev结构体进行链接，这时设备号才真正指向了内核中注册的设备。设备注册成功之后，此时还不能对字符设备进行文件操作，所以需要设备节节点来充当内核和用户层通信的桥梁，至此，前面三个章节就总结完成了，以上步骤并没有涉及到操作设备文件，本章节将对字符设备框架进行最终的完善。 </p>
<h2 id="12-1-文件操作集简介"><a href="#12-1-文件操作集简介" class="headerlink" title="12.1 文件操作集简介"></a>12.1 文件操作集简介</h2><p> 在进行注册字符设备实验章节中，使用cdev_init(…)函数对struct cdev结构体类型变量和struct file_operations结构体类型变量相链接，struct file_operations结构体就是把系统调用和驱动程序关联起来的关键数据结构。该结构体的每一个成员都对应着一个系统调用，读取file_operation中相应的函数指针，接着把控制权转交给函数，从而完成了Linux设备驱动程序的工作。</p>
<p>file_operations结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;fs.h”文件中，下面对部分常用函数进行说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br></pre></td></tr></table></figure>

<p>owner是第一个 file_operations 成员，它并不是一个操作, 而一个指向拥有该结构的模块的指针，避免正在操作时被卸载，一般为初始化为THIS_MODULES (在 &lt;linux&#x2F;module.h&gt; 中定义的宏)</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br></pre></td></tr></table></figure>

<p>read函数指针用来从设备中同步读取数据，读取成功返回读取的字节数。与应用程序中的 read函数对应。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br></pre></td></tr></table></figure>

<p>write函数指针用来发送数据给设备. 写入成功返回写入的字节数。与应用程序中的write函数对应。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br></pre></td></tr></table></figure>

<p>unlocked_ioctl函数指针提供对于设备的控制功能，与应用程序中的ioctl函数对应。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br></pre></td></tr></table></figure>

<p>open函数指针用于打开设备,与应用程序中的open函数对应。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br></pre></td></tr></table></figure>

<p>release函数指针在file结构体释放时被调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br></pre></td></tr></table></figure>

<p>至此对于file_operations文件操作集的部分常用函数就介绍完了，填充了部分常用函数的 file_operations结构体如下（图12-1）所示：</p>
<p>图 12-1</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_fops_test</span> =</span> &#123;</span><br><span class="line">   .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">   .open = chrdev_open,<span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">   .read = chrdev_read,<span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">   .write = chrdev_write,<span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">   .release = chrdev_release,<span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;<span class="comment">//定义file_operations结构体类型的变量cdev_test_ops</span></span><br></pre></td></tr></table></figure>



<p>会在下个小节进行字符设备驱动框架实验代码的编写，在上一章节实验的基础上加入file_operations结构体，并通过应用程序对字符设备驱动进行文件操作测试。</p>
<h2 id="12-2-实验程序的编写"><a href="#12-2-实验程序的编写" class="headerlink" title="12.2 实验程序的编写"></a>12.2 实验程序的编写</h2><h3 id="12-2-1-驱动程序编写"><a href="#12-2-1-驱动程序编写" class="headerlink" title="12.2.1 驱动程序编写"></a>12.2.1 驱动程序编写</h3><p>本实验驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\07\module。</p>
<p>本章实验将编写字符设备驱动框架实验，会在上一章节实验基础上对file_operation结构体相关内容进行补充。</p>
<p>首先采用自动申请设备号的方式进行设备号的申请，然后对获取的主设备号与次设备号进行打印，之后对字符设备进行注册，并填充相应的file_openration结构体和相关函数，最后自动对设备节点进行创建，编写完成的chrdev_fops.c代码如下（图12-2）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>                                                                                                    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chrdev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is chrdev_open \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">chrdev_read</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is chrdev_read \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">chrdev_write</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *buf,<span class="type">size_t</span> size,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is chrdev_write \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chrdev_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_fops_test</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = chrdev_open,<span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = chrdev_read,<span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = chrdev_write,<span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = chrdev_release,<span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;<span class="comment">//定义file_operations结构体类型的变量cdev_test_ops</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chrdev_fops_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;<span class="comment">//定义int类型的变量ret，用来对函数返回值进行判断</span></span><br><span class="line">    <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>);<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">    <span class="keyword">if</span> (ret  &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">    major = MAJOR(dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">    minor = MINOR(dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">    printk(<span class="string">&quot;major is %d\n minor is %d \n&quot;</span>,major,minor);</span><br><span class="line">    cdev_init(&amp;cdev_test,&amp;cdev_fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到cdev_test_ops结构体</span></span><br><span class="line">    cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    ret = cdev_add(&amp;cdev_test,dev_num,<span class="number">1</span>); <span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">         printk(<span class="string">&quot;cdev_add is error \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;cdev_add is ok \n&quot;</span>);                                                                                </span><br><span class="line">    class_test  = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">    device_create(class_test,<span class="literal">NULL</span>,dev_num,<span class="literal">NULL</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chrdev_fops_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    device_destroy(class_test,dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">class_destroy(class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">    cdev_del(&amp;cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">    unregister_chrdev_region(dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">    printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(chrdev_fops_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(chrdev_fops_exit);<span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);<span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>图 12-2</p>
<h3 id="12-2-2-编写测试-APP"><a href="#12-2-2-编写测试-APP" class="headerlink" title="12.2.2 编写测试 APP"></a>12.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\07\app。</p>
<p>由于在驱动程序中，只是对一系列文件操作函数添加了标志打印（之后的章节会加入数据的读写），所以本小节的应用程序只是起简单的测试作用。编写完成的应用程序app.c内容如下（图12-3）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>];<span class="comment">//定义读取缓冲区buf</span></span><br><span class="line">    fd=open(argv[<span class="number">1</span>],O_RDWR,<span class="number">0666</span>);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;open is ok\n&quot;</span>);</span><br><span class="line">	<span class="comment">/*如果第二个参数为read，条件成立，调用read函数，对文件进行读取*/</span>                                                                                                                                  </span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;read&quot;</span>))&#123;</span><br><span class="line">        read(fd,buf,<span class="number">32</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为write，条件成立，调用write函数，对文件进行写入*/</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;write&quot;</span>))&#123;</span><br><span class="line">        write(fd,<span class="string">&quot;hello\n&quot;</span>,<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">close(fd);<span class="comment">//调用close函数，对取消文件描述符到文件的映射</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>图 12-3</p>
<p>上述应用程序逻辑较为简单，第一个参数为要进行读写操作的设备节点，第二个参数为read时，对设备节点进行读操作，第二个参数为write时，对设备节点进行写操作。</p>
<h2 id="12-3-运行测试"><a href="#12-3-运行测试" class="headerlink" title="12.3 运行测试"></a>12.3 运行测试</h2><h3 id="12-3-1-编译驱动程序"><a href="#12-3-1-编译驱动程序" class="headerlink" title="12.3.1 编译驱动程序"></a>12.3.1 编译驱动程序</h3><p>在上一小节中的chrdev_fops.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图12-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += chrdev_fops.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>图 12-4</p>
<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放chrdev_fops.c和Makefile文件目录下，如下图（图12-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps91.jpg" alt="img"> </p>
<p>图 12-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图12-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps92.jpg" alt="img"> </p>
<p>图 12-6</p>
<p>编译完生成chrdev_fops.ko目标文件，如下图（图12-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps93.jpg" alt="img"> </p>
<p>图 12-7</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h3 id="12-3-2-编译应用程序"><a href="#12-3-2-编译应用程序" class="headerlink" title="12.3.2 编译应用程序"></a>12.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图12-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps94.jpg" alt="img"> </p>
<p>图 12-8</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图12-9）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps95.jpg" alt="img"> </p>
<p>图 12-9</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="12-3-3-运行测试"><a href="#12-3-3-运行测试" class="headerlink" title="12.3.3 运行测试"></a>12.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图12-10）所示：</p>
<p>insmod chrdev_fops.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps96.jpg" alt="img"> </p>
<p>图 12-10</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图12-11）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps97.jpg" alt="img"> </p>
<p>图 12-11</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令对open()函数进行测试，如下图（图12-11）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps98.jpg" alt="img"> </p>
<p>图 12-12</p>
<p>可以看到“This is chrdev_open”和“open is ok”信息被打印了，证明应用程序运行成功，且调用了驱动程序中的open(…)函数，而“Segmentation fault”相关打印是因为没有对第二个参数进行传入，这里忽略即可，随后使用以下命令对设备进行读测试，如下图（图12-13）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test read</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps99.jpg" alt="img"> </p>
<p>图 12-13</p>
<p>可以看到“This is chrdev_read”信息被打印了出来，证明驱动程序中的read(…)函数被调用了,然后使用以下命令对设备进行写测试，如下图（图12-14）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test write</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps100.jpg" alt="img"> </p>
<p>图 12-14</p>
<p>可以看到“This is chrdev_write”信息被打印了出来，证明驱动程序中的write(…)函数被调用了。最后可以使用以下命令进行驱动的卸载，如下图（图12-15）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps101.jpg" alt="img"> </p>
<p>图 12-15</p>
<p>至此，字符设备驱动框架实验就完成了。</p>
<h1 id="第13章-杂项设备驱动实验"><a href="#第13章-杂项设备驱动实验" class="headerlink" title="第13章 杂项设备驱动实验"></a>第13章 杂项设备驱动实验</h1><p>经过前面章节的学习，我们已经对字符设备驱动框架有了一定的理解，而本章要讲解的杂项设备属于特殊的一种字符型设备，是对字符设备的一种封装，为最简单的字符设备。为什么从字符设备中单独提取出了杂项设备呢？杂项设备又要如何进行使用呢？带着疑问，让我们进行杂项设备的学习吧！</p>
<h2 id="13-1-杂项设备驱动简介"><a href="#13-1-杂项设备驱动简介" class="headerlink" title="13.1 杂项设备驱动简介"></a>13.1 杂项设备驱动简介</h2><p>在Linux中，把无法归类的五花八门的设备定义成杂项设备。相较于字符设备，杂项设备有以下两个优点:</p>
<p>(1)节省主设备号:杂项设备的主设备号固定为10，而字符设备不管是动态分配还是静态分配设备号，都会消耗一个主设备号，进而造成了主设备号浪费。当系统中注册了多个misc设备驱动时，只需使用子设备号进行区分即可。</p>
<p>(2)使用简单：当使用普通的字符设备驱动时，如果开发人员需要导出操作接口给用户空间，就需要注册对应的字符驱动，并创建字符设备class从而自动在&#x2F;dev下生成设备节点，而misc驱动只需要将基本信息通过结构体传递给相应处理函数即可。</p>
<p>在驱动中使用miscdevice结构体描述misc设备，该结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;miscdevice.h”文件中（在下面的实验代码中需要加入该头文件的引用），具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span>  &#123;</span></span><br><span class="line">	<span class="type">int</span> minor; <span class="comment">/* 子设备号 需要用户填写*/</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;<span class="comment">/* 设备名 需要用户填写*/</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span><span class="comment">/* 设备操作集 需要用户填写*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">this_device</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *nodename;</span><br><span class="line">	<span class="type">umode_t</span> mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义一个misc 设备，一般只需要填充minor、name、fops 这三个成员变量。</p>
<p>minor指次设备号，可以从“内核源码&#x2F;include&#x2F;linux&#x2F;miscdevice.h”文件中预定义的次设备号挑选，也可以自行定义子设备号（没有被其他设备使用即可），通常情况下将该参数设置为MISC_DYNAMIC_MINOR，表示自动分配子设备号。</p>
<p>name表示misc设备的名字。misc设备驱动注册成功之后，会在dev目录下生成名为name的设备节点。</p>
<p>fops 指向了file_operations的结构体，表示字符设备的操作集合。</p>
<h2 id="13-2-杂项设备的注册和卸载"><a href="#13-2-杂项设备的注册和卸载" class="headerlink" title="13.2 杂项设备的注册和卸载"></a>13.2 杂项设备的注册和卸载</h2><p>不同于字符设备的注册和卸载的繁琐，杂项设备的注册可以直接使用函数misc_register函数来完成，杂项设备的卸载可以直接使用misc_deregister函数来完成。上述两个函数均定义在“内核源码&#x2F;include&#x2F;linux&#x2F;miscdevice.h”文件当中。</p>
<p>杂项设备的注册：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int misc_register(struct miscdevice *misc)</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>基于misc_class构造一个设备，将miscdevice结构挂载到misc_list列表上，并初始化与linux设备模型相关的结构。进而起到杂项设备注册的作用。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p> misc: 杂项设备的结构体指针</p>
<p>****函数返回值：****申请成功返回0，申请失败返回负数</p>
<p>杂项设备的卸载：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int misc_deregister(struct miscdevice *misc)</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>从mist_list中删除miscdevice，进而起到杂项设备卸载的作用。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p> misc: 杂项设备的结构体指针</p>
<p>****函数返回值：****卸载成功返回0，申请失败返回负数</p>
<p>至此，注册和卸载杂项设备的API函数就讲解完成了，会在接下来的驱动章节中对上述函数进行具体使用。</p>
<h2 id="13-3-杂项设备驱动框架"><a href="#13-3-杂项设备驱动框架" class="headerlink" title="13.3 杂项设备驱动框架"></a>13.3 杂项设备驱动框架</h2><p>MISC驱动一般使用以下结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">xxx_fops</span>&#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">	.read = xxx_read,</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">xxx_dev</span>&#123;</span></span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">    .name = <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">    .fops = &amp;xxx_fops</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;xxx_init\r\n&quot;</span>);</span><br><span class="line">    ret = misc_register(&amp;xxx_dev);<span class="comment">//注册杂项设备</span></span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         printk( <span class="string">&quot;misc_register failed\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> 	printk( <span class="string">&quot;misc_register ok\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_exit</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;xxx_exit\r\n&quot;</span>);</span><br><span class="line">    misc_deregister(&amp;xxx_dev);  <span class="comment">//卸载杂项设备</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(xxx_init);    <span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(xxx_exit);   </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);   </span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="13-4-实验程序的编写"><a href="#13-4-实验程序的编写" class="headerlink" title="13.4 实验程序的编写"></a>13.4 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\08。</p>
<p>本小节将编写最简单的misc驱动，在驱动入口函数中通过misc_register(…)函数注册杂项设备驱动，在驱动出口函数中通过misc_deregister(…)函数注销杂项设备驱动。编写完成的miscdevice.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>              <span class="comment">//初始化头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>            <span class="comment">//最基本的文件，支持动态添加和卸载模块。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span>        <span class="comment">//注册杂项设备头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span>                <span class="comment">//注册设备节点的文件结构体</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">misc_fops</span> =</span> &#123; <span class="comment">//文件操作集</span></span><br><span class="line">    .owner = THIS_MODULE <span class="comment">////将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">misc_dev</span> =</span> &#123;       <span class="comment">//杂项设备结构体</span></span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR,     <span class="comment">//动态申请的次设备号</span></span><br><span class="line">    .name = <span class="string">&quot;test&quot;</span>,                  <span class="comment">//杂项设备名字是hello_misc</span></span><br><span class="line">    .fops = &amp;misc_fops,              <span class="comment">//文件操作集</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">misc_init</span><span class="params">(<span class="type">void</span>)</span>           </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = misc_register(&amp;misc_dev); <span class="comment">//在初始化函数中注册杂项设备</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;misc registe is error \n&quot;</span>); <span class="comment">//打印注册杂项设备失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;misc registe is succeed \n&quot;</span>);<span class="comment">//打印注册杂项设备成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">misc_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">    misc_deregister(&amp;misc_dev);     <span class="comment">//在卸载函数中注销杂项设备</span></span><br><span class="line">    printk(<span class="string">&quot; misc goodbye! \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(misc_init);</span><br><span class="line">module_exit(misc_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="13-5-运行测试"><a href="#13-5-运行测试" class="headerlink" title="13.5 运行测试"></a>13.5 运行测试</h2><h3 id="13-5-1-编译驱动程序"><a href="#13-5-1-编译驱动程序" class="headerlink" title="13.5.1 编译驱动程序"></a>13.5.1 编译驱动程序</h3><p>在上一小节中的miscdevice.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += miscdevice.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>Makefile保存退出之后，来到存放miscdevice.c和Makefile文件目录下，如下图（图13-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps102.jpg" alt="img"> </p>
<p>图 13-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 13-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps103.jpg" alt="img"> </p>
<p>图 13-2</p>
<p>编译完生成 miscdevice.ko目标文件，如下图（图 13-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps104.jpg" alt="img"> </p>
<p>图 13-2</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h3 id="13-5-2-运行测试"><a href="#13-5-2-运行测试" class="headerlink" title="13.5.2 运行测试"></a>13.5.2 运行测试</h3><p>将编译生成的驱动模块miscdevice.ko拷贝到开发板上，输入以下命令加载驱动模块。</p>
<p>insmod miscdevice.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps105.jpg" alt="img"> </p>
<p>图 13-3</p>
<p>可以看到驱动加载之后，打印“misc registe is succeed”,说明misc驱动注册成功。输入以下命令查看加载的驱动模块，驱动加载成功如下（图13-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps106.jpg" alt="img"> </p>
<p>图 13-4</p>
<p>然后来到&#x2F;sys&#x2F;class&#x2F;misc目录下，可以看到名为“test”的文件夹已经被创建了，在&#x2F;sys&#x2F;class&#x2F;misc目录下有misc类的所有设备，每个注册的杂项设备对应一个文件夹目录，如下图（图13-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps107.jpg" alt="img"> </p>
<p>图 13-5</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps108.jpg" alt="img"> </p>
<p>图 13-7</p>
<p>驱动加载成功之后会生成&#x2F;dev&#x2F;test设备驱动文件，输入以下命令查看杂项设备的主次设备号。</p>
<p>ls &#x2F;dev&#x2F;test -al</p>
<p>结果如下图（图 13-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps109.jpg" alt="img"> </p>
<p>图 13-8</p>
<p>从上图可以看出，&#x2F;dev&#x2F;test这个杂项设备的主设备号为10，次设备号为53，最后可以使用以下命令对驱动进行卸载，卸载完成如下图（图 13-9）所示：</p>
<p>rmmod miscdevice.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps110.jpg" alt="img"> </p>
<p>图 13-9</p>
<h1 id="第14章-内核空间与用户空间数据交互实验"><a href="#第14章-内核空间与用户空间数据交互实验" class="headerlink" title="第14章 内核空间与用户空间数据交互实验"></a>第14章 内核空间与用户空间数据交互实验</h1><p>在“第12章 字符设备驱动框架实验”中，已经对file_operations结构体的进行了填充，该结构体的每一个成员都对应着一个系统调用，例如read、write等，在对应的实验中，只是对调用函数进行了标志打印，并没有真正实现设备的读写功能，而在本章节将对内核空间与用户空间的数据交换功能进行实现。</p>
<h2 id="14-1-内核空间与用户空间"><a href="#14-1-内核空间与用户空间" class="headerlink" title="14.1 内核空间与用户空间"></a>14.1 内核空间与用户空间</h2><p>Linux系统将可访问的内存空间分为了两个部分，一部分是内核空间，一部分是用户空间。操作系统和驱动程序运行在内核空间（内核态），应用程序运行在用户空间（用户态）。</p>
<p>那么为什么要区分用户空间和内核空间呢？</p>
<p>（1）内核空间中的代码控制了硬件资源，用户空间中的代码只能通过内核暴露的系统调用接口来使用系统中的硬件资源，这样的设计可以保证操作系统自身的安全性和稳定性。</p>
<p>（2）从另一方面来说，内核空间的代码更偏向于系统管理，而用户空间中的代码更偏重业务逻辑实现，俩者的分工不同。</p>
<p>硬件资源管理都是在内核空间完成的，应用程序无法直接对硬件进行操作，只能通过调用相应的内核接口来完成相应的操作。比如应用程序要对磁盘上的一个文件进行读取，应用程序可以向内核发起一个“系统调用”申请——我要读取磁盘上的文件。这个过程其实是通过一个特殊的指令让进程从用户态进入到了内核态。在内核空间中，CPU可以执行任何命令，包括从磁盘上读取数据，具体过程是先把数据读取到内核空间中，然后再把数据拷贝到用户空间并从内核态切换到用户态。此时应用程序已经从系统调用中返回并拿到了想要的数据，可以继续往下执行了。</p>
<p>进程只有从用户空间切换到内核空间才可以使用系统的硬件资源，切换的方式有三种：系统调用，软中断，硬中断，如下图（图 14-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps111.jpg" alt="img"> </p>
<p>图 14-1</p>
<h2 id="14-2-用户空间和内核空间数据交换"><a href="#14-2-用户空间和内核空间数据交换" class="headerlink" title="14.2 用户空间和内核空间数据交换"></a>14.2 用户空间和内核空间数据交换</h2><p>内核空间和用户空间的内存是不能互相访问的。但是很多应用程序都需要和内核进行数据的交换，例如应用程序使用read函数从驱动中读取数据，使用write函数向驱动中写数据，上述功能就需要使用copy_from_user和copy_to_user俩个函数来完成。copy_from_user函数是将用户空间的数据拷贝到内核空间。copy_to_user函数是将内核空间的数据拷贝到用户空间。</p>
<p>这俩个函数定义在了kernel&#x2F;include&#x2F;linux&#x2F;uaccess.h文件下，如下所示：</p>
<p>copy_to_user</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>unsigned long copy_to_user_inatomic(void __user *to, const void *from, unsigned long n);</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>把内核空间的数据复制到用户空间。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>*to是用户空间的指针</p>
<p>*from是内核空间的指针</p>
<p>n是从内核空间向用户空间拷贝的字节数</p>
<p>copy_from_user</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>unsigned long copy_from_user(void *to, const void __user *from, unsigned long n)</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>把用户空间的数据复制到内核空间。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>*to是内核空间的指针</p>
<p>*from是用户空间的指针</p>
<p>n是从用户空间向内核空间拷贝的字节数</p>
<h2 id="14-3-实验程序编写"><a href="#14-3-实验程序编写" class="headerlink" title="14.3 实验程序编写"></a>14.3 实验程序编写</h2><h3 id="14-3-1-驱动程序编写"><a href="#14-3-1-驱动程序编写" class="headerlink" title="14.3.1 驱动程序编写"></a>14.3.1 驱动程序编写</h3><p>本驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\09\module。</p>
<p>在该实验中将实现内核空间和用户空间进行数据交换的功能。以12章编写的字符设备驱动框架实验为基础编写驱动程序，程序使用copy_to_user函数和copy_from_user函数来实现内核空间和用户空间互传数据的功能，编写完成的file.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;  <span class="comment">//主设备号</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> minor = <span class="number">0</span>;  <span class="comment">//次设备号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>       <span class="comment">//类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>    <span class="comment">//设备</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*本章实验重点******/</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//定义写入缓存区kbuf</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);<span class="comment">//打印copy_from_user函数执行失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_write\r\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;kbuf is %s\r\n&quot;</span>, kbuf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*本章实验重点******/</span></span><br><span class="line"><span class="type">char</span> kbuf[<span class="number">32</span>] = <span class="string">&quot;This is cdev_test_read!&quot;</span>;<span class="comment">//定义内核空间数据</span></span><br><span class="line"><span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, kbuf, <span class="built_in">strlen</span>(kbuf)) != <span class="number">0</span>)     &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>); <span class="comment">//打印copy_to_user函数执行失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数，定义file_operations结构体类型的变量cdev_test_fops*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read,  <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"><span class="comment">/*1 创建设备号*/</span></span><br><span class="line"><span class="comment">//动态分配设备号</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>);     <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);<span class="comment">//打印动态分配设备号失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    major = MAJOR(dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    minor = MINOR(dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">    cdev_add(&amp;cdev_test, dev_num, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">    device = device_create(class, <span class="literal">NULL</span>, dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;cdev_test);               <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(class, dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);   <span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(chr_fops_exit);  <span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码在cdev_test_read函数中使用copy_to_user函数将内核数据拷贝到用户空间，在cdev_test_write函数中使用copy_from_user函数将用户空间数据拷贝到内核空间。</p>
<h3 id="14-3-2-编写测试-APP"><a href="#14-3-2-编写测试-APP" class="headerlink" title="14.3.2 编写测试 APP"></a>14.3.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\09\app。</p>
<p>编写测试APP其实是在编写Linux应用，编译完成的应用程序app.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  <span class="comment">//主函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;   <span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//定义读取缓存区buf1</span></span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>; <span class="comment">//定义写入缓存区buf2</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开字符设备驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    read(fd, buf1, <span class="keyword">sizeof</span>(buf1));<span class="comment">//从/dev/test文件读取数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf1 is %s \r\n&quot;</span>, buf1); <span class="comment">//打印读取的数据</span></span><br><span class="line"></span><br><span class="line">    write(fd,buf2,<span class="keyword">sizeof</span>(buf2));<span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="14-4-运行测试"><a href="#14-4-运行测试" class="headerlink" title="14.4 运行测试"></a>14.4 运行测试</h2><h3 id="14-4-1-编译驱动程序"><a href="#14-4-1-编译驱动程序" class="headerlink" title="14.4.1 编译驱动程序"></a>14.4.1 编译驱动程序</h3><p>在上一小节中的file.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下   所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m +=file.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放file.c和Makefile文件目录下，如下图（图14-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps112.jpg" alt="img"> </p>
<p>图 14-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图14-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps113.jpg" alt="img"> </p>
<p>图14-3</p>
<p>编译完生成 file.ko目标文件，如下图（图 14-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps114.jpg" alt="img"> </p>
<p>图 14-4</p>
<p>至此我们的驱动模块就编译成功了，下面进行应用程序编译.</p>
<h3 id="14-4-2-编译应用程序"><a href="#14-4-2-编译应用程序" class="headerlink" title="14.4.2 编译应用程序"></a>14.4.2 编译应用程序</h3><p>因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图 14-5）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps115.jpg" alt="img"> </p>
<p>图 14-5</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="14-4-3-运行测试"><a href="#14-4-3-运行测试" class="headerlink" title="14.4.3 运行测试"></a>14.4.3 运行测试</h3><p>驱动模块file.ko和测试程序app都已经准备好了，接下来就是运行测试。首先输入以下命令加载驱动程序，如下图（图14–6）所示：</p>
<p>insmod file.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps116.jpg" alt="img"> </p>
<p>图 14-6</p>
<p>输入以下命令运行应用程序，如下图（图 14-7）所示</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps117.jpg" alt="img"> </p>
<p>图 14-7</p>
<p>由上图可知，打印“This is cdev_test_open”信息说明成功打开了字符设备驱动。</p>
<p>打印“ This is cdev_test_read”和“buf1 is This is cdev_test_read!”说明应用程序成功读取到内核的数据。</p>
<p>打印“This is cdev_test_write”和“kbuf is nihao”说明应用程序向内核写数据成功。</p>
<p>最后打印“This is cdev_test_release”说明卸载字符设备。</p>
<h1 id="第15章-文件私有数据实验"><a href="#第15章-文件私有数据实验" class="headerlink" title="第15章 文件私有数据实验"></a>第15章 文件私有数据实验</h1><p>在之前章节编写的驱动程序中，将生成字符设备的一些硬件属性（设备号、类、设备名称等）全都写成了变量的形式，虽然这样编写驱动代码不会产生报错，但是会显得有点不专业。通常在驱动开发中会为设备定义相关的设备结构体，将硬件属性的描述信息全部放在该结构体中，在本章节中将对设备结构体的功能实现和文件私有数据进行学习。</p>
<h2 id="15-1-文件私有数据简介"><a href="#15-1-文件私有数据简介" class="headerlink" title="15.1 文件私有数据简介"></a>15.1 文件私有数据简介</h2><p>Linux中并没有明确规定要使用文件私有数据，但是在linux驱动源码中，广泛使用了文件私有数据，这是Linux驱动遵循的“潜规则”，实际上也体现了Linux面向对象的思想。struct file 结构体中专门为用户留了一个域用于定义私有数据。结构体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">fu_llist</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">fu_rcuhead</span>;</span></span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span>	<span class="comment">/* cached value */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protects f_ep_links, f_flags.</span></span><br><span class="line"><span class="comment">	 * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rw_hint</span>		<span class="title">f_write_hint</span>;</span></span><br><span class="line">	<span class="type">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> 		f_flags;</span><br><span class="line">	<span class="type">fmode_t</span>			f_mode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">	<span class="type">loff_t</span>			f_pos;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="type">void</span>			*private_data;<span class="comment">//私有数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_ep_links</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_tfile_llink</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span></span><br><span class="line">	<span class="type">errseq_t</span>		f_wb_err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件私有数据的概念在Linux驱动中有着非常广泛的应用，文件私有数据就是将私有数据private_data指向设备结构体。通过它可以将私有数据一路从open函数带到read, write函数层层传入。一般是在open 的时候赋值，read、write时使用。open函数中私有数据的使用如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">	file-&gt;private_data=&amp;dev1;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，定义了一个设备结构体dev1，然后在open函数中，将私有数据private_data指向了设备结构体dev1。</p>
<p>我们可以在read write函数中通过private_data访问设备结构体，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> _user *buf, <span class="type">size_t</span> size,<span class="type">loff_t</span> *<span class="type">off_t</span>)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-2-实验程序编写"><a href="#15-2-实验程序编写" class="headerlink" title="15.2 实验程序编写"></a>15.2 实验程序编写</h2><h3 id="15-2-1-驱动程序编写"><a href="#15-2-1-驱动程序编写" class="headerlink" title="15.2.1 驱动程序编写"></a>15.2.1 驱动程序编写</h3><p>本驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\10\module。</p>
<p>本章实验将编写Linux下的使用文件私有数据实例代码，在open函数中对私有数据结构体赋值，在write函数中使用。编写完成的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">dev_t</span> dev_num;              <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;                  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;                   <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span>          <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>             <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>          <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];                <span class="comment">//缓存区buf</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  <span class="comment">//定义一个device_test结构体变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;  <span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data; <span class="comment">//在write函数中读取private_data</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_write\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;kbuf is %s\r\n&quot;</span>, test_dev-&gt;kbuf); <span class="comment">//打印kbuf的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;    </span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,         <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open,         <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read,          <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write,         <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release,<span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">  dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">    cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建设备*/</span></span><br><span class="line">    dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="15-2-2-编写测试-APP"><a href="#15-2-2-编写测试-APP" class="headerlink" title="15.2.2 编写测试 APP"></a>15.2.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\10\app。</p>
<p>编写测试APP其实是在编写Linux应用，在应用程序中向设备文件写入数据，编写完成的应用程序app.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> <span class="comment">//主函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>;  <span class="comment">//定义写入缓存区buf1</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR); <span class="comment">//打开/dev/test设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd,buf1,<span class="keyword">sizeof</span>(buf1)); <span class="comment">//向/dev/test设备写入数据</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-3-运行测试"><a href="#15-3-运行测试" class="headerlink" title="15.3 运行测试"></a>15.3 运行测试</h2><h3 id="15-3-1-编译驱动程序"><a href="#15-3-1-编译驱动程序" class="headerlink" title="15.3.1 编译驱动程序"></a>15.3.1 编译驱动程序</h3><p>在上一小节中的file.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图5-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += file.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放file.c和Makefile文件目录下，如下图（图15-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps118.jpg" alt="img"> </p>
<p>图15-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图15-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps119.jpg" alt="img"> </p>
<p>图 15-2</p>
<p>编译完生成 file.ko目标文件，如下图（图15-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps120.jpg" alt="img"> </p>
<p>图 15-3</p>
<p>至此我们的驱动模块就编译成功了，下面进行应用程序编译，</p>
<h3 id="15-3-2-编译应用程序"><a href="#15-3-2-编译应用程序" class="headerlink" title="15.3.2 编译应用程序"></a>15.3.2 编译应用程序</h3><p>因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图15-4）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps121.jpg" alt="img"> </p>
<p>图15-4</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="15-3-3-运行测试"><a href="#15-3-3-运行测试" class="headerlink" title="15.3.3 运行测试"></a>15.3.3 运行测试</h3><p>驱动模块file.ko和测试程序app都已经准备好了，接下来就是运行测试。</p>
<p>输入以下命令加载驱动程序</p>
<p>insmod file.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps122.jpg" alt="img"> </p>
<p>图 15-5</p>
<p>驱动加载成功之后会生成&#x2F;dev&#x2F;test设备驱动文件，输入以下命令查看杂项设备的主次设备号。</p>
<p>ls &#x2F;dev&#x2F;test -al</p>
<p>结果如下图（图15-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps123.jpg" alt="img"> </p>
<p>图 15-6</p>
<p>运行应用程序，如下（图 15-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps124.jpg" alt="img"> </p>
<p>图 15-7</p>
<p>在此实验中，将硬件属性的信息全部放在一个结构体private_data，依然可以实现字符设备的操作。</p>
<h1 id="第16章-一个驱动兼容不同设备实验"><a href="#第16章-一个驱动兼容不同设备实验" class="headerlink" title="第16章 一个驱动兼容不同设备实验"></a>第16章 一个驱动兼容不同设备实验</h1><p>在Linux中，使用主设备号来表示对应某一类驱动，使用次设备号来表示这类驱动下的各个设备。假如现在驱动要支持的主设备号相同，但是次设备号不同的设备。驱动程序要怎样编写呢，上一章节学习的私有数据private_date在此时就派上了用场，具体是怎样使用的呢，多个设备是如何在一个驱动中兼容的呢，带着疑问，让我们开始本章节的学习吧。</p>
<h2 id="16-1-container-of函数简介"><a href="#16-1-container-of函数简介" class="headerlink" title="16.1 container_of函数简介"></a>16.1 container_of函数简介</h2><p>container_of在Linux内核中是一个常用的宏，用于从包含在某个结构中的指针获得结构本身的指针，通俗地讲就是通过结构体变量中某个成员的首地址进而获得整个结构体变量的首地址。那么可以使用这个函数获取不同设备的地址，来对不同的设备进行操作，从而一个驱动可以兼容不同的设备。</p>
<p>container_of</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>container_of(ptr,type,member)</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>通过结构体变量中某个成员的首地址获取到整个结构体变量的首地址。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>ptr是结构体变量中某个成员的地址。</p>
<p>type是结构体的类型 </p>
<p>member是该结构体变量的具体名字</p>
<p>container_of宏的作用是通过结构体内某个成员变量的地址和该变量名，以及结构体类型。找到该结构体变量的地址。</p>
<h2 id="16-2-实验程序编写"><a href="#16-2-实验程序编写" class="headerlink" title="16.2 实验程序编写"></a>16.2 实验程序编写</h2><h3 id="16-2-1-驱动程序编写"><a href="#16-2-1-驱动程序编写" class="headerlink" title="16.2.1 驱动程序编写"></a>16.2.1 驱动程序编写</h3><p>本驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\11\module。</p>
<p>本章实验将使用container_of函数编写一个驱动兼容不同设备的实例代码，编写完成的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> dev_num;             <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major;                  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor;                  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span>        <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>           <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>        <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];              <span class="comment">//定义缓冲区kbuf</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span>   <span class="comment">//定义一个device_test结构体变量dev1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev2</span>;</span>  <span class="comment">//定义一个device_test结构体变量dev2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    dev1.minor = <span class="number">0</span>;    <span class="comment">//设置dev1的次设备号为0</span></span><br><span class="line">    dev2.minor = <span class="number">1</span>;   <span class="comment">//设置dev2的次设备号为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//inode-&gt;i_rdev 为该 inode 的设备号，使用container_of函数找到结构体变量dev1 dev2的地址</span></span><br><span class="line"><span class="comment">//然后设置私有数据</span></span><br><span class="line">    file-&gt;private_data = container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> device_test, cdev_test);</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span> =</span> (<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="comment">//如果次设备号是0，则为dev1</span></span><br><span class="line">    <span class="keyword">if</span> (test_dev-&gt;minor == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(<span class="string">&quot; test_dev-&gt;kbuf is %s\r\n&quot;</span>, test_dev-&gt;kbuf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果次设备号是1，则为dev2</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(test_dev-&gt;minor == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(<span class="string">&quot; test_dev-&gt;kbuf is %s\r\n&quot;</span>, test_dev-&gt;kbuf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span> =</span> (<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>(test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数,定义file_operations结构体类型的变量cdev_test_fops*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号,,这里注册2个设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对设备1进行操作</span></span><br><span class="line">    <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">    cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">    dev1.class = class_create(THIS_MODULE, <span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5 创建设备*/</span></span><br><span class="line">    dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev2.major = MAJOR(dev1.dev_num + <span class="number">1</span>); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev2.minor = MINOR(dev1.dev_num + <span class="number">1</span>); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev2.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev2.minor); <span class="comment">//打印次设备号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对设备2进行操作</span></span><br><span class="line">  <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev2.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev2.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">    cdev_add(&amp;dev2.cdev_test, dev1.dev_num + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">    dev2.class = class_create(THIS_MODULE, <span class="string">&quot;test2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">    dev2.device = device_create(dev2.class, <span class="literal">NULL</span>, dev1.dev_num + <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&quot;test2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>);    <span class="comment">//注销设备号</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num + <span class="number">1</span>, <span class="number">1</span>);  <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                  <span class="comment">//删除cdev</span></span><br><span class="line">    cdev_del(&amp;dev2.cdev_test);                  <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);     <span class="comment">//删除设备</span></span><br><span class="line">    device_destroy(dev2.class, dev1.dev_num + <span class="number">1</span>);  <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">    class_destroy(dev2.class);                 <span class="comment">//删除类</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="16-2-2-编写测试-APP"><a href="#16-2-2-编写测试-APP" class="headerlink" title="16.2.2 编写测试 APP"></a>16.2.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\11\app。</p>
<p>编写应用程序，打开生成的俩个设备，并向俩个设备中写入数据，编写完成的应用程序app.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd1;  <span class="comment">//定义设备1的文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd2;  <span class="comment">//定义设备2的文件描述符</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = <span class="string">&quot;nihao /dev/test1&quot;</span>;   <span class="comment">//定义写入缓存区buf1</span></span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = <span class="string">&quot;nihao /dev/test2&quot;</span>;   <span class="comment">//定义写入缓存区buf2</span></span><br><span class="line">    fd1 = open(<span class="string">&quot;/dev/test1&quot;</span>, O_RDWR);  <span class="comment">//打开设备1：test1</span></span><br><span class="line">    <span class="keyword">if</span> (fd1 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd1;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd1,buf1,<span class="keyword">sizeof</span>(buf1));  <span class="comment">//向设备1写入数据</span></span><br><span class="line">    close(fd1); <span class="comment">//取消文件描述符到文件的映射</span></span><br><span class="line"></span><br><span class="line">    fd2= open(<span class="string">&quot;/dev/test2&quot;</span>, O_RDWR); <span class="comment">//打开设备2：test2</span></span><br><span class="line">    <span class="keyword">if</span> (fd2 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd2;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd2,buf2,<span class="keyword">sizeof</span>(buf2));  <span class="comment">//向设备2写入数据</span></span><br><span class="line">    close(fd2);   <span class="comment">//取消文件描述符到文件的映射</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="16-3-运行测试"><a href="#16-3-运行测试" class="headerlink" title="16.3 运行测试"></a>16.3 运行测试</h2><h3 id="16-3-1-编译驱动程序"><a href="#16-3-1-编译驱动程序" class="headerlink" title="16.3.1 编译驱动程序"></a>16.3.1 编译驱动程序</h3><p>在上一小节中的file.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图5-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += file.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放file.c和Makefile文件目录下，如下图（图16-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps125.jpg" alt="img"> </p>
<p>图 16-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图16-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps126.jpg" alt="img"> </p>
<p>图 16-2</p>
<p>编译完生成 file.ko目标文件，如下图（图16-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps127.jpg" alt="img"> </p>
<p>图 16-3</p>
<p>至此我们的驱动模块就编译成功了，下面进行应用程序编译</p>
<h3 id="16-3-2-编译应用程序"><a href="#16-3-2-编译应用程序" class="headerlink" title="16.3.2 编译应用程序"></a>16.3.2 编译应用程序</h3><p>因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图 16-4）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps128.jpg" alt="img"> </p>
<p>图 16-5</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="16-3-2-运行测试"><a href="#16-3-2-运行测试" class="headerlink" title="16.3.2 运行测试"></a>16.3.2 运行测试</h3><p>驱动模块file.ko和测试程序app都已经准备好了，接下来就是运行测试。</p>
<p>输入以下命令加载驱动模块，如下图（图 16-6）所示：</p>
<p>insmod file.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps129.jpg" alt="img"> </p>
<p>图 16-7</p>
<p>驱动加载成功之后会生成&#x2F;dev&#x2F;test1和&#x2F;dev&#x2F;test2设备驱动文件，输入以下命令查看设备，可以看到一个驱动创建并管理了多个驱动设备，如下图（图 16-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps130.jpg" alt="img"> </p>
<p>图 16-9</p>
<p>运行应用程序，如下（图 16-10）所示:</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps131.jpg" alt="img"> </p>
<p>图 16-11</p>
<p>如上图所示，可以看到用户顺利向俩个设备写入数据，且每个设备拥有私有数据。</p>
<h1 id="第17章-Linux错误处理实验"><a href="#第17章-Linux错误处理实验" class="headerlink" title="第17章 Linux错误处理实验"></a>第17章 Linux错误处理实验</h1><p>在前面章节进行的字符设备驱动实验中，即使是最简单的注册字符设备，也存在注册失败的可能性，因此在之前编写的驱动代码中采用检查函数返回值的方式，确认函数是否成功执行，而在本章节中将采用goto语句对Linux错误处理进行更进一步的处理。</p>
<h2 id="17-1-goto语句简介"><a href="#17-1-goto语句简介" class="headerlink" title="17.1 goto语句简介"></a>17.1 goto语句简介</h2><p>在编写驱动程序时，驱动程序应该提供函数执行失败后处理的能力。如果驱动程序中函数执行失败了，必须取消掉所有失败前的注册，否则内核会处于一个不稳定的状态，因为它包含了不存在代码的内部指针。在处理Linux错误时，最好使用goto语句，goto语句的使用示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>   init <span class="title function_">my_init_function</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line">err = register_this(ptr1, <span class="string">&quot;skull&quot;</span>); </span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">	<span class="keyword">goto</span> fail_this;</span><br><span class="line"></span><br><span class="line">err = register_that(ptr2, <span class="string">&quot;skull&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">	<span class="keyword">goto</span> fail_that;</span><br><span class="line"></span><br><span class="line">err = register_those(ptr3, <span class="string">&quot;skull&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">	<span class="keyword">goto</span> fail_those;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line"> </span><br><span class="line">fail_those:</span><br><span class="line">	unregister_that(ptr2, <span class="string">&quot;skull&quot;</span>); </span><br><span class="line">fail_that:</span><br><span class="line">	unregister_this(ptr1, <span class="string">&quot;skull&quot;</span>);</span><br><span class="line">fail_this:</span><br><span class="line">	<span class="keyword">return</span> err;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中试图注册3个虚构设备，goto语句在失败情况下使用，对之前已经成功注册的设施进行注销。使用goto语句处理的时候，应该遵循“先进后出”的原则，如下图（图 17-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps132.jpg" alt="img"> </p>
<p>图 17-2</p>
<p>如果在驱动代码中初始化和卸载函数比较复杂，goto方法可能变得难于管理，为了使代码重复性最小以及流程化，Linux提供了更简便的方法，我们接着来学习下一小节。</p>
<h2 id="17-2-IS-ERR-简介"><a href="#17-2-IS-ERR-简介" class="headerlink" title="17.2 IS_ERR()简介"></a>17.2 IS_ERR()简介</h2><p>对于任何一个指针来说，必然存在三种情况，一种是合法指针，一种是NULL(也就是空指针)，一种是错误指针(也就是无效指针)。在Linux内核中，所谓的错误指针已经指向了内核空间的最后一页，例如，对于一个64位系统来说，内核空间最后地址为0xffffffffffffffff，那么最后一页的地址是0xfffffffffffff000~0xffffffffffffffff，这段地址是被保留的，如果指针落在这段地址之内，说明是错误的无效指针。</p>
<p>在Linux内核源码中实现了指针错误的处理机制，相关的函数接口主要有IS_ERR()、PTR_ERR()、ERR_PTR()等，其函数的源码在include&#x2F;linux&#x2F;err.h文件中，如下所示：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\ksohtml55808\wps133.jpg" alt="img"> </p>
<p>如上图所示，在Linux源码中IS_ERR()函数其实就是判断指针是否出错，如果指针指向了内核空间的最后一页，就说明指针是一个无效指针，如果指针并不是落在内核空间的最后一页，就说明这指针是有效的。无效的指针能表示成一种负数的错误码，如果想知道这个指针是哪个错误码，使用PTR_ERR函数转化。0xfffffffffffff000~0xffffffffffffffff这段地址和Linux错误码是一一对应的，内核错误码保存在errno-base.h文件中。如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_GENERIC_ERRNO_BASE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_GENERIC_ERRNO_BASE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EPERM		 1	<span class="comment">/* Operation not permitted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOENT		 2	<span class="comment">/* No such file or directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ESRCH		 3	<span class="comment">/* No such process */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EINTR		 4	<span class="comment">/* Interrupted system call */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EIO		 5	<span class="comment">/* I/O error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENXIO		 6	<span class="comment">/* No such device or address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	E2BIG		 7	<span class="comment">/* Argument list too long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOEXEC		 8	<span class="comment">/* Exec format error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EBADF		 9	<span class="comment">/* Bad file number */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ECHILD		10	<span class="comment">/* No child processes */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EAGAIN		11	<span class="comment">/* Try again */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOMEM		12	<span class="comment">/* Out of memory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EACCES		13	<span class="comment">/* Permission denied */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EFAULT		14	<span class="comment">/* Bad address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOTBLK		15	<span class="comment">/* Block device required */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EBUSY		16	<span class="comment">/* Device or resource busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EEXIST		17	<span class="comment">/* File exists */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EXDEV		18	<span class="comment">/* Cross-device link */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENODEV		19	<span class="comment">/* No such device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOTDIR		20	<span class="comment">/* Not a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EISDIR		21	<span class="comment">/* Is a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EINVAL		22	<span class="comment">/* Invalid argument */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENFILE		23	<span class="comment">/* File table overflow */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EMFILE		24	<span class="comment">/* Too many open files */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOTTY		25	<span class="comment">/* Not a typewriter */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ETXTBSY		26	<span class="comment">/* Text file busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EFBIG		27	<span class="comment">/* File too large */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOSPC		28	<span class="comment">/* No space left on device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ESPIPE		29	<span class="comment">/* Illegal seek */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EROFS		30	<span class="comment">/* Read-only file system */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EMLINK		31	<span class="comment">/* Too many links */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EPIPE		32	<span class="comment">/* Broken pipe */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EDOM		33	<span class="comment">/* Math argument out of domain of func */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ERANGE		34	<span class="comment">/* Math result not representable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>那么如何判断函数返回的指针是有效地址还是错误码呢？对于IS_ERR()的使用，实例代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">myclass = class_create(THIS_MODULE, <span class="string">&quot;myclass&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(myclass)) &#123;</span><br><span class="line">　　ret = PTR_ERR(myclass);</span><br><span class="line">   <span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">mydevice = device_create(myclass, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;simple-device&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(mydevice)) &#123;</span><br><span class="line">　　class_destroy(myclass);</span><br><span class="line">　　ret = PTR_ERR(mydevice);</span><br><span class="line">　　<span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，调用了class_create()和device_create()函数，必须使用IS_ERR()函数判断返回的指针是否是有效的，如果是无效的，需要调用PTR_ERR()函数将无效指针转换为错误码，并进行错误码的返回。</p>
<h2 id="17-3-实验程序编写"><a href="#17-3-实验程序编写" class="headerlink" title="17.3 实验程序编写"></a>17.3 实验程序编写</h2><h3 id="17-3-1-驱动程序编写"><a href="#17-3-1-驱动程序编写" class="headerlink" title="17.3.1 驱动程序编写"></a>17.3.1 驱动程序编写</h3><p>本驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\12\module。</p>
<p>本实验在15章的驱动程序基础上进行编写，进行Linux错误处理实验。当创建设备号，初始化cdev，注册字符设备，创建类，创建设备的这些函数执行失败时，应该怎么处理呢，编写好的驱动程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];  <span class="comment">//定义缓存区kbuf</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>   <span class="comment">//定义一个device_test结构体变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">    file-&gt;private_data=&amp;dev1;  <span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_write\r\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;kbuf is %s\r\n&quot;</span>, test_dev-&gt;kbuf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;   </span><br><span class="line"><span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">       ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="17-3-2-编写测试-APP"><a href="#17-3-2-编写测试-APP" class="headerlink" title="17.3.2 编写测试 APP"></a>17.3.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\12\app。</p>
<p>编写应用程序app.c，完成的应用程序app.c代码如下所示，应用程序只是起简单的测试作用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> <span class="comment">//主函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>;  <span class="comment">//定义写入缓存区buf1</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR); <span class="comment">//打开/dev/test设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd,buf1,<span class="keyword">sizeof</span>(buf1)); <span class="comment">//向/dev/test设备写入数据</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="17-4-运行测试"><a href="#17-4-运行测试" class="headerlink" title="17.4 运行测试"></a>17.4 运行测试</h2><h3 id="17-4-1-编译驱动程序"><a href="#17-4-1-编译驱动程序" class="headerlink" title="17.4.1 编译驱动程序"></a>17.4.1 编译驱动程序</h3><p>在上一小节中的file.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图5-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += chrdev_fops.o                     <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel   <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules     <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放file.c和Makefile文件目录下，如下图（图17-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps134.jpg" alt="img"> </p>
<p>图 17-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图17-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps135.jpg" alt="img"> </p>
<p>图 17-3</p>
<p>编译完生成 file.ko目标文件，如下图（图17-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps136.jpg" alt="img"> </p>
<p>图 17-4</p>
<p>至此我们的驱动模块就编译成功了。</p>
<h3 id="17-4-2-编译应用程序"><a href="#17-4-2-编译应用程序" class="headerlink" title="17.4.2 编译应用程序"></a>17.4.2 编译应用程序</h3><p>下面进行应用程序编译，因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图17-5）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps137.jpg" alt="img"> </p>
<p>图 17-5</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="17-4-3运行测试"><a href="#17-4-3运行测试" class="headerlink" title="17.4.3运行测试"></a>17.4.3运行测试</h3><p>驱动模块file.ko和测试程序app都已经准备好了，接下来就是运行测试。</p>
<p>输入以下命令，加载驱动程序，如下图（图17-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps138.jpg" alt="img"> </p>
<p>图 17-6</p>
<p>运行应用程序如下（图17-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps139.jpg" alt="img"> </p>
<p>图 17-7</p>
<p>卸载驱动程序，如下图（图17-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps140.jpg" alt="img"> </p>
<p>图 17-8</p>
<h1 id="第18章-点亮LED灯实验"><a href="#第18章-点亮LED灯实验" class="headerlink" title="第18章 点亮LED灯实验"></a>第18章 点亮LED灯实验</h1><p>经过前面章节的学习，我们已经对字符设备相关的知识进行了学习和实验，但实际上并没有涉及到对硬件的操作，而在本小节中将通过字符设备驱动及相关的应用程序对LED灯进行控制，通过对硬件的实际操作，从而对之前学习到的知识进行整合与回顾。</p>
<h2 id="18-1-查看原理图"><a href="#18-1-查看原理图" class="headerlink" title="18.1 查看原理图"></a>18.1 查看原理图</h2><p>首先打开底板原理图，如下图（图18-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps141.jpg" alt="img"> </p>
<p>图 18-1</p>
<p>由上图可以看出，LED灯是由GPIO0_B7控制的。当GPIO0_B7为高电平时，三极管Q16导通，LED9点亮。当GPIO0_B7为低电平时，三极管Q16截止，LED9不亮。</p>
<h2 id="18-2-查询寄存器地址"><a href="#18-2-查询寄存器地址" class="headerlink" title="18.2 查询寄存器地址"></a>18.2 查询寄存器地址</h2><p>在上一小节，我们查询到了控制LED灯的GPIO为GPIO0_B7。在接下来的实验中需要对GPIO进行配置，一般情况下需要对GPIO的复用寄存器，方向寄存器，数据寄存器进行配置。接下来我们打开RK3568的参考手册part1查找这几个寄存器的地址。</p>
<p>查找复用寄存器</p>
<p>打开参考手册part1的第三章，GPIOB的复用寄存器的偏移地址如下（图18-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps142.jpg" alt="img"> </p>
<p>图 18-2</p>
<p>搜索gpio0b7，如下图（图 18-3）所示，gpio0b7_sel在PMU_GRF_GPIO0B_IOMUX_H上，所以偏移地址为0x000C。gpio0b7可以通过控制[14:12]位来选择复用为哪个功能，我们要控制led灯，所以功能要复用为gpio。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps143.jpg" alt="img"> </p>
<p>图 18-3</p>
<p>复用寄存器的基地址如下图(图 18-4)所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps144.jpg" alt="img"> </p>
<p>图 18-4</p>
<p>所以复用寄存器地址&#x3D;基地址+偏移地址&#x3D;0xFDC2000C 。使用io命令查看此寄存器的地址：</p>
<p>io -r -4 0xFDC2000C</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps145.jpg" alt="img"> </p>
<p>图 18-5</p>
<p>如上图(图 18-5)所示，寄存器值为00000001，[14:12]位为000，如下图（图 18-6）所示，所以默认设置的为gpio功能。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps146.jpg" alt="img"> </p>
<p>图 18-6</p>
<p>查找方向寄存器</p>
<p>打开参考手册part1的第16章节，数据寄存器的偏移地址如下图（图 18-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps147.jpg" alt="img"> </p>
<p>图 18-7</p>
<p>GPIO有四组GPIO，分别是GPIOA，GPIOB，GPIOC，GPIOD。每组又以 A0<del>A7, B0</del>B7, C0<del>C7, D0</del>D7 作为编号区分。GPIO0B7在GPIO_SWPORT_DDR_L上所以，方向寄存器的偏移地址为0x0008。接着查看GPIO_SWPORT_DDR_L寄存器的具体描述，如下图（图18-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps148.jpg" alt="img"> </p>
<p>图 18-8</p>
<p>如上图（图 18-8）所示，[31:16]位属性是WO，也就是只可写入。这[31:16]位是写标志位，是低16位的写使能。如果低16位中某一位要设置输入输入输出，则对应高位写标志也应该设置为1。 [15：0] 是数据方向控制寄存器低位，如果要设置某个GPIO为输出，则对应位置1，如果要设置某个GPIO为输入，则对应位置0。那么GPIO0 B7 ，我们要设置第15位为输入还是输出，那么对应的[31:16]位写使能也要置1。</p>
<p>打开参考手册part1的1.1小节Address Mapping。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps149.jpg" alt="img"> </p>
<p>图 18-9</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps150.jpg" alt="img"> </p>
<p>图 18-10</p>
<p>如上图（图18-10）所示，GPIO0的基地址为0xFDD60000。方向寄存器的地址&#x3D;基地址+偏移地址&#x3D;0xFDD60000+0x0008&#x3D;0xFDD60008</p>
<p>然后使用IO命令查看该寄存器的值，如下（图18-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps151.jpg" alt="img"> </p>
<p>图 18-11</p>
<p>如下图（图 18-11）所示，第15位默认为1，设置GPIO0_B7为输出。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps152.jpg" alt="img"> </p>
<p>查找数据寄存器</p>
<p>打开参考手册part1的1.1小节Address Mapping。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps153.jpg" alt="img"> </p>
<p>图 18-12</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps154.jpg" alt="img"> </p>
<p>图 18-13</p>
<p>如上图（图18-13）所示，GPIO0的基地址为0xFDD60000。</p>
<p>数据寄存器的偏移地址如下（图18-14）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps155.jpg" alt="img"> </p>
<p>图 18-14</p>
<p>所以数据寄存器的地址为基地址+偏移地址&#x3D;0xFDD60000。使用IO命令查看地址的值，如下（图18-15）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps156.jpg" alt="img"> </p>
<p>图 18-15</p>
<p>我们来看一下这个数据寄存器的描述，如下图（图18-16）所示，</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps157.jpg" alt="img"> </p>
<p>图18-16</p>
<p>分析上图的方法和在分析方向寄存器的方法同理，由上图可知，如果要控制第15位为高电平（置1），需要设置31位为1，那么点亮灯，需要向数据寄存器写入0x8000c040，如下图（图18-17）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps158.jpg" alt="img"> </p>
<p>图 18-17</p>
<p>如果要灭灯，需要设置第15位为0 ，第31位为1，那么向数据寄存器中写入0x80004040，如下图（图 18-18）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps159.jpg" alt="img"> </p>
<p>图 18-18</p>
<p>总结</p>
<p>l 复用关系寄存器的基地址为0xFDC20000 ，偏移地址为000C ，所以要操作的地址为基地址+偏移地址&#x3D;0xFDC2000C </p>
<p>l GPIO的基地址为0xFDD60000，偏移地址为0x0008，所以方向寄存器要操作的地址为基地址+偏移地址&#x3D;0xFDD60008</p>
<p>l GPIO的基地址为0xFDD60000，偏移地址为0x0000，所以数据寄存器要操作的地址为基地址+偏移地址&#x3D;0xFDD60000</p>
<p>l 默认的数据寄存器的值：0x8000c040亮灯，0x80004040灭灯</p>
<h2 id="18-3-实验程序编写"><a href="#18-3-实验程序编写" class="headerlink" title="18.3 实验程序编写"></a>18.3 实验程序编写</h2><h3 id="18-3-1-驱动程序编写"><a href="#18-3-1-驱动程序编写" class="headerlink" title="18.3.1 驱动程序编写"></a>18.3.1 驱动程序编写</h3><p>本驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\13\module。</p>
<p>本次实验在15章的驱动程序基础上进行编写，通过在应用层传入0&#x2F;1数据到内核，如果传入数据是1，则设置GPIO的数据寄存器值为0x8000c040，如果应用层传入0，则设置GPIO的数据寄存器值为0x80004040，这样就可以达到控制led的效果， 编写好的驱动程序file.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_DR 0xFDD60000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *vir_gpio_dr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(test_dev-&gt;kbuf[<span class="number">0</span>]==<span class="number">1</span>)&#123;   <span class="comment">//如果应用层传入的数据是1，则打开灯</span></span><br><span class="line">            *(test_dev-&gt;vir_gpio_dr) = <span class="number">0x8000c040</span>;   <span class="comment">//设置数据寄存器的地址</span></span><br><span class="line">            printk(<span class="string">&quot;test_dev-&gt;kbuf [0]  is %d\n&quot;</span>,test_dev-&gt;kbuf[<span class="number">0</span>]);  <span class="comment">//打印传入的数据</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(test_dev-&gt;kbuf[<span class="number">0</span>]==<span class="number">0</span>)&#123;  <span class="comment">//如果应用层传入的数据是0，则关闭灯</span></span><br><span class="line">        *(test_dev-&gt;vir_gpio_dr) = <span class="number">0x80004040</span>; <span class="comment">//设置数据寄存器的地址</span></span><br><span class="line">        printk(<span class="string">&quot;test_dev-&gt;kbuf [0]  is %d\n&quot;</span>,test_dev-&gt;kbuf[<span class="number">0</span>]); <span class="comment">//打印传入的数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*本实验重点*****/</span></span><br><span class="line">    dev1.vir_gpio_dr=ioremap(GPIO_DR,<span class="number">4</span>);  <span class="comment">//将物理地址转化为虚拟地址</span></span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.vir_gpio_dr))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.vir_gpio_dr);  <span class="comment">//PTR_ERR()来返回错误代码</span></span><br><span class="line">        <span class="keyword">goto</span> err_ioremap;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_ioremap:</span><br><span class="line">        iounmap(dev1.vir_gpio_dr);</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);    <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="18-3-2-编写测试-APP"><a href="#18-3-2-编写测试-APP" class="headerlink" title="18.3.2 编写测试 APP"></a>18.3.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\13\app。</p>
<p>编写测试app,led驱动加载成功之后会生成&#x2F;dev&#x2F;test节点，应用程序APP通过操作&#x2F;dev&#x2F;test文件来完成对LED设备的控制。向&#x2F;dev&#x2F;test文件写入0表示关闭LED灯，写入1表示打开LED灯。编写完成的应用程序app.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开led驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// atoi()将字符串转为整型，这里将第一个参数转化为整型后，存放在 buf[0]中</span></span><br><span class="line">buf[<span class="number">0</span>] =atoi(argv[<span class="number">1</span>]);  </span><br><span class="line">write(fd,buf,<span class="keyword">sizeof</span>(buf));  <span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-4-运行测试"><a href="#18-4-运行测试" class="headerlink" title="18.4 运行测试"></a>18.4 运行测试</h2><h3 id="18-4-1编译驱动程序"><a href="#18-4-1编译驱动程序" class="headerlink" title="18.4.1编译驱动程序"></a>18.4.1编译驱动程序</h3><p>在上一小节中的file.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图5-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += file.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放file.c和Makefile文件目录下，如下图（图18-19）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps160.jpg" alt="img"> </p>
<p>图 18-19</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 18-20）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps161.jpg" alt="img"> </p>
<p>图 18-20</p>
<p>编译完生成 file.ko目标文件，如下图（图 18-21）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps162.jpg" alt="img"> </p>
<p>图 18-21</p>
<h3 id="18-4-2-编译应用程序"><a href="#18-4-2-编译应用程序" class="headerlink" title="18.4.2 编译应用程序"></a>18.4.2 编译应用程序</h3><p>至此我们的驱动模块就编译成功了，下面进行应用程序编译，因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图 18-21）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps163.jpg" alt="img"> </p>
<p>图 18-21</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="18-4-3-运行测试"><a href="#18-4-3-运行测试" class="headerlink" title="18.4.3 运行测试"></a>18.4.3 运行测试</h3><p>驱动模块file.ko和测试程序app都已经准备好了，接下来就是运行测试。</p>
<p>输入以下命令加载驱动程序，如下（图 18-22）所示：</p>
<p>insmod file.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps164.jpg" alt="img"> </p>
<p>图 18-22</p>
<p>然后运行测试程序，输入“.&#x2F;app 1”，LED灯点亮，如下图（图 18-24）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps165.jpg" alt="img"> </p>
<p>图 18-23</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps166.jpg" alt="img"> </p>
<p>图 18-24</p>
<p>输入“.&#x2F;app 0”,LED灯熄灭，如下图（图 18-26）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps167.jpg" alt="img"> </p>
<p>图 18-25</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps168.jpg" alt="img"> </p>
<p>图 18-26</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%9F%BA%E7%A1%80/" rel="tag">字符设备基础</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-cmake-基础课"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/03/cmake-%E5%9F%BA%E7%A1%80%E8%AF%BE/"
    >cmake 基础课</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/03/cmake-%E5%9F%BA%E7%A1%80%E8%AF%BE/" class="article-date">
  <time datetime="2023-09-03T09:50:19.000Z" itemprop="datePublished">2023-09-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/cmake/">cmake</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="一、准备知识"><a href="#一、准备知识" class="headerlink" title="一、准备知识"></a>一、准备知识</h1><h2 id="1-1-C-的编译过程"><a href="#1-1-C-的编译过程" class="headerlink" title="1.1 C++的编译过程"></a>1.1 C++的编译过程</h2><ul>
<li>-E 仅预处理；不编译、汇编或链接。</li>
<li>-S 仅编译；不汇编或链接。</li>
<li>-c 编译和汇编，但不链接。</li>
<li>-o <file> 将输出放入<file>中。</li>
</ul>
<p><strong>C++源代码的编译过程</strong></p>
<ol>
<li><p><strong>预处理</strong>：在预处理阶段，C++源代码中的预处理指令会被处理，包括宏展开和条件编译等。在此阶段，需要添加所有头文件的引用路径。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将xx.cpp源文件预处理为xx.i文件（文本文件）</span></span><br><span class="line">g++ -E main.cpp -o main.i</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编译</strong>：编译阶段会对预处理后的代码进行语法检查和编译，将代码翻译为汇编语言文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将xx.i文件编译为xx.s的汇编文件（文本文件）</span></span><br><span class="line">g++ -S main.i -o main.s</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>汇编</strong>：汇编阶段将汇编语言文件转换为二进制格式的目标文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将xx.s文件汇编为xx.o的二进制目标文件</span></span><br><span class="line">g++ -c main.s -o main.o</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>链接</strong>：链接阶段将目标文件与所依赖的库文件进行关联或组装，生成可执行文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将目标文件进行链接，生成可执行程序</span></span><br><span class="line">g++ main.o -o main</span><br><span class="line">```</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="1-2-静态链接库和动态链接库"><a href="#1-2-静态链接库和动态链接库" class="headerlink" title="1.2 静态链接库和动态链接库"></a>1.2 静态链接库和动态链接库</h2><p>静态链接库和动态链接库的区别在于链接的阶段不同。</p>
<p><strong>静态链接库</strong>的名称通常以<code>.a</code>结尾（表示archive library），它在编译阶段进行链接。如果一个工程依赖于静态链接库，那么生成的可执行文件或库会将静态链接库<code>.a</code>打包到输出文件中，因此生成的文件比较大。在运行时，不再需要单独的库文件。</p>
<p><strong>动态链接库</strong>的链接发生在程序的执行过程中，它在编译阶段仅进行链接检查，而不进行真正的链接过程。动态链接库的后缀名通常为<code>.so</code>（表示shared object，在Linux上）或<code>.dylib</code>（在macOS上）。动态链接库在加载后，在内存中只保存一份拷贝。多个程序依赖于它时，不会重复加载和拷贝，节省了内存空间。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/image-20230903175645024.png" alt="image-20230903175645024"></p>
<h2 id="1-3-为什么需要CMake"><a href="#1-3-为什么需要CMake" class="headerlink" title="1.3 为什么需要CMake"></a>1.3 为什么需要CMake</h2><h3 id="1-3-1-g-命令行编译"><a href="#1-3-1-g-命令行编译" class="headerlink" title="1.3.1 g++命令行编译"></a>1.3.1 g++命令行编译</h3><p>当编译hello_world.cpp&#96;文件时，可以使用以下命令进行编译和运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -o main</span><br></pre></td></tr></table></figure>

<p>如果需要引入外部库可以使用以下方法进行编译：</p>
<p>方法一：使用<code>-lgflags</code>参数进行链接**</p>
<p>首先，需要安装<code>gflags</code>库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libgflags-dev libgflags2.2</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">然后，使用以下命令进行编译：</span><br><span class="line"></span><br><span class="line">````bash</span><br><span class="line">g++ main.cpp -lgflags -o main</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>方法二：使用<code>pkg-config</code>进行库文件和头文件路径查找**</p>
<p>首先，需要安装<code>pkg-config</code>工具：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install pkg-config</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">然后，使用以下命令进行编译：</span><br><span class="line"></span><br><span class="line">````bash</span><br><span class="line">g++ main.cpp `pkg-config --cflags --libs gflags` -o main</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">这里，`pkg-config --cflags --libs gflags`命令用于查找`gflags`库的头文件和库文件路径。</span><br></pre></td></tr></table></figure>

<p>编译完成后，可以使用以下命令运行可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main --age 31 --name alice</span><br></pre></td></tr></table></figure>

<p>有时候，在编译时不需要手动添加头文件或链接库路径，因为<code>g++</code>可以在默认的查询路径中找到这些库。然而，当项目文件和引入的外部库变得较多时，使用命令行编译会变得冗长且不便于调试和编辑。通常，在测试单个文件时可以使用命令行编译，但不推荐在实际项目中使用命令行编译方式。</p>
<h3 id="1-3-2-CMake简介"><a href="#1-3-2-CMake简介" class="headerlink" title="1.3.2 CMake简介"></a>1.3.2 CMake简介</h3><p>在实际工作中，推荐使用CMake来构建C++项目。CMake是一个开源的跨平台工具，用于构建、测试和软件打包。</p>
<p>CMake具有以下特性：</p>
<ul>
<li><strong>自动搜索依赖项</strong>：CMake具有自动搜索可能需要的程序、库和头文件的能力，可以简化依赖项的配置过程。</li>
<li><strong>独立的构建目录</strong>：CMake支持使用独立的构建目录（例如<code>build</code>目录），这样可以安全地清理构建产生的中间文件和输出文件，不会污染源代码目录。</li>
<li><strong>自定义命令</strong>：CMake支持定义复杂的自定义命令，例如下载文件、生成各种文件等，可以满足项目构建过程中的特定需求。</li>
<li><strong>自定义配置</strong>：CMake支持根据需求进行自定义配置，可以选择性地启用或禁用特定的组件或功能。</li>
<li><strong>文本文件生成工作区和项目</strong>：CMake使用简单的文本文件（<code>CMakeLists.txt</code>）来描述项目的配置和构建规则，可以根据这些文件自动生成工作区和项目。</li>
<li><strong>文件依赖项自动生成和并行构建</strong>：CMake可以在主流平台上自动生成文件之间的依赖关系，从而使构建过程更高效。同时，CMake支持并行构建，可以加快构建速度。</li>
<li><strong>支持多种IDE</strong>：CMake几乎支持所有主流的集成开发环境（IDE），包括Visual Studio、Xcode、Eclipse等，可以方便地在不同的开发环境中进行项目开发和调试。</li>
</ul>
<h1 id="二、CMake基础知识"><a href="#二、CMake基础知识" class="headerlink" title="二、CMake基础知识"></a>二、CMake基础知识</h1><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h2><p>在Ubuntu上安装CMake可以使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install cmake -y</span><br></pre></td></tr></table></figure>

<p>这将使用apt包管理器自动安装CMake。</p>
<p>如果你想编译安装特定版本的CMake，可以按照以下步骤操作：</p>
<p>克隆CMake的源代码库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone -b v3.25.1 https://github.com/Kitware/CMake.git</span><br><span class="line">cd CMake</span><br><span class="line"></span><br><span class="line">这里以安装版本3.25.1为例，你可以将`v3.25.1`替换为你想要安装的特定版本。</span><br></pre></td></tr></table></figure>

<p>配置和编译CMake：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./bootstrap --prefix=&lt;安装路径&gt;</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">你可以使用`--prefix`选项来指定安装路径，或者省略`--prefix`以安装到默认路径。</span><br></pre></td></tr></table></figure>

<p>安装CMake：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">这将以管理员权限安装CMake到系统中。</span><br></pre></td></tr></table></figure>

<p>安装完成后，你可以验证CMake的安装版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure>

<p>该命令将显示CMake的版本信息，确认安装成功与否。</p>
<h2 id="2-2-第一个CMake例子"><a href="#2-2-第一个CMake例子" class="headerlink" title="2.2 第一个CMake例子"></a>2.2 第一个CMake例子</h2><p><strong>配置：</strong> 使用<code>cmake</code>命令进行配置，其中<code>-S</code>选项指定源码目录，<code>-B</code>选项指定构建目录。在终端中执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake -S . -B build</span><br><span class="line"></span><br><span class="line">这将在当前目录下执行CMake配置，并将生成的构建系统文件放在名为`build`的目录中。</span><br></pre></td></tr></table></figure>

<p><strong>生成：</strong> 使用<code>cmake --build</code>命令进行生成，其中<code>--build</code>选项指定构建目录。在终端中执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake --build build</span><br><span class="line"></span><br><span class="line">这将在`build`目录中执行构建步骤，生成可执行文件。</span><br></pre></td></tr></table></figure>

<p><strong>运行：</strong> 使用以下命令运行生成的可执行文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./build/first_cmake</span><br><span class="line"></span><br><span class="line">这将执行生成的可执行文件。</span><br></pre></td></tr></table></figure>

<h2 id="2-3-语法基础"><a href="#2-3-语法基础" class="headerlink" title="2.3 语法基础"></a>2.3 语法基础</h2><h3 id="2-3-1-指定版本"><a href="#2-3-1-指定版本" class="headerlink" title="2.3.1 指定版本"></a>2.3.1 指定版本</h3><p>在CMake中，可以使用<code>cmake_minimum_required</code>命令指定当前项目所需的最低CMake版本。它的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION &lt;version_number&gt;)</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;version_number&gt;</code>是所需的最低CMake版本号。在这个命令之后，CMake将会检查系统中安装的CMake版本是否满足这个要求，如果不满足则会产生错误。</p>
<p>例如，如果要指定最低的CMake版本为3.10，可以在CMakeLists.txt文件中添加以下命令：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br></pre></td></tr></table></figure>

<p>这样，CMake将会检查系统中的CMake版本是否大于等于3.10。</p>
<p>除了<code>cmake_minimum_required</code>命令，CMake中还有其他类似的命令，它们不区分大小写，并且有许多关键字来引导命令的参数输入，类似于函数的参数传递。这些命令使用的关键字在CMake中是不区分大小写的。</p>
<h3 id="2-3-2-设置项目"><a href="#2-3-2-设置项目" class="headerlink" title="2.3.2 设置项目"></a>2.3.2 设置项目</h3><p>在CMakeLists.txt文件的开头，通常会使用<code>project</code>命令来指定项目的名称、版本、描述和所使用的语言。<code>project</code>命令的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(ProjectName</span><br><span class="line">    [VERSION &lt;version_number&gt;]</span><br><span class="line">    [DESCRIPTION <span class="string">&quot;project_description&quot;</span>]</span><br><span class="line">    [LANGUAGES &lt;language&gt;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>其中，<code>ProjectName</code>是项目的名称，在例子中使用的是”first_cmake”。<code>VERSION</code>关键字后面是项目的版本号，可以是任意格式的版本号，例如”1.0.0”。<code>DESCRIPTION</code>关键字后面是项目的描述，可以是一个字符串。<code>LANGUAGES</code>关键字后面是项目所使用的语言，这里使用的是”Cxx”，表示C++。</p>
<p>示例中的<code>project</code>命令：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(first_cmake</span><br><span class="line">    VERSION <span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line">    DESCRIPTION <span class="string">&quot;项目描述&quot;</span></span><br><span class="line">    LANGUAGES Cxx</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这样，通过<code>project</code>命令，可以在CMakeLists.txt中指定项目的基本信息，方便管理和描述项目。</p>
<h3 id="2-3-3-添加可执行文件目标"><a href="#2-3-3-添加可执行文件目标" class="headerlink" title="2.3.3 添加可执行文件目标"></a>2.3.3 添加可执行文件目标</h3><p>使用了<code>add_executable</code>命令来定义一个可执行文件。该命令的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(&lt;target_name&gt; &lt;source_files&gt;)</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;target_name&gt;</code>是最终生成的可执行文件名，也是在CMake中定义的目标（Target）名。<code>&lt;source_files&gt;</code>是编译目标所使用的源文件。</p>
<p>在你提供的例子中，使用了<code>add_executable</code>命令来定义一个名为<code>first_cmake</code>的目标，并指定了一个源文件<code>main.cpp</code>。这意味着在编译时，会将<code>main.cpp</code>编译为一个可执行文件，该文件的名称将是<code>first_cmake</code>。</p>
<p>示例中的<code>add_executable</code>命令：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(first_cmake main.cpp)</span><br></pre></td></tr></table></figure>

<p>通过<code>add_executable</code>命令，可以在CMakeLists.txt中定义编译目标，并指定相应的源文件。这样，CMake将会根据这些定义生成相应的构建规则和编译指令。</p>
<h3 id="2-3-4-生成静态库并链接"><a href="#2-3-4-生成静态库并链接" class="headerlink" title="2.3.4 生成静态库并链接"></a>2.3.4 生成静态库并链接</h3><p>A. 生成静态库：</p>
<p>在<code>account_dir/CMakeLists.txt</code>中，使用<code>add_library</code>命令来生成静态库。该命令的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_library(&lt;library_name&gt; &lt;library_type&gt; &lt;source_files&gt;)</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;library_name&gt;</code>是最终生成的库文件名，例如在Linux下会生成<code>libAccount.a</code>。</p>
<p><code>&lt;library_type&gt;</code>用于指定链接库的类型，可以是动态链接库（<code>SHARED</code>）或静态链接库（<code>STATIC</code>）。</p>
<p><code>&lt;source_files&gt;</code>是需要用到的源文件。</p>
<p>例如，在<code>account_dir/CMakeLists.txt</code>中，使用<code>add_library</code>命令生成一个名为<code>Account</code>的静态库，其包含了<code>Account.cpp</code>和<code>Account.h</code>两个源文件。示例命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Account STATIC Account.cpp Account.h)</span><br></pre></td></tr></table></figure>

<p>这将生成一个静态库文件<code>libAccount.a</code>。</p>
<p>B. 链接：</p>
<p>在<code>test_account/CMakeLists.txt</code>中，可以通过<code>target_link_libraries</code>命令将生成的静态库链接到目标可执行文件中。该命令的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(&lt;target_name&gt; &lt;library_name&gt;)</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;target_name&gt;</code>是目标可执行文件的名称，<code>&lt;library_name&gt;</code>是要链接的库文件名。</p>
<p>例如，在<code>test_account/CMakeLists.txt</code>中，假设有一个目标可执行文件名为<code>test_account</code>，需要链接生成的静态库<code>Account</code>。示例命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(test_account Account)</span><br></pre></td></tr></table></figure>

<p>这样，生成的可执行文件<code>test_account</code>将会链接静态库<code>Account</code>。</p>
<h3 id="2-3-5-生成动态库并连接"><a href="#2-3-5-生成动态库并连接" class="headerlink" title="2.3.5 生成动态库并连接"></a>2.3.5 生成动态库并连接</h3><p>A. 生成动态库：</p>
<p>在<code>account_dir/CMakeLists.txt</code>中，使用<code>add_library</code>命令来生成动态库。与生成静态库不同的是，需要将<code>&lt;library_type&gt;</code>参数设置为<code>SHARED</code>，表示生成动态链接库。</p>
<p>示例命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Account SHARED Account.cpp Account.h)</span><br></pre></td></tr></table></figure>

<p>这将生成一个动态库文件<code>libAccount.so</code>。</p>
<p>B. 链接：</p>
<p>链接过程与生成静态库时的操作相同，使用<code>target_link_libraries</code>命令将动态库链接到目标可执行文件中。</p>
<p>示例命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(test_account Account)</span><br></pre></td></tr></table></figure>

<p>这样，生成的可执行文件<code>test_account</code>将会链接动态库<code>Account</code>。</p>
<h3 id="2-3-6-CMake中的PUBLIC、PRIVATE、INTERFACE"><a href="#2-3-6-CMake中的PUBLIC、PRIVATE、INTERFACE" class="headerlink" title="2.3.6 CMake中的PUBLIC、PRIVATE、INTERFACE"></a>2.3.6 CMake中的PUBLIC、PRIVATE、INTERFACE</h3><p>在CMake中，可以使用<code>target_...()</code>系列命令来操作目标（Target）。这些命令通常支持通过<code>PUBLIC</code>、<code>PRIVATE</code>、<code>INTERFACE</code>关键字来控制属性的传播。</p>
<p>以<code>target_link_libraries(A B)</code>为例，下面是对这些关键字的理解：</p>
<ul>
<li><code>PRIVATE</code>：依赖项B仅链接到目标A。如果有目标C链接了目标A，目标C不会链接目标B。</li>
<li><code>INTERFACE</code>：依赖项B并不链接到目标A。如果有目标C链接了目标A，目标C会链接目标B。</li>
<li><code>PUBLIC</code>：依赖项B链接到目标A。如果有目标C链接了目标A，目标C也会链接目标B。</li>
</ul>
<p>可以将其类比为一个散烟的比方：</p>
<ul>
<li><code>PRIVATE</code>：就是自己抽烟，不给别人抽。</li>
<li><code>INTERFACE</code>：就是自己不抽烟，给别人抽。</li>
<li><code>PUBLIC</code>：就是自己抽烟，也给别人抽。</li>
</ul>
<p>从使用的角度来看，假设有目标C链接了目标A：</p>
<ul>
<li>如果目标B仅用于目标A的实现，并且不在头文件中提供给目标C使用，可以使用<code>PRIVATE</code>。</li>
<li>如果目标B不用于目标A的实现，仅在头文件中作为接口给目标C使用，可以使用<code>INTERFACE</code>。</li>
<li>如果目标B既用于目标A的实现，也在头文件中提供给目标C使用，可以使用<code>PUBLIC</code>。</li>
</ul>
<p>以下是一个示例：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建库</span></span><br><span class="line"><span class="keyword">add_library</span>(c c.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(D d.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(B b.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用target_link_libraries命令进行链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(A PRIVATE B)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(A INTERFACE C)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(A PUBLIC D)</span><br></pre></td></tr></table></figure>

<p>在上述示例中，目标<code>A</code>通过<code>target_link_libraries</code>命令链接了目标<code>B</code>、<code>C</code>和<code>D</code>，使用了不同的传播属性。具体属性的选择取决于目标之间的关系和使用需求。</p>
<h3 id="2-3-7-变量"><a href="#2-3-7-变量" class="headerlink" title="2.3.7 变量"></a>2.3.7 变量</h3><p>在CMake中，你可以使用<code>message</code>命令输出消息并进行变量的操作和设置。</p>
<p>以下是一些常见的用法：</p>
<p>1.输出消息：使用<code>message</code>命令可以输出消息到CMake的输出。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;输出消息&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>2.消息拼接：使用<code>message</code>命令可以将多个消息进行拼接输出。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;输出1&quot;</span> <span class="string">&quot;输出2&quot;</span> <span class="string">&quot;输出3&quot;</span>)  <span class="comment"># 会进行拼接输出</span></span><br></pre></td></tr></table></figure>

<p>3.设置变量：使用<code>set</code>命令可以设置变量的值。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(VAR1 <span class="string">&quot;变量1&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;VAR1=&quot;</span> <span class="variable">$&#123;VAR1&#125;</span>)  <span class="comment"># 外部访问</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;输出变量VAR1:$&#123;VAR1&#125;&quot;</span>)  <span class="comment"># 内部拼接</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;\$&#123;VAR1&#125;=$&#123;VAR1&#125;&quot;</span>)  <span class="comment"># 使用\转义</span></span><br></pre></td></tr></table></figure>

<p>4.删除变量：使用<code>unset</code>命令可以删除变量。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unset</span>(VAR1)  <span class="comment"># 删除变量</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;\$&#123;VAR1&#125;=$&#123;VAR1&#125;&quot;</span>)  <span class="comment"># 删除变量后，输出为空</span></span><br></pre></td></tr></table></figure>

<p>5.设置变量缓存：使用<code>set</code>命令的<code>CACHE</code>选项可以设置一个变量的缓存，可以通过命令行的<code>-D</code>参数来修改该变量的值。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CACHE_VARIABLE_TEST <span class="string">&quot;原始值&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;变量缓存的描述&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;变量缓存的值:$&#123;CACHE_VARIABLE_TEST&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>6.常见的内置变量：CMake提供了一些内置的变量，用于获取构建系统的信息和配置</p>
<p>第一类: 提供信息的变量</p>
<ul>
<li><code>PROJECT_NAME</code>：项目名称，表示当前CMake项目的名称。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;PROJECT_NAME&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMAKE_SOURCE_DIR</code>：源码目录，表示当前CMake项目的根源码目录。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMAKE_BINARY_DIR</code>：编译目录，表示当前CMake项目的编译输出目录。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMAKE_CURRENT_LIST_FILE</code>：当前CMakeLists.txt文件路径，表示当前正在处理的CMakeLists.txt文件的完整路径。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_FILE&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这些变量提供了与项目、目录结构和文件相关的信息。</p>
<hr>
<p>第二类: 控制CMake运行的变量</p>
<p>CMake中的变量通常是根据构建选项进行命名的，例如<code>BUILD_SHARED_LIBS</code>。这些变量用于控制CMake的运行和构建过程。</p>
<hr>
<p>第三类: 描述系统的变量</p>
<ul>
<li><code>WIN32</code>：表示当前操作系统是否为Windows。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;是否是Windows系统: $&#123;WIN32&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>UNIX</code>：表示当前操作系统是否为类Unix（包括Linux、macOS等）。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;是否是Unix系统: $&#123;UNIX&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMAKE_SYSTEM_NAME</code>：系统名称，表示当前操作系统的名称。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;系统名称: $&#123;CMAKE_SYSTEM_NAME&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这些变量用于描述当前操作系统的一些信息，以便在构建过程中进行条件判断和配置。</p>
<h3 id="2-3-8-include引入其他代码"><a href="#2-3-8-include引入其他代码" class="headerlink" title="2.3.8 include引入其他代码"></a>2.3.8 include引入其他代码</h3><h3 id="2-3-9-条件控制"><a href="#2-3-9-条件控制" class="headerlink" title="2.3.9 条件控制"></a>2.3.9 条件控制</h3><p>CMake提供了条件控制的语法和关键词，使得你可以根据条件来控制构建过程中的行为。以下是一些常用的条件控制关键词和语法：</p>
<ul>
<li><code>if (variable)</code>：当变量的值为真时，执行相应的代码块。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE为真时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>else()</code>：在if条件为假时执行的代码块。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE为真时执行的代码块</span></span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE为假时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>真值常量：<code>ON</code>、<code>YES</code>、<code>TRUE</code>、<code>Y</code>、<code>1</code>、非零数字等。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE <span class="keyword">STREQUAL</span> <span class="string">&quot;ON&quot;</span>)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE的值为真时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>假值常量：<code>OFF</code>、<code>NO</code>、<code>FALSE</code>、<code>N</code>、<code>0</code>、空字符串、<code>NOTFOUND</code>等。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE <span class="keyword">STREQUAL</span> <span class="string">&quot;OFF&quot;</span>)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE的值为假时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>关键词：<code>NOT</code>、<code>TARGET</code>、<code>EXISTS (file)</code>、<code>DEFINED</code>等，可以与条件一起使用。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> <span class="keyword">TARGET</span> MyTarget)</span><br><span class="line">    <span class="comment"># 当MyTarget不存在时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>逻辑运算符：<code>AND</code>、<code>OR</code>用于组合多个条件。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (CONDITION1 <span class="keyword">AND</span> CONDITION2)</span><br><span class="line">    <span class="comment"># 当CONDITION1和CONDITION2同时为真时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CONDITION1 <span class="keyword">OR</span> CONDITION2)</span><br><span class="line">    <span class="comment"># 当CONDITION1或CONDITION2至少一个为真时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>MATCHES (regular expression)</code>：使用正则表达式进行匹配。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE <span class="keyword">MATCHES</span> <span class="string">&quot;^prefix.*&quot;</span>)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE以&quot;prefix&quot;开头时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>VERSION LESS</code>、<code>VERSION LESS_EQUAL</code>：用于比较版本号。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VERSION VERSION <span class="keyword">LESS</span> <span class="number">2.0</span>)</span><br><span class="line">    <span class="comment"># 当MY_VERSION小于2.0时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>通过这些条件控制关键词和语法，你可以根据不同的条件来执行不同的代码块，从而实现更灵活和可配置的构建过程。你可以根据具体的需求选择适当的条件控制方式，并结合变量、关键词和运算符来编写CMake脚本。</p>
<h3 id="2-3-10-CMake分步编译"><a href="#2-3-10-CMake分步编译" class="headerlink" title="2.3.10 CMake分步编译"></a>2.3.10 CMake分步编译</h3><p>首先，你使用以下命令查看所有的目标：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target help</span><br></pre></td></tr></table></figure>

<p>这将列出项目中可用的目标列表，包括默认目标”all”、”clean”、”depend”、”rebuild_cache”、”edit_cache”以及其他一些目标。</p>
<p>接下来，你执行以下命令进行预处理：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target main.i</span><br></pre></td></tr></table></figure>

<p>这将对”main.cpp”源文件进行预处理，并将预处理结果保存在”CMakeFiles&#x2F;steps_demo.dir&#x2F;main.cpp.i”文件中。</p>
<p>然后，你执行以下命令进行编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target main.sI</span><br></pre></td></tr></table></figure>

<p>这将将”main.cpp”源文件编译为汇编代码，并将汇编代码保存在”CMakeFiles&#x2F;steps_demo.dir&#x2F;main.cpp.s”文件中。</p>
<p>接着，你执行以下命令进行汇编：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target main.o</span><br></pre></td></tr></table></figure>

<p>这将将汇编代码编译为目标文件，并将目标文件保存为”CMakeFiles&#x2F;steps_demo.dir&#x2F;main.cpp.o”。</p>
<p>最后，你执行以下命令进行链接：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build .</span><br></pre></td></tr></table></figure>

<p>这将扫描依赖项并链接生成最终的可执行文件”steps_demo”。</p>
<p>最后，你执行以下命令运行可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./steps_demo</span><br></pre></td></tr></table></figure>

<p>这将运行生成的可执行文件。</p>
<h3 id="2-3-11-生成器表达式"><a href="#2-3-11-生成器表达式" class="headerlink" title="2.3.11 生成器表达式"></a>2.3.11 生成器表达式</h3><p>生成器表达式是CMake中一种用于在生成构建系统时根据不同配置动态生成特定内容的表达式。它可以让代码更加精简和灵活。下面是几种常用的生成器表达式类型：</p>
<p>条件表达式：<code>$&lt;condition:true_string&gt;</code>。当条件为真时，返回<code>true_string</code>，否则返回空字符串。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&lt;<span class="number">0</span>:<span class="keyword">TEST</span>&gt;           <span class="comment"># 返回空字符串</span></span><br><span class="line">$&lt;<span class="number">1</span>:<span class="keyword">TEST</span>&gt;           <span class="comment"># 返回&quot;TEST&quot;</span></span><br><span class="line">$&lt;$&lt;BOOL:<span class="keyword">TRUE</span>&gt;:<span class="keyword">TEST</span>&gt;  <span class="comment"># 返回&quot;TEST&quot;</span></span><br></pre></td></tr></table></figure>

<p>变量查询（Variable-Query）：通过查询变量来获取动态的值。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&lt;TARGET_EXISTS:<span class="keyword">target</span>&gt;             <span class="comment"># 判断目标是否存在</span></span><br><span class="line">$&lt;CONFIG:Debug&gt;                     <span class="comment"># 判断当前构建类型是否为Debug</span></span><br></pre></td></tr></table></figure>

<p>目标查询（Target-Query）：通过查询目标来获取相关的信息。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&lt;TARGET_FILE:<span class="keyword">target</span>&gt;               <span class="comment"># 获取目标的文件路径</span></span><br><span class="line">$&lt;TARGET_FILE_NAME:<span class="keyword">target</span>&gt;          <span class="comment"># 获取目标的文件名</span></span><br></pre></td></tr></table></figure>

<p>输出相关表达式：用于在不同的构建环节使用不同的参数。比如，在<code>install</code>和<code>build</code>阶段使用不同的参数。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Foo ...)</span><br><span class="line"><span class="keyword">target_include_directories</span>(Foo</span><br><span class="line">    PUBLIC</span><br><span class="line">        $&lt;$&lt;CONFIG:Debug&gt;:<span class="variable">$&#123;DEBUG_INCLUDES&#125;</span>&gt;</span><br><span class="line">        $&lt;$&lt;CONFIG:Release&gt;:<span class="variable">$&#123;RELEASE_INCLUDES&#125;</span>&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在上述示例中，根据不同的构建配置（Debug或Release），生成器表达式选择性地包含不同的头文件路径。</p>
<p>需要注意的是，生成器表达式在生成构建系统时被展开，因此无法通过<code>message</code>命令直接打印。你可以使用类似<code>file(GENERATE OUTPUT &quot;./generator_test.txt&quot; CONTENT &quot;$&lt;$&lt;BOOL:TRUE&gt;:TEST&gt;&quot;)</code>的方式将生成器表达式的结果写入文件，以间接测试生成器表达式的值。</p>
<h3 id="2-3-12-函数和宏"><a href="#2-3-12-函数和宏" class="headerlink" title="2.3.12 函数和宏"></a>2.3.12 函数和宏</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个宏</span></span><br><span class="line"><span class="keyword">macro</span>(my_macro)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;宏内部的信息&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(macro_var <span class="string">&quot;宏内部变量test&quot;</span>)</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数</span></span><br><span class="line"><span class="keyword">function</span>(second_func arg1 arg2)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;第一个参数: $&#123;arg1&#125;，第二个参数: $&#123;arg2&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>my_macro</code>是一个没有参数的宏，它在宏内部输出一条信息，并设置了一个变量<code>macro_var</code>的值。</p>
<p><code>second_func</code>是一个函数，它有两个参数<code>arg1</code>和<code>arg2</code>。在函数内部，它输出了两个参数的值。</p>
<p>你可以在CMakeLists.txt文件中使用这些宏和函数，例如：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用宏</span></span><br><span class="line">my_macro()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">second_func(<span class="string">&quot;Hello&quot;</span> <span class="string">&quot;World&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当你运行CMake生成构建系统时，你将看到宏内部的信息输出，并且可以访问在宏或函数内部定义的变量。函数将输出参数的值。</p>
<p>请注意，宏和函数的定义需要在CMakeLists.txt文件的适当位置进行，并且在调用它们之前必须先定义它们。</p>
<h3 id="2-3-13-设置安装"><a href="#2-3-13-设置安装" class="headerlink" title="2.3.13 设置安装"></a>2.3.13 设置安装</h3><p><code>install</code>命令用于设置安装规则，将目标文件和文件夹安装到指定的位置。下面是你提供的代码的解释：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS instal_demo slib dlib</span><br><span class="line">    RUNTIME DESTINATION bin     <span class="comment"># 可执行文件安装路径</span></span><br><span class="line">    LIBRARY DESTINATION lib     <span class="comment"># 动态库安装路径</span></span><br><span class="line">    ARCHIVE DESTINATION lib     <span class="comment"># 静态库安装路径</span></span><br><span class="line">    PUBLIC_HEADER DESTINATION <span class="keyword">include</span>   <span class="comment"># 公共头文件安装路径</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>install</code>命令指定了要安装的目标文件列表，其中包括<code>instal_demo</code>、<code>slib</code>和<code>dlib</code>。</p>
<p>接下来，通过指定不同的<code>DESTINATION</code>参数，定义了目标文件在安装过程中的安装路径：</p>
<ul>
<li><code>RUNTIME DESTINATION bin</code>：指定可执行文件的安装路径为<code>bin</code>目录。</li>
<li><code>LIBRARY DESTINATION lib</code>：指定动态库的安装路径为<code>lib</code>目录。</li>
<li><code>ARCHIVE DESTINATION lib</code>：指定静态库的安装路径为<code>lib</code>目录。</li>
<li><code>PUBLIC_HEADER DESTINATION include</code>：指定公共头文件的安装路径为<code>include</code>目录。</li>
</ul>
<p>根据你的需求，这些目标文件将被安装到指定的目录中。</p>
<p>请注意，安装路径是相对于安装目录的，因此你需要确保安装目录在运行<code>make install</code>时正确设置。</p>
<p>要解决在安装后无法找到动态库的问题，可以使用<code>set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)</code>和<code>set(CMAKE_INSTALL_RPATH &quot;$&#123;CMAKE_INSTALL_PREFIX&#125;/lib&quot;)</code>来设置RPATH。</p>
<p>下面是相应的代码：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_WITH_INSTALL_RPATH <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_RPATH <span class="string">&quot;$&#123;CMAKE_INSTALL_PREFIX&#125;/lib&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)</code>指示在构建过程中使用与安装RPATH相同的RPATH。这样，在构建时就可以正确地查找和链接动态库。</p>
<p><code>set(CMAKE_INSTALL_RPATH &quot;$&#123;CMAKE_INSTALL_PREFIX&#125;/lib&quot;)</code>将安装RPATH设置为<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/lib</code>，其中<code>$&#123;CMAKE_INSTALL_PREFIX&#125;</code>是安装目录的路径。这将导致在安装时设置RPATH，使得安装后的可执行文件可以在<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/lib</code>目录中正确地查找和加载动态库。</p>
<p>通过使用这两个设置，你可以解决在安装后无法找到动态库的问题。确保将其放置在CMakeLists.txt文件中的合适位置，并根据实际情况调整<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/lib</code>路径，以匹配你的安装目录结构。</p>
<h3 id="2-3-14-寻找依赖find-package"><a href="#2-3-14-寻找依赖find-package" class="headerlink" title="2.3.14 寻找依赖find_package"></a>2.3.14 寻找依赖find_package</h3><p>对于大多数支持CMake的项目来说，可以使用<code>find_package</code>命令来查找对应的依赖库。通常情况下，如果找到了库，会设置以下变量（这些变量由库的作者设置）：</p>
<ul>
<li><code>&lt;LibaryName&gt;_FOUND</code>：表示是否找到库。</li>
<li><code>&lt;LibaryName&gt;_INCLUDE_DIR</code>：表示库的头文件目录。</li>
<li><code>&lt;LibaryName&gt;_LIBRARIES</code>：表示库的库文件目录。</li>
</ul>
<p>如果你编写了一个新的函数库，并希望其他项目可以通过<code>find_package</code>引用它，你可以使用以下两种方法：</p>
<ol>
<li><p>编写一个<code>Find&lt;LibraryName&gt;.cmake</code>文件：适用于导入非CMake安装的项目。</p>
<p>你可以编写一个名为<code>Find&lt;LibraryName&gt;.cmake</code>的文件，并将其放置在CMake的<code>Modules</code>目录或项目的特定目录中。该文件应包含查找和设置相关变量的逻辑。其他项目可以通过<code>find_package</code>命令来引用这个自定义的查找文件，从而找到并使用你的库。</p>
<p>附件: 15.custom_find</p>
</li>
<li><p>使用<code>install</code>安装并生成<code>&lt;LibraryName&gt;Config.cmake</code>文件：适用于导入你自己开发的CMake项目。</p>
<p>在你的库项目中，可以使用<code>install</code>命令将库文件安装到指定位置，并生成<code>&lt;LibraryName&gt;Config.cmake</code>文件。该文件应包含设置变量和导出目标的逻辑。其他项目可以通过<code>find_package</code>命令找到并使用你的库。</p>
</li>
</ol>
<p>&#x3D;&#x3D;现在只是简单的写了一下学习的内容，但是对于很多内容还并不是很熟悉，一切都要等到最后实战的时候&#x3D;&#x3D;</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cmake/" rel="tag">cmake</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-c-进阶语法-oop-智能指针-STL"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/03/c-%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95-oop-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-STL/"
    >c++进阶语法 oop 智能指针 STL</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/03/c-%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95-oop-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-STL/" class="article-date">
  <time datetime="2023-09-03T05:42:43.000Z" itemprop="datePublished">2023-09-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c/">c++</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-OOP面向对象开发"><a href="#1-OOP面向对象开发" class="headerlink" title="1 OOP面向对象开发"></a>1 OOP面向对象开发</h1><h2 id="1-1-类-class-和对象-objects"><a href="#1-1-类-class-和对象-objects" class="headerlink" title="1.1 类(class)和对象(objects)"></a>1.1 类(class)和对象(objects)</h2><pre><code>类(classes)和对象(objects)
</code></pre>
<p>C++类(classes)</p>
<ul>
<li>创建对象用的蓝图(blueprint)</li>
<li>用户自定义的数据类型</li>
<li>有成员属性(data)和成员方法(methods)</li>
<li>可以隐藏属性和方法(private)</li>
<li>可以提供公共接口(public)</li>
<li>示例:Account,Student,std:vector, std:string</li>
</ul>
<p>C++对象(objects)</p>
<ul>
<li>由类创建而来</li>
<li>表示类的一个具体的实例(lnstance)</li>
<li>可以有很多个实例，每个都有独立的身份·每个对象都可以使用类中定义的方法</li>
</ul>
<p>Account对象示例</p>
<ul>
<li>Jobs、Alice的apunt是Account类的实例</li>
<li>每个实例都有它的余额、可以提现、存钱</li>
</ul>
<p>声明一个类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span></span>; <span class="comment">// 存款</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span></span>; <span class="comment">// 取款</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建类的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Account jobs_account;</span><br><span class="line">Account alice_account;</span><br><span class="line">Account* mary_account = <span class="keyword">new</span> <span class="built_in">Account</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> mary_account;</span><br></pre></td></tr></table></figure>



<p>示例1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> </span><br><span class="line">&#123;</span><br><span class="line">    string name &#123;<span class="string">&quot;None&quot;</span>&#125;;</span><br><span class="line">    <span class="type">double</span> balance &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Account a;</span><br><span class="line">    Account b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>获取类的属性或者方法</p>
<p>使用点操作符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Account jobs_account;</span><br><span class="line">jobs_account.balance;</span><br><span class="line">jobs_account.<span class="built_in">deposit</span>( <span class="number">10.00</span>);</span><br></pre></td></tr></table></figure>

<p>如果是一个指向对象的指针，可以解引用或者使用箭头操作符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Account* alice_account = <span class="keyword">new</span> <span class="built_in">Account</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解引用指针并访问成员</span></span><br><span class="line">(*alice_account).balance; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指针访问成员</span></span><br><span class="line">alice_account-&gt;<span class="built_in">deposit</span>(<span class="number">100.0</span>);</span><br><span class="line">alice_account-&gt;balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> alice_account;</span><br></pre></td></tr></table></figure>



<h2 id="1-2-public、private、protected访问权限"><a href="#1-2-public、private、protected访问权限" class="headerlink" title="1.2 public、private、protected访问权限"></a>1.2 public、private、protected访问权限</h2><p>public</p>
<p>可以被任何实体访问   </p>
<hr>
<p>private<br>只能被本类的方法访问</p>
<hr>
<p>protected</p>
<p>可以被本类和子类(继承)的方法访问\</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span></span>; <span class="comment">// 存款</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span></span>; <span class="comment">// 取款</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>在类中实现完整的成员方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="type">double</span> balance &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">setBalance</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        balance = amount;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在类外面实现需要特殊定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="type">double</span> balance &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">setBalance</span><span class="params">(<span class="type">double</span> amount)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBalance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Account::setBalance</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">    balance = amount;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Account::getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-3-构造函数-constructor"><a href="#1-3-构造函数-constructor" class="headerlink" title="1.3 构造函数(constructor)"></a>1.3 构造函数(constructor)</h2><ul>
<li>特殊的成员方法</li>
<li>对象创建的时候自动调用</li>
<li>适用于实例参数初始化</li>
<li>函数名和类的名称一致</li>
<li>无需设置返回类型</li>
<li>可以被重载(overload)</li>
</ul>
<h2 id="1-4-析构函数-destructor"><a href="#1-4-析构函数-destructor" class="headerlink" title="1.4 析构函数(destructor)"></a>1.4 析构函数(destructor)</h2><ul>
<li>特殊的成员方法</li>
<li>函数名和类的名称一致，前面跟着一个~波浪符号</li>
<li>对象销毁的时候自动调用</li>
<li>没有参数，没有返回类型</li>
<li>只有一个析构函数(不能重载)</li>
<li>适用于释放内存等资源</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    std::string name&#123;<span class="string">&quot;account&quot;</span>&#125;;</span><br><span class="line">    <span class="type">double</span> balance&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Account</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Account</span>(std::string name);</span><br><span class="line">    <span class="built_in">Account</span>(<span class="type">double</span> balance);</span><br><span class="line">    <span class="built_in">Account</span>(std::string name, <span class="type">double</span> balance);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Account</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​		</p>
<h2 id="1-5-构造函数初始化列表"><a href="#1-5-构造函数初始化列表" class="headerlink" title="1.5 构造函数初始化列表"></a>1.5 构造函数初始化列表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，使用构造函数内部初始化参数</span></span><br><span class="line">    <span class="built_in">Account</span>(std::string name, <span class="type">double</span> balance) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，使用初始化列表初始化参数</span></span><br><span class="line">    <span class="built_in">Account</span>(std::string name, <span class="type">double</span> balance)</span><br><span class="line">        : name&#123;name&#125;, balance&#123;balance&#125; &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-代理构造函数"><a href="#1-6-代理构造函数" class="headerlink" title="1.6 代理构造函数"></a>1.6 代理构造函数</h2><ul>
<li>重载的构造函数很相似·冗余的代码可能会导致错误</li>
<li>使用代理构造函数</li>
<li>在一个构造函数初始化列表中调用另一个构造函数</li>
</ul>
<h2 id="1-7-拷贝构造函数"><a href="#1-7-拷贝构造函数" class="headerlink" title="1.7 拷贝构造函数"></a>1.7 拷贝构造函数</h2><p>当对象被拷贝时，C++必须从已存在的对象复制出一个新的对象</p>
<p>何时使用拷贝构造函数?</p>
<ul>
<li>以值传递方式传递对象给函数（作参数)</li>
<li>函数以值方式返回对象</li>
<li>使用已存在的对象复制新的对象</li>
</ul>
<p>如果不提供自己写的copy constructor,编译器会自动生成一个(可能不符合要</p>
<h2 id="1-9-浅拷贝和深拷贝"><a href="#1-9-浅拷贝和深拷贝" class="headerlink" title="1.9 浅拷贝和深拷贝"></a>1.9 浅拷贝和深拷贝</h2><p>如果不提供自己写的copy constructor.编译器会生成默认的<br>将目标对象的值逐个拷贝过来;<br>如果是指针，拷贝的是值（指向的地址)，而不是指向的对象（浅拷贝)在析构函数中释放内存时，其他对象中的指针可能还在指向被释放的资源</p>
<h2 id="1-10-在类中使用const"><a href="#1-10-在类中使用const" class="headerlink" title="1.10 在类中使用const"></a>1.10 在类中使用const</h2><p>在类中使用const常函数</p>
<p>函数名称后加const</p>
<ul>
<li>函数体内不可以修改类成员属性。常对象</li>
</ul>
<p>声明对象时前面加const</p>
<ul>
<li>不可以修改常对象的成员属性仅能调用常函数</li>
</ul>
<h2 id="1-11-在类中使用static"><a href="#1-11-在类中使用static" class="headerlink" title="1.11 在类中使用static"></a>1.11 在类中使用static</h2><p>静态成员变量</p>
<ul>
<li><p>所有对象共有同一份数据（数据共享)</p>
</li>
<li><p>在类中声明，类外初始化</p>
</li>
</ul>
<p>静态成员函数</p>
<p>所有对象共享同一个函数</p>
<ul>
<li>只能访问静态成员变量</li>
</ul>
<h2 id="1-12-struct和class区别"><a href="#1-12-struct和class区别" class="headerlink" title="1.12 struct和class区别"></a>1.12 struct和class区别</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    std::string name&#123;<span class="string">&quot;none&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认私有属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    std::string name&#123;<span class="string">&quot;none&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 默认公有属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Account aa;</span><br><span class="line">    <span class="comment">// aa.name = &quot;bob&quot;; // 报错，无法访问私有成员</span></span><br><span class="line"></span><br><span class="line">    Student ss;</span><br><span class="line">    ss.name = <span class="string">&quot;alice&quot;</span>; <span class="comment">// 可以访问公有成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-智能指针"><a href="#2-智能指针" class="headerlink" title="2 智能指针"></a>2 智能指针</h1><p>原始指针(raw pointer)的一些问题</p>
<p>1.c++提供了内存管理的绝对自由度</p>
<ul>
<li><p>分配</p>
</li>
<li><p>释放</p>
</li>
<li><p>声明周期管理</p>
</li>
</ul>
<p>2.一些潜在严重问题</p>
<ul>
<li><p>未初始化的指针(wild pointer)</p>
</li>
<li><p>内存泄漏(memory leak)</p>
</li>
<li><p>悬空指针(dangling pointer</p>
</li>
</ul>
<p>3.所有权(ownership)</p>
<ul>
<li>谁拥有指针?</li>
<li>何时可以删除指针?</li>
</ul>
<p>C++智能指针是一种用来管理动态分配的内存的工具，它们遵循RAII（资源获取即初始化）原则，可以自动释放内存，防止内存泄漏。</p>
<p>以下是几种常见的C++智能指针：</p>
<ol>
<li><code>unique_ptr</code>: <code>unique_ptr</code> 是一种独占所有权的智能指针，它指向堆上分配的对象，并负责在其生命周期结束时自动删除对象。每个 <code>unique_ptr</code> 只能拥有一个对象，并且不能进行拷贝，但可以进行移动。</li>
<li><code>shared_ptr</code>: <code>shared_ptr</code> 是一种共享所有权的智能指针，多个 <code>shared_ptr</code> 可以指向同一个对象。它使用引用计数来跟踪对象的所有者数量，并在最后一个所有者释放内存时删除对象。</li>
<li><code>weak_ptr</code>: <code>weak_ptr</code> 是一种弱引用指针，它可以与 <code>shared_ptr</code> 一起使用。<code>weak_ptr</code> 不会增加对象的引用计数，它允许对被 <code>shared_ptr</code> 管理的对象进行观测，但不拥有所有权。当 <code>shared_ptr</code> 删除对象后，<code>weak_ptr</code> 会自动失效。</li>
<li><code>auto_ptr</code>（已弃用）: <code>auto_ptr</code> 是C++98标准引入的智能指针，它类似于 <code>unique_ptr</code>，但具有一些问题和局限性，已被废弃，不推荐使用。</li>
</ol>
<p><code>unique_ptr&lt;T&gt;</code> 是一种独占所有权的智能指针，用于指向堆上的类型为 <code>T</code> 的对象。它保证在其生命周期结束时自动释放所指向的对象，确保资源的正确释放，避免内存泄漏。</p>
<p><code>unique_ptr</code> 的特点如下：</p>
<ul>
<li>它是唯一（unique）的，即一个 <code>unique_ptr</code> 对象拥有对应对象的唯一所有权。不能有多个 <code>unique_ptr</code> 指向同一个对象，这样可以避免多次释放同一块内存的问题。</li>
<li><code>unique_ptr</code> 不能进行复制或赋值，但可以通过移动语义来转移所有权。这意味着可以将所有权从一个 <code>unique_ptr</code> 转移到另一个 <code>unique_ptr</code>，从而实现对象所有权的转移而不进行内存复制。</li>
<li>当 <code>unique_ptr</code> 使用完毕或超出作用域时，它所指向的对象会自动释放和销毁，无需手动调用 <code>delete</code>。</li>
</ul>
<p>&#x3D;&#x3D;目前还没用过，等真正用过的时候再仔细看吧&#x3D;&#x3D;</p>
<h1 id="3-STL标准模板库"><a href="#3-STL标准模板库" class="headerlink" title="3 STL标准模板库"></a>3 STL标准模板库</h1><h2 id="3-1-STL简介"><a href="#3-1-STL简介" class="headerlink" title="3.1 STL简介"></a>3.1 STL简介</h2><p>一个强大的、可复用的、自适应的泛型类和函数集合</p>
<p>使用C++模板(templates)实现</p>
<p>实现了常见的数据结构(data struuctures)和算法(algorithms)</p>
<p>庞大的类库</p>
<p>俄裔美籍程序员:Alexander Step:anov 1994年开发</p>
<p>容器(containers)</p>
<ul>
<li>各种对象或原始类型的集合. array、vector、deque、stack、set、map等</li>
</ul>
<p>算法(algorithms)</p>
<ul>
<li>处理容器元素序列的各种函数find、max、count、accumulate、sort等</li>
</ul>
<p>迭代器(iterators)</p>
<ul>
<li>从容器中生成元素的序列. forward、reveise、by value、by constant等</li>
</ul>
<h2 id="3-2-STL容器的类别"><a href="#3-2-STL容器的类别" class="headerlink" title="3.2 STL容器的类别"></a>3.2 STL容器的类别</h2><p>序列式容器（Sequence Containers）：</p>
<ol>
<li><code>vector</code>：动态数组，支持快速随机访问，尾部插入和删除元素效率高，但在中间或头部插入和删除元素效率低。</li>
<li><code>list</code>：双向链表，支持在任意位置插入和删除元素，但随机访问效率较低。</li>
<li><code>forward_list</code>：单向链表，与 <code>list</code> 类似，但只支持单向遍历，没有双向遍历的能力。</li>
<li><code>deque</code>：双端队列，支持在头部和尾部高效地插入和删除元素，同时支持随机访问。</li>
</ol>
<p>关联式容器（Associative Containers）：</p>
<ol>
<li><code>set</code>：集合，存储唯一的元素，并按升序排序。</li>
<li><code>multi_set</code>：多重集合，可存储重复的元素，并按升序排序。</li>
<li><code>map</code>：映射，存储键值对，按键的升序排序。</li>
<li><code>multi_map</code>：多重映射，可存储重复的键值对，并按键的升序排序。</li>
</ol>
<p>容器适配器（Container Adapters）：</p>
<ol>
<li><code>stack</code>：栈，以 LIFO（后进先出）的方式存储元素，底层基于序列式容器实现，默认使用 <code>deque</code>。</li>
<li><code>queue</code>：队列，以 FIFO（先进先出）的方式存储元素，底层基于序列式容器实现，默认使用 <code>deque</code>。</li>
<li><code>priority_queue</code>：优先队列，按照优先级存储元素，底层基于序列式容器实现，默认使用 <code>vector</code>。</li>
</ol>
<h2 id="3-3-STL迭代器的类别"><a href="#3-3-STL迭代器的类别" class="headerlink" title="3.3 STL迭代器的类别"></a>3.3 STL迭代器的类别</h2><p>迭代器是一种用于遍历容器中元素的抽象概念，它提供了对容器中元素的访问和操作方式。C++中定义了多种类型的迭代器，每种迭代器具有不同的特性和功能。</p>
<ol>
<li>输入迭代器（Input Iterators）：从容器到程序，对数据进行只读访问。它允许逐个元素地读取容器中的数据，并且只能单向移动，不支持对容器进行修改。</li>
<li>输出迭代器（Output Iterators）：从程序到容器，对数据进行只写访问。它允许逐个元素地向容器中写入数据，并且只能单向移动，不支持读取容器中的数据。</li>
<li>前向迭代器（Forward Iterators）：向前推进迭代器，支持对容器进行读写操作。它具有输入迭代器和输出迭代器的所有功能，并且可以在容器中任意位置插入和删除元素，支持双向移动。</li>
<li>双向迭代器（Bidirectional Iterators）：向前、向后推进迭代器，支持对容器进行读写操作。它具有前向迭代器的所有功能，并且可以反向移动，即向前和向后移动。</li>
<li>随机访问迭代器（Random Access Iterators）：直接获取容器元素，支持对容器进行读写操作。它具有双向迭代器的所有功能，并且支持随机访问，可以通过偏移量直接访问容器中的任意元素。</li>
</ol>
<h2 id="3-4-STL算法的类别"><a href="#3-4-STL算法的类别" class="headerlink" title="3.4 STL算法的类别"></a>3.4 STL算法的类别</h2><p>非质变的算法（Non-modifying Algorithms）：</p>
<ol>
<li><code>std::all_of</code>：判断范围内的所有元素是否满足给定条件。</li>
<li><code>std::any_of</code>：判断范围内是否存在满足给定条件的元素。</li>
<li><code>std::none_of</code>：判断范围内是否所有元素都不满足给定条件。</li>
<li><code>std::for_each</code>：对范围内的每个元素执行指定的操作。</li>
<li><code>std::count</code>：计算范围内满足给定值的元素个数。</li>
<li><code>std::count_if</code>：计算范围内满足给定条件的元素个数。</li>
<li><code>std::find</code>：查找范围内第一个等于给定值的元素。</li>
<li><code>std::find_if</code>：查找范围内第一个满足给定条件的元素。</li>
<li><code>std::find_if_not</code>：查找范围内第一个不满足给定条件的元素。</li>
<li><code>std::find_end</code>：在范围内查找最后一次出现子序列的起始位置。</li>
<li><code>std::find_first_of</code>：在范围内查找第一次出现指定元素之一的位置。</li>
<li><code>std::adjacent_find</code>：在范围内查找第一对相邻重复元素的位置。</li>
<li><code>std::search</code>：在范围内查找第一次出现子序列的起始位置。</li>
<li><code>std::search_n</code>：在范围内查找第一次出现连续多个相等元素的起始位置。</li>
<li><code>std::equal</code>：判断两个范围内的元素是否相等。</li>
<li><code>std::mismatch</code>：找到两个范围内第一次不匹配的位置。</li>
<li><code>std::lexicographical_compare</code>：按字典顺序比较两个范围。</li>
<li><code>std::is_permutation</code>：判断两个范围内的元素是否是排列关系。</li>
<li><code>std::min_element</code>：找到范围内的最小元素的位置。</li>
<li><code>std::max_element</code>：找到范围内的最大元素的位置。</li>
<li><code>std::minmax_element</code>：同时找到范围内的最小和最大元素的位置。</li>
<li><code>std::clamp</code>：将给定值限制在指定范围内。</li>
<li><code>std::is_sorted</code>：判断范围内的元素是否按升序排序。</li>
<li><code>std::is_partitioned</code>：判断范围内的元素是否满足分区条件。</li>
<li><code>std::is_heap</code>：判断范围内的元素是否满足堆的条件。</li>
<li><code>std::is_sorted_until</code>：找到范围内的第一个无序位置。</li>
<li><code>std::is_partitioned_until</code>：找到范围内的第一个不满足分区条件的位置。</li>
<li><code>std::is_heap_until</code>：找到范围内的第一个不满足堆条件的位置。</li>
</ol>
<p>质变的算法（Modifying Algorithms）：</p>
<ol>
<li><code>std::copy</code>：复制范围内的元素到另一个容器。</li>
<li><code>std::copy_if</code>：复制满足给定条件的元素到另一个容器。</li>
<li><code>std::copy_n</code>：复制指定数量的元素到另一个容器。</li>
<li><code>std::copy_backward</code>：反向复制范围内的元素到另一个容器。</li>
<li><code>std::move</code>：将范围内的元素移动到另一个容器。</li>
<li><code>std::move_backward</code>：反向移动范围内的元素到另一个容器。</li>
<li><code>std::fill</code>：用给定值填充容器中的元素。</li>
<li><code>std::fill_n</code>：用给定值填充指定数量的元素。</li>
<li><code>std::generate</code>：使用生成器函数生成范围内的元素。</li>
<li><code>std::generate_n</code>：使用生成器函数生成指定数量的元素。</li>
<li><code>std::transform</code>：对范围内的元素应用指定的操作，并将结果存储到另一个容器。</li>
<li><code>std::replace</code>：将范围内的指定值替换为新值。</li>
<li><code>std::replace_if</code>：根据给定条件将范围内的元素替换为新值。</li>
<li><code>std::replace_copy</code>：将范围内的元素复制到另一个容器，并将指定值替换为新值。</li>
<li><code>std::replace_copy_if</code>：将范围内的元素复制到另一个容器，并根据给定条件替换为新值。</li>
<li><code>std::swap</code>：交换两个对象的值。</li>
<li><code>std::swap_ranges</code>：交换两个范围的元素。</li>
<li><code>std::iter_swap</code>：交换两个迭代器所指向的元素。</li>
<li><code>std::reverse</code>：反转范围内的元素顺序。</li>
<li><code>std::reverse_copy</code>：将范围内的元素反转后复制到另一个容器。</li>
<li><code>std::rotate</code>：将范围内的元素循环右移。</li>
<li><code>std::rotate_copy</code>：将范围内的元素循环右移后复制到另一个容器。</li>
<li><code>std::shuffle</code>：随机重排范围内的元素。</li>
<li><code>std::unique</code>：移除范围内的连续重复元素，只保留一个副本。</li>
<li><code>std::unique_copy</code>：将范围内的连续重复元素复制到另一个容器，只保留一个副本。</li>
<li><code>std::partition</code>：根据给定条件将范围内的元素分为满足条件和不满足条件的两部分。</li>
<li><code>std::stable_partition</code>：根据给定条件将范围内的元素稳定地分为满足条件和不满足条件的两部分。</li>
<li><code>std::sort</code>：对范围内的元素进行排序。</li>
<li><code>std::stable_sort</code>：对范围内的元素进行稳定排序。</li>
<li><code>std::partial_sort</code>：部分排序范围内的元素。</li>
<li><code>std::nth_element</code>：将范围内的第 n 小的元素移动到指定位置。</li>
<li><code>std::inplace_merge</code>：将两个已排序的范围合并为一个已排序的范围。</li>
<li><code>std::transform</code>：对范围内的元素应用指定的操作，并将结果存储到另一个容器。</li>
<li><code>std::generate</code>：使用生成器函数生成范围内的元素。</li>
<li><code>std::generate_n</code>：使用生成器函数生成指定数量的元素。</li>
<li><code>std::random_shuffle</code>：随机重排范围内的元素。</li>
<li><code>std::partition</code>：根据给定条件将范围内的元素分为满足条件和不满足条件的两部分。</li>
<li><code>std::sort</code>：对范围内的元素进行排序。</li>
<li><code>std::stable_sort</code>：对范围内的元素进行稳定排序。</li>
<li><code>std::partial_sort</code>：部分排序范围内的元素。</li>
<li><code>std::nth_element</code>：将范围内的第 n 小的元素移动到指定位置。</li>
<li><code>std::inplace_merge</code>：将两个已排序的范围合并为一个已排序的范围。</li>
<li><code>std::copy_backward</code>：反向复制范围内的元素到另一个容器。</li>
</ol>
<h2 id="3-5泛型编程和宏"><a href="#3-5泛型编程和宏" class="headerlink" title="3.5泛型编程和宏"></a>3.5泛型编程和宏</h2><h2 id="3-6函数模板"><a href="#3-6函数模板" class="headerlink" title="3.6函数模板"></a>3.6函数模板</h2><p>函数模板（Function Template）是C++中的一种特殊函数，用于定义通用的函数，可以适用于不同类型的参数。函数模板通过在函数定义中使用类型参数来实现通用性，这些类型参数可以在函数调用时被具体的类型替代。</p>
<p>以下是两个使用函数模板定义的求最大值函数的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(a, b) &lt;&lt; std::endl;  <span class="comment">// 调用模板函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-7类模板"><a href="#3-7类模板" class="headerlink" title="3.7类模板"></a>3.7类模板</h2><p>类模板（Class Template）是C++中的一种特殊类，用于定义通用的类，可以适用于不同类型的成员变量和成员函数。类模板通过在类定义中使用类型参数来实现通用性，这些类型参数可以在类实例化时被具体的类型替代。</p>
<p>类模板的使用方式类似于函数模板，通过在类定义前面使用 <code>template&lt;typename T&gt;</code> 或 <code>template&lt;class T&gt;</code> 声明一个模板类，其中 <code>T</code> 是一个模板参数，可以在类内部的成员变量和成员函数中使用。</p>
<p>以下是一个使用类模板定义的通用的容器类的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Container</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-c-进阶-函数和指针"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/03/c-%E8%BF%9B%E9%98%B6-%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88/"
    >c++ 进阶 函数和指针</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/03/c-%E8%BF%9B%E9%98%B6-%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88/" class="article-date">
  <time datetime="2023-09-03T03:48:33.000Z" itemprop="datePublished">2023-09-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c/">c++</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-掌握C-函数基本概念用法"><a href="#1-掌握C-函数基本概念用法" class="headerlink" title="1.掌握C++函数基本概念用法"></a>1.掌握C++函数基本概念用法</h1><h2 id="1-1-函数定义"><a href="#1-1-函数定义" class="headerlink" title="1.1 函数定义"></a>1.1 函数定义</h2><p>什么是函数(function)</p>
<ul>
<li><p>C++程序</p>
</li>
<li><p>C++标准库(functions和clas;ses)</p>
</li>
<li><p>第三方库(functions和class</p>
</li>
<li><p>自定义的functions和classes</p>
</li>
</ul>
<p>函数让我们的程序更加模块化</p>
<ul>
<li>让代码解耦，分成按业务，</li>
<li>按逻辑的单元提高代码复用性</li>
</ul>
<p>函数名称参数列表</p>
<ul>
<li><p>传给函数的变量</p>
</li>
<li><p>变量类型需声明</p>
</li>
</ul>
<p>返回值类型</p>
<ul>
<li><p>函数体</p>
</li>
<li><p>函数被调用执行的部分，花括号{}内部</p>
<p>示例1：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI &#123;<span class="number">3.1415926</span>&#125;; <span class="comment">// 圆周率</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculate_area</span><span class="params">(<span class="type">double</span> radius)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PI * <span class="built_in">pow</span>(radius, <span class="number">2</span>); <span class="comment">// pow()函数用于计算幂</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">circle_area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入圆的半径：&quot;</span>;</span><br><span class="line">    <span class="type">double</span> radius &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    cin &gt;&gt; radius;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的面积为：&quot;</span> &lt;&lt; <span class="built_in">calculate_area</span>(radius) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">circle_area</span>(); <span class="comment">// 调用计算圆的面积的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="1-2-函数原型-prototype"><a href="#1-2-函数原型-prototype" class="headerlink" title="1.2 函数原型(prototype)"></a>1.2 函数原型(prototype)</h2><p>&#x3D;&#x3D;编译器要求:使用函数前必须“见过”这个函数&#x3D;&#x3D;</p>
<p>先定义函数再调用</p>
<ul>
<li>适用于小型程序，不适用于大型项目</li>
</ul>
<p>使用函数原型</p>
<ul>
<li><p>告诉编译器函数定义必要的信息</p>
</li>
<li><p>也称为前向声明(forward declaration)</p>
</li>
<li><p>放在程序开始的部分</p>
</li>
<li><p>或者放在头文件(header files.h)中</p>
</li>
</ul>
<h2 id="1-3参数"><a href="#1-3参数" class="headerlink" title="1.3参数"></a>1.3参数</h2><ol>
<li>当我们传递数据给函数时，其实用的是值传递(pass by value)</li>
<li>数据的拷贝会传给函数</li>
<li>函数内部的代码不会改变我们传给它的变量</li>
</ol>
<p>形参(formal parameters)与实参(actual parameters)<br>形参(formal parameters)</p>
<ul>
<li>函数定义语句中的参数</li>
</ul>
<p>实参(actual parameters</p>
<ul>
<li>调用函数时传递的参数(arguments)</li>
</ul>
<h2 id="1-4-重载"><a href="#1-4-重载" class="headerlink" title="1.4 重载"></a>1.4 重载</h2><p>一组函数具有相同函数名，不同参数列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型，函数重载</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_numbers</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>; <span class="comment">// 两个 int 类型数字相加</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add_numbers</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>; <span class="comment">// 两个 double 类型数字相加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_numbers</span>(<span class="number">5</span>, <span class="number">10</span>) &lt;&lt; endl; <span class="comment">// int 类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_numbers</span>(<span class="number">1.23</span>, <span class="number">2.45</span>) &lt;&lt; endl; <span class="comment">// double 类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_numbers</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add_numbers</span><span class="params">(<span class="type">double</span> num1, <span class="type">double</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-5-函数传参-数组、引用"><a href="#1-5-函数传参-数组、引用" class="headerlink" title="1.5 函数传参(数组、引用)"></a>1.5 函数传参(数组、引用)</h2><ul>
<li><p>数组元素并没有复制</p>
</li>
<li><p>数组变量名称表示第一个元素在内存中的地址这个地址才被复制了</p>
</li>
<li><p>函数内部无法知道数组大小(数组大小需要额外传参)</p>
<p>·声明参数numbers是常量(只读read-only)</p>
</li>
</ul>
<p>		</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_array</span> <span class="params">(<span class="type">const</span> <span class="type">int</span> numbers[ ], <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_num</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换两个数字</span></span><br><span class="line">    <span class="type">int</span> x &#123;<span class="number">100</span>&#125;, y &#123;<span class="number">200</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y is: &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 100 200</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap_num</span>(x, y);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y is: &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 200 100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的是取地址，上面的函数和下面这个函数的作用相同：</p>
<p>传递地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_num</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换两个数字</span></span><br><span class="line">    <span class="type">int</span> x &#123;<span class="number">100</span>&#125;, y &#123;<span class="number">200</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y is: &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 100 200</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap_num</span>(&amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y is: &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 200 100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&#x3D;&#x3D;注意&#x3D;&#x3D;</p>
<p><code>int&amp;</code> 是 C++ 中的引用类型，它是一种特殊的类型，用于给一个已存在的变量起一个别名。可以将其理解为变量的一个别名或者另一个名称，与原变量共享同一块内存空间。</p>
<p>引用类型与指针类型有所不同。引用在声明时必须初始化，并且一旦初始化后，它就一直引用同一个对象，不能再引用其他对象。而指针可以在声明后重新指向不同的对象。</p>
<p>使用引用类型的主要目的是提供一种更简洁、更直观的方式来操作变量，同时避免了指针操作的一些繁琐性和潜在的错误。</p>
<p>在上述修正后的代码中，<code>int&amp;</code> 用于函数参数的声明，表示传递的参数是一个整数的引用。通过引用参数，可以直接修改原变量的值，而无需通过指针进行解引用。在函数内部，通过引用操作修改了 <code>a</code> 和 <code>b</code> 所指向的变量的值。</p>
<p>其实也就相当于传地址</p>
<h1 id="2-掌握C-指针基本概念、用法"><a href="#2-掌握C-指针基本概念、用法" class="headerlink" title="2.掌握C++指针基本概念、用法"></a>2.掌握C++指针基本概念、用法</h1><h2 id="2-1-什么是指针"><a href="#2-1-什么是指针" class="headerlink" title="2.1 什么是指针"></a>2.1 什么是指针</h2><p>指针是变量<br>变量的值是一个地址<br>指针的值可以存储哪些地址?</p>
<p>另一个变量</p>
<p>函数</p>
<hr>
<p>如果指针指向变量或函数，那么为什么不直接用他们?</p>
<p>可以，但不常用:</p>
<ul>
<li><p>函数内部，指针可以访问函数作用域外的数据</p>
</li>
<li><p>高效操作数组</p>
</li>
<li><p>在堆(heap)上动态分配内存空间</p>
<p>​      这些空间没有变量名称只能通过指针访问</p>
</li>
<li><p>可以获取内存中特殊地址</p>
</li>
</ul>
<p>​              如嵌入式系统、设备驱动等</p>
<hr>
<ul>
<li>&amp;地址操作符</li>
<li>指针也是一个变量(variable)，所以它的值可以改变</li>
<li>指针可以为null</li>
<li>指针可以不初始化</li>
</ul>
<h2 id="2-2-动态内存分配-dynami-allocation"><a href="#2-2-动态内存分配-dynami-allocation" class="headerlink" title="2.2 动态内存分配(dynami allocation)"></a>2.2 动态内存分配(dynami allocation)</h2><p>在堆(heap)上程序员自己分配内存空间;<br>数组(array)</p>
<ul>
<li>使用数组需要知道数组大小，并且数组大小是固定的;</li>
<li>Vector容器大小可以动态调整</li>
</ul>
<p>使用指针获取堆上刚分配的内存空间</p>
<hr>
<p>使用new[]为数组分配内存空间</p>
<p>使用delete[]释放内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* array_ptr &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr_size &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;你需要多少个整数: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; arr_size;</span><br><span class="line"></span><br><span class="line">    array_ptr = <span class="keyword">new</span> <span class="type">int</span>[arr_size]; <span class="comment">// 在堆上分配内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] array_ptr; <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-指针和数组的关系"><a href="#2-3-指针和数组的关系" class="headerlink" title="2.3 指针和数组的关系"></a>2.3 指针和数组的关系</h2><ul>
<li>数组变量名称的值是数组第一个元素的地址;</li>
<li>指针变量的的值是一个地址;</li>
<li>如果指针指向的类型和数组元素的类型一致，那么指针和数组名称几乎是等价的</li>
</ul>
<h2 id="2-4-const和指针一一指针本身和被指向的对象都是常量"><a href="#2-4-const和指针一一指针本身和被指向的对象都是常量" class="headerlink" title="2.4 const和指针一一指针本身和被指向的对象都是常量"></a>2.4 const和指针一一指针本身和被指向的对象都是常量</h2><p>指针可以操作:地址及被指向的对象</p>
<ul>
<li>被指向的对象是常量(povinters to constants)</li>
<li>指针本身是常量(constant pointers)</li>
<li>指针本身和被指向的对象都是常量(constant pointers to constants)</li>
</ul>
<p>示例1</p>
<ul>
<li>被指向的对象是常量，不可以通过指针改动·</li>
<li>指针本身可以改变</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> high_temp &#123;<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="type">int</span> low_temp &#123;<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* temp_ptr &#123;&amp;high_temp&#125;; <span class="comment">// 被指向的数据是常量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// *temp_ptr = 100; // 错误，不能通过解引用修改常量的值</span></span><br><span class="line"></span><br><span class="line">    temp_ptr = &amp;low_temp; <span class="comment">// 正确，可以通过指针修改指向的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例2</p>
<ul>
<li>被指向的对象可以通过指针改动</li>
<li>指针本身不可以改变</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> high_temp &#123;<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="type">int</span> low_temp &#123;<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> temp_ptr &#123;&amp;high_temp&#125;; <span class="comment">// 指针本身是常量，指向 high_temp</span></span><br><span class="line"></span><br><span class="line">    *temp_ptr = <span class="number">100</span>; <span class="comment">// 正确，通过指针解引用修改值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// temp_ptr = &amp;low_temp; // 错误，不能修改指针的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>示例3 </p>
<ul>
<li>被指向的对象不可以改动</li>
<li>指针本身不可以改变</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> high_temp &#123;<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="type">int</span> low_temp &#123;<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> temp_ptr &#123;&amp;high_temp&#125;; <span class="comment">// 指针和被指向对象都是常量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// *temp_ptr = 100; // 错误，不能修改指针指向的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// temp_ptr = &amp;low_temp; // 错误，不能修改指针的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-函数返回指针"><a href="#2-5-函数返回指针" class="headerlink" title="2.5 函数返回指针"></a>2.5 函数返回指针</h2><p>函数可以返回指针:</p>
<p> *function( );</p>
<p>返回哪些指针:</p>
<ul>
<li>函数内部动态分配的内存空间传入的数据</li>
<li>不能返回函数内的局部变量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">create_array</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> initial_value = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* new_storage &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    new_storage = <span class="keyword">new</span> <span class="type">int</span>[size]; <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i&#123;<span class="number">0</span>&#125;; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 初始化值</span></span><br><span class="line">        *(new_storage + i) = initial_value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_storage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> size &#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* array_ptr = <span class="built_in">create_array</span>(size, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数组元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i&#123;<span class="number">0</span>&#125;; i &lt; size; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; *(array_ptr + i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] array_ptr; <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-hexo-进阶"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/03/hexo-%E8%BF%9B%E9%98%B6/"
    >hexo 进阶</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/03/hexo-%E8%BF%9B%E9%98%B6/" class="article-date">
  <time datetime="2023-09-03T01:55:17.000Z" itemprop="datePublished">2023-09-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/hexo/">hexo</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-文章的分类和标签"><a href="#1-文章的分类和标签" class="headerlink" title="1 文章的分类和标签"></a>1 文章的分类和标签</h1><p>分类的话就是在最上方的状态栏中加入	categories:  属性即可</p>
<p>标签的话就是在最上方的状态栏中加入	tags:  属性即可</p>
<h1 id="2图床搭建教程"><a href="#2图床搭建教程" class="headerlink" title="2图床搭建教程"></a>2图床搭建教程</h1><p>根据这个教程来即可</p>
<p><a target="_blank" rel="noopener" href="https://eryinote.com/post/105">图床</a></p>
<p>踩坑 picgo这个软件双击并不是直接打开，而是到了右下角的小菜单。。。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/image-20230903113402329.png" alt="image-20230903113402329"></p>
<p>然后在typora软件中进行简单的设置即可。如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/image-20230903114440776.png" alt="image-20230903114440776"></p>
<p>至此就搞完了，其他目前也没啥需求，继续学习C++</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-c-基本语法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/02/c-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"
    >c++基本语法</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/02/c-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" class="article-date">
  <time datetime="2023-09-02T13:41:01.000Z" itemprop="datePublished">2023-09-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c/">c++</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-C-程序结构"><a href="#1-C-程序结构" class="headerlink" title="1.C++程序结构"></a>1.C++程序结构</h1><h2 id="1-1-C-程序的基本组成部分"><a href="#1-1-C-程序的基本组成部分" class="headerlink" title="1.1 C++程序的基本组成部分"></a>1.1 C++程序的基本组成部分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> favorites_num;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入0~10中你最喜欢的数字: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; favorites_num;</span><br><span class="line">    std::cout &lt;&lt; favorites_num &lt;&lt; <span class="string">&quot;也是我喜欢的数字！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标识符(identifiers)：</p>
<p>​	main favorites_num  cout cin</p>
<p>操作符(operators)：</p>
<p>​	&lt;&lt;    &gt;&gt; </p>
<p>标点(punctuation：</p>
<p>​	；}</p>
<h2 id="1-2-预处理指令-Preprocessor-Directives"><a href="#1-2-预处理指令-Preprocessor-Directives" class="headerlink" title="1.2 预处理指令(Preprocessor Directives)"></a>1.2 预处理指令(Preprocessor Directives)</h2><ul>
<li>它指示编译器在实际编译开始之前预处理信息·以#开头，不以分号(;)结尾</li>
<li>并不理解C++语法</li>
</ul>
<h2 id="1-3-注释"><a href="#1-3-注释" class="headerlink" title="1.3 注释"></a>1.3 注释</h2><p>​	跟C相同，双斜杠的单行注释和、&#x2F;**&#x2F;多行注释</p>
<h2 id="1-4-main函数"><a href="#1-4-main函数" class="headerlink" title="1.4 main函数"></a>1.4 main函数</h2><p>​	例程1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>#include &lt;iostream&gt;</code>：这是一个预处理指令，用于包含输入输出流库（iostream），以便在程序中使用输入输出功能。</li>
<li><code>using namespace std;</code>：这是一个命名空间的声明，使用了<code>std</code>命名空间。命名空间<code>std</code>包含了C++标准库的函数和对象，使我们可以直接使用其中的成员，而无需在每个标识符前添加<code>std::</code>前缀。</li>
<li><code>int main()</code>：这是程序的主函数，也是程序的入口点。在C++中，每个程序都必须有一个<code>main</code>函数作为程序的起点。</li>
<li><code>&#123;</code> 和 <code>&#125;</code>：这对花括号之间的代码块是<code>main</code>函数的主体，包含了程序要执行的代码。</li>
<li><code>cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;</code>：这是一个输出语句，使用了<code>cout</code>对象，它是标准输出流。<code>&lt;&lt;</code>是输出运算符，用于将字符串常量”hello world”输出到控制台。<code>endl</code>是一个特殊的输出控制符，表示换行。</li>
</ol>
<p>例程2：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//argc表示参数数量，argc表示输入的参数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;参数数量&quot;</span> &lt;&lt; argc &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;参数名称&quot;</span> &lt;&lt; argv &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	 </p>
<h2 id="1-5-命名空间namespace"><a href="#1-5-命名空间namespace" class="headerlink" title="1.5 命名空间namespace"></a>1.5 命名空间namespace</h2><p>在C++中，命名空间是一种用来组织程序中的标识符（例如变量名、函数名、类名等）的机制。命名空间可以避免标识符之间的名称冲突，使得不同库、模块或代码段中的标识符可以拥有相同的名称而不会发生冲突。</p>
<p><code>std</code> 是C++标准库中的命名空间，包含了大量的标准函数和类型定义。例如，<code>std::cout</code> 是用于标准输出的对象，<code>std::cin</code> 是用于标准输入的对象，<code>std::string</code> 是用于处理字符串的类，<code>std::vector</code> 是用于动态数组的类等等。这些标准库的功能都封装在 <code>std</code> 命名空间中。</p>
<p>使用 <code>using namespace std;</code> 声明后，就可以在代码中直接使用 <code>std</code> 命名空间中的成员，而无需在每个标识符前添加 <code>std::</code> 前缀。例如，可以直接使用 <code>cout</code> 来表示 <code>std::cout</code>，使用 <code>endl</code> 来表示 <code>std::endl</code>，以及使用 <code>string</code> 来表示 <code>std::string</code> 等等。</p>
<p>需要注意的是，尽管 <code>using namespace std;</code> 可以简化代码，但也可能引发命名冲突问题。如果程序中使用了不同命名空间中具有相同名称的标识符，可能会导致编译错误或意想不到的行为。因此，在大型项目中或与其他库进行交互时，最好明确指定使用的命名空间，而不是使用 <code>using namespace</code> 全局声明。</p>
<h1 id="2-C-变量和常量"><a href="#2-C-变量和常量" class="headerlink" title="2. C++变量和常量"></a>2. C++变量和常量</h1><h2 id="2-1-变量-variable"><a href="#2-1-变量-variable" class="headerlink" title="2.1 变量(variable)"></a>2.1 变量(variable)</h2><p>变量是内存地址的抽象变量有2个重要的属性:<br>Type:变量类型( integer、real nurber、string、Student)<br>Value:变量值(1,3.14,”computer”)</p>
<h2 id="2-2-基本类型-primitive-types"><a href="#2-2-基本类型-primitive-types" class="headerlink" title="2.2 基本类型(primitive types)"></a>2.2 基本类型(primitive types)</h2><p>示例3：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;参数a=&quot;</span> &lt;&lt; a &lt;&lt; endl;	  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	上述示例运行打印为 a&#x3D;0，最好设置初值</p>
<p>示例4：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> width = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入房间宽度&quot;</span>;	  </span><br><span class="line">    cin &gt;&gt; width;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入房间长度&quot;</span>;	  </span><br><span class="line">    cin &gt;&gt; length;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;房间的面积为&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; width * length &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符型-character-char"><a href="#字符型-character-char" class="headerlink" title="字符型(character) : char"></a>字符型(character) : char</h3><p>作用︰用于表示单个字符，如I@’,’a’,’X’<br>只占用1个字节<br>语法:char c &#x3D;(a;<br>&#x3D;&#x3D;注意&#x3D;&#x3D;:<br>需要和字符串区分开，用单引号不是双引号<br>存储的是字符的ASCIl编码，而不是字符本身</p>
<h3 id="整型-integer-short、int、long、long-long"><a href="#整型-integer-short、int、long、long-long" class="headerlink" title="整型(integer) : short、int、long、long long"></a>整型(integer) : short、int、long、long long</h3><h3 id="浮点型-floating-point-float、double"><a href="#浮点型-floating-point-float、double" class="headerlink" title="浮点型(floating point) : float、double"></a>浮点型(floating point) : float、double</h3><h3 id="布尔型-Boolean-bool"><a href="#布尔型-Boolean-bool" class="headerlink" title="布尔型(Boolean) : bool"></a>布尔型(Boolean) : bool</h3><p>示例5</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a = &#123;<span class="string">&#x27;j&#x27;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符型参数a的值=&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符型参数a的ascll=&quot;</span> &lt;&lt; <span class="built_in">int</span>(a) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// short取值范围和溢出</span></span><br><span class="line">    <span class="type">short</span> overflow_num_1 = <span class="number">32768</span>;    <span class="comment">// 不会报错，但是值会溢出</span></span><br><span class="line">    <span class="type">short</span> overflow_num_2 &#123;<span class="number">32768</span>&#125;;    <span class="comment">// 会报错</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;短整型溢出：&quot;</span> &lt;&lt; overflow_num_1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;短整型溢出：&quot;</span> &lt;&lt; overflow_num_2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	&#x3D;&#x3D;注意&#x3D;&#x3D;:一般人们都是使用等于号进行赋值，但是对于一些超出范围的情况，编译器并不会报错，但是使用{}花括号的情况就会报错，所以建议大家之后使用花括号进行赋值.</p>
<h2 id="2-3-sizeof和climits"><a href="#2-3-sizeof和climits" class="headerlink" title="2.3 sizeof和climits"></a>2.3 sizeof和climits</h2><p>sizeof(int), &#x2F;&#x2F;确定int占用空间<br>sizeof(double), &#x2F;&#x2F;确定double占用空间<br>sizeof(变量名), &#x2F;&#x2F;确定具体某个变量占用空间<br>sizeof 变量名, &#x2F;&#x2F;不用括号</p>
<p>示例6：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a = &#123;<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符型变量a的大小为&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;整形变量b的大小为&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-4-常量-constant"><a href="#2-4-常量-constant" class="headerlink" title="2.4 常量(constant)"></a>2.4 常量(constant)</h2><p>作用:记录不可更改的数据，防止变量误修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理器定义</span></span><br><span class="line"><span class="comment">// 在老版本的C++中常用，现在不建议使用（预处理器不认识C++代码，不会做类型检查等工作)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pi 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const修饰方法</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> months = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pi = 3.5; 常量不可以再变更值，否则编译器会报错</span></span><br></pre></td></tr></table></figure>

<p>示例7：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> PI &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length &#123;<span class="number">10</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的面积为&quot;</span> &lt;&lt; length * length * PI &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-C-数组和容器"><a href="#3-C-数组和容器" class="headerlink" title="3. C++数组和容器"></a>3. C++数组和容器</h1><h2 id="3-1-数组"><a href="#3-1-数组" class="headerlink" title="3.1 数组"></a>3.1 数组</h2><p>·数组所有元素都是同一个数据类型。每个元素可以单独读取。</p>
<p>数组的特点：</p>
<ul>
<li>长度大小固定，且不可以再修改</li>
<li>所有元素是同一类型</li>
<li>元素在内存中是连续存储的</li>
<li>声明array时，内存中会分配一块区域来存储</li>
<li>可以使用存储的索引位置来获取元素（从0开始，最后一个元素索引为size -1)</li>
<li>不检查是否超出区域（超出长度获取元素可能会报错)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int student_scores[5] = &#123;92, 78, 100, 86, 65&#125;;  // 所有元素初始化</span><br><span class="line">int ages[10] = &#123;19, 23&#125;;                      // 前两个元素初始化对应值，其他元素为0</span><br><span class="line">const int days_in_year = 365;</span><br><span class="line">double hi_temperatures[days_in_year] = &#123;0&#125;;   // 所有元素初始化为0</span><br><span class="line">int another_array[] = &#123;1, 2, 3, 4, 5, 6&#125;;      // 数组大小自动计算</span><br></pre></td></tr></table></figure>

<p>​	数组如果只是定义，他是没有初值的最好在创建的过程中就加入初值。、只有加入一个初值，其他没赋予的值也会有，只是为0 </p>
<p>示例8：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> a[] &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[] &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a数组的第五个值为&quot;</span> &lt;&lt; a[<span class="number">4</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b数组名打印&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-容器"><a href="#3-2-容器" class="headerlink" title="3.2 容器"></a>3.2 容器</h2><p>假设需要存储整个学校所有学生的考试成绩无法知道具体的学生数量<br>解决办法:</p>
<ul>
<li><p>使用数组，数组大小设置的足够大</p>
</li>
<li><p>使用vector动态数组</p>
</li>
</ul>
<p>&#x3D;&#x3D;容器的特点&#x3D;&#x3D;：</p>
<ul>
<li><p>C++标准模板库STL中的容器(container)</p>
</li>
<li><p>长度大小可以随时缩放</p>
</li>
<li><p>和数组类似的语法用法</p>
</li>
<li><p>高性能越界检查</p>
</li>
<li><p>很多有用的函数:sort, reverrse, find等</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">vowels</span><span class="params">(<span class="number">5</span>)</span></span>;             <span class="comment">// 构造函数初始化方法，需要五个位置</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">student_scores</span><span class="params">(<span class="number">10</span>)</span></span>;     <span class="comment">// 大小为10，这10个数字会自动初始化为0</span></span><br></pre></td></tr></table></figure>

<p>赋予初值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">char</span>&gt; vowels &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; student_scores &#123;<span class="number">100</span>, <span class="number">99</span>, <span class="number">98</span>, <span class="number">97</span>, <span class="number">96</span>&#125;;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">hi_temperatures</span><span class="params">(<span class="number">365</span>, <span class="number">37.0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​	这里有些区别，第一个使用的是花括号进行的初值赋予，第二个跟第一个相同，但是第三个使用的是圆括号来进行的，第一个参数为365表示将会有365个元素，第二个参数为初始值，表示这365个元素都会被初始化为37.0</p>
<p>​	.at获取</p>
<p>​	.pushback进行追加</p>
<p>示例 9：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; vowel &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; vowel.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt;endl;</span><br><span class="line">    vowel.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; vowel.<span class="built_in">at</span>(<span class="number">5</span>) &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	需要注意的是上面的vector和&lt;类型&gt;必须连在一起，否则会报错。</p>
<p>​	容器的获取方式跟数组的获取方式相同，但也可以有更多的方式</p>
<h1 id="4-C-程序流程"><a href="#4-C-程序流程" class="headerlink" title="4. C++程序流程"></a>4. C++程序流程</h1><h2 id="4-1-if"><a href="#4-1-if" class="headerlink" title="4.1 if"></a>4.1 if</h2><p>示例 10：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lower_limit &#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> upper_limit &#123;<span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> input_num;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入一个介于&quot;</span> &lt;&lt; lower_limit &lt;&lt; <span class="string">&quot;和&quot;</span> &lt;&lt; upper_limit &lt;&lt; <span class="string">&quot;之间的整数：&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cin &gt;&gt; input_num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (input_num &gt;= lower_limit) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;===条件一满足===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; input_num &lt;&lt; <span class="string">&quot;大于等于&quot;</span> &lt;&lt; lower_limit &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; input_num &lt;&lt; <span class="string">&quot;比&quot;</span> &lt;&lt; lower_limit &lt;&lt; <span class="string">&quot;大&quot;</span> &lt;&lt; (input_num - lower_limit) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (input_num &lt;= upper_limit) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;===条件二满足===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; input_num &lt;&lt; <span class="string">&quot;小于等于&quot;</span> &lt;&lt; upper_limit &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; input_num &lt;&lt; <span class="string">&quot;比&quot;</span> &lt;&lt; upper_limit &lt;&lt; <span class="string">&quot;小&quot;</span> &lt;&lt; (upper_limit - input_num) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (input_num &gt; lower_limit &amp;&amp; input_num &lt; upper_limit) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;===条件三满足===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; input_num &lt;&lt; <span class="string">&quot;介于&quot;</span> &lt;&lt; lower_limit &lt;&lt; <span class="string">&quot;和&quot;</span> &lt;&lt; upper_limit &lt;&lt; <span class="string">&quot;之间&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-switch"><a href="#4-2-switch" class="headerlink" title="4.2 switch"></a>4.2 switch</h2><p>示例 11：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char input_grade = &#x27;0&#x27;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;请输入你的成绩：&quot;;</span><br><span class="line">    std::cin &gt;&gt; input_grade;</span><br><span class="line"></span><br><span class="line">    switch (input_grade)</span><br><span class="line">    &#123;</span><br><span class="line">        case &#x27;a&#x27;:</span><br><span class="line">        case &#x27;A&#x27;:</span><br><span class="line">            std::cout &lt;&lt; &quot;优秀&quot; &lt;&lt; std::endl;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;b&#x27;:</span><br><span class="line">        case &#x27;B&#x27;:</span><br><span class="line">            std::cout &lt;&lt; &quot;良好&quot; &lt;&lt; std::endl;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;c&#x27;:</span><br><span class="line">        case &#x27;C&#x27;:</span><br><span class="line">            std::cout &lt;&lt; &quot;中等&quot; &lt;&lt; std::endl;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-3循环-for、while、do-while"><a href="#4-3循环-for、while、do-while" class="headerlink" title="4.3循环: for、while、do-while"></a>4.3循环: for、while、do-while</h2><p>示例 11：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 简单的 for 循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次 i 增加 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面这种最简单的方式，for也支持基于范围的循环，类似于python：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> scores [ ] &#123;<span class="number">100</span>,<span class="number">99</span>,<span class="number">98</span>&#125; ;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> score: scores)</span><br><span class="line">	cout&lt;&lt; score &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>有时确定范围比较困难，所以可以使用auto这个类型，可以帮我们自动确认类型</p>
<p>while和do while就不重复了，还是很简单的</p>
<h1 id="5-C-字符和字符串"><a href="#5-C-字符和字符串" class="headerlink" title="5. C++字符和字符串"></a>5. C++字符和字符串</h1><h2 id="5-1C风格字符串"><a href="#5-1C风格字符串" class="headerlink" title="5.1C风格字符串"></a>5.1C风格字符串</h2><p>示例 12：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> first_name[<span class="number">20</span>] &#123;&#125;;</span><br><span class="line">    <span class="type">char</span> last_name[<span class="number">20</span>] &#123;&#125;;</span><br><span class="line">    <span class="type">char</span> full_name[<span class="number">50</span>] &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">50</span>] &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入你的姓：&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; first_name;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入你的名：&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; last_name;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;===============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;您的姓：&quot;</span> &lt;&lt; first_name &lt;&lt; <span class="string">&quot;，一共有&quot;</span> &lt;&lt; <span class="built_in">strlen</span>(first_name) &lt;&lt; <span class="string">&quot;个字符&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;您的名：&quot;</span> &lt;&lt; last_name &lt;&lt; <span class="string">&quot;，一共有&quot;</span> &lt;&lt; <span class="built_in">strlen</span>(last_name) &lt;&lt; <span class="string">&quot;个字符&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-2-C-风格字符串"><a href="#5-2-C-风格字符串" class="headerlink" title="5.2 C++风格字符串"></a>5.2 C++风格字符串</h2><ul>
<li><p>STL中一个类</p>
</li>
<li><p>使用前必须要导入#include <string></p>
</li>
<li><p>std namespace</p>
</li>
<li><p>内存中连续，动态大小</p>
</li>
<li><p>可转c-style字符串相互转化</p>
</li>
<li><p>更安全</p>
<p>示例 13：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string sl; <span class="comment">// 全部初始化为空</span></span><br><span class="line">    std::string s2 &#123; <span class="string">&quot;hello&quot;</span> &#125;; <span class="comment">// 初始化为 &quot;hello&quot;</span></span><br><span class="line">    std::string s3 &#123; s2 &#125;; <span class="comment">// 拷贝 s2</span></span><br><span class="line">    std::string s4 &#123; s3, <span class="number">0</span>, <span class="number">4</span> &#125;; <span class="comment">// 拷贝 s3 的前4个字符：&quot;hell&quot;</span></span><br><span class="line">    std::string s5 &#123; <span class="string">&quot;hello&quot;</span>, <span class="number">3</span> &#125;; <span class="comment">// 拷贝 &quot;hello&quot; 的前3个字符：&quot;hel&quot;</span></span><br><span class="line">    <span class="function">std::string <span class="title">s6</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>; <span class="comment">// 5个 &#x27;x&#x27;：&quot;xxxxx&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	c++字符串可以直接赋值，根据他的参数的数量可以划分不同的重定向函数</p>
<p>拼接</p>
<p>示例 14：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string part1 &#123; <span class="string">&quot;C++&quot;</span> &#125;;</span><br><span class="line">    std::string part2 &#123; <span class="string">&quot;是一门强大的&quot;</span> &#125;;</span><br><span class="line">    std::string sentence;</span><br><span class="line"></span><br><span class="line">    sentence = part1 + <span class="string">&quot; &quot;</span> + part2 + <span class="string">&quot;语言&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; sentence &lt;&lt; std::endl; <span class="comment">// 输出: C++ 是一门强大的语言</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sentence = &quot;C+++&quot; 是一门强大的语言&quot;; // 错误，不能将两个C风格字符串字面量相加</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/11/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/13/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="热爱学习的未来酱"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>