<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="永远年轻，永远热泪盈眶" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 热爱学习的未来酱</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="热爱学习的未来酱" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/1.png" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">热爱学习的未来酱</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['我希望用一生的时间不断学习和深入电子计算机相关的一切知识，并将其整理成网络，分享出来，与更多志同道合的朋友一起进步', '无论你最终要成为一个怎样的人，千万要记住，时间在飞逝。', ''],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  <article class="articles">
    
    
    
    
    <article
  id="post-01_反思/35_反思 (24年1月及之前)"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/01/31/01_%E5%8F%8D%E6%80%9D/35_%E5%8F%8D%E6%80%9D%20(24%E5%B9%B41%E6%9C%88%E5%8F%8A%E4%B9%8B%E5%89%8D)/"
    >反思(24年1月及之前)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/01/31/01_%E5%8F%8D%E6%80%9D/35_%E5%8F%8D%E6%80%9D%20(24%E5%B9%B41%E6%9C%88%E5%8F%8A%E4%B9%8B%E5%89%8D)/" class="article-date">
  <time datetime="2024-01-31T13:26:56.000Z" itemprop="datePublished">2024-01-31</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E6%B4%BB/">生活</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  Here's something encrypted, password is required to continue reading. 
      <a class="article-more-link" href="/2024/01/31/01_%E5%8F%8D%E6%80%9D/35_%E5%8F%8D%E6%80%9D%20(24%E5%B9%B41%E6%9C%88%E5%8F%8A%E4%B9%8B%E5%89%8D)/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-03_学习/31 Linux基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/01/30/03_%E5%AD%A6%E4%B9%A0/31%20Linux%E5%9F%BA%E7%A1%80/"
    >Linux基础</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/01/30/03_%E5%AD%A6%E4%B9%A0/31%20Linux%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2024-01-30T13:57:19.000Z" itemprop="datePublished">2024-01-30</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>==我希望用一生的时间不断学习和深入电子计算机相关的一切知识，并将其整理成网络，并分享出去，与更多志同道合的人共同进步==</p>
<p>==无论你最终要成为一个怎样的人，蛋清千万记住，时光在飞逝==</p>
<h1 id="linux-目录结构"><a class="markdownIt-Anchor" href="#linux-目录结构"></a> Linux 目录结构</h1>
<h2 id="11-linux目录结构"><a class="markdownIt-Anchor" href="#11-linux目录结构"></a> 1.1 Linux目录结构</h2>
<p>​	在Linux系统中，文件系统采用了树型结构，以一个称为根目录的起始点开始，所有文件和目录都位于根目录之下。根目录在Linux中表示为<code>/</code>（斜线），是整个文件系统的顶级目录。从根目录向下，可以创建更多的目录和文件，形成一个层次结构。</p>
<p>​	在Windows系统中，每个逻辑驱动器通常会被分配一个盘符，如C盘、D盘、E盘等。每个盘符可以拥有自己的根目录和文件系统。这使得在Windows系统中可以直接访问不同的逻辑驱动器，并且它们之间是相互独立的。</p>
<h2 id="12-linux路径描述方式"><a class="markdownIt-Anchor" href="#12-linux路径描述方式"></a> 1.2 Linux路径描述方式</h2>
<p>​	在Linux系统中，路径之间的层级关系使用斜线（/）来表示。例如，<code>/home/user/Documents</code> 表示位于根目录下的 <code>home</code> 目录中的 <code>user</code> 目录中的 <code>Documents</code> 目录。</p>
<p>在Windows系统中，路径之间的层级关系使用反斜线（\）来表示。例如，<code>C:\Users\Username\Documents</code> 表示位于 C 盘下的 <code>Users</code> 目录中的 <code>Username</code> 目录中的 <code>Documents</code> 目录。</p>
<p>在Linux系统中，斜线（/）具有以下含义：</p>
<ol>
<li>根目录：当斜线（/）出现在路径的开头时，表示根目录。根目录是整个文件系统的顶级目录，是文件系统的起点。所有其他目录和文件都位于根目录之下。例如，<code>/home/user/Documents</code> 表示位于根目录的 <code>home</code> 目录中的 <code>user</code> 目录中的 <code>Documents</code> 目录。</li>
<li>层次关系：当斜线（/）出现在路径的中间或末尾时，表示路径中不同层级之间的关系。斜线用于分隔不同的目录或文件名，并表示它们之间的层次关系。例如，<code>/home/user/Documents</code> 中的斜线表示 <code>home</code> 目录位于根目录下，<code>user</code> 目录位于 <code>home</code> 目录下，<code>Documents</code> 目录位于 <code>user</code> 目录下。</li>
</ol>
<h1 id="相对路径绝对路径"><a class="markdownIt-Anchor" href="#相对路径绝对路径"></a> 相对路径绝对路径</h1>
<p>绝对路径是一种路径写法，它以根目录作为起点来描述文件或目录的位置。绝对路径始终以斜线（/）开头。通过绝对路径，您可以准确地指定文件或目录在文件系统中的位置，不受当前工作目录的影响。例如，<code>/home/user/Documents/file.txt</code> 是一个绝对路径，它从根目录开始，描述了文件 <code>file.txt</code> 在 <code>Documents</code> 目录中的位置。</p>
<p>相对路径是另一种路径写法，它以当前工作目录为起点来描述文件或目录的位置。相对路径不以斜线开头，而是从当前工作目录开始描述路径的层级关系。相对路径的解析依赖于当前工作目录的位置。例如，如果当前工作目录是 <code>/home/user</code>，那么相对路径 <code>Documents/file.txt</code> 表示文件 <code>file.txt</code> 在 <code>Documents</code> 目录中的位置，而该目录位于当前工作目录下的 <code>user</code> 目录中。</p>
<p>相对路径的优势在于更加简洁，不需要显式地指定根目录。它适用于当前工作目录已知的情况，并且可以相对于当前位置快速定位文件或目录。</p>
<p>总结起来，绝对路径以根目录为起点，以斜线开头来描述文件或目录的位置。相对路径以当前工作目录为起点，不以斜线开头来描述文件或目录的位置，路径描述相对于当前位置。</p>
<h1 id="特殊路径符"><a class="markdownIt-Anchor" href="#特殊路径符"></a> 特殊路径符</h1>
<ol>
<li>
<p><code>.</code> （点）：表示当前目录。使用单个点表示当前所在的目录。例如，<code>./file.txt</code> 表示当前目录下的文件 <code>file.txt</code>。</p>
</li>
<li>
<p><code>..</code> （点点）：表示上一级目录。使用两个点表示当前目录的父目录。例如，<code>../dir/file.txt</code> 表示当前目录的上一级目录中的 <code>dir</code> 目录下的文件 <code>file.txt</code>。</p>
</li>
<li>
<p><code>~</code> （波浪线）：表示当前用户的主目录。波浪线后面可以跟其他路径来表示主目录下的子目录或文件。例如，<code>~/Documents</code> 表示当前用户主目录下的 <code>Documents</code> 目录。</p>
</li>
<li>
<p><code>/</code> （斜线）：表示根目录。根目录是整个文件系统的顶级目录。以斜线开头的路径表示从根目录开始的绝对路径。例如，<code>/usr/bin</code> 表示根目录下的 <code>usr</code> 目录中的 <code>bin</code> 目录。</p>
</li>
<li>
<p><code>-</code> （短横线）：表示前一个工作目录。使用短横线可以回到上一个工作目录。这在需要快速切换目录时很有用。</p>
<h1 id="普通用户和系统管理员用户"><a class="markdownIt-Anchor" href="#普通用户和系统管理员用户"></a> 普通用户和系统管理员用户</h1>
<ol>
<li>
<p>在 Linux 系统中，root 用户和普通用户是两种不同的用户身份。下面详细讲解它们的区别和特点：</p>
<ol>
<li>Root 用户：
<ul>
<li>超级用户：root 用户是系统的超级用户，也称为管理员用户。它拥有系统中的最高权限，可以执行所有操作，包括修改系统配置、安装软件、管理用户和文件等。</li>
<li>UID 和 GID：root 用户的用户标识号（UID）和组标识号（GID）都为 0。</li>
<li>根目录：root 用户的主目录为根目录（/），在大多数 Linux 发行版中，其主目录路径为 “/root”。</li>
<li>安全性注意：由于 root 用户具有最高权限，使用 root 用户时需要谨慎操作。推荐使用 sudo 命令以普通用户身份执行需要特权的任务，以提高系统安全性。</li>
<li>特权访问：root 用户可以直接登录系统，或通过其他用户登录后切换到 root 用户。默认情况下，远程登录方式禁止直接使用 root 用户登录。</li>
</ul>
</li>
<li>普通用户：
<ul>
<li>一般权限：普通用户是系统中除 root 用户以外的用户。它们具有有限的权限，并受到权限限制，无法执行对系统关键部分的修改和访问。</li>
<li>UID 和 GID：普通用户具有非零的用户标识号（UID）和组标识号（GID），用于唯一标识用户和分配权限。</li>
<li>主目录：每个普通用户都有一个主目录，用于存储其个人文件和配置。主目录的路径通常是 “/home/username”，其中 “username” 是用户的用户名。</li>
<li>限制：普通用户受到许多权限限制，例如无法修改系统配置、安装软件包或访问其他用户的私有文件等。这些限制增加了系统的安全性，防止误操作和恶意行为。</li>
</ul>
</li>
</ol>
<p>总结起来，root 用户是系统的超级用户，具有最高权限和特权，能够执行所有操作。普通用户是系统中的常规用户，受到权限限制，无法执行对系统关键部分的修改和访问。使用 root 用户需要谨慎，而普通用户则更适合日常任务和常规操作，以增加系统安全性。</p>
<h1 id="su和exit"><a class="markdownIt-Anchor" href="#su和exit"></a> su和exit</h1>
</li>
</ol>
</li>
</ol>
<p>su命令是用于在 Linux 系统中切换用户的命令，它允许当前用户切换到其他用户账户，包括 root 用户。而exit命令用于退出当前用户的登录会话。</p>
<p>以下是对su命令和exit命令的详细解释：</p>
<ol>
<li>su命令：
<ul>
<li>语法：su [-] [用户名]</li>
<li>
<ul>
<li>符号是可选的，表示是否在切换用户后加载目标用户的环境变量。如果使用 - 符号，会加载目标用户的环境变量，包括其配置文件（如 .bashrc）中定义的环境变量。如果不使用 - 符号，则不会加载环境变量。</li>
</ul>
</li>
<li>用户名参数是要切换到的目标用户的用户名。如果省略用户名，su 命令默认切换到 root 用户。</li>
<li>在切换用户时，如果当前用户不是 root 用户，通常需要输入目标用户的密码。只有在当前用户是 root 用户时，才可以直接切换到其他用户而无需密码。</li>
</ul>
</li>
<li>exit命令：
<ul>
<li>exit命令用于退出当前用户的登录会话或终端窗口。</li>
<li>当使用 su 命令切换到其他用户时，可以使用 exit 命令返回到之前的用户。执行 exit 命令后，会关闭当前用户的登录会话或终端窗口，并回到上一个用户的会话或窗口。</li>
<li>另外，可以使用快捷键 Ctrl + D 来执行与 exit 命令相同的操作，即退出当前用户的登录会话。</li>
</ul>
</li>
</ol>
<p>需要注意的是，su 命令和 exit 命令都需要在命令行中使用，而不是在图形界面中使用。su 命令要求输入目标用户的密码，而 exit 命令不需要任何参数，直接执行即可退出当前用户的登录会话。这些命令在管理 Linux 系统时非常有用，可以在不同的用户之间切换，以便执行特定的任务和操作。</p>
<h1 id="sudo命令"><a class="markdownIt-Anchor" href="#sudo命令"></a> sudo命令</h1>
<p>sudo命令是在 Linux 系统中用于临时以 root 身份执行命令的工具。它允许普通用户在执行需要特权的操作时，临时获取 root 用户的权限，而无需切换到 root 用户。</p>
<p>以下是对sudo命令的详细解释：</p>
<ol>
<li>语法：sudo 其他命令
<ul>
<li>其他命令是要以 root 权限执行的实际命令。在其他命令之前添加 sudo 前缀，即可为该命令临时赋予 root 用户的权限。</li>
<li>举例来说，如果要以 root 权限安装软件包，可以使用命令 sudo apt install package-name。</li>
</ul>
</li>
<li>配置 sudo 认证：
<ul>
<li>并非所有用户都有权使用 sudo 命令。在 Linux 系统中，需要配置 sudo 来授权普通用户使用该命令。</li>
<li>在配置 sudo 时，可以为特定的用户或用户组分配 sudo 认证。</li>
<li>sudo 配置文件位于 /etc/sudoers，可以使用 visudo 命令来编辑该文件，visudo 命令会检查 sudoers 文件的语法错误。</li>
<li>在 sudoers 文件中，可以使用特定的语法为用户或用户组添加授权，例如：
<ul>
<li>user1 ALL=(ALL) ALL：为 user1 用户授予所有命令的 sudo 权限。</li>
<li>%group1 ALL=(ALL) ALL：为 group1 用户组授予所有命令的 sudo 权限。</li>
</ul>
</li>
</ul>
</li>
<li>sudo 命令的工作方式：
<ul>
<li>当用户使用 sudo 执行命令时，系统会要求用户输入自己的密码进行身份验证。这是为了确保执行特权操作的用户是经过授权的。</li>
<li>默认情况下，sudo 会在一段时间内缓存用户的密码，以便在此期间内执行多次 sudo 命令时无需重复输入密码。</li>
<li>sudo 还提供了一些选项，例如：
<ul>
<li>-i：以 root 用户的身份登录并获取 root 用户的环境变量。</li>
<li>-u user：以指定用户的身份执行命令。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="查看-linux-文件的权限管控信息"><a class="markdownIt-Anchor" href="#查看-linux-文件的权限管控信息"></a> 查看 Linux 文件的权限管控信息</h1>
<p>​	在 Linux 系统中，可以使用 ls 命令结合选项来查看文件的权限管控信息。ls 命令用于列出目录中的文件和子目录，并显示其相关属性。</p>
<ul>
<li>语法：ls -l [文件或目录]</li>
<li>-l 选项指示 ls 命令以长格式显示文件信息，包括权限、所有者、组、大小、时间戳等。</li>
<li>文件或目录参数是要查看权限信息的文件或目录的路径。如果省略该参数，默认为当前目录。</li>
</ul>
<p>输出结果中权限信息由 10 个字符组成，分别表示文件类型和文件权限。前三个字符表示所有者权限，接下来三个字符表示所属组权限，最后三个字符表示其他用户权限。</p>
<h1 id="读-写-执行三种权限的含义"><a class="markdownIt-Anchor" href="#读-写-执行三种权限的含义"></a> 读、写、执行三种权限的含义</h1>
<p>​	在 Linux 系统中，每个文件都有三种基本权限：读取权限、写入权限和执行权限。</p>
<ul>
<li>读取权限（r）：读取权限允许用户查看文件的内容。对于目录来说，读取权限允许用户列出目录中的文件和子目录。</li>
<li>写入权限（w）：写入权限允许用户修改文件的内容、重命名文件或删除文件。对于目录来说，写入权限允许用户在目录中创建、删除或重命名文件和子目录。</li>
<li>执行权限（x）：执行权限允许用户执行可执行文件、脚本或进入目录。</li>
</ul>
<p>权限字符的含义：</p>
<ul>
<li>r 表示读取权限，用数字 4 表示。</li>
<li>w 表示写入权限，用数字 2 表示。</li>
<li>x 表示执行权限，用数字 1 表示。</li>
<li>“-” 表示没有相应的权限。</li>
</ul>
<p>在权限字符的表示中，可以使用数字表示权限组合。例如，rwx 表示读取、写入和执行权限的组合，其数字表示为 7。r-x 表示具有读取和执行权限，但没有写入权限，其数字表示为 5。</p>
<p>通过对文件和目录设置适当的权限，可以实现对系统资源的安全管控。正确设置权限可以保护重要文件的机密性、完整性和可用性，并防止未经授权的访问和修改。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401312251927.png" alt="image-20240131225129893" /></p>
<ul>
<li>第一个字符（-、d、l）表示文件类型：
<ul>
<li>“-” 表示普通文件。</li>
<li>“d” 表示目录（文件夹）。</li>
<li>“l” 表示符号链接（软链接）。</li>
</ul>
</li>
<li>剩下的九个字符表示权限，按照权限分为三组：
<ol>
<li>所属用户权限（User）：
<ul>
<li>第一个字符表示所属用户对文件或目录的权限：
<ul>
<li>“r” 表示具有读取权限。</li>
<li>“-” 表示没有读取权限。</li>
</ul>
</li>
<li>第二个字符表示所属用户对文件或目录的写入权限：
<ul>
<li>“w” 表示具有写入权限。</li>
<li>“-” 表示没有写入权限。</li>
</ul>
</li>
<li>第三个字符表示所属用户对文件或目录的执行权限：
<ul>
<li>“x” 表示具有执行权限。</li>
<li>“-” 表示没有执行权限。</li>
</ul>
</li>
</ul>
</li>
<li>所属用户组权限（Group）：
<ul>
<li>第四个字符表示所属用户组对文件或目录的权限，含义与所属用户权限相同。</li>
<li>第五个字符表示所属用户组对文件或目录的写入权限。</li>
<li>第六个字符表示所属用户组对文件或目录的执行权限。</li>
</ul>
</li>
<li>其他用户权限（Other）：
<ul>
<li>第七个字符表示其他用户对文件或目录的权限。</li>
<li>第八个字符表示其他用户对文件或目录的写入权限。</li>
<li>第九个字符表示其他用户对文件或目录的执行权限。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>这种权限字符的排列顺序是：文件类型 + 所属用户权限 + 所属用户组权限 + 其他用户权限。</p>
<p>权限字符 “r”、“w” 和 “x” 分别表示读取、写入和执行权限。“-” 表示没有相应的权限。</p>
<p>通过读取这些权限字符，可以了解特定文件或目录对不同用户的访问权限。正确设置这些权限可以确保文件和目录的安全性和可访问性。</p>
<p>分享</p>
<p>rwx是UNIX和类UNIX系统中用于表示文件或目录权限的符号。它是由三个字符组成，分别代表读权限（r），写权限（w）和执行权限（x）。</p>
<ul>
<li>r（读权限）表示允许用户读取文件的内容或查看目录中的文件列表。对于文件来说，这意味着可以读取文件的内容；对于目录来说，这意味着可以列出目录中的文件。</li>
<li>w（写权限）表示允许用户修改文件的内容或在目录中创建、删除和重命名文件。对于文件来说，这意味着可以修改文件的内容；对于目录来说，这意味着可以在目录中进行写操作。</li>
<li>x（执行权限）表示允许用户执行文件或将工作目录更改为目录。对于文件来说，这意味着可以将文件作为可执行程序来运行；对于目录来说，这意味着可以进入该目录并在其中执行操作。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-03_学习/30_C语言补弱"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/01/24/03_%E5%AD%A6%E4%B9%A0/30_C%E8%AF%AD%E8%A8%80%E8%A1%A5%E5%BC%B1/"
    >C语言补弱</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/01/24/03_%E5%AD%A6%E4%B9%A0/30_C%E8%AF%AD%E8%A8%80%E8%A1%A5%E5%BC%B1/" class="article-date">
  <time datetime="2024-01-24T01:30:19.000Z" itemprop="datePublished">2024-01-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/C%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E5%AD%A6%E4%B9%A0/">C语言高级学习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>==我希望用一生的时间不断学习和深入电子计算机相关的一切知识，并将其整理成网络，并分享出去，与更多志同道合的人共同进步==</p>
<p>==无论你最终要成为一个怎样的人，蛋清千万记住，时光在飞逝==</p>
<h1 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h1>
<p>​</p>
<p><code>struct</code>是C语言中的关键字，用于定义自定义的数据类型，可以将多个不同类型的变量组合在一起形成一个结构体，从而创建一个包含多个成员的复合数据类型。</p>
<p>结构体的定义通常包括以下几个部分：</p>
<ol>
<li><code>struct</code>关键字：用于声明一个结构体类型。</li>
<li>结构体标签：用于标识结构体类型的名称，可以在定义时指定，也可以省略。</li>
<li>成员列表：定义结构体的成员，每个成员包括类型和名称。</li>
</ol>
<p>下面是一个简单的示例，展示了如何使用<code>struct</code>定义一个包含姓名和年龄的人员信息结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>struct</code>关键字用于定义一个名为<code>Person</code>的结构体类型。该结构体有两个成员：<code>name</code>和<code>age</code>，分别表示人员的姓名和年龄。</p>
<p>定义结构体后，就可以声明结构体变量并使用它们，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">person1</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">person2</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(person1.name, <span class="string">&quot;John Smith&quot;</span>);</span><br><span class="line">person1.age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Person 1: Name = %s, Age = %d\n&quot;</span>, person1.name, person1.age);</span><br><span class="line"></span><br><span class="line">person2 = person1;  <span class="comment">// 结构体变量之间可以进行赋值操作</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Person 2: Name = %s, Age = %d\n&quot;</span>, person2.name, person2.age);</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们声明了两个<code>Person</code>类型的结构体变量<code>person1</code>和<code>person2</code>。然后，我们使用<code>strcpy</code>函数将字符串&quot;John Smith&quot;复制到<code>person1</code>的<code>name</code>成员中，并将30赋值给<code>person1</code>的<code>age</code>成员。最后，我们打印了<code>person1</code>和<code>person2</code>的姓名和年龄。</p>
<p>结构体变量的成员可以通过<code>.</code>运算符来访问，即<code>结构体变量名.成员名</code>。可以像访问普通变量一样访问结构体变量的成员。</p>
<p>使用结构体可以更好地组织和管理相关数据，将多个相关的数据打包在一起，方便进行传递和处理。结构体还可以嵌套定义，允许在一个结构体中包含另一个结构体作为成员，从而形成更复杂的数据结构。</p>
<p>示例代码1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">person1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">person2</span>;</span></span><br><span class="line"></span><br><span class="line">    person1.name = <span class="string">&quot;John Smith&quot;</span>;</span><br><span class="line">    person1.age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Person 1: Name = %s, Age = %d\n&quot;</span>, person1.name, person1.age);</span><br><span class="line">    </span><br><span class="line">    person2 = person1;  <span class="comment">// 结构体变量之间可以进行赋值操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Person 2: Name = %s, Age = %d\n&quot;</span>, person2.name, person2.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题1：</p>
<p>​	上面结构体中的name用来存放一个人的名字，那请问为什么可以这样写，这样写为什么可以成立呢？</p>
<p>​	学习例程1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印为正常的字符：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401242202460.png" alt="image-20240124220211404" /></p>
<p>从上可以 得到，char类型定义的是单个字符，而事实上每个字符对应的都是相对应的数字罢了，可以看下面的学习示例</p>
<p>学习示例2：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> d = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %c\n&quot;</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d = %c\n&quot;</span>, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401242204555.png" alt="image-20240124220450510" /></p>
<p>​	这次看到了吧，其实不管是int 类型的还是char类型的，最终凭靠的还是对应的printf，这些都是无所谓的。那字符串是怎样的呢？</p>
<p>学习示例3：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> string1[<span class="number">50</span>] = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, string1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	这是一个最简单的字符串打印，实际上呢，字符串也就是一个一个字符的组合罢了，以\0结尾，字符串的大小为数组长度减一，然后看更详细的一个案例：</p>
<p>学习示例4：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> string1[<span class="number">50</span>] = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, string1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, string1[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, string1[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, string1[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, string1[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, string1[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, string1[<span class="number">5</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, string1[<span class="number">6</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, string1[<span class="number">7</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401242213481.png" alt="image-20240124221312434" /></p>
<p>​	同样的，这些也不外乎是一些对应的ascll码值而已，但那个char *的是怎样的呢，目前还是不懂。</p>
<p>示例代码4</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *<span class="built_in">string</span>;</span><br><span class="line">    <span class="built_in">string</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">string</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	这里的string是一个指针变量，它其实只是一个地址而已，而&quot;this is a string&quot;这个字符串实际上存储在了其他的区域，这里的赋值实际意义上是将这个字符串存储位置的首地址给了string，string本身也就是一个指针变量，指针变量就是专门用于存放数据地址的，现在我应该是懂了。</p>
<p>问题2：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person person1;</span><br><span class="line">Person person2;</span><br></pre></td></tr></table></figure>
<p>​	在上面的代码中不能直接这样来创建person1和person2这两个变量吗，答案是不能，对应的打印信息如下所示：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401242233006.png" alt="image-20240124223346726" />	在 C 语言中，结构体类型必须要使用 <code>struct</code> 关键字来定义，然后可以使用定义的结构体类型来创建相应的变量。</p>
<p>​	如果想上面那样子定义就需要用到结构体了，例如可以这样修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125; Person;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Person person1;</span><br><span class="line">    Person person2;</span><br><span class="line"></span><br><span class="line">    person1.name = <span class="string">&quot;John Smith&quot;</span>;</span><br><span class="line">    person1.age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Person 1: Name = %s, Age = %d\n&quot;</span>, person1.name, person1.age);</span><br><span class="line"></span><br><span class="line">    person2 = person1;  <span class="comment">// 结构体变量之间可以进行赋值操作</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Person 2: Name = %s, Age = %d\n&quot;</span>, person2.name, person2.age);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="typedef-别名"><a class="markdownIt-Anchor" href="#typedef-别名"></a> typedef 别名</h1>
<p><code>typedef</code> 是 C 语言中的一个关键字，用于为已有的数据类型创建新的别名。通过 <code>typedef</code>，我们可以为现有的数据类型赋予一个新的名称，以便在程序中更方便地使用。</p>
<p><code>typedef</code> 的语法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> &lt;existing_data_type&gt; &lt;new_alias&gt;;</span><br></pre></td></tr></table></figure>
<p>其中，<code>existing_data_type</code> 是现有的数据类型，可以是基本的数据类型（如 <code>int</code>、<code>float</code>、<code>char</code> 等）或自定义的数据类型（如结构体、枚举等），<code>new_alias</code> 是我们为该数据类型创建的新的别名。</p>
<p>使用 <code>typedef</code> 的主要优点是提高代码的可读性和可维护性。通过为数据类型创建别名，我们可以在代码中使用更具有描述性的名称，从而使代码更易于理解。</p>
<p>以下是一些 <code>typedef</code> 的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Integer;</span><br></pre></td></tr></table></figure>
<p>这个例子中，我们为 <code>int</code> 类型创建了一个新的别名 <code>Integer</code>。现在，我们可以使用 <code>Integer</code> 来定义整型变量，就像使用 <code>int</code> 一样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>另一个常见的应用是在定义结构体时使用 <code>typedef</code>，以便在创建结构体变量时不需要每次都加上 <code>struct</code> 关键字。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125; Person;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们为匿名的结构体类型创建了别名 <code>Person</code>。现在，我们可以直接使用 <code>Person</code> 来定义结构体变量，而不需要每次都写 <code>struct</code> 关键字：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person1;</span><br></pre></td></tr></table></figure>
<p><code>typedef</code> 还可以用于创建函数指针类型的别名，以简化复杂的函数指针声明。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*MathOperation)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们为接受两个整数参数并返回一个整数的函数指针类型创建了别名 <code>MathOperation</code>。现在，我们可以使用 <code>MathOperation</code> 来声明函数指针变量，而不需要每次都写出完整的函数指针声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MathOperation add;</span><br></pre></td></tr></table></figure>
<p>总结起来，<code>typedef</code> 允许我们为已有的数据类型创建新的别名，提高代码的可读性和可维护性。通过使用 <code>typedef</code>，我们可以在代码中使用更具有描述性的名称，使代码更易于理解和维护。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-03_学习/28_必剪"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/01/18/03_%E5%AD%A6%E4%B9%A0/28_%E5%BF%85%E5%89%AA/"
    >必剪学习</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/01/18/03_%E5%AD%A6%E4%B9%A0/28_%E5%BF%85%E5%89%AA/" class="article-date">
  <time datetime="2024-01-17T22:50:19.000Z" itemprop="datePublished">2024-01-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%AA%E8%BE%91/">剪辑</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1软件的下载和安装"><a class="markdownIt-Anchor" href="#1软件的下载和安装"></a> 1.软件的下载和安装</h1>
<p><a target="_blank" rel="noopener" href="https://bcut.bilibili.cn/">必剪</a></p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172022927.png" alt="image-20240117202232865" /></p>
<p>​	安装完成之后打开，具体如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172022957.png" alt="image-20240117202252915" /></p>
<p>​	至此，关于必剪的安装就完成了，然后开始进行下一个阶段的学习吧。</p>
<h1 id="2必剪使用流程"><a class="markdownIt-Anchor" href="#2必剪使用流程"></a> 2.必剪使用流程</h1>
<p>​	首先点击开始创作，具体如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172024874.png" alt="image-20240117202434830" /></p>
<p>​	点击之后如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172025359.png" alt="image-20240117202503291" /></p>
<h2 id="21-菜单栏"><a class="markdownIt-Anchor" href="#21-菜单栏"></a> 2.1 菜单栏</h2>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172025789.png" alt="image-20240117202540774" /></p>
<p>​	必剪的左上方有着三个菜单栏，分别是文件、剪辑和帮助，并且必剪可以自动保存，这一点就很好。</p>
<h2 id="22-功能栏"><a class="markdownIt-Anchor" href="#22-功能栏"></a> 2.2 功能栏</h2>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172035969.png" alt="image-20240117203550954" /></p>
<p>​	功能栏分为“本地素材”、“素材库”、“B站热梗”、“音频”、“文本”、“贴纸”、“特效”、“转场”、“一键三联”、“滤镜”、“调色”。</p>
<h3 id="221-本地素材"><a class="markdownIt-Anchor" href="#221-本地素材"></a> 2.2.1 本地素材</h3>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172038506.png" alt="image-20240117203849494" /></p>
<p>​		可以分别导入视频、图片、音频三个本地素材。</p>
<h3 id="222-素材库"><a class="markdownIt-Anchor" href="#222-素材库"></a> 2.2.2 素材库</h3>
<p>​	这里存放着的是一些有用的素材，如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172044566.png" alt="image-20240117204430534" /></p>
<p>​	可以在这里寻找一些有用的素材，一般情况下是用不到的。</p>
<h3 id="223-b站热梗"><a class="markdownIt-Anchor" href="#223-b站热梗"></a> 2.2.3 B站热梗</h3>
<p>​	一些好玩的B站热梗，不过一般情况下，我是用不到的。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172054582.png" alt="image-20240117205420559" /></p>
<h3 id="224-音频"><a class="markdownIt-Anchor" href="#224-音频"></a> 2.2.4 音频</h3>
<p>​	用来存放一些音频</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172054670.png" alt="image-20240117205437652" /></p>
<h3 id="225-文本"><a class="markdownIt-Anchor" href="#225-文本"></a> 2.2.5 文本</h3>
<p>​	这里可以添加一些文本，还可以自动识别字幕，如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172057058.png" alt="image-20240117205738043" /></p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172058678.png" alt="image-20240117205836568" /></p>
<p>​	如果出现了一些问题，也可以根据右边的字幕列表来修改字幕。</p>
<h3 id="226-贴纸"><a class="markdownIt-Anchor" href="#226-贴纸"></a> 2.2.6 贴纸</h3>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172100665.png" alt="image-20240117210014650" /></p>
<h3 id="227-特效"><a class="markdownIt-Anchor" href="#227-特效"></a> 2.2.7 特效</h3>
<p>​</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172100620.png" alt="image-20240117210050588" /></p>
<h3 id="228-转场"><a class="markdownIt-Anchor" href="#228-转场"></a> 2.2.8 转场</h3>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172101821.png" alt="image-20240117210141794" /></p>
<h3 id="229-一键三联"><a class="markdownIt-Anchor" href="#229-一键三联"></a> 2.2.9 一键三联</h3>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172103908.png" alt="image-20240117210357894" /></p>
<p>​	哈哈，我感觉这个可以有。</p>
<h3 id="2210-滤镜"><a class="markdownIt-Anchor" href="#2210-滤镜"></a> 2.2.10 滤镜</h3>
<p>​</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172104375.png" alt="image-20240117210424351" /></p>
<h3 id="2211-调色"><a class="markdownIt-Anchor" href="#2211-调色"></a> 2.2.11 调色</h3>
<p>​	这个无所谓了。</p>
<h2 id="23-时间线窗口"><a class="markdownIt-Anchor" href="#23-时间线窗口"></a> 2.3 时间线窗口</h2>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172105602.png" alt="image-20240117210536566" /></p>
<h2 id="24-素材属性调整"><a class="markdownIt-Anchor" href="#24-素材属性调整"></a> 2.4 素材属性调整</h2>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172114094.png" alt="image-20240117211406076" /></p>
<h2 id="25-快捷按键"><a class="markdownIt-Anchor" href="#25-快捷按键"></a> 2.5 快捷按键</h2>
<p>​	快速选择分割工具 C</p>
<p>​	快速选择工具V</p>
<p>​	分割状态下的单次分割为 X</p>
<p>​	放大轨道为 =</p>
<p>​	缩小隧道为 -</p>
<p>​	切换全屏 ctrl+`</p>
<h1 id="3进度条添加"><a class="markdownIt-Anchor" href="#3进度条添加"></a> 3.进度条添加</h1>
<p>白色和蓝色</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172146002.png" alt="image-20240117214656976" /></p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172151087.png" alt="image-20240117215111035" /></p>
<p>最终效果</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401172157895.png" alt="image-20240117215754864" /></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-03_学习/27 CPU里的C和C++"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/01/02/03_%E5%AD%A6%E4%B9%A0/27%20CPU%E9%87%8C%E7%9A%84C%E5%92%8CC++/"
    >计算机眼里的C和C++</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/01/02/03_%E5%AD%A6%E4%B9%A0/27%20CPU%E9%87%8C%E7%9A%84C%E5%92%8CC++/" class="article-date">
  <time datetime="2024-01-01T22:50:19.000Z" itemprop="datePublished">2024-01-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/C%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E5%AD%A6%E4%B9%A0/">C语言高级学习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>​		其实学完王老师的嵌入式C高级之后，我仍是有一些问题，但让我说具体是哪个地方抱歉我真的说不出来，而我在逛拼多多的时候，看到了这本书，也就是计算机里的C和C++，看目录倒是挺吸引我的，所以趁着晚上的时间学习一下。</p>
<h1 id="第一章-预备知识"><a class="markdownIt-Anchor" href="#第一章-预备知识"></a> 第一章 预备知识</h1>
<h2 id="11-工具介绍"><a class="markdownIt-Anchor" href="#11-工具介绍"></a> 1.1 工具介绍</h2>
<p><a target="_blank" rel="noopener" href="https://godbolt.org/">compiler explorer</a></p>
<p>​	我是第一次听说这个工具，但本书的作者却说这是一个很好的工具，可视化的进行汇编语言和高级语言的对比，从而更利于人们的理解。</p>
<p>代码1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	进入该网址之后，界面如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401022108917.png" alt="image-20240102210858840" /></p>
<p>​	通过颜色可以进行代码关系的匹配，左边是源代码，而右边是CPU指令，也可以通过修改右侧output options选项来查看机器码，也就是二进制的机器指令，如下图所示：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401022115284.png" alt="image-20240102211556230" />	除此之外，还支持切换不同的编译器，现在的编译器是X84-64架构的，也可以切换为arm或者aarch64相应的版本，具体如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401022119496.png" alt="image-20240102211912462" /></p>
<p>​	其余要注意的就不多了，先这样，有需要再回来学习。</p>
<h2 id="12-cpu眼里程序的运行"><a class="markdownIt-Anchor" href="#12-cpu眼里程序的运行"></a> 1.2 CPU眼里程序的运行</h2>
<p>​	代码2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[] = <span class="string">&quot;password&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> *c = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    *c = <span class="number">0x11223344</span>;</span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">&quot;%p %p %p %p\n&quot;</span>, &amp;a, &amp;b, &amp;c, main);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	在上面的示例中，定义了一个全局变量a，定义了一个局部变量b，然后申请了一段内存，并赋值为0x11223344，最后分别打印了a、b、c和main函数的内存地址，执行结果如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401022136235.png" alt="image-20240102213640112" /></p>
<p>​	内存地址由低到高分别存放这main函数的CPU指令，我们称之为代码段，随后的内存区域存放着全局变量a的值，我们称这个区域为数据段，经过更长的一段距离之后，来到.heap内存区域，在程序运行起来之后，会存储数值0x11223344，我们称这个区域为“堆”。</p>
<p>​	而在最上面的内存区域存放着变量b和c,也就是我们常说的栈，但是由于程序还没运行起来，所以变量b和c的值可能是随机的。</p>
<p>​	==前瞻知识就这样了，然后开始学习基础语法==</p>
<h1 id="第二章-基础语法"><a class="markdownIt-Anchor" href="#第二章-基础语法"></a> 第二章 基础语法</h1>
<h2 id="21-cpu眼里的main函数"><a class="markdownIt-Anchor" href="#21-cpu眼里的main函数"></a> 2.1 CPU眼里的main函数</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401022145747.png" alt="image-20240102214500667" /></p>
<p>​	左右对比可以看到，main函数和func函数翻译成汇编语言之后，除了函数名之外，其余的地方都相同，所以main函数能成为程序的起点，并不仅仅是因为名称的原因。</p>
<ul>
<li>CPU面前，函数没有主次之分，main函数的实现方法，跟普通函数完全相同。</li>
<li>main函数有是很多函数的起点，但是并非它不可，任何函数都可以被设置为函数的起点。</li>
</ul>
<h2 id="22-cpu眼里的变量"><a class="markdownIt-Anchor" href="#22-cpu眼里的变量"></a> 2.2 CPU眼里的变量</h2>
<p>​	无论是何种型号的内存，都必然分为数据信号线和地址信号线，这两大类重要的信号线，顾名思义，数据信号线用来在计算机和内存之间传递数据信息，而在读写数据之前，必须明确的告诉内存条，我们要在哪块内存读，哪块内存写，否则内存那么大，CPU又怎么会知道你要写哪个地方呢？所以内存地址是一切内存读和内存写的前提。</p>
<p>​	代码4：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401022158243.png" alt="image-20240102215800195" /></p>
<p>​	上面只有一条有用的指令，也就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov    DWORD PTR [rip+0x2f00],0x1 </span><br></pre></td></tr></table></figure>
<p>​	很用以猜出这是将1放到变量a所在的地址，由于指令集的原因，CPU不能直接访问内存地址，需要寄存器来实现间接访问，而rip存放的是CPU吓一条指令的地址，所以变量a的地址就是</p>
<p>401114 + 0x2f00 = 404014</p>
<p>​	正如变量的定义所说，变量不过是内存地址的别名。</p>
<p>​	每一个变量都对应了一个内存地址，变量的类型则决定了它占用内存空间的长度。</p>
<h2 id="23-cpu眼里的指针变量"><a class="markdownIt-Anchor" href="#23-cpu眼里的指针变量"></a> 2.3 CPU眼里的指针变量</h2>
<p>代码5：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> a;</span><br><span class="line">    a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *a;</span><br><span class="line">    a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> *a;</span><br><span class="line">    a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func4</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> (*a)[<span class="number">3</span>];</span><br><span class="line">    a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func5</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> **a;</span><br><span class="line">    a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401022211757.png" alt="image-20240102221130668" /></p>
<p>​	func1定义了一个普通变量，并写入0；func2定义了一个char类型的指针变量，并写入0；func3定义了一个short类型的指针变量，并写入0；func4定义了一个数组类型的指针变量，并写入了0，fun4定义了一个数组类型的指针变量，并写入0，func5定义了一个指针类型的指针变量，并写入了0；</p>
<p>​	然后仔细对比可以得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">func1():</span><br><span class="line"> push   rbp</span><br><span class="line"> mov    rbp,rsp</span><br><span class="line"> mov    QWORD PTR [rbp-0x8],0x0</span><br><span class="line"> nop</span><br><span class="line"> pop    rbp</span><br><span class="line"> ret</span><br><span class="line">func2():</span><br><span class="line"> push   rbp</span><br><span class="line"> mov    rbp,rsp</span><br><span class="line"> mov    QWORD PTR [rbp-0x8],0x0</span><br><span class="line"> nop</span><br><span class="line"> pop    rbp</span><br><span class="line"> ret</span><br><span class="line">func3():</span><br><span class="line"> push   rbp</span><br><span class="line"> mov    rbp,rsp</span><br><span class="line"> mov    QWORD PTR [rbp-0x8],0x0</span><br><span class="line"> nop</span><br><span class="line"> pop    rbp</span><br><span class="line"> ret</span><br><span class="line">func4():</span><br><span class="line"> push   rbp</span><br><span class="line"> mov    rbp,rsp</span><br><span class="line"> mov    QWORD PTR [rbp-0x8],0x0</span><br><span class="line"> nop</span><br><span class="line"> pop    rbp</span><br><span class="line"> ret</span><br><span class="line">func5():</span><br><span class="line"> push   rbp</span><br><span class="line"> mov    rbp,rsp</span><br><span class="line"> mov    QWORD PTR [rbp-0x8],0x0</span><br><span class="line"> nop</span><br><span class="line"> pop    rbp</span><br><span class="line"> ret</span><br><span class="line">main:</span><br></pre></td></tr></table></figure>
<p>​	五个函数的实现完全是相同的，无论是什么类型的指针变量，对指针变量的读写操作跟普通变量是没有任何区别的，而所谓的指向，仍旧是在描述指针变量的值是多少而已，跟描述普通变量的值没有什么两样，所以对于CPU来说，管你是多么复杂的变量，一级指针、二级指针，无外乎也是一个地址罢了。</p>
<p>​	不同的是，普通变量的值多用来进行数学运算，而指针变量的值，往往用来定位具体的内存地址，它可以是某个变量的地址，可以是常量地址、函数地址、CPU寄存器地址、也可以是受保护的地址空间。</p>
<h2 id="24-cpu眼里的指针本质"><a class="markdownIt-Anchor" href="#24-cpu眼里的指针本质"></a> 2.4 CPU眼里的指针本质</h2>
<p>​	指针的本质是内存地址，可无论是普通变量亦或者类还是成员变量，都是有地址的，那普通变量可以像指针变量那样进行指针操作吗，也就是*取地址和箭头指向操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> * p = &amp;a;</span><br><span class="line">    *p = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    *(<span class="type">int</span> *)&amp;a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401022227430.png" alt="image-20240102222727321" /></p>
<p>​	三个函数，最终的实现效果是相同的，都是将1赋值到a，只是实现的方法不一样，函数1使用的是指针的方法，函数2是华丽花哨的使用指针，，，函数3是使用变量名，而从最终翻译出来的汇编语言来看，函数二和函数三是相同的，所以一般不会华丽花哨强行使用指针，人都有变量名，你非要得到变量名的地址，再强制类型转换，这不是闲的没事干。</p>
<h2 id="25-cpu眼里的数组"><a class="markdownIt-Anchor" href="#25-cpu眼里的数组"></a> 2.5 CPU眼里的数组</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">8</span>];</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">    a[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">    a[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line">    a[<span class="number">5</span>] = <span class="number">6</span>;</span><br><span class="line">    a[<span class="number">6</span>] = <span class="number">7</span>;</span><br><span class="line">    a[<span class="number">7</span>] = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401030742737.png" alt="image-20240103074224646" /></p>
<p>​	只要知道数组a的首地址和长度，就可以精确定位数组a的地址空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a[<span class="number">2</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> *a)</span></span><br><span class="line">&#123;</span><br><span class="line">    *a = <span class="number">1</span>;</span><br><span class="line">    *(a + <span class="number">1</span>) = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401030746049.png" alt="image-20240103074607944" /></p>
<p>​	上面的代码是用数组变量作为参数的函数和指针变量作为参数的函数，从左右两个对比可以看出，两个的汇编指令完全相同，所以在传递参数的时候，无论你的数组有多大，编译器都不会像传递普通变量那样，在堆栈中创建一个相同大小的临时数组变量，而是简单的传递一个数组的内存首地址，像传递一个指针变量一样，将内存的首地址传递给被调函数，从而对数组进行读写操作，就相当于指针的*操作。</p>
<ol>
<li>数组是一段连续的内存，除了常规的读写元素之外，也会用指针来表示数组，并用指针的*操作进行数组元素的读写</li>
<li>传递数组参数，本质上是传递指针，所以在函数内改变数组的值，也会改变函数外数组的值</li>
<li>多为数组的本质还是一维数组，只是索引方式不同</li>
</ol>
<h1 id="第三章-函数原理"><a class="markdownIt-Anchor" href="#第三章-函数原理"></a> 第三章 函数原理</h1>
<p>​	函数看上去人畜无害，但是实际上是深藏不漏，他是最普通最常见的程序代码，可以说我们编写的代码就是在编写函数，很多时候，我们的程序就是在不断的调用和运行各种函数而已，但你知道吗，实际上是一个非常成功的软件技术，他在占用很少内存的情况下，实现了程序的高效跳转并且原路返回，以及分配临时变量，也叫栈变量，在本章将探索隐藏在函数背后的秘密。</p>
<h2 id="31-cpu眼里的参数传递"><a class="markdownIt-Anchor" href="#31-cpu眼里的参数传递"></a> 3.1 CPU眼里的参数传递</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">long</span> *x, <span class="type">long</span> *y, <span class="type">long</span> *z)</span></span><br><span class="line">&#123;</span><br><span class="line">    *x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">long</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    func1(a, b, c);</span><br><span class="line">    func2(&amp;a, &amp;b, &amp;c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401032049568.png" alt="image-20240103204953450" /></p>
<p>​	上面只是截图的func1和func2两个函数的汇编代码，可以看到无论是值还是指针，他们最终的实现是相同的，有一点点的区别，而这一点点的区别就决定了传值和传址的不同，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov    QWORD PTR [rbp-0x8],0x0</span><br><span class="line"></span><br><span class="line">mov    rax,QWORD PTR [rbp-0x8]</span><br><span class="line">mov    QWORD PTR [rax],0x0</span><br></pre></td></tr></table></figure>
<p>​	在函数1中，只是将rbp-0x8也就是函数调用后备份的参数进行了赋值，而原参数并没有，但是函数2呢，可并不是这样，rbp-0x8中是地址，将地址给了一个寄存器，然后第二条中引用该寄存器里存放的地址，给0，所以修改的是原参数的值。</p>
<p>然后来看下面main函数的截图：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401032051215.png" alt="image-20240103205158112" /></p>
<p>​	可以看到函数1需要将参数值1、2、3传递给函数func1，具体的传输方式就是mov指令，而后面的func2函数，需要把a、b、c、的指针传递非函数func2，通过mov指令将abc三个参数的内存地址进行了传递。</p>
<p>​	很显然，无论是传值还是传地址，他们的实现原理完全一致，都是将某个数值传递给寄存器，如果非要说有什么不同的话，那就是这些数值所要表达的信息不同。</p>
<h2 id="32cpu眼里的函数括号"><a class="markdownIt-Anchor" href="#32cpu眼里的函数括号"></a> 3.2CPU眼里的函数括号</h2>
<p>​	在你写过无数个函数之后，有没有考虑过这样一个问题，当你在函数中进行一顿操作之后，为什么函数返回一切之后还能恢复如初，那刚刚定义的那些临时环境变量最后回去哪些地方呢？本小节我们将从CPU的角度探究背后的秘密。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401032128408.png" alt="image-20240103212803325" /></p>
<p>​	从代码的颜色就能看出，正括号和反括号都有对应的汇编代码，分别是push和pop，也就是入栈和出栈的操作</p>
<h2 id="33-cpu眼里的函数指针"><a class="markdownIt-Anchor" href="#33-cpu眼里的函数指针"></a> 3.3 CPU眼里的函数指针</h2>
<p>​	函数指针真的让我感到头疼，那奇怪的调用呀，希望这个小节可以帮助我理解一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*foo)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    foo func = &amp;test;</span><br><span class="line">    func(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> a = <span class="number">0x401106</span>;</span><br><span class="line">    ((foo)a)(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	定义了一个最简单的函数指针类型和一个与之对应的test函数，然后写了一个简单的函数func1，做一个函数指针的赋值，会后写了一个更简单的函数func2，作为一个普通变量赋值。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401032138186.png" alt="image-20240103213828090" /></p>
<p>​	通过对比可以看出，函数1和函数2 的汇编程序是完全相同的，但他们并没有任何的相同点呀,从汇编的角度可以看看出，两个函数做的都是同一件事情，都是将0x401106放在了一个临时的“栈”变量里面，所以如你所见，函数指针和普通变量一样，它依然是变量，在CPU眼里对函数指针的赋值和对普通变量的赋值是没有区别的。</p>
<p>​	而401106是函数test的内存首地址，函数指针和指针变量一样，并不是来做加减运算的，而是用来存放内存地址的，只不过，指针变量往往用来存放某个变量的地址，而函数指针往往用来存放某个函数的首地址。而一旦知道了函数的首地址那这个函数就可以进行调用了。</p>
<p>​	但是仅仅是知道函数的首地址还是不够的，还需要知道被调函数的相关参数，那这里的参数是如何被告知的呢，其实就是第一行的typedef，他告诉当调用这个函数指针的时候，需要为他准备一个int类型的参数</p>
<h2 id="34-cpu眼里的堆和栈"><a class="markdownIt-Anchor" href="#34-cpu眼里的堆和栈"></a> 3.4 CPU眼里的堆和栈</h2>
<p>​	其实堆和栈并不是一个陌生的话题，但我好像从来没有真正里结果他们两个，今天研究看看。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %p\n&quot;</span>,a ,&amp;a);</span><br><span class="line">    <span class="built_in">stack</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">stack</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202401032155259.png" alt="image-20240103215542199" /></p>
<p>​	可以看到随着函数的调用，变量a的值是没有变化的，一直是0，但是变量的地址确实在一直的降低，这也验证了栈的生长方向或者小号、申请方向是由高内存向低内存生长的，而且每个地址的间隔都是32个字节也就是0x20</p>
<p>而堆跟栈相同，也是系统送给我们的，但是堆的内存往往更大，可以用来存放超大的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    </span><br><span class="line">    p = (<span class="type">int</span> *)<span class="built_in">calloc</span>(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">realloc</span>(&amp;p, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    </span><br><span class="line">    p = new <span class="type">int</span>(<span class="number">10</span>);</span><br><span class="line">    delete p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-03_学习/23 嵌入式C语言的自我修养"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/01/02/03_%E5%AD%A6%E4%B9%A0/23%20%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"
    >C高级学习</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/01/02/03_%E5%AD%A6%E4%B9%A0/23%20%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/" class="article-date">
  <time datetime="2024-01-01T22:50:19.000Z" itemprop="datePublished">2024-01-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/C%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E5%AD%A6%E4%B9%A0/">C语言高级学习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>​	先说一下前提条件，在五年前的大一下学期，我第一次系统的学习了C语言，但那也仅仅只是一个初步的入门，并且在学校中的学习呀，大家懂的都懂，没有深究、没有思考、一切呀都是为了考试，然而如今的我不一样了，相对而言，我更喜欢研究研究研究这些，或者在小说的世界里躲避一下生活，这些都是类似的，只不过研究研究这些更让我有成就感，晚上就慢慢的来吧。</p>
<h1 id="1计算机理论基石"><a class="markdownIt-Anchor" href="#1计算机理论基石"></a> 1.计算机理论基石</h1>
<p>​	前面的关于二极管、三极管以及cmos管的原理这里就不深究了，等我以后再更深层次的学习的时候再说，现在就直接从CPU直接的工作原理开始。</p>
<p>​	计算机的核心：==任何复杂的运算都可以分解为有限个的基本指令运算==。这句话其实我好久好久之前就听说过了，但其实呀一直不解其意这个原理被称为图灵完备性，它表明只要有足够的基本指令，就可以执行任何可计算的任务。</p>
<p>​	在现代计算机上，也是采用这个原理。计算机的中央处理器（CPU）通过执行一系列的基本指令来完成各种复杂的任务。这些基本指令包括算术操作（如加法、减法、乘法）、逻辑操作（如与、或、非）、条件分支（如if语句）和循环（如for循环）等。</p>
<p>​	下面是一个简单的例子，展示了如何使用基本指令来执行一个较复杂的任务，即计算一个整数的阶乘：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">n</span>):</span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        result *= i</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(factorial(<span class="number">5</span>))  <span class="comment"># 输出 120</span></span><br></pre></td></tr></table></figure>
<p>​	在这个例子中，我们使用了基本的乘法和循环指令来计算给定整数的阶乘。通过多次执行乘法操作和循环迭代，实现了一个复杂的计算任务。</p>
<p>​	即使是电脑上的按键操作和视频播放这样的高级任务，也可以通过分解为基本指令运算来实现。</p>
<p>​	例如，当你在电脑上按下一个键时，操作系统会通过底层的指令来检测按键的状态。这可能涉及到读取硬件设备的输入状态、处理中断信号和执行相应的操作。这些底层指令可能包括读取寄存器、执行条件分支、更新内存等等。通过组合这些基本指令，操作系统可以捕捉到按键事件，并触发相应的操作，如打开应用程序、输入字符等。</p>
<p>​	类似地，视频播放也可以通过基本指令来实现。当你打开一个视频文件时，视频播放器会解码视频数据、渲染图像、播放音频等。这些操作涉及到复杂的算法和数据处理，但它们可以分解为基本指令的执行。例如，视频解码可能包括读取文件、解析视频编码、处理图像数据、渲染图像等。通过执行这些基本指令的组合，视频播放器可以实现流畅的视频播放。</p>
<p>​	因此，无论是按键操作还是视频播放，都可以通过将复杂的任务分解为基本指令运算来实现，并且现代计算机提供了这些基本指令的支持。</p>
<p>​	==电脑上的一切操作都可以分解为上面所说的算术操作、逻辑操作、条件分支等一系列基本指令==</p>
<p>​	当然你要懂得的肯定不止上面这些，还有一些跟深层次的分解，就比如复杂的操作是如何被分解为一个个基本指令的、CPU是如何识别这些基本指令的、CPU如何确定这条指令是否运行完成，以及这些基本指令是如何一条条的排序逐次运行的呢？</p>
<p>​	指令集：CPU的加减乘除、与或非、load、store等基本指令一般称之为指令集，任何复杂的运算都可以分解为指令集中的基本指令</p>
<p>​	程序：这种由基本指令组成的不同组合就称之程序。</p>
<p>​	汇编语言：为了变成方便，我们给每个二进制的指令起了一个别名，也可以称之为助记符，也就是我们常说的汇编指令。</p>
<p>​	高级语言：虽然汇编语言的出现给人们带来了极大的便利，人们不需要面对不懂含义的101010，但是当工程更为复杂的时候，汇编的维护也会变得极为艰难，所以为了迎合人们的开发和阅读，人们在汇编的基础上做了一系列的高级语言，就比如python、C、c++和java。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312112059025.png" alt="image-20231211205948001" /></p>
<p>​	然后用一个最简单的C语言程序和C++程序来验证</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">4 &#123;</span><br><span class="line"><span class="number">5</span>     <span class="built_in">printf</span>(<span class="string">&quot;hello world \r\n&quot;</span>);           </span><br><span class="line"><span class="number">6</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">7</span> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;                                    </span><br></pre></td></tr></table></figure>
<p>​	上面是两个最简单的C语言和C++语言的helloworld编程示例，而且最终的实现效果相同都是打印出来helloworld，如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312112103692.png" alt="image-20231211210339665" /></p>
<p>​	这个a.out是编译过后的可执行文件，中间的编译过程又是怎么样的呢？</p>
<p>​	就像上面图示绘制的那样，高级语言都有对应的编译器，C语言又gcc,C<ins>有g</ins>，如果只是通过下面的命令进行编译的话只会得到最后的可执行文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c</span><br><span class="line">g++ test.cpp</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312112133800.png" alt="image-20231211213317748" /></p>
<p>​	当然因为上面两个命令生成的都是a.out所以就覆盖了，也可以通过-o命令进行执行生成的可执行文件名称</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o test_c</span><br><span class="line">g++ test.cpp -o test_c++</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312112134585.png" alt="image-20231211213439536" /></p>
<p>一个高级语言编译成可执行文件，更详细的过程为预处理、编译、汇编、链接</p>
<p>(1)预处理指的是将头文件、函数、恒定义等都展开，可以通过-E参数来实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -E test.c</span><br><span class="line">g++ -E test.cpp</span><br></pre></td></tr></table></figure>
<p>(2)编译指的是通过编译器将高级语言编译为汇编语言，可以通过-S参数来完成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -S test.c -o test_c.s</span><br><span class="line">g++ -S test.cpp -o test_cpp.s</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312112140031.png" alt="image-20231211214028969" /></p>
<p>以s结尾的就是汇编文件，现在对于汇编语言的理解可以不用过深，以后再说。</p>
<p>(3)汇编指的是将汇编程序通过汇编器编译为二进制的.o文件，可以通过参数-c来完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.c -o test_c.o</span><br><span class="line">g++ -c test.cpp -o test_cpp.o</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312112144517.png" alt="image-20231211214409461" /></p>
<p>(4)链接，可以将多个.o文件链接到一起从而生成可执行文件，没有命令，直接gcc编译即可。</p>
<p>​	==我这里有个疑问，我这个程序是最简单那的hello world，也没有多个文件，那他未什么要进行链接呢，我这个地方不是很懂，希望下面的学习能解答我这个疑惑==</p>
<h1 id="2cpu的频率指的是什么"><a class="markdownIt-Anchor" href="#2cpu的频率指的是什么"></a> 2.CPU的频率指的是什么</h1>
<p>​	我先说一下，这个我确实是不知道，我学了这么多年的计算机，我第一台电脑是18年大学，我爸给买的戴尔G3，那时候是一个8300的CPU，后来电脑烧了，我爸又给我买了一个洋垃圾台式机，CPU是2690,虽然现在知道了他是洋垃圾，但之前是不知道的呀，其实就也还好吧，每一段时间都有一段时间的感悟，再后来我工作了，自己花实习的一个月工资高了一台小主机，5900hx的CPU，一年之后没有笔记本，又搞了一台联想的笔记本，笔记本的CPU是6800hx，总体跟我的5900hx差不多，再后来不满足需求了，又因为我的4070ti显卡一直在闲置，我也不想卖掉，所以两个月前又买了一个13900kf的无核显主机，买了这么多电脑，终于是对电脑有了一些基本的认识，但是对于CPU的频率依然是一知半解，趁着这个机会学习一下。</p>
<p>​	<strong>频率的概念</strong></p>
<p>​	在CPU这个复杂的数字系统中，为了确保内部所有硬件单元能够协同快速工作，CPU架构工程师们往往会设计一套时钟信号与系统同步进行操作。时钟信号是由一系列的脉冲信号构成，并且总是按一定电压幅度、时间间隔连续发出的方波信号，它周期性地在0与1之间往复变化。在第一脉冲和第二个脉冲之间的时间间隔称之为周期，它的单位是秒（s）。但单位时间1s内所产生的脉冲个数称之为频率，频率的最基本计量单位就是赫兹Hz。</p>
<p>​	以Intel Core i3-8350k为例，它的默频是4GHz，意味着它内部时钟频率为4GHz，一秒钟可以产生40亿个脉冲信号，换句话说每一个脉冲信号仅仅用时0.25ns（时钟周期）。这是多么令人震惊的时钟，可以想象到CPU内部结构是多么精妙，可以处理如此之短的信号，整套系统协同有序地运行，所以才会说CPU是全人类智慧的结晶，极大地提升了我们的科技水平进步。</p>
<p>​	时钟周期作为CPU操作的最小时间单位，内部的所有操作都是以这个时钟周期作为基准。一般来说CPU都是以时钟脉冲的上升沿作为执行指令的基准，频率越高，CPU执行的指令数越多，工作速度越快。</p>
<p>​	那么CPU频率是由什么决定的呢？其实这个是一个非常复杂的问题，因为决定这个频率是一个系统学的东西，影响到频率高度的因素非常之多，诸如CPU的架构、流水线设计、内部寄存器设计、支持的指令甚至是功耗、温度这些物理因素，所以说CPU出厂频率就是综合多种考虑，以木桶效应下的最小值作为CPU的最高频率。</p>
<p>​	G是十的9次方也就是十亿，M是10的6次方也就是百万，K是10的3次方，</p>
<p><strong>外频</strong></p>
<p>​	CPU在诞生后不久，各大CPU巨头为了追求高性能，开启了频率大战（有没有效果这个我们先不提），但是这样一来，CPU虽然跑得更换了（主频更高），但是外部的主板芯片组、内存、外部接口（PCIe、Sata）可还是处于旧有标准，而且这些设备的运行频率早就固定下来了，并且远低于CPU工作频率。</p>
<p>​	这样一来CPU就无法很好与之交流，Intel就机智地提出了倍频的概念（下面讲述），并且提出了影响至今的一个CPU主频计算公式：主频=外频 X 倍频，外频的提出可以让主板外部的设备工作在较低的频率下，并且还能正确地CPU进行交流。</p>
<p>​	但总是有很多网友将前端总线频率和外频混为一谈，其实他们不太一样。在以前有北桥的时代，前端总线是CPU总线接口单元和北桥芯片之间的数据交换通道，曾经在AMD雷鸟系列、Intel奔腾 4处理器以前，前端总线与外频是一致的，但后来有了四倍数据传输率技术或者是八倍数据传输率技术，前端总线频率就极大地提高了。</p>
<p>​	举个例子，如果一个处理器的频率是2GHz，外频为100MHz，使用四倍数据传输率技术时，前端总线频率就变成400MHz；如果是八倍，那么就是800MHz。前端总线频率越大, 代表着CPU与北桥芯片之间的数据传输能力越大, 更能充分发挥出CPU的功能。<br />
目前处理器的默认外频基本上都是100MHz</p>
<p><strong>倍频</strong></p>
<p>​	目前的CPU设计的外频都相当低，只有100MHz，CPU要获得更快运算速度，我们就需要获得一个超高速的频率来支撑更快运算速度。而CPU通常就是在内部设计有一个锁相环频率发生器，对于输入的时钟信号进行分频处理，按照一定比例提高输入的外频频率，从而得到CPU的实际工作频率，这个比例就称之为倍频系数（简称倍频）。</p>
<p>​	利用倍频技术, 较为完美地解决了CPU和内存等数据中转站的异步运行问题。为CPU后来向更高频率方向发展打下了扎实的基础。</p>
<p>​	倍频系数是指CPU主频与外频之间的相对比例关系。在相同的外频下，倍频越高CPU的频率也越高。但实际上，在相同外频的前提下，高倍频的CPU本身意义并不大。这是因为CPU与系统之间数据传输速度是有限的，一味追求高主频而得到高倍频的CPU就会出现明显的“瓶颈”效应－CPU从系统中得到数据的极限速度不能够满足CPU运算的速度。</p>
<p>​	我有个问题，我的13900KF的CPU频率是5.8GHZ ,我的内存频率是6000M的DDR5内存，这么算的话我的内存比CPU频率高呀，但理论来说不是呀，那问题出在哪？</p>
<p>​	时间的单位是纳秒（ns，十亿分之一秒），毫秒（ms，千分之一秒），和秒（s）。吞吐量的单位是兆字节（MB）和千兆字节（GB）。让我们先从CPU和内存开始，下图是北桥部分：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312112227283.webp" alt="img" /></p>
<p>​	第一个令人惊叹的事实是：CPU快得离谱。在Core 2 3.0GHz上，大部分简单指令的执行只需要一个时钟周期，也就是<strong>1/3纳秒</strong>。即使是真空中传播的光，在这段时间内也只能走10厘米（约4英寸）。把上述事实记在心中是有好处的。当你要对程序做优化的时候就会想到，执行指令的开销对于当今的CPU而言是多么的微不足道。</p>
<p>​	当CPU运转起来以后，它便会通过L1 cache和L2 cache对系统中的主存进行读写访问。cache使用的是静态存储器(SRAM)。相对于系统主存中使用的动态存储器（DRAM），cache读写速度快得多、造价也高昂得多。cache一般被放置在CPU芯片的内部，加之使用昂贵高速的存储器，使其给CPU带来的延迟非常低。在指令层次上的优化（instruction-level optimization），其效果是与优化后代码的大小息息相关。由于使用了高速缓存技术（caching），那些能够整体放入L1/L2 cache中的代码，和那些在运行时需要不断调入/调出（marshall into/out of）cache的代码，在性能上会产生非常明显的差异。</p>
<p>​	正常情况下，当CPU操作一块内存区域时，其中的信息要么已经保存在L1/L2 cache，要么就需要将之从系统主存中调入cache，然后再处理。如果是后一种情况，我们就碰到了第一个瓶颈，一个大约250个时钟周期的延迟。在此期间如果CPU没有其他事情要做，则往往是处在停机状态的（stall）。为了给大家一个直观的印象，我们把CPU的一个时钟周期看作一秒。那么，从L1 cache读取信息就好像是拿起桌上的一张草稿纸（3秒）；从L2 cache读取信息则是从身边的书架上取出一本书（14秒）；而从主存中读取信息则相当于走到办公楼下去买个零食（4分钟）。</p>
<p>​	主存操作的准确延迟是不固定的，与具体的应用以及其他许多因素有关。比如，它依赖于列选通延迟(CAS)以及内存条的型号，它还依赖于CPU指令预取的成功率。指令预取可以根据当前执行的代码来猜测主存中哪些部分即将被使用，从而提前将这些信息载入cache。</p>
<p>看看L1/L2 cache的性能，再对比主存，就会发现：配置更大的cache或者编写能更好的利用cache的应用程序，会使系统的性能得到多么显著的提高。</p>
<p>​	人们通常把CPU与内存之间的瓶颈叫做<strong>冯·诺依曼瓶颈（von Neumann bottleneck）</strong>。当今系统的前端总线带宽约为10GB/s，看起来很令人满意。在这个速度下，你可以在1秒内从内存中读取8GB的信息，或者10纳秒内读取100字 节。遗憾的是，这个吞吐量只是理论最大值（图中其他数据为实际值），而且是根本不可能达到的，因为主存控制电路会引入延迟。在做内存访问时，会遇到很多零 散的等待周期。比如电平协议要求，在选通一行、选通一列、取到可靠的数据之前，需要有一定的信号稳定时间。由于主存中使用电容来存储信息，为了防止因自然 放电而导致的信息丢失，就需要周期性的刷新它所存储的内容，这也带来额外的等待时间。某些连续的内存访问方式可能会比较高效，但仍然具有延时。而那些随机 的内存访问则消耗更多时间。所以延迟是不可避免的。</p>
<p>图中下方的南桥连接了很多其他总线（如：PCI-E, USB）和外围设备：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312112229804.webp" alt="img" /></p>
<p>​	令人沮丧的是，南桥管理了一些反应相当迟钝的设备，比如硬盘。就算是缓慢的系统主存，和硬盘相比也可谓速度如飞了。继续拿办公室做比喻，等待硬盘寻道的时间相当于离开办公大楼并开始长达<strong>一年零三个月</strong>的环球旅行。这就解释了为何电脑的大部分工作都受制于磁盘I/O，以及为何数据库的性能在内存缓冲区被耗尽后会陡然下降。同时也解释了为何充足的RAM（用于缓冲）和高速的磁盘驱动器对系统的整体性能如此重要。</p>
<p>虽然磁盘的&quot;连续&quot;存取速度确实可以在实际使用中达到，但这并非故事的全部。真正令人头疼的瓶颈在于寻道操作，也就是在磁盘表面移动读写磁头到正确的磁道上，然后再等待磁盘旋转到正确的位置上，以便读取指定扇区内的信息。RPM（每分钟绕转次数）用来指示磁盘的旋转速度：RPM越大，耽误在寻道上的时间就越少，所以越高的RPM意味着越快的磁盘。</p>
<p>当 磁盘驱动器读取一个大的、连续存储的文件时会达到更高的持续读取速度，因为省去了寻道的时间。文件系统的碎片整理器就是用来把文件信息重组在连续的数据块 中，通过尽可能减少寻道来提高数据吞吐量。然而，说到计算机实际使用时的感受，磁盘的连续存取速度就不那么重要了，反而应该关注驱动器在单位时间内可以完 成的寻道和随机I/O操作的次数。对此，固态硬盘可以成为一个很棒的选择。</p>
<p>硬盘的cache也有助于改进性能。虽然16MB的cache只能覆盖整个磁盘容量的0.002%，可别看cache只有这么一点大，其效果十分明显。它可以把一组零散的写入操作合成一个，也就是使磁盘能够控制写入操作的顺序，从而减少寻道的次数。同样的，为了提高效率，一系列读取操作也可以被重组，而且操作系统和驱动器固件(firmware)都会参与到这类优化中来。</p>
<p>最后，图中还列出了网络和其他总线的实际数据吞吐量。火线(fireware)仅供参考，Intel X48芯片组并不直接支持火线。我们可以把Internet看作是计算机之间的总线。去访问那些速度很快的网站（比如<a href="https://link.zhihu.com/?target=http%3A//google.com">http://google.com</a>），延迟大约45毫秒，与硬盘驱动器带来的延迟相当。事实上，尽管硬盘比内存慢了5个数量级，它的速度与Internet是在同一数量级上的。目前，一般家用网络的带宽还是要落后于硬盘连续读取速度的，但&quot;网络就是计算机&quot;这句话可谓名符其实。如果将来Internet比硬盘还快了，那会是个什么景象呢？</p>
<p>==内存频率（6000 MHz）指的是内存模块的时钟速度，它表示内存模块每秒钟能够完成的数据传输次数。它通常用于衡量内存模块的性能，较高的内存频率可以提供更快的数据传输速度。==</p>
<p>==CPU频率（5.8 GHz）指的是中央处理器（CPU）的时钟速度，它表示CPU每秒钟执行指令的次数。CPU频率是衡量CPU性能的指标之一，较高的CPU频率通常表示更高的计算能力和处理速度。==</p>
<h1 id="3cache"><a class="markdownIt-Anchor" href="#3cache"></a> 3.cache</h1>
<p>​	cache是sram是静态随机存储器，而内存是sram是动态随机存储器，静态是比动态速度更快的，但是呢，更快意味着更贵。我之前一直对cache了解的不多，知道一级cache、二级cache、三级cache，但并不明白他们的作用，如今学习到这里了，就认识一下。找了一段cdsn大佬的讲解，很生动，这里记录一下。</p>
<p>对于没有接触过底层技术的朋友来说，或许从未听说过cache。毕竟cache的存在对程序员来说是透明的。在接触cache之前，先为你准备段code分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>][<span class="number">128</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">128</span>; j++)</span><br><span class="line">                arr[i][j] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>如果你曾经学习过C/C++语言，这段code自然不会陌生。如此简单的将<code>arr</code><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&amp;spm=1001.2101.3001.7020">数组</a>所有元素置1。 你有没有想过这段code还有下面的一种写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>][<span class="number">128</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">                arr[j][i] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>​	功能完全一样，但是我们一直在重复着第一种写法（或许很多的书中也是建议这么编码），你是否想过这其中的缘由？文章的主角是cache，所以你一定猜到了答案。那么cache是如何影响这2段code的呢？</p>
<h2 id="为什么需要cache"><a class="markdownIt-Anchor" href="#为什么需要cache"></a> 为什么需要cache</h2>
<p>在思考为什么需要cache之前，我们首先先来思考另一个问题：我们的程序是如何运行起来的？</p>
<p>我们应该知道程序是运行在 <strong>RAM</strong>之中，RAM 就是我们常说的DDR（例如： <strong>DDR3、DDR4</strong>等）。我们称之为<strong>main memory（主存）</strong>。当我们需要运行一个进程的时候，首先会从<strong>磁盘设备</strong>（例如，eMMC、UFS、SSD等）中将可执行程序load到主存中，然后开始执行。在CPU内部存在一堆的<strong>通用寄存器（register）</strong>。如果CPU需要将一个变量（假设地址是A）加1，一般分为以下3个步骤：</p>
<ol>
<li>CPU 从主存中读取地址A的数据到内部通用寄存器 x0（ARM64架构的通用寄存器之一）</li>
<li>通用寄存器 x0 加1</li>
<li>CPU 将通用寄存器 x0 的值写入<strong>主存</strong></li>
</ol>
<p>我们将这个过程可以表示如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312112220988.png" alt="img" /></p>
<p>其实现实中，CPU<strong>通用寄存器的速度和主存之间存在着太大的差异</strong>。两者之间的速度大致如下关系：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312112220339.png" alt="img" /></p>
<p>​	CPU register的速度一般小于1ns，主存的速度一般是65ns左右。速度差异近百倍。因此，上面举例的3个步骤中，<strong>步骤1和步骤3实际上速度很慢</strong>。当CPU试图从主存中load/store 操作时，由于主存的速度限制，CPU不得不等待这漫长的65ns时间。如果我们可以提升主存的速度，那么系统将会获得很大的性能提升。如今的DDR存储设备，动不动就是几个GB，容量很大。如果我们采用更快材料制作更快速度的主存，并且拥有几乎差不多的容量。其成本将会大幅度上升。我们试图提升主存的速度和容量，又期望其成本很低，这就有点难为人了。因此，我们有一种折中的方法，那就是制作一块速度极快但是容量极小的存储设备。那么其成本也不会太高。这块存储设备我们称之为<strong>cache memory</strong>。在硬件上，我们<strong>将cache放置在CPU和主存之间</strong>，作为主存数据的缓存。 <strong>当CPU试图从主存中load/store数据的时候， CPU会首先从cache中查找对应地址的数据是否缓存在cache 中。如果其数据缓存在cache中，直接从cache中拿到数据并返回给CPU</strong>。当存在cache的时候，以上程序如何运行的例子的流程将会变成如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200830230817392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsZWF1Y2hhdA==,size_16,color_FFFFFF,t_70" alt="img" /></p>
<p>CPU和主存之间直接数据传输的方式转变成CPU和cache之间直接数据传输，cache负责和主存之间数据传输。</p>
<h2 id="多级cache存储结构"><a class="markdownIt-Anchor" href="#多级cache存储结构"></a> <strong>多级cache存储结构</strong></h2>
<p>cahe的速度在一定程度上同样影响着系统的性能。一般情况cache的速度可以达到1ns，几乎可以和CPU寄存器速度媲美。但是，这就满足人们对性能的追求了吗？并没有。当cache中没有缓存我们想要的数据的时候，依然需要漫长的等待从主存中load数据。为了进一步提升性能，引入多级cache。前面提到的cache，称之为<strong>L1 cache</strong>（第一级cache）。我们在L1 cache 后面连接<strong>L2 cache</strong>，在L2 cache 和主存之间连接<strong>L3 cache</strong>。等<strong>级越高，速度越慢，容量越大</strong>。但是速度相比较主存而言，依然很快。不同等级cache速度之间关系如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312120658651.png" alt="img" /></p>
<p>经过3级cache的缓冲，各级cache和主存之间的速度最萌差也逐级减小。在一个真实的系统上，各级cache之间硬件上是如何关联的呢？我们看下Cortex-A53架构上各级cache之间的硬件抽象框图如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312120659396.png" alt="img" /></p>
<p>​	在Cortex-A53架构上，<strong>L1 cache分为单独的instruction cache（ICache）和data cache（DCache），指令和数据分开</strong>。L1 cache是每个CPU私有的，<strong>每个CPU都有一个L1 cache</strong>。一个cluster 内的所有CPU共享一个L2 cache，<strong>L2 cache不区分指令和数据，都可以缓存</strong>。所有cluster之间共享L3 cache，L3 cache通过总线和主存相连</p>
<p>​	关于cache就学习到这里，如果想要学习更多相关的可以看这个<a target="_blank" rel="noopener" href="https://blog.csdn.net/bleauchat/article/details/108312753?ops_request_misc=%7B%22request%5Fid%22%3A%22170230386216800225597418%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170230386216800225597418&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108312753-null-null.142%5Ev96%5Epc_search_result_base2&amp;utm_term=cache&amp;spm=1018.2226.3001.4187">博客</a>.</p>
<h1 id="4总线和地址"><a class="markdownIt-Anchor" href="#4总线和地址"></a> 4.总线和地址</h1>
<p>​	先来阐述一个疑惑<strong>32位的CPU和64位的CPU这里的32和64指的什么</strong>？</p>
<p>​	32位CPU：指的是处理器的寻址能力或数据总线宽度为32位。这意味着该处理器可以在单个时钟周期内处理32位（4字节）的数据或地址。它最大支持的物理内存容量通常限制在4GB左右。</p>
<p>​	64位CPU：指的是处理器的寻址能力或数据总线宽度为64位。这意味着该处理器可以在单个时钟周期内处理64位（8字节）的数据或地址。它的寻址能力更大，可以支持更大的物理内存容量，通常可以支持数TB（1TB = 1024GB）的内存。</p>
<p>​	因此，32位和64位CPU主要区别在于它们的寻址能力和数据总线宽度，这直接影响到它们在处理数据和内存方面的能力和限制。64位CPU相对于32位CPU具有更高的处理能力和更大的内存扩展性。</p>
<p>​	CPU和内存以及各种外部设备是通过总线连接在一起的，那CPU是如何访问内存或者控制各个外部设备的呢？在CPU内部，存在一系列的寄存器，这些寄存器是没有地址的，只需要寄存器的名称去访问即可，而内存以及各个外部设备就需要地址去访问了。那这里的地址是什么，这里的地址又是如何分配的呢？</p>
<p>​	地址的本质实际上就是由CPU管教发出的一组地址控制信号，因为这些信号是由CPU管教直接发出的，因此也被称之为物理地址。在带有MMU的CPU平台下 ，程序的运行一般使用的是虚拟地址，MMU会把虚拟地址转换为物理地址，然后通过CPU的管教发送出去。</p>
<p>​	所谓总线（Bus），是指计算机设备和设备之间传输信息的公共数据通道。总线是连接计算机硬件系统内多种设备的通信线路，它的一个重要特征是由总线上的所有设备共享，可以将计算机系统内的多种设备连接到总线上。如果是某两个设备或设备之间专用的信号连线，就不能称之为总线。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312120727706.png" alt="9bb1a43e2e0140128d3e1e35f1bf0096.png" /></p>
<p>​	一些总线标准：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312120726170.png" alt="770540885ce04b5a83ef5b49f5fc9546.png" /></p>
<h1 id="5指令集和微架构"><a class="markdownIt-Anchor" href="#5指令集和微架构"></a> 5.指令集和微架构</h1>
<p>​	在第一节提到过，任何一个复杂的程序都可以分解位=为有限个基本指令的组合，而这些是在CPU设计的时候就已经确定了的，他的内部只允许对应指令的完成，而不同架构的处理器，他们的指令是不一样的，哪怕是同样的指令，他们的内部电路实现也是不一样的，所以不同架构的可执行程序是不能混用的。ARM架构的处理器只能运行ARM架构的程序，X86架构的处理器只允许运行X86架构的程序。上面提到的这些指令的集合就被称之为指令集。</p>
<p>​	在芯片工程师设计CPU的时候，要根据指令集中规定的格式指令作为标准，实现那不同的译码电路来支持指令集各种指令的运行（==这里你不用管如何译码的，这里目前不需要深究==），指令集的最终实现就是微架构，也就是CPU内部的各种译码和执行电路。</p>
<p>​	就比如a7核心 a9核心等就是微架构，而RK3568的四核心A55就是指的微架构。</p>
<p>​	这里目前认识到这个程度就可以了，不做过多的深究，以及后面有需要再去学习了解一下汇编语言。</p>
<h1 id="6可执行文件的组成"><a class="markdownIt-Anchor" href="#6可执行文件的组成"></a> 6.可执行文件的组成</h1>
<p>​	在上面已经讲解过了，编译完成之后会生成一个二进制的可执行文件，这个可执行文件只能在对应架构的机器上才能运行，那这个可执行程序都是由什么组成的呢？这时候就要提到一个命令了，也就是readelf，从名字就可以看出他的作用是读取一个可执行文件，先来用file命令查看一下可执行程序，如下所示：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312122103556.png" alt="image-20231212210354485" /></p>
<ul>
<li>“test_c:”: 这是文件的名称。</li>
<li>“ELF 64-bit LSB shared object, x86-64”: 这是文件的类型和架构。它是一个64位的LSB（Linux Standard Base）共享对象，针对x86-64架构。</li>
<li>“version 1 (SYSV)”: 这是ELF文件的版本，采用SYSV格式。</li>
<li>“dynamically linked”: 这表示该文件是动态链接的，它依赖于其他共享库来提供其所需的功能。</li>
<li>“interpreter /lib64/ld-linux-x86-64.so.2”: 这是解释器路径，指示系统在执行该文件时使用的动态链接器。</li>
<li>“BuildID[sha1]=cad02772db45e07867103cc6069ae544863b9ebc”: 这是文件的构建ID，用于唯一标识该文件的构建版本。它是使用SHA1算法计算的哈希值。</li>
<li>“for GNU/Linux 3.2.0”: 这表示该文件是为GNU/Linux 3.2.0版本编译的。</li>
<li>“not stripped”: 这表示该文件没有被剥离（stripped），即没有从文件中移除调试信息和符号表。</li>
</ul>
<p>Executable and Linkable Format  可执行和可链接的格式。</p>
<p>可以通过readelf -h命令查看可执行文件的文件头（header）信息，例如查看上面编译的hellloworld文件，具体内容如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312122111923.png" alt="image-20231212211112738" /></p>
<p>​	这里了解到的信息其实并没有什么用，唯一有用的就是最下面的section header数量，section header用来主要用来描述可执行文件的section信息，一个可执行文件通常由不同的section来组成，包括代码段、数据段、BSS段、只读数据段，每个section由section header来描述。这里的文件头其实也就是指的文件最开始的那几个字节的信息，然后通过readelf -S 查看可执行文件的节头表（section header）。仍旧以helloworld为里，查看到的节头表内容如下所示：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312122118128.png" alt="image-20231212211818864" /></p>
<p>​	通过节头表的信息可以窥探到一个可执行文件的组成，上面我比较熟悉的其实并不多，其实也就知道代码段 text ，数据段 data，。bss段，其他知道的并不多，函数翻译成二级制指令放在代码段之中，初始化的全局变量和静态局部变量放在数据段之中，未初始化的全局变量和静态局部变量放在BSS段当中，其他就没了。</p>
<h1 id="7汇编过程"><a class="markdownIt-Anchor" href="#7汇编过程"></a> 7.汇编过程</h1>
<p>​	先说一下我的想法，本来我是不想学习这个的，后来我感觉这个东西与后面的链接、与动态库静态库有很深的联系，所以我还是回来看这个了。</p>
<p>​	预处理之后就是编译，汇编的过程就是将程序代码转换为一个个的汇编指令，再后面才是真正的汇编过程，汇编依靠汇编器，汇编器会将汇编语言转换为二进制语言。</p>
<p>​	每个重定位的目标文件都是以零地址为基地址进行的代码段的组装，但是后面的链接过程需要将好多个目标文件链接为一个可执行文件，而每个文件都是以零地址进行偏移的，所以在链接的时候需要更新目标文件中的变量或者函数的地址，这个被称之为重定义。那链接器如何知道哪些函数或者变量需要重定位呢？很简单将需要重定位的符号收集起来，生成一个重定位表，以section的形式保存到每个可重定位目标文件即可。</p>
<p>​	上面提到符号表和重定位表都是很重要的概念。符号表可以通过readelf -s命令来获取，注意这里是小s</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312122209612.png" alt="image-20231212220932369" /></p>
<p>使用readelf -r可以获得该重定位目标文件的重定位表，如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312122214971.png" alt="image-20231212221407848" /></p>
<h1 id="8静态链接库"><a class="markdownIt-Anchor" href="#8静态链接库"></a> 8.静态链接库</h1>
<p>​	仍旧先说一下我的理解和看法，无论是静态链接库还是动态链接库，他们实际上就是可重定位的目标文件，即汇编过程之后生成的文件，当然也不对，可以是由一个目标文件生成的库文件也可以是由好几个目标文件生成库文件。很多时候人们会将函数的实现给封装起来，我们只需要调用相应的函数即可，而很多不开源的项目，也会提供封装好的库，让人们只需要使用头文件中定义的相应函数即可。</p>
<p>​	静态库会在编译程序的时候将引用的函数代码或者变量链接到可执行文件里，和在可执行程序组装到一起，而动态库不会和可执行文件组装到一起，而是在程序运行的时候加载到内存参与链接。</p>
<p>​	所以静态库的本质就是一个可重定位的目标文件，与上面经过汇编编译出来的.o文件没什么不同，只是多了一个归档的过程。静态库的制作使用ar归档命令来实现，ar是一个用于创建和管理静态库（Archive）的命令行工具。它的名称是&quot;ar&quot;，代表&quot;archive&quot;，可以在Unix和Unix-like系统上使用。ar命令可以用于创建静态库、向静态库中添加对象文件、从静态库中提取对象文件以及执行其他与静态库相关的操作。下面是对ar命令的一些常见用法的详细解释：</p>
<p>1.创建静态库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar -rcs libexample.a file1.o file2.o file3.o</span><br></pre></td></tr></table></figure>
<p>这个命令将创建一个名为&quot;libexample.a&quot;的静态库，并将文件&quot;file1.o&quot;、&quot;file2.o&quot;和&quot;file3.o&quot;添加到该库中。选项&quot;r&quot;表示替换库中的现有文件，选项&quot;c&quot;表示创建库，选项&quot;s&quot;用于在库中添加索引信息。</p>
<ul>
<li><code>-r</code>：将指定的文件插入或替换到归档文件中。</li>
<li><code>-s</code>：创建索引表。</li>
<li><code>-c</code>:   不在必须创建库的时候给出警告</li>
</ul>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312130724504.png" alt="" /></p>
<p>2.向静态库中添加对象文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar -r libexample.a newfile.o</span><br></pre></td></tr></table></figure>
<p>这个命令将向现有的静态库&quot;libexample.a&quot;中添加新的对象文件&quot;newfile.o&quot;。选项&quot;r&quot;表示替换库中的现有文件。</p>
<p>3.从静态库中提取对象文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar -x libexample.a newfile.o</span><br></pre></td></tr></table></figure>
<p>这个命令将从静态库&quot;libexample.a&quot;中提取出对象文件&quot;file1.o&quot;。选项&quot;x&quot;表示提取</p>
<p>4.列出静态库中的对象文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar -t libexample.a</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312130727529.png" alt="image-20231213072726515" /></p>
<p>5.替换静态库中的对象文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ar -d libexample.a file1.o</span><br><span class="line">ar -r libexample.a newfile.o</span><br></pre></td></tr></table></figure>
<p>这两个命令分别用于从静态库中删除对象文件&quot;file1.o&quot;和向静态库中添加新的对象文件&quot;newfile.o&quot;。选项&quot;d&quot;表示删除。</p>
<p>​	编译器是以源文件为单位进行程序编译的，链接器在连接的过程中逐个对目标文件进行分解和组装，但这样很容易产生一个问题，如果一个源文件中我们定义了一百个函数，但是只使用了其中的一个，链接器在连接的过程中会将这一百个函数都组装到可执行文件中，这会让最终生成的可执行文件大大增加，那要如何解决这个问题呢，只需要将每一个函数单独使用一个源文件来实现，最终将多个目标文件打包即可。而我们最常用的libc库就是这样实现的，可以通过上面学习的ar -t命令来查看对象文件列表</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312130742069.png" alt="image-20231213074253042" /></p>
<p>​	可以看到libc将每个函数都搞成了一个目标文件，从而解决了上面提到的问题。这时候又出现了另一个问题，就比如我们经常用到printf进行字段的打印，可能很多个程序都调用了它，链接器在链接的时候就要将多个printf指令添加到多个可执行文件中，在一个多任务的环境中，多个进程并发运行的时候，你会发现内存中有大量重复的printf指令代码，从而浪费了很多的资源，那这个问题要如何解决呢，聪明的工程师们想出来了动态库的方法。</p>
<p>​	==今天就学习到这个地方了，其实上面的这些东西你都不配说难，因为已经有先人替你踩过坑了，也有更厉害的先人提出来了这些理论，并且用到了实践中，计算机当中的一切都不再属于新鲜事，我们已经站在了巨人的肩膀上，没有理由后人比前人笨，也没有道理学不会，学不会只能证明你没有用心==</p>
<h1 id="9动态链接库"><a class="markdownIt-Anchor" href="#9动态链接库"></a> 9.动态链接库</h1>
<p>​		在讲解静态链接库的最后面也提到了静态链接库现有的一些问题，所以人们就提出了动态链接库，动态链接库在程序运行时进行加载，而且不同的可执行文件可以共用动态链接库，所以可以极大的节省内存，动态链接库的编译方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -shared C文件 -o 库文件</span><br></pre></td></tr></table></figure>
<p>​		在Linux环境下，当我们运行一个程序时，操作系统首先会在给程序fork一个子进程，接着动态连接器加载到内存，操作系统将控制器权交给动态链接器，让动态链接器完成动态库的加载和重定位搞作，最后跳转到要运行的程序。动态链接器在C标准库中实现，是glibc的一部分，主要完成程序运行前的动态链接工作，在可执行文件的.interp段中存放的有动态链接器的加载路径，可以通过objdump命令查看。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -j .interp -s a.out</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312132058333.png" alt="" /></p>
<p><code>objdump</code>是一个用于分析目标文件（object file）的常用命令行工具。它在各种操作系统和编程环境中都有提供，例如Linux和Windows。</p>
<p><code>objdump</code>的主要作用是提供目标文件的反汇编、符号表、节（section）信息等相关信息。以下是一些常见的用途：</p>
<ol>
<li>反汇编目标文件：<code>objdump</code>可以将目标文件中的机器码转换为可读的汇编代码，以便进行代码分析、调试和优化。这对于理解代码的执行流程、查找问题和进行二进制分析非常有用。</li>
<li>显示符号表：<code>objdump</code>可以列出目标文件中的符号表，包括函数、变量和其他符号的信息。这对于了解代码的结构、查找特定符号、检查符号的可见性和解决符号冲突非常有帮助。</li>
<li>显示节信息：<code>objdump</code>可以显示目标文件中各个节（section）的信息，例如代码段、数据段、符号表、重定位表等。这对于了解目标文件的布局、存储的数据、链接信息和其他元数据非常有用。</li>
<li>检查目标文件的属性：<code>objdump</code>可以提供有关目标文件的一些属性，例如目标文件格式、目标架构、入口点等。这对于验证目标文件的正确性和兼容性非常有帮助。</li>
</ol>
<p>​		动态链接器本身也是一个动态库，即lib/ld-linux.so文件，动态链接器被加载到内存后，会首先给自己重定位，然后才能运行，像这种给自己重定位然后自动运行的行为，我们称之为自举，在嵌入式系统中Uboot也有自举功能，它在系统上电启动之后会完成代码的自我复制和重定位操作，然后加载到Linux内核镜像中运行。</p>
<p>​	动态链接器解析解析可执行文件中未确定的符号以及需要链接的动态库信息，将对应的动态库加载到内存，并进行重定位操作，这个过程其实和静态链接的重定位过程相同，只不过推迟到了运行阶段，重定位结束之后，程序中要引用的符号都有了地址和定义，动态链接器要将控制权交给可执行程序，跳转到该程序运行。</p>
<p>​	静态链接的可执行程序在运行时，一般加载地址等于链接地址，而且这个地址是固定的，可执行文件是操作系统帮我们创建一个子进程之后第一个被加载到内存空间的文件，此时进程的地址一马平川，还未被占用，所以不用考虑地址资源的问题，而动态链接库加载到内存的地址是随机的，因为每一个可执行文件的带线啊哦不同，所以加载到内存后剩余的地址空间也不相同，动态链接库的地址要根据进程地址空间的实际空间的情况随机分配。</p>
<p>​	so文件是在加载时进行的重定位，虽然解决了可执行文件中对绝对地址的引用问题，但也带来了另外的问题，那就是对于每个进行，动态库加载到内存的不同地址，只能被进程自身共享，无法再多个进程间共享，无法节约内存，但这也又违背了动态库设计的初衷，跟静态库是一样的效果，要如何解决这个问题呢。</p>
<p>​	如果想要让动态库放到内存的任何位置都可以运行，都可以被多个进行共享，那就是将动态库设计成与位置无关的代码，上面的gcc的-fPIC参数就是指与位置无关，最终的设计思路为，将指令中需要修改的部分分离出来，剩余的部分就与地址无关了，放在哪里都能执行，而且可以被多个进程共享，需要被修改的指令和数据在每个进行中都有一个副本，互不影响各自的运行。</p>
<p>​	对于同一个程序，我们很容易通过相对寻址来实现代码和地址无关，但是当动态库作为第三方模块被不同的应用程序引用的时候，库中的一些绝对地址符号，如何能做到同时被不同的应用程序引用的呢，解决这个问题的方法其实也很简单，那就是将应用程序引用的动态库符号收集起来，保存到一个表之中买这个表用来记录各个引用符号的地址，这个表被称之为全局偏移表。</p>
<p>​	现在大部分软件都是通过动态链接的方式开发的，不仅可以节省内存空间，升级维护也比较方便。动态链接器会在系统默认的路径下查找，即lib usr/lib，也回到系统指定的一些路径下查找，用户可以在/etc/ld.so.conf文件中添加自己的共享库路径，修改之后可以使用ldconbfig重新生成一个缓存的/etc/ld.so.chche，每次增加或者删除共享库的路径时，都需要使用ldconfig更新缓存。除此之外也可以使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=库的路径</span><br></pre></td></tr></table></figure>
<p>​	临时改变共享库的查找路径。</p>
<h1 id="10堆栈"><a class="markdownIt-Anchor" href="#10堆栈"></a> 10.堆栈</h1>
<p>​	在一个进程的地址空间中，代码段、数据段、BSS段在内存加载程序运行之后，地址就已经被确定了，在整个此程序的运行期间不在发生变化，这部分内存就被称之为静态内存，而在程序中使用malloc申请的内存、函数调用过程中的栈在程序运行期间是不断进行变化的，这部i分内存被称之为动态内存，用户使用malloc申请的内存一般被称之为堆内存，函数调用过程中使用的内存被称之为栈内存，</p>
<p>​	堆内存一般在BSS的后面，随着用户使用malloc申请的内存越来越多，堆空间并不断地往高地址增长。栈空间则紧挨着内核空间，arm使用的是满递减堆栈，栈指针会从用户空间的高地址向低地址不断增长。</p>
<p>​	栈是C语言运行的基础，一个函数内定义的局部变量、传递的实参都是保存在栈中，每个函数都会有专门的栈空间来保存这些数据，每个函数的栈空间都被称之为栈帧。</p>
<p>==只是感觉目前堆和栈对于我并没有什么作用，下次真的有需求再来吧。==</p>
<h1 id="11数据对齐"><a class="markdownIt-Anchor" href="#11数据对齐"></a> 11.数据对齐</h1>
<p>​	仍旧先来说一下我的看法，数据对齐其实我听过很多次了，无论是在NPU学习里接触到的数据对其，还是在这里遇到的数据对其，他们都说数据对齐可以极大的加速程序运行时间、我不知道这个说法是不是对的，但我还是比较奇怪，不是很懂，这样加速的原理，今天就来真正的理解一下。</p>
<p>​	为什么非要进行地址对齐呢，这是由CPU的硬件决定的，为了简化CPU的电路设计，有些CPU在设计师简化了地址的访问，只支持边界对齐的访问方式，就比如有0-7这八个地址，CPU只能读取0和4这俩，0-3、4-7为两组，如果有一个数据存储在了2-5，这四个地址，那么CPU就需要读取两次，而如果单独放在每个组里那也就只需要一次。</p>
<p>​	我可能知道为什么要用指针了，上面也说过了堆栈相关的东西，我之前还疑惑那些值传递和地址的传递，现在可能是懂得了，函数的形参和实参。</p>
<p>​	如果将一个很庞大的值传递到函数中，该函数会有一个专门的栈空间，而那些值同样也会重新复制一份，但是如果是地址的话，就不会如此，只需要传递相应的地址即可，省去了拷贝的步骤，从而大大提升运行的速度。</p>
<p>​</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-03_学习/25 ubuntu环境搭建"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/12/25/03_%E5%AD%A6%E4%B9%A0/25%20ubuntu%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"
    >ubuntu环境搭建</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/12/25/03_%E5%AD%A6%E4%B9%A0/25%20ubuntu%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="article-date">
  <time datetime="2023-12-24T22:50:19.000Z" itemprop="datePublished">2023-12-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B8%B8%E6%88%8F/">游戏</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1ubuntu22环境搭建"><a class="markdownIt-Anchor" href="#1ubuntu22环境搭建"></a> 1.ubuntu22环境搭建</h1>
<h2 id="11-ubuntu22-镜像源下载"><a class="markdownIt-Anchor" href="#11-ubuntu22-镜像源下载"></a> 1.1 ubuntu22 镜像源下载</h2>
<p>​	清华源 <a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/</a></p>
<p>​	中科大源 <a target="_blank" rel="noopener" href="https://mirrors.ustc.edu.cn/ubuntu-releases/">https://mirrors.ustc.edu.cn/ubuntu-releases/</a></p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312252052418.png" alt="image-20231225205248378" /></p>
<p>​	我这里就直接下载ubuntu22了，vmware虚拟机安装ubuntu22的步骤就不再多说，这里就根据步骤来进行就好了。</p>
<h2 id="2设置中文"><a class="markdownIt-Anchor" href="#2设置中文"></a> 2.设置中文</h2>
<p>​	对于一打印信息还是中文更加友好，所以这里将系统的环境更换为中文。首先来到设置，如下所示：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312252107402.png" alt="image-20231225210703377" /></p>
<p>​	找到Region and Language，点击语言管理：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312252108180.png" alt="image-20231225210811158" /></p>
<p>​	将汉语(中国)移动到最上面，移动完成如下所示：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312252109085.png" alt="image-20231225210931069" /></p>
<p>​	然后点击应用到系统：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312252109436.png" alt="image-20231225210958420" /></p>
<p>​	重启系统就是中文了。如下所示：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312252111623.png" alt="image-20231225211128599" /></p>
<h2 id="3设置不休眠"><a class="markdownIt-Anchor" href="#3设置不休眠"></a> 3.设置不休眠</h2>
<p>​	默认情况下都是五分钟休眠，这里时间太短了，所以需要在设置里的电源中改为无休眠。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312252112513.png" alt="image-20231225211252490" /></p>
<h2 id="4其他配置"><a class="markdownIt-Anchor" href="#4其他配置"></a> 4.其他配置</h2>
<p>​	安装一些软件和依赖，确保编译和一些工具能成功</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y uuid uuid-dev zlib1g-dev liblz-dev liblzo2-2 liblzo2-dev lzop \</span><br><span class="line">git curl u-boot-tools mtd-utils openjdk-8-jdk device-tree-compiler \</span><br><span class="line">gdisk m4 git gnupg flex bison gperf libsdl1.2-dev libesd-java \</span><br><span class="line">squashfs-tools build-essential zip libncurses5-dev pngcrush schedtool \</span><br><span class="line">libxml2 libxml2-utils xsltproc lzop libc6-dev g++-multilib lib32z1-dev \</span><br><span class="line">lib32ncurses-dev lib32readline-dev libswitch-perl libssl-dev unzip \</span><br><span class="line">liblz4-tool ssh make gcc libssl-dev vim expect \</span><br><span class="line">patchelf chrpath gawk texinfo diffstat binfmt-support \</span><br><span class="line">qemu-user-static live-build fakeroot cmake rsync subversion \</span><br><span class="line">sed binutils wget bzr cvs git mercurial \</span><br><span class="line">patch gzip bzip2 perl tar cpio file bc python3-pip \</span><br><span class="line">rsync android-sdk-libsparse-utils python2 net-tools vim</span><br></pre></td></tr></table></figure>
<p>​	然后禁止掉wayland，不禁掉不能正常拖动文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/gdm3/custom.conf</span><br></pre></td></tr></table></figure>
<p>打开WaylandEnable=false的注释，然后重启系统，果然修改了之后，可以直接拖动了，不错。然后修改一下虚拟机配置：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312252115362.png" alt="image-20231225105730434" /></p>
<p>​	上面的这三个没啥用，直接关掉，启动时连接也取消掉。然后备份一下系统，中文输入法也不用安装，反正一般都是用ssh来连接的。</p>
<p>​	重启之后先来设置ssh，我还是喜欢用ssh，设置的步骤如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使能root用户登录</span></span><br><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure>
<p>到这里该安装的就差不多了，剩下的就让tabby来，为了确保传输速度，先加一个nat的网卡：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312252115313.png" alt="image-20231225112113607" /></p>
<p>在编译内核的时候遇到了的第一个问题：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312252115336.png" alt="image-20231225134018868" />需要将python3链接到python，具体命令如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/bin/python3 /usr/bin/python</span><br></pre></td></tr></table></figure>
<p>修改之后内核编译成功。编译recovery成功。编译文件系统成功、打包完整的update镜像成功，皆大欢喜，莫得问题，编译整体时间大约为两个小时，13：30开始编译，15：30编译结束时间.</p>
<p>随后又测试了安卓，同样可以编译成功。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-03_学习/26_vim学习"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/12/25/03_%E5%AD%A6%E4%B9%A0/26_vim%E5%AD%A6%E4%B9%A0/"
    >vim学习</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/12/25/03_%E5%AD%A6%E4%B9%A0/26_vim%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2023-12-24T22:50:19.000Z" itemprop="datePublished">2023-12-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>​	所以，学习这东西就是一个不断重复的过程，两年之前我就学习过vim了，今天终于还是又来了，重新学习一下吧，增加效率，后面也会对vim进行讲解，就当为自己，为后面做铺垫吧。</p>
<h2 id="1-什么是vim"><a class="markdownIt-Anchor" href="#1-什么是vim"></a> 1、什么是VIM</h2>
<p>​	在说vim之前，先说下什么是vi。vi是visual interface的简称，是Linux中最经典的文本编辑器。vi的核心设计思想是：让程序员的手始终保持在键盘的核心区域就能够完成所有的编辑操作。而Vim又是从 vi 发展出来的一个文本编辑器，即vi improved,它在代码补全、编译及错误跳转等方便编程的功能上特别丰富，在程序员中被广泛使用。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312252027488.png" alt="image-20231225202718396" /></p>
<p>​	先说一下到底如何学习，其实vim已经给了我们一个学习资料，那就是vimtutor，vim安装之自动会带着一个教程，这个教程很不错，跟着这个教程来即可。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-03_学习/24 VScode学习"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/12/23/03_%E5%AD%A6%E4%B9%A0/24%20VScode%E5%AD%A6%E4%B9%A0/"
    >VScode学习</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/12/23/03_%E5%AD%A6%E4%B9%A0/24%20VScode%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2023-12-22T22:50:19.000Z" itemprop="datePublished">2023-12-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>​	先说一下前提条件</p>
<h1 id="1vscode下载"><a class="markdownIt-Anchor" href="#1vscode下载"></a> 1.VScode下载</h1>
<p>[附上官网地址：Visual Studio Code - Code Editing. Redefined](</p>
<p>1)、C/C++，这个肯定是必须的。</p>
<p>2)、C/C++ Snippets，即 C/C++重用代码块。</p>
<p>3)、C/C++ Advanced Lint,即 C/C++静态检测 。</p>
<p>4)、Code Runner，即代码运行。</p>
<p>5)、Include AutoComplete，即自动头文件包含。</p>
<p>6)、Rainbow Brackets，彩虹花括号，有助于阅读代码。</p>
<p>7)、One Dark Pro，VSCode 的主题。</p>
<p>8)、GBKtoUTF8，将 GBK 转换为 UTF8。</p>
<p>9)、ARM，即支持 ARM 汇编语法高亮显示。</p>
<p>10)、Chinese(Simplified)，即中文环境。</p>
<p>11)、vscode-icons，VSCode 图标插件，主要是资源管理器下各个文件夹的图标。</p>
<p>12)、compareit，比较插件，可以用于比较两个文件的差异。</p>
<p>13)、DeviceTree，设备树语法插件。</p>
<p>14)、CMake Tools Cmake 工具</p>
<p>15)、Remote - SSH SSH远程连接</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-03_学习/19 shell编程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/12/18/03_%E5%AD%A6%E4%B9%A0/19%20shell%E7%BC%96%E7%A8%8B/"
    >shell编程 第一次学习</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/12/18/03_%E5%AD%A6%E4%B9%A0/19%20shell%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2023-12-18T12:41:19.000Z" itemprop="datePublished">2023-12-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>​	先说一下前提条件，其实shell编程我好早之前就知道了，其实吧，这个就跟法师最后让我录制的课程是差不多的，只是一个叫做Ubuntu基础，一个叫做shell编程，这两个其实是一个东西，而我对于ubuntu中的一些命令其实并不熟悉，我也并不能独立写出来一个脚本，所以我并不反感法师让我去录课，我的基础其实并不牢固，要学习的东西真的太多了，而我这一星期的重点就是戒掉小说，学生shell。</p>
<p>==弱小和无知并不是生存的障碍，傲慢才是==</p>
<h1 id="1什么是shell和bash"><a class="markdownIt-Anchor" href="#1什么是shell和bash"></a> 1.什么是shell和bash</h1>
<p>​	近代以来，计算机操作系统都采用了某种形式的用户界面，借此指定需要操作系统执行的命令，但是很多操作系统当中命令是内建的，是同计算机交互的唯一方式，而shell无非也就是一个程序而已，这个程序的作用就是为用户执行其他程序，但他要做的并不只于此，一个只允许你输入命令的shell确实没有太大的意思，但如果你可以使用这些命令编程呢，是不是很酷。</p>
<p>​	Shell（壳层）是计算机科学中的一个概念。在操作系统中，Shell 是用户与操作系统内核之间的接口。它提供了一个命令行界面（CLI）或图形用户界面（GUI），使用户能够与操作系统进行交互、运行命令和访问系统资源。</p>
<p>​	bash也是一种shell，即命令解释器，bash的目的是让用户同计算机操作系统进行交互，从而完成想做的任务，当然这些任务可能是重复性的、要么非常的复杂，shell编程允许你对此任务进行自动化，以实现易用性、可靠性以及可重现性。</p>
<h1 id="2标准输出"><a class="markdownIt-Anchor" href="#2标准输出"></a> 2.标准输出</h1>
<h2 id="21-输出到终端"><a class="markdownIt-Anchor" href="#21-输出到终端"></a> 2.1 输出到终端</h2>
<p>​	使用内建命令echo，将命令行中的参数打印到屏幕上</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello shell</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182109865.png" alt="image-20231218210955820" /></p>
<p>​	echo是最简单的bash命令之一，该命令可以将参数输出到屏幕上，需要注意的是shell会接续echo的命令行参数，即在输出之前，shell自动完成赋值、替换、等一系列操作，除此之外参数之间的空白字符会忽略，无论多少个空白字符，都会是一个字符，具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello    shell !  !    !</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182112259.png" alt="image-20231218211254225" /></p>
<p>​	但有些时候又需要空白字符，那要如何做呢？</p>
<h2 id="22-保留空白字符"><a class="markdownIt-Anchor" href="#22-保留空白字符"></a> 2.2 保留空白字符</h2>
<p>​	其实保留空白字符的方法十分简单，只需要在字符前后加上双引号或者单引号即可，具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello    shell !  !    !&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182119526.png" alt="image-20231218211953490" /></p>
<p>​	通过单引号和双引号可以指定为字符串，而shell不会对字符串进行干涉，双引号和单引号也是有区别的,单引号明确告诉不要干涉，而双引号仍旧会执行一些替换操作，包括变量扩展、算数运算、波浪号扩展等</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182135535.png" alt="image-20231218213521502" /></p>
<h2 id="23-在输出中加入更多的格式控制"><a class="markdownIt-Anchor" href="#23-在输出中加入更多的格式控制"></a> 2.3 在输出中加入更多的格式控制</h2>
<p>​	就跟C语言里面的相同，仍旧可以使用printf命令打印这些，具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf &quot;%s = %d\n&quot; lines $LINES</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182138655.png" alt="image-20231218213848622" /></p>
<p>​	==我知道你想说，这个东西有什么用吗，没错我也是这样想的，但是你怎么知道你以后不用它呢，当你真的用的时候你还能想的起来吗==</p>
<h2 id="24-消除换行符"><a class="markdownIt-Anchor" href="#24-消除换行符"></a> 2.4 消除换行符</h2>
<p>​	认真观察的同学可能发现了，上面的echo命令自带换行，而printf命令默认不带换行，换行需要一个\n来完成，那echo如何不换行呢，其实可以加一个参数-n，具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -n lines</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182146056.png" alt="image-20231218214603028" /></p>
<p>除此之外还可以通过添加-e参数和\c转义序列来实现，具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e &#x27;lines\c&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182147836.png" alt="image-20231218214717809" /></p>
<h2 id="25-保存命令输出"><a class="markdownIt-Anchor" href="#25-保存命令输出"></a> 2.5 保存命令输出</h2>
<p>可以通过&gt;符号来告诉shell将输出重定向到文件中，具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello shell &gt; 01_helloshell</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182149376.png" alt="image-20231218214925317" /></p>
<p>​	上面用到了cat命令进行文件夹内容的查看，当然cat并不仅仅是用来查看文件夹内容的，cat的英文原型是concatenation（拼接），该命令会将出现在命令行上的文件的输出拼接在一起。后面会有章节对cat进行学习，这里先了解这么多。</p>
<h2 id="26-追加输出"><a class="markdownIt-Anchor" href="#26-追加输出"></a> 2.6 追加输出</h2>
<p>​	上面使用单括号进行了输出重定向，使用两个单括号进行追加输出。具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo hello shell &gt; 02_helloshell</span><br><span class="line">echo hello shell too &gt;&gt; 02_helloshell</span><br><span class="line">cat 02_helloshell</span><br></pre></td></tr></table></figure>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231218215813823.png" alt="image-20231218215813823" /></p>
<h2 id="27-获取文件的开始和结尾"><a class="markdownIt-Anchor" href="#27-获取文件的开始和结尾"></a> 2.7 获取文件的开始和结尾</h2>
<p>​	使用head和tail命令输出指定文件的开始和结尾前10行或者后10行的内容，也可以加入-number参数指定默认行数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head -1 02_helloshell</span><br><span class="line">tail -1 02_helloshell</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182201446.png" alt="image-20231218220159397" /></p>
<p>​	tail除了-number这一参数外，还可以有这样的格式 -n number，这样可以指定相对于文件末尾的行偏移。因此tail -n 10 file 会显示文件的最后10行，而如果以加号开头则表示文件起始的偏移数，例如tail -n +1 file会显示整个文件，tail -n +2 file会跳过第一行，以此类推。</p>
<h2 id="28-丢弃输出"><a class="markdownIt-Anchor" href="#28-丢弃输出"></a> 2.8 丢弃输出</h2>
<p>​	这个我还是很熟悉的，我前些日子搞了一下这个，通过将输出丢弃，从而起到了美化终端的作用。其实也挺简单的，就是输出重定向到/dev/null中。具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello shell too &gt; /dev/null</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182220976.png" alt="image-20231218222037949" /></p>
<h2 id="29-将输出作为输入管道"><a class="markdownIt-Anchor" href="#29-将输出作为输入管道"></a> 2.9 将输出作为输入(管道)</h2>
<p>管道符 | ，可以将上一个命令的输出作为输入传给下一个命令，具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 02_helloshell | grep too</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182224603.png" alt="image-20231218222447569" /></p>
<p>tee可以保留输出前的副本，上面的管道可以省略步骤，但是呢，如果想要查看中间步骤的结果要怎么办呢，那就是tee命令了，tee可以将管道分成两个一模一样的流，一个用来写入文件，一个用来继续向下传递，具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 02_helloshell | tee 03_tee | grep too</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182230184.png" alt="image-20231218223034147" /></p>
<h2 id="210-以输出为参数连接两个程序"><a class="markdownIt-Anchor" href="#210-以输出为参数连接两个程序"></a> 2.10 以输出为参数连接两个程序</h2>
<p>​	<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312190736817.png" alt="image-20231219073617761" />	如上图所示，可以通过find命令查找上面的三个文件，那如何将这些输入引入rm 从而删除呢，rm只能以命令行参数的形式获取文件名，所以像下面这种方式是不对的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name &#x27;0*&#x27; | rm </span><br></pre></td></tr></table></figure>
<p>​	那应该如何操作呢，其实也不难，只需使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mtext>即可，</mtext></mrow><annotation encoding="application/x-tex">()即可，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mclose">)</span><span class="mord cjk_fallback">即</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">，</span></span></span></span>()会被替换成所包含的命令输出，具体示例如下所示</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $(find -name &#x27;0*&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312190742576.png" alt="image-20231219074243540" /></p>
<p>可以看到输出就变成了命令行参数，所以可以通过下面的命令来删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm $(find -name &#x27;0*&#x27;)</span><br></pre></td></tr></table></figure>
<h1 id="3-标准输入"><a class="markdownIt-Anchor" href="#3-标准输入"></a> 3 标准输入</h1>
<h2 id="31获取文件输入"><a class="markdownIt-Anchor" href="#31获取文件输入"></a> 3.1获取文件输入</h2>
<p>​	这个其实比较简单，标准输出的符号是&gt;，那相对的标准输入的符号肯定就是&lt;了，但是我目前并不理解这个&lt;的实际用法是什么，以后如果学习到了再来进行弥补。</p>
<h2 id="32-获得脚本输入"><a class="markdownIt-Anchor" href="#32-获得脚本输入"></a> 3.2 获得脚本输入</h2>
<p>​	使用&lt;&lt;两个箭头来从命令行，而非文件重定向输入文本，如果放在shell脚本中，可以同时包含数据和代码，一个具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grep $1 &lt;&lt;EOF</span><br><span class="line">111 1</span><br><span class="line">222 2</span><br><span class="line">333 3</span><br><span class="line">444 4</span><br><span class="line">555 5</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312192029903.png" alt="image-20231219202905867" /></p>
<p>​		上面这个shell脚本有两个地方要注意的，第一个是$1。这个表示脚本输入的第一个参数，而后面的&lt;&lt;表示我们想要创建一个临时的输入源，==EOF是上面最重要的一个点，我之前一直以为他是开始和结束的标志，而实际上并不是，在&lt;&lt;后面可以是任意的字符串，只要最后的结束也是这个字符串即可==。</p>
<p>​	仍旧需要注意的是，在&lt;&lt;内部的这些内容，都是可以被解释的，例如如果内部输入了一个$1，那就会被转换为输入的第一个字符，那要如何避免这个情况呢，其实也很简单，那就是给EOF加上‘’单引号，表示不用执行扩展。</p>
<h2 id="33-获取用户输入"><a class="markdownIt-Anchor" href="#33-获取用户输入"></a> 3.3 获取用户输入</h2>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312192038960.png" alt="image-20231219203837889" /></p>
<p>​	可以通过read命令进行用户输入的获取，就比如上面的RPE变量，通过输入之后再读取出来。</p>
<h1 id="4-执行命令"><a class="markdownIt-Anchor" href="#4-执行命令"></a> 4 执行命令</h1>
<h2 id="41-运行程序"><a class="markdownIt-Anchor" href="#41-运行程序"></a> 4.1 运行程序</h2>
<p>​	bash的基本操作就是载入并运行程序，其他都是一些准备工作，除了shell的变量之外还有循环控制语句、判断以及各种控制输入和输出的方法，但是上面的这些描述仅仅只是锦上添花而已，所以这时候就应该想一些内容了，程序到底是从哪里开始运行的呢。</p>
<p>​	bash使用名为￥PATH的shell变量来定位这些可执行文件，￥PATH变量包含了一个目录列表，各个目录之间以冒号：进行分割，bash在这些目录中查找命令行上指定的可执行文件，目录的顺序很重要，会根据PATH变量中定义的顺序依次查找，选择所找到的第一个同名的可执行文件。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312210733311.png" alt="image-20231221073336242" /></p>
<p>​	赋予可执行权限的命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x name</span><br></pre></td></tr></table></figure>
<h2 id="42-执行多个命令"><a class="markdownIt-Anchor" href="#42-执行多个命令"></a> 4.2 执行多个命令</h2>
<p>​	方法一：不停的输入，Linux系统足够先进，在运行上一个命令的同时允许你继续输入，因此可以将命令依次输入进去即可。</p>
<p>​	方法二：将多个命令写入脚本中，运行这个脚本即可</p>
<p>​	方法三：依次执行这些命令，只需要使用分号将这些命令分隔开然后输入即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long ; medium ; short</span><br></pre></td></tr></table></figure>
<p>​	这样无论前面的程序是否运行成功，都会继续执行后面的命令，如果想要确保前面的命令运行成功，可以用下面这种写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long &amp;&amp; medium &amp;&amp; short</span><br></pre></td></tr></table></figure>
<h2 id="43-同时执行多个命令"><a class="markdownIt-Anchor" href="#43-同时执行多个命令"></a> 4.3 同时执行多个命令</h2>
<p>​	可以在命令行的末尾加上一个&amp;符号，在后台运行起来，这样一来，就能够快速的同时执行三个命令了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long &amp;</span><br><span class="line">medium &amp;</span><br><span class="line">short </span><br></pre></td></tr></table></figure>
<p>或者也可以将他们放在一个单行，具体如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long &amp; medium &amp; short </span><br></pre></td></tr></table></figure>
<p>这里提一下bg命令,一个示例如下所示：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312210751415.png" alt="image-20231221075105359" /></p>
<p>​	这个脚本的作用很简单就是睡眠10秒钟，在睡眠的过程中使用ctrl+z暂停，需要注意的是这里是暂停，而不是中断或者停止，暂停是可以回复的，可以使用两个命令进行恢复命令，也就是fg和bg，这两个命令从名字就可以看出fg是放到前台，而bg是放到后台，但每个命令都能继续运行相应的脚本。</p>
<h2 id="44-了解命令是否成功运行"><a class="markdownIt-Anchor" href="#44-了解命令是否成功运行"></a> 4.4 了解命令是否成功运行</h2>
<p>​	shell变量中$?中保存着命令的退出状态，其取值范围为0-255，在编写shell脚本的时候，正确的做法是，如果一切正常，退出时候就会返回0，如果运行的过程中出错了，就会返回非0值，一个具体示例如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312210757591.png" alt="image-20231221075735514" /></p>
<p>​	可以看到睡眠十秒的程序被打断了，然后它的返回值为148，为非零值就表示没有正常退出，但要注意的是，退出状态的机会只有一次。</p>
<h2 id="45-无人值守下运行耗时作业"><a class="markdownIt-Anchor" href="#45-无人值守下运行耗时作业"></a> 4.5 无人值守下运行耗时作业</h2>
<p>​	这个很重要呀，就比如，我在我的电脑上运行服务器编译，当我的本地终端关掉之后，服务器的命令我想让他仍旧可以继续运行，放到后台当然也是一个很好的办法，但是终端关掉之后这个仍旧是退出了，所以本小节的nohup命令很是重要，nohup命令的效果只是设置子进程忽略hangup信号，但其仍旧可以被kail杀死，这当然是两回事。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./06_bg &amp;</span><br></pre></td></tr></table></figure>
<p>​	这样运行06进行睡眠，然后关掉终端，这个程序仍旧是在运行的。</p>
<h1 id="5-shell变量"><a class="markdownIt-Anchor" href="#5-shell变量"></a> 5 shell变量</h1>
<p>​	无论是什么编程语言，变量都是必不可少的一个，shell编程中也不例外，一般情况下，shell中的变量采用全大写的方式，变量不需要进行声明，直接使用即可，由于命令的区分困难，所以赋值语句前后都不能有空格，当然在文件名字中也不能出现=等于号。引用变量的时候要使用$美元符号，而赋值的时候不需要加上引用符。</p>
<h2 id="51-注释"><a class="markdownIt-Anchor" href="#51-注释"></a> 5.1 注释</h2>
<p>​	在shell中使用#作为注释，在#后面的一行不会被解释。</p>
<h2 id="52-提高脚本可读性"><a class="markdownIt-Anchor" href="#52-提高脚本可读性"></a> 5.2 提高脚本可读性</h2>
<ol>
<li>​	以四个空格为一个等级，不要使用tab指标符号。</li>
<li>尽可能的不要省略变量名称，利于后期的维护</li>
<li>每行的内容描述不完时可以使用\进行断行</li>
</ol>
<h2 id="53-变量的导出"><a class="markdownIt-Anchor" href="#53-变量的导出"></a> 5.3 变量的导出</h2>
<p>​	如果在一个脚本中定义了一个变量，其他脚本中是不能共享该变量的，如果想要共享这个变量需要使用export进行变量的导出。</p>
<h2 id="54查看所有的变量"><a class="markdownIt-Anchor" href="#54查看所有的变量"></a> 5.4查看所有的变量</h2>
<p>​	可以使用set或者env对变量进行查看，set可以查看定义的所有变量和值，而env是查看所有导出的变量。</p>
<h2 id="55在shell脚本中使用参数"><a class="markdownIt-Anchor" href="#55在shell脚本中使用参数"></a> 5.5在shell脚本中使用参数</h2>
<p>​	 使用$1 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mtext>来代替脚本中所使用的参数，当然要是有很多个，超过了十个以上的参数，那么需要用双括号引起来</mtext></mrow><annotation encoding="application/x-tex">2 来代替脚本中所使用的参数，当然要是有很多个，超过了十个以上的参数，那么需要用双括号引起来</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">替</span><span class="mord cjk_fallback">脚</span><span class="mord cjk_fallback">本</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">当</span><span class="mord cjk_fallback">然</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">很</span><span class="mord cjk_fallback">多</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">超</span><span class="mord cjk_fallback">过</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">十</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">那</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">双</span><span class="mord cjk_fallback">括</span><span class="mord cjk_fallback">号</span><span class="mord cjk_fallback">引</span><span class="mord cjk_fallback">起</span><span class="mord cjk_fallback">来</span></span></span></span>{10}</p>
<h2 id="56-获取参数的数量"><a class="markdownIt-Anchor" href="#56-获取参数的数量"></a> 5.6 获取参数的数量</h2>
<p>​	使用$#来获取脚本输入的数量，在限定输入参数的一些脚本中有用。</p>
<h1 id="6-shell逻辑和运算"><a class="markdownIt-Anchor" href="#6-shell逻辑和运算"></a> 6 shell逻辑和运算</h1>
<h2 id="61-算数运算"><a class="markdownIt-Anchor" href="#61-算数运算"></a> 6.1 算数运算</h2>
<p>​	使用$(())或者let进行算数运算，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COUNT=$((COUNT + 5 + MAX * 2))</span><br><span class="line">let COUNT+=&#x27;5+MAX*2&#x27;</span><br></pre></td></tr></table></figure>
<p>​	需要注意等于号两边不能有任何的空格，举一个反面例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COUNT = $((COUNT + 5 + MAX * 2))</span><br></pre></td></tr></table></figure>
<p>​	那么shell会解析成COUNT这个命令第一个参数是等于号，后面是运算。</p>
<h2 id="62-分支条件"><a class="markdownIt-Anchor" href="#62-分支条件"></a> 6.2 分支条件</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if [$# -lt 3 ]</span><br><span class="line">then</span><br><span class="line">	printf &quot;xxx&quot;</span><br><span class="line">elif [$# &gt; 3 ]</span><br><span class="line">then </span><br><span class="line">	printf &quot;xxx&quot;</span><br><span class="line">else</span><br><span class="line">    printf &quot;xxx&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>上面使用的是换行符号，其实也可以使用分号来替代上面的换行符。</p>
<h2 id="63-测试文件特性"><a class="markdownIt-Anchor" href="#63-测试文件特性"></a> 6.3 测试文件特性</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-b # 块设备文件</span><br><span class="line">-c # 字符设备文件</span><br><span class="line">-d # 目录文件</span><br><span class="line">-e # 文件是否存在</span><br><span class="line">-f # 普通文件</span><br><span class="line">-h # 链接符号文件</span><br><span class="line">-r # 可读文件</span><br><span class="line">-s # 文件大小不为空</span><br><span class="line">-w # 可写文件</span><br><span class="line">-x # 可执行文件</span><br></pre></td></tr></table></figure>
<p>也可以使用-a或者-o参数在判断内进行逻辑判断的组合，-a表示逻辑与，-o表示逻辑或</p>
<h2 id="64-多路分支"><a class="markdownIt-Anchor" href="#64-多路分支"></a> 6.4 多路分支</h2>
<p>​	如果有多个比较，如果只是简单的使用if elif else 则会显得非常啰嗦和重复，而更好的解决办法是case，一个case的示例如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case $FN in</span><br><span class="line">	1）xxx;;</span><br><span class="line">	2) xxx;;</span><br><span class="line">	3) xxx;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<p>​	case语句会扩展case和in之间的单词，然后依次匹配多种模式</p>
<h1 id="7-中级shell工具"><a class="markdownIt-Anchor" href="#7-中级shell工具"></a> 7 中级shell工具</h1>
<h2 id="71-在文件中查找字符串"><a class="markdownIt-Anchor" href="#71-在文件中查找字符串"></a> 7.1 在文件中查找字符串</h2>
<p>​	使用grep命令在文件中查找相关的字符串，一个具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep printf *.c</span><br></pre></td></tr></table></figure>
<p>​	这段shell代码的作用就是在本地的C程序中查找printf语句。</p>
<p>​	如果一个文件中出现了很多次的printtf，那会将这个文件打印很多遍，要如何只打印一遍呢，这个只需要-l参数即可，具体如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -l printf *.c</span><br></pre></td></tr></table></figure>
<p>​	如果只是想知道在某个文件中是否有这个字符，只需要使用-q参数即可，该参数的作用是将输入结果丢弃到/dev/null，然后通过$?查看即可。</p>
<p>不区分大小写的话要使用-i参数，具体示例如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i printf *.c</span><br></pre></td></tr></table></figure>
<p>​	那如何在压缩文件中搜索呢，其实也只能搜索是不是有这个文件，但不能得到相应的信息，就比如下面这样</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312222132396.png" alt="image-20231222213204345" /></p>
<p>​	我还以为能有好东西了，原来只是简单的搜索。</p>
<h2 id="72-保留部分行"><a class="markdownIt-Anchor" href="#72-保留部分行"></a> 7.2 保留部分行</h2>
<p>​	使用awk命令从命令行上指定的文件中读取数据，例如默认情况下ls -l的打印如下所示：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312222137695.png" alt="image-20231222213709584" />	可以通过下面这个命令只打印第一行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l | awk &#x27;&#123;print $1&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312222137811.png" alt="image-20231222213756694" /></p>
<p>​	而现在得到的结果也并不好，因为并没有相应的文件名，上面的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mtext>是第一行，那文件名是第几行呢，是最后一行，我们并不知道最后一行是多少，不要着急，有内建命令，在</mtext><mi>a</mi><mi>w</mi><mi>k</mi><mtext>中</mtext></mrow><annotation encoding="application/x-tex">1是第一行，那文件名是第几行呢，是最后一行，我们并不知道最后一行是多少，不要着急，有内建命令，在awk中</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">第</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">那</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">名</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">第</span><span class="mord cjk_fallback">几</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">呢</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">知</span><span class="mord cjk_fallback">道</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">多</span><span class="mord cjk_fallback">少</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">着</span><span class="mord cjk_fallback">急</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">建</span><span class="mord cjk_fallback">命</span><span class="mord cjk_fallback">令</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">在</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">中</span></span></span></span>NF表示最后一行的元素。所以这个命令可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l | awk &#x27;&#123;print $1,$NF&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312222142312.png" alt="image-20231222214203181" /></p>
<h2 id="73-压缩文件"><a class="markdownIt-Anchor" href="#73-压缩文件"></a> 7.3 压缩文件</h2>
<p>tar这个命令我用过很多次了，但好像我一直都不解其意，tar的英文全程是tape archive翻译成中文也就是磁带归档。</p>
<h2 id="74-find"><a class="markdownIt-Anchor" href="#74-find"></a> 7.4 find</h2>
<p>好像find并不是我想象中的那么简单，一个具体的示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name *gz -print -exec mv &#x27;&#123;&#125;&#x27; /home/topeet/ \;</span><br></pre></td></tr></table></figure>
<p>​	上面这句脚本前面很用以理解，那就是查找以gz结尾的文件，后面是print是必须要有的，打印正确，而-exec是找到文件之后要执行的命令，这里是mv，而后面的‘{}’就表示前面查找到的内容，再后面是移动到的位置，最后是\；这个不能缺少</p>
<p>​	可如果是软链接或者硬链接呢，上面的find查找到的只是文件名，并没有找到文件的根本位置，其实也很见到那，只需要加入一个-L参数即可，具体示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -L . -name *gz -print -exec mv &#x27;&#123;&#125;&#x27; /home/topeet/ \;</span><br></pre></td></tr></table></figure>
<p>​	那如何不区分大小写进行查找呢，其实也简单只需要将上面的-name 换位-iname即可，具体示例如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -L . -iname *gz -print -exec mv &#x27;&#123;&#125;&#x27; /home/topeet/ \;</span><br></pre></td></tr></table></figure>
<h2 id="75-函数"><a class="markdownIt-Anchor" href="#75-函数"></a> 7.5 函数</h2>
<p>​	三种不同的函数编写方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function usage ()</span><br><span class="line">&#123;</span><br><span class="line">	printf xxx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function usage &#123;</span><br><span class="line">	printf xxx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usage ()</span><br><span class="line">&#123;</span><br><span class="line">	printf xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	可以注意到保留字function或者（）必须出现，如果使用了function，那么（）就是可选的，一般情况下都使用第一种情况</p>
<h2 id="76-别名"><a class="markdownIt-Anchor" href="#76-别名"></a> 7.6 别名</h2>
<p>​	可以通过alias对一些常用命令进行重命名，默认情况下其实已经有一些别名了，如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312230714153.png" alt="image-20231223071432992" /></p>
<p>​	一个具体的示例如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias h=’ls -’</span><br></pre></td></tr></table></figure>
<h2 id="77-计算时间"><a class="markdownIt-Anchor" href="#77-计算时间"></a> 7.7 计算时间</h2>
<p>​	不建议使用time，建议使用bash内建的SECONDS变量，可以记录时间，具体如下所示：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312230726458.png" alt="image-20231223072615391" /></p>
<h1 id="8-简单的图形界面"><a class="markdownIt-Anchor" href="#8-简单的图形界面"></a> 8 简单的图形界面</h1>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/bin/bash</span> </span><br><span class="line">titlestr=&quot;选择一个选项&quot;  # 标题字符串</span><br><span class="line">backtitle=&quot;iTOP-RK3568构建脚本，http://www.topeet.com&quot;  # 返回标题，网站链接</span><br><span class="line">menustr=&quot;Compile image | uboot| kernel| recovery| buildroot | debian | yocto | all&quot;  # 菜单字符串</span><br><span class="line">TTY_X=$(($(stty size | awk &#x27;&#123;print $2&#125;&#x27;)-6))                    # 确定终端宽度</span><br><span class="line">TTY_Y=$(($(stty size | awk &#x27;&#123;print $1&#125;&#x27;)-6))                    # 确定终端高度</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选项数组，包含选项和对应的函数名</span></span><br><span class="line">choose+=(&quot;uboot&quot; &quot;build_uboot&quot;)</span><br><span class="line">choose+=(&quot;kernel&quot; &quot;build_kernel&quot;)</span><br><span class="line">choose+=(&quot;recovery&quot; &quot;build_recovery&quot;)</span><br><span class="line">choose+=(&quot;buildroot&quot; &quot;build_rootfs buildroot&quot;)</span><br><span class="line">choose+=(&quot;debian&quot; &quot;build_rootfs debian&quot;)</span><br><span class="line">choose+=(&quot;yocto&quot; &quot;build_rootfs yocto&quot;)</span><br><span class="line">choose+=(&quot;save&quot; &quot;build_save&quot;)</span><br><span class="line">choose+=(&quot;all&quot; &quot;build_all&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用whiptail创建菜单，保存用户选择的选项到变量OPTIONS中</span></span><br><span class="line">OPTIONS=$(whiptail --title &quot;$&#123;titlestr&#125;&quot; --backtitle &quot;$&#123;backtitle&#125;&quot; --notags \</span><br><span class="line">                            --menu &quot;$&#123;menustr&#125;&quot; &quot;$&#123;TTY_Y&#125;&quot; &quot;$&#123;TTY_X&#125;&quot; $((TTY_Y - 8))  \</span><br><span class="line">                            --cancel-button Exit --ok-button Select &quot;$&#123;choose[@]&#125;&quot; \</span><br><span class="line">                            3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3)</span><br><span class="line">echo $OPTIONS</span><br></pre></td></tr></table></figure>
<p>​	图像示例如下所示：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312250734246.png" alt="image-20231225073426133" />	然后进行简单的修改将脚本修改为两页。具体脚本内容如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/bin/bash</span> </span><br><span class="line">titlestr=&quot;选择一个选项&quot;  # 标题字符串</span><br><span class="line">backtitle=&quot;iTOP-RK3568构建脚本，http://www.topeet.com&quot;  # 返回标题，网站链接</span><br><span class="line">menustr=&quot;Compile image | uboot| kernel| recovery| buildroot | debian | yocto | all&quot;  # 菜单字符串</span><br><span class="line">TTY_X=$(($(stty size | awk &#x27;&#123;print $2&#125;&#x27;)-6))                    # 确定终端宽度</span><br><span class="line">TTY_Y=$(($(stty size | awk &#x27;&#123;print $1&#125;&#x27;)-6))                    # 确定终端高度</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一页选项数组，包含选项和对应的函数名</span></span><br><span class="line">choose_page1+=(&quot;uboot&quot; &quot;build_uboot&quot;)</span><br><span class="line">choose_page1+=(&quot;kernel&quot; &quot;build_kernel&quot;)</span><br><span class="line">choose_page1+=(&quot;recovery&quot; &quot;build_recovery&quot;)</span><br><span class="line">choose_page1+=(&quot;save&quot; &quot;build_save&quot;)</span><br><span class="line">choose_page1+=(&quot;all&quot; &quot;build_all&quot;)</span><br><span class="line">choose_page1+=(&quot;rootfs&quot; &quot;build_rootfs&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第二页选项数组，包含选项和对应的函数名</span></span><br><span class="line">choose_page2+=(&quot;buildroot&quot; &quot;build_rootfs buildroot&quot;)</span><br><span class="line">choose_page2+=(&quot;debian&quot; &quot;build_rootfs debian&quot;)</span><br><span class="line">choose_page2+=(&quot;yocto&quot; &quot;build_rootfs yocto&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用whiptail创建第一页菜单，保存用户选择的选项到变量OPTIONS中</span></span><br><span class="line">OPTIONS=$(whiptail --title &quot;$&#123;titlestr&#125;&quot; --backtitle &quot;$&#123;backtitle&#125;&quot; --notags \</span><br><span class="line">                    --menu &quot;$&#123;menustr&#125;&quot; &quot;$&#123;TTY_Y&#125;&quot; &quot;$&#123;TTY_X&#125;&quot; $((TTY_Y - 8))  \</span><br><span class="line">                    --cancel-button Exit --ok-button Select &quot;$&#123;choose_page1[@]&#125;&quot; \</span><br><span class="line">                    3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据用户选择的选项，判断是否需要显示第二页菜单</span></span><br><span class="line">if [[ $OPTIONS == &quot;rootfs&quot; ]]; then</span><br><span class="line">    # 使用whiptail创建第二页菜单，保存用户选择的选项到变量OPTIONS中</span><br><span class="line">    OPTIONS=$(whiptail --title &quot;$&#123;titlestr&#125;&quot; --backtitle &quot;$&#123;backtitle&#125;&quot; --notags \</span><br><span class="line">                        --menu &quot;$&#123;menustr&#125;&quot; &quot;$&#123;TTY_Y&#125;&quot; &quot;$&#123;TTY_X&#125;&quot; $((TTY_Y - 8))  \</span><br><span class="line">                        --cancel-button Exit --ok-button Select &quot;$&#123;choose_page2[@]&#125;&quot; \</span><br><span class="line">                        3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3)</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo $OPTIONS</span><br></pre></td></tr></table></figure>
<p>这是第一页的内容：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312250743408.png" alt="image-20231225074324294" />	这是第二页的内容：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312250744974.png" alt="image-20231225074424898" />	还有许多要改的内容，就比如上面的标题，然后那个提示文字等等，这些都需要改，慢慢来吧，最后对该命令的介绍进行总结：当我们需要在终端界面中创建交互式的对话框和菜单时，Whiptail是一个非常有用的命令行工具。它提供了一种简单的方式来创建和显示对话框、消息框、输入框、菜单等，并且可以捕获用户的选择和输入。下面我将详细介绍Whiptail命令及其使用方法。</p>
<p>Whiptail命令的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whiptail [选项] [标题] [高度] [宽度] [默认值]</span><br></pre></td></tr></table></figure>
<p>选项可以用来配置对话框的外观和行为，标题是对话框的标题栏文本，高度和宽度指定对话框的尺寸，而默认值是可选的，用于设置输入框的默认值。</p>
<p>下面是Whiptail命令中常用的选项：</p>
<ul>
<li><code>--title &lt;文本&gt;</code>：设置对话框的标题。</li>
<li><code>--backtitle &lt;文本&gt;</code>：设置对话框的返回标题，通常用来显示相关的信息或链接。</li>
<li><code>--yesno &lt;文本&gt; &lt;高度&gt; &lt;宽度&gt;</code>：显示一个简单的是/否对话框，用户可以选择是或否。</li>
<li><code>--msgbox &lt;文本&gt; &lt;高度&gt; &lt;宽度&gt;</code>：显示一个简单的消息框，只用于显示信息，没有用户选择。</li>
<li><code>--inputbox &lt;文本&gt; &lt;高度&gt; &lt;宽度&gt; [默认值]</code>：显示一个输入框，用户可以输入文本。</li>
<li><code>--passwordbox &lt;文本&gt; &lt;高度&gt; &lt;宽度&gt;</code>：显示一个密码输入框，用户输入的内容会被隐藏。</li>
<li><code>--menu &lt;文本&gt; &lt;高度&gt; &lt;宽度&gt; &lt;菜单项1&gt; &lt;菜单项2&gt; ...</code>：显示一个菜单，用户可以从选项中选择一个。</li>
<li><code>--checklist &lt;文本&gt; &lt;高度&gt; &lt;宽度&gt; &lt;菜单项1&gt; &lt;菜单项2&gt; ...</code>：显示一个复选框菜单，用户可以选择多个选项。</li>
<li><code>--radiolist &lt;文本&gt; &lt;高度&gt; &lt;宽度&gt; &lt;菜单项1&gt; &lt;菜单项2&gt; ...</code>：显示一个单选框菜单，用户可以从选项中选择一个。</li>
<li><code>--textbox &lt;文件&gt; &lt;高度&gt; &lt;宽度&gt;</code>：显示一个只读文本框，用于显示文件中的内容。</li>
</ul>
<p>除了上述选项之外，Whiptail还提供了其他一些选项和功能，例如<code>--yes-button</code>、<code>--no-button</code>、<code>--defaultno</code>、<code>--nocancel</code>等，用于自定义对话框的按钮和默认行为。</p>
<p>使用Whiptail命令创建对话框时，用户的选择和输入可以通过标准输出返回，可以使用命令替换或重定向来捕获这些值。例如，可以将用户选择的选项保存到变量中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS=$(whiptail --menu &quot;请选择一个选项&quot; 10 40 3 \</span><br><span class="line">           &quot;1&quot; &quot;选项1&quot; \</span><br><span class="line">           &quot;2&quot; &quot;选项2&quot; \</span><br><span class="line">           &quot;3&quot; &quot;选项3&quot; \</span><br><span class="line">           3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3)</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，用户选择的选项将保存在变量<code>OPTIONS</code>中。使用<code>3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3</code>的重定向语法可以将标准输出和标准错误输出互换，这样可以将用户的选择输出到标准输出。</p>
<p>Whiptail还提供了一些辅助功能，例如获取终端的尺寸可以使用<code>stty size</code>命令，并结合算术运算来动态计算对话框的尺寸。这对于使对话框在不同终端上具有良好的可移植性非常有用。</p>
<p>总结一下，Whiptail是一个功能强大的命令行工具，用于创建交互式的对话框和菜单。它提供了当我们需要在终端界面中创建交互式的对话框和菜单时，Whiptail是一个非常有用的命令行工具。它提供了一种简单的方式来创建和显示对话框、消息框、输入框、菜单等，并且可以捕获用户的选择和输入。下面我将详细介绍Whiptail命令及其使用方法。</p>
<h1 id="9-实战"><a class="markdownIt-Anchor" href="#9-实战"></a> 9 实战</h1>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> tabstop=4 <span class="string">&quot;设置tab按键为四个字符</span></span><br><span class="line"><span class="string">set shiftwidth=4 &quot;</span>设置缩进为四个字符</span><br></pre></td></tr></table></figure>
<h2 id="91-在path-中查找程序"><a class="markdownIt-Anchor" href="#91-在path-中查找程序"></a> 9.1 在PATH 中查找程序</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">in_path 函数用于检查给定命令是否在指定路径中可执行</span></span><br><span class="line">in_path()</span><br><span class="line">&#123;</span><br><span class="line">    cmd=$1 ourpath=$2 result=1</span><br><span class="line">    oldIFS=$IFS IFS=&quot;:&quot;</span><br><span class="line">    for directory in $ourpath</span><br><span class="line">    do</span><br><span class="line">        if [ -x $directory/$cmd ] ; then</span><br><span class="line">            result=0</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">    IFS=$oldIFS</span><br><span class="line">    return $result</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">checkForCmdInPath 函数用于检查指定命令是否在环境变量 PATH 中可执行</span></span><br><span class="line">checkForCmdInPath()</span><br><span class="line">&#123;</span><br><span class="line">    var=$1</span><br><span class="line">    if [ &quot;$var&quot; != &quot;&quot; ] ; then</span><br><span class="line">        if [ &quot;$&#123;var:0:1&#125;&quot; = &quot;/&quot; ] ; then</span><br><span class="line">            if [ ! -x $var ] ; then</span><br><span class="line">                return 1</span><br><span class="line">            fi</span><br><span class="line">        elif ! in_path $var &quot;$PATH&quot; ; then</span><br><span class="line">            return 2</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查参数数量是否正确</span></span><br><span class="line">if [ $# -ne 1 ] ; then</span><br><span class="line">    echo &quot;使用方法: $0 命令&quot; &gt;&amp;2</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用 checkForCmdInPath 函数检查命令是否在 PATH 中</span></span><br><span class="line">checkForCmdInPath &quot;$1&quot;</span><br><span class="line">case $? in</span><br><span class="line">    0 ) echo &quot;$1 在 PATH 中找到&quot; ;;</span><br><span class="line">    1 ) echo &quot;$1 未找到或不可执行&quot; ;;</span><br><span class="line">    2 ) echo &quot;$1 未在 PATH 中找到&quot; ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
<p>​	<strong>知识点1：$用法</strong></p>
<ol>
<li><code>$1</code>：表示脚本中的第一个参数。在这个脚本中，<code>$1</code> 用于获取传递给脚本的命令参数。</li>
<li><code>$2</code>：表示脚本中的第二个参数。在 <code>in_path</code> 函数中，<code>$2</code> 用于获取传递给该函数的第二个参数，即路径。</li>
<li><code>$IFS</code>：表示内部字段分隔符（Internal Field Separator）。在脚本中，<code>$IFS</code> 用于保存原始的字段分隔符，并在后续代码中修改为 <code>:</code>，以便在路径中进行分隔。</li>
<li><code>$&#123;var:0:1&#125;</code>：表示对变量 <code>var</code> 进行字符串截取。<code>$&#123;var:0:1&#125;</code> 表示从字符串的第一个字符开始，截取长度为 1 的子字符串。在脚本中，<code>$&#123;var:0:1&#125;</code> 用于检查给定的命令是否是以 <code>/</code> 开头。</li>
<li><code>&quot;$var&quot;</code>：表示对变量进行引用。在脚本中，<code>&quot;$var&quot;</code> 用于将变量 <code>var</code> 的值作为字符串进行引用，以便在条件语句中进行判断。</li>
<li><code>$?</code>：表示上一个命令的退出状态。在脚本中，<code>$?</code> 用于获取 <code>checkForCmdInPath</code> 函数的返回值，即命令是否在 PATH 中可执行的状态。</li>
<li><code>$#</code> ：表示传递给脚本的参数数量。</li>
</ol>
<p>​	<strong>知识点2：if语法</strong></p>
<p>​		在Shell脚本中，<code>if</code>语句是用于执行条件判断的控制结构。它的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># 执行条件为真时的代码块</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># 执行条件为假时的代码块</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p><code>if</code>语句的工作原理如下：</p>
<ol>
<li>首先，<code>if</code>关键字标识条件语句的开始。</li>
<li>紧接着是一个条件表达式，用于判断条件的真假。条件表达式通常使用方括号 <code>[ ]</code> 来包裹，且表达式与方括号之间需要有空格。</li>
<li>如果条件表达式的结果为真（非零），则执行<code>then</code>关键字后面的代码块。代码块可以是单行命令或多行代码块，可以包含任何Shell支持的命令。</li>
<li>如果条件表达式的结果为假（零），则跳过<code>then</code>代码块，执行<code>else</code>关键字后面的代码块（可选）。如果没有<code>else</code>部分，整个<code>if</code>语句结束。</li>
<li>最后，通过<code>fi</code>关键字结束整个<code>if</code>语句块。</li>
</ol>
<p>在条件表达式中，可以使用各种条件判断运算符和Shell的内置命令来进行条件判断。常用的条件判断运算符包括：</p>
<ul>
<li><code>-eq</code>：等于</li>
<li><code>-ne</code>：不等于</li>
<li><code>-gt</code>：大于</li>
<li><code>-lt</code>：小于</li>
<li><code>-ge</code>：大于等于</li>
<li><code>-le</code>：小于等于</li>
<li><code>-z</code>：判断字符串是否为空</li>
<li><code>-n</code>：判断字符串是否非空</li>
<li><code>-f</code>：判断文件是否存在且为普通文件</li>
<li><code>-d</code>：判断路径是否存在且为目录</li>
<li><code>-x</code>：判断文件或路径是否可执行</li>
</ul>
<p><strong>知识点3：case语句</strong></p>
<p>在Shell脚本中，<code>case</code>语句是一种用于多重条件判断的控制结构。它的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> expression <span class="keyword">in</span></span><br><span class="line">    pattern1)</span><br><span class="line">        <span class="comment"># 匹配 pattern1 执行的代码块</span></span><br><span class="line">        ;;</span><br><span class="line">    pattern2)</span><br><span class="line">        <span class="comment"># 匹配 pattern2 执行的代码块</span></span><br><span class="line">        ;;</span><br><span class="line">    pattern3)</span><br><span class="line">        <span class="comment"># 匹配 pattern3 执行的代码块</span></span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="comment"># 默认情况（即未匹配任何模式）执行的代码块</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p><code>case</code>语句的工作原理如下：</p>
<ol>
<li>首先，<code>case</code>关键字标识多重条件语句的开始。</li>
<li><code>expression</code>是要进行匹配的表达式或变量。通常，<code>expression</code>是一个变量，你希望根据其值进行多重条件判断。</li>
<li>接下来，使用<code>in</code>关键字表示要开始进行模式匹配。</li>
<li>然后，每个模式使用圆括号<code>()</code>包括起来，并在每个模式后面加上<code>)</code>。</li>
<li>对于每个模式，如果<code>expression</code>的值与模式相匹配，则执行与该模式对应的代码块。代码块可以是单行命令或多行代码块，可以包含任何Shell支持的命令。</li>
<li>每个代码块的结尾需要使用两个分号<code>;;</code>表示结束。</li>
<li>如果<code>expression</code>的值未匹配任何模式，则执行<code>*)</code>后面的代码块（即默认情况）。这部分代码块是可选的。</li>
<li>最后，通过<code>esac</code>关键字结束整个<code>case</code>语句块。</li>
</ol>
<p>以下是一个具体的示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">fruit=<span class="string">&quot;apple&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$fruit</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">&quot;apple&quot;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;这是一个苹果&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="string">&quot;orange&quot;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;这是一个橘子&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="string">&quot;banana&quot;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;这是一个香蕉&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;未知的水果&quot;</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们使用变量<code>fruit</code>作为匹配表达式。根据<code>$fruit</code>的值，<code>case</code>语句会依次进行模式匹配。如果<code>$fruit</code>的值匹配到某个模式（例如，“apple”），则执行与该模式对应的代码块（输出&quot;这是一个苹果&quot;）。如果<code>$fruit</code>的值未匹配到任何模式，则执行默认情况下的代码块（输出&quot;未知的水果&quot;）。</p>
<h2 id="92-验证输入仅限字母和数字"><a class="markdownIt-Anchor" href="#92-验证输入仅限字母和数字"></a> 9.2 验证输入：仅限字母和数字</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数，用于验证字符串是否仅由字母和数字组成</span></span><br><span class="line"><span class="function"><span class="title">volidAlphaNum</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"># 通过sed命令将输入的字符串中的非字母和数字字符替换为空字符串</span></span><br><span class="line">    validchars=<span class="string">&quot;<span class="subst">$(echo $1 | sed &#x27;s/[^[:alnum:]]//g&#x27;)</span>&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 比较替换后的字符串与原始输入的字符串是否相等</span></span><br><span class="line">    <span class="comment"># 如果相等，说明输入的字符串仅由字母和数字组成，返回0</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$validchars</span>&quot;</span> = <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> 0</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment"># 如果不相等，说明输入的字符串包含非字母和数字字符，返回1</span></span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出提示并读取用户输入</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;请输入输入内容:&quot;</span></span><br><span class="line"><span class="built_in">read</span> input</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用验证函数检查输入的内容是否仅由字母和数字组成</span></span><br><span class="line"><span class="keyword">if</span> ! volidAlphaNum <span class="string">&quot;<span class="variable">$input</span>&quot;</span> ; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># 如果验证函数返回非0，说明输入的内容包含非字母和数字字符</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;错误：输入内容必须仅包含字母和数字&quot;</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># 如果验证函数返回0，说明输入的内容仅由字母和数字组成</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;输入内容有效&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本正常结束，退出状态码为0</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>
<p><strong>知识点</strong>1 <strong>read</strong></p>
<p>在Shell脚本中，<code>read</code> 是一个用于读取用户输入的命令。它允许脚本暂停执行，等待用户从标准输入（通常是键盘）输入一行文本，并将输入的内容保存到一个或多个变量中。</p>
<p><code>read</code> 命令的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> [options] [variable ...]</span><br></pre></td></tr></table></figure>
<p>其中，<code>options</code> 是一些可选的参数，用于控制 <code>read</code> 命令的行为。<code>variable</code> 是一个或多个变量名，用于保存用户输入的值。</p>
<p>以下是一些常用的 <code>read</code> 命令选项：</p>
<ul>
<li><code>-p prompt</code>：显示一个提示符，提示用户输入。<code>prompt</code> 是要显示的提示信息，可以是字符串或变量。示例：<code>read -p &quot;Enter your name: &quot; name</code></li>
<li><code>-s</code>：静默模式，用户输入内容时不回显在终端上，适用于输入密码等敏感信息。示例：<code>read -s password</code></li>
<li><code>-n num</code>：读取指定数量的字符后立即返回，而不需要等待用户按下回车键。<code>num</code> 是要读取的字符数。示例：<code>read -n 1 key</code> 读取一个字符。</li>
<li><code>-t timeout</code>：设置等待用户输入的超时时间（秒），如果超过指定时间没有输入，则 <code>read</code> 命令返回一个非零的退出状态码。示例：<code>read -t 5 input</code> 设置等待时间为5秒。</li>
</ul>
<p><strong>知识点2 sed</strong></p>
<p>​	在Shell脚本中，<code>sed</code>（Stream Editor）是一种流式文本编辑器，用于处理和转换文本流。它可以读取输入流中的文本，根据指定的编辑命令对文本进行修改，并将结果输出到标准输出流。</p>
<p><code>sed</code> 命令的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [options] <span class="string">&#x27;command&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>其中，<code>options</code> 是一些可选的参数，用于控制 <code>sed</code> 命令的行为。<code>'command'</code> 是一个或多个编辑命令，用于指定要对文本进行的操作。<code>file</code> 是要处理的输入文件。</p>
<p>以下是一些常用的 <code>sed</code> 命令选项：</p>
<ul>
<li><code>-n</code>：禁止默认输出，只输出经过编辑处理后的结果。如果没有使用 <code>-n</code>，则 <code>sed</code> 会默认将每一行的结果输出到标准输出。</li>
<li><code>-e script</code>：指定要执行的编辑命令。可以在一个 <code>sed</code> 命令中指定多个编辑命令，使用 <code>-e</code> 分隔它们。</li>
<li><code>-i</code>：原地编辑，直接修改输入文件，而不是将结果输出到标准输出。使用 <code>-i</code> 选项时可以指定备份文件的扩展名，备份文件会保留原始文件的副本。</li>
<li><code>-r</code>（或 <code>-E</code>）：启用扩展的正则表达式语法，可以使用更强大的正则表达式功能。</li>
</ul>
<p><code>sed</code> 命令的编辑命令由一个或多个操作组成，每个操作由一个地址和一个命令组成。地址指定了要应用命令的行范围，命令指定了要对行执行的操作。</p>
<p>以下是一些常用的 <code>sed</code> 命令操作：</p>
<ul>
<li><code>s/regexp/replacement/</code>：替换操作，将与正则表达式 <code>regexp</code> 匹配的文本替换为 <code>replacement</code>。例如：<code>sed 's/apple/orange/' file</code> 将文件中的 “apple” 替换为 “orange”。</li>
<li><code>p</code>：打印操作，输出指定范围内的行。例如：<code>sed -n '1,10p' file</code> 打印文件中的前10行。</li>
<li><code>d</code>：删除操作，删除指定范围内的行。例如：<code>sed '5,10d' file</code> 删除文件中的第5到第10行。</li>
<li><code>i\text</code>：插入操作，向指定行之前插入文本。例如：<code>sed '3i\This is a new line.' file</code> 在文件的第3行之前插入一行文本。</li>
<li><code>a\text</code>：追加操作，向指定行之后追加文本。例如：<code>sed '3a\This is a new line.' file</code> 在文件的第3行之后追加一行文本。</li>
</ul>
<p><code>sed 's/[^[:alnum:]]//g'</code>：这是 <code>sed</code> 命令的一部分，用于对输入的文本进行替换操作。</p>
<ol>
<li><code>s/[^[:alnum:]]//g</code> 是一个替换命令，用于将输入中的非字母数字字符替换为空字符串。</li>
<li><code>[^[:alnum:]]</code> 是一个正则表达式，表示匹配任何非字母数字字符。</li>
<li><code>//</code> 是替换命令的分隔符，用于指定要替换的文本为空字符串。</li>
<li><code>g</code> 是替换命令的标志，表示要替换所有匹配项，而不是只替换第一个匹配项。</li>
</ol>
<h2 id="93-规范日期格式"><a class="markdownIt-Anchor" href="#93-规范日期格式"></a> 9.3 规范日期格式</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">mounthNumToName</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">        1 ) month=<span class="string">&quot;Jan&quot;</span>;; 2 ) month=<span class="string">&quot;Feb&quot;</span> ;;</span><br><span class="line">        3 ) month=<span class="string">&quot;Mar&quot;</span>;; 4 ) month=<span class="string">&quot;Apr&quot;</span>;;</span><br><span class="line">        5 ) month=<span class="string">&quot;May&quot;</span>;; 6 ) month=<span class="string">&quot;Jun&quot;</span>;;</span><br><span class="line">        7 ) month=<span class="string">&quot;Jul&quot;</span>;; 8 ) month=<span class="string">&quot;Aug&quot;</span>;;</span><br><span class="line">        9 ) month=<span class="string">&quot;Sep&quot;</span>;; 10 ) month=<span class="string">&quot;Oct&quot;</span>;;</span><br><span class="line">        11 ) month=<span class="string">&quot;Nov&quot;</span>;; 12 ) month=<span class="string">&quot;Dec&quot;</span>;;</span><br><span class="line">        * ) <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$0</span>: 未知的月份数值 <span class="variable">$1</span>&quot;</span> &gt;&amp;2</span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查参数数量是否正确</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -ne 3 ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;用法: <span class="variable">$0</span> 月份 日  年份&quot;</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查年份是否为4位数字</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$3</span> -le 99 ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$0</span>: 预期为4位数字的年份&quot;</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查月份是否为纯数字</span></span><br><span class="line"><span class="keyword">if</span> [ -z $(<span class="built_in">echo</span> <span class="variable">$1</span>|sed <span class="string">&#x27;s/[[:digit:]]//g&#x27;</span>) ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># 如果是纯数字，则调用函数将月份转换为对应的名称</span></span><br><span class="line">    mounthNumToName <span class="variable">$1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># 如果不是纯数字，则将首字母大写，后续字母小写</span></span><br><span class="line">    month=<span class="string">&quot;<span class="subst">$(echo $1| cut -c1|tr &#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27;)</span>&quot;</span></span><br><span class="line">    month=<span class="string">&quot;$month<span class="subst">$(echo $1|cut -c2-3 | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;)</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$month</span> <span class="variable">$2</span> <span class="variable">$3</span></span><br></pre></td></tr></table></figure>
<h2 id="94-美化多位数字"><a class="markdownIt-Anchor" href="#94-美化多位数字"></a> 9.4 美化多位数字</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nicenumber--给定一个数字，以逗号分隔的形式显示它。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  需要DD（小数点分隔符）和TD（千位分隔符）被实例化。如果指定了第二个参数，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  则将输出回显到标准输出。</span></span><br><span class="line"></span><br><span class="line">nicenumber()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">注意，我们假设“.”是此脚本输入值中的小数分隔符。</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">输出值中的小数分隔符是“.”，除非用户使用-d标志指定。</span></span><br><span class="line"></span><br><span class="line">  integer=$(echo $1 | cut -d. -f1)        # 小数点左边</span><br><span class="line">  decimal=$(echo $1 | cut -d. -f2)        # 小数点右边</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">检查我们的数字是否除了整数部分之外还有其他部分。</span></span><br><span class="line">  if [ &quot;$decimal&quot; != &quot;$1&quot; ]; then</span><br><span class="line">    # 存在小数部分，因此将其包含在内。</span><br><span class="line">    result=&quot;$&#123;DD:= &#x27;.&#x27;&#125;$decimal&quot;</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  thousands=$integer</span><br><span class="line"></span><br><span class="line">  while [ $thousands -gt 999 ]; do</span><br><span class="line">    remainder=$(($thousands % 1000))    # 三个最低有效位</span><br><span class="line">    </span><br><span class="line">    # 我们需要“remainder”是三位数。我们需要添加零吗？</span><br><span class="line">    while [ $&#123;#remainder&#125; -lt 3 ] ; do  # 强制前导零</span><br><span class="line">      remainder=&quot;0$remainder&quot;</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    result=&quot;$&#123;TD:=&quot;,&quot;&#125;$&#123;remainder&#125;$&#123;result&#125;&quot;    # 从右向左构建</span><br><span class="line">    thousands=$(($thousands / 1000))    # 如果有余数，则向左移动</span><br><span class="line">  done</span><br><span class="line"></span><br><span class="line">  nicenum=&quot;$&#123;thousands&#125;$&#123;result&#125;&quot;</span><br><span class="line">  if [ ! -z $2 ] ; then</span><br><span class="line">    echo $nicenum</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DD=&quot;.&quot;  # 小数点分隔符，用于分隔整数和小数部分</span><br><span class="line">TD=&quot;,&quot;  # 千位分隔符，用于每三位数分隔</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始主脚本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=================</span></span><br><span class="line"></span><br><span class="line">while getopts &quot;d:t:&quot; opt; do</span><br><span class="line">  case $opt in</span><br><span class="line">    d ) DD=&quot;$OPTARG&quot;    ;;</span><br><span class="line">    t ) TD=&quot;$OPTARG&quot;    ;;</span><br><span class="line">  esac</span><br><span class="line">done</span><br><span class="line">shift $(($OPTIND - 1))</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入验证</span></span><br><span class="line">if [ $# -eq 0 ] ; then</span><br><span class="line">  echo &quot;Usage: $(basename $0) [-d c] [-t c] numeric_value&quot;</span><br><span class="line">  echo &quot;  -d 指定小数点分隔符（默认为&#x27;.&#x27;）&quot;</span><br><span class="line">  echo &quot;  -t 指定千位分隔符（默认为&#x27;,&#x27;）&quot;</span><br><span class="line">  exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">nicenumber $1 1         # 第二个参数强制nicenumber将输出回显。</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
<p><strong>重点1：</strong><br />
<code>getopts</code> 是一个用于处理命令行选项的 Bash 内置命令。它可以帮助你解析和处理脚本或命令的命令行参数。<code>getopts</code> 在循环中使用，每次循环处理一个选项，并将其与相应的参数关联起来。</p>
<p><code>getopts</code> 命令的语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getopts</span> optstring variable [args]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>optstring</code>：定义了脚本支持的选项列表，每个选项由一个字母表示。如果选项后面带有冒号（<code>:</code>），则表示该选项需要附加参数。</li>
<li><code>variable</code>：用于存储当前解析的选项的变量名。</li>
<li><code>args</code>：可选参数，用于指定要解析的命令行参数列表。如果省略，则默认使用脚本的命令行参数。</li>
</ul>
<p>在使用 <code>getopts</code> 时，你需要在脚本中使用一个 <code>while</code> 循环来处理每个选项。在循环中，<code>getopts</code> 会将当前解析的选项存储在 <code>variable</code> 变量中，并将附加的参数存储在特殊变量 <code>OPTARG</code> 中。</p>
<p>以下是一个简单的示例，展示了如何使用 <code>getopts</code> 处理命令行选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="string">&quot;a:b:&quot;</span> opt; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$opt</span> <span class="keyword">in</span></span><br><span class="line">    a)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;选项 -a，参数为 <span class="variable">$OPTARG</span>&quot;</span></span><br><span class="line">      ;;</span><br><span class="line">    b)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;选项 -b，参数为 <span class="variable">$OPTARG</span>&quot;</span></span><br><span class="line">      ;;</span><br><span class="line">    \?)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;无效的选项： -<span class="variable">$OPTARG</span>&quot;</span></span><br><span class="line">      ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行脚本并传递选项和参数</span></span><br><span class="line"><span class="comment"># ./script.sh -a value1 -b value2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 选项 -a，参数为 value1</span></span><br><span class="line"><span class="comment"># 选项 -b，参数为 value2</span></span><br></pre></td></tr></table></figure>
<p>在这个示例中，脚本使用 <code>getopts</code> 解析了两个选项 <code>-a</code> 和 <code>-b</code>，并将它们的参数打印出来。如果脚本遇到无效的选项，则会打印出错误信息。</p>
<p>总之，<code>getopts</code> 命令是一个用于处理命令行选项的工具，可以帮助你编写更灵活和可配置的脚本。</p>
<p><strong>重点2：</strong></p>
<ul>
<li><code>-z string</code>：判断给定的字符串是否为空。如果字符串为空，则条件为真。</li>
<li><code>-n string</code>：判断给定的字符串是否非空。如果字符串非空，则条件为真。</li>
<li><code>string1 = string2</code>：判断两个字符串是否相等。如果相等，则条件为真。</li>
<li><code>string1 != string2</code>：判断两个字符串是否不相等。如果不相等，则条件为真。</li>
<li><code>file1 -eq file2</code>：判断两个文件是否具有相同的设备号和 inode 号。如果相同，则条件为真。</li>
<li><code>file1 -nt file2</code>：判断文件 1 是否比文件 2 更新（修改时间更晚）。如果是，则条件为真。</li>
<li><code>file1 -ot file2</code>：判断文件 1 是否比文件 2 更旧（修改时间更早）。如果是，则条件为真。</li>
<li><code>num1 -eq num2</code>：判断两个数字是否相等。如果相等，则条件为真。</li>
<li><code>num1 -ne num2</code>：判断两个数字是否不相等。如果不相等，则条件为真。</li>
<li><code>num1 -lt num2</code>：判断 num1 是否小于 num2。如果是，则条件为真。</li>
<li><code>num1 -le num2</code>：判断 num1 是否小于等于 num2。如果是，则条件为真。</li>
<li><code>num1 -gt num2</code>：判断 num1 是否大于 num2。如果是，则条件为真。</li>
<li><code>num1 -ge num2</code>：判断 num1 是否大于等于 num2。如果是，则条件为真。</li>
</ul>
<h2 id="95-验证整数输入"><a class="markdownIt-Anchor" href="#95-验证整数输入"></a> 9.5 验证整数输入</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">validint--验证整数输入，允许负数。</span></span><br><span class="line"></span><br><span class="line">validint()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">验证第一个字段，并将其与提供的最小值 <span class="variable">$2</span> 和/或最大值 <span class="variable">$3</span> 进行比较：</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">如果值不在范围内或不仅由数字组成，则失败。</span></span><br><span class="line"></span><br><span class="line">  number=&quot;$1&quot;;      min=&quot;$2&quot;;      max=&quot;$3&quot;</span><br><span class="line"></span><br><span class="line">  if [ -z $number ] ; then</span><br><span class="line">    echo &quot;您未输入任何内容。请输入一个数字。&quot; &gt;&amp;2 ; return 1</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">第一个字符是否为 <span class="string">&#x27;-&#x27;</span> 符号？</span></span><br><span class="line">  if [ &quot;$&#123;number%$&#123;number#?&#125;&#125;&quot; = &quot;-&quot; ] ; then</span><br><span class="line">    testvalue=&quot;$&#123;number#?&#125;&quot; # 提取除第一个字符外的所有字符进行测试。</span><br><span class="line">  else</span><br><span class="line">    testvalue=&quot;$number&quot;</span><br><span class="line">  fi</span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">创建一个没有数字的版本，用于测试。</span></span><br><span class="line">  nodigits=&quot;$(echo $testvalue | sed &#x27;s/[[:digit:]]//g&#x27;)&quot;</span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">检查是否存在非数字字符。</span></span><br><span class="line">  if [ ! -z $nodigits ] ; then</span><br><span class="line">    echo &quot;无效的数字格式！只允许数字，不允许逗号、空格等。&quot; &gt;&amp;2</span><br><span class="line">    return 1</span><br><span class="line">  fi</span><br><span class="line">  </span><br><span class="line">  if [ ! -z $min ] ; then</span><br><span class="line">    # 输入值是否小于最小值？</span><br><span class="line">    if [ &quot;$number&quot; -lt &quot;$min&quot; ] ; then</span><br><span class="line">      echo &quot;$number 太小了：最小可接受值为 $min&quot; &gt;&amp;2</span><br><span class="line">      return 1</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">  if [ ! -z $max ] ; then</span><br><span class="line">    # 输入值是否大于最大值？</span><br><span class="line">    if [ &quot;$number&quot; -gt &quot;$max&quot; ] ; then</span><br><span class="line">      echo &quot;您的值太大了：最大可接受值为 $max&quot; &gt;&amp;2</span><br><span class="line">      return 1</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">  return 0</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入验证</span></span><br><span class="line">if validint &quot;$1&quot; &quot;$2&quot; &quot;$3&quot; ; then</span><br><span class="line">  echo &quot;输入是一个在您约束条件内的有效整数&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h2 id="96-验证浮点数输入"><a class="markdownIt-Anchor" href="#96-验证浮点数输入"></a> 9.6 验证浮点数输入</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">validfloat--检测一个数字是否是有效的浮点数。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  注意，此脚本无法接受科学计数法（1.304e5）表示的浮点数。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为了测试输入值是否是有效的浮点数，我们需要将该值拆分为两部分：整数部分和小数部分。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们可以测试第一部分，看它是否是有效的整数，然后再测试第二部分是否是有效的 &gt;=0 整数。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因此，-30.5 被认为是有效的，但 -30.-8 不是。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要在此脚本中包含另一个 shell 脚本作为一部分，可以使用 <span class="string">&quot;.&quot;</span> 来源符号。非常简单。</span></span><br><span class="line"></span><br><span class="line">. validint   # Bourne shell 的方式，引入 validint 函数</span><br><span class="line"></span><br><span class="line">validfloat()</span><br><span class="line">&#123;</span><br><span class="line">  fvalue=&quot;$1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">检查输入的数字是否有小数点。</span></span><br><span class="line">  if [ ! -z $(echo $fvalue | sed &#x27;s/[^.]//g&#x27;) ] ; then</span><br><span class="line"></span><br><span class="line">    # 提取小数点前的部分（比如 &#x27;3.14&#x27; 中的 &#x27;3&#x27;）。</span><br><span class="line">    decimalPart=&quot;$(echo $fvalue | cut -d. -f1)&quot;</span><br><span class="line"></span><br><span class="line">    # 提取小数点后的数字部分（比如 &#x27;3.14&#x27; 中的 &#x27;14&#x27;）。</span><br><span class="line">    fractionalPart=&quot;$&#123;fvalue#*\.&#125;&quot;</span><br><span class="line"></span><br><span class="line">    # 首先测试小数部分，即小数点左边的部分。</span><br><span class="line"></span><br><span class="line">    if [ ! -z $decimalPart ] ; then</span><br><span class="line">      # &quot;!&quot; 反转了测试逻辑，所以下面的条件表示 &quot;如果不是有效的整数&quot;</span><br><span class="line">      if ! validint &quot;$decimalPart&quot; &quot;&quot; &quot;&quot; ; then</span><br><span class="line">        return 1</span><br><span class="line">      fi </span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 现在测试小数部分（小数点右边的值）。</span><br><span class="line">    # 首先，小数点后面不能有负号，比如 33.-11，所以我们要检查小数部分是否包含负号。</span><br><span class="line">    if [ &quot;$&#123;fractionalPart%$&#123;fractionalPart#?&#125;&#125;&quot; = &quot;-&quot; ] ; then</span><br><span class="line">      echo &quot;无效的浮点数：小数点后面不允许有负号&quot; &gt;&amp;2  # &gt;&amp;2 将输出发送到 stderr。</span><br><span class="line">      return 1</span><br><span class="line">    fi </span><br><span class="line">    if [ &quot;$fractionalPart&quot; != &quot;&quot; ] ; then </span><br><span class="line">      # 如果小数部分不是有效的整数...</span><br><span class="line">      if ! validint &quot;$fractionalPart&quot; &quot;0&quot; &quot;&quot; ; then</span><br><span class="line">        return 1</span><br><span class="line">      fi</span><br><span class="line">    fi</span><br><span class="line">  else </span><br><span class="line">    # 如果整个值只是 &quot;-&quot;，也是不允许的。</span><br><span class="line">    if [ &quot;$fvalue&quot; = &quot;-&quot; ] ; then</span><br><span class="line">      echo &quot;无效的浮点格式。&quot; &gt;&amp;2 ; return 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 最后，检查剩余的数字是否是有效的整数。</span><br><span class="line">    if ! validint &quot;$fvalue&quot; &quot;&quot; &quot;&quot; ; then</span><br><span class="line">      return 1</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if validfloat $1 ; then</span><br><span class="line">  echo &quot;$1 是一个有效的浮点数&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2024
        <i class="ri-heart-fill heart_icon"></i> chai
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="热爱学习的未来酱"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E7%94%9F%E6%B4%BB">生活</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%AD%A6%E4%B9%A0">学习</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E7%91%9E%E8%8A%AF%E5%BE%AE">瑞芯微</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/C%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E5%AD%A6%E4%B9%A0">C语言高级学习</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=0&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>