<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="永远年轻，永远热泪盈眶" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 热爱学习的未来酱</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="热爱学习的未来酱" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover3.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">热爱学习的未来酱</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '向上的路，并不拥挤。拥挤是因为，大部分人选择了安逸', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-3-9-链接过程-3-重定位"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/3-9-%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B-3-%E9%87%8D%E5%AE%9A%E4%BD%8D/"
    >3.9-链接过程(3)-重定位</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/3-9-%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B-3-%E9%87%8D%E5%AE%9A%E4%BD%8D/" class="article-date">
  <time datetime="2023-09-04T23:47:04.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">c高级编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="3-9-1-重定位"><a href="#3-9-1-重定位" class="headerlink" title="3.9.1 重定位"></a>3.9.1 重定位</h1><p>重定位是链接过程中的核心步骤之一，它的主要目的是修正指令中的符号地址，使得程序可以正确地访问和调用其他模块或库中的函数和变量。</p>
<p>在链接过程中，重定位完成以下任务：</p>
<ol>
<li>地址空间分配：<ul>
<li>在链接过程中，编译器和链接器会为程序分配地址空间，包括代码段、数据段、堆、栈等。</li>
<li>重定位阶段负责将各个模块的代码段和数据段中的地址修正为最终的实际地址，确保模块之间的地址空间不发生冲突。</li>
</ul>
</li>
<li>符号解析：<ul>
<li>在链接过程中，各个模块之间可能存在对函数和变量的引用或调用。</li>
<li>重定位阶段负责解析这些引用，找到对应的函数或变量的实际地址，并将其填充到引用的位置，以便程序在执行时可以正确访问和调用。</li>
</ul>
</li>
</ol>
<h1 id="3-9-2-重定位过程1"><a href="#3-9-2-重定位过程1" class="headerlink" title="3.9.2 重定位过程1"></a>3.9.2 重定位过程1</h1><p>重定位过程是在链接过程中完成的，它涉及多个步骤和数据结构：</p>
<ol>
<li>汇编阶段：<ul>
<li>在汇编阶段，汇编器会将源代码转换为机器代码，并生成目标模块。</li>
<li>当汇编器遇到未定义的符号（外部定义的函数、变量、库函数引用等），它会认为这些符号在其他地方定义，不会报错。</li>
<li>汇编器会收集这些未定义符号，并生成一个重定位表（relocation table），用于告诉链接器这些符号不在当前模块中定义，可能在其他文件或库中定义，需要在链接时进行解析。</li>
</ul>
</li>
<li>段与重定位表：<ul>
<li>目标模块通常被划分为多个段，如代码段、数据段等。</li>
<li>在每个段中，可能存在对其他文件或库中定义的函数或变量的引用。</li>
<li>汇编器会为每个段生成相应的重定位表，记录需要重定位的符号及其对应的位置信息。</li>
</ul>
</li>
<li>重定位表的生成：<ul>
<li>重定位表是一个数据结构，用于记录需要进行重定位的各种符号。</li>
<li>对于每个需要重定位的符号，重定位表会记录符号的类型（函数或变量）、位置信息（段偏移量或地址）等。</li>
<li>链接器在链接过程中会根据重定位表的信息，解析和修正这些符号的地址，使得它们指向正确的位置。</li>
</ul>
</li>
</ol>
<h1 id="3-9-3-重定位过程2"><a href="#3-9-3-重定位过程2" class="headerlink" title="3.9.3 重定位过程2"></a>3.9.3 重定位过程2</h1><p>重定位表是在ELF文件中用于记录需要进行重定位的符号及其相关信息的数据结构。在一个可重定位的ELF文件中，每个需要重定位的段都会有一个对应的重定位表，例如<code>.rel.text</code>和<code>.rel.data</code>。</p>
<p>重定位表本身也是一个段，因此也被称为重定位段。通过查看重定位表，我们可以了解在链接过程中需要进行重定位的符号以及它们在代码中的偏移位置。</p>
<p>重定位表的构成如下所示（对于32位ELF文件）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf32_Rel</span> &#123;</span></span><br><span class="line">    Elf32_Addr r_offset;  <span class="comment">// 需要重定位的项在代码中的偏移位置</span></span><br><span class="line">    Elf32_Word r_info;    <span class="comment">// 重定位类型和符号索引</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，<code>r_offset</code>字段指定了需要重定位的项在代码中的偏移位置，<code>r_info</code>字段包含了重定位类型和符号索引。</p>
<p>通过解析重定位表中的信息，链接器可以根据符号索引找到对应的符号表项，并根据重定位类型进行相应的修正，使得符号的地址指向正确的位置。</p>
<p>要查看一个ELF文件的重定位表，可以使用工具如<code>arm-linux-gnueabi-objdump</code>或<code>arm-linux-gnueabi-readelf</code>，并指定相应的选项来打印出重定位表的内容和相关信息。</p>
<h1 id="3-9-4-重定位过程3"><a href="#3-9-4-重定位过程3" class="headerlink" title="3.9.4 重定位过程3"></a>3.9.4 重定位过程3</h1><p>在链接过程中，重定位过程涉及修改符号地址，通过读取各个目标文件中的重定位信息（重定位表）来进行符号重定位，即修改指令中的符号地址。</p>
<p>具体步骤如下：</p>
<ol>
<li>读取重定位信息：<ul>
<li>链接器会读取每个目标文件中的各个段的重定位信息，通常是通过读取重定位表来获取这些信息。</li>
<li>重定位表记录了需要进行重定位的符号在代码中的位置以及相关的重定位类型和符号索引。</li>
</ul>
</li>
<li>符号重定位：<ul>
<li>链接器根据重定位表中的信息，确定各个重定位符号的新地址。</li>
<li>这些新地址的计算通常涉及到基址的概念，即新的段基址加上段内的偏移量来得到重定位地址。</li>
<li>重定位地址计算公式为：重定位地址 &#x3D; 新段基址 + 段内偏移。</li>
</ul>
</li>
<li>修改指令中的符号地址：<ul>
<li>链接器对目标文件中的指令进行扫描，在指令中定位到需要进行重定位的符号地址的位置。</li>
<li>然后，链接器会将指令中的符号地址修改为相应的重定位地址，以完成符号的重定位。</li>
</ul>
</li>
<li>形成新的符号表：<ul>
<li>在重定位过程中，链接器会根据符号索引和重定位信息，确定每个重定位符号的新地址。</li>
<li>链接器会将这些新地址形成一个新的符号表，用于在最终的可执行文件或共享库中进行符号解析和访问。</li>
</ul>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BF%90%E8%A1%8C/" rel="tag">程序的编译、链接和运行</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-3-8-链接过程-2-符号解析-强符号与弱符号"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/3-8-%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B-2-%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90-%E5%BC%BA%E7%AC%A6%E5%8F%B7%E4%B8%8E%E5%BC%B1%E7%AC%A6%E5%8F%B7/"
    >3.8-链接过程(2)-符号解析-强符号与弱符号</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/3-8-%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B-2-%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90-%E5%BC%BA%E7%AC%A6%E5%8F%B7%E4%B8%8E%E5%BC%B1%E7%AC%A6%E5%8F%B7/" class="article-date">
  <time datetime="2023-09-04T23:47:02.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">c高级编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="3-8-1-编译器对符号的处理规则"><a href="#3-8-1-编译器对符号的处理规则" class="headerlink" title="3.8.1 编译器对符号的处理规则"></a>3.8.1 编译器对符号的处理规则</h1><p>符号（Symbol）是在程序中引用或定义的标识符，通常是函数名、全局变量名或其他标识符。符号具有以下几种不同的概念：</p>
<ul>
<li><p>强符号（Strong Symbol）：强符号是指在程序中只有一个定义的符号。当多个目标文件中存在同名的强符号时，链接器会产生冲突并报错。通常，全局变量</p>
<p>和初始化的全局变量是强符号。每个强符号在整个程序中只能有一个定义。</p>
</li>
</ul>
<p>函数名：函数名是程序中表示函数的符号。函数名通常是强符号，因为每个函数在整个程序中只能有一个定义。</p>
<p>初始化的全局变量：初始化的全局变量是指在程序中定义并显式初始化的全局变量。它们通常是强符号，因为每个初始化的全局变量在整个程序中只能有一个定义。</p>
<ul>
<li><p>弱符号（Weak Symbol）：弱符号是指在程序中可以存在多个定义的符号。当多个目标文件中存在同名的弱符号时，链接器通常会选择其中一个定义，而其他</p>
<p>的定义会被忽略。弱符号通常用于具有默认实现或可选实现的函数或变量。未初始化的全局变量也是弱符号</p>
</li>
</ul>
<p>​	未初始化的全局变量：未初始化的全局变量是指在程序中定义但没有显式初始化的全局变量。它们通常是弱符号，因为多个目标文件中可以存在同名的未初始化全局变量，链接器会在运行时将它们合并为一个共享的内存区域。</p>
<p>编译器对符号的处理规则如下：</p>
<ol>
<li>强符号：<ul>
<li>强符号不允许多次定义，每个强符号在整个程序中只能有一个定义。</li>
<li>强符号和弱符号可以共存，即在程序中可以同时存在强符号和弱符号。</li>
<li>当强符号和弱符号共存时，强符号会覆盖弱符号。在链接时，如果存在多个同名符号，链接器会选择强符号作为最终的定义。</li>
</ul>
</li>
<li>弱符号：<ul>
<li>编译器允许多个弱符号在程序中存在。</li>
<li>在编译期间，编译器并不知道弱符号所占用的空间大小。为了解决这个问题，编译器会使用一个未定义的COMMON符号来代替弱符号的定义。COMMON符号表示一个未初始化的全局变量或未分配内存的占位符。</li>
<li>在链接期间，链接器会比较多个文件中的弱符号，并选择占用空间最大的弱符号作为最终的定义。这意味着在多个目标文件中存在同名弱符号时，链接器会选择占用空间最大的弱符号来作为最终的定义。</li>
</ul>
</li>
</ol>
<h1 id="3-8-2-弱符号与BSS段"><a href="#3-8-2-弱符号与BSS段" class="headerlink" title="3.8.2 弱符号与BSS段"></a>3.8.2 弱符号与BSS段</h1><p>弱符号和BSS段在编译和链接过程中的关系如下：</p>
<ol>
<li>不同目标文件中的BSS段：<ul>
<li>BSS段是用于存储未初始化的全局变量和静态变量的内存段。</li>
<li>在编译阶段，编译器将未初始化的全局变量和静态变量标记为BSS段，并分配了对应的空间。但是，BSS段中的变量并没有实际的初始化值。</li>
<li>在链接阶段，多个目标文件中的BSS段会被合并到一个统一的BSS段中，以便在最终的可执行文件中分配内存。</li>
</ul>
</li>
<li>可重定位目标文件的链接：<ul>
<li>在可重定位目标文件的链接过程中，链接器不会确定弱符号的最终定义。因此，未初始化的全局变量和弱符号不会放在BSS段中，而是放在临时的COMMON块中。</li>
<li>COMMON块是一个临时的内存区域，用于存放未初始化的全局变量和弱符号。在链接器最终确定了弱符号的定义后，它们将被分配到最终的BSS段中。</li>
</ul>
</li>
<li>可执行目标文件的链接：<ul>
<li>在可执行目标文件的链接过程中，链接器已经确定了弱符号的最终定义。</li>
<li>弱符号被分配了一个最大的空间，并放置在BSS段中。这是因为在链接过程中，链接器选择了占用空间最大的弱符号作为最终的定义，并为其分配了足够的内存空间。</li>
</ul>
</li>
</ol>
<h1 id="3-8-3-强引用与弱引用"><a href="#3-8-3-强引用与弱引用" class="headerlink" title="3.8.3 强引用与弱引用"></a>3.8.3 强引用与弱引用</h1><p>强引用和弱引用是指对符号的引用的特性，而符号本身代表一个地址，可以是函数或变量的名称。</p>
<p>在一个文件内，当我们定义一个函数或变量时，其函数名或变量名就是一个符号。在另一个文件中，如果我们通过函数名或变量名来调用该函数或引用该变量，就称为对符号的引用。引用的本质是使用符号的地址。</p>
<p>特点如下：</p>
<ol>
<li>强引用：<ul>
<li>当一个符号引用被标记为强引用时，如果在链接时找不到该符号的定义，链接过程将会报错。</li>
<li>强引用表示对符号的依赖性较高，如果缺少了符号的定义，程序无法正常链接和执行。</li>
</ul>
</li>
<li>弱引用：<ul>
<li>当一个符号引用被标记为弱引用时，如果这个符号没有定义，链接过程不会报错，而是在运行时可能会导致错误。</li>
<li>弱引用表示对符号的依赖性较低，如果缺少了符号的定义，链接过程仍然可以继续，但在运行时可能会遇到未定义符号的错误。</li>
</ul>
</li>
</ol>
<p>根据符号引用是否为0（即空指针或空引用），我们可以在程序中判断是否执行某个函数。如果符号引用为0，表示符号没有定义，可以根据这个判断来避免执行相应的函数。</p>
<h1 id="3-8-4-弱引用的应用"><a href="#3-8-4-弱引用的应用" class="headerlink" title="3.8.4 弱引用的应用"></a>3.8.4 弱引用的应用</h1><p>弱引用在以下场景中常被应用：</p>
<ol>
<li>库：<ul>
<li>在使用库时，可以将库中的函数定义为弱引用。</li>
<li>这样，在链接时，如果存在相同名称的函数定义，链接器会选择强引用的函数定义，但如果找不到强引用的函数定义，就会选择弱引用的函数定义。</li>
<li>这使得我们可以自定义函数来覆盖库中的函数，使用自定义版本的库函数。</li>
</ul>
</li>
<li>扩展功能模块：<ul>
<li>当程序依赖于某些可选的扩展功能模块时，可以将这些模块的引用定义为弱引用。</li>
<li>这样，在链接时，如果这些模块不存在或被删除，程序仍然可以正常链接和运行，因为对这些模块的引用是弱引用，链接器不会报错。</li>
</ul>
</li>
<li>多线程：<ul>
<li>在多线程编程中，有时需要根据运行时环境的不同来决定是否开启多线程模式。</li>
<li>例如，在Linux下，可以将<code>pthread_create</code>函数定义为弱引用。</li>
<li>运行时，程序可以判断链接的是单线程版本的glibc库还是多线程版本的glibc库，从而决定是否启用多线程模式。</li>
</ul>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BF%90%E8%A1%8C/" rel="tag">程序的编译、链接和运行</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-3-7-链接过程-1-地址空间分配与链接脚本"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/3-7-%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B-1-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E4%B8%8E%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC/"
    >3.7-链接过程(1)-地址空间分配与链接脚本</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/3-7-%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B-1-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E4%B8%8E%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC/" class="article-date">
  <time datetime="2023-09-04T23:47:01.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">c高级编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="3-7-1-链接的重要性"><a href="#3-7-1-链接的重要性" class="headerlink" title="3.7.1 链接的重要性"></a>3.7.1 链接的重要性</h1><p>链接（Linking）是将多个可重定位目标文件合并、组装成可执行目标文件或共享库的过程。链接器（Linker）是执行链接操作的工具或程序。</p>
<p>链接的主要目的是解决多个目标文件之间的符号引用和地址重定位问题，使得程序能够正确地执行。</p>
<p>链接过程包括以下主要步骤：</p>
<ol>
<li>地址空间分配：链接器将可执行目标文件加载到内存中的适当地址空间中。这涉及到分配代码段、数据段、堆栈等内存区域，并为每个目标文件分配适当的地址范围。</li>
<li>符号解析：在链接过程中，符号解析是一个重要的步骤。符号解析的目的是解决符号的引用关系，将符号引用与符号定义进行匹配。在符号解析阶段，链接器会根据符号的绑定属性（如全局、局部、弱符号）来确定符号的可见性和重复定义规则。<ul>
<li>强符号（Strong Symbols）：具有全局绑定属性的符号，优先级高于弱符号。如果存在多个强符号同名定义，链接器会报错。</li>
<li>弱符号（Weak Symbols）：具有弱绑定属性的符号，允许在多个目标文件中重复定义。如果存在多个弱符号同名定义，并且没有对应的强符号，链接器会选择其中一个定义。</li>
</ul>
</li>
<li>重定位（Relocation）：重定位是将目标文件中的地址引用转换为最终可执行文件中的实际地址的过程。在链接过程中，由于目标文件中的地址是相对于各自的节（Section）的起始地址的偏移量，因此需要进行重定位操作，将这些相对地址转换为绝对地址。重定位过程涉及到修正目标文件中的跳转、调用和数据访问等指令，使得它们指向正确的地址。</li>
</ol>
<h1 id="3-7-2-地址空间分配"><a href="#3-7-2-地址空间分配" class="headerlink" title="3.7.2 地址空间分配"></a>3.7.2 地址空间分配</h1><p>地址空间分配是链接过程中的一项重要任务，它确定了各个目标文件中不同段（如代码段、数据段、bss段）在最终可执行目标文件中的位置和大小。</p>
<p>以下是地址空间分配的一般步骤：</p>
<ol>
<li>扫描所有目标文件：链接器会逐个扫描所有目标文件，包括主程序文件和库文件。对于每个目标文件，链接器会读取其文件头部和段表等信息。</li>
<li>获取段信息：链接器从各个目标文件的段表中获取各个段的信息，包括段的类型（如代码段、数据段、bss段）、大小和对齐等属性。每个目标文件中的段表记录了该文件中各个段的位置和长度。</li>
<li>确定链接地址：链接器会指定一个链接地址（linkaddr）作为起始地址，用于存放最终可执行目标文件的各个段。</li>
<li>合并同类型段：链接器按照段的类型（代码段、数据段、bss段）顺序，将各个目标文件中相同类型的段进行合并。对于代码段和数据段，链接器会根据链接地址和各个段的偏移量（offset）计算出最终的段地址。</li>
<li>重新计算段长度和位置：合并后，链接器会重新计算各个段的长度和位置。对于代码段和数据段，它们的长度是各个段的长度之和；而对于bss段，它的长度通常为0，因为bss段存放的是未初始化的全局变量和静态变量。</li>
<li>处理库文件：链接器还会处理库文件，将库文件中的目标模块合并到最终的可执行目标文件中。这涉及到符号解析、重定位和符号表的更新等操作。</li>
</ol>
<h1 id="3-7-3-创建全局符号表"><a href="#3-7-3-创建全局符号表" class="headerlink" title="3.7.3 创建全局符号表"></a>3.7.3 创建全局符号表</h1><p>创建全局符号表是链接过程的一项关键任务，它的目的是将各个目标文件中的符号收集起来，并统一保存在一个全局符号表中。</p>
<p>以下是创建全局符号表的一般步骤：</p>
<ol>
<li>扫描所有目标文件：链接器会逐个扫描所有目标文件，包括主程序文件和库文件。对于每个目标文件，链接器会读取其符号表信息。</li>
<li>收集符号：链接器从每个目标文件的符号表中收集符号信息。符号表中包含了各个目标文件中定义和引用的符号的名称、属性和地址等信息。</li>
<li>统一放入全局符号表：链接器将从各个目标文件中收集到的符号统一放入一个全局符号表中。全局符号表是链接器维护的一个数据结构，用于保存所有目标文件中的符号信息。</li>
<li>相对零地址偏移：在创建全局符号表时，符号的地址仍然是相对于零地址的偏移量。这是因为在链接过程的后续阶段，还需要进行重定位操作，将符号的地址转换为最终可执行目标文件中的实际地址。</li>
</ol>
<h1 id="3-7-4-链接脚本"><a href="#3-7-4-链接脚本" class="headerlink" title="3.7.4 链接脚本"></a>3.7.4 链接脚本</h1><p>不同的代码段在链接过程中的组装是由链接脚本（Linker Script）来规定的。链接脚本是一个文本文件，其中包含了链接器的指令和规则，用于指导链接器如何组装各个代码段。</p>
<p>链接脚本通常包含以下信息：</p>
<ol>
<li>组装顺序：链接脚本规定了各个代码段的组装顺序。根据链接脚本的指定顺序，链接器会按照代码段的顺序将它们组装到最终可执行目标文件中。</li>
<li>起始地址：链接脚本指定了各个代码段在最终可执行目标文件中的起始地址。链接器会根据链接脚本中的地址规定，将各个代码段放置到相应的地址位置。</li>
<li>位置对齐：链接脚本还规定了代码段的位置对齐要求。根据链接脚本中指定的对齐规则，链接器会确保代码段在最终可执行目标文件中按照规定的对齐边界进行放置。</li>
<li>输出格式和运行平台：链接脚本可以指定输出可执行文件的格式和运行平台。这些信息对于生成符合特定格式和平台要求的可执行目标文件非常重要。</li>
<li>入口地址：链接脚本可以指定可执行目标文件的入口地址。入口地址是程序执行的起始点，在加载和执行可执行文件时，操作系统会将控制权转移到指定的入口地址处开始执行程序。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">oUTPUT_FORMAT( <span class="string">&quot;elf32-littlearm”</span></span><br><span class="line"><span class="string">&quot;</span>elf32-bigarm”</span><br><span class="line"><span class="string">&quot;elf32-littlearm”)</span></span><br><span class="line"><span class="string">;输出ELF麻件格式</span></span><br><span class="line"><span class="string">OUTPUT_ARCH( “arm”)</span></span><br><span class="line"><span class="string">;输出可执行文件的运行平台为arm</span></span><br><span class="line"><span class="string">ENTRY(_start)</span></span><br><span class="line"><span class="string">;程序入口地址</span></span><br><span class="line"><span class="string">SECTIONS</span></span><br><span class="line"><span class="string">;各段描述</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">.= Ox60000000;</span></span><br><span class="line"><span class="string">;代码段起始地址</span></span><br><span class="line"><span class="string">.text:&#123;*(.text)&#125;</span></span><br><span class="line"><span class="string">;代码段描述:所有.o文件的. text</span></span><br><span class="line"><span class="string">.= Ox60200000;</span></span><br><span class="line"><span class="string">;数据段的起始地址</span></span><br><span class="line"><span class="string">.data: &#123;*(. data)&#125;</span></span><br><span class="line"><span class="string">;数据段描述</span></span><br><span class="line"><span class="string">.bss :&#123;*(. bss)&#125;</span></span><br><span class="line"><span class="string">; BSS段描述</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>在SECTIONS部分，代码段的起始地址为0x60000000，紧接着是代码段的描述；数据段的起始地址为0x60200000，后面是数据段的描述；最后是BSS段的描述。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BF%90%E8%A1%8C/" rel="tag">程序的编译、链接和运行</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-3-6-编译过程-3-符号表"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/3-6-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B-3-%E7%AC%A6%E5%8F%B7%E8%A1%A8/"
    >3.6-编译过程(3)-符号表</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/3-6-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B-3-%E7%AC%A6%E5%8F%B7%E8%A1%A8/" class="article-date">
  <time datetime="2023-09-04T23:46:59.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">c高级编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="3-6-1-符号表"><a href="#3-6-1-符号表" class="headerlink" title="3.6.1 符号表"></a>3.6.1 符号表</h1><p>符号表在编译过程中起到了重要的作用，主要用来保存源程序中各种符号（如变量、函数、类、常量等）的相关信息，如地址值、类型、占用空间的大小等。</p>
<p>符号表的主要作用如下：</p>
<ol>
<li>辅助语义检查：符号表可以用于辅助编译器进行语义检查。编译器通过符号表来验证标识符的合法性、类型匹配等语义规则，以确保源程序的语义正确性。例如，编译器在进行类型检查时可以通过符号表中记录的类型信息来判断赋值操作是否合法。</li>
<li>辅助代码生成：符号表在代码生成阶段发挥重要作用。编译器通过符号表来进行地址和空间的分配，以确定变量和函数在内存中的位置。符号表中记录的地址信息可以用于生成汇编代码或机器代码时的地址计算。例如，编译器可以根据符号表中的地址信息为变量分配栈空间或静态数据区空间。</li>
<li>符号决议：符号表用于解析标识符的引用，即在程序中使用某个标识符时，找到该标识符的定义位置。编译器通过符号表中记录的定义位置信息来处理标识符的引用，以确保标识符在使用前已经被定义。符号决议阶段还包括解决标识符的作用域和命名空间等问题。</li>
<li>重定位：符号表用于链接器进行符号重定位。在多个目标文件进行链接时，链接器需要解析和处理目标文件中的符号引用。链接器通过符号表中记录的地址信息，将符号引用链接到正确的地址上，以确保最终生成的可执行文件能够正确地访问和使用各个目标文件中的符号。</li>
</ol>
<h1 id="3-6-2-elf文件和bin文件"><a href="#3-6-2-elf文件和bin文件" class="headerlink" title="3.6.2 elf文件和bin文件"></a>3.6.2 elf文件和bin文件</h1><p>ELF文件和BIN文件是两种不同的可执行文件格式。</p>
<p>BIN文件是一种纯粹的二进制文件，只包含机器码，没有附加的元数据信息。它通常被称为raw binary文件或镜像文件。BIN文件中的机器码是直接按照内存中的布局排列的，没有分节或分段的概念。常见的BIN文件格式还包括HEX文件，它以十六进制形式表示机器码。</p>
<p>而ELF文件（Executable and Linkable Format）是一种更为复杂的可执行文件格式。除了包含机器码之外，ELF文件还包含了一些额外的元数据信息，用于描述程序的结构、加载地址、运行地址等。ELF文件具有分节（Section）和分段（Segment）的概念，不同的节和段存储了不同的信息，如代码段、数据段、符号表、重定位表等。</p>
<p>ELF文件的结构包括以下几个重要的部分：</p>
<ol>
<li>ELF头（ELF Header）：位于文件的开头，包含了对整个ELF文件的描述信息，如文件类型、目标体系结构、入口地址等。</li>
<li>节表（Section Table）：记录了ELF文件中各个节的信息。每个节存储了特定类型的数据，例如代码、数据、符号表、重定位表等。节表中的每个表项描述了一个节的名称、大小、偏移量等信息。</li>
<li>段表（Segment Table）：记录了ELF文件中各个段的信息。段是逻辑上一组相关的节的集合，用于定义程序的内存布局。段表中的每个表项描述了一个段的类型、虚拟地址、文件偏移量等信息。</li>
<li>符号表（Symbol Table）：记录了程序中定义和引用的符号（如变量、函数、类等）的信息。符号表中的每个表项描述了一个符号的名称、类型、地址等信息。符号表在链接过程中用于解析符号引用和进行符号重定位。</li>
<li>重定位表（Relocation Table）：记录了需要进行符号重定位的位置和相关信息。重定位表在链接过程中用于调整代码和数据的位置，确保程序能够正确访问和使用符号。</li>
</ol>
<h1 id="3-6-3-readelf-s-和readelf-S-的区别"><a href="#3-6-3-readelf-s-和readelf-S-的区别" class="headerlink" title="3.6.3 readelf -s 和readelf -S 的区别"></a>3.6.3 readelf -s 和readelf -S 的区别</h1><p><code>readelf -s</code>和<code>readelf -S</code>是<code>readelf</code>命令的两个不同的选项，它们用于显示ELF文件中的不同部分信息。</p>
<ol>
<li><code>readelf -s</code>：该选项用于显示ELF文件的符号表（Symbol Table）。符号表记录了程序中定义和引用的符号（如变量、函数、类等）的信息。使用<code>readelf -s</code>命令可以列出符号表中的所有符号，包括符号的名称、类型、绑定属性、地址等信息。这对于进行符号分析、调试和动态链接等操作非常有用。</li>
<li><code>readelf -S</code>：该选项用于显示ELF文件的节表（Section Table）。节表记录了ELF文件中各个节的信息，每个节存储了特定类型的数据，如代码、数据、符号表、重定位表等。使用<code>readelf -S</code>命令可以列出节表中的所有节，包括节的名称、类型、大小、偏移量、虚拟地址等信息。这对于了解程序的内存布局、代码和数据段的大小以及节之间的关系非常有帮助。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/topeet/demo# readelf -s sub.o </span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 13 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS sub.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    2 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     9: 0000000000000000    24 FUNC    GLOBAL DEFAULT    1 add</span><br><span class="line">    10: 0000000000000018    22 FUNC    GLOBAL DEFAULT    1 sub</span><br><span class="line">    11: 000000000000002e    23 FUNC    GLOBAL DEFAULT    1 mul</span><br><span class="line">    12: 0000000000000045    23 FUNC    GLOBAL DEFAULT    1 div</span><br><span class="line">root@ubuntu:/home/topeet/demo# readelf -S sub.o </span><br><span class="line">There are 12 section headers, starting at offset 0x398:</span><br><span class="line"></span><br><span class="line">节头：</span><br><span class="line">  [号] 名称              类型             地址              偏移量</span><br><span class="line">       大小              全体大小          旗标   链接   信息   对齐</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000005c  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .data             PROGBITS         0000000000000000  0000009c</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 3] .bss              NOBITS           0000000000000000  0000009c</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .comment          PROGBITS         0000000000000000  0000009c</span><br><span class="line">       000000000000002c  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 5] .note.GNU-stack   PROGBITS         0000000000000000  000000c8</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 6] .note.gnu.propert NOTE             0000000000000000  000000c8</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 7] .eh_frame         PROGBITS         0000000000000000  000000e8</span><br><span class="line">       0000000000000098  0000000000000000   A       0     0     8</span><br><span class="line">  [ 8] .rela.eh_frame    RELA             0000000000000000  000002d0</span><br><span class="line">       0000000000000060  0000000000000018   I       9     7     8</span><br><span class="line">  [ 9] .symtab           SYMTAB           0000000000000000  00000180</span><br><span class="line">       0000000000000138  0000000000000018          10     9     8</span><br><span class="line">  [10] .strtab           STRTAB           0000000000000000  000002b8</span><br><span class="line">       0000000000000017  0000000000000000           0     0     1</span><br><span class="line">  [11] .shstrtab         STRTAB           0000000000000000  00000330</span><br><span class="line">       0000000000000067  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br><span class="line">root@ubuntu:/home/topeet/demo# </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3-6-3-符号类型和绑定属性"><a href="#3-6-3-符号类型和绑定属性" class="headerlink" title="3.6.3 符号类型和绑定属性"></a>3.6.3 符号类型和绑定属性</h1><p>符号类型和绑定属性是符号表中的两个重要概念，用于描述符号的特性和可见性。</p>
<ol>
<li>符号类型（Symbol Type）：符号类型描述了符号关联的实体类型，即符号表示的是什么。在符号表中常见的符号类型包括：</li>
</ol>
<ul>
<li>OBJECT（对象）：符号关联的是一个数据对象，如变量、数组或指针。</li>
<li>FUNC（函数）：符号关联到一个函数或过程。</li>
<li>SECTION（节）：符号关联到一个节的名字。</li>
<li>FILE（文件）：符号关联一个文件名。</li>
<li>NOTYPE（未指定类型）：符号的类型未指定，它常用于未定义的引用。</li>
</ul>
<p>2.绑定属性（Binding Attribute）：绑定属性描述了符号的可见性和重复定义的规则。在符号表中常见的绑定属性包括：</p>
<ul>
<li>LOCAL（局部）：局部符号只在目标文件内可见，多个目标文件可以有相同的局部符号名而不会冲突。</li>
<li>GLOBAL（全局）：全局符号在目标文件内部可见，也可以被其他文件引用。全局符号在整个程序中是可见的，但是不同文件中的全局符号名称不能重复。</li>
<li>WEAK（弱）：弱符号是一种特殊的全局符号，它可以在多个文件中重复定义。即使弱符号未定义，链接过程也不会报错，而是将其符号值设置为0。弱符号可以被强符号覆盖。</li>
</ul>
<h1 id="3-6-4-节索引"><a href="#3-6-4-节索引" class="headerlink" title="3.6.4 节索引"></a>3.6.4 节索引</h1><p>节索引（Section Index）是在符号表中使用的一个索引值，用于指示每个符号所在的节（Section）。</p>
<p>在目标文件中，包含了多个节（如代码节、数据节、符号表节等），用于存储不同类型的数据和信息。而符号表（Symbol Table）中保存了所有节的符号信息。</p>
<p>为了确定每个符号所在的具体节，符号表中的每个符号都使用一个节索引来表示其所在的节。节索引是一个非负整数，它对应着目标文件中节头表（Section Header Table）中的表项序号。</p>
<p>节头表是目标文件中的一部分，用于描述每个节的属性和位置等信息。每个节头表的表项都包含了该节的名称、类型、大小、偏移量等信息。通过符号表中的节索引，可以找到符号所属的具体节，并将该符号绑定到该节上。</p>
<p>在符号表中，还有几个特殊的节索引值：</p>
<ul>
<li>ABS：表示符号的绝对值，不需要进行重定位，即该符号的地址是绝对的。</li>
<li>UNDEF：表示未定义符号，即在当前模块中引用了该符号，但在其他地方定义。</li>
<li>COMMON：表示尚未分配位置的未初始化数据，通常用于全局未初始化的变量。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BF%90%E8%A1%8C/" rel="tag">程序的编译、链接和运行</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-3-5-编译过程-2-汇编过程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/3-5-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B-2-%E6%B1%87%E7%BC%96%E8%BF%87%E7%A8%8B/"
    >3.5-编译过程(2)-汇编过程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/3-5-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B-2-%E6%B1%87%E7%BC%96%E8%BF%87%E7%A8%8B/" class="article-date">
  <time datetime="2023-09-04T23:46:58.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">c高级编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="3-5-1-汇编过程"><a href="#3-5-1-汇编过程" class="headerlink" title="3.5.1 汇编过程"></a>3.5.1 汇编过程</h1><p>汇编过程的基本流程如下：</p>
<ol>
<li>词法分析：在这个阶段，汇编器将输入的源文件（通常以.s为后缀，如main.s）进行词法分析。词法分析器将源代码分解为一个个的词法单元，如指令、寄存器、标识符等，并生成词法单元流。</li>
<li>语法分析：在语法分析阶段，汇编器使用词法单元流进行语法分析。语法分析器根据语法规则将词法单元流解析为语法结构，并构建相应的语法树。语法分析过程中还会生成符号表，用于记录和管理标识符、变量和常量等信息。</li>
<li>组装：在组装阶段，汇编器将语法树转换为可执行的目标文件。这个过程包括将汇编指令转换为机器指令、填充符号表、生成重定位表等。组装器的主要任务是将汇编代码转换为机器代码，并生成可执行目标文件。</li>
<li>代码生成：在代码生成阶段，汇编器根据语法树和符号表生成目标文件的指令。这个阶段涉及指令的翻译和生成各种表信息，如重定位表、赋值信息等。指令的翻译过程将汇编指令转化为目标机器的机器指令，生成的表信息用于链接和重定位等操作。</li>
<li>主要工作：汇编过程的主要工作包括词法分析、语法分析、组装、代码生成和生成各种表信息。这些工作协同完成，最终生成可重定位目标文件（通常以.o为后缀，如main.o）。</li>
</ol>
<h1 id="3-5-2-符号表（Symbol-Table）"><a href="#3-5-2-符号表（Symbol-Table）" class="headerlink" title="3.5.2 符号表（Symbol Table）"></a>3.5.2 符号表（Symbol Table）</h1><p>​	符号表（Symbol Table）是编译器和链接器中存储程序中符号信息的数据结构。它记录了源代码中定义和引用的变量、函数、类、常量等标识符的相关信息，如名称、类型、内存地址等。符号表在编译和链接过程中起着重要的作用，用于解析符号引用、符号重定位和符号解析等任务。</p>
<p>符号表通常包含以下信息：</p>
<ol>
<li>符号名称（Symbol Name）：记录标识符的名称，如变量名、函数名等。</li>
<li>符号类型（Symbol Type）：指示标识符的类型，如整型、浮点型、函数等。</li>
<li>符号属性（Symbol Attributes）：记录标识符的属性，如是否为全局变量、局部变量、静态变量等。</li>
<li>内存地址（Memory Address）：记录标识符在内存中的地址或偏移量。</li>
<li>作用域（Scope）：指示标识符的作用域范围，如全局作用域、局部作用域等。</li>
<li>定义位置（Definition Location）：记录标识符的定义位置，用于解析符号引用。</li>
<li>引用位置（Reference Locations）：记录标识符的引用位置，用于解析符号引用。</li>
</ol>
<p>符号表在编译过程中起着重要的作用：</p>
<ol>
<li>语法分析：在语法分析阶段，编译器将标识符添加到符号表中，并记录其名称、类型和定义位置等信息。</li>
<li>符号解析：在编译器的符号解析阶段，通过符号表来解析标识符的引用。编译器会检查符号表，找到标识符的定义位置，并进行类型检查和语义分析。</li>
<li>重复定义检查：符号表可以检查是否存在重复定义的标识符，如重复的变量名或函数名。</li>
<li>作用域管理：符号表中的作用域信息可以帮助编译器正确处理局部变量和全局变量的作用域范围。</li>
<li>符号重定位：在链接过程中，符号表用于解析符号引用和进行符号重定位。链接器会根据符号表中的地址信息，将各个目标文件中的符号引用链接到正确的地址上。</li>
</ol>
<h1 id="3-5-3-重定位表（Relocation-Table）"><a href="#3-5-3-重定位表（Relocation-Table）" class="headerlink" title="3.5.3 重定位表（Relocation Table）"></a>3.5.3 重定位表（Relocation Table）</h1><p>​	重定位表（Relocation Table）是链接器生成的一种表格，用于记录需要进行符号重定位的位置和相关信息。在目标文件中，由于代码和数据的位置是相对于起始地址的偏移量，因此在链接时需要对这些位置进行调整，以确保最终生成的可执行文件能够正确地访问和使用这些代码和数据。</p>
<p>重定位表通常包含以下信息：</p>
<ol>
<li>符号名称（Symbol Name）：记录需要进行重定位的符号的名称。</li>
<li>重定位类型（Relocation Type）：指示需要进行的重定位类型，如绝对重定位、相对重定位等。</li>
<li>位置（Location）：记录需要进行重定位的位置或偏移量。</li>
<li>目标地址（Target Address）：记录需要重定位到的目标地址。</li>
</ol>
<p>重定位表在链接过程中起着重要的作用：</p>
<ol>
<li>符号解析与重定位：链接器通过重定位表中的信息，对目标文件中的符号引用进行解析和重定位。它会根据目标文件的符号表和重定位表，将符号引用链接到正确的地址上。</li>
<li>位置调整：重定位表中记录了需要进行重定位的位置和目标地址，链接器根据这些信息对目标文件中的代码和数据位置进行调整，使其能够正确地访问和使用。</li>
<li>符号冲突解决：如果存在多个目标文件中相同名称的符号，重定位表可以帮助链接器解决符号冲突的问题。通过重定位表中的符号名称和目标地址，链接器可以确定每个符号应该链接到的具体地址，从而避免冲突。</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BF%90%E8%A1%8C/" rel="tag">程序的编译、链接和运行</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-3-4-编译过程-1-从源程序到汇编文件"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/3-4-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B-1-%E4%BB%8E%E6%BA%90%E7%A8%8B%E5%BA%8F%E5%88%B0%E6%B1%87%E7%BC%96%E6%96%87%E4%BB%B6/"
    >3.4-编译过程(1)-从源程序到汇编文件</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/3-4-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B-1-%E4%BB%8E%E6%BA%90%E7%A8%8B%E5%BA%8F%E5%88%B0%E6%B1%87%E7%BC%96%E6%96%87%E4%BB%B6/" class="article-date">
  <time datetime="2023-09-04T23:46:56.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">c高级编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="3-4-1-编译输入输出"><a href="#3-4-1-编译输入输出" class="headerlink" title="3.4.1 编译输入输出"></a>3.4.1 编译输入输出</h1><p>编译过程主要是将高级语言（如C语言）的源代码转换为低级语言（如汇编语言或机器语言），以便计算机可以理解和执行。</p>
<p>在编译过程中，主要的步骤包括：</p>
<ol>
<li>词法分析（Lexical Analysis）：将源代码划分为词法单元（tokens），例如关键字、标识符、运算符和常量等。词法分析器（也称为扫描器）会扫描源代码，并生成词法单元流。</li>
<li>语法分析（Syntax Analysis）：根据语法规则，将词法单元流组织成语法树（Parse Tree）或抽象语法树（Abstract Syntax Tree，AST）。语法分析器（也称为解析器）会检查语法的正确性，并生成语法树或AST。</li>
<li>语义分析（Semantic Analysis）：对语法树或AST进行语义检查，包括类型检查、语义规则验证等。语义分析器会确保程序在语义上是合法的，并生成相应的符号表（Symbol Table）来记录变量、函数等的信息。</li>
<li>中间代码生成（Intermediate Code Generation）：将语法树或AST转换为中间表示形式，通常是一种类似于三地址码的中间代码。中间代码是一种抽象的表示形式，它更接近于底层的机器语言，但仍保留了高级语言的结构特点。</li>
<li>代码优化（Code Optimization）：对中间代码进行优化，以改善程序的性能、减少代码的执行时间或空间占用。代码优化技术包括常量传播、循环展开、公共子表达式消除等，旨在生成更高效的目标代码。</li>
<li>目标代码生成（Code Generation）：将优化后的中间代码转换为目标机器的机器代码或汇编代码。目标代码生成器会根据目标机器的体系结构和指令集生成对应的机器代码或汇编代码。</li>
<li>链接（Linking）：如果程序包含多个源文件或库文件，链接器会将它们合并为一个可执行文件。链接过程包括符号解析、重定位等步骤，以确保程序中引用的函数和变量正确地连接到对应的定义。</li>
</ol>
<h1 id="3-4-2-词法分析"><a href="#3-4-2-词法分析" class="headerlink" title="3.4.2 词法分析"></a>3.4.2 词法分析</h1><p>词法分析是编译过程中的一项关键任务，它将源代码作为输入，并将其划分为一系列记号（tokens）。</p>
<p>在词法分析过程中，主要的步骤包括：</p>
<ol>
<li>从左到右读取源程序：词法分析器按顺序逐个字符地读取源代码，从左到右进行扫描。</li>
<li>扫描和分解记号：词法分析器根据语言的词法规则，将源程序的字符流分解成一系列记号。记号可以是关键字、标识符、字面量（数字、字符串等）、特殊字符（运算符等）和分界符（分号、逗号等）等。</li>
<li>构建记号流：词法分析器将分解出的记号按顺序构建记号流，以便后续的语法分析和语义分析等阶段使用。</li>
<li>符号表：在词法分析过程中，识别到的标识符（如函数名、变量名、标号等）会被记录在符号表中。符号表是编译器维护的一张表格，用于存储标识符的属性信息（如类型、作用域等）。</li>
<li>字符串表：识别到的数字、字符串等字面量会被存放在字符串表中。字符串表是一个存储字符串字面量的表格，编译器可以使用索引来引用字符串表中的内容，以减少内存占用和提高效率。</li>
</ol>
<h1 id="3-4-3-语法分析"><a href="#3-4-3-语法分析" class="headerlink" title="3.4.3 语法分析"></a>3.4.3 语法分析</h1><p>语法分析是编译过程中的一个重要阶段，它根据语法规则检查词法分析器生成的记号流，以确定是否构成一个语法上正确的程序，并将其分解为语法短语（如程序、语句、表达式等）。语法分析器将记号流转化为语法树（Parse Tree），它是一种树形结构，表示了程序的语法结构。</p>
<p>在语法分析过程中，主要的步骤包括：</p>
<ol>
<li>语法规则：语法分析器使用预定义的语法规则来判断记号流是否符合语法要求。语法规则描述了语言的语法结构，包括语句的组成、表达式的形式等。</li>
<li>语法树构建：语法分析器根据语法规则，将记号流转化为语法树。语法树是一种树形结构，它以记号为节点，将程序的语法结构表示为树的分支和叶子节点。</li>
<li>语法分析工具：为了简化语法分析的实现，可以使用专门的语法分析工具，如Yacc（Yet Another Compiler Compiler）。这些工具提供了一种形式化的方式来描述语法规则，并自动生成语法分析器的代码。</li>
<li>通用性：由于语法规则是与编程语言相关的，不同的编程语言具有不同的语法规则。但幸运的是，对于常见的编程语言，不需要为每个编译器编写一个新的语法分析器。相同的语法分析技术和工具可以用于不同的编程语言，只需要提供相应的语法规则。</li>
<li>语法错误：如果记号流不能按照语法规则进行正确的匹配，就会发生语法错误（syntax error）。语法分析器会检测这些错误并生成相应的错误信息，指示程序中存在哪些语法错误以及其位置。</li>
</ol>
<h1 id="3-4-4-语义分析"><a href="#3-4-4-语义分析" class="headerlink" title="3.4.4 语义分析"></a>3.4.4 语义分析</h1><p>语义分析是编译过程中的一个关键阶段，它在语法分析的基础上对语句、程序、表达式等进行进一步检查，以确定其语义是否正确。语义分析器会检查静态语义和动态语义，并对整个语法树的表达式进行类型标注。</p>
<p>在语义分析过程中，主要的任务包括：</p>
<ol>
<li>静态语义：静态语义分析在编译期间进行，它关注的是在编译期能够确定的语义。静态语义包括函数实参与形参的类型匹配和转换、变量的声明和使用、类型检查等。例如，语义分析器会检查函数调用时实参与形参的类型是否匹配，是否存在未声明的变量等。</li>
<li>动态语义：动态语义分析在运行期间进行，它关注的是在运行时才能确定的语义。动态语义包括除数为零、数组越界访问等。例如，语义分析器会检查除法表达式中除数是否为零，以避免发生运行时错误。</li>
<li>类型标注：语义分析器会对整个语法树的表达式进行类型标注，即为每个表达式确定其类型信息。这可以帮助后续的代码生成和优化阶段进行类型检查和优化操作。</li>
<li>语义分析器：语义分析器是执行语义分析的工具或组件。它接收语法分析器生成的语法树作为输入，并根据语义规则进行分析和检查。语义分析器会发现并报告语义错误，如类型不匹配、未声明的变量等。</li>
</ol>
<h1 id="3-4-5-第四阶段"><a href="#3-4-5-第四阶段" class="headerlink" title="3.4.5 第四阶段"></a>3.4.5 第四阶段</h1><p>第四阶段是编译器的中间代码生成阶段。在这个阶段，编译器将语法树转换为中间代码，以便进行后续的优化和目标代码生成。</p>
<p>中间代码是一种抽象的表示形式，它通常比源代码更接近于目标代码，但仍具有较高的可移植性和可理解性。中间代码使得编译器可以对程序进行统一的优化处理，而不受目标机器的限制。</p>
<p>现代编译器的构造通常包括以下三个主要组成部分：</p>
<ol>
<li>前端：前端负责词法分析、语法分析和语义分析等任务。它将源代码转换为中间表示形式（如语法树或中间代码），并进行基本的语法和语义检查。前端确保源代码在语法和语义上是正确的，并为后续的优化和代码生成阶段提供准确的输入。</li>
<li>优化器：优化器是编译器的重要组成部分，它对中间代码进行优化。优化器通过分析和重写中间代码，以提高程序的执行效率、减少代码大小或改进其他性能指标。优化器使用各种技术，如常量传播、循环优化、数据流分析等，来改进程序的质量和性能。</li>
<li>后端：后端负责将优化后的中间代码转换为目标机器的汇编代码或机器代码。后端包括指令选择（将中间代码转换为适合目标机器的指令序列）、寄存器分配（为变量选择寄存器）、代码布局、代码生成等任务。后端将优化后的中间代码转化为目标机器能够执行的代码。</li>
</ol>
<p>中间代码是一维线性序列，更容易生成和处理。它可以在后续的优化和代码生成阶段中进行处理和转换。</p>
<p>生成中间代码的过程通常在语义分析阶段之后，在优化器之前。语义分析器将源代码转换为语法树，然后通过对语法树进行遍历和转换，生成中间代码表示。这个过程包括将每个语法结构转换为相应的中间代码指令，并保留必要的信息来保证后续的优化和代码生成。</p>
<p>中间代码具有一些特点，如：</p>
<ol>
<li>接近目标代码：中间代码的表示形式类似于目标代码，它更接近于实际的机器指令。这使得后续的代码生成阶段更容易进行，因为中间代码已经具有了一定的目标机器相关性。</li>
<li>容易生成和转换：中间代码的生成过程相对简单，通常是基于语法树的遍历和转换。中间代码的线性结构使得对其进行处理和转换更加方便，例如进行优化和目标代码生成。</li>
</ol>
<h1 id="3-4-6-为什么需要中间代码"><a href="#3-4-6-为什么需要中间代码" class="headerlink" title="3.4.6 为什么需要中间代码"></a>3.4.6 为什么需要中间代码</h1><p>使用中间代码有以下几个主要原因：</p>
<ol>
<li>可移植性：中间代码是一种与具体目标机器无关的表示形式。通过生成中间代码，编译器可以将源代码与目标机器解耦，使得编译器更加可移植。中间代码可以在不同的目标平台上进行后续的优化和代码生成，从而实现源代码在不同平台上的跨平台执行。</li>
<li>优化：中间代码提供了一个高层次的表示形式，使得编译器可以在这个层次上进行各种优化操作。编译器可以利用中间代码的结构和语义信息，进行常量传播、死代码消除、循环优化、内联函数等优化操作，以提高程序的执行效率和性能。</li>
<li>简化代码生成：中间代码更接近于目标代码的表示形式，因此在后续的代码生成阶段，可以更轻松地将中间代码转换为目标机器的汇编代码或机器代码。中间代码的生成和转换过程相对简单，可以通过一系列的规则和转换操作来实现。</li>
<li>可读性和可理解性：中间代码通常使用一种高级语言或伪代码的形式表示，相对于目标机器的汇编代码来说，更容易阅读和理解。中间代码使得编译器的工作更加透明和可追踪，同时也有助于开发人员理解编译器的工作过程。</li>
</ol>
<h2 id="3-4-6从中间代码到汇编"><a href="#3-4-6从中间代码到汇编" class="headerlink" title="3.4.6从中间代码到汇编"></a>3.4.6从中间代码到汇编</h2><p>编译器的第五阶段是生成汇编代码，该阶段将中间代码翻译为汇编文件，并最终生成目标文件。这个阶段涉及到指令选择、控制流分析、数据流分析、寄存器分配等过程。</p>
<p>以下是生成汇编代码的一般过程：</p>
<ol>
<li>指令选择：在这个过程中，编译器将中间代码转换为汇编语言指令。指令选择的目标是选择合适的汇编指令，使得它们能够实现中间代码所描述的操作。这个过程通常会根据目标机器的架构和指令集来进行，以生成与目标机器兼容的汇编代码。</li>
<li>控制流分析：控制流分析用于确定程序中的基本块和控制流图。基本块是一段连续的指令序列，没有分支或跳转。控制流图记录了程序中的基本块之间的控制流关系，包括条件分支、循环等。控制流分析是进行优化和寻找代码转换机会的基础。</li>
<li>数据流分析：数据流分析用于分析程序中的数据依赖关系。它可以确定变量的定义和使用位置，以及数据传递和转换的路径。数据流分析对于进行寄存器分配和优化非常重要，因为它提供了变量的生命周期和使用信息。</li>
<li>寄存器分配：寄存器分配是将变量和临时值映射到物理寄存器的过程。寄存器分配可以基于静态或动态策略进行。静态寄存器分配在编译时确定寄存器的分配方案，而动态寄存器分配在运行时根据需要进行寄存器分配。寄存器分配的目标是最大程度地利用寄存器，减少内存访问。</li>
<li>汇编语言生成：在这个过程中，编译器将经过指令选择、控制流分析、数据流分析和寄存器分配的中间代码转换为汇编语言。汇编语言是一种与目标机器相关的低级表示形式，它使用特定的汇编指令和寄存器来描述程序的操作和数据。生成的汇编代码将被进一步处理以生成目标文件。</li>
<li>汇编器：汇编器是一个独立工具，它将汇编语言代码转换为可执行的目标文件。汇编器接受汇编语言作为输入，根据目标机器的指令集和格式，将汇编语言翻译为机器代码，并生成目标文件。</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BF%90%E8%A1%8C/" rel="tag">程序的编译、链接和运行</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-3-3-预处理过程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/3-3-%E9%A2%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/"
    >3.3-预处理过程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/3-3-%E9%A2%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/" class="article-date">
  <time datetime="2023-09-04T23:46:55.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">c高级编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="3-3-1-预处理的过程"><a href="#3-3-1-预处理的过程" class="headerlink" title="3.3.1 预处理的过程"></a>3.3.1 预处理的过程</h1><p>预处理是编译过程中的第一步，它对源代码进行一系列的处理，包括头文件展开、宏展开、条件编译、删除注释、添加行号和文件名标识等。下面是预处理过程的主要步骤：</p>
<ol>
<li>头文件展开：将所有<code>#include</code>指令包含的文件插入到指令所在的位置。这样可以将头文件的内容插入到源代码中，使得源代码中可以使用头文件中定义的函数、变量和宏等。</li>
<li>宏展开：对所有的宏定义进行展开，并删除<code>#define</code>指令。预处理器会查找源代码中使用的宏，并将其替换为宏定义中的内容。这样可以将宏定义的代码在预处理阶段进行替换，减少了函数调用的开销。</li>
<li>条件编译：处理所有的条件预编译指令，例如<code>#if</code>、<code>#ifdef</code>、<code>#else</code>等。根据条件的真假，选择性地编译或排除部分代码。这样可以根据不同的条件编译选项，编译不同的代码分支。</li>
<li>删除注释：去除源代码中的注释部分。注释对于程序的理解和阅读很重要，但在编译过程中并不需要注释，因此预处理阶段会将注释删除，减少后续编译的工作量。</li>
<li>添加行号和文件名标识：为了方便编译调试和错误定位，预处理阶段会为每一行源代码添加行号和文件名标识。这样在编译出错时，可以准确地定位错误所在的行和文件。</li>
<li>保留#pragma命令：预处理阶段会保留<code>#pragma</code>指令。<code>#pragma</code>指令是编译器提供的一些特定功能的扩展，用于控制编译器的行为或实现特定的功能。</li>
<li>宏命令展开和文本替换：预处理阶段最后一步是对源代码进行宏命令展开和文本替换。在宏展开过程中，预处理器会查找源代码中使用的宏，并将其展开为宏定义中的内容。同时，还会进行一些文本替换的操作，例如替换宏参数、替换宏函数调用等。</li>
</ol>
<h1 id="3-3-2-为什么要进行预处理"><a href="#3-3-2-为什么要进行预处理" class="headerlink" title="3.3.2 为什么要进行预处理"></a>3.3.2 为什么要进行预处理</h1><p>预处理过程在编译过程中起着重要的作用，原因如下：</p>
<ol>
<li>宏定义：预处理阶段允许使用宏定义，宏可以将一段代码或表达式替换为预定义的文本。通过使用宏定义，可以简化代码编写，提高代码的可读性和可维护性。</li>
<li>方便条件编译：条件编译指令（如<code>#if</code>、<code>#ifdef</code>、<code>#else</code>）允许根据不同的编译条件选择性地编译或排除代码块。这对于实现跨平台兼容性或针对不同的编译配置进行调试和优化非常有用。</li>
<li>兼容各个平台和处理器架构：预处理过程可以根据不同的平台和处理器架构进行编译选项的设置。通过使用条件编译指令，可以编写适用于不同平台和处理器的代码，提高代码的可移植性和兼容性。</li>
<li>最大程度复用公用代码：通过使用头文件，可以将公用的函数、结构体和宏等定义保存在独立的文件中，并在需要的地方进行引用。这样可以实现代码的模块化和复用，减少代码的冗余和重复编写。</li>
<li>头文件包含：预处理过程中的头文件展开允许将其他文件中的代码插入到源文件中。这样可以将相关的代码组织在一起，提高代码的可读性和可维护性，并减少代码中的重复内容。</li>
<li>模块化编程：预处理过程可以通过定义和使用宏来实现模块化编程。模块化编程将代码划分为独立的功能模块，使代码更易于理解、测试和维护。</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BF%90%E8%A1%8C/" rel="tag">程序的编译、链接和运行</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-预处理过程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/%E9%A2%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/"
    >预处理过程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/%E9%A2%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/" class="article-date">
  <time datetime="2023-09-04T23:45:08.000Z" itemprop="datePublished">2023-09-05</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
   
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-3-2-GCC命令参数"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/3-2-GCC%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0/"
    >3.2 GCC命令参数</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/3-2-GCC%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0/" class="article-date">
  <time datetime="2023-09-04T23:44:56.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">c高级编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="3-2-1-什么是GCC"><a href="#3-2-1-什么是GCC" class="headerlink" title="3.2.1 什么是GCC ?"></a>3.2.1 什么是GCC ?</h1><p>GCC指的是GNU编译器套件（GNU Compiler Collection），它是一个开源的编译器集合。GCC包括预处理器、编译器、汇编器和链接器等工具，它能够将源代码转换为可执行文件。GCC支持多种编程语言，如C、C++、Objective-C、Fortran、Ada等，并且可在多个操作系统上使用，包括Linux、Unix、Windows等。</p>
<p>除了编译器本身，GCC还提供了一些文件处理工具，如objdump、objcopy、nm、readelf和strip等，用于处理目标文件、库文件和可执行文件。此外，GCC也提供了一套标准的库文件和头文件，供开发者在编译程序时使用。</p>
<h1 id="3-2-2-gcc-参数"><a href="#3-2-2-gcc-参数" class="headerlink" title="3.2.2 gcc 参数"></a>3.2.2 gcc 参数</h1><p>通过在GCC命令行中使用不同的参数，可以调用GCC工具集中的不同工具。以下是一些常用的参数和对应的工具：</p>
<ul>
<li><code>-E</code>：预处理，调用cpp预处理器，将源代码中的宏定义展开、包含头文件等操作。</li>
<li><code>-S</code>：生成汇编文件，GCC将合并预处理后的代码，并将其转换为汇编语言。</li>
<li><code>-c</code>：生成目标文件，调用汇编器as，将汇编代码转换为机器代码，但不进行链接操作。</li>
<li><code>-o &lt;output&gt;</code>：指定输出文件的名称，可以用于指定生成的目标文件或可执行文件的名称。</li>
<li><code>--verbose</code>：显示详细的编译信息，包括调用的工具和执行的步骤。</li>
</ul>
<p>gcc -E main.c<br>该命令会直接将预处理的内容打印到终端并不会生成一个文件，所以需要指定一下输出文件，重定向，如下所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309050822386.png" alt="image-20230905082213343"></p>
<p>同样的gcc -S main.c 也是如此</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309050822178.png" alt="image-20230905082250151"></p>
<p>更多参数的详细介绍</p>
<ol>
<li><p><strong>控制编译过程的参数</strong>：</p>
<ul>
<li><code>-c</code>：只编译源文件，生成目标文件而不进行链接。</li>
<li><code>-S</code>：生成汇编代码文件，不进行编译和链接。</li>
<li><code>-E</code>：只进行预处理，生成预处理后的源代码。</li>
<li><code>-o &lt;output&gt;</code>：指定输出文件的名称。</li>
<li><code>-I &lt;dir&gt;</code>：指定头文件搜索路径。</li>
<li><code>-L &lt;dir&gt;</code>：指定库文件搜索路径。</li>
<li><code>-M</code>：生成文件依赖关系。使用该选项时，GCC会分析源文件中的<code>#include</code>指令，输出每个源文件及其所包含的头文件之间的依赖关系。输出结果通常以makefile规则的格式呈现。</li>
<li><code>-MD</code>：与<code>-M</code>相同，但是将输出导入到<code>.d</code>文件中。生成的<code>.d</code>文件通常包含了源文件及其所包含的头文件之间的依赖关系，可以在makefile中引用这些<code>.d</code>文件来自动化编译过程。</li>
<li><code>-MM</code>：与<code>-M</code>相似，但忽略<code>#include &lt;file.h&gt;</code>产生的依赖关系。这意味着只生成自定义头文件（使用双引号<code>#include &quot;file.h&quot;</code>）的依赖关系，而不包括系统头文件（使用尖括号<code>#include &lt;file.h&gt;</code>）。</li>
<li></li>
</ul>
</li>
<li><p><strong>编译选项的设置</strong>：</p>
<ul>
<li><p><code>-std=&lt;standard&gt;</code>：指定使用的语言标准，如<code>-std=c11</code>表示使用C11标准。</p>
</li>
<li><p><code>-Wall</code>：开启所有警告信息。</p>
</li>
<li><p><code>-Werror</code>：将警告视为错误，编译过程中遇到警告将中止。</p>
</li>
<li><p><code>-Wextra</code>：开启额外的警告选项。</p>
</li>
<li><p><code>-pedantic</code>：严格遵循语言标准，显示更多警告信息。</p>
</li>
<li><p><code>-g</code>：在编译过程中生成调试信息，用于调试程序。这些调试信息可以被调试器（如GDB）使用。</p>
</li>
<li><p><code>-static</code>：禁止使用动态库，强制链接静态库。这意味着编译后的可执行文件将不依赖于系统上已安装的动态库，而是包含了所有必要的库的副本。</p>
</li>
<li><p><code>-shared</code>：生成共享目标文件，也称为共享库或动态库。共享库可以在运行时被不同的程序加载和使用。</p>
</li>
<li><p><code>-L&lt;dir&gt;</code>：指定库搜索路径。使用该选项可以告诉编译器在指定的目录中搜索库文件。</p>
</li>
<li><p><code>-l&lt;libname&gt;</code>：指定编译时使用的库。例如，<code>-lmath</code>将链接数学库。编译器会在标准库搜索路径和使用<code>-L</code>选项指定的路径中查找库文件。</p>
</li>
<li><p><code>-I&lt;dir&gt;</code>：指定头文件搜索路径。使用该选项可以告诉编译器在指定的目录中搜索头文件。</p>
</li>
<li><p><code>-w</code>：禁止生成任何警告信息。编译器将不会显示任何警告。</p>
</li>
<li><p><code>-std=c99</code>：指定使用C99标准进行编译。GCC默认采用GNU C标准。</p>
</li>
</ul>
</li>
<li><p><strong>编译器优化选项</strong>：</p>
<ul>
<li><code>-O0</code>、<code>-O1</code>、<code>-O2</code>、<code>-O3</code>：控制编译器的优化级别，从无优化到高级优化。</li>
<li><code>-Os</code>：优化代码大小。</li>
<li><code>-Ofast</code>：最大程度地优化代码执行速度，可能牺牲一些标准的符合性。</li>
<li><code>-march=&lt;arch&gt;</code>：指定目标处理器架构，优化代码以适应特定处理器。</li>
</ul>
</li>
</ol>
<h1 id="3-2-3-交叉编译"><a href="#3-2-3-交叉编译" class="headerlink" title="3.2.3 交叉编译"></a>3.2.3 交叉编译</h1><p>交叉编译是指在一种平台上进行编译，生成能够在另一种不同平台上运行的可执行文件或镜像。在交叉编译中，编译器和工具链被配置为目标平台的编译器和工具，以便生成与目标平台兼容的代码和可执行文件。</p>
<p>例如，如果你正在运行的是 x86 架构的电脑，但你想要编译一个在 ARM 架构的嵌入式设备上运行的程序，就需要进行交叉编译。在这种情况下，你需要使用针对 ARM 架构的交叉编译器和工具链，例如 <code>arm-linux-gnueabi-gcc</code>。</p>
<p>安装交叉编译器和工具链时，你可以使用适合你的发行版的包管理器。在这个例子中，你可以使用 <code>apt</code> 包管理器来安装 ARM 架构的交叉编译器和工具链，命令如下：</p>
<p>Copy</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install gcc-arm-linux-gnueabi</span><br></pre></td></tr></table></figure>

<p>安装完成后，你就可以使用 <code>arm-linux-gnueabi-gcc</code> 命令来进行 ARM 架构的交叉编译了。这样你就能够生成适用于 ARM 架构设备的可执行文件或镜像。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BF%90%E8%A1%8C/" rel="tag">程序的编译、链接和运行</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-3-1-程序的编译与可执行文件"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/04/3-1-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"
    >程序的编译与可执行文件</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/3-1-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/" class="article-date">
  <time datetime="2023-09-04T13:19:52.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">c高级编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="3-1-程序的编译与可执行文件"><a href="#3-1-程序的编译与可执行文件" class="headerlink" title="3.1 程序的编译与可执行文件"></a>3.1 程序的编译与可执行文件</h1><h2 id="3-1-1-可执行文件的组装"><a href="#3-1-1-可执行文件的组装" class="headerlink" title="3.1.1 可执行文件的组装"></a>3.1.1 可执行文件的组装</h2><p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042146452.png" alt="image-20230904214608380"></p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042146097.png" alt="image-20230904214623995"></p>
<p>编译过程的特点可以总结如下：</p>
<p>非一步到位：编译过程不是一次性完成的，而是分为多个阶段逐步完成的。</p>
<p>环环相扣：每个阶段的输出作为下一个阶段的输入，各个阶段之间有着紧密的联系和依赖关系。</p>
<p>分为预编译、编译、汇编、链接阶段：编译过程可以划分为预处理、编译、汇编和链接几个主要阶段。</p>
<p>调用不同的工具：每个阶段都调用不同的工具或编译器来完成特定的任务。</p>
<ul>
<li><p>预处理：在预处理阶段，预处理器将源文件进行处理，如宏展开、头文件包含等，生成处理后的源文件。</p>
</li>
<li><p>编译：在编译阶段，编译器将处理后的源文件转换为汇编语言代码，进行语法分析、语义分析、优化等操作。</p>
</li>
<li><p>汇编：在汇编阶段，汇编器将生成的汇编语言代码转换为机器语言指令，并生成目标文件。</p>
</li>
<li><p>链接：在链接阶段，链接器将多个目标文件和库文件进行链接，解析符号引用，生成可执行目标文件（如ELF格式）。</p>
</li>
</ul>
<p>生成可执行文件是编译过程中的最终目标，但为什么编译过程中不直接生成可执行文件，而是分为多个阶段呢？</p>
<p>首先是GNU的思想，即”一个工具只干一件事情”。GNU工具链以及许多其他编译工具都遵循这个原则。将编译过程分为多个阶段，每个阶段有专门的工具来处理，可以使得每个工具更加专注于自己的任务。例如，预处理器负责处理宏展开、头文件包含等，编译器负责将源代码转换为汇编代码，汇编器负责将汇编代码转换为机器代码，链接器负责将目标文件链接为可执行文件。这样的分工可以简化每个工具的实现和复杂度，使得工具更加可靠、可维护，并提高了工具的复用性。</p>
<p>其次是计算机工业思维中的标准接口和分层原则。将编译过程分为多个阶段，每个阶段的输入和输出都有明确定义的接口，使得每个阶段都可以独立进行开发和优化。这样的分层结构可以适配更多的平台、CPU架构和指令集，使得编译器可以在不同的系统上使用相同的前端和中间表示，通过后端进行特定平台的代码生成。这种模块化和分层的设计使得编译器更加灵活、可扩展，并能够适应不断变化的计算机体系结构和需求。</p>
<h2 id="3-1-2-从源程序到可执行文件"><a href="#3-1-2-从源程序到可执行文件" class="headerlink" title="3.1.2 从源程序到可执行文件"></a>3.1.2 从源程序到可执行文件</h2><p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042152389.png" alt="image-20230904215208244"></p>
<ol>
<li>预处理：源程序中的 <code>#include&lt;stdio.h&gt;</code> 被预处理器处理，将对应的头文件内容插入到源程序中，生成处理后的源程序。</li>
<li>编译：编译器将处理后的源程序进行语法分析、语义分析、优化等操作，生成目标文件。在目标文件中，包括以下部分：<ul>
<li>ELF header：ELF（可执行与可链接格式）头部，包含关于文件格式的信息。</li>
<li>Program header table：程序头表，描述程序的段（段包含代码、数据等）。</li>
<li>.text 段：包含程序的机器代码。</li>
<li>.rodata 段：包含只读数据，如字符串常量。</li>
<li>.data 段：包含已初始化的全局和静态变量。</li>
<li>.bss 段：包含未初始化的全局和静态变量。</li>
</ul>
</li>
<li>链接：链接器将目标文件进行链接，生成可执行文件。在可执行文件中，包括以下部分：<ul>
<li>ELF header：与目标文件相同，包含关于文件格式的信息。</li>
<li>Program header table：与目标文件相同，描述程序的段。</li>
<li>.text 段：与目标文件相同，包含程序的机器代码。</li>
<li>.rodata 段：与目标文件相同，包含只读数据。</li>
<li>.data 段：与目标文件相同，包含已初始化的全局和静态变量。</li>
<li>.bss 段：与目标文件相同，包含未初始化的全局和静态变量。</li>
<li>符号表（.symtab）：包含程序中定义的全局和静态符号的信息。</li>
<li>字符串表（.strtab）：保存符号表中的字符串。</li>
<li>调试信息（.debug）：包含调试器使用的信息。</li>
<li>行号信息（.line）：包含源代码的行号信息。</li>
</ul>
</li>
</ol>
<p>最终生成的可执行文件包含了程序的机器代码、数据、符号表等信息，可以在计算机上执行。编译过程中的中间文件和信息都嵌入到最终的可执行文件中，以便在运行时进行处理和调试。</p>
<h2 id="3-1-3-目标文件"><a href="#3-1-3-目标文件" class="headerlink" title="3.1.3 目标文件"></a>3.1.3 目标文件</h2><p>目标文件（Object file）是编译器生成的中间文件，它包含了编译后的机器代码、数据和符号信息，用于最终生成可执行文件或共享目标文件。目标文件的类型可以通过命令 <code>file</code> 进行查看。</p>
<p>常见的目标文件类型包括：</p>
<ul>
<li>可重定位目标文件（Relocatable files）：这种类型的目标文件包含了编译后的机器代码、数据和符号信息，但是它们的内部地址是相对于起始地址的偏移量，还没有进行最终的地址分配和链接。可重定位目标文件可以作为其他可重定位目标文件或可执行目标文件的输入，用于生成最终的可执行文件或共享目标文件。</li>
<li>可执行目标文件（Executable files）：这种类型的目标文件是经过链接的最终可执行文件，包含了所有的机器代码、数据和符号信息，可以直接在操作系统上执行。</li>
<li>可被共享目标文件（Shared object file）：也被称为动态链接库（Dynamic Linking Library）或共享库（Shared Library）。这种类型的目标文件包含了可被多个可执行文件或其他共享库共享使用的代码和数据，可以在运行时动态加载到内存中，并与其他程序共享使用。</li>
<li>可执行文件（ELF，Executable and Linkable Format）：这是一种可执行文件的格式，广泛用于类UNIX系统。可执行文件可以直接在操作系统上执行，包含了机器代码、数据和符号信息，以及其他与执行相关的信息（如程序入口点等）。</li>
</ul>
<h2 id="3-1-4-ELF可执行文件的结构"><a href="#3-1-4-ELF可执行文件的结构" class="headerlink" title="3.1.4 ELF可执行文件的结构"></a>3.1.4 ELF可执行文件的结构</h2><ol>
<li>ELF header（ELF 头）：包含了关于文件格式的信息，如文件类型、目标体系结构、入口点地址等。</li>
<li>Program header table（程序头表）：描述了可执行文件的段（segment）信息，每个段对应一个或多个节（section），包括代码段、只读数据段、可读写数据段等。程序头表记录了每个段的起始地址、大小、访问权限等信息。</li>
<li>.init 段：包含了可执行文件在加载到内存后需要执行的初始化代码，如全局变量的初始化和动态链接器的初始化等。</li>
<li>.text、.rodata、.data、.bss 等段：这些段包含了实际的代码和数据。<ul>
<li>.text 段：包含了可执行代码的机器指令，也就是程序的代码段。</li>
<li>.rodata 段：包含了只读数据，如字符串常量等。</li>
<li>.data 段：包含了已初始化的全局和静态变量。</li>
<li>.bss 段：包含了未初始化的全局和静态变量，这些变量在运行时会被初始化为 0。</li>
</ul>
</li>
<li>符号表（.symtab）：记录了程序中定义和引用的全局和静态符号的信息，如函数和变量。符号表中包含了符号的名称、类型、大小、地址等信息。</li>
<li>调试信息（.debug）：包含了调试器使用的信息，如源代码的行号信息、变量和函数的调试信息等。</li>
<li>行号信息（.line）：包含了源代码的行号信息，用于将机器代码映射回源代码的行号。</li>
<li>字符串表（.strtab）：保存了符号表和调试信息中使用的字符串。</li>
<li>Section header table（节头表）：描述了各个节的信息，包括名称、类型、偏移量、大小等。</li>
</ol>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_val = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> uninit_val;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> local_val = <span class="number">2</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> uninit_local_val;</span><br><span class="line">    </span><br><span class="line">    a = add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    b = sub(<span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sub.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用以下命令编译成目标文件，但是不进行链接</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c main.c sub.c</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042209197.png" alt="image-20230904220907171"></p>
<p>使用以下命令读取ELF header</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -h main.o</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042211626.png" alt="image-20230904221103590"></p>
<p>然后使用以下命令查看节头表（section heads）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -S main.o</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042213386.png" alt="image-20230904221310333"></p>
<p>最后使用以下命令进行链接,生成可执行文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.o sub.o</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042215351.png" alt="image-20230904221504326"></p>
<p>重新读取elf头和section heads</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">topeet@ubuntu:~/demo$ readelf -h a.out </span><br><span class="line">ELF 头：</span><br><span class="line">  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  类别:                              ELF64</span><br><span class="line">  数据:                              2 补码，小端序 (little endian)</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          0</span><br><span class="line">  类型:                              DYN (共享目标文件)</span><br><span class="line">  系统架构:                          Advanced Micro Devices X86-64</span><br><span class="line">  版本:                              0x1</span><br><span class="line">  入口点地址：               0x1060</span><br><span class="line">  程序头起点：          64 (bytes into file)</span><br><span class="line">  Start of section headers:          15016 (bytes into file)</span><br><span class="line">  标志：             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         13</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         31</span><br><span class="line">  Section header string table index: 30</span><br><span class="line">topeet@ubuntu:~/demo$ read</span><br><span class="line">read         readarray    readelf      readlink     readonly     readprofile  </span><br><span class="line">topeet@ubuntu:~/demo$ readelf -S a.out </span><br><span class="line">There are 31 section headers, starting at offset 0x3aa8:</span><br><span class="line"></span><br><span class="line">节头：</span><br><span class="line">  [号] 名称              类型             地址              偏移量</span><br><span class="line">       大小              全体大小          旗标   链接   信息   对齐</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .interp           PROGBITS         0000000000000318  00000318</span><br><span class="line">       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">  [ 2] .note.gnu.propert NOTE             0000000000000338  00000338</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE             0000000000000358  00000358</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .note.ABI-tag     NOTE             000000000000037c  0000037c</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 5] .gnu.hash         GNU_HASH         00000000000003a0  000003a0</span><br><span class="line">       0000000000000028  0000000000000000   A       6     0     8</span><br><span class="line">  [ 6] .dynsym           DYNSYM           00000000000003c8  000003c8</span><br><span class="line">       00000000000000c0  0000000000000018   A       7     1     8</span><br><span class="line">  [ 7] .dynstr           STRTAB           0000000000000488  00000488</span><br><span class="line">       0000000000000088  0000000000000000   A       0     0     1</span><br><span class="line">  [ 8] .gnu.version      VERSYM           0000000000000510  00000510</span><br><span class="line">       0000000000000010  0000000000000002   A       6     0     2</span><br><span class="line">  [ 9] .gnu.version_r    VERNEED          0000000000000520  00000520</span><br><span class="line">       0000000000000020  0000000000000000   A       7     1     8</span><br><span class="line">  [10] .rela.dyn         RELA             0000000000000540  00000540</span><br><span class="line">       00000000000000c0  0000000000000018   A       6     0     8</span><br><span class="line">  [11] .rela.plt         RELA             0000000000000600  00000600</span><br><span class="line">       0000000000000018  0000000000000018  AI       6    24     8</span><br><span class="line">  [12] .init             PROGBITS         0000000000001000  00001000</span><br><span class="line">       000000000000001b  0000000000000000  AX       0     0     4</span><br><span class="line">  [13] .plt              PROGBITS         0000000000001020  00001020</span><br><span class="line">       0000000000000020  0000000000000010  AX       0     0     16</span><br><span class="line">  [14] .plt.got          PROGBITS         0000000000001040  00001040</span><br><span class="line">       0000000000000010  0000000000000010  AX       0     0     16</span><br><span class="line">  [15] .plt.sec          PROGBITS         0000000000001050  00001050</span><br><span class="line">       0000000000000010  0000000000000010  AX       0     0     16</span><br><span class="line">  [16] .text             PROGBITS         0000000000001060  00001060</span><br><span class="line">       0000000000000225  0000000000000000  AX       0     0     16</span><br><span class="line">  [17] .fini             PROGBITS         0000000000001288  00001288</span><br><span class="line">       000000000000000d  0000000000000000  AX       0     0     4</span><br><span class="line">  [18] .rodata           PROGBITS         0000000000002000  00002000</span><br><span class="line">       0000000000000014  0000000000000000   A       0     0     4</span><br><span class="line">  [19] .eh_frame_hdr     PROGBITS         0000000000002014  00002014</span><br><span class="line">       0000000000000064  0000000000000000   A       0     0     4</span><br><span class="line">  [20] .eh_frame         PROGBITS         0000000000002078  00002078</span><br><span class="line">       0000000000000188  0000000000000000   A       0     0     8</span><br><span class="line">  [21] .init_array       INIT_ARRAY       0000000000003db8  00002db8</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [22] .fini_array       FINI_ARRAY       0000000000003dc0  00002dc0</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [23] .dynamic          DYNAMIC          0000000000003dc8  00002dc8</span><br><span class="line">       00000000000001f0  0000000000000010  WA       7     0     8</span><br><span class="line">  [24] .got              PROGBITS         0000000000003fb8  00002fb8</span><br><span class="line">       0000000000000048  0000000000000008  WA       0     0     8</span><br><span class="line">  [25] .data             PROGBITS         0000000000004000  00003000</span><br><span class="line">       0000000000000018  0000000000000000  WA       0     0     8</span><br><span class="line">  [26] .bss              NOBITS           0000000000004018  00003018</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     4</span><br><span class="line">  [27] .comment          PROGBITS         0000000000000000  00003018</span><br><span class="line">       000000000000002b  0000000000000001  MS       0     0     1</span><br><span class="line">  [28] .symtab           SYMTAB           0000000000000000  00003048</span><br><span class="line">       00000000000006f0  0000000000000018          29    49     8</span><br><span class="line">  [29] .strtab           STRTAB           0000000000000000  00003738</span><br><span class="line">       0000000000000255  0000000000000000           0     0     1</span><br><span class="line">  [30] .shstrtab         STRTAB           0000000000000000  0000398d</span><br><span class="line">       000000000000011a  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br><span class="line">topeet@ubuntu:~/demo$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-1-5-动态库和静态库的生成"><a href="#3-1-5-动态库和静态库的生成" class="headerlink" title="3.1.5 动态库和静态库的生成"></a>3.1.5 动态库和静态库的生成</h2><p>使用以下命令可以生成静态库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libsub.a sub.o</span><br></pre></td></tr></table></figure>

<p>其中库的名字必须以lib开头，使用readelf重新读取以下该库的elf头，如下所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042226316.png" alt="image-20230904222640273"></p>
<p>使用以下命令生成动态库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC -o libsub.so sub.c</span><br></pre></td></tr></table></figure>

<p>然后使用readelf 读取elf头如下所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042227936.png" alt="image-20230904222725900"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BF%90%E8%A1%8C/" rel="tag">程序的编译、链接和运行</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/14/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/16/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="热爱学习的未来酱"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>