<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="永远年轻，永远热泪盈眶" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 热爱学习的未来酱</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="热爱学习的未来酱" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover3.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">热爱学习的未来酱</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '向上的路，并不拥挤。拥挤是因为，大部分人选择了安逸', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-rk3568-驱动开发第二篇-字符设备基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%8C%E7%AF%87-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%9F%BA%E7%A1%80/"
    >rk3568 驱动开发第二篇 字符设备基础</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%8C%E7%AF%87-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2023-09-04T12:55:19.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第7章-menuconfig图形化配置实验"><a href="#第7章-menuconfig图形化配置实验" class="headerlink" title="第7章 menuconfig图形化配置实验"></a>第7章 menuconfig图形化配置实验</h1><p>Linux内核可以通过输入“make menuconfig”来打开图形化配置界面，menuconfig是一套图形化的配置工具，本章节来学习使用menuconfig配置内核。</p>
<h2 id="7-1图形化界面的操作"><a href="#7-1图形化界面的操作" class="headerlink" title="7.1图形化界面的操作"></a>7.1图形化界面的操作</h2><p>menuconfig图形化的配置工具需要 ncurses 库支持。ncurses库提供了一系列的API函数供调用者生成基于文本的图形界面，因此在使用menuconfig图形化配置界面之前需要先在 Ubuntu 中安装ncurses库，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line"></span><br><span class="line">sudo apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure>

<p>图形化配置界面主要有以下四种，在这四种方式中，最推荐的是 make menuconfig，它不依赖于 QT 或 GTK+，且非常直观。</p>
<p>make config （基于文本的最为传统的配置界面，不推荐使用）</p>
<p>make menuconfig （基于文本菜单的配置界面）</p>
<p>make xconfig （要求 QT 被安装）</p>
<p>make gconfig （要求 GTK+ 被安装）</p>
<p>如何打开menuconfig图形化配置界面呢？</p>
<p>以RK3568为例，在内核源码目录下输入以下命令，打开图形化配置界面。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm64</span><br><span class="line"></span><br><span class="line">make rockchip_linux_defconfig</span><br><span class="line"></span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps33.jpg" alt="img"> </p>
<p>图 7-1</p>
<p>打开后界面如下所（图7-2）示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps34.jpg" alt="img"> </p>
<p>图 7-2</p>
<p>打开menuconfig图形化配置界面以后，可以使用以下方式进行操作，如下表（表7-3）所示：</p>
<table>
<thead>
<tr>
<th>上下键</th>
<th>选择不同的行，即移动到不同的（每一行的）选项上</th>
</tr>
</thead>
<tbody><tr>
<td>空格键</td>
<td>用于在选择该选项，取消选择该选项之间来回切换</td>
</tr>
<tr>
<td>选择该（行所在的）选项</td>
<td>则对应的该选项前面就变成了 [ * ]，表示被选中了。把驱动编译编译成模块，用 M 来表示。把驱动编译到内核里面，用*来表示。</td>
</tr>
<tr>
<td>取消该选项</td>
<td>则对应的该选项变成了只有一个中括号，里面是空的，即：[ ]</td>
</tr>
<tr>
<td>左右键</td>
<td>用于在 Select&#x2F;Exit&#x2F;Help 之前切换</td>
</tr>
<tr>
<td>回车键</td>
<td>左右键切换到了某个键上，此时回车键，就执行相应的动作</td>
</tr>
<tr>
<td>Select</td>
<td>此时一般都是所在（的行的）选项，后面有三个短横线加上一个右箭头，即 —&gt;，表示此项下面还有子选项，即进入子菜单</td>
</tr>
<tr>
<td>Exit</td>
<td>直接退出当前的配置。所以，当你更改了一些配置，但是又没有去保存，此时一般都会询问你是否要保存当前（已修改后的最新的）配置，然后再退出。</td>
</tr>
<tr>
<td>Help</td>
<td>针对你当前所在某个（行的）选项，查看其帮助信息。一般来说，其帮助信息，都包含针对该选项的很详细的解释。换句话说：如果你对某个选项的功能，不是很清楚，那么就应该认真仔细的去看看其 Help，往往都会找到详细解释，以便你更加了解此配置的含义。另外一般也会写出，此选项所对应的宏。该宏，就是写出到配置文件中的那个宏，对于写 makefile 的人来说，往往也是利用此相关的宏，在 makefile 中，实现对应的不同的控制。</td>
</tr>
<tr>
<td>快捷键快速跳转到对应的选项</td>
<td>menuconfig 中的每一行的选项，都有一个用特殊颜色标记出来的字母，很明显，此字母，就是该行的快捷字母。注意：此类快捷字母，一般都是大写的，且是大小写区分的</td>
</tr>
<tr>
<td>&#x2F; 键</td>
<td>输入“&#x2F;”即可弹出搜索界面，然后输入我们想要搜索的内容即可。</td>
</tr>
</tbody></table>
<p>表 7-3</p>
<h2 id="7-2-Kconfig-语法简介"><a href="#7-2-Kconfig-语法简介" class="headerlink" title="7.2 Kconfig 语法简介"></a>7.2 Kconfig 语法简介</h2><p>上一小节我们打开的图形化配置界面是如何生成的呢？图形化配置界面中的每一个界面都会对应一个Kconfig文件。所以图形化配置界面的每一级菜单是由Kconfig文件来决定的。</p>
<p>图形化配置界面有很多菜单。所以就会有很多Kconfig文件，这也就是为什么我们会在内核源码的每个子目录下，都会看到Kconfig文件的原因，那掌握Kconfig文件相关的知识是不是就非常重要呢。</p>
<p>所以这一小节我们来看下如何编写Kconfig文件来生成图形化配置界面，也就是Kconfig文件的语法是什么。</p>
<p>\1. Mainmenu</p>
<p>mainmenu顾名思义就是主菜单，也就是我们输入完“make menuconfig”以后默认打开的界面，mainmenu用来设置主菜单的标题，如下所示：</p>
<p>mainmenu “Linux&#x2F;$(ARCH) $(KERNELVERSION) Kernel Configuration”</p>
<p>此行代码是设置菜单的名字为“Linux&#x2F;$(ARCH) $(KERNELVERSION) Kernel Configuration”。如下图（图7-4）所示，ARCH变量是通过“export ARCH&#x3D;arm64”设置的，内核版本KERNELVERSION为4.19.232。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps35.jpg" alt="img"> </p>
<p>图 7-4</p>
<p>2.source</p>
<p>source用于读取另一个Kconfig文件，比如“source “init&#x2F;Kconfig””就是读取init目录下的Kconfig文件。</p>
<p>3.menu&#x2F;endmenu</p>
<p>menu&#x2F;endmenu条目用于生成菜单，如下（图7-5）所示，生成了Watchdog Timer Support的菜单。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">menu <span class="string">&quot;Watchdog Timer Support&quot;</span></span><br><span class="line"> </span><br><span class="line">config HW_WATCHDOG</span><br><span class="line">	bool</span><br><span class="line"> </span><br><span class="line">config WDT</span><br><span class="line">	bool <span class="string">&quot;Enable driver model for watchdog timer drivers&quot;</span></span><br><span class="line">	depends on DM</span><br><span class="line">	help</span><br><span class="line">	  Enable driver model for watchdog timer. At the moment the API.</span><br><span class="line">......</span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure>

<p>图 7-5</p>
<p>menu之后的字符串是菜单名，“menu”是菜单开始的标志，“endmenu”是菜单结束的标志，这俩个是成对出现的。“menu”和“endmenu”之间有很多config条目。在kernel目录下输入make menuconfig，如下图（图7-6）所示，可以看到上述代码描述的”Watchdog Timer Support”菜单。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps36.jpg" alt="img"> </p>
<p>图 7-6</p>
<p>进入“ Watchdog Timer Support  —&gt; ”可以看到很多config定义的条目，如下（图7-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps37.jpg" alt="img"> </p>
<p>图 7-7</p>
<p>4.if&#x2F;endif</p>
<p>if&#x2F;endif 语句是一个条件判断，定义了一个 if 结构，Kconfig中代码如下（图7-8）所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">menu &quot;Hardware Drivers Config&quot;</span><br><span class="line">    menuconfig BSP_USING_CAN</span><br><span class="line">        bool &quot;Enable CAN&quot;</span><br><span class="line">        default n</span><br><span class="line">        select RT_USING_CAN</span><br><span class="line">        if BSP_USING_CAN</span><br><span class="line">            config BSP_USING_CAN1</span><br><span class="line">                bool &quot;Enable CAN1&quot;</span><br><span class="line">                default n</span><br><span class="line">        endif</span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure>

<p>图 7-8</p>
<p>当没有选中 “Enable CAN” 选项时，下面通过 if 判断的 Enable CAN1 选项并不会显示出来。当上一级菜单选中 “Enable CAN” 时，Enable CAN1 选项才会显示。</p>
<p>\5. choice&#x2F;endchooice</p>
<p>choice条目将多个类似的配置选项组合到一起，供用户选择，用户选择是从“choice”开始，从“endchoice”结束，“choice”和“endchoice”之间有很多的config条目，这些config条目是提供用户选择的，如下（图7-9）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">choice</span><br><span class="line">        bool <span class="string">&quot;Parade TrueTouch Gen5 MultiTouch Protocol&quot;</span></span><br><span class="line">        depends on TOUCHSCREEN_CYPRESS_CYTTSP5</span><br><span class="line">        default TOUCHSCREEN_CYPRESS_CYTTSP5_MT_B</span><br><span class="line">        help</span><br><span class="line">          This option controls which MultiTouch protocol will be used to</span><br><span class="line">          report the touch events.</span><br><span class="line">config TOUCHSCREEN_CYPRESS_CYTTSP5_MT_A</span><br><span class="line">        bool <span class="string">&quot;Protocol A&quot;</span></span><br><span class="line">        help</span><br><span class="line">          Select to enable MultiTouch touch reporting using protocol A</span><br><span class="line">          on Parade TrueTouch(tm) Standard Product Generation4 touchscreen</span><br><span class="line">          controller.</span><br><span class="line"> </span><br><span class="line">config TOUCHSCREEN_CYPRESS_CYTTSP5_MT_B</span><br><span class="line">        bool <span class="string">&quot;Protocol B&quot;</span></span><br><span class="line">        help</span><br><span class="line">          Select to enable MultiTouch touch reporting using protocol B</span><br><span class="line">          on Parade TrueTouch(tm) Standard Product Generation4 touchscreen</span><br><span class="line">          controller.</span><br><span class="line"> </span><br><span class="line">endchoice</span><br></pre></td></tr></table></figure>

<p>图 7-9</p>
<p>我们在内核目录下输入make menuconfig可以看到，如下（图7-10）所示，“Parade TrueTouch Gen5 MultiTouch Protocol”是choice选项名称，“Protocol B”是Kconfig里面默认选择的。“–&gt;”代表此菜单能进入，需要键盘操作进入。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps38.jpg" alt="img"> </p>
<p>图7-10</p>
<p>进入“Parade TrueTouch Gen5 MultiTouch Protocol”后，可以看到多选项提供给用户进行选择，如下（图7-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps39.jpg" alt="img"> </p>
<p>图7-11</p>
<p>6.comment</p>
<p>comment 语句出现在界面的第一行，用于定义一些提示信息。</p>
<p>comment “Compiler: $(CC_VERSION_TEXT)”</p>
<p>以上代码的配置界面如下（图7-12）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps40.jpg" alt="img"> </p>
<p>图7-12</p>
<p>7.config</p>
<p>使用关键字config来定义一个新的选项，如下（图7-13）所示</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config helloworld</span><br><span class="line">bool “hello world support”</span><br><span class="line">default y</span><br><span class="line">help</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>图7-13</p>
<p>如上所示，使用config关键字定义了一个“helloworld”选项，每个选项都必须指定类型，类型包括bool，tristate,string,hex,int。最常见的是bool,tristate,string这三个。</p>
<p>bool类型取值只有“y”和“n”</p>
<p>tristate类型的变量取值有3种：“y”,“n”,“m”</p>
<p>string类型取值为字符串</p>
<p>hex类型取值为十六进制的数据</p>
<p>int类型取值为十进制的数据</p>
<p>help表示帮助信息，当我们在图形化界面按下h按键，弹出来的就是help的内容。</p>
<p>8.depends on</p>
<p>Kconfig中depends on关键字用来指定依赖关系，当依赖的选项被选中时，当前的配置选项的信息才会在菜单中显示出来，才能操作该选项的内容。举例来说，如下所示，选项A依赖选项B，只有当选项B被选中时，选项A才可以被选中。</p>
<p>config A</p>
<p>depends on B</p>
<p>9.select</p>
<p>Kconfig中select关键字用来表示反向依赖关系，当指定当前选项被选中时，此时select后面的选项也会被自动选中。举个例子来说，如下所示，在选项A被选中的情况下，选项B自动被选中。</p>
<p>config A</p>
<p>select on B</p>
<p>\10. menuconfig</p>
<p>menuconfig可以认为是config 中的升级版。menuconfig也是一个正常的配置项，通过自己的配置值来决定另外一组配置项是否作为子菜单的形式显示出来并供用户配置。代码如下（图7-14）所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">menuconfig NETDEVICES</span><br><span class="line">	default y if UML</span><br><span class="line">	depends on NET</span><br><span class="line">	bool &quot;Network device support&quot;</span><br><span class="line">	---help---</span><br><span class="line">if NETDEVICES</span><br><span class="line">config MII</span><br><span class="line">	tristate</span><br><span class="line"></span><br><span class="line">config NET_CORE</span><br><span class="line">	default y</span><br><span class="line">	bool &quot;Network core driver support&quot;</span><br><span class="line">	---help---</span><br><span class="line">	  You can say N here if you do not intend to use any of the</span><br><span class="line">	  networking core drivers (i.e. VLAN, bridging, bonding, etc.)</span><br></pre></td></tr></table></figure>

<p>图7-14</p>
<p>以上代码中通过menuconfig配置了一个bool类型的配置项，在图形化配置界面中显示（图7-15）如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps41.jpg" alt="img"> </p>
<p>图7-15</p>
<p>当我们选中”Network device support”配置项时，其子菜单被显示出来，如下图（图7-16）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps42.jpg" alt="img"> </p>
<p>图7-16</p>
<h2 id="7-3-config配置文件介绍"><a href="#7-3-config配置文件介绍" class="headerlink" title="7.3 .config配置文件介绍"></a>7.3 .config配置文件介绍</h2><p>我们在图形化配置界面配置好了以后，会得到一个.config配置文件。在编译内核的时候会根据这个.config文件来编译内核。这样是不是就实现了通过图像化界面的配置来配置内核呀。用通俗的话来说，Kconfig就是饭店的菜单，.config就是客人点完的菜。然后厨师会根据客人点的菜，也就是.config来做菜，对应的操作就是编译内核。</p>
<p>那.config是如何产生的呢？对应上面的例子就是要有服务员给我们点菜呀。</p>
<p>当我们使用make menuconfig的时候，会通过mconf程序去解析Kconfig文件，然后生成对应的配置文件.config。所以这个mconf就是服务员。</p>
<p>mconf程序源码在内核源码scripts&#x2F;kconfig目录下，如下图所示，这里不对Kconfig文件的解析流程进行分析，感兴趣的同学可以自行分析下mconf的源码。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps43.jpg" alt="img"> </p>
<p>图7-18</p>
<p>有了.config配置文件以后，内核就可以根据这个配置文件来编译内核，比如控制某些驱动编译进内核，或者控制某些驱动不编译内核。那他是怎么实现的呢？</p>
<p>.config会通过syncconfig目标将.config作为输入然后输出需要文件，这里我们重点更关注auto.conf和autoconf.h。如下图（图7-19）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps44.jpg" alt="img"> </p>
<p>图7-19</p>
<p>在auto.conf文件中，存放的是配置信息。如下图（图7-20）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps45.jpg" alt="img"> </p>
<p>图7-20</p>
<p>在内核源码的顶层Makefile中会包含auto.conf文件，以此引用其中的变量来控制Makefile的动作，如哪些驱动编译，哪些驱动不编译。如：</p>
<p>auto.conf文件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include include/config/auto.conf</span><br><span class="line">CONFIG _A=y</span><br></pre></td></tr></table></figure>

<p>顶层Makefile中包含auto.conf文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifeq ($(dot-config),1)</span><br><span class="line">include include/config/auto.conf</span><br><span class="line">Endif</span><br></pre></td></tr></table></figure>



<p>内核源码下drivers&#x2F;A&#x2F;Makefile引用这个变量</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONFIG _A) +=A.o</span><br></pre></td></tr></table></figure>



<p>注：obj-y就是编译进内核，obj-m就是编译成ko文件。</p>
<p>在autoconf.h中，是C语言代码。用来配合编译时的条件选择。如下图（图7-21）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps46.jpg" alt="img"> </p>
<p>图7-21</p>
<h2 id="7-4-defconfig配置文件"><a href="#7-4-defconfig配置文件" class="headerlink" title="7.4 defconfig配置文件"></a>7.4 defconfig配置文件</h2><p>defconfig文件和.config文件都是linux内核的配置文件，defconfig文件在内核源码的arch&#x2F;$(ARCH)&#x2F;configs目录下，是Linux系统默认的配置文件。比如说瑞芯微平台Linux源码默认的配置文件为：kernel&#x2F;arch&#x2F;arm64&#x2F;configs&#x2F;rockchip_linux_defconfig。</p>
<p>.config文件位于Linux内核源码的顶层目录下，编译Linux内核时会使用.config文件里面的配置来编译内核镜像。</p>
<p>如果.config文件存在，make menuconfig界面的默认配置也就是当前.config文件的配置，如果修改了图形化配置界面的设置并保存，那么.config文件会被更新。</p>
<p>如果.config文件不存在，使用命令“make XXX_defconfig”命令会根据arch&#x2F;$(ARCH)&#x2F;configs目录下的XXX_defconfig自动生成.config。make menuconfig界面的默认配置则为defconfig文件中的默认配置，比如说瑞芯微平台Linux内核源码目录下输入“make rockchip_linux_defconfig”会自动生成.config文件。那么此时rockchip_linux_defconfig的配置项和.config的配置项是相同的。</p>
<h2 id="7-5-自定义菜单实验"><a href="#7-5-自定义菜单实验" class="headerlink" title="7.5 自定义菜单实验"></a>7.5 自定义菜单实验</h2><p>有了上面的理论基础后，我们就可以自己在图形化配置界面中来自定义一个菜单，要定义一个菜单，根据我们前面的分析，是不是就要从Kconfig文件入手呀。因为图形化配置界面是根据Kconfig文件来生成的！</p>
<p>1 在kernel目录下创建一个topeet的文件夹，如下（图7-22）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps47.jpg" alt="img"> </p>
<p>图7-22</p>
<p>2 打开kernel下的Kconfig文件，在里面加入以下代码：</p>
<p>source “topeet&#x2F;Kconfig”</p>
<p>添加完成后如下（图7-23）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps48.jpg" alt="img"> </p>
<p>图7-23</p>
<p>3 然后进入到topeet文件夹，在此文件夹下创建一个Kconfig文件，创建完成如下（图7-24）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps49.jpg" alt="img"> </p>
<p>图7-24</p>
<p>4 打开创建好的Kconfig文件，写入以下（图7-25）内容：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">menu <span class="string">&quot;test menu&quot;</span></span><br><span class="line">config TEST_CONFIG</span><br><span class="line">bool <span class="string">&quot;test&quot;</span></span><br><span class="line">default y</span><br><span class="line">help</span><br><span class="line">just test</span><br><span class="line">comment <span class="string">&quot;just test&quot;</span></span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure>

<p>图7-25</p>
<p>在上面的代码中，我们在主菜单中添加了一个名为 test menu 的子菜单，然后在这个子菜单里面我们添加了一个名为 TEST_CONFIG 的配置项，这个配置项变量类型为 bool，默认配置为 Y，帮助信息为 just test，注释为 just test。添加完成如下图（图7-26）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps50.jpg" alt="img"> </p>
<p>图7-26</p>
<p>5 添加完成以后，打开图形化配置界面，如下图（图7-27）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps51.jpg" alt="img"> </p>
<p>图7-27</p>
<p>6子菜单中的配置项，默认为 y，注释信息为 just test。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps52.jpg" alt="img"> </p>
<p>图7-28</p>
<p>7 在此界面输入？，显示帮助信息为 just test，如下（图7-29）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps53.jpg" alt="img"> </p>
<p>图7-29</p>
<p>8 保存退出后，打开内核源码目录下的.config 文件，如下图（图7-30）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps54.jpg" alt="img"> </p>
<p>图7-30</p>
<p>9 可以在这个.config 文件中找到添加的 TEST_CONFIG（注意，我们需要在 make menuconfig 中保存才可以看到，否则是看不到我们添加的这个选项的），这样在编译内核的时候就可以根据这个配置信息来执行对应的操作了，就是我们下一章节要给大家讲的把驱动编译进内核，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps55.jpg" alt="img"> </p>
<p>图7-31</p>
<h1 id="第8章-驱动模块编译进内核实验"><a href="#第8章-驱动模块编译进内核实验" class="headerlink" title="第8章 驱动模块编译进内核实验"></a>第8章 驱动模块编译进内核实验</h1><p>通过上一章的学习，我们学会了使用menuconfig图形化配置工具，以及了解了menuconfig相关的文件：Kconfig .config XXXdefconfig。本章节学习将helloworld驱动编译进内核。</p>
<p>输入“cd drivers&#x2F;char”进入到 drivers&#x2F;char 目录下，然后输入“mkdir hello”建立hello文件夹，并输入“cd hello”进入hello文件夹，如下（图8-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps56.jpg" alt="img"> </p>
<p>图8-1</p>
<p>然后将第三章编写的hello.c文件拷贝到hello文件夹内。如下（图8-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps57.jpg" alt="img"> </p>
<p>图8-2</p>
<p>输入“touch Kconfig”命令创建Kconfig文件，Kconfig文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config HELLO</span><br><span class="line">tristate &quot;hello world&quot;</span><br><span class="line">help</span><br><span class="line">hello hello</span><br></pre></td></tr></table></figure>

<p>然后“touch Makefile”命令创建Makefile文件,Makefile文件内容如下所示：</p>
<p>obj-$(CONFIG_HELLO)+&#x3D;helloworld.o</p>
<p>接下来修改上一级目录的Kconfig文件和Makefile文件，也就是driver&#x2F;char目录。Makefile添加如下图(图8-3)所示内容。</p>
<p>obj-y +&#x3D; hello&#x2F;</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps58.jpg" alt="img"> </p>
<p>图8-3</p>
<p>Kconfig添加如下图（图8-4）所示内容：</p>
<p>source “drivers&#x2F;char&#x2F;hello&#x2F;Kconfig”</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps59.jpg" alt="img"> </p>
<p>图8-4</p>
<p>最后打开menuconfig图形化配置工具，在配置界面选择helloworld驱动。把驱动编译进Linux内核，用 * 来表示，所以配置选项改为*。如果想要将驱动编译为模块，则用M来表示，配置选项改为M。这里我们选择成 * </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers ─&gt;</span><br><span class="line">    Character devices ---&gt;</span><br><span class="line">        &lt;*&gt; hello world或者&lt;M&gt; hello world</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps60.jpg" alt="img"> </p>
<p>图8-5</p>
<p>然后将光标移动到save，保存配置，如下图（图8-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps61.jpg" alt="img"> </p>
<p>图8-6</p>
<p>保存到.config文件，如下（图8-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps62.jpg" alt="img"> </p>
<p>图-7</p>
<p>退出配置界面，然后输入以下命令便可以编译源码了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make savedefconfig</span><br><span class="line">cp defconfig arch/arm64/configs/rockchip_linux_defconfig </span><br><span class="line">cd ../</span><br><span class="line">./build.sh kernel</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps63.jpg" alt="img"> </p>
<p>图8-8</p>
<p>编译成功之后，进入到drivers&#x2F;char&#x2F;hello目录下，可以看到会生成对应的.o文件。就说明已经成功将驱动编译进内核。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps64.jpg" alt="img"> </p>
<p>图8-9</p>
<p>将编译好的内核镜像烧写到开发板上后，在开发板系统启动的时候也可以成功看到加载helloworld驱动，如下图（图8-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps65.jpg" alt="img"> </p>
<p>图8-10</p>
<p>如果在图形化配置界面中选择的M，也就是编译成驱动模块，则生成helloworld.ko文件如下图（图8-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps66.jpg" alt="img"> </p>
<p>图8-11</p>
<h1 id="第9章-申请字符设备号实验"><a href="#第9章-申请字符设备号实验" class="headerlink" title="第9章 申请字符设备号实验"></a>第9章 申请字符设备号实验</h1><p>经过前面章节的学习，相信大家已经对驱动模块的基本框架、驱动模块传参等知识有了自己的认识，本章节开始就要进入字符设备的世界了。 字符设备是指在I&#x2F;O传输过程中以字符为单位进行传输的设备，可以使用与普通文件相同的文件操作命令（打开、关闭、读、写等）对字符设备进行操作，是Linux驱动中最基本的一类设备驱动，例如最常见的LED、按键、IIC、SPI，LCD等都属于字符设备的范畴。要想对字符设备进行操作，需要通过设备号来对相应的设备进行查找，在本章节将对设备号相关知识进行讲解。 </p>
<h2 id="9-1-申请驱动设备号"><a href="#9-1-申请驱动设备号" class="headerlink" title="9.1 申请驱动设备号"></a>9.1 申请驱动设备号</h2><h3 id="9-1-1-设备号申请"><a href="#9-1-1-设备号申请" class="headerlink" title="9.1.1 设备号申请"></a>9.1.1 设备号申请</h3><p>在Linux系统中每一个设备都有相应的设备号，通过该设备号查找对应的设备，从而进行之后的文件操作。设备号有主设备号与次设备号之分，主设备号用来表示一个特定的驱动，次设备号用来管理下面的设备。</p>
<p>在Linux驱动中可以使用以下两种方法进行设备号的申请：</p>
<p>1.通过register_chrdev_region(dev_t from, unsigned count, const char *name)函数进行静态申请设备号。</p>
<p>2.通过alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,const char *name)函数进行动态申请设备号。</p>
<p>两个函数在“内核源码&#x2F;include&#x2F;linux&#x2F;fs.h”文件中引用(在编写驱动程序的时候要加入该文件的引用)，如下（图9-1）所示： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *, <span class="type">unsigned</span>, <span class="type">unsigned</span>, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">register_chrdev_region</span><span class="params">(<span class="type">dev_t</span>, <span class="type">unsigned</span>, <span class="type">const</span> <span class="type">char</span> *)</span>;   </span><br></pre></td></tr></table></figure>

<p>图9-1</p>
<p>静态申请设备号：</p>
<p><strong>函数原型</strong>：</p>
<p>register_chrdev_region(dev_t from, unsigned count, const char *name)</p>
<p><strong>函数作用：</strong></p>
<p>静态申请设备号，对指定好的设备号进行申请。</p>
<p><strong>参数含义：</strong></p>
<p> from: 自定义的dev_t类型设备号</p>
<p> count: 申请设备的数量</p>
<p> name: 申请的设备名称</p>
<p><strong>函数返回值：</strong>申请成功返回0，申请失败返回负数</p>
<p>动态申请设备号：</p>
<p><strong>函数原型：</strong></p>
<p>alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,const char *name)</p>
<p><strong>函数作用</strong></p>
<p>动态申请设备号，内核会自动分配一个未使用的设备号，相较于静态申请设备号，动态申请会避免注册设备号相同引发冲突的问题。</p>
<p><strong>参数含义</strong></p>
<p>dev *: 会将申请完成的设备号保存在dev变量中</p>
<p>baseminor: 次设备号可申请的最小值</p>
<p>count: 申请设备的数量</p>
<p>name: 申请的设备名称</p>
<p>****函数返回值：****申请成功返回0，申请失败返回负数</p>
<p>对于申请设备号所用到的函数就讲解完成了，会在之后的测试小节对两个函数进行实际运用。</p>
<h3 id="9-1-2-设备号类型"><a href="#9-1-2-设备号类型" class="headerlink" title="9.1.2 设备号类型"></a>9.1.2 设备号类型</h3><p>申请的设备号类型为dev_t ，在“内核源码&#x2F;include&#x2F;linux&#x2F;types.h” 文件中定义如下（图9-2）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> u32 <span class="type">__kernel_dev_t</span>;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">__kernel_dev_t</span>      <span class="type">dev_t</span>;</span><br></pre></td></tr></table></figure>

<p>图 9-2</p>
<p>dev_t为u32类型，而u32 定义在文件 “内核源码&#x2F;include&#x2F;uapi&#x2F;asm-generic&#x2F;int-ll64.h”文件中，定义如下（图9-3）： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> __u32;</span><br></pre></td></tr></table></figure>

<p>图 9-3</p>
<p>__u32为unsigned int类型，所以dev_t是一个无符号的32位整形类型。其中高12位表示主设备号，低20位表示次设备号。在“内核源码&#x2F;include&#x2F;linux&#x2F;kdev_t.h”中提供了设备号相关的宏定义，如下（图9-4）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MINORBITS   20   <span class="comment">/*次设备号位数*/</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINORMASK   ((1U &lt;&lt; MINORBITS) - 1)  <span class="comment">/*次设备号掩码*/</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAJOR(dev)  ((unsigned int) ((dev) &gt;&gt; MINORBITS))<span class="comment">/*dev右移20位得到主设备号*/</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINOR(dev)  ((unsigned int) ((dev) &amp; MINORMASK))  <span class="comment">/*与次设备掩码与，得到次设备号*/</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MKDEV(ma,mi)    (((ma) &lt;&lt; MINORBITS) | (mi))<span class="comment">/*MKDEV宏将主设备号（ma）左移20位，然后与次设备号（mi）相与，得到设备号*/</span></span></span><br></pre></td></tr></table></figure>

<p>图 9-4</p>
<p>在稍后的实验中不论是静态申请设备号还是动态申请设备号都会用到上述宏，例如在静态申请设备号时需要将指定的主设备号和从设备号通过MKDEV(ma,mi)宏进行设备号的转换，在动态申请设备号时可以用MAJOR(dev) 和MINOR(dev)宏将动态申请的设备号转化为主设备号和从设备号。</p>
<p>至此，关于设备号相关的知识就结束了，在下一小节中将对申请设备号实验代码进行编写。</p>
<h2 id="9-2-实验程序的编写"><a href="#9-2-实验程序的编写" class="headerlink" title="9.2 实验程序的编写"></a>9.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\04。</p>
<p>本章节实验将编写Linux下申请字符设备号实例代码，如果在进行驱动模块加载时传入了major主设备号，则通过静态的方式进行设备号的申请，如果不传入任何参数进行驱动模块加载，则通过动态的方式进行设备号申请。</p>
<p>编写完成的dev_t.c代码如下（图9-5）所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>                                                                                                                                </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major;<span class="comment">//定义静态加载方式时的主设备号参数major</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> minor;<span class="comment">//定义静态加载方式时的次设备号参数minor</span></span><br><span class="line">module_param(major,<span class="type">int</span>,S_IRUGO);<span class="comment">//通过驱动模块传参的方式传递主设备号参数major</span></span><br><span class="line">module_param(minor,<span class="type">int</span>,S_IRUGO);<span class="comment">//通过驱动模块传参的方式传递次设备号参数minor</span></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型(32位大小)的变量dev_num</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">dev_t_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;<span class="comment">//定义int类型的变量ret，用来判断函数返回值</span></span><br><span class="line">    <span class="comment">/*以主设备号进行条件判断，即如果通过驱动传入了major参数则条件成立，进入以下分支*/</span></span><br><span class="line">    <span class="keyword">if</span>(major)&#123;</span><br><span class="line">        dev_num = MKDEV(major,minor);<span class="comment">//通过MKDEV函数将驱动传参的主设备号和次设备号转换成dev_t类型的设备号</span></span><br><span class="line">        printk(<span class="string">&quot;major is %d\n&quot;</span>,major);</span><br><span class="line">        printk(<span class="string">&quot;minor is %d\n&quot;</span>,minor);</span><br><span class="line">        ret = register_chrdev_region(dev_num,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>);<span class="comment">//通过静态方式进行设备号册</span></span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            printk(<span class="string">&quot;register_chrdev_region is error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        printk(<span class="string">&quot;register_chrdev_region is ok\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*如果没有通过驱动传入major参数，则条件成立，进入以下分支*/</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ret = alloc_chrdev_region(&amp;dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_num&quot;</span>);<span class="comment">//通过动态方式进行设备号注册</span></span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);</span><br><span class="line">        &#125;                                                                                                                                              </span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line">        major=MAJOR(dev_num);<span class="comment">//通过MAJOR()函数进行主设备号获取</span></span><br><span class="line">        minor=MINOR(dev_num);<span class="comment">//通过MINOR()函数进行次设备号获取</span></span><br><span class="line">        printk(<span class="string">&quot;major is %d\n&quot;</span>,major);</span><br><span class="line">        printk(<span class="string">&quot;minor is %d\n&quot;</span>,minor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">dev_t_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    unregister_chrdev_region(dev_num,<span class="number">1</span>);<span class="comment">//释放字符驱动设备号 </span></span><br><span class="line">    printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(dev_t_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(dev_t_exit);<span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);  <span class="comment">//作者信息  </span></span><br></pre></td></tr></table></figure>

<p>图 9-5</p>
<p>以上代码通过对传入参数的判断，从而进行设备号申请方式的选择，会在下一小节进行相应的驱动加载测试。</p>
<h2 id="9-3-运行测试"><a href="#9-3-运行测试" class="headerlink" title="9.3 运行测试"></a>9.3 运行测试</h2><h3 id="9-3-1-编译驱动程序"><a href="#9-3-1-编译驱动程序" class="headerlink" title="9.3.1 编译驱动程序"></a>9.3.1 编译驱动程序</h3><p>在上一小节中的dev_t.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图9-6）所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m += dev_c.o    #此处要和你的驱动源文件同名</span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    #make操作</span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    #make clean操作</span><br></pre></td></tr></table></figure>

<p>图 9-6</p>
<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放dev_t.c和Makefile文件目录下，如下图（图9-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps67.jpg" alt="img"> </p>
<p>图 9-7</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图9-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps68.jpg" alt="img"> </p>
<p>图 9-8</p>
<p>编译完生成dev_t.ko目标文件，如下图（图9-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps69.jpg" alt="img"> </p>
<p>图 9-9</p>
<p>至此我们的驱动模块就编译成功了，下面对驱动进行加载测试。</p>
<h3 id="9-3-2-运行测试"><a href="#9-3-2-运行测试" class="headerlink" title="9.3.2 运行测试"></a>9.3.2 运行测试</h3><p>开发板上电启动之后，使用以下命令加载dev_t.ko驱动，加载完成之后的打印信息如下图图（9-10）所示：</p>
<p>insmod dev_t.ko major&#x3D;200 minor&#x3D;0</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps70.jpg" alt="img"> </p>
<p>图 9-10</p>
<p>可以看到传入的主设备号和次设备号都被打印了出来，“register_chrdev_region is ok”也被成功打印了证明设备注册成功了，然后使用以下命令进行注册设备号的查看，如下图（图9-11）所示：</p>
<p> cat &#x2F;proc&#x2F;devices</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps71.jpg" alt="img"> </p>
<p>图 9-11</p>
<p>可以看到主设备号200的设备名为chrdev_name，和驱动程序中设置的相同，证明我们的设备号注册成功了，然后使用以下命令进行驱动的卸载，如下图（图9-12）所示：</p>
<p>rmmod dev_t.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps72.jpg" alt="img"> </p>
<p>图 9-12</p>
<p>下面进行动态申请设备号实验，使用以下命令进行驱动模块的加载，如下图（图9-13）所示：</p>
<p> insmod dev_t.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps73.jpg" alt="img"> </p>
<p>图 9-13</p>
<p>可以看到动态申请设备号成功了，主设备号为236，次设备号为0，然后使用以下命令进行注册设备号的查看，如下图（图9-14）所示：</p>
<p> cat &#x2F;proc&#x2F;devices</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps74.jpg" alt="img"> </p>
<p>图 9-14</p>
<p>可以看到主设备号236的设备名为chrdev_name，和驱动程序中设置的相同，证明我们的设备号注册成功了，最后可以输入以下命令对驱动进行卸载，卸载完成如下图（图9-15）所示：</p>
<p>rmmod dev_t.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps75.jpg" alt="img"> </p>
<p>图 9-15</p>
<h1 id="第10章-注册字符设备实验"><a href="#第10章-注册字符设备实验" class="headerlink" title="第10章 注册字符设备实验"></a>第10章 注册字符设备实验</h1><p>在上一小节中已经对设备号的相关知识进行了讲解，并成功申请到了设备号，那在Linux系统中，设备号是怎样与字符设备进行关联的呢？字符设备又是怎样注册的呢？带着疑问，让我们开始本章节的学习吧。</p>
<h2 id="10-1-注册字符设备"><a href="#10-1-注册字符设备" class="headerlink" title="10.1 注册字符设备"></a>10.1 注册字符设备</h2><p>注册字符设备可以分为两个步骤：</p>
<p>1.字符设备初始化</p>
<p>2.字符设备的添加</p>
<p>在本小节将对上述两个步骤所用到的函数和结构体进行讲解。</p>
<h3 id="10-1-1-字符设备初始化"><a href="#10-1-1-字符设备初始化" class="headerlink" title="10.1.1 字符设备初始化"></a>10.1.1 字符设备初始化</h3><p>字符设备初始化所用到的函数为cdev_init(…),在对该函数讲解之前，首先对cdev结构体进行介绍。</p>
<p>Linux 内核中将字符设备抽象成一个具体的数据结构 (struct cdev), 我们可以理解为字符设备对象，cdev 记录了字符设备号、内核对象、文件操作file_operations结构体（设备的打开、读写、关闭等操作接口）等信息，struct cdev 结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;cdev.h”文件中（在编写驱动程序的时候要加入该文件的引用），如下（图10-1）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>                  <span class="comment">//内嵌的内核对象.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>                 <span class="comment">//该字符设备所在的内核模块的对象指针.</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span>    <span class="comment">//该结构描述了字符设备所能实现的方法，是极为关键的一个结构体.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>                <span class="comment">//用来将已经向内核注册的所有字符设备形成链表.</span></span><br><span class="line">	<span class="type">dev_t</span> dev;                            <span class="comment">//字符设备的设备号，由主设备号和次设备号构成.</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> count;                   <span class="comment">//隶属于同一主设备号的次设备号的个数.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>图 10-1</p>
<p>关于该结构体参数的注释在上图已经添加，设备初始化所用到的函数为cdev_init(),该函数同样在“内核源码&#x2F;include&#x2F;linux&#x2F;cdev.h”文件中所引用如下（图10-2）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="type">const</span> <span class="keyword">struct</span> file_operations *)</span>;</span><br></pre></td></tr></table></figure>

<p> 图10-2</p>
<p>该函数的详细内容在“内核源码&#x2F;include&#x2F;fs&#x2F;char_dev.c”文件中定义，如下（图10-3）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cdev, <span class="number">0</span>, <span class="keyword">sizeof</span> *cdev);<span class="comment">//将整个结构体清零；</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);<span class="comment">//初始化list成员使其指向自身；</span></span><br><span class="line">    kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);<span class="comment">//初始化kobj成员；</span></span><br><span class="line">    cdev-&gt;ops = fops;<span class="comment">//初始化ops成员，建立cdev 和 file_operations之间的连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图 10-3</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>初始化传入的cdev 类型的结构体，并与自定义的file_operations * 类型的结构体进行链接。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p> cdev: 要传入的cdev类型结构体，为要初始化的字符设备。</p>
<p> fops：要传入的file_operations * 类型结构体，关于file_operations结构体的相关的知识会在下一章节进行讲解。</p>
<p>****函数返回值：****无返回值。</p>
<h3 id="10-1-2-字符设备的注册"><a href="#10-1-2-字符设备的注册" class="headerlink" title="10.1.2 字符设备的注册"></a>10.1.2 字符设备的注册</h3><p><em><strong>*字符设备的注册：*</strong></em>	</p>
<p>字符设备添加所用到的函数为cdev_add()，该函数在“内核源码&#x2F;include&#x2F;linux&#x2F;cdev.h”文件中所引用，如下（图10-4）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="type">dev_t</span>, <span class="type">unsigned</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>图 10-4</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int cdev_add(struct cdev *p, dev_t dev, unsigned count)   </p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>该函数向内核注册一个struct cdev结构体</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>(1)第一个参数为要添加的struct cdev 类型的结构体</p>
<p>(2)第二个参数为申请的字符设备号</p>
<p>(3)第三个参数为和该设备关联的设备编号的数量。</p>
<p>这两个参数直接赋值给struct cdev 的dev成员和count成员。</p>
<p>****函数返回值：****添加成功返回0，添加失败返回负数。</p>
<p><em><strong>*字符设备的注销：*</strong></em></p>
<p>字符设备删除所用到的函数为cdev_del()，该函数同样在“内核源码&#x2F;include&#x2F;linux&#x2F;cdev.h”文件中所引用，如下（图10-5）所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cdev_del(struct cdev *);</span><br></pre></td></tr></table></figure>

<p>图 10-5</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>void cdev_del(struct cdev *p)  </p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>该函数会向内核删除一个struct cdev 类型结构体</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>该函数只有一个参数，为要删除的struct cdev 类型的结构体</p>
<p>****函数返回值：****无返回值</p>
<p>至此，关于注册字符设备实验所用到的函数就讲解完成了，在下一小节中将编写注册字符设备代码。</p>
<h2 id="10-2-实验程序的编写"><a href="#10-2-实验程序的编写" class="headerlink" title="10.2 实验程序的编写"></a>10.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\05。</p>
<p>本实验采用动态申请设备号的方式进行设备号的申请，然后对设备进行注册，并将申请到的主设备号和次设备号以及设备注册情况打印到终端上。</p>
<p>编写完成的cdev.c代码如下（图10-6）所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型（32位大小）的变量dev_num,用来存放设备号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义cdev结构体类型的变量cdev_test</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_ops</span>&#123;</span></span><br><span class="line">	.owner=THIS_MODULE<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">&#125;;<span class="comment">//定义file_operations结构体类型的变量cdev_test_ops</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">module_cdev_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;<span class="comment">//定义int类型变量ret，进行函数返回值判断</span></span><br><span class="line">    <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>);<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_register_region is ok\n&quot;</span>);</span><br><span class="line">    major = MAJOR(dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">    minor = MINOR(dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">    printk(<span class="string">&quot;major is %d\n&quot;</span>,major);</span><br><span class="line">    printk(<span class="string">&quot;minor is %d\n&quot;</span>,minor);                                         </span><br><span class="line">cdev_init(&amp;cdev_test,&amp;cdev_test_ops);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到cdev_test_ops结构体</span></span><br><span class="line">cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块 </span></span><br><span class="line">    ret = cdev_add(&amp;cdev_test,dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        printk(<span class="string">&quot;cdev_add is error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;cdev_add is ok\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">module_cdev_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cdev_del(&amp;cdev_test);<span class="comment">//使用cdev_del()函数进行字符设备的删除</span></span><br><span class="line">    unregister_chrdev_region(dev_num,<span class="number">1</span>);<span class="comment">//释放字符驱动设备号 </span></span><br><span class="line">    printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(module_cdev_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(module_cdev_exit);<span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);  <span class="comment">//作者信息  </span></span><br></pre></td></tr></table></figure>

<p>图 10-6</p>
<p>相较于上一章节实验，本章节的代码去掉了静态申请设备号部分代码，并在申请设备号完成之后注册了相应的字符设备，并在驱动出口函数中添加了相应的字符设备删除代码（相关代码已加粗）。</p>
<p>需要注意的是，字符设备的注册要放在申请字符设备号之后，字符设备的删除要放在释放字符驱动设备号之前。</p>
<h2 id="10-3-运行测试"><a href="#10-3-运行测试" class="headerlink" title="10.3 运行测试"></a>10.3 运行测试</h2><h3 id="10-3-1-编译驱动程序"><a href="#10-3-1-编译驱动程序" class="headerlink" title="10.3.1 编译驱动程序"></a>10.3.1 编译驱动程序</h3><p>在上一小节中的cdev.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图10-7）所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m += cdev.o    #此处要和你的驱动源文件同名</span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    #make操作</span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    #make clean操作</span><br></pre></td></tr></table></figure>

<p>图 10-7</p>
<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放parameter.c和Makefile文件目录下，如下图（图10-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps76.jpg" alt="img"> </p>
<p>图 10-8</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图10-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps77.jpg" alt="img"> </p>
<p>图 10-9</p>
<p>编译完会生成 cdev.ko目标文件，如下图（图10-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps78.jpg" alt="img"> </p>
<p>图 10-10</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h3 id="10-3-2-运行测试"><a href="#10-3-2-运行测试" class="headerlink" title="10.3.2 运行测试"></a>10.3.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图10-11）所示：</p>
<p>insmod cdev.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps79.jpg" alt="img"> </p>
<p>图 10-11</p>
<p>可以看到动态申请设备号成功了，主设备号为236，次设备号为0，然后使用以下命令进行注册设备号的查看，如下图（图10-12）所示：</p>
<p> cat &#x2F;proc&#x2F;devices</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps80.jpg" alt="img"> </p>
<p>图 10-12</p>
<p>可以看到主设备号236的设备名为chrdev_name，和驱动程序中设置的设备名称相同，证明字符设备注册成功了，最后可以使用以下命令对驱动进行卸载，卸载完成如下图（10-13）所示：</p>
<p>rmmod cdev.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps81.jpg" alt="img"> </p>
<p>图 10-13</p>
<h1 id="第11章-创建设备节点实验"><a href="#第11章-创建设备节点实验" class="headerlink" title="第11章 创建设备节点实验"></a>第11章 创建设备节点实验</h1><p>在上两个章节的学习中，我们已经成功的申请了设备号并且注册了相应的字符设备。系统通过设备号对设备进行查找，而字符设备注册到内核之后，并不能直接进行设备文件操作命令（打开、关闭、读、写等），需要相应的设备文件作为桥梁以此来进行设备的访问，在本章节将对如何创建设备节点进行学习。 </p>
<h2 id="11-1-创建设备节点"><a href="#11-1-创建设备节点" class="headerlink" title="11.1 创建设备节点"></a>11.1 创建设备节点</h2><p>在Linux操作系统中一切皆文件，设备访问也是通过文件的方式来进行的，对于用来进行设备访问的文件称之为设备节点，设备节点被创建在&#x2F;dev目录下，将内核中注册的设备与用户层进行链接，这样应用程序才能对设备进行访问。</p>
<p>根据设备节点的创建方式不同，分为了手动创建设备节点和自动创建设备节点，下面对两种设备节点创建方式进行介绍。</p>
<h3 id="11-1-1-手动创建设备节点"><a href="#11-1-1-手动创建设备节点" class="headerlink" title="11.1.1 手动创建设备节点"></a>11.1.1 手动创建设备节点</h3><p>使用mknod命令手动创建设备节点，mknod 命令格式为：</p>
<p>mknod NAME TYPE MAJOR MINOR</p>
<p>参数含义：</p>
<p>NAME: 要创建的节点名称</p>
<p>TYPE: b表示块设备，c表示字符设备，p表示管道</p>
<p>MAJOR：要链接设备的主设备号</p>
<p>MINOR: 要链接设备的从设备号</p>
<p>例如使用以下命令创建一个名为device_test的字符设备节点，链接设备的主设备号和从设备号分别为236和0：</p>
<p>mknod &#x2F;dev&#x2F;device_test c 236 0 </p>
<h3 id="11-1-2-自动创建设备节点"><a href="#11-1-2-自动创建设备节点" class="headerlink" title="11.1.2 自动创建设备节点"></a>11.1.2 自动创建设备节点</h3><p>设备文件的自动创建是利用udev(mdev)机制来实现，多数情况下采用自动创建设备节点的方式。udev(mdev)可以检测系统中硬件设备状态，可以根据系统中硬件设备状态来创建或者删除设备文件。在驱动中首先使用class_create(…)函数对class进行创建，这个类存放于&#x2F;sys&#x2F;class&#x2F; 目录下，之后使用device_create(…)函数创建相应的设备，在进行模块加载时，用户空间中的udev会自动响应device_create()函数，寻找对应的类从而创建设备节点。</p>
<p>下面对于自动创建节点中所用到的函数进行解释说明：</p>
<p><em><strong>*class_create(…)函数*</strong></em></p>
<p>该函数在“内核源码&#x2F;include&#x2F;linux&#x2F;device.h”文件中所引用（由于上一小节中引用的cdev.h文件已包含device.h，所以不需要再重复引用），如下（图11-1）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> class_create(owner, name)       \</span></span><br><span class="line"><span class="meta">(&#123;                      \</span></span><br><span class="line"><span class="meta">   static struct lock_class_key __key; \</span></span><br><span class="line"><span class="meta">    __class_create(owner, name, &amp;__key);    \                                                                           </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>图 11-1</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>用于动态创建设备的逻辑类，并完成部分字段的初始化，然后将其添加进Linux内核系统。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>owner：struct module结构体类型的指针，指向函数即将创建的这个struct class的模块。一般赋值为THIS_MODULE。</p>
<p>name：char类型的指针，代表即将创建的struct class变量的名字。</p>
<p>返回值：struct class * 类型的结构体。 </p>
<p><em><strong>*class_destroy(…)函数*</strong></em></p>
<p>该函数在“内核源码&#x2F;include&#x2F;linux&#x2F;device.h”文件中所引用，如下（图11-2）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">class_destroy</span><span class="params">(<span class="keyword">struct</span> class *cls)</span>;  </span><br></pre></td></tr></table></figure>

<p>图 11-2</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>用于删除设备的逻辑类，即从Linux内核系统中删除设备的逻辑类。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>owner：struct module结构体类型的指针，指向函数即将创建的这个struct class的模块。一般赋值为THIS_MODULE。</p>
<p>name：char类型的指针，代表即将创建的struct class变量的名字。</p>
<p>返回值：无</p>
<p><em><strong>*device_create(…)函数*</strong></em></p>
<p>该函数在“内核源码&#x2F;include&#x2F;linux&#x2F;device.h”文件中所引用，如下（图11-3）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device *<span class="title function_">device_create</span><span class="params">(<span class="keyword">struct</span> class *cls, <span class="keyword">struct</span> device *parent,                                                  </span></span><br><span class="line"><span class="params">               <span class="type">dev_t</span> devt, <span class="type">void</span> *drvdata,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>图 11-3</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>用来在class类中下创建一个设备属性文件，udev会自动识别从而进行设备节点的创建。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>cls：指定所要创建的设备所从属的类。</p>
<p>parent:指定该设备的父设备，如果没有就指定为NULL。</p>
<p>devt:指定创建设备的设备号。</p>
<p>drvdata:被添加到该设备回调的数据，没有则指定为NULL。</p>
<p>fmt：添加到系统的设备节点名称。</p>
<p>****返回值：****struct device * 类型结构体</p>
<p><em><strong>*device_destroy(…)函数*</strong></em></p>
<p>在“内核源码&#x2F;include&#x2F;linux&#x2F;device.h”文件中所引用，如下（图11-4）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">device_destroy</span><span class="params">(<span class="keyword">struct</span> class *cls, <span class="type">dev_t</span> devt)</span>; </span><br></pre></td></tr></table></figure>

<p>图 11-4</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>用来删除class类中的设备属性文件，udev会自动识别从而进行设备节点的删除。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>cls：指定所要创建的设备所从属的类。</p>
<p>devt:指定创建设备的设备号。</p>
<p>返回值：无</p>
<p>至此，关于自动创建节点相关的函数就介绍完成了，会在下一小节中对于设备节点的自动创建进行相应实验程序的编写。</p>
<h2 id="11-2-实验程序的编写"><a href="#11-2-实验程序的编写" class="headerlink" title="11.2 实验程序的编写"></a>11.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\06。</p>
<p>本章实验将编写Linux下的自动创建设备节点实验代码，首先采用自动申请设备号的方式进行设备号的申请，并对获取的主设备号与次设备号进行打印，之后对字符设备进行注册(file_operations结构体只填充owner 字段即可，会在下个章节对file_operations结构体进行讲解)，最后自动对设备节点进行创建。</p>
<p>编写完成的chrdev_node.c代码如下（图11-5）所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_fops_test</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">&#125;;<span class="comment">//定义file_operations结构体类型的变量cdev_test_ops</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chrdev_fops_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;<span class="comment">//定义int类型的变量ret，用来对函数返回值进行判断</span></span><br><span class="line">    <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>);<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">    <span class="keyword">if</span> (ret  &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">    major = MAJOR(dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">    minor = MINOR(dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">    printk(<span class="string">&quot;major is %d\n minor is %d \n&quot;</span>,major,minor);</span><br><span class="line">    cdev_init(&amp;cdev_test,&amp;cdev_fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到cdev_test_ops结构&gt;体</span></span><br><span class="line">    cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    ret = cdev_add(&amp;cdev_test,dev_num,<span class="number">1</span>); <span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">         printk(<span class="string">&quot;cdev_add is error \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;cdev_add is ok \n&quot;</span>);</span><br><span class="line">    class_test  = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">    device_create(class_test,<span class="literal">NULL</span>,dev_num,<span class="literal">NULL</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chrdev_fops_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cdev_del(&amp;cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">    unregister_chrdev_region(dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">    device_destroy(class_test,dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">    class_destroy(class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">    printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(chrdev_fops_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(chrdev_fops_exit);<span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);<span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>图 11-5</p>
<p>相较于上一章节实验，本章节代码在入口函数中添加了自动创建设备节点相关代码，在驱动出口函数中添加了相应的删除设备节点相关代码(相关代码已加粗)。</p>
<p>需要注意的是，在进行设备节点添加时，类的创建要放在设备创建之前；在进行设备节点删除时，类的删除要放在设备删除之后。</p>
<h2 id="11-3-运行测试"><a href="#11-3-运行测试" class="headerlink" title="11.3 运行测试"></a>11.3 运行测试</h2><h3 id="11-3-1-编译驱动程序"><a href="#11-3-1-编译驱动程序" class="headerlink" title="11.3.1 编译驱动程序"></a>11.3.1 编译驱动程序</h3><p>在上一小节中的chrdev_node.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图11-6）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += chrdev_node.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>图 11-6</p>
<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放chrdev_node.c和Makefile文件目录下，如下图（图11-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps82.jpg" alt="img"> </p>
<p>图 11-7</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图11-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps83.jpg" alt="img"> </p>
<p>图 11-8</p>
<p>编译完生成 chrdev_node.ko目标文件，如下图（图11-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps84.jpg" alt="img"> </p>
<p>图 11-9</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h3 id="11-3-2-运行测试"><a href="#11-3-2-运行测试" class="headerlink" title="11.3.2 运行测试"></a>11.3.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图11-10）所示：</p>
<p>insmod cdev.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps85.jpg" alt="img"> </p>
<p>图 11-10</p>
<p>可以看到动态申请设备号成功了，主设备号为236，次设备号为0，然后使用以下命令进行注册设备号的查看，如下图（图11-11）所示：</p>
<p> cat &#x2F;proc&#x2F;devices</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps86.jpg" alt="img"> </p>
<p>图 11-11</p>
<p>可以看到主设备号236的设备名为chrdev_name，和驱动程序中设置的相同，证明我们的设备号注册成功了，然后使用以下命令对class目录进行查看，如下图（图11-12）所示：</p>
<p>ls &#x2F;sys&#x2F;class&#x2F;</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps87.jpg" alt="img"> </p>
<p>图 11-12</p>
<p>可以看到在驱动程序中创建的class_test 类已经被成功创建了，然后使用以下命令对class_test 目录进行查看，如下图（图11-12）所示：</p>
<p>ls &#x2F;sys&#x2F;class&#x2F;class_test&#x2F;</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps88.jpg" alt="img"> </p>
<p>图 11-12</p>
<p>可以看到在驱动程序中创建的名为device_test的设备属性文件夹也被创建了，然后使用命令“ls &#x2F;dev&#x2F;device_test”对&#x2F;dev目录进行查看，相应的设备节点也已经被自动创建了，如下图（图11-13）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps89.jpg" alt="img"> </p>
<p>图 11-13</p>
<p>最后可以使用以下命令进行驱动的卸载，卸载完成如下图（图11-14）所示：</p>
<p>rmmod chrdev_node.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps90.jpg" alt="img"> </p>
<p>图 11-14</p>
<h1 id="第12章-字符设备驱动框架实验"><a href="#第12章-字符设备驱动框架实验" class="headerlink" title="第12章 字符设备驱动框架实验"></a>第12章 字符设备驱动框架实验</h1><p>下面对前面三个章节进行总结，首先驱动向Linux内核进行设备号申请，之后的字符设备注册时，会对申请的设备号进行使用。而Linux 内核会将字符设备抽象成一个具体的struct cdev结构体，该结构体记录了字符设备的字符设备号、内核对象等信息，cdev_init(…)函数对结构体进行初始化之后，cdev_add(…)函数将设备号和cdev结构体进行链接，这时设备号才真正指向了内核中注册的设备。设备注册成功之后，此时还不能对字符设备进行文件操作，所以需要设备节节点来充当内核和用户层通信的桥梁，至此，前面三个章节就总结完成了，以上步骤并没有涉及到操作设备文件，本章节将对字符设备框架进行最终的完善。 </p>
<h2 id="12-1-文件操作集简介"><a href="#12-1-文件操作集简介" class="headerlink" title="12.1 文件操作集简介"></a>12.1 文件操作集简介</h2><p> 在进行注册字符设备实验章节中，使用cdev_init(…)函数对struct cdev结构体类型变量和struct file_operations结构体类型变量相链接，struct file_operations结构体就是把系统调用和驱动程序关联起来的关键数据结构。该结构体的每一个成员都对应着一个系统调用，读取file_operation中相应的函数指针，接着把控制权转交给函数，从而完成了Linux设备驱动程序的工作。</p>
<p>file_operations结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;fs.h”文件中，下面对部分常用函数进行说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br></pre></td></tr></table></figure>

<p>owner是第一个 file_operations 成员，它并不是一个操作, 而一个指向拥有该结构的模块的指针，避免正在操作时被卸载，一般为初始化为THIS_MODULES (在 &lt;linux&#x2F;module.h&gt; 中定义的宏)</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br></pre></td></tr></table></figure>

<p>read函数指针用来从设备中同步读取数据，读取成功返回读取的字节数。与应用程序中的 read函数对应。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br></pre></td></tr></table></figure>

<p>write函数指针用来发送数据给设备. 写入成功返回写入的字节数。与应用程序中的write函数对应。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br></pre></td></tr></table></figure>

<p>unlocked_ioctl函数指针提供对于设备的控制功能，与应用程序中的ioctl函数对应。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br></pre></td></tr></table></figure>

<p>open函数指针用于打开设备,与应用程序中的open函数对应。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br></pre></td></tr></table></figure>

<p>release函数指针在file结构体释放时被调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br></pre></td></tr></table></figure>

<p>至此对于file_operations文件操作集的部分常用函数就介绍完了，填充了部分常用函数的 file_operations结构体如下（图12-1）所示：</p>
<p>图 12-1</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_fops_test</span> =</span> &#123;</span><br><span class="line">   .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">   .open = chrdev_open,<span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">   .read = chrdev_read,<span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">   .write = chrdev_write,<span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">   .release = chrdev_release,<span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;<span class="comment">//定义file_operations结构体类型的变量cdev_test_ops</span></span><br></pre></td></tr></table></figure>



<p>会在下个小节进行字符设备驱动框架实验代码的编写，在上一章节实验的基础上加入file_operations结构体，并通过应用程序对字符设备驱动进行文件操作测试。</p>
<h2 id="12-2-实验程序的编写"><a href="#12-2-实验程序的编写" class="headerlink" title="12.2 实验程序的编写"></a>12.2 实验程序的编写</h2><h3 id="12-2-1-驱动程序编写"><a href="#12-2-1-驱动程序编写" class="headerlink" title="12.2.1 驱动程序编写"></a>12.2.1 驱动程序编写</h3><p>本实验驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\07\module。</p>
<p>本章实验将编写字符设备驱动框架实验，会在上一章节实验基础上对file_operation结构体相关内容进行补充。</p>
<p>首先采用自动申请设备号的方式进行设备号的申请，然后对获取的主设备号与次设备号进行打印，之后对字符设备进行注册，并填充相应的file_openration结构体和相关函数，最后自动对设备节点进行创建，编写完成的chrdev_fops.c代码如下（图12-2）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>                                                                                                    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chrdev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is chrdev_open \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">chrdev_read</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is chrdev_read \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">chrdev_write</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *buf,<span class="type">size_t</span> size,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is chrdev_write \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chrdev_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_fops_test</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = chrdev_open,<span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = chrdev_read,<span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = chrdev_write,<span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = chrdev_release,<span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;<span class="comment">//定义file_operations结构体类型的变量cdev_test_ops</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chrdev_fops_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;<span class="comment">//定义int类型的变量ret，用来对函数返回值进行判断</span></span><br><span class="line">    <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>);<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">    <span class="keyword">if</span> (ret  &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">    major = MAJOR(dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">    minor = MINOR(dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">    printk(<span class="string">&quot;major is %d\n minor is %d \n&quot;</span>,major,minor);</span><br><span class="line">    cdev_init(&amp;cdev_test,&amp;cdev_fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到cdev_test_ops结构体</span></span><br><span class="line">    cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    ret = cdev_add(&amp;cdev_test,dev_num,<span class="number">1</span>); <span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">         printk(<span class="string">&quot;cdev_add is error \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;cdev_add is ok \n&quot;</span>);                                                                                </span><br><span class="line">    class_test  = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">    device_create(class_test,<span class="literal">NULL</span>,dev_num,<span class="literal">NULL</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chrdev_fops_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    device_destroy(class_test,dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">class_destroy(class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">    cdev_del(&amp;cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">    unregister_chrdev_region(dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">    printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(chrdev_fops_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(chrdev_fops_exit);<span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);<span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>图 12-2</p>
<h3 id="12-2-2-编写测试-APP"><a href="#12-2-2-编写测试-APP" class="headerlink" title="12.2.2 编写测试 APP"></a>12.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\07\app。</p>
<p>由于在驱动程序中，只是对一系列文件操作函数添加了标志打印（之后的章节会加入数据的读写），所以本小节的应用程序只是起简单的测试作用。编写完成的应用程序app.c内容如下（图12-3）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>];<span class="comment">//定义读取缓冲区buf</span></span><br><span class="line">    fd=open(argv[<span class="number">1</span>],O_RDWR,<span class="number">0666</span>);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;open is ok\n&quot;</span>);</span><br><span class="line">	<span class="comment">/*如果第二个参数为read，条件成立，调用read函数，对文件进行读取*/</span>                                                                                                                                  </span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;read&quot;</span>))&#123;</span><br><span class="line">        read(fd,buf,<span class="number">32</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为write，条件成立，调用write函数，对文件进行写入*/</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;write&quot;</span>))&#123;</span><br><span class="line">        write(fd,<span class="string">&quot;hello\n&quot;</span>,<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">close(fd);<span class="comment">//调用close函数，对取消文件描述符到文件的映射</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>图 12-3</p>
<p>上述应用程序逻辑较为简单，第一个参数为要进行读写操作的设备节点，第二个参数为read时，对设备节点进行读操作，第二个参数为write时，对设备节点进行写操作。</p>
<h2 id="12-3-运行测试"><a href="#12-3-运行测试" class="headerlink" title="12.3 运行测试"></a>12.3 运行测试</h2><h3 id="12-3-1-编译驱动程序"><a href="#12-3-1-编译驱动程序" class="headerlink" title="12.3.1 编译驱动程序"></a>12.3.1 编译驱动程序</h3><p>在上一小节中的chrdev_fops.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图12-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += chrdev_fops.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>图 12-4</p>
<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放chrdev_fops.c和Makefile文件目录下，如下图（图12-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps91.jpg" alt="img"> </p>
<p>图 12-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图12-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps92.jpg" alt="img"> </p>
<p>图 12-6</p>
<p>编译完生成chrdev_fops.ko目标文件，如下图（图12-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps93.jpg" alt="img"> </p>
<p>图 12-7</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h3 id="12-3-2-编译应用程序"><a href="#12-3-2-编译应用程序" class="headerlink" title="12.3.2 编译应用程序"></a>12.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图12-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps94.jpg" alt="img"> </p>
<p>图 12-8</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图12-9）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps95.jpg" alt="img"> </p>
<p>图 12-9</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="12-3-3-运行测试"><a href="#12-3-3-运行测试" class="headerlink" title="12.3.3 运行测试"></a>12.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图12-10）所示：</p>
<p>insmod chrdev_fops.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps96.jpg" alt="img"> </p>
<p>图 12-10</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图12-11）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps97.jpg" alt="img"> </p>
<p>图 12-11</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令对open()函数进行测试，如下图（图12-11）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps98.jpg" alt="img"> </p>
<p>图 12-12</p>
<p>可以看到“This is chrdev_open”和“open is ok”信息被打印了，证明应用程序运行成功，且调用了驱动程序中的open(…)函数，而“Segmentation fault”相关打印是因为没有对第二个参数进行传入，这里忽略即可，随后使用以下命令对设备进行读测试，如下图（图12-13）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test read</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps99.jpg" alt="img"> </p>
<p>图 12-13</p>
<p>可以看到“This is chrdev_read”信息被打印了出来，证明驱动程序中的read(…)函数被调用了,然后使用以下命令对设备进行写测试，如下图（图12-14）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test write</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps100.jpg" alt="img"> </p>
<p>图 12-14</p>
<p>可以看到“This is chrdev_write”信息被打印了出来，证明驱动程序中的write(…)函数被调用了。最后可以使用以下命令进行驱动的卸载，如下图（图12-15）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps101.jpg" alt="img"> </p>
<p>图 12-15</p>
<p>至此，字符设备驱动框架实验就完成了。</p>
<h1 id="第13章-杂项设备驱动实验"><a href="#第13章-杂项设备驱动实验" class="headerlink" title="第13章 杂项设备驱动实验"></a>第13章 杂项设备驱动实验</h1><p>经过前面章节的学习，我们已经对字符设备驱动框架有了一定的理解，而本章要讲解的杂项设备属于特殊的一种字符型设备，是对字符设备的一种封装，为最简单的字符设备。为什么从字符设备中单独提取出了杂项设备呢？杂项设备又要如何进行使用呢？带着疑问，让我们进行杂项设备的学习吧！</p>
<h2 id="13-1-杂项设备驱动简介"><a href="#13-1-杂项设备驱动简介" class="headerlink" title="13.1 杂项设备驱动简介"></a>13.1 杂项设备驱动简介</h2><p>在Linux中，把无法归类的五花八门的设备定义成杂项设备。相较于字符设备，杂项设备有以下两个优点:</p>
<p>(1)节省主设备号:杂项设备的主设备号固定为10，而字符设备不管是动态分配还是静态分配设备号，都会消耗一个主设备号，进而造成了主设备号浪费。当系统中注册了多个misc设备驱动时，只需使用子设备号进行区分即可。</p>
<p>(2)使用简单：当使用普通的字符设备驱动时，如果开发人员需要导出操作接口给用户空间，就需要注册对应的字符驱动，并创建字符设备class从而自动在&#x2F;dev下生成设备节点，而misc驱动只需要将基本信息通过结构体传递给相应处理函数即可。</p>
<p>在驱动中使用miscdevice结构体描述misc设备，该结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;miscdevice.h”文件中（在下面的实验代码中需要加入该头文件的引用），具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span>  &#123;</span></span><br><span class="line">	<span class="type">int</span> minor; <span class="comment">/* 子设备号 需要用户填写*/</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;<span class="comment">/* 设备名 需要用户填写*/</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span><span class="comment">/* 设备操作集 需要用户填写*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">this_device</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *nodename;</span><br><span class="line">	<span class="type">umode_t</span> mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义一个misc 设备，一般只需要填充minor、name、fops 这三个成员变量。</p>
<p>minor指次设备号，可以从“内核源码&#x2F;include&#x2F;linux&#x2F;miscdevice.h”文件中预定义的次设备号挑选，也可以自行定义子设备号（没有被其他设备使用即可），通常情况下将该参数设置为MISC_DYNAMIC_MINOR，表示自动分配子设备号。</p>
<p>name表示misc设备的名字。misc设备驱动注册成功之后，会在dev目录下生成名为name的设备节点。</p>
<p>fops 指向了file_operations的结构体，表示字符设备的操作集合。</p>
<h2 id="13-2-杂项设备的注册和卸载"><a href="#13-2-杂项设备的注册和卸载" class="headerlink" title="13.2 杂项设备的注册和卸载"></a>13.2 杂项设备的注册和卸载</h2><p>不同于字符设备的注册和卸载的繁琐，杂项设备的注册可以直接使用函数misc_register函数来完成，杂项设备的卸载可以直接使用misc_deregister函数来完成。上述两个函数均定义在“内核源码&#x2F;include&#x2F;linux&#x2F;miscdevice.h”文件当中。</p>
<p>杂项设备的注册：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int misc_register(struct miscdevice *misc)</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>基于misc_class构造一个设备，将miscdevice结构挂载到misc_list列表上，并初始化与linux设备模型相关的结构。进而起到杂项设备注册的作用。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p> misc: 杂项设备的结构体指针</p>
<p>****函数返回值：****申请成功返回0，申请失败返回负数</p>
<p>杂项设备的卸载：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int misc_deregister(struct miscdevice *misc)</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>从mist_list中删除miscdevice，进而起到杂项设备卸载的作用。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p> misc: 杂项设备的结构体指针</p>
<p>****函数返回值：****卸载成功返回0，申请失败返回负数</p>
<p>至此，注册和卸载杂项设备的API函数就讲解完成了，会在接下来的驱动章节中对上述函数进行具体使用。</p>
<h2 id="13-3-杂项设备驱动框架"><a href="#13-3-杂项设备驱动框架" class="headerlink" title="13.3 杂项设备驱动框架"></a>13.3 杂项设备驱动框架</h2><p>MISC驱动一般使用以下结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">xxx_fops</span>&#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">	.read = xxx_read,</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">xxx_dev</span>&#123;</span></span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">    .name = <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">    .fops = &amp;xxx_fops</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;xxx_init\r\n&quot;</span>);</span><br><span class="line">    ret = misc_register(&amp;xxx_dev);<span class="comment">//注册杂项设备</span></span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         printk( <span class="string">&quot;misc_register failed\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> 	printk( <span class="string">&quot;misc_register ok\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_exit</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;xxx_exit\r\n&quot;</span>);</span><br><span class="line">    misc_deregister(&amp;xxx_dev);  <span class="comment">//卸载杂项设备</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(xxx_init);    <span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(xxx_exit);   </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);   </span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="13-4-实验程序的编写"><a href="#13-4-实验程序的编写" class="headerlink" title="13.4 实验程序的编写"></a>13.4 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\08。</p>
<p>本小节将编写最简单的misc驱动，在驱动入口函数中通过misc_register(…)函数注册杂项设备驱动，在驱动出口函数中通过misc_deregister(…)函数注销杂项设备驱动。编写完成的miscdevice.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>              <span class="comment">//初始化头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>            <span class="comment">//最基本的文件，支持动态添加和卸载模块。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span>        <span class="comment">//注册杂项设备头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span>                <span class="comment">//注册设备节点的文件结构体</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">misc_fops</span> =</span> &#123; <span class="comment">//文件操作集</span></span><br><span class="line">    .owner = THIS_MODULE <span class="comment">////将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">misc_dev</span> =</span> &#123;       <span class="comment">//杂项设备结构体</span></span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR,     <span class="comment">//动态申请的次设备号</span></span><br><span class="line">    .name = <span class="string">&quot;test&quot;</span>,                  <span class="comment">//杂项设备名字是hello_misc</span></span><br><span class="line">    .fops = &amp;misc_fops,              <span class="comment">//文件操作集</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">misc_init</span><span class="params">(<span class="type">void</span>)</span>           </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = misc_register(&amp;misc_dev); <span class="comment">//在初始化函数中注册杂项设备</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;misc registe is error \n&quot;</span>); <span class="comment">//打印注册杂项设备失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;misc registe is succeed \n&quot;</span>);<span class="comment">//打印注册杂项设备成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">misc_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">    misc_deregister(&amp;misc_dev);     <span class="comment">//在卸载函数中注销杂项设备</span></span><br><span class="line">    printk(<span class="string">&quot; misc goodbye! \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(misc_init);</span><br><span class="line">module_exit(misc_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="13-5-运行测试"><a href="#13-5-运行测试" class="headerlink" title="13.5 运行测试"></a>13.5 运行测试</h2><h3 id="13-5-1-编译驱动程序"><a href="#13-5-1-编译驱动程序" class="headerlink" title="13.5.1 编译驱动程序"></a>13.5.1 编译驱动程序</h3><p>在上一小节中的miscdevice.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += miscdevice.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>Makefile保存退出之后，来到存放miscdevice.c和Makefile文件目录下，如下图（图13-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps102.jpg" alt="img"> </p>
<p>图 13-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 13-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps103.jpg" alt="img"> </p>
<p>图 13-2</p>
<p>编译完生成 miscdevice.ko目标文件，如下图（图 13-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps104.jpg" alt="img"> </p>
<p>图 13-2</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h3 id="13-5-2-运行测试"><a href="#13-5-2-运行测试" class="headerlink" title="13.5.2 运行测试"></a>13.5.2 运行测试</h3><p>将编译生成的驱动模块miscdevice.ko拷贝到开发板上，输入以下命令加载驱动模块。</p>
<p>insmod miscdevice.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps105.jpg" alt="img"> </p>
<p>图 13-3</p>
<p>可以看到驱动加载之后，打印“misc registe is succeed”,说明misc驱动注册成功。输入以下命令查看加载的驱动模块，驱动加载成功如下（图13-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps106.jpg" alt="img"> </p>
<p>图 13-4</p>
<p>然后来到&#x2F;sys&#x2F;class&#x2F;misc目录下，可以看到名为“test”的文件夹已经被创建了，在&#x2F;sys&#x2F;class&#x2F;misc目录下有misc类的所有设备，每个注册的杂项设备对应一个文件夹目录，如下图（图13-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps107.jpg" alt="img"> </p>
<p>图 13-5</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps108.jpg" alt="img"> </p>
<p>图 13-7</p>
<p>驱动加载成功之后会生成&#x2F;dev&#x2F;test设备驱动文件，输入以下命令查看杂项设备的主次设备号。</p>
<p>ls &#x2F;dev&#x2F;test -al</p>
<p>结果如下图（图 13-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps109.jpg" alt="img"> </p>
<p>图 13-8</p>
<p>从上图可以看出，&#x2F;dev&#x2F;test这个杂项设备的主设备号为10，次设备号为53，最后可以使用以下命令对驱动进行卸载，卸载完成如下图（图 13-9）所示：</p>
<p>rmmod miscdevice.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps110.jpg" alt="img"> </p>
<p>图 13-9</p>
<h1 id="第14章-内核空间与用户空间数据交互实验"><a href="#第14章-内核空间与用户空间数据交互实验" class="headerlink" title="第14章 内核空间与用户空间数据交互实验"></a>第14章 内核空间与用户空间数据交互实验</h1><p>在“第12章 字符设备驱动框架实验”中，已经对file_operations结构体的进行了填充，该结构体的每一个成员都对应着一个系统调用，例如read、write等，在对应的实验中，只是对调用函数进行了标志打印，并没有真正实现设备的读写功能，而在本章节将对内核空间与用户空间的数据交换功能进行实现。</p>
<h2 id="14-1-内核空间与用户空间"><a href="#14-1-内核空间与用户空间" class="headerlink" title="14.1 内核空间与用户空间"></a>14.1 内核空间与用户空间</h2><p>Linux系统将可访问的内存空间分为了两个部分，一部分是内核空间，一部分是用户空间。操作系统和驱动程序运行在内核空间（内核态），应用程序运行在用户空间（用户态）。</p>
<p>那么为什么要区分用户空间和内核空间呢？</p>
<p>（1）内核空间中的代码控制了硬件资源，用户空间中的代码只能通过内核暴露的系统调用接口来使用系统中的硬件资源，这样的设计可以保证操作系统自身的安全性和稳定性。</p>
<p>（2）从另一方面来说，内核空间的代码更偏向于系统管理，而用户空间中的代码更偏重业务逻辑实现，俩者的分工不同。</p>
<p>硬件资源管理都是在内核空间完成的，应用程序无法直接对硬件进行操作，只能通过调用相应的内核接口来完成相应的操作。比如应用程序要对磁盘上的一个文件进行读取，应用程序可以向内核发起一个“系统调用”申请——我要读取磁盘上的文件。这个过程其实是通过一个特殊的指令让进程从用户态进入到了内核态。在内核空间中，CPU可以执行任何命令，包括从磁盘上读取数据，具体过程是先把数据读取到内核空间中，然后再把数据拷贝到用户空间并从内核态切换到用户态。此时应用程序已经从系统调用中返回并拿到了想要的数据，可以继续往下执行了。</p>
<p>进程只有从用户空间切换到内核空间才可以使用系统的硬件资源，切换的方式有三种：系统调用，软中断，硬中断，如下图（图 14-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps111.jpg" alt="img"> </p>
<p>图 14-1</p>
<h2 id="14-2-用户空间和内核空间数据交换"><a href="#14-2-用户空间和内核空间数据交换" class="headerlink" title="14.2 用户空间和内核空间数据交换"></a>14.2 用户空间和内核空间数据交换</h2><p>内核空间和用户空间的内存是不能互相访问的。但是很多应用程序都需要和内核进行数据的交换，例如应用程序使用read函数从驱动中读取数据，使用write函数向驱动中写数据，上述功能就需要使用copy_from_user和copy_to_user俩个函数来完成。copy_from_user函数是将用户空间的数据拷贝到内核空间。copy_to_user函数是将内核空间的数据拷贝到用户空间。</p>
<p>这俩个函数定义在了kernel&#x2F;include&#x2F;linux&#x2F;uaccess.h文件下，如下所示：</p>
<p>copy_to_user</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>unsigned long copy_to_user_inatomic(void __user *to, const void *from, unsigned long n);</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>把内核空间的数据复制到用户空间。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>*to是用户空间的指针</p>
<p>*from是内核空间的指针</p>
<p>n是从内核空间向用户空间拷贝的字节数</p>
<p>copy_from_user</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>unsigned long copy_from_user(void *to, const void __user *from, unsigned long n)</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>把用户空间的数据复制到内核空间。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>*to是内核空间的指针</p>
<p>*from是用户空间的指针</p>
<p>n是从用户空间向内核空间拷贝的字节数</p>
<h2 id="14-3-实验程序编写"><a href="#14-3-实验程序编写" class="headerlink" title="14.3 实验程序编写"></a>14.3 实验程序编写</h2><h3 id="14-3-1-驱动程序编写"><a href="#14-3-1-驱动程序编写" class="headerlink" title="14.3.1 驱动程序编写"></a>14.3.1 驱动程序编写</h3><p>本驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\09\module。</p>
<p>在该实验中将实现内核空间和用户空间进行数据交换的功能。以12章编写的字符设备驱动框架实验为基础编写驱动程序，程序使用copy_to_user函数和copy_from_user函数来实现内核空间和用户空间互传数据的功能，编写完成的file.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;  <span class="comment">//主设备号</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> minor = <span class="number">0</span>;  <span class="comment">//次设备号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>       <span class="comment">//类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>    <span class="comment">//设备</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*本章实验重点******/</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//定义写入缓存区kbuf</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);<span class="comment">//打印copy_from_user函数执行失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_write\r\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;kbuf is %s\r\n&quot;</span>, kbuf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*本章实验重点******/</span></span><br><span class="line"><span class="type">char</span> kbuf[<span class="number">32</span>] = <span class="string">&quot;This is cdev_test_read!&quot;</span>;<span class="comment">//定义内核空间数据</span></span><br><span class="line"><span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, kbuf, <span class="built_in">strlen</span>(kbuf)) != <span class="number">0</span>)     &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>); <span class="comment">//打印copy_to_user函数执行失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数，定义file_operations结构体类型的变量cdev_test_fops*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read,  <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"><span class="comment">/*1 创建设备号*/</span></span><br><span class="line"><span class="comment">//动态分配设备号</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>);     <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);<span class="comment">//打印动态分配设备号失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    major = MAJOR(dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    minor = MINOR(dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">    cdev_add(&amp;cdev_test, dev_num, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">    device = device_create(class, <span class="literal">NULL</span>, dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;cdev_test);               <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(class, dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);   <span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(chr_fops_exit);  <span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码在cdev_test_read函数中使用copy_to_user函数将内核数据拷贝到用户空间，在cdev_test_write函数中使用copy_from_user函数将用户空间数据拷贝到内核空间。</p>
<h3 id="14-3-2-编写测试-APP"><a href="#14-3-2-编写测试-APP" class="headerlink" title="14.3.2 编写测试 APP"></a>14.3.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\09\app。</p>
<p>编写测试APP其实是在编写Linux应用，编译完成的应用程序app.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  <span class="comment">//主函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;   <span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//定义读取缓存区buf1</span></span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>; <span class="comment">//定义写入缓存区buf2</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开字符设备驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    read(fd, buf1, <span class="keyword">sizeof</span>(buf1));<span class="comment">//从/dev/test文件读取数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf1 is %s \r\n&quot;</span>, buf1); <span class="comment">//打印读取的数据</span></span><br><span class="line"></span><br><span class="line">    write(fd,buf2,<span class="keyword">sizeof</span>(buf2));<span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="14-4-运行测试"><a href="#14-4-运行测试" class="headerlink" title="14.4 运行测试"></a>14.4 运行测试</h2><h3 id="14-4-1-编译驱动程序"><a href="#14-4-1-编译驱动程序" class="headerlink" title="14.4.1 编译驱动程序"></a>14.4.1 编译驱动程序</h3><p>在上一小节中的file.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下   所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m +=file.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放file.c和Makefile文件目录下，如下图（图14-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps112.jpg" alt="img"> </p>
<p>图 14-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图14-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps113.jpg" alt="img"> </p>
<p>图14-3</p>
<p>编译完生成 file.ko目标文件，如下图（图 14-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps114.jpg" alt="img"> </p>
<p>图 14-4</p>
<p>至此我们的驱动模块就编译成功了，下面进行应用程序编译.</p>
<h3 id="14-4-2-编译应用程序"><a href="#14-4-2-编译应用程序" class="headerlink" title="14.4.2 编译应用程序"></a>14.4.2 编译应用程序</h3><p>因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图 14-5）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps115.jpg" alt="img"> </p>
<p>图 14-5</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="14-4-3-运行测试"><a href="#14-4-3-运行测试" class="headerlink" title="14.4.3 运行测试"></a>14.4.3 运行测试</h3><p>驱动模块file.ko和测试程序app都已经准备好了，接下来就是运行测试。首先输入以下命令加载驱动程序，如下图（图14–6）所示：</p>
<p>insmod file.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps116.jpg" alt="img"> </p>
<p>图 14-6</p>
<p>输入以下命令运行应用程序，如下图（图 14-7）所示</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps117.jpg" alt="img"> </p>
<p>图 14-7</p>
<p>由上图可知，打印“This is cdev_test_open”信息说明成功打开了字符设备驱动。</p>
<p>打印“ This is cdev_test_read”和“buf1 is This is cdev_test_read!”说明应用程序成功读取到内核的数据。</p>
<p>打印“This is cdev_test_write”和“kbuf is nihao”说明应用程序向内核写数据成功。</p>
<p>最后打印“This is cdev_test_release”说明卸载字符设备。</p>
<h1 id="第15章-文件私有数据实验"><a href="#第15章-文件私有数据实验" class="headerlink" title="第15章 文件私有数据实验"></a>第15章 文件私有数据实验</h1><p>在之前章节编写的驱动程序中，将生成字符设备的一些硬件属性（设备号、类、设备名称等）全都写成了变量的形式，虽然这样编写驱动代码不会产生报错，但是会显得有点不专业。通常在驱动开发中会为设备定义相关的设备结构体，将硬件属性的描述信息全部放在该结构体中，在本章节中将对设备结构体的功能实现和文件私有数据进行学习。</p>
<h2 id="15-1-文件私有数据简介"><a href="#15-1-文件私有数据简介" class="headerlink" title="15.1 文件私有数据简介"></a>15.1 文件私有数据简介</h2><p>Linux中并没有明确规定要使用文件私有数据，但是在linux驱动源码中，广泛使用了文件私有数据，这是Linux驱动遵循的“潜规则”，实际上也体现了Linux面向对象的思想。struct file 结构体中专门为用户留了一个域用于定义私有数据。结构体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">fu_llist</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">fu_rcuhead</span>;</span></span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span>	<span class="comment">/* cached value */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protects f_ep_links, f_flags.</span></span><br><span class="line"><span class="comment">	 * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rw_hint</span>		<span class="title">f_write_hint</span>;</span></span><br><span class="line">	<span class="type">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> 		f_flags;</span><br><span class="line">	<span class="type">fmode_t</span>			f_mode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">	<span class="type">loff_t</span>			f_pos;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="type">void</span>			*private_data;<span class="comment">//私有数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_ep_links</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_tfile_llink</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span></span><br><span class="line">	<span class="type">errseq_t</span>		f_wb_err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件私有数据的概念在Linux驱动中有着非常广泛的应用，文件私有数据就是将私有数据private_data指向设备结构体。通过它可以将私有数据一路从open函数带到read, write函数层层传入。一般是在open 的时候赋值，read、write时使用。open函数中私有数据的使用如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">	file-&gt;private_data=&amp;dev1;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，定义了一个设备结构体dev1，然后在open函数中，将私有数据private_data指向了设备结构体dev1。</p>
<p>我们可以在read write函数中通过private_data访问设备结构体，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> _user *buf, <span class="type">size_t</span> size,<span class="type">loff_t</span> *<span class="type">off_t</span>)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-2-实验程序编写"><a href="#15-2-实验程序编写" class="headerlink" title="15.2 实验程序编写"></a>15.2 实验程序编写</h2><h3 id="15-2-1-驱动程序编写"><a href="#15-2-1-驱动程序编写" class="headerlink" title="15.2.1 驱动程序编写"></a>15.2.1 驱动程序编写</h3><p>本驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\10\module。</p>
<p>本章实验将编写Linux下的使用文件私有数据实例代码，在open函数中对私有数据结构体赋值，在write函数中使用。编写完成的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">dev_t</span> dev_num;              <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;                  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;                   <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span>          <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>             <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>          <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];                <span class="comment">//缓存区buf</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  <span class="comment">//定义一个device_test结构体变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;  <span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data; <span class="comment">//在write函数中读取private_data</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_write\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;kbuf is %s\r\n&quot;</span>, test_dev-&gt;kbuf); <span class="comment">//打印kbuf的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;    </span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,         <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open,         <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read,          <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write,         <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release,<span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">  dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">    cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建设备*/</span></span><br><span class="line">    dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="15-2-2-编写测试-APP"><a href="#15-2-2-编写测试-APP" class="headerlink" title="15.2.2 编写测试 APP"></a>15.2.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\10\app。</p>
<p>编写测试APP其实是在编写Linux应用，在应用程序中向设备文件写入数据，编写完成的应用程序app.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> <span class="comment">//主函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>;  <span class="comment">//定义写入缓存区buf1</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR); <span class="comment">//打开/dev/test设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd,buf1,<span class="keyword">sizeof</span>(buf1)); <span class="comment">//向/dev/test设备写入数据</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-3-运行测试"><a href="#15-3-运行测试" class="headerlink" title="15.3 运行测试"></a>15.3 运行测试</h2><h3 id="15-3-1-编译驱动程序"><a href="#15-3-1-编译驱动程序" class="headerlink" title="15.3.1 编译驱动程序"></a>15.3.1 编译驱动程序</h3><p>在上一小节中的file.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图5-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += file.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放file.c和Makefile文件目录下，如下图（图15-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps118.jpg" alt="img"> </p>
<p>图15-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图15-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps119.jpg" alt="img"> </p>
<p>图 15-2</p>
<p>编译完生成 file.ko目标文件，如下图（图15-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps120.jpg" alt="img"> </p>
<p>图 15-3</p>
<p>至此我们的驱动模块就编译成功了，下面进行应用程序编译，</p>
<h3 id="15-3-2-编译应用程序"><a href="#15-3-2-编译应用程序" class="headerlink" title="15.3.2 编译应用程序"></a>15.3.2 编译应用程序</h3><p>因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图15-4）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps121.jpg" alt="img"> </p>
<p>图15-4</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="15-3-3-运行测试"><a href="#15-3-3-运行测试" class="headerlink" title="15.3.3 运行测试"></a>15.3.3 运行测试</h3><p>驱动模块file.ko和测试程序app都已经准备好了，接下来就是运行测试。</p>
<p>输入以下命令加载驱动程序</p>
<p>insmod file.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps122.jpg" alt="img"> </p>
<p>图 15-5</p>
<p>驱动加载成功之后会生成&#x2F;dev&#x2F;test设备驱动文件，输入以下命令查看杂项设备的主次设备号。</p>
<p>ls &#x2F;dev&#x2F;test -al</p>
<p>结果如下图（图15-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps123.jpg" alt="img"> </p>
<p>图 15-6</p>
<p>运行应用程序，如下（图 15-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps124.jpg" alt="img"> </p>
<p>图 15-7</p>
<p>在此实验中，将硬件属性的信息全部放在一个结构体private_data，依然可以实现字符设备的操作。</p>
<h1 id="第16章-一个驱动兼容不同设备实验"><a href="#第16章-一个驱动兼容不同设备实验" class="headerlink" title="第16章 一个驱动兼容不同设备实验"></a>第16章 一个驱动兼容不同设备实验</h1><p>在Linux中，使用主设备号来表示对应某一类驱动，使用次设备号来表示这类驱动下的各个设备。假如现在驱动要支持的主设备号相同，但是次设备号不同的设备。驱动程序要怎样编写呢，上一章节学习的私有数据private_date在此时就派上了用场，具体是怎样使用的呢，多个设备是如何在一个驱动中兼容的呢，带着疑问，让我们开始本章节的学习吧。</p>
<h2 id="16-1-container-of函数简介"><a href="#16-1-container-of函数简介" class="headerlink" title="16.1 container_of函数简介"></a>16.1 container_of函数简介</h2><p>container_of在Linux内核中是一个常用的宏，用于从包含在某个结构中的指针获得结构本身的指针，通俗地讲就是通过结构体变量中某个成员的首地址进而获得整个结构体变量的首地址。那么可以使用这个函数获取不同设备的地址，来对不同的设备进行操作，从而一个驱动可以兼容不同的设备。</p>
<p>container_of</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>container_of(ptr,type,member)</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>通过结构体变量中某个成员的首地址获取到整个结构体变量的首地址。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>ptr是结构体变量中某个成员的地址。</p>
<p>type是结构体的类型 </p>
<p>member是该结构体变量的具体名字</p>
<p>container_of宏的作用是通过结构体内某个成员变量的地址和该变量名，以及结构体类型。找到该结构体变量的地址。</p>
<h2 id="16-2-实验程序编写"><a href="#16-2-实验程序编写" class="headerlink" title="16.2 实验程序编写"></a>16.2 实验程序编写</h2><h3 id="16-2-1-驱动程序编写"><a href="#16-2-1-驱动程序编写" class="headerlink" title="16.2.1 驱动程序编写"></a>16.2.1 驱动程序编写</h3><p>本驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\11\module。</p>
<p>本章实验将使用container_of函数编写一个驱动兼容不同设备的实例代码，编写完成的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> dev_num;             <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major;                  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor;                  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span>        <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>           <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>        <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];              <span class="comment">//定义缓冲区kbuf</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span>   <span class="comment">//定义一个device_test结构体变量dev1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev2</span>;</span>  <span class="comment">//定义一个device_test结构体变量dev2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    dev1.minor = <span class="number">0</span>;    <span class="comment">//设置dev1的次设备号为0</span></span><br><span class="line">    dev2.minor = <span class="number">1</span>;   <span class="comment">//设置dev2的次设备号为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//inode-&gt;i_rdev 为该 inode 的设备号，使用container_of函数找到结构体变量dev1 dev2的地址</span></span><br><span class="line"><span class="comment">//然后设置私有数据</span></span><br><span class="line">    file-&gt;private_data = container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> device_test, cdev_test);</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span> =</span> (<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="comment">//如果次设备号是0，则为dev1</span></span><br><span class="line">    <span class="keyword">if</span> (test_dev-&gt;minor == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(<span class="string">&quot; test_dev-&gt;kbuf is %s\r\n&quot;</span>, test_dev-&gt;kbuf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果次设备号是1，则为dev2</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(test_dev-&gt;minor == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(<span class="string">&quot; test_dev-&gt;kbuf is %s\r\n&quot;</span>, test_dev-&gt;kbuf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span> =</span> (<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>(test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数,定义file_operations结构体类型的变量cdev_test_fops*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号,,这里注册2个设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对设备1进行操作</span></span><br><span class="line">    <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">    cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">    dev1.class = class_create(THIS_MODULE, <span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5 创建设备*/</span></span><br><span class="line">    dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev2.major = MAJOR(dev1.dev_num + <span class="number">1</span>); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev2.minor = MINOR(dev1.dev_num + <span class="number">1</span>); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev2.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev2.minor); <span class="comment">//打印次设备号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对设备2进行操作</span></span><br><span class="line">  <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev2.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev2.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">    cdev_add(&amp;dev2.cdev_test, dev1.dev_num + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">    dev2.class = class_create(THIS_MODULE, <span class="string">&quot;test2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">    dev2.device = device_create(dev2.class, <span class="literal">NULL</span>, dev1.dev_num + <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&quot;test2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>);    <span class="comment">//注销设备号</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num + <span class="number">1</span>, <span class="number">1</span>);  <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                  <span class="comment">//删除cdev</span></span><br><span class="line">    cdev_del(&amp;dev2.cdev_test);                  <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);     <span class="comment">//删除设备</span></span><br><span class="line">    device_destroy(dev2.class, dev1.dev_num + <span class="number">1</span>);  <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">    class_destroy(dev2.class);                 <span class="comment">//删除类</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="16-2-2-编写测试-APP"><a href="#16-2-2-编写测试-APP" class="headerlink" title="16.2.2 编写测试 APP"></a>16.2.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\11\app。</p>
<p>编写应用程序，打开生成的俩个设备，并向俩个设备中写入数据，编写完成的应用程序app.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd1;  <span class="comment">//定义设备1的文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd2;  <span class="comment">//定义设备2的文件描述符</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = <span class="string">&quot;nihao /dev/test1&quot;</span>;   <span class="comment">//定义写入缓存区buf1</span></span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = <span class="string">&quot;nihao /dev/test2&quot;</span>;   <span class="comment">//定义写入缓存区buf2</span></span><br><span class="line">    fd1 = open(<span class="string">&quot;/dev/test1&quot;</span>, O_RDWR);  <span class="comment">//打开设备1：test1</span></span><br><span class="line">    <span class="keyword">if</span> (fd1 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd1;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd1,buf1,<span class="keyword">sizeof</span>(buf1));  <span class="comment">//向设备1写入数据</span></span><br><span class="line">    close(fd1); <span class="comment">//取消文件描述符到文件的映射</span></span><br><span class="line"></span><br><span class="line">    fd2= open(<span class="string">&quot;/dev/test2&quot;</span>, O_RDWR); <span class="comment">//打开设备2：test2</span></span><br><span class="line">    <span class="keyword">if</span> (fd2 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd2;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd2,buf2,<span class="keyword">sizeof</span>(buf2));  <span class="comment">//向设备2写入数据</span></span><br><span class="line">    close(fd2);   <span class="comment">//取消文件描述符到文件的映射</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="16-3-运行测试"><a href="#16-3-运行测试" class="headerlink" title="16.3 运行测试"></a>16.3 运行测试</h2><h3 id="16-3-1-编译驱动程序"><a href="#16-3-1-编译驱动程序" class="headerlink" title="16.3.1 编译驱动程序"></a>16.3.1 编译驱动程序</h3><p>在上一小节中的file.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图5-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += file.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放file.c和Makefile文件目录下，如下图（图16-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps125.jpg" alt="img"> </p>
<p>图 16-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图16-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps126.jpg" alt="img"> </p>
<p>图 16-2</p>
<p>编译完生成 file.ko目标文件，如下图（图16-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps127.jpg" alt="img"> </p>
<p>图 16-3</p>
<p>至此我们的驱动模块就编译成功了，下面进行应用程序编译</p>
<h3 id="16-3-2-编译应用程序"><a href="#16-3-2-编译应用程序" class="headerlink" title="16.3.2 编译应用程序"></a>16.3.2 编译应用程序</h3><p>因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图 16-4）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps128.jpg" alt="img"> </p>
<p>图 16-5</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="16-3-2-运行测试"><a href="#16-3-2-运行测试" class="headerlink" title="16.3.2 运行测试"></a>16.3.2 运行测试</h3><p>驱动模块file.ko和测试程序app都已经准备好了，接下来就是运行测试。</p>
<p>输入以下命令加载驱动模块，如下图（图 16-6）所示：</p>
<p>insmod file.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps129.jpg" alt="img"> </p>
<p>图 16-7</p>
<p>驱动加载成功之后会生成&#x2F;dev&#x2F;test1和&#x2F;dev&#x2F;test2设备驱动文件，输入以下命令查看设备，可以看到一个驱动创建并管理了多个驱动设备，如下图（图 16-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps130.jpg" alt="img"> </p>
<p>图 16-9</p>
<p>运行应用程序，如下（图 16-10）所示:</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps131.jpg" alt="img"> </p>
<p>图 16-11</p>
<p>如上图所示，可以看到用户顺利向俩个设备写入数据，且每个设备拥有私有数据。</p>
<h1 id="第17章-Linux错误处理实验"><a href="#第17章-Linux错误处理实验" class="headerlink" title="第17章 Linux错误处理实验"></a>第17章 Linux错误处理实验</h1><p>在前面章节进行的字符设备驱动实验中，即使是最简单的注册字符设备，也存在注册失败的可能性，因此在之前编写的驱动代码中采用检查函数返回值的方式，确认函数是否成功执行，而在本章节中将采用goto语句对Linux错误处理进行更进一步的处理。</p>
<h2 id="17-1-goto语句简介"><a href="#17-1-goto语句简介" class="headerlink" title="17.1 goto语句简介"></a>17.1 goto语句简介</h2><p>在编写驱动程序时，驱动程序应该提供函数执行失败后处理的能力。如果驱动程序中函数执行失败了，必须取消掉所有失败前的注册，否则内核会处于一个不稳定的状态，因为它包含了不存在代码的内部指针。在处理Linux错误时，最好使用goto语句，goto语句的使用示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>   init <span class="title function_">my_init_function</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line">err = register_this(ptr1, <span class="string">&quot;skull&quot;</span>); </span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">	<span class="keyword">goto</span> fail_this;</span><br><span class="line"></span><br><span class="line">err = register_that(ptr2, <span class="string">&quot;skull&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">	<span class="keyword">goto</span> fail_that;</span><br><span class="line"></span><br><span class="line">err = register_those(ptr3, <span class="string">&quot;skull&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">	<span class="keyword">goto</span> fail_those;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line"> </span><br><span class="line">fail_those:</span><br><span class="line">	unregister_that(ptr2, <span class="string">&quot;skull&quot;</span>); </span><br><span class="line">fail_that:</span><br><span class="line">	unregister_this(ptr1, <span class="string">&quot;skull&quot;</span>);</span><br><span class="line">fail_this:</span><br><span class="line">	<span class="keyword">return</span> err;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中试图注册3个虚构设备，goto语句在失败情况下使用，对之前已经成功注册的设施进行注销。使用goto语句处理的时候，应该遵循“先进后出”的原则，如下图（图 17-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps132.jpg" alt="img"> </p>
<p>图 17-2</p>
<p>如果在驱动代码中初始化和卸载函数比较复杂，goto方法可能变得难于管理，为了使代码重复性最小以及流程化，Linux提供了更简便的方法，我们接着来学习下一小节。</p>
<h2 id="17-2-IS-ERR-简介"><a href="#17-2-IS-ERR-简介" class="headerlink" title="17.2 IS_ERR()简介"></a>17.2 IS_ERR()简介</h2><p>对于任何一个指针来说，必然存在三种情况，一种是合法指针，一种是NULL(也就是空指针)，一种是错误指针(也就是无效指针)。在Linux内核中，所谓的错误指针已经指向了内核空间的最后一页，例如，对于一个64位系统来说，内核空间最后地址为0xffffffffffffffff，那么最后一页的地址是0xfffffffffffff000~0xffffffffffffffff，这段地址是被保留的，如果指针落在这段地址之内，说明是错误的无效指针。</p>
<p>在Linux内核源码中实现了指针错误的处理机制，相关的函数接口主要有IS_ERR()、PTR_ERR()、ERR_PTR()等，其函数的源码在include&#x2F;linux&#x2F;err.h文件中，如下所示：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\ksohtml55808\wps133.jpg" alt="img"> </p>
<p>如上图所示，在Linux源码中IS_ERR()函数其实就是判断指针是否出错，如果指针指向了内核空间的最后一页，就说明指针是一个无效指针，如果指针并不是落在内核空间的最后一页，就说明这指针是有效的。无效的指针能表示成一种负数的错误码，如果想知道这个指针是哪个错误码，使用PTR_ERR函数转化。0xfffffffffffff000~0xffffffffffffffff这段地址和Linux错误码是一一对应的，内核错误码保存在errno-base.h文件中。如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_GENERIC_ERRNO_BASE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_GENERIC_ERRNO_BASE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EPERM		 1	<span class="comment">/* Operation not permitted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOENT		 2	<span class="comment">/* No such file or directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ESRCH		 3	<span class="comment">/* No such process */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EINTR		 4	<span class="comment">/* Interrupted system call */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EIO		 5	<span class="comment">/* I/O error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENXIO		 6	<span class="comment">/* No such device or address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	E2BIG		 7	<span class="comment">/* Argument list too long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOEXEC		 8	<span class="comment">/* Exec format error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EBADF		 9	<span class="comment">/* Bad file number */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ECHILD		10	<span class="comment">/* No child processes */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EAGAIN		11	<span class="comment">/* Try again */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOMEM		12	<span class="comment">/* Out of memory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EACCES		13	<span class="comment">/* Permission denied */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EFAULT		14	<span class="comment">/* Bad address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOTBLK		15	<span class="comment">/* Block device required */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EBUSY		16	<span class="comment">/* Device or resource busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EEXIST		17	<span class="comment">/* File exists */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EXDEV		18	<span class="comment">/* Cross-device link */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENODEV		19	<span class="comment">/* No such device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOTDIR		20	<span class="comment">/* Not a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EISDIR		21	<span class="comment">/* Is a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EINVAL		22	<span class="comment">/* Invalid argument */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENFILE		23	<span class="comment">/* File table overflow */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EMFILE		24	<span class="comment">/* Too many open files */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOTTY		25	<span class="comment">/* Not a typewriter */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ETXTBSY		26	<span class="comment">/* Text file busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EFBIG		27	<span class="comment">/* File too large */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOSPC		28	<span class="comment">/* No space left on device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ESPIPE		29	<span class="comment">/* Illegal seek */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EROFS		30	<span class="comment">/* Read-only file system */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EMLINK		31	<span class="comment">/* Too many links */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EPIPE		32	<span class="comment">/* Broken pipe */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EDOM		33	<span class="comment">/* Math argument out of domain of func */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ERANGE		34	<span class="comment">/* Math result not representable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>那么如何判断函数返回的指针是有效地址还是错误码呢？对于IS_ERR()的使用，实例代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">myclass = class_create(THIS_MODULE, <span class="string">&quot;myclass&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(myclass)) &#123;</span><br><span class="line">　　ret = PTR_ERR(myclass);</span><br><span class="line">   <span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">mydevice = device_create(myclass, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;simple-device&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(mydevice)) &#123;</span><br><span class="line">　　class_destroy(myclass);</span><br><span class="line">　　ret = PTR_ERR(mydevice);</span><br><span class="line">　　<span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，调用了class_create()和device_create()函数，必须使用IS_ERR()函数判断返回的指针是否是有效的，如果是无效的，需要调用PTR_ERR()函数将无效指针转换为错误码，并进行错误码的返回。</p>
<h2 id="17-3-实验程序编写"><a href="#17-3-实验程序编写" class="headerlink" title="17.3 实验程序编写"></a>17.3 实验程序编写</h2><h3 id="17-3-1-驱动程序编写"><a href="#17-3-1-驱动程序编写" class="headerlink" title="17.3.1 驱动程序编写"></a>17.3.1 驱动程序编写</h3><p>本驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\12\module。</p>
<p>本实验在15章的驱动程序基础上进行编写，进行Linux错误处理实验。当创建设备号，初始化cdev，注册字符设备，创建类，创建设备的这些函数执行失败时，应该怎么处理呢，编写好的驱动程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];  <span class="comment">//定义缓存区kbuf</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>   <span class="comment">//定义一个device_test结构体变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">    file-&gt;private_data=&amp;dev1;  <span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_write\r\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;kbuf is %s\r\n&quot;</span>, test_dev-&gt;kbuf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;   </span><br><span class="line"><span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">       ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="17-3-2-编写测试-APP"><a href="#17-3-2-编写测试-APP" class="headerlink" title="17.3.2 编写测试 APP"></a>17.3.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\12\app。</p>
<p>编写应用程序app.c，完成的应用程序app.c代码如下所示，应用程序只是起简单的测试作用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> <span class="comment">//主函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>;  <span class="comment">//定义写入缓存区buf1</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR); <span class="comment">//打开/dev/test设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd,buf1,<span class="keyword">sizeof</span>(buf1)); <span class="comment">//向/dev/test设备写入数据</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="17-4-运行测试"><a href="#17-4-运行测试" class="headerlink" title="17.4 运行测试"></a>17.4 运行测试</h2><h3 id="17-4-1-编译驱动程序"><a href="#17-4-1-编译驱动程序" class="headerlink" title="17.4.1 编译驱动程序"></a>17.4.1 编译驱动程序</h3><p>在上一小节中的file.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图5-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += chrdev_fops.o                     <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel   <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules     <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放file.c和Makefile文件目录下，如下图（图17-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps134.jpg" alt="img"> </p>
<p>图 17-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图17-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps135.jpg" alt="img"> </p>
<p>图 17-3</p>
<p>编译完生成 file.ko目标文件，如下图（图17-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps136.jpg" alt="img"> </p>
<p>图 17-4</p>
<p>至此我们的驱动模块就编译成功了。</p>
<h3 id="17-4-2-编译应用程序"><a href="#17-4-2-编译应用程序" class="headerlink" title="17.4.2 编译应用程序"></a>17.4.2 编译应用程序</h3><p>下面进行应用程序编译，因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图17-5）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps137.jpg" alt="img"> </p>
<p>图 17-5</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="17-4-3运行测试"><a href="#17-4-3运行测试" class="headerlink" title="17.4.3运行测试"></a>17.4.3运行测试</h3><p>驱动模块file.ko和测试程序app都已经准备好了，接下来就是运行测试。</p>
<p>输入以下命令，加载驱动程序，如下图（图17-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps138.jpg" alt="img"> </p>
<p>图 17-6</p>
<p>运行应用程序如下（图17-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps139.jpg" alt="img"> </p>
<p>图 17-7</p>
<p>卸载驱动程序，如下图（图17-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps140.jpg" alt="img"> </p>
<p>图 17-8</p>
<h1 id="第18章-点亮LED灯实验"><a href="#第18章-点亮LED灯实验" class="headerlink" title="第18章 点亮LED灯实验"></a>第18章 点亮LED灯实验</h1><p>经过前面章节的学习，我们已经对字符设备相关的知识进行了学习和实验，但实际上并没有涉及到对硬件的操作，而在本小节中将通过字符设备驱动及相关的应用程序对LED灯进行控制，通过对硬件的实际操作，从而对之前学习到的知识进行整合与回顾。</p>
<h2 id="18-1-查看原理图"><a href="#18-1-查看原理图" class="headerlink" title="18.1 查看原理图"></a>18.1 查看原理图</h2><p>首先打开底板原理图，如下图（图18-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps141.jpg" alt="img"> </p>
<p>图 18-1</p>
<p>由上图可以看出，LED灯是由GPIO0_B7控制的。当GPIO0_B7为高电平时，三极管Q16导通，LED9点亮。当GPIO0_B7为低电平时，三极管Q16截止，LED9不亮。</p>
<h2 id="18-2-查询寄存器地址"><a href="#18-2-查询寄存器地址" class="headerlink" title="18.2 查询寄存器地址"></a>18.2 查询寄存器地址</h2><p>在上一小节，我们查询到了控制LED灯的GPIO为GPIO0_B7。在接下来的实验中需要对GPIO进行配置，一般情况下需要对GPIO的复用寄存器，方向寄存器，数据寄存器进行配置。接下来我们打开RK3568的参考手册part1查找这几个寄存器的地址。</p>
<p>查找复用寄存器</p>
<p>打开参考手册part1的第三章，GPIOB的复用寄存器的偏移地址如下（图18-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps142.jpg" alt="img"> </p>
<p>图 18-2</p>
<p>搜索gpio0b7，如下图（图 18-3）所示，gpio0b7_sel在PMU_GRF_GPIO0B_IOMUX_H上，所以偏移地址为0x000C。gpio0b7可以通过控制[14:12]位来选择复用为哪个功能，我们要控制led灯，所以功能要复用为gpio。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps143.jpg" alt="img"> </p>
<p>图 18-3</p>
<p>复用寄存器的基地址如下图(图 18-4)所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps144.jpg" alt="img"> </p>
<p>图 18-4</p>
<p>所以复用寄存器地址&#x3D;基地址+偏移地址&#x3D;0xFDC2000C 。使用io命令查看此寄存器的地址：</p>
<p>io -r -4 0xFDC2000C</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps145.jpg" alt="img"> </p>
<p>图 18-5</p>
<p>如上图(图 18-5)所示，寄存器值为00000001，[14:12]位为000，如下图（图 18-6）所示，所以默认设置的为gpio功能。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps146.jpg" alt="img"> </p>
<p>图 18-6</p>
<p>查找方向寄存器</p>
<p>打开参考手册part1的第16章节，数据寄存器的偏移地址如下图（图 18-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps147.jpg" alt="img"> </p>
<p>图 18-7</p>
<p>GPIO有四组GPIO，分别是GPIOA，GPIOB，GPIOC，GPIOD。每组又以 A0<del>A7, B0</del>B7, C0<del>C7, D0</del>D7 作为编号区分。GPIO0B7在GPIO_SWPORT_DDR_L上所以，方向寄存器的偏移地址为0x0008。接着查看GPIO_SWPORT_DDR_L寄存器的具体描述，如下图（图18-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps148.jpg" alt="img"> </p>
<p>图 18-8</p>
<p>如上图（图 18-8）所示，[31:16]位属性是WO，也就是只可写入。这[31:16]位是写标志位，是低16位的写使能。如果低16位中某一位要设置输入输入输出，则对应高位写标志也应该设置为1。 [15：0] 是数据方向控制寄存器低位，如果要设置某个GPIO为输出，则对应位置1，如果要设置某个GPIO为输入，则对应位置0。那么GPIO0 B7 ，我们要设置第15位为输入还是输出，那么对应的[31:16]位写使能也要置1。</p>
<p>打开参考手册part1的1.1小节Address Mapping。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps149.jpg" alt="img"> </p>
<p>图 18-9</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps150.jpg" alt="img"> </p>
<p>图 18-10</p>
<p>如上图（图18-10）所示，GPIO0的基地址为0xFDD60000。方向寄存器的地址&#x3D;基地址+偏移地址&#x3D;0xFDD60000+0x0008&#x3D;0xFDD60008</p>
<p>然后使用IO命令查看该寄存器的值，如下（图18-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps151.jpg" alt="img"> </p>
<p>图 18-11</p>
<p>如下图（图 18-11）所示，第15位默认为1，设置GPIO0_B7为输出。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps152.jpg" alt="img"> </p>
<p>查找数据寄存器</p>
<p>打开参考手册part1的1.1小节Address Mapping。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps153.jpg" alt="img"> </p>
<p>图 18-12</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps154.jpg" alt="img"> </p>
<p>图 18-13</p>
<p>如上图（图18-13）所示，GPIO0的基地址为0xFDD60000。</p>
<p>数据寄存器的偏移地址如下（图18-14）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps155.jpg" alt="img"> </p>
<p>图 18-14</p>
<p>所以数据寄存器的地址为基地址+偏移地址&#x3D;0xFDD60000。使用IO命令查看地址的值，如下（图18-15）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps156.jpg" alt="img"> </p>
<p>图 18-15</p>
<p>我们来看一下这个数据寄存器的描述，如下图（图18-16）所示，</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps157.jpg" alt="img"> </p>
<p>图18-16</p>
<p>分析上图的方法和在分析方向寄存器的方法同理，由上图可知，如果要控制第15位为高电平（置1），需要设置31位为1，那么点亮灯，需要向数据寄存器写入0x8000c040，如下图（图18-17）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps158.jpg" alt="img"> </p>
<p>图 18-17</p>
<p>如果要灭灯，需要设置第15位为0 ，第31位为1，那么向数据寄存器中写入0x80004040，如下图（图 18-18）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps159.jpg" alt="img"> </p>
<p>图 18-18</p>
<p>总结</p>
<p>l 复用关系寄存器的基地址为0xFDC20000 ，偏移地址为000C ，所以要操作的地址为基地址+偏移地址&#x3D;0xFDC2000C </p>
<p>l GPIO的基地址为0xFDD60000，偏移地址为0x0008，所以方向寄存器要操作的地址为基地址+偏移地址&#x3D;0xFDD60008</p>
<p>l GPIO的基地址为0xFDD60000，偏移地址为0x0000，所以数据寄存器要操作的地址为基地址+偏移地址&#x3D;0xFDD60000</p>
<p>l 默认的数据寄存器的值：0x8000c040亮灯，0x80004040灭灯</p>
<h2 id="18-3-实验程序编写"><a href="#18-3-实验程序编写" class="headerlink" title="18.3 实验程序编写"></a>18.3 实验程序编写</h2><h3 id="18-3-1-驱动程序编写"><a href="#18-3-1-驱动程序编写" class="headerlink" title="18.3.1 驱动程序编写"></a>18.3.1 驱动程序编写</h3><p>本驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\13\module。</p>
<p>本次实验在15章的驱动程序基础上进行编写，通过在应用层传入0&#x2F;1数据到内核，如果传入数据是1，则设置GPIO的数据寄存器值为0x8000c040，如果应用层传入0，则设置GPIO的数据寄存器值为0x80004040，这样就可以达到控制led的效果， 编写好的驱动程序file.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_DR 0xFDD60000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *vir_gpio_dr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(test_dev-&gt;kbuf[<span class="number">0</span>]==<span class="number">1</span>)&#123;   <span class="comment">//如果应用层传入的数据是1，则打开灯</span></span><br><span class="line">            *(test_dev-&gt;vir_gpio_dr) = <span class="number">0x8000c040</span>;   <span class="comment">//设置数据寄存器的地址</span></span><br><span class="line">            printk(<span class="string">&quot;test_dev-&gt;kbuf [0]  is %d\n&quot;</span>,test_dev-&gt;kbuf[<span class="number">0</span>]);  <span class="comment">//打印传入的数据</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(test_dev-&gt;kbuf[<span class="number">0</span>]==<span class="number">0</span>)&#123;  <span class="comment">//如果应用层传入的数据是0，则关闭灯</span></span><br><span class="line">        *(test_dev-&gt;vir_gpio_dr) = <span class="number">0x80004040</span>; <span class="comment">//设置数据寄存器的地址</span></span><br><span class="line">        printk(<span class="string">&quot;test_dev-&gt;kbuf [0]  is %d\n&quot;</span>,test_dev-&gt;kbuf[<span class="number">0</span>]); <span class="comment">//打印传入的数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*本实验重点*****/</span></span><br><span class="line">    dev1.vir_gpio_dr=ioremap(GPIO_DR,<span class="number">4</span>);  <span class="comment">//将物理地址转化为虚拟地址</span></span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.vir_gpio_dr))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.vir_gpio_dr);  <span class="comment">//PTR_ERR()来返回错误代码</span></span><br><span class="line">        <span class="keyword">goto</span> err_ioremap;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_ioremap:</span><br><span class="line">        iounmap(dev1.vir_gpio_dr);</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);    <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="18-3-2-编写测试-APP"><a href="#18-3-2-编写测试-APP" class="headerlink" title="18.3.2 编写测试 APP"></a>18.3.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\13\app。</p>
<p>编写测试app,led驱动加载成功之后会生成&#x2F;dev&#x2F;test节点，应用程序APP通过操作&#x2F;dev&#x2F;test文件来完成对LED设备的控制。向&#x2F;dev&#x2F;test文件写入0表示关闭LED灯，写入1表示打开LED灯。编写完成的应用程序app.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开led驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// atoi()将字符串转为整型，这里将第一个参数转化为整型后，存放在 buf[0]中</span></span><br><span class="line">buf[<span class="number">0</span>] =atoi(argv[<span class="number">1</span>]);  </span><br><span class="line">write(fd,buf,<span class="keyword">sizeof</span>(buf));  <span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-4-运行测试"><a href="#18-4-运行测试" class="headerlink" title="18.4 运行测试"></a>18.4 运行测试</h2><h3 id="18-4-1编译驱动程序"><a href="#18-4-1编译驱动程序" class="headerlink" title="18.4.1编译驱动程序"></a>18.4.1编译驱动程序</h3><p>在上一小节中的file.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图5-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += file.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放file.c和Makefile文件目录下，如下图（图18-19）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps160.jpg" alt="img"> </p>
<p>图 18-19</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 18-20）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps161.jpg" alt="img"> </p>
<p>图 18-20</p>
<p>编译完生成 file.ko目标文件，如下图（图 18-21）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps162.jpg" alt="img"> </p>
<p>图 18-21</p>
<h3 id="18-4-2-编译应用程序"><a href="#18-4-2-编译应用程序" class="headerlink" title="18.4.2 编译应用程序"></a>18.4.2 编译应用程序</h3><p>至此我们的驱动模块就编译成功了，下面进行应用程序编译，因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图 18-21）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps163.jpg" alt="img"> </p>
<p>图 18-21</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="18-4-3-运行测试"><a href="#18-4-3-运行测试" class="headerlink" title="18.4.3 运行测试"></a>18.4.3 运行测试</h3><p>驱动模块file.ko和测试程序app都已经准备好了，接下来就是运行测试。</p>
<p>输入以下命令加载驱动程序，如下（图 18-22）所示：</p>
<p>insmod file.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps164.jpg" alt="img"> </p>
<p>图 18-22</p>
<p>然后运行测试程序，输入“.&#x2F;app 1”，LED灯点亮，如下图（图 18-24）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps165.jpg" alt="img"> </p>
<p>图 18-23</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps166.jpg" alt="img"> </p>
<p>图 18-24</p>
<p>输入“.&#x2F;app 0”,LED灯熄灭，如下图（图 18-26）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps167.jpg" alt="img"> </p>
<p>图 18-25</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps168.jpg" alt="img"> </p>
<p>图 18-26</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%9F%BA%E7%A1%80/" rel="tag">字符设备基础</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-2023-0904-读书"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/04/2023-0904-%E8%AF%BB%E4%B9%A6/"
    >2023 0904 读书</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/2023-0904-%E8%AF%BB%E4%B9%A6/" class="article-date">
  <time datetime="2023-09-04T00:08:48.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>读书是一种很好的提升自控力的方式。我正在阅读的《自控力》是一本关于意志力的书籍。</p>
<p>第一章讲述了意志力的重要性，并提出了一周的自我观察方法，帮助我们了解自己是如何屈服于冲动的。我们甚至不需要设定具体的自控目标，只需要观察自己是否意识到自己在做什么时容易冲动，以及什么样的想法、感受和情况最容易让我们放弃冲动。</p>
<p>在平常的一天中，我会经历许多冲动，既有积极的冲动，也有消极的冲动。比如早晨6点起床的冲动，写反思日记的冲动，读书提升自己的冲动等等。同时，也会有一些消极的冲动，比如看手机的冲动，回复消息的冲动，学习时刷哔哩哔哩的冲动，晚上回家后看小说的冲动等等。目前我能想到的就这么多，那么如何克制这些冲动呢？冥想！！！</p>
<p>冥想训练主要包括以下几个步骤：</p>
<ol>
<li>找到一个安静舒适的地方：选择一个安静、无干扰的环境，可以是你家中的一间房间或其他让你感到放松的地方。</li>
<li>坐下来，放松身体：找一个舒适的坐姿，可以是盘腿坐或坐在椅子上，放松肩部、颈部和脸部的肌肉。</li>
<li>关注呼吸：将注意力集中在呼吸上，感受每一次的呼吸进出。可以留意呼气时的身体松弛感和吸气时的充实感。</li>
<li>观察思绪：当你的思绪开始游离时，不要强行压制或判断，只是观察并让它们自然地流过。将注意力重新回到呼吸上。</li>
<li>培养耐心和坚持：冥想是一项需要持续练习的技能，刚开始可能会感到困难或不适应，但坚持下来会逐渐体验到好处。</li>
</ol>
<p>在《自控力》这本书中，作者提出了一周的自我观察方法，以帮助读者了解自己是如何屈服于冲动的。这种观察方法可以帮助我们认识到自己在什么情况下容易失去自控，从而更好地应对冲动。</p>
<p>其中，书中列举了一个女性的案例，她是一个不停查看邮件的人。这个案例描述了她在一周中的自我观察情况，具体包括以下几个方面：</p>
<ol>
<li>冲动的触发：女性在一周中遇到了多种触发冲动的情况，比如接收到新邮件的提示、感到无聊或焦虑时等。</li>
<li>冲动的表现：她在面对这些冲动时，表现为立即检查电子邮件，无法抑制自己的冲动，经常中断正在进行的任务。</li>
<li>冲动的后果：女性认识到这种冲动行为带来了一系列的后果，比如分散注意力、延迟完成任务、减少工作效率等。</li>
</ol>
<p>通过这个案例，读者可以看到自己在类似情况下的反应，并从中了解到自己容易屈服于冲动的原因和模式。这种自我观察的方法可以帮助我们更好地认识自己的行为模式和冲动的来源，从而有针对性地制定控制策略和改善方法。</p>
<p>当我们意识到自己容易屈服于冲动时，可以尝试一些应对措施，比如设定专门的时间段查看邮件、使用提醒工具来控制查看频率、设定目标和奖励机制等，以提升自我控制力和应对冲动的能力。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6/" rel="tag">读书</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-2023-0904-反思"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/04/2023-0904-%E5%8F%8D%E6%80%9D/"
    >2023 0904 反思</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/2023-0904-%E5%8F%8D%E6%80%9D/" class="article-date">
  <time datetime="2023-09-04T00:08:43.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8F%8D%E6%80%9D/">反思</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>日期：2023年9月4日<br>星期一</p>
<p>今天我想总结一下最近两天的反思和经验。</p>
<p>首先，我认识到搭建自己的博客真的非常重要。这是一件有趣的事情，目前给我带来了很多正向的收益。与之前只在笔记本上记录的方式相比，现在搭建博客让我能够对比自己的学习进展。以前的手写记录方式有一个最大的问题，就是我很少会去第二次看自己的笔记。这样一来，我就无法确认自己是否真正理解了学习的内容。现在，我意识到重要的是多次复习和总结，不管学习的内容是难是易，只有通过不断地学习才能真正掌握知识。</p>
<p>另外，当面对技术支持时，我想知道如何保持内心的宁静。客户可能会提出许多问题，而这时候我可能会感到心烦意乱。最好的办法是设定一个固定的时间段，比如15分钟，专注于学习而不去处理技术支持问题。在这15分钟内努力学习，不被打扰。然后，在这段时间结束后，给自己5分钟的自由时间，用来回答客户的问题。我之前试过这种方法，效果还不错。</p>
<p>今天一天的安排如下：</p>
<ol>
<li>进行反思和总结。</li>
<li>继续阅读一本书。</li>
<li>打扫卫生</li>
<li>将驱动手册整理为Markdown格式。</li>
<li>继续阅读并写驱动手册的后面部分。</li>
<li>晚上将整理好的Markdown文件上传。</li>
<li>晚上继续学习C语言的深入知识。</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%8D%E6%80%9D/" rel="tag">反思</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-cmake-基础课"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/03/cmake-%E5%9F%BA%E7%A1%80%E8%AF%BE/"
    >cmake 基础课</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/03/cmake-%E5%9F%BA%E7%A1%80%E8%AF%BE/" class="article-date">
  <time datetime="2023-09-03T09:50:19.000Z" itemprop="datePublished">2023-09-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/cmake/">cmake</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="一、准备知识"><a href="#一、准备知识" class="headerlink" title="一、准备知识"></a>一、准备知识</h1><h2 id="1-1-C-的编译过程"><a href="#1-1-C-的编译过程" class="headerlink" title="1.1 C++的编译过程"></a>1.1 C++的编译过程</h2><ul>
<li>-E 仅预处理；不编译、汇编或链接。</li>
<li>-S 仅编译；不汇编或链接。</li>
<li>-c 编译和汇编，但不链接。</li>
<li>-o <file> 将输出放入<file>中。</li>
</ul>
<p><strong>C++源代码的编译过程</strong></p>
<ol>
<li><p><strong>预处理</strong>：在预处理阶段，C++源代码中的预处理指令会被处理，包括宏展开和条件编译等。在此阶段，需要添加所有头文件的引用路径。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将xx.cpp源文件预处理为xx.i文件（文本文件）</span></span><br><span class="line">g++ -E main.cpp -o main.i</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编译</strong>：编译阶段会对预处理后的代码进行语法检查和编译，将代码翻译为汇编语言文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将xx.i文件编译为xx.s的汇编文件（文本文件）</span></span><br><span class="line">g++ -S main.i -o main.s</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>汇编</strong>：汇编阶段将汇编语言文件转换为二进制格式的目标文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将xx.s文件汇编为xx.o的二进制目标文件</span></span><br><span class="line">g++ -c main.s -o main.o</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>链接</strong>：链接阶段将目标文件与所依赖的库文件进行关联或组装，生成可执行文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将目标文件进行链接，生成可执行程序</span></span><br><span class="line">g++ main.o -o main</span><br><span class="line">```</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="1-2-静态链接库和动态链接库"><a href="#1-2-静态链接库和动态链接库" class="headerlink" title="1.2 静态链接库和动态链接库"></a>1.2 静态链接库和动态链接库</h2><p>静态链接库和动态链接库的区别在于链接的阶段不同。</p>
<p><strong>静态链接库</strong>的名称通常以<code>.a</code>结尾（表示archive library），它在编译阶段进行链接。如果一个工程依赖于静态链接库，那么生成的可执行文件或库会将静态链接库<code>.a</code>打包到输出文件中，因此生成的文件比较大。在运行时，不再需要单独的库文件。</p>
<p><strong>动态链接库</strong>的链接发生在程序的执行过程中，它在编译阶段仅进行链接检查，而不进行真正的链接过程。动态链接库的后缀名通常为<code>.so</code>（表示shared object，在Linux上）或<code>.dylib</code>（在macOS上）。动态链接库在加载后，在内存中只保存一份拷贝。多个程序依赖于它时，不会重复加载和拷贝，节省了内存空间。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/image-20230903175645024.png" alt="image-20230903175645024"></p>
<h2 id="1-3-为什么需要CMake"><a href="#1-3-为什么需要CMake" class="headerlink" title="1.3 为什么需要CMake"></a>1.3 为什么需要CMake</h2><h3 id="1-3-1-g-命令行编译"><a href="#1-3-1-g-命令行编译" class="headerlink" title="1.3.1 g++命令行编译"></a>1.3.1 g++命令行编译</h3><p>当编译hello_world.cpp&#96;文件时，可以使用以下命令进行编译和运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -o main</span><br></pre></td></tr></table></figure>

<p>如果需要引入外部库可以使用以下方法进行编译：</p>
<p>方法一：使用<code>-lgflags</code>参数进行链接**</p>
<p>首先，需要安装<code>gflags</code>库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libgflags-dev libgflags2.2</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">然后，使用以下命令进行编译：</span><br><span class="line"></span><br><span class="line">````bash</span><br><span class="line">g++ main.cpp -lgflags -o main</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>方法二：使用<code>pkg-config</code>进行库文件和头文件路径查找**</p>
<p>首先，需要安装<code>pkg-config</code>工具：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install pkg-config</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">然后，使用以下命令进行编译：</span><br><span class="line"></span><br><span class="line">````bash</span><br><span class="line">g++ main.cpp `pkg-config --cflags --libs gflags` -o main</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">这里，`pkg-config --cflags --libs gflags`命令用于查找`gflags`库的头文件和库文件路径。</span><br></pre></td></tr></table></figure>

<p>编译完成后，可以使用以下命令运行可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main --age 31 --name alice</span><br></pre></td></tr></table></figure>

<p>有时候，在编译时不需要手动添加头文件或链接库路径，因为<code>g++</code>可以在默认的查询路径中找到这些库。然而，当项目文件和引入的外部库变得较多时，使用命令行编译会变得冗长且不便于调试和编辑。通常，在测试单个文件时可以使用命令行编译，但不推荐在实际项目中使用命令行编译方式。</p>
<h3 id="1-3-2-CMake简介"><a href="#1-3-2-CMake简介" class="headerlink" title="1.3.2 CMake简介"></a>1.3.2 CMake简介</h3><p>在实际工作中，推荐使用CMake来构建C++项目。CMake是一个开源的跨平台工具，用于构建、测试和软件打包。</p>
<p>CMake具有以下特性：</p>
<ul>
<li><strong>自动搜索依赖项</strong>：CMake具有自动搜索可能需要的程序、库和头文件的能力，可以简化依赖项的配置过程。</li>
<li><strong>独立的构建目录</strong>：CMake支持使用独立的构建目录（例如<code>build</code>目录），这样可以安全地清理构建产生的中间文件和输出文件，不会污染源代码目录。</li>
<li><strong>自定义命令</strong>：CMake支持定义复杂的自定义命令，例如下载文件、生成各种文件等，可以满足项目构建过程中的特定需求。</li>
<li><strong>自定义配置</strong>：CMake支持根据需求进行自定义配置，可以选择性地启用或禁用特定的组件或功能。</li>
<li><strong>文本文件生成工作区和项目</strong>：CMake使用简单的文本文件（<code>CMakeLists.txt</code>）来描述项目的配置和构建规则，可以根据这些文件自动生成工作区和项目。</li>
<li><strong>文件依赖项自动生成和并行构建</strong>：CMake可以在主流平台上自动生成文件之间的依赖关系，从而使构建过程更高效。同时，CMake支持并行构建，可以加快构建速度。</li>
<li><strong>支持多种IDE</strong>：CMake几乎支持所有主流的集成开发环境（IDE），包括Visual Studio、Xcode、Eclipse等，可以方便地在不同的开发环境中进行项目开发和调试。</li>
</ul>
<h1 id="二、CMake基础知识"><a href="#二、CMake基础知识" class="headerlink" title="二、CMake基础知识"></a>二、CMake基础知识</h1><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h2><p>在Ubuntu上安装CMake可以使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install cmake -y</span><br></pre></td></tr></table></figure>

<p>这将使用apt包管理器自动安装CMake。</p>
<p>如果你想编译安装特定版本的CMake，可以按照以下步骤操作：</p>
<p>克隆CMake的源代码库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone -b v3.25.1 https://github.com/Kitware/CMake.git</span><br><span class="line">cd CMake</span><br><span class="line"></span><br><span class="line">这里以安装版本3.25.1为例，你可以将`v3.25.1`替换为你想要安装的特定版本。</span><br></pre></td></tr></table></figure>

<p>配置和编译CMake：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./bootstrap --prefix=&lt;安装路径&gt;</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">你可以使用`--prefix`选项来指定安装路径，或者省略`--prefix`以安装到默认路径。</span><br></pre></td></tr></table></figure>

<p>安装CMake：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">这将以管理员权限安装CMake到系统中。</span><br></pre></td></tr></table></figure>

<p>安装完成后，你可以验证CMake的安装版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure>

<p>该命令将显示CMake的版本信息，确认安装成功与否。</p>
<h2 id="2-2-第一个CMake例子"><a href="#2-2-第一个CMake例子" class="headerlink" title="2.2 第一个CMake例子"></a>2.2 第一个CMake例子</h2><p><strong>配置：</strong> 使用<code>cmake</code>命令进行配置，其中<code>-S</code>选项指定源码目录，<code>-B</code>选项指定构建目录。在终端中执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake -S . -B build</span><br><span class="line"></span><br><span class="line">这将在当前目录下执行CMake配置，并将生成的构建系统文件放在名为`build`的目录中。</span><br></pre></td></tr></table></figure>

<p><strong>生成：</strong> 使用<code>cmake --build</code>命令进行生成，其中<code>--build</code>选项指定构建目录。在终端中执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake --build build</span><br><span class="line"></span><br><span class="line">这将在`build`目录中执行构建步骤，生成可执行文件。</span><br></pre></td></tr></table></figure>

<p><strong>运行：</strong> 使用以下命令运行生成的可执行文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./build/first_cmake</span><br><span class="line"></span><br><span class="line">这将执行生成的可执行文件。</span><br></pre></td></tr></table></figure>

<h2 id="2-3-语法基础"><a href="#2-3-语法基础" class="headerlink" title="2.3 语法基础"></a>2.3 语法基础</h2><h3 id="2-3-1-指定版本"><a href="#2-3-1-指定版本" class="headerlink" title="2.3.1 指定版本"></a>2.3.1 指定版本</h3><p>在CMake中，可以使用<code>cmake_minimum_required</code>命令指定当前项目所需的最低CMake版本。它的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION &lt;version_number&gt;)</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;version_number&gt;</code>是所需的最低CMake版本号。在这个命令之后，CMake将会检查系统中安装的CMake版本是否满足这个要求，如果不满足则会产生错误。</p>
<p>例如，如果要指定最低的CMake版本为3.10，可以在CMakeLists.txt文件中添加以下命令：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br></pre></td></tr></table></figure>

<p>这样，CMake将会检查系统中的CMake版本是否大于等于3.10。</p>
<p>除了<code>cmake_minimum_required</code>命令，CMake中还有其他类似的命令，它们不区分大小写，并且有许多关键字来引导命令的参数输入，类似于函数的参数传递。这些命令使用的关键字在CMake中是不区分大小写的。</p>
<h3 id="2-3-2-设置项目"><a href="#2-3-2-设置项目" class="headerlink" title="2.3.2 设置项目"></a>2.3.2 设置项目</h3><p>在CMakeLists.txt文件的开头，通常会使用<code>project</code>命令来指定项目的名称、版本、描述和所使用的语言。<code>project</code>命令的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(ProjectName</span><br><span class="line">    [VERSION &lt;version_number&gt;]</span><br><span class="line">    [DESCRIPTION <span class="string">&quot;project_description&quot;</span>]</span><br><span class="line">    [LANGUAGES &lt;language&gt;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>其中，<code>ProjectName</code>是项目的名称，在例子中使用的是”first_cmake”。<code>VERSION</code>关键字后面是项目的版本号，可以是任意格式的版本号，例如”1.0.0”。<code>DESCRIPTION</code>关键字后面是项目的描述，可以是一个字符串。<code>LANGUAGES</code>关键字后面是项目所使用的语言，这里使用的是”Cxx”，表示C++。</p>
<p>示例中的<code>project</code>命令：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(first_cmake</span><br><span class="line">    VERSION <span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line">    DESCRIPTION <span class="string">&quot;项目描述&quot;</span></span><br><span class="line">    LANGUAGES Cxx</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这样，通过<code>project</code>命令，可以在CMakeLists.txt中指定项目的基本信息，方便管理和描述项目。</p>
<h3 id="2-3-3-添加可执行文件目标"><a href="#2-3-3-添加可执行文件目标" class="headerlink" title="2.3.3 添加可执行文件目标"></a>2.3.3 添加可执行文件目标</h3><p>使用了<code>add_executable</code>命令来定义一个可执行文件。该命令的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(&lt;target_name&gt; &lt;source_files&gt;)</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;target_name&gt;</code>是最终生成的可执行文件名，也是在CMake中定义的目标（Target）名。<code>&lt;source_files&gt;</code>是编译目标所使用的源文件。</p>
<p>在你提供的例子中，使用了<code>add_executable</code>命令来定义一个名为<code>first_cmake</code>的目标，并指定了一个源文件<code>main.cpp</code>。这意味着在编译时，会将<code>main.cpp</code>编译为一个可执行文件，该文件的名称将是<code>first_cmake</code>。</p>
<p>示例中的<code>add_executable</code>命令：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(first_cmake main.cpp)</span><br></pre></td></tr></table></figure>

<p>通过<code>add_executable</code>命令，可以在CMakeLists.txt中定义编译目标，并指定相应的源文件。这样，CMake将会根据这些定义生成相应的构建规则和编译指令。</p>
<h3 id="2-3-4-生成静态库并链接"><a href="#2-3-4-生成静态库并链接" class="headerlink" title="2.3.4 生成静态库并链接"></a>2.3.4 生成静态库并链接</h3><p>A. 生成静态库：</p>
<p>在<code>account_dir/CMakeLists.txt</code>中，使用<code>add_library</code>命令来生成静态库。该命令的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_library(&lt;library_name&gt; &lt;library_type&gt; &lt;source_files&gt;)</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;library_name&gt;</code>是最终生成的库文件名，例如在Linux下会生成<code>libAccount.a</code>。</p>
<p><code>&lt;library_type&gt;</code>用于指定链接库的类型，可以是动态链接库（<code>SHARED</code>）或静态链接库（<code>STATIC</code>）。</p>
<p><code>&lt;source_files&gt;</code>是需要用到的源文件。</p>
<p>例如，在<code>account_dir/CMakeLists.txt</code>中，使用<code>add_library</code>命令生成一个名为<code>Account</code>的静态库，其包含了<code>Account.cpp</code>和<code>Account.h</code>两个源文件。示例命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Account STATIC Account.cpp Account.h)</span><br></pre></td></tr></table></figure>

<p>这将生成一个静态库文件<code>libAccount.a</code>。</p>
<p>B. 链接：</p>
<p>在<code>test_account/CMakeLists.txt</code>中，可以通过<code>target_link_libraries</code>命令将生成的静态库链接到目标可执行文件中。该命令的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(&lt;target_name&gt; &lt;library_name&gt;)</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;target_name&gt;</code>是目标可执行文件的名称，<code>&lt;library_name&gt;</code>是要链接的库文件名。</p>
<p>例如，在<code>test_account/CMakeLists.txt</code>中，假设有一个目标可执行文件名为<code>test_account</code>，需要链接生成的静态库<code>Account</code>。示例命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(test_account Account)</span><br></pre></td></tr></table></figure>

<p>这样，生成的可执行文件<code>test_account</code>将会链接静态库<code>Account</code>。</p>
<h3 id="2-3-5-生成动态库并连接"><a href="#2-3-5-生成动态库并连接" class="headerlink" title="2.3.5 生成动态库并连接"></a>2.3.5 生成动态库并连接</h3><p>A. 生成动态库：</p>
<p>在<code>account_dir/CMakeLists.txt</code>中，使用<code>add_library</code>命令来生成动态库。与生成静态库不同的是，需要将<code>&lt;library_type&gt;</code>参数设置为<code>SHARED</code>，表示生成动态链接库。</p>
<p>示例命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Account SHARED Account.cpp Account.h)</span><br></pre></td></tr></table></figure>

<p>这将生成一个动态库文件<code>libAccount.so</code>。</p>
<p>B. 链接：</p>
<p>链接过程与生成静态库时的操作相同，使用<code>target_link_libraries</code>命令将动态库链接到目标可执行文件中。</p>
<p>示例命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(test_account Account)</span><br></pre></td></tr></table></figure>

<p>这样，生成的可执行文件<code>test_account</code>将会链接动态库<code>Account</code>。</p>
<h3 id="2-3-6-CMake中的PUBLIC、PRIVATE、INTERFACE"><a href="#2-3-6-CMake中的PUBLIC、PRIVATE、INTERFACE" class="headerlink" title="2.3.6 CMake中的PUBLIC、PRIVATE、INTERFACE"></a>2.3.6 CMake中的PUBLIC、PRIVATE、INTERFACE</h3><p>在CMake中，可以使用<code>target_...()</code>系列命令来操作目标（Target）。这些命令通常支持通过<code>PUBLIC</code>、<code>PRIVATE</code>、<code>INTERFACE</code>关键字来控制属性的传播。</p>
<p>以<code>target_link_libraries(A B)</code>为例，下面是对这些关键字的理解：</p>
<ul>
<li><code>PRIVATE</code>：依赖项B仅链接到目标A。如果有目标C链接了目标A，目标C不会链接目标B。</li>
<li><code>INTERFACE</code>：依赖项B并不链接到目标A。如果有目标C链接了目标A，目标C会链接目标B。</li>
<li><code>PUBLIC</code>：依赖项B链接到目标A。如果有目标C链接了目标A，目标C也会链接目标B。</li>
</ul>
<p>可以将其类比为一个散烟的比方：</p>
<ul>
<li><code>PRIVATE</code>：就是自己抽烟，不给别人抽。</li>
<li><code>INTERFACE</code>：就是自己不抽烟，给别人抽。</li>
<li><code>PUBLIC</code>：就是自己抽烟，也给别人抽。</li>
</ul>
<p>从使用的角度来看，假设有目标C链接了目标A：</p>
<ul>
<li>如果目标B仅用于目标A的实现，并且不在头文件中提供给目标C使用，可以使用<code>PRIVATE</code>。</li>
<li>如果目标B不用于目标A的实现，仅在头文件中作为接口给目标C使用，可以使用<code>INTERFACE</code>。</li>
<li>如果目标B既用于目标A的实现，也在头文件中提供给目标C使用，可以使用<code>PUBLIC</code>。</li>
</ul>
<p>以下是一个示例：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建库</span></span><br><span class="line"><span class="keyword">add_library</span>(c c.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(D d.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(B b.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用target_link_libraries命令进行链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(A PRIVATE B)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(A INTERFACE C)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(A PUBLIC D)</span><br></pre></td></tr></table></figure>

<p>在上述示例中，目标<code>A</code>通过<code>target_link_libraries</code>命令链接了目标<code>B</code>、<code>C</code>和<code>D</code>，使用了不同的传播属性。具体属性的选择取决于目标之间的关系和使用需求。</p>
<h3 id="2-3-7-变量"><a href="#2-3-7-变量" class="headerlink" title="2.3.7 变量"></a>2.3.7 变量</h3><p>在CMake中，你可以使用<code>message</code>命令输出消息并进行变量的操作和设置。</p>
<p>以下是一些常见的用法：</p>
<p>1.输出消息：使用<code>message</code>命令可以输出消息到CMake的输出。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;输出消息&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>2.消息拼接：使用<code>message</code>命令可以将多个消息进行拼接输出。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;输出1&quot;</span> <span class="string">&quot;输出2&quot;</span> <span class="string">&quot;输出3&quot;</span>)  <span class="comment"># 会进行拼接输出</span></span><br></pre></td></tr></table></figure>

<p>3.设置变量：使用<code>set</code>命令可以设置变量的值。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(VAR1 <span class="string">&quot;变量1&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;VAR1=&quot;</span> <span class="variable">$&#123;VAR1&#125;</span>)  <span class="comment"># 外部访问</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;输出变量VAR1:$&#123;VAR1&#125;&quot;</span>)  <span class="comment"># 内部拼接</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;\$&#123;VAR1&#125;=$&#123;VAR1&#125;&quot;</span>)  <span class="comment"># 使用\转义</span></span><br></pre></td></tr></table></figure>

<p>4.删除变量：使用<code>unset</code>命令可以删除变量。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unset</span>(VAR1)  <span class="comment"># 删除变量</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;\$&#123;VAR1&#125;=$&#123;VAR1&#125;&quot;</span>)  <span class="comment"># 删除变量后，输出为空</span></span><br></pre></td></tr></table></figure>

<p>5.设置变量缓存：使用<code>set</code>命令的<code>CACHE</code>选项可以设置一个变量的缓存，可以通过命令行的<code>-D</code>参数来修改该变量的值。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CACHE_VARIABLE_TEST <span class="string">&quot;原始值&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;变量缓存的描述&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;变量缓存的值:$&#123;CACHE_VARIABLE_TEST&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>6.常见的内置变量：CMake提供了一些内置的变量，用于获取构建系统的信息和配置</p>
<p>第一类: 提供信息的变量</p>
<ul>
<li><code>PROJECT_NAME</code>：项目名称，表示当前CMake项目的名称。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;PROJECT_NAME&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMAKE_SOURCE_DIR</code>：源码目录，表示当前CMake项目的根源码目录。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMAKE_BINARY_DIR</code>：编译目录，表示当前CMake项目的编译输出目录。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMAKE_CURRENT_LIST_FILE</code>：当前CMakeLists.txt文件路径，表示当前正在处理的CMakeLists.txt文件的完整路径。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_FILE&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这些变量提供了与项目、目录结构和文件相关的信息。</p>
<hr>
<p>第二类: 控制CMake运行的变量</p>
<p>CMake中的变量通常是根据构建选项进行命名的，例如<code>BUILD_SHARED_LIBS</code>。这些变量用于控制CMake的运行和构建过程。</p>
<hr>
<p>第三类: 描述系统的变量</p>
<ul>
<li><code>WIN32</code>：表示当前操作系统是否为Windows。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;是否是Windows系统: $&#123;WIN32&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>UNIX</code>：表示当前操作系统是否为类Unix（包括Linux、macOS等）。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;是否是Unix系统: $&#123;UNIX&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMAKE_SYSTEM_NAME</code>：系统名称，表示当前操作系统的名称。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;系统名称: $&#123;CMAKE_SYSTEM_NAME&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这些变量用于描述当前操作系统的一些信息，以便在构建过程中进行条件判断和配置。</p>
<h3 id="2-3-8-include引入其他代码"><a href="#2-3-8-include引入其他代码" class="headerlink" title="2.3.8 include引入其他代码"></a>2.3.8 include引入其他代码</h3><h3 id="2-3-9-条件控制"><a href="#2-3-9-条件控制" class="headerlink" title="2.3.9 条件控制"></a>2.3.9 条件控制</h3><p>CMake提供了条件控制的语法和关键词，使得你可以根据条件来控制构建过程中的行为。以下是一些常用的条件控制关键词和语法：</p>
<ul>
<li><code>if (variable)</code>：当变量的值为真时，执行相应的代码块。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE为真时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>else()</code>：在if条件为假时执行的代码块。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE为真时执行的代码块</span></span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE为假时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>真值常量：<code>ON</code>、<code>YES</code>、<code>TRUE</code>、<code>Y</code>、<code>1</code>、非零数字等。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE <span class="keyword">STREQUAL</span> <span class="string">&quot;ON&quot;</span>)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE的值为真时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>假值常量：<code>OFF</code>、<code>NO</code>、<code>FALSE</code>、<code>N</code>、<code>0</code>、空字符串、<code>NOTFOUND</code>等。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE <span class="keyword">STREQUAL</span> <span class="string">&quot;OFF&quot;</span>)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE的值为假时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>关键词：<code>NOT</code>、<code>TARGET</code>、<code>EXISTS (file)</code>、<code>DEFINED</code>等，可以与条件一起使用。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> <span class="keyword">TARGET</span> MyTarget)</span><br><span class="line">    <span class="comment"># 当MyTarget不存在时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>逻辑运算符：<code>AND</code>、<code>OR</code>用于组合多个条件。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (CONDITION1 <span class="keyword">AND</span> CONDITION2)</span><br><span class="line">    <span class="comment"># 当CONDITION1和CONDITION2同时为真时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CONDITION1 <span class="keyword">OR</span> CONDITION2)</span><br><span class="line">    <span class="comment"># 当CONDITION1或CONDITION2至少一个为真时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>MATCHES (regular expression)</code>：使用正则表达式进行匹配。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VARIABLE <span class="keyword">MATCHES</span> <span class="string">&quot;^prefix.*&quot;</span>)</span><br><span class="line">    <span class="comment"># 当MY_VARIABLE以&quot;prefix&quot;开头时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>VERSION LESS</code>、<code>VERSION LESS_EQUAL</code>：用于比较版本号。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MY_VERSION VERSION <span class="keyword">LESS</span> <span class="number">2.0</span>)</span><br><span class="line">    <span class="comment"># 当MY_VERSION小于2.0时执行的代码块</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>通过这些条件控制关键词和语法，你可以根据不同的条件来执行不同的代码块，从而实现更灵活和可配置的构建过程。你可以根据具体的需求选择适当的条件控制方式，并结合变量、关键词和运算符来编写CMake脚本。</p>
<h3 id="2-3-10-CMake分步编译"><a href="#2-3-10-CMake分步编译" class="headerlink" title="2.3.10 CMake分步编译"></a>2.3.10 CMake分步编译</h3><p>首先，你使用以下命令查看所有的目标：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target help</span><br></pre></td></tr></table></figure>

<p>这将列出项目中可用的目标列表，包括默认目标”all”、”clean”、”depend”、”rebuild_cache”、”edit_cache”以及其他一些目标。</p>
<p>接下来，你执行以下命令进行预处理：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target main.i</span><br></pre></td></tr></table></figure>

<p>这将对”main.cpp”源文件进行预处理，并将预处理结果保存在”CMakeFiles&#x2F;steps_demo.dir&#x2F;main.cpp.i”文件中。</p>
<p>然后，你执行以下命令进行编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target main.sI</span><br></pre></td></tr></table></figure>

<p>这将将”main.cpp”源文件编译为汇编代码，并将汇编代码保存在”CMakeFiles&#x2F;steps_demo.dir&#x2F;main.cpp.s”文件中。</p>
<p>接着，你执行以下命令进行汇编：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target main.o</span><br></pre></td></tr></table></figure>

<p>这将将汇编代码编译为目标文件，并将目标文件保存为”CMakeFiles&#x2F;steps_demo.dir&#x2F;main.cpp.o”。</p>
<p>最后，你执行以下命令进行链接：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build .</span><br></pre></td></tr></table></figure>

<p>这将扫描依赖项并链接生成最终的可执行文件”steps_demo”。</p>
<p>最后，你执行以下命令运行可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./steps_demo</span><br></pre></td></tr></table></figure>

<p>这将运行生成的可执行文件。</p>
<h3 id="2-3-11-生成器表达式"><a href="#2-3-11-生成器表达式" class="headerlink" title="2.3.11 生成器表达式"></a>2.3.11 生成器表达式</h3><p>生成器表达式是CMake中一种用于在生成构建系统时根据不同配置动态生成特定内容的表达式。它可以让代码更加精简和灵活。下面是几种常用的生成器表达式类型：</p>
<p>条件表达式：<code>$&lt;condition:true_string&gt;</code>。当条件为真时，返回<code>true_string</code>，否则返回空字符串。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&lt;<span class="number">0</span>:<span class="keyword">TEST</span>&gt;           <span class="comment"># 返回空字符串</span></span><br><span class="line">$&lt;<span class="number">1</span>:<span class="keyword">TEST</span>&gt;           <span class="comment"># 返回&quot;TEST&quot;</span></span><br><span class="line">$&lt;$&lt;BOOL:<span class="keyword">TRUE</span>&gt;:<span class="keyword">TEST</span>&gt;  <span class="comment"># 返回&quot;TEST&quot;</span></span><br></pre></td></tr></table></figure>

<p>变量查询（Variable-Query）：通过查询变量来获取动态的值。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&lt;TARGET_EXISTS:<span class="keyword">target</span>&gt;             <span class="comment"># 判断目标是否存在</span></span><br><span class="line">$&lt;CONFIG:Debug&gt;                     <span class="comment"># 判断当前构建类型是否为Debug</span></span><br></pre></td></tr></table></figure>

<p>目标查询（Target-Query）：通过查询目标来获取相关的信息。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&lt;TARGET_FILE:<span class="keyword">target</span>&gt;               <span class="comment"># 获取目标的文件路径</span></span><br><span class="line">$&lt;TARGET_FILE_NAME:<span class="keyword">target</span>&gt;          <span class="comment"># 获取目标的文件名</span></span><br></pre></td></tr></table></figure>

<p>输出相关表达式：用于在不同的构建环节使用不同的参数。比如，在<code>install</code>和<code>build</code>阶段使用不同的参数。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Foo ...)</span><br><span class="line"><span class="keyword">target_include_directories</span>(Foo</span><br><span class="line">    PUBLIC</span><br><span class="line">        $&lt;$&lt;CONFIG:Debug&gt;:<span class="variable">$&#123;DEBUG_INCLUDES&#125;</span>&gt;</span><br><span class="line">        $&lt;$&lt;CONFIG:Release&gt;:<span class="variable">$&#123;RELEASE_INCLUDES&#125;</span>&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在上述示例中，根据不同的构建配置（Debug或Release），生成器表达式选择性地包含不同的头文件路径。</p>
<p>需要注意的是，生成器表达式在生成构建系统时被展开，因此无法通过<code>message</code>命令直接打印。你可以使用类似<code>file(GENERATE OUTPUT &quot;./generator_test.txt&quot; CONTENT &quot;$&lt;$&lt;BOOL:TRUE&gt;:TEST&gt;&quot;)</code>的方式将生成器表达式的结果写入文件，以间接测试生成器表达式的值。</p>
<h3 id="2-3-12-函数和宏"><a href="#2-3-12-函数和宏" class="headerlink" title="2.3.12 函数和宏"></a>2.3.12 函数和宏</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个宏</span></span><br><span class="line"><span class="keyword">macro</span>(my_macro)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;宏内部的信息&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(macro_var <span class="string">&quot;宏内部变量test&quot;</span>)</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数</span></span><br><span class="line"><span class="keyword">function</span>(second_func arg1 arg2)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;第一个参数: $&#123;arg1&#125;，第二个参数: $&#123;arg2&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>my_macro</code>是一个没有参数的宏，它在宏内部输出一条信息，并设置了一个变量<code>macro_var</code>的值。</p>
<p><code>second_func</code>是一个函数，它有两个参数<code>arg1</code>和<code>arg2</code>。在函数内部，它输出了两个参数的值。</p>
<p>你可以在CMakeLists.txt文件中使用这些宏和函数，例如：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用宏</span></span><br><span class="line">my_macro()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">second_func(<span class="string">&quot;Hello&quot;</span> <span class="string">&quot;World&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当你运行CMake生成构建系统时，你将看到宏内部的信息输出，并且可以访问在宏或函数内部定义的变量。函数将输出参数的值。</p>
<p>请注意，宏和函数的定义需要在CMakeLists.txt文件的适当位置进行，并且在调用它们之前必须先定义它们。</p>
<h3 id="2-3-13-设置安装"><a href="#2-3-13-设置安装" class="headerlink" title="2.3.13 设置安装"></a>2.3.13 设置安装</h3><p><code>install</code>命令用于设置安装规则，将目标文件和文件夹安装到指定的位置。下面是你提供的代码的解释：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS instal_demo slib dlib</span><br><span class="line">    RUNTIME DESTINATION bin     <span class="comment"># 可执行文件安装路径</span></span><br><span class="line">    LIBRARY DESTINATION lib     <span class="comment"># 动态库安装路径</span></span><br><span class="line">    ARCHIVE DESTINATION lib     <span class="comment"># 静态库安装路径</span></span><br><span class="line">    PUBLIC_HEADER DESTINATION <span class="keyword">include</span>   <span class="comment"># 公共头文件安装路径</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>install</code>命令指定了要安装的目标文件列表，其中包括<code>instal_demo</code>、<code>slib</code>和<code>dlib</code>。</p>
<p>接下来，通过指定不同的<code>DESTINATION</code>参数，定义了目标文件在安装过程中的安装路径：</p>
<ul>
<li><code>RUNTIME DESTINATION bin</code>：指定可执行文件的安装路径为<code>bin</code>目录。</li>
<li><code>LIBRARY DESTINATION lib</code>：指定动态库的安装路径为<code>lib</code>目录。</li>
<li><code>ARCHIVE DESTINATION lib</code>：指定静态库的安装路径为<code>lib</code>目录。</li>
<li><code>PUBLIC_HEADER DESTINATION include</code>：指定公共头文件的安装路径为<code>include</code>目录。</li>
</ul>
<p>根据你的需求，这些目标文件将被安装到指定的目录中。</p>
<p>请注意，安装路径是相对于安装目录的，因此你需要确保安装目录在运行<code>make install</code>时正确设置。</p>
<p>要解决在安装后无法找到动态库的问题，可以使用<code>set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)</code>和<code>set(CMAKE_INSTALL_RPATH &quot;$&#123;CMAKE_INSTALL_PREFIX&#125;/lib&quot;)</code>来设置RPATH。</p>
<p>下面是相应的代码：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_WITH_INSTALL_RPATH <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_RPATH <span class="string">&quot;$&#123;CMAKE_INSTALL_PREFIX&#125;/lib&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)</code>指示在构建过程中使用与安装RPATH相同的RPATH。这样，在构建时就可以正确地查找和链接动态库。</p>
<p><code>set(CMAKE_INSTALL_RPATH &quot;$&#123;CMAKE_INSTALL_PREFIX&#125;/lib&quot;)</code>将安装RPATH设置为<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/lib</code>，其中<code>$&#123;CMAKE_INSTALL_PREFIX&#125;</code>是安装目录的路径。这将导致在安装时设置RPATH，使得安装后的可执行文件可以在<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/lib</code>目录中正确地查找和加载动态库。</p>
<p>通过使用这两个设置，你可以解决在安装后无法找到动态库的问题。确保将其放置在CMakeLists.txt文件中的合适位置，并根据实际情况调整<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/lib</code>路径，以匹配你的安装目录结构。</p>
<h3 id="2-3-14-寻找依赖find-package"><a href="#2-3-14-寻找依赖find-package" class="headerlink" title="2.3.14 寻找依赖find_package"></a>2.3.14 寻找依赖find_package</h3><p>对于大多数支持CMake的项目来说，可以使用<code>find_package</code>命令来查找对应的依赖库。通常情况下，如果找到了库，会设置以下变量（这些变量由库的作者设置）：</p>
<ul>
<li><code>&lt;LibaryName&gt;_FOUND</code>：表示是否找到库。</li>
<li><code>&lt;LibaryName&gt;_INCLUDE_DIR</code>：表示库的头文件目录。</li>
<li><code>&lt;LibaryName&gt;_LIBRARIES</code>：表示库的库文件目录。</li>
</ul>
<p>如果你编写了一个新的函数库，并希望其他项目可以通过<code>find_package</code>引用它，你可以使用以下两种方法：</p>
<ol>
<li><p>编写一个<code>Find&lt;LibraryName&gt;.cmake</code>文件：适用于导入非CMake安装的项目。</p>
<p>你可以编写一个名为<code>Find&lt;LibraryName&gt;.cmake</code>的文件，并将其放置在CMake的<code>Modules</code>目录或项目的特定目录中。该文件应包含查找和设置相关变量的逻辑。其他项目可以通过<code>find_package</code>命令来引用这个自定义的查找文件，从而找到并使用你的库。</p>
<p>附件: 15.custom_find</p>
</li>
<li><p>使用<code>install</code>安装并生成<code>&lt;LibraryName&gt;Config.cmake</code>文件：适用于导入你自己开发的CMake项目。</p>
<p>在你的库项目中，可以使用<code>install</code>命令将库文件安装到指定位置，并生成<code>&lt;LibraryName&gt;Config.cmake</code>文件。该文件应包含设置变量和导出目标的逻辑。其他项目可以通过<code>find_package</code>命令找到并使用你的库。</p>
</li>
</ol>
<p>&#x3D;&#x3D;现在只是简单的写了一下学习的内容，但是对于很多内容还并不是很熟悉，一切都要等到最后实战的时候&#x3D;&#x3D;</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cmake/" rel="tag">cmake</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-c-进阶语法-oop-智能指针-STL"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/03/c-%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95-oop-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-STL/"
    >c++进阶语法 oop 智能指针 STL</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/03/c-%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95-oop-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-STL/" class="article-date">
  <time datetime="2023-09-03T05:42:43.000Z" itemprop="datePublished">2023-09-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c/">c++</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-OOP面向对象开发"><a href="#1-OOP面向对象开发" class="headerlink" title="1 OOP面向对象开发"></a>1 OOP面向对象开发</h1><h2 id="1-1-类-class-和对象-objects"><a href="#1-1-类-class-和对象-objects" class="headerlink" title="1.1 类(class)和对象(objects)"></a>1.1 类(class)和对象(objects)</h2><pre><code>类(classes)和对象(objects)
</code></pre>
<p>C++类(classes)</p>
<ul>
<li>创建对象用的蓝图(blueprint)</li>
<li>用户自定义的数据类型</li>
<li>有成员属性(data)和成员方法(methods)</li>
<li>可以隐藏属性和方法(private)</li>
<li>可以提供公共接口(public)</li>
<li>示例:Account,Student,std:vector, std:string</li>
</ul>
<p>C++对象(objects)</p>
<ul>
<li>由类创建而来</li>
<li>表示类的一个具体的实例(lnstance)</li>
<li>可以有很多个实例，每个都有独立的身份·每个对象都可以使用类中定义的方法</li>
</ul>
<p>Account对象示例</p>
<ul>
<li>Jobs、Alice的apunt是Account类的实例</li>
<li>每个实例都有它的余额、可以提现、存钱</li>
</ul>
<p>声明一个类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span></span>; <span class="comment">// 存款</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span></span>; <span class="comment">// 取款</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建类的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Account jobs_account;</span><br><span class="line">Account alice_account;</span><br><span class="line">Account* mary_account = <span class="keyword">new</span> <span class="built_in">Account</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> mary_account;</span><br></pre></td></tr></table></figure>



<p>示例1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> </span><br><span class="line">&#123;</span><br><span class="line">    string name &#123;<span class="string">&quot;None&quot;</span>&#125;;</span><br><span class="line">    <span class="type">double</span> balance &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Account a;</span><br><span class="line">    Account b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>获取类的属性或者方法</p>
<p>使用点操作符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Account jobs_account;</span><br><span class="line">jobs_account.balance;</span><br><span class="line">jobs_account.<span class="built_in">deposit</span>( <span class="number">10.00</span>);</span><br></pre></td></tr></table></figure>

<p>如果是一个指向对象的指针，可以解引用或者使用箭头操作符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Account* alice_account = <span class="keyword">new</span> <span class="built_in">Account</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解引用指针并访问成员</span></span><br><span class="line">(*alice_account).balance; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指针访问成员</span></span><br><span class="line">alice_account-&gt;<span class="built_in">deposit</span>(<span class="number">100.0</span>);</span><br><span class="line">alice_account-&gt;balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> alice_account;</span><br></pre></td></tr></table></figure>



<h2 id="1-2-public、private、protected访问权限"><a href="#1-2-public、private、protected访问权限" class="headerlink" title="1.2 public、private、protected访问权限"></a>1.2 public、private、protected访问权限</h2><p>public</p>
<p>可以被任何实体访问   </p>
<hr>
<p>private<br>只能被本类的方法访问</p>
<hr>
<p>protected</p>
<p>可以被本类和子类(继承)的方法访问\</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span></span>; <span class="comment">// 存款</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span></span>; <span class="comment">// 取款</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>在类中实现完整的成员方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="type">double</span> balance &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">setBalance</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        balance = amount;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在类外面实现需要特殊定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="type">double</span> balance &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">setBalance</span><span class="params">(<span class="type">double</span> amount)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBalance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Account::setBalance</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">    balance = amount;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Account::getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-3-构造函数-constructor"><a href="#1-3-构造函数-constructor" class="headerlink" title="1.3 构造函数(constructor)"></a>1.3 构造函数(constructor)</h2><ul>
<li>特殊的成员方法</li>
<li>对象创建的时候自动调用</li>
<li>适用于实例参数初始化</li>
<li>函数名和类的名称一致</li>
<li>无需设置返回类型</li>
<li>可以被重载(overload)</li>
</ul>
<h2 id="1-4-析构函数-destructor"><a href="#1-4-析构函数-destructor" class="headerlink" title="1.4 析构函数(destructor)"></a>1.4 析构函数(destructor)</h2><ul>
<li>特殊的成员方法</li>
<li>函数名和类的名称一致，前面跟着一个~波浪符号</li>
<li>对象销毁的时候自动调用</li>
<li>没有参数，没有返回类型</li>
<li>只有一个析构函数(不能重载)</li>
<li>适用于释放内存等资源</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    std::string name&#123;<span class="string">&quot;account&quot;</span>&#125;;</span><br><span class="line">    <span class="type">double</span> balance&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Account</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Account</span>(std::string name);</span><br><span class="line">    <span class="built_in">Account</span>(<span class="type">double</span> balance);</span><br><span class="line">    <span class="built_in">Account</span>(std::string name, <span class="type">double</span> balance);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Account</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​		</p>
<h2 id="1-5-构造函数初始化列表"><a href="#1-5-构造函数初始化列表" class="headerlink" title="1.5 构造函数初始化列表"></a>1.5 构造函数初始化列表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，使用构造函数内部初始化参数</span></span><br><span class="line">    <span class="built_in">Account</span>(std::string name, <span class="type">double</span> balance) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，使用初始化列表初始化参数</span></span><br><span class="line">    <span class="built_in">Account</span>(std::string name, <span class="type">double</span> balance)</span><br><span class="line">        : name&#123;name&#125;, balance&#123;balance&#125; &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-代理构造函数"><a href="#1-6-代理构造函数" class="headerlink" title="1.6 代理构造函数"></a>1.6 代理构造函数</h2><ul>
<li>重载的构造函数很相似·冗余的代码可能会导致错误</li>
<li>使用代理构造函数</li>
<li>在一个构造函数初始化列表中调用另一个构造函数</li>
</ul>
<h2 id="1-7-拷贝构造函数"><a href="#1-7-拷贝构造函数" class="headerlink" title="1.7 拷贝构造函数"></a>1.7 拷贝构造函数</h2><p>当对象被拷贝时，C++必须从已存在的对象复制出一个新的对象</p>
<p>何时使用拷贝构造函数?</p>
<ul>
<li>以值传递方式传递对象给函数（作参数)</li>
<li>函数以值方式返回对象</li>
<li>使用已存在的对象复制新的对象</li>
</ul>
<p>如果不提供自己写的copy constructor,编译器会自动生成一个(可能不符合要</p>
<h2 id="1-9-浅拷贝和深拷贝"><a href="#1-9-浅拷贝和深拷贝" class="headerlink" title="1.9 浅拷贝和深拷贝"></a>1.9 浅拷贝和深拷贝</h2><p>如果不提供自己写的copy constructor.编译器会生成默认的<br>将目标对象的值逐个拷贝过来;<br>如果是指针，拷贝的是值（指向的地址)，而不是指向的对象（浅拷贝)在析构函数中释放内存时，其他对象中的指针可能还在指向被释放的资源</p>
<h2 id="1-10-在类中使用const"><a href="#1-10-在类中使用const" class="headerlink" title="1.10 在类中使用const"></a>1.10 在类中使用const</h2><p>在类中使用const常函数</p>
<p>函数名称后加const</p>
<ul>
<li>函数体内不可以修改类成员属性。常对象</li>
</ul>
<p>声明对象时前面加const</p>
<ul>
<li>不可以修改常对象的成员属性仅能调用常函数</li>
</ul>
<h2 id="1-11-在类中使用static"><a href="#1-11-在类中使用static" class="headerlink" title="1.11 在类中使用static"></a>1.11 在类中使用static</h2><p>静态成员变量</p>
<ul>
<li><p>所有对象共有同一份数据（数据共享)</p>
</li>
<li><p>在类中声明，类外初始化</p>
</li>
</ul>
<p>静态成员函数</p>
<p>所有对象共享同一个函数</p>
<ul>
<li>只能访问静态成员变量</li>
</ul>
<h2 id="1-12-struct和class区别"><a href="#1-12-struct和class区别" class="headerlink" title="1.12 struct和class区别"></a>1.12 struct和class区别</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    std::string name&#123;<span class="string">&quot;none&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认私有属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    std::string name&#123;<span class="string">&quot;none&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 默认公有属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Account aa;</span><br><span class="line">    <span class="comment">// aa.name = &quot;bob&quot;; // 报错，无法访问私有成员</span></span><br><span class="line"></span><br><span class="line">    Student ss;</span><br><span class="line">    ss.name = <span class="string">&quot;alice&quot;</span>; <span class="comment">// 可以访问公有成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-智能指针"><a href="#2-智能指针" class="headerlink" title="2 智能指针"></a>2 智能指针</h1><p>原始指针(raw pointer)的一些问题</p>
<p>1.c++提供了内存管理的绝对自由度</p>
<ul>
<li><p>分配</p>
</li>
<li><p>释放</p>
</li>
<li><p>声明周期管理</p>
</li>
</ul>
<p>2.一些潜在严重问题</p>
<ul>
<li><p>未初始化的指针(wild pointer)</p>
</li>
<li><p>内存泄漏(memory leak)</p>
</li>
<li><p>悬空指针(dangling pointer</p>
</li>
</ul>
<p>3.所有权(ownership)</p>
<ul>
<li>谁拥有指针?</li>
<li>何时可以删除指针?</li>
</ul>
<p>C++智能指针是一种用来管理动态分配的内存的工具，它们遵循RAII（资源获取即初始化）原则，可以自动释放内存，防止内存泄漏。</p>
<p>以下是几种常见的C++智能指针：</p>
<ol>
<li><code>unique_ptr</code>: <code>unique_ptr</code> 是一种独占所有权的智能指针，它指向堆上分配的对象，并负责在其生命周期结束时自动删除对象。每个 <code>unique_ptr</code> 只能拥有一个对象，并且不能进行拷贝，但可以进行移动。</li>
<li><code>shared_ptr</code>: <code>shared_ptr</code> 是一种共享所有权的智能指针，多个 <code>shared_ptr</code> 可以指向同一个对象。它使用引用计数来跟踪对象的所有者数量，并在最后一个所有者释放内存时删除对象。</li>
<li><code>weak_ptr</code>: <code>weak_ptr</code> 是一种弱引用指针，它可以与 <code>shared_ptr</code> 一起使用。<code>weak_ptr</code> 不会增加对象的引用计数，它允许对被 <code>shared_ptr</code> 管理的对象进行观测，但不拥有所有权。当 <code>shared_ptr</code> 删除对象后，<code>weak_ptr</code> 会自动失效。</li>
<li><code>auto_ptr</code>（已弃用）: <code>auto_ptr</code> 是C++98标准引入的智能指针，它类似于 <code>unique_ptr</code>，但具有一些问题和局限性，已被废弃，不推荐使用。</li>
</ol>
<p><code>unique_ptr&lt;T&gt;</code> 是一种独占所有权的智能指针，用于指向堆上的类型为 <code>T</code> 的对象。它保证在其生命周期结束时自动释放所指向的对象，确保资源的正确释放，避免内存泄漏。</p>
<p><code>unique_ptr</code> 的特点如下：</p>
<ul>
<li>它是唯一（unique）的，即一个 <code>unique_ptr</code> 对象拥有对应对象的唯一所有权。不能有多个 <code>unique_ptr</code> 指向同一个对象，这样可以避免多次释放同一块内存的问题。</li>
<li><code>unique_ptr</code> 不能进行复制或赋值，但可以通过移动语义来转移所有权。这意味着可以将所有权从一个 <code>unique_ptr</code> 转移到另一个 <code>unique_ptr</code>，从而实现对象所有权的转移而不进行内存复制。</li>
<li>当 <code>unique_ptr</code> 使用完毕或超出作用域时，它所指向的对象会自动释放和销毁，无需手动调用 <code>delete</code>。</li>
</ul>
<p>&#x3D;&#x3D;目前还没用过，等真正用过的时候再仔细看吧&#x3D;&#x3D;</p>
<h1 id="3-STL标准模板库"><a href="#3-STL标准模板库" class="headerlink" title="3 STL标准模板库"></a>3 STL标准模板库</h1><h2 id="3-1-STL简介"><a href="#3-1-STL简介" class="headerlink" title="3.1 STL简介"></a>3.1 STL简介</h2><p>一个强大的、可复用的、自适应的泛型类和函数集合</p>
<p>使用C++模板(templates)实现</p>
<p>实现了常见的数据结构(data struuctures)和算法(algorithms)</p>
<p>庞大的类库</p>
<p>俄裔美籍程序员:Alexander Step:anov 1994年开发</p>
<p>容器(containers)</p>
<ul>
<li>各种对象或原始类型的集合. array、vector、deque、stack、set、map等</li>
</ul>
<p>算法(algorithms)</p>
<ul>
<li>处理容器元素序列的各种函数find、max、count、accumulate、sort等</li>
</ul>
<p>迭代器(iterators)</p>
<ul>
<li>从容器中生成元素的序列. forward、reveise、by value、by constant等</li>
</ul>
<h2 id="3-2-STL容器的类别"><a href="#3-2-STL容器的类别" class="headerlink" title="3.2 STL容器的类别"></a>3.2 STL容器的类别</h2><p>序列式容器（Sequence Containers）：</p>
<ol>
<li><code>vector</code>：动态数组，支持快速随机访问，尾部插入和删除元素效率高，但在中间或头部插入和删除元素效率低。</li>
<li><code>list</code>：双向链表，支持在任意位置插入和删除元素，但随机访问效率较低。</li>
<li><code>forward_list</code>：单向链表，与 <code>list</code> 类似，但只支持单向遍历，没有双向遍历的能力。</li>
<li><code>deque</code>：双端队列，支持在头部和尾部高效地插入和删除元素，同时支持随机访问。</li>
</ol>
<p>关联式容器（Associative Containers）：</p>
<ol>
<li><code>set</code>：集合，存储唯一的元素，并按升序排序。</li>
<li><code>multi_set</code>：多重集合，可存储重复的元素，并按升序排序。</li>
<li><code>map</code>：映射，存储键值对，按键的升序排序。</li>
<li><code>multi_map</code>：多重映射，可存储重复的键值对，并按键的升序排序。</li>
</ol>
<p>容器适配器（Container Adapters）：</p>
<ol>
<li><code>stack</code>：栈，以 LIFO（后进先出）的方式存储元素，底层基于序列式容器实现，默认使用 <code>deque</code>。</li>
<li><code>queue</code>：队列，以 FIFO（先进先出）的方式存储元素，底层基于序列式容器实现，默认使用 <code>deque</code>。</li>
<li><code>priority_queue</code>：优先队列，按照优先级存储元素，底层基于序列式容器实现，默认使用 <code>vector</code>。</li>
</ol>
<h2 id="3-3-STL迭代器的类别"><a href="#3-3-STL迭代器的类别" class="headerlink" title="3.3 STL迭代器的类别"></a>3.3 STL迭代器的类别</h2><p>迭代器是一种用于遍历容器中元素的抽象概念，它提供了对容器中元素的访问和操作方式。C++中定义了多种类型的迭代器，每种迭代器具有不同的特性和功能。</p>
<ol>
<li>输入迭代器（Input Iterators）：从容器到程序，对数据进行只读访问。它允许逐个元素地读取容器中的数据，并且只能单向移动，不支持对容器进行修改。</li>
<li>输出迭代器（Output Iterators）：从程序到容器，对数据进行只写访问。它允许逐个元素地向容器中写入数据，并且只能单向移动，不支持读取容器中的数据。</li>
<li>前向迭代器（Forward Iterators）：向前推进迭代器，支持对容器进行读写操作。它具有输入迭代器和输出迭代器的所有功能，并且可以在容器中任意位置插入和删除元素，支持双向移动。</li>
<li>双向迭代器（Bidirectional Iterators）：向前、向后推进迭代器，支持对容器进行读写操作。它具有前向迭代器的所有功能，并且可以反向移动，即向前和向后移动。</li>
<li>随机访问迭代器（Random Access Iterators）：直接获取容器元素，支持对容器进行读写操作。它具有双向迭代器的所有功能，并且支持随机访问，可以通过偏移量直接访问容器中的任意元素。</li>
</ol>
<h2 id="3-4-STL算法的类别"><a href="#3-4-STL算法的类别" class="headerlink" title="3.4 STL算法的类别"></a>3.4 STL算法的类别</h2><p>非质变的算法（Non-modifying Algorithms）：</p>
<ol>
<li><code>std::all_of</code>：判断范围内的所有元素是否满足给定条件。</li>
<li><code>std::any_of</code>：判断范围内是否存在满足给定条件的元素。</li>
<li><code>std::none_of</code>：判断范围内是否所有元素都不满足给定条件。</li>
<li><code>std::for_each</code>：对范围内的每个元素执行指定的操作。</li>
<li><code>std::count</code>：计算范围内满足给定值的元素个数。</li>
<li><code>std::count_if</code>：计算范围内满足给定条件的元素个数。</li>
<li><code>std::find</code>：查找范围内第一个等于给定值的元素。</li>
<li><code>std::find_if</code>：查找范围内第一个满足给定条件的元素。</li>
<li><code>std::find_if_not</code>：查找范围内第一个不满足给定条件的元素。</li>
<li><code>std::find_end</code>：在范围内查找最后一次出现子序列的起始位置。</li>
<li><code>std::find_first_of</code>：在范围内查找第一次出现指定元素之一的位置。</li>
<li><code>std::adjacent_find</code>：在范围内查找第一对相邻重复元素的位置。</li>
<li><code>std::search</code>：在范围内查找第一次出现子序列的起始位置。</li>
<li><code>std::search_n</code>：在范围内查找第一次出现连续多个相等元素的起始位置。</li>
<li><code>std::equal</code>：判断两个范围内的元素是否相等。</li>
<li><code>std::mismatch</code>：找到两个范围内第一次不匹配的位置。</li>
<li><code>std::lexicographical_compare</code>：按字典顺序比较两个范围。</li>
<li><code>std::is_permutation</code>：判断两个范围内的元素是否是排列关系。</li>
<li><code>std::min_element</code>：找到范围内的最小元素的位置。</li>
<li><code>std::max_element</code>：找到范围内的最大元素的位置。</li>
<li><code>std::minmax_element</code>：同时找到范围内的最小和最大元素的位置。</li>
<li><code>std::clamp</code>：将给定值限制在指定范围内。</li>
<li><code>std::is_sorted</code>：判断范围内的元素是否按升序排序。</li>
<li><code>std::is_partitioned</code>：判断范围内的元素是否满足分区条件。</li>
<li><code>std::is_heap</code>：判断范围内的元素是否满足堆的条件。</li>
<li><code>std::is_sorted_until</code>：找到范围内的第一个无序位置。</li>
<li><code>std::is_partitioned_until</code>：找到范围内的第一个不满足分区条件的位置。</li>
<li><code>std::is_heap_until</code>：找到范围内的第一个不满足堆条件的位置。</li>
</ol>
<p>质变的算法（Modifying Algorithms）：</p>
<ol>
<li><code>std::copy</code>：复制范围内的元素到另一个容器。</li>
<li><code>std::copy_if</code>：复制满足给定条件的元素到另一个容器。</li>
<li><code>std::copy_n</code>：复制指定数量的元素到另一个容器。</li>
<li><code>std::copy_backward</code>：反向复制范围内的元素到另一个容器。</li>
<li><code>std::move</code>：将范围内的元素移动到另一个容器。</li>
<li><code>std::move_backward</code>：反向移动范围内的元素到另一个容器。</li>
<li><code>std::fill</code>：用给定值填充容器中的元素。</li>
<li><code>std::fill_n</code>：用给定值填充指定数量的元素。</li>
<li><code>std::generate</code>：使用生成器函数生成范围内的元素。</li>
<li><code>std::generate_n</code>：使用生成器函数生成指定数量的元素。</li>
<li><code>std::transform</code>：对范围内的元素应用指定的操作，并将结果存储到另一个容器。</li>
<li><code>std::replace</code>：将范围内的指定值替换为新值。</li>
<li><code>std::replace_if</code>：根据给定条件将范围内的元素替换为新值。</li>
<li><code>std::replace_copy</code>：将范围内的元素复制到另一个容器，并将指定值替换为新值。</li>
<li><code>std::replace_copy_if</code>：将范围内的元素复制到另一个容器，并根据给定条件替换为新值。</li>
<li><code>std::swap</code>：交换两个对象的值。</li>
<li><code>std::swap_ranges</code>：交换两个范围的元素。</li>
<li><code>std::iter_swap</code>：交换两个迭代器所指向的元素。</li>
<li><code>std::reverse</code>：反转范围内的元素顺序。</li>
<li><code>std::reverse_copy</code>：将范围内的元素反转后复制到另一个容器。</li>
<li><code>std::rotate</code>：将范围内的元素循环右移。</li>
<li><code>std::rotate_copy</code>：将范围内的元素循环右移后复制到另一个容器。</li>
<li><code>std::shuffle</code>：随机重排范围内的元素。</li>
<li><code>std::unique</code>：移除范围内的连续重复元素，只保留一个副本。</li>
<li><code>std::unique_copy</code>：将范围内的连续重复元素复制到另一个容器，只保留一个副本。</li>
<li><code>std::partition</code>：根据给定条件将范围内的元素分为满足条件和不满足条件的两部分。</li>
<li><code>std::stable_partition</code>：根据给定条件将范围内的元素稳定地分为满足条件和不满足条件的两部分。</li>
<li><code>std::sort</code>：对范围内的元素进行排序。</li>
<li><code>std::stable_sort</code>：对范围内的元素进行稳定排序。</li>
<li><code>std::partial_sort</code>：部分排序范围内的元素。</li>
<li><code>std::nth_element</code>：将范围内的第 n 小的元素移动到指定位置。</li>
<li><code>std::inplace_merge</code>：将两个已排序的范围合并为一个已排序的范围。</li>
<li><code>std::transform</code>：对范围内的元素应用指定的操作，并将结果存储到另一个容器。</li>
<li><code>std::generate</code>：使用生成器函数生成范围内的元素。</li>
<li><code>std::generate_n</code>：使用生成器函数生成指定数量的元素。</li>
<li><code>std::random_shuffle</code>：随机重排范围内的元素。</li>
<li><code>std::partition</code>：根据给定条件将范围内的元素分为满足条件和不满足条件的两部分。</li>
<li><code>std::sort</code>：对范围内的元素进行排序。</li>
<li><code>std::stable_sort</code>：对范围内的元素进行稳定排序。</li>
<li><code>std::partial_sort</code>：部分排序范围内的元素。</li>
<li><code>std::nth_element</code>：将范围内的第 n 小的元素移动到指定位置。</li>
<li><code>std::inplace_merge</code>：将两个已排序的范围合并为一个已排序的范围。</li>
<li><code>std::copy_backward</code>：反向复制范围内的元素到另一个容器。</li>
</ol>
<h2 id="3-5泛型编程和宏"><a href="#3-5泛型编程和宏" class="headerlink" title="3.5泛型编程和宏"></a>3.5泛型编程和宏</h2><h2 id="3-6函数模板"><a href="#3-6函数模板" class="headerlink" title="3.6函数模板"></a>3.6函数模板</h2><p>函数模板（Function Template）是C++中的一种特殊函数，用于定义通用的函数，可以适用于不同类型的参数。函数模板通过在函数定义中使用类型参数来实现通用性，这些类型参数可以在函数调用时被具体的类型替代。</p>
<p>以下是两个使用函数模板定义的求最大值函数的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(a, b) &lt;&lt; std::endl;  <span class="comment">// 调用模板函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-7类模板"><a href="#3-7类模板" class="headerlink" title="3.7类模板"></a>3.7类模板</h2><p>类模板（Class Template）是C++中的一种特殊类，用于定义通用的类，可以适用于不同类型的成员变量和成员函数。类模板通过在类定义中使用类型参数来实现通用性，这些类型参数可以在类实例化时被具体的类型替代。</p>
<p>类模板的使用方式类似于函数模板，通过在类定义前面使用 <code>template&lt;typename T&gt;</code> 或 <code>template&lt;class T&gt;</code> 声明一个模板类，其中 <code>T</code> 是一个模板参数，可以在类内部的成员变量和成员函数中使用。</p>
<p>以下是一个使用类模板定义的通用的容器类的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Container</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-c-进阶-函数和指针"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/03/c-%E8%BF%9B%E9%98%B6-%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88/"
    >c++ 进阶 函数和指针</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/03/c-%E8%BF%9B%E9%98%B6-%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88/" class="article-date">
  <time datetime="2023-09-03T03:48:33.000Z" itemprop="datePublished">2023-09-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c/">c++</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-掌握C-函数基本概念用法"><a href="#1-掌握C-函数基本概念用法" class="headerlink" title="1.掌握C++函数基本概念用法"></a>1.掌握C++函数基本概念用法</h1><h2 id="1-1-函数定义"><a href="#1-1-函数定义" class="headerlink" title="1.1 函数定义"></a>1.1 函数定义</h2><p>什么是函数(function)</p>
<ul>
<li><p>C++程序</p>
</li>
<li><p>C++标准库(functions和clas;ses)</p>
</li>
<li><p>第三方库(functions和class</p>
</li>
<li><p>自定义的functions和classes</p>
</li>
</ul>
<p>函数让我们的程序更加模块化</p>
<ul>
<li>让代码解耦，分成按业务，</li>
<li>按逻辑的单元提高代码复用性</li>
</ul>
<p>函数名称参数列表</p>
<ul>
<li><p>传给函数的变量</p>
</li>
<li><p>变量类型需声明</p>
</li>
</ul>
<p>返回值类型</p>
<ul>
<li><p>函数体</p>
</li>
<li><p>函数被调用执行的部分，花括号{}内部</p>
<p>示例1：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI &#123;<span class="number">3.1415926</span>&#125;; <span class="comment">// 圆周率</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculate_area</span><span class="params">(<span class="type">double</span> radius)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PI * <span class="built_in">pow</span>(radius, <span class="number">2</span>); <span class="comment">// pow()函数用于计算幂</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">circle_area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入圆的半径：&quot;</span>;</span><br><span class="line">    <span class="type">double</span> radius &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    cin &gt;&gt; radius;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的面积为：&quot;</span> &lt;&lt; <span class="built_in">calculate_area</span>(radius) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">circle_area</span>(); <span class="comment">// 调用计算圆的面积的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="1-2-函数原型-prototype"><a href="#1-2-函数原型-prototype" class="headerlink" title="1.2 函数原型(prototype)"></a>1.2 函数原型(prototype)</h2><p>&#x3D;&#x3D;编译器要求:使用函数前必须“见过”这个函数&#x3D;&#x3D;</p>
<p>先定义函数再调用</p>
<ul>
<li>适用于小型程序，不适用于大型项目</li>
</ul>
<p>使用函数原型</p>
<ul>
<li><p>告诉编译器函数定义必要的信息</p>
</li>
<li><p>也称为前向声明(forward declaration)</p>
</li>
<li><p>放在程序开始的部分</p>
</li>
<li><p>或者放在头文件(header files.h)中</p>
</li>
</ul>
<h2 id="1-3参数"><a href="#1-3参数" class="headerlink" title="1.3参数"></a>1.3参数</h2><ol>
<li>当我们传递数据给函数时，其实用的是值传递(pass by value)</li>
<li>数据的拷贝会传给函数</li>
<li>函数内部的代码不会改变我们传给它的变量</li>
</ol>
<p>形参(formal parameters)与实参(actual parameters)<br>形参(formal parameters)</p>
<ul>
<li>函数定义语句中的参数</li>
</ul>
<p>实参(actual parameters</p>
<ul>
<li>调用函数时传递的参数(arguments)</li>
</ul>
<h2 id="1-4-重载"><a href="#1-4-重载" class="headerlink" title="1.4 重载"></a>1.4 重载</h2><p>一组函数具有相同函数名，不同参数列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型，函数重载</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_numbers</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>; <span class="comment">// 两个 int 类型数字相加</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add_numbers</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>; <span class="comment">// 两个 double 类型数字相加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_numbers</span>(<span class="number">5</span>, <span class="number">10</span>) &lt;&lt; endl; <span class="comment">// int 类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_numbers</span>(<span class="number">1.23</span>, <span class="number">2.45</span>) &lt;&lt; endl; <span class="comment">// double 类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_numbers</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add_numbers</span><span class="params">(<span class="type">double</span> num1, <span class="type">double</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-5-函数传参-数组、引用"><a href="#1-5-函数传参-数组、引用" class="headerlink" title="1.5 函数传参(数组、引用)"></a>1.5 函数传参(数组、引用)</h2><ul>
<li><p>数组元素并没有复制</p>
</li>
<li><p>数组变量名称表示第一个元素在内存中的地址这个地址才被复制了</p>
</li>
<li><p>函数内部无法知道数组大小(数组大小需要额外传参)</p>
<p>·声明参数numbers是常量(只读read-only)</p>
</li>
</ul>
<p>		</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_array</span> <span class="params">(<span class="type">const</span> <span class="type">int</span> numbers[ ], <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_num</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换两个数字</span></span><br><span class="line">    <span class="type">int</span> x &#123;<span class="number">100</span>&#125;, y &#123;<span class="number">200</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y is: &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 100 200</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap_num</span>(x, y);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y is: &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 200 100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的是取地址，上面的函数和下面这个函数的作用相同：</p>
<p>传递地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_num</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换两个数字</span></span><br><span class="line">    <span class="type">int</span> x &#123;<span class="number">100</span>&#125;, y &#123;<span class="number">200</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y is: &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 100 200</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap_num</span>(&amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y is: &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 200 100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&#x3D;&#x3D;注意&#x3D;&#x3D;</p>
<p><code>int&amp;</code> 是 C++ 中的引用类型，它是一种特殊的类型，用于给一个已存在的变量起一个别名。可以将其理解为变量的一个别名或者另一个名称，与原变量共享同一块内存空间。</p>
<p>引用类型与指针类型有所不同。引用在声明时必须初始化，并且一旦初始化后，它就一直引用同一个对象，不能再引用其他对象。而指针可以在声明后重新指向不同的对象。</p>
<p>使用引用类型的主要目的是提供一种更简洁、更直观的方式来操作变量，同时避免了指针操作的一些繁琐性和潜在的错误。</p>
<p>在上述修正后的代码中，<code>int&amp;</code> 用于函数参数的声明，表示传递的参数是一个整数的引用。通过引用参数，可以直接修改原变量的值，而无需通过指针进行解引用。在函数内部，通过引用操作修改了 <code>a</code> 和 <code>b</code> 所指向的变量的值。</p>
<p>其实也就相当于传地址</p>
<h1 id="2-掌握C-指针基本概念、用法"><a href="#2-掌握C-指针基本概念、用法" class="headerlink" title="2.掌握C++指针基本概念、用法"></a>2.掌握C++指针基本概念、用法</h1><h2 id="2-1-什么是指针"><a href="#2-1-什么是指针" class="headerlink" title="2.1 什么是指针"></a>2.1 什么是指针</h2><p>指针是变量<br>变量的值是一个地址<br>指针的值可以存储哪些地址?</p>
<p>另一个变量</p>
<p>函数</p>
<hr>
<p>如果指针指向变量或函数，那么为什么不直接用他们?</p>
<p>可以，但不常用:</p>
<ul>
<li><p>函数内部，指针可以访问函数作用域外的数据</p>
</li>
<li><p>高效操作数组</p>
</li>
<li><p>在堆(heap)上动态分配内存空间</p>
<p>​      这些空间没有变量名称只能通过指针访问</p>
</li>
<li><p>可以获取内存中特殊地址</p>
</li>
</ul>
<p>​              如嵌入式系统、设备驱动等</p>
<hr>
<ul>
<li>&amp;地址操作符</li>
<li>指针也是一个变量(variable)，所以它的值可以改变</li>
<li>指针可以为null</li>
<li>指针可以不初始化</li>
</ul>
<h2 id="2-2-动态内存分配-dynami-allocation"><a href="#2-2-动态内存分配-dynami-allocation" class="headerlink" title="2.2 动态内存分配(dynami allocation)"></a>2.2 动态内存分配(dynami allocation)</h2><p>在堆(heap)上程序员自己分配内存空间;<br>数组(array)</p>
<ul>
<li>使用数组需要知道数组大小，并且数组大小是固定的;</li>
<li>Vector容器大小可以动态调整</li>
</ul>
<p>使用指针获取堆上刚分配的内存空间</p>
<hr>
<p>使用new[]为数组分配内存空间</p>
<p>使用delete[]释放内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* array_ptr &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr_size &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;你需要多少个整数: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; arr_size;</span><br><span class="line"></span><br><span class="line">    array_ptr = <span class="keyword">new</span> <span class="type">int</span>[arr_size]; <span class="comment">// 在堆上分配内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] array_ptr; <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-指针和数组的关系"><a href="#2-3-指针和数组的关系" class="headerlink" title="2.3 指针和数组的关系"></a>2.3 指针和数组的关系</h2><ul>
<li>数组变量名称的值是数组第一个元素的地址;</li>
<li>指针变量的的值是一个地址;</li>
<li>如果指针指向的类型和数组元素的类型一致，那么指针和数组名称几乎是等价的</li>
</ul>
<h2 id="2-4-const和指针一一指针本身和被指向的对象都是常量"><a href="#2-4-const和指针一一指针本身和被指向的对象都是常量" class="headerlink" title="2.4 const和指针一一指针本身和被指向的对象都是常量"></a>2.4 const和指针一一指针本身和被指向的对象都是常量</h2><p>指针可以操作:地址及被指向的对象</p>
<ul>
<li>被指向的对象是常量(povinters to constants)</li>
<li>指针本身是常量(constant pointers)</li>
<li>指针本身和被指向的对象都是常量(constant pointers to constants)</li>
</ul>
<p>示例1</p>
<ul>
<li>被指向的对象是常量，不可以通过指针改动·</li>
<li>指针本身可以改变</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> high_temp &#123;<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="type">int</span> low_temp &#123;<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* temp_ptr &#123;&amp;high_temp&#125;; <span class="comment">// 被指向的数据是常量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// *temp_ptr = 100; // 错误，不能通过解引用修改常量的值</span></span><br><span class="line"></span><br><span class="line">    temp_ptr = &amp;low_temp; <span class="comment">// 正确，可以通过指针修改指向的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例2</p>
<ul>
<li>被指向的对象可以通过指针改动</li>
<li>指针本身不可以改变</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> high_temp &#123;<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="type">int</span> low_temp &#123;<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> temp_ptr &#123;&amp;high_temp&#125;; <span class="comment">// 指针本身是常量，指向 high_temp</span></span><br><span class="line"></span><br><span class="line">    *temp_ptr = <span class="number">100</span>; <span class="comment">// 正确，通过指针解引用修改值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// temp_ptr = &amp;low_temp; // 错误，不能修改指针的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>示例3 </p>
<ul>
<li>被指向的对象不可以改动</li>
<li>指针本身不可以改变</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> high_temp &#123;<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="type">int</span> low_temp &#123;<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> temp_ptr &#123;&amp;high_temp&#125;; <span class="comment">// 指针和被指向对象都是常量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// *temp_ptr = 100; // 错误，不能修改指针指向的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// temp_ptr = &amp;low_temp; // 错误，不能修改指针的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-函数返回指针"><a href="#2-5-函数返回指针" class="headerlink" title="2.5 函数返回指针"></a>2.5 函数返回指针</h2><p>函数可以返回指针:</p>
<p> *function( );</p>
<p>返回哪些指针:</p>
<ul>
<li>函数内部动态分配的内存空间传入的数据</li>
<li>不能返回函数内的局部变量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">create_array</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> initial_value = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* new_storage &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    new_storage = <span class="keyword">new</span> <span class="type">int</span>[size]; <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i&#123;<span class="number">0</span>&#125;; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 初始化值</span></span><br><span class="line">        *(new_storage + i) = initial_value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_storage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> size &#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* array_ptr = <span class="built_in">create_array</span>(size, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数组元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i&#123;<span class="number">0</span>&#125;; i &lt; size; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; *(array_ptr + i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] array_ptr; <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-hexo-进阶"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/03/hexo-%E8%BF%9B%E9%98%B6/"
    >hexo 进阶</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/03/hexo-%E8%BF%9B%E9%98%B6/" class="article-date">
  <time datetime="2023-09-03T01:55:17.000Z" itemprop="datePublished">2023-09-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/hexo/">hexo</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-文章的分类和标签"><a href="#1-文章的分类和标签" class="headerlink" title="1 文章的分类和标签"></a>1 文章的分类和标签</h1><p>分类的话就是在最上方的状态栏中加入	categories:  属性即可</p>
<p>标签的话就是在最上方的状态栏中加入	tags:  属性即可</p>
<h1 id="2图床搭建教程"><a href="#2图床搭建教程" class="headerlink" title="2图床搭建教程"></a>2图床搭建教程</h1><p>根据这个教程来即可</p>
<p><a target="_blank" rel="noopener" href="https://eryinote.com/post/105">图床</a></p>
<p>踩坑 picgo这个软件双击并不是直接打开，而是到了右下角的小菜单。。。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/image-20230903113402329.png" alt="image-20230903113402329"></p>
<p>然后在typora软件中进行简单的设置即可。如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/image-20230903114440776.png" alt="image-20230903114440776"></p>
<p>至此就搞完了，其他目前也没啥需求，继续学习C++</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-c-基本语法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/02/c-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"
    >c++基本语法</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/02/c-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" class="article-date">
  <time datetime="2023-09-02T13:41:01.000Z" itemprop="datePublished">2023-09-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c/">c++</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-C-程序结构"><a href="#1-C-程序结构" class="headerlink" title="1.C++程序结构"></a>1.C++程序结构</h1><h2 id="1-1-C-程序的基本组成部分"><a href="#1-1-C-程序的基本组成部分" class="headerlink" title="1.1 C++程序的基本组成部分"></a>1.1 C++程序的基本组成部分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> favorites_num;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入0~10中你最喜欢的数字: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; favorites_num;</span><br><span class="line">    std::cout &lt;&lt; favorites_num &lt;&lt; <span class="string">&quot;也是我喜欢的数字！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标识符(identifiers)：</p>
<p>​	main favorites_num  cout cin</p>
<p>操作符(operators)：</p>
<p>​	&lt;&lt;    &gt;&gt; </p>
<p>标点(punctuation：</p>
<p>​	；}</p>
<h2 id="1-2-预处理指令-Preprocessor-Directives"><a href="#1-2-预处理指令-Preprocessor-Directives" class="headerlink" title="1.2 预处理指令(Preprocessor Directives)"></a>1.2 预处理指令(Preprocessor Directives)</h2><ul>
<li>它指示编译器在实际编译开始之前预处理信息·以#开头，不以分号(;)结尾</li>
<li>并不理解C++语法</li>
</ul>
<h2 id="1-3-注释"><a href="#1-3-注释" class="headerlink" title="1.3 注释"></a>1.3 注释</h2><p>​	跟C相同，双斜杠的单行注释和、&#x2F;**&#x2F;多行注释</p>
<h2 id="1-4-main函数"><a href="#1-4-main函数" class="headerlink" title="1.4 main函数"></a>1.4 main函数</h2><p>​	例程1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>#include &lt;iostream&gt;</code>：这是一个预处理指令，用于包含输入输出流库（iostream），以便在程序中使用输入输出功能。</li>
<li><code>using namespace std;</code>：这是一个命名空间的声明，使用了<code>std</code>命名空间。命名空间<code>std</code>包含了C++标准库的函数和对象，使我们可以直接使用其中的成员，而无需在每个标识符前添加<code>std::</code>前缀。</li>
<li><code>int main()</code>：这是程序的主函数，也是程序的入口点。在C++中，每个程序都必须有一个<code>main</code>函数作为程序的起点。</li>
<li><code>&#123;</code> 和 <code>&#125;</code>：这对花括号之间的代码块是<code>main</code>函数的主体，包含了程序要执行的代码。</li>
<li><code>cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;</code>：这是一个输出语句，使用了<code>cout</code>对象，它是标准输出流。<code>&lt;&lt;</code>是输出运算符，用于将字符串常量”hello world”输出到控制台。<code>endl</code>是一个特殊的输出控制符，表示换行。</li>
</ol>
<p>例程2：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//argc表示参数数量，argc表示输入的参数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;参数数量&quot;</span> &lt;&lt; argc &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;参数名称&quot;</span> &lt;&lt; argv &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	 </p>
<h2 id="1-5-命名空间namespace"><a href="#1-5-命名空间namespace" class="headerlink" title="1.5 命名空间namespace"></a>1.5 命名空间namespace</h2><p>在C++中，命名空间是一种用来组织程序中的标识符（例如变量名、函数名、类名等）的机制。命名空间可以避免标识符之间的名称冲突，使得不同库、模块或代码段中的标识符可以拥有相同的名称而不会发生冲突。</p>
<p><code>std</code> 是C++标准库中的命名空间，包含了大量的标准函数和类型定义。例如，<code>std::cout</code> 是用于标准输出的对象，<code>std::cin</code> 是用于标准输入的对象，<code>std::string</code> 是用于处理字符串的类，<code>std::vector</code> 是用于动态数组的类等等。这些标准库的功能都封装在 <code>std</code> 命名空间中。</p>
<p>使用 <code>using namespace std;</code> 声明后，就可以在代码中直接使用 <code>std</code> 命名空间中的成员，而无需在每个标识符前添加 <code>std::</code> 前缀。例如，可以直接使用 <code>cout</code> 来表示 <code>std::cout</code>，使用 <code>endl</code> 来表示 <code>std::endl</code>，以及使用 <code>string</code> 来表示 <code>std::string</code> 等等。</p>
<p>需要注意的是，尽管 <code>using namespace std;</code> 可以简化代码，但也可能引发命名冲突问题。如果程序中使用了不同命名空间中具有相同名称的标识符，可能会导致编译错误或意想不到的行为。因此，在大型项目中或与其他库进行交互时，最好明确指定使用的命名空间，而不是使用 <code>using namespace</code> 全局声明。</p>
<h1 id="2-C-变量和常量"><a href="#2-C-变量和常量" class="headerlink" title="2. C++变量和常量"></a>2. C++变量和常量</h1><h2 id="2-1-变量-variable"><a href="#2-1-变量-variable" class="headerlink" title="2.1 变量(variable)"></a>2.1 变量(variable)</h2><p>变量是内存地址的抽象变量有2个重要的属性:<br>Type:变量类型( integer、real nurber、string、Student)<br>Value:变量值(1,3.14,”computer”)</p>
<h2 id="2-2-基本类型-primitive-types"><a href="#2-2-基本类型-primitive-types" class="headerlink" title="2.2 基本类型(primitive types)"></a>2.2 基本类型(primitive types)</h2><p>示例3：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;参数a=&quot;</span> &lt;&lt; a &lt;&lt; endl;	  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	上述示例运行打印为 a&#x3D;0，最好设置初值</p>
<p>示例4：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> width = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入房间宽度&quot;</span>;	  </span><br><span class="line">    cin &gt;&gt; width;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入房间长度&quot;</span>;	  </span><br><span class="line">    cin &gt;&gt; length;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;房间的面积为&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; width * length &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符型-character-char"><a href="#字符型-character-char" class="headerlink" title="字符型(character) : char"></a>字符型(character) : char</h3><p>作用︰用于表示单个字符，如I@’,’a’,’X’<br>只占用1个字节<br>语法:char c &#x3D;(a;<br>&#x3D;&#x3D;注意&#x3D;&#x3D;:<br>需要和字符串区分开，用单引号不是双引号<br>存储的是字符的ASCIl编码，而不是字符本身</p>
<h3 id="整型-integer-short、int、long、long-long"><a href="#整型-integer-short、int、long、long-long" class="headerlink" title="整型(integer) : short、int、long、long long"></a>整型(integer) : short、int、long、long long</h3><h3 id="浮点型-floating-point-float、double"><a href="#浮点型-floating-point-float、double" class="headerlink" title="浮点型(floating point) : float、double"></a>浮点型(floating point) : float、double</h3><h3 id="布尔型-Boolean-bool"><a href="#布尔型-Boolean-bool" class="headerlink" title="布尔型(Boolean) : bool"></a>布尔型(Boolean) : bool</h3><p>示例5</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a = &#123;<span class="string">&#x27;j&#x27;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符型参数a的值=&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符型参数a的ascll=&quot;</span> &lt;&lt; <span class="built_in">int</span>(a) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// short取值范围和溢出</span></span><br><span class="line">    <span class="type">short</span> overflow_num_1 = <span class="number">32768</span>;    <span class="comment">// 不会报错，但是值会溢出</span></span><br><span class="line">    <span class="type">short</span> overflow_num_2 &#123;<span class="number">32768</span>&#125;;    <span class="comment">// 会报错</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;短整型溢出：&quot;</span> &lt;&lt; overflow_num_1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;短整型溢出：&quot;</span> &lt;&lt; overflow_num_2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	&#x3D;&#x3D;注意&#x3D;&#x3D;:一般人们都是使用等于号进行赋值，但是对于一些超出范围的情况，编译器并不会报错，但是使用{}花括号的情况就会报错，所以建议大家之后使用花括号进行赋值.</p>
<h2 id="2-3-sizeof和climits"><a href="#2-3-sizeof和climits" class="headerlink" title="2.3 sizeof和climits"></a>2.3 sizeof和climits</h2><p>sizeof(int), &#x2F;&#x2F;确定int占用空间<br>sizeof(double), &#x2F;&#x2F;确定double占用空间<br>sizeof(变量名), &#x2F;&#x2F;确定具体某个变量占用空间<br>sizeof 变量名, &#x2F;&#x2F;不用括号</p>
<p>示例6：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a = &#123;<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符型变量a的大小为&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;整形变量b的大小为&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-4-常量-constant"><a href="#2-4-常量-constant" class="headerlink" title="2.4 常量(constant)"></a>2.4 常量(constant)</h2><p>作用:记录不可更改的数据，防止变量误修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理器定义</span></span><br><span class="line"><span class="comment">// 在老版本的C++中常用，现在不建议使用（预处理器不认识C++代码，不会做类型检查等工作)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pi 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const修饰方法</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> months = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pi = 3.5; 常量不可以再变更值，否则编译器会报错</span></span><br></pre></td></tr></table></figure>

<p>示例7：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> PI &#123;<span class="number">3.14159</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length &#123;<span class="number">10</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的面积为&quot;</span> &lt;&lt; length * length * PI &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-C-数组和容器"><a href="#3-C-数组和容器" class="headerlink" title="3. C++数组和容器"></a>3. C++数组和容器</h1><h2 id="3-1-数组"><a href="#3-1-数组" class="headerlink" title="3.1 数组"></a>3.1 数组</h2><p>·数组所有元素都是同一个数据类型。每个元素可以单独读取。</p>
<p>数组的特点：</p>
<ul>
<li>长度大小固定，且不可以再修改</li>
<li>所有元素是同一类型</li>
<li>元素在内存中是连续存储的</li>
<li>声明array时，内存中会分配一块区域来存储</li>
<li>可以使用存储的索引位置来获取元素（从0开始，最后一个元素索引为size -1)</li>
<li>不检查是否超出区域（超出长度获取元素可能会报错)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int student_scores[5] = &#123;92, 78, 100, 86, 65&#125;;  // 所有元素初始化</span><br><span class="line">int ages[10] = &#123;19, 23&#125;;                      // 前两个元素初始化对应值，其他元素为0</span><br><span class="line">const int days_in_year = 365;</span><br><span class="line">double hi_temperatures[days_in_year] = &#123;0&#125;;   // 所有元素初始化为0</span><br><span class="line">int another_array[] = &#123;1, 2, 3, 4, 5, 6&#125;;      // 数组大小自动计算</span><br></pre></td></tr></table></figure>

<p>​	数组如果只是定义，他是没有初值的最好在创建的过程中就加入初值。、只有加入一个初值，其他没赋予的值也会有，只是为0 </p>
<p>示例8：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> a[] &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[] &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a数组的第五个值为&quot;</span> &lt;&lt; a[<span class="number">4</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b数组名打印&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-容器"><a href="#3-2-容器" class="headerlink" title="3.2 容器"></a>3.2 容器</h2><p>假设需要存储整个学校所有学生的考试成绩无法知道具体的学生数量<br>解决办法:</p>
<ul>
<li><p>使用数组，数组大小设置的足够大</p>
</li>
<li><p>使用vector动态数组</p>
</li>
</ul>
<p>&#x3D;&#x3D;容器的特点&#x3D;&#x3D;：</p>
<ul>
<li><p>C++标准模板库STL中的容器(container)</p>
</li>
<li><p>长度大小可以随时缩放</p>
</li>
<li><p>和数组类似的语法用法</p>
</li>
<li><p>高性能越界检查</p>
</li>
<li><p>很多有用的函数:sort, reverrse, find等</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">vowels</span><span class="params">(<span class="number">5</span>)</span></span>;             <span class="comment">// 构造函数初始化方法，需要五个位置</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">student_scores</span><span class="params">(<span class="number">10</span>)</span></span>;     <span class="comment">// 大小为10，这10个数字会自动初始化为0</span></span><br></pre></td></tr></table></figure>

<p>赋予初值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">char</span>&gt; vowels &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; student_scores &#123;<span class="number">100</span>, <span class="number">99</span>, <span class="number">98</span>, <span class="number">97</span>, <span class="number">96</span>&#125;;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">hi_temperatures</span><span class="params">(<span class="number">365</span>, <span class="number">37.0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​	这里有些区别，第一个使用的是花括号进行的初值赋予，第二个跟第一个相同，但是第三个使用的是圆括号来进行的，第一个参数为365表示将会有365个元素，第二个参数为初始值，表示这365个元素都会被初始化为37.0</p>
<p>​	.at获取</p>
<p>​	.pushback进行追加</p>
<p>示例 9：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; vowel &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; vowel.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt;endl;</span><br><span class="line">    vowel.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; vowel.<span class="built_in">at</span>(<span class="number">5</span>) &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	需要注意的是上面的vector和&lt;类型&gt;必须连在一起，否则会报错。</p>
<p>​	容器的获取方式跟数组的获取方式相同，但也可以有更多的方式</p>
<h1 id="4-C-程序流程"><a href="#4-C-程序流程" class="headerlink" title="4. C++程序流程"></a>4. C++程序流程</h1><h2 id="4-1-if"><a href="#4-1-if" class="headerlink" title="4.1 if"></a>4.1 if</h2><p>示例 10：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lower_limit &#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> upper_limit &#123;<span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> input_num;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入一个介于&quot;</span> &lt;&lt; lower_limit &lt;&lt; <span class="string">&quot;和&quot;</span> &lt;&lt; upper_limit &lt;&lt; <span class="string">&quot;之间的整数：&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cin &gt;&gt; input_num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (input_num &gt;= lower_limit) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;===条件一满足===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; input_num &lt;&lt; <span class="string">&quot;大于等于&quot;</span> &lt;&lt; lower_limit &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; input_num &lt;&lt; <span class="string">&quot;比&quot;</span> &lt;&lt; lower_limit &lt;&lt; <span class="string">&quot;大&quot;</span> &lt;&lt; (input_num - lower_limit) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (input_num &lt;= upper_limit) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;===条件二满足===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; input_num &lt;&lt; <span class="string">&quot;小于等于&quot;</span> &lt;&lt; upper_limit &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; input_num &lt;&lt; <span class="string">&quot;比&quot;</span> &lt;&lt; upper_limit &lt;&lt; <span class="string">&quot;小&quot;</span> &lt;&lt; (upper_limit - input_num) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (input_num &gt; lower_limit &amp;&amp; input_num &lt; upper_limit) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;===条件三满足===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; input_num &lt;&lt; <span class="string">&quot;介于&quot;</span> &lt;&lt; lower_limit &lt;&lt; <span class="string">&quot;和&quot;</span> &lt;&lt; upper_limit &lt;&lt; <span class="string">&quot;之间&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-switch"><a href="#4-2-switch" class="headerlink" title="4.2 switch"></a>4.2 switch</h2><p>示例 11：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char input_grade = &#x27;0&#x27;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;请输入你的成绩：&quot;;</span><br><span class="line">    std::cin &gt;&gt; input_grade;</span><br><span class="line"></span><br><span class="line">    switch (input_grade)</span><br><span class="line">    &#123;</span><br><span class="line">        case &#x27;a&#x27;:</span><br><span class="line">        case &#x27;A&#x27;:</span><br><span class="line">            std::cout &lt;&lt; &quot;优秀&quot; &lt;&lt; std::endl;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;b&#x27;:</span><br><span class="line">        case &#x27;B&#x27;:</span><br><span class="line">            std::cout &lt;&lt; &quot;良好&quot; &lt;&lt; std::endl;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;c&#x27;:</span><br><span class="line">        case &#x27;C&#x27;:</span><br><span class="line">            std::cout &lt;&lt; &quot;中等&quot; &lt;&lt; std::endl;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-3循环-for、while、do-while"><a href="#4-3循环-for、while、do-while" class="headerlink" title="4.3循环: for、while、do-while"></a>4.3循环: for、while、do-while</h2><p>示例 11：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 简单的 for 循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次 i 增加 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面这种最简单的方式，for也支持基于范围的循环，类似于python：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> scores [ ] &#123;<span class="number">100</span>,<span class="number">99</span>,<span class="number">98</span>&#125; ;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> score: scores)</span><br><span class="line">	cout&lt;&lt; score &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>有时确定范围比较困难，所以可以使用auto这个类型，可以帮我们自动确认类型</p>
<p>while和do while就不重复了，还是很简单的</p>
<h1 id="5-C-字符和字符串"><a href="#5-C-字符和字符串" class="headerlink" title="5. C++字符和字符串"></a>5. C++字符和字符串</h1><h2 id="5-1C风格字符串"><a href="#5-1C风格字符串" class="headerlink" title="5.1C风格字符串"></a>5.1C风格字符串</h2><p>示例 12：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> first_name[<span class="number">20</span>] &#123;&#125;;</span><br><span class="line">    <span class="type">char</span> last_name[<span class="number">20</span>] &#123;&#125;;</span><br><span class="line">    <span class="type">char</span> full_name[<span class="number">50</span>] &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">50</span>] &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入你的姓：&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; first_name;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入你的名：&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; last_name;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;===============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;您的姓：&quot;</span> &lt;&lt; first_name &lt;&lt; <span class="string">&quot;，一共有&quot;</span> &lt;&lt; <span class="built_in">strlen</span>(first_name) &lt;&lt; <span class="string">&quot;个字符&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;您的名：&quot;</span> &lt;&lt; last_name &lt;&lt; <span class="string">&quot;，一共有&quot;</span> &lt;&lt; <span class="built_in">strlen</span>(last_name) &lt;&lt; <span class="string">&quot;个字符&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-2-C-风格字符串"><a href="#5-2-C-风格字符串" class="headerlink" title="5.2 C++风格字符串"></a>5.2 C++风格字符串</h2><ul>
<li><p>STL中一个类</p>
</li>
<li><p>使用前必须要导入#include <string></p>
</li>
<li><p>std namespace</p>
</li>
<li><p>内存中连续，动态大小</p>
</li>
<li><p>可转c-style字符串相互转化</p>
</li>
<li><p>更安全</p>
<p>示例 13：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string sl; <span class="comment">// 全部初始化为空</span></span><br><span class="line">    std::string s2 &#123; <span class="string">&quot;hello&quot;</span> &#125;; <span class="comment">// 初始化为 &quot;hello&quot;</span></span><br><span class="line">    std::string s3 &#123; s2 &#125;; <span class="comment">// 拷贝 s2</span></span><br><span class="line">    std::string s4 &#123; s3, <span class="number">0</span>, <span class="number">4</span> &#125;; <span class="comment">// 拷贝 s3 的前4个字符：&quot;hell&quot;</span></span><br><span class="line">    std::string s5 &#123; <span class="string">&quot;hello&quot;</span>, <span class="number">3</span> &#125;; <span class="comment">// 拷贝 &quot;hello&quot; 的前3个字符：&quot;hel&quot;</span></span><br><span class="line">    <span class="function">std::string <span class="title">s6</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>; <span class="comment">// 5个 &#x27;x&#x27;：&quot;xxxxx&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	c++字符串可以直接赋值，根据他的参数的数量可以划分不同的重定向函数</p>
<p>拼接</p>
<p>示例 14：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string part1 &#123; <span class="string">&quot;C++&quot;</span> &#125;;</span><br><span class="line">    std::string part2 &#123; <span class="string">&quot;是一门强大的&quot;</span> &#125;;</span><br><span class="line">    std::string sentence;</span><br><span class="line"></span><br><span class="line">    sentence = part1 + <span class="string">&quot; &quot;</span> + part2 + <span class="string">&quot;语言&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; sentence &lt;&lt; std::endl; <span class="comment">// 输出: C++ 是一门强大的语言</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sentence = &quot;C+++&quot; 是一门强大的语言&quot;; // 错误，不能将两个C风格字符串字面量相加</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-hexo基本操作命令"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/02/hexo%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"
    >hexo基本操作命令</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/02/hexo%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/" class="article-date">
  <time datetime="2023-09-02T12:37:14.000Z" itemprop="datePublished">2023-09-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/hexo/">hexo</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Hexo&spm=1001.2101.3001.7020">Hexo</a> 约有二十个命令，但普通用户经常使用的大概只有下列几个:</p>
<h2 id="hexo-s"><a href="#hexo-s" class="headerlink" title="hexo s"></a><strong>hexo s</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>启动本地服务器，用于预览主题。默认地址： <a target="_blank" rel="noopener" href="http://localhost:4000/">http://localhost:4000/</a></p>
<ul>
<li>hexo s 是 hexo server 的缩写，命令效果一致；</li>
<li>预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；</li>
<li>对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果。</li>
</ul>
<h2 id="hexo-new"><a href="#hexo-new" class="headerlink" title="hexo new"></a><strong>hexo new</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;学习笔记  六&quot;</span><br></pre></td></tr></table></figure>

<p>新建一篇标题为 学习笔记 六 的文章，因为标题里有空格，所以加上了引号。</p>
<ul>
<li>文章标题可以在对应 md 文件里改，新建时标题可以写的简单些。</li>
</ul>
<h2 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a><strong>hexo d</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>自动生成网站静态文件，并部署到设定的仓库。</p>
<ul>
<li>hexo d 是 hexo deploy 的缩写，命令效果一致。</li>
</ul>
<h2 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a><strong>hexo clean</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p>清除缓存文件 db.json 和已生成的静态文件 public 。</p>
<ul>
<li>网站显示异常时可以执行这条命令试试。</li>
</ul>
<h2 id="hexo-g"><a href="#hexo-g" class="headerlink" title="hexo g"></a><strong>hexo g</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>生成网站静态文件到默认设置的 public 文件夹。</p>
<ul>
<li>便于查看网站生成的静态文件或者手动部署网站；</li>
<li>如果使用自动部署，不需要先执行该命令；</li>
<li>hexo g 是 hexo generate 的缩写，命令效果一致。</li>
</ul>
<h2 id="hexo-new-page"><a href="#hexo-new-page" class="headerlink" title="hexo new page"></a><strong>hexo new page</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page aboutme</span><br></pre></td></tr></table></figure>

<p>新建一个标题为 aboutme 的页面，默认链接地址为 主页地址&#x2F;aboutme&#x2F;</p>
<ul>
<li>标题可以为中文，但一般习惯用英文；</li>
<li>页面标题和文章一样可以随意修改；</li>
<li>页面不会出现在首页文章列表和归档中，也不支持设置分类和标签。</li>
</ul>
<p>hexo n “我的博客” 等价于 hexo new “我的博客” 还等价于 hexo new post “我的博客” #新建一篇文章<br>hexo p 等价于 hexo publish<br>hexo g 等价于 hexo generate<br>hexo s等价于 hexo server<br>hexo d 等价于 hexo deploy<br>hexo deploy -g 等价于 hexo deploy –generate<br>hexo generate -d等价于hexo generate –deploy</p>
<p>一般只需要四个命令，</p>
<p>hexo n 创建一个新的博客</p>
<p>hexo s 开启一个新的服务</p>
<p>hexo g 生成一个静态的网页</p>
<p>hexo d 将生成的静态网页推到服务器github</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-ayer-主题熟悉"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/02/ayer-%E4%B8%BB%E9%A2%98%E7%86%9F%E6%82%89/"
    >ayer 主题熟悉</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/02/ayer-%E4%B8%BB%E9%A2%98%E7%86%9F%E6%82%89/" class="article-date">
  <time datetime="2023-09-02T11:54:05.000Z" itemprop="datePublished">2023-09-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/hexo/">hexo</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-整体介绍"><a href="#1-整体介绍" class="headerlink" title="1 整体介绍"></a>1 整体介绍</h1><p><a target="_blank" rel="noopener" href="https://github.com/Shen-Yu/hexo-theme-ayer">Ayer</a> 是一个干净且优雅的 Hexo 主题，自带响应式，加载速度很快，该有的功能都有，可配置项很多，非常适合作为你的博客主题，主题内还附送了 6 张精美的高清壁纸。欢迎使用和 Star 支持，如果你在使用过程中有任何疑问或者建议，欢迎联系我！如果你的博客采用了本主题，欢迎在下面评论区留下地址~</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Shen-Yu/hexo-theme-ayer">Ayer</a> 在马来语中是“水”的意思，在西班牙语中是“昨天”的意思。</p>
<h1 id="2-特性"><a href="#2-特性" class="headerlink" title="2. 特性"></a>2. 特性</h1><ol>
<li>干净且优雅，文章内容美观易读</li>
<li>首页封面全屏平铺，扁平化设计，简洁又不失高大上</li>
<li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li>
<li>首页封面和文案可以任意更换，主题内附送 6 张精美高清壁纸</li>
<li>时间轴式的归档页</li>
<li>支持 <code>黑夜阅读</code> 模式</li>
<li>侧边栏可以点击显示或隐藏</li>
<li>支持文章置顶和文章打赏</li>
<li>支持文章字数和阅读时长统计</li>
<li>支持网易云音乐播放</li>
<li>支持  <code>MathJax</code> 和 <code>Katex</code> 数学公式</li>
<li>支持 <code>Mermaid</code> 流程图、状态图、时序图、甘特图</li>
<li><code>TOC</code> 目录在文章页悬浮，跳转更方便</li>
<li>集成了博客加密访问的功能</li>
<li>可设置阅读文章时做密码验证<a target="_blank" rel="noopener" href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md">hexo-blog-encrypt</a></li>
<li><a target="_blank" rel="noopener" href="https://valine.js.org/">Valine</a>和<a target="_blank" rel="noopener" href="https://gitalk.github.io/">Gitalk</a>评论模块（推荐配合<code>leancloud</code>使用  <code>Valine</code>）</li>
<li>集成了<a target="_blank" rel="noopener" href="http://busuanzi.ibruce.info/">不蒜子</a>、百度统计、Google Analytics、CNZZ 等统计功能</li>
<li>支持 Github Ribbons</li>
</ol>
<h1 id="3-主题配置"><a href="#3-主题配置" class="headerlink" title="3.主题配置"></a>3.主题配置</h1><p>以下是 ayer 主题目录下的 <code>_config.yml</code> 文件配置，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"># 侧边栏菜单</span><br><span class="line">menu:</span><br><span class="line">  主页: /</span><br><span class="line">  归档: /archives</span><br><span class="line">  分类: /categories</span><br><span class="line">  标签: /tags</span><br><span class="line">  摄影: http://shenyu-vip.lofter.com</span><br><span class="line">  旅行: /tags/旅行/</span><br><span class="line">  关于我: /2019/about</span><br><span class="line"></span><br><span class="line"># 站点次标题和打字动效</span><br><span class="line"># https://github.com/mattboldt/typed.js</span><br><span class="line">subtitle:</span><br><span class="line">  enable: true # 是否开启动效</span><br><span class="line">  text: 面朝大海，春暖花开 # 显示的文字</span><br><span class="line">  text2: 愿你一生努力，一生被爱 # 滚动播放，如果不需要可以留空</span><br><span class="line">  text3: 想要的都拥有，得不到的都释怀 # 最多支持三段文字</span><br><span class="line">  startDelay: 0 # 延迟时间</span><br><span class="line">  typeSpeed: 200 # 打字速度</span><br><span class="line">  loop: true # 是否循环</span><br><span class="line">  backSpeed: 100 # 回退速度</span><br><span class="line">  showCursor: true # 是否显示光标</span><br><span class="line"></span><br><span class="line"># 网站图标和侧边栏logo</span><br><span class="line">favicon: /favicon.ico</span><br><span class="line">logo: /images/ayer-side.svg</span><br><span class="line"></span><br><span class="line"># 封面配置</span><br><span class="line"># enable-是否启用封面；path-封面背景图；logo-封面logo</span><br><span class="line">cover:</span><br><span class="line">  enable: true</span><br><span class="line">  path: /images/cover1.jpg # /source/images目录下附送多张精美壁纸，可任意更换</span><br><span class="line">  logo: /images/ayer.svg # 如果不要直接设置成false</span><br><span class="line"></span><br><span class="line"># 页面顶部进度条</span><br><span class="line">progressBar: true</span><br><span class="line"></span><br><span class="line"># 告示板模块</span><br><span class="line">broadcast:</span><br><span class="line">  enable: true # true开启，false关闭</span><br><span class="line">  type: 2 # 1：自定义输入，2：一言api(https://hitokoto.cn/)</span><br><span class="line">  text: 一个安静优雅的hexo主题，快速且响应式。 # type为1时有效</span><br><span class="line"></span><br><span class="line"># 文章配置</span><br><span class="line"># 文章太长，截断按钮文字(在需要截断的行增加此标记：&lt;!--more--&gt;)</span><br><span class="line">excerpt_link: 阅读更多...</span><br><span class="line"># 如果你嫌每篇文章手动加more标记比较麻烦，又不想在首页全文显示，可以把excerpt_all设置成true，这样首页只会显示文章归档</span><br><span class="line">excerpt_all: false</span><br><span class="line"></span><br><span class="line"># 是否开启代码复制按钮</span><br><span class="line">copy_btn: true</span><br><span class="line"># 是否开启文章分享按钮</span><br><span class="line">share_enable: true</span><br><span class="line"># 国内的社交平台(If you are not in China, maybe you prefer to set:false)</span><br><span class="line">share_china: true</span><br><span class="line"># 文章分享文字</span><br><span class="line">share_text: 分享</span><br><span class="line"></span><br><span class="line"># 分页文字</span><br><span class="line">nav_text:</span><br><span class="line">  page_prev: 上一页</span><br><span class="line">  page_next: 下一页</span><br><span class="line">  post_prev: 上一篇</span><br><span class="line">  post_next: 下一篇</span><br><span class="line"></span><br><span class="line"># 文章页是否显示目录</span><br><span class="line">toc: true</span><br><span class="line"></span><br><span class="line"># 文章中的图片是否支持点击放大</span><br><span class="line">image_viewer: true</span><br><span class="line"></span><br><span class="line"># https://github.com/willin/hexo-wordcount</span><br><span class="line"># 是否开启字数统计(关闭请设置enable为false)</span><br><span class="line"># 也可以单独在md文件里Front-matter设置`no_word_count: true`属性，来自定义关闭字数统计</span><br><span class="line">word_count:</span><br><span class="line">  enable: true</span><br><span class="line">  # 只在文章详情显示(不在首页显示)</span><br><span class="line">  only_article_visit: true</span><br><span class="line"></span><br><span class="line"># 打赏</span><br><span class="line"># 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-默认开启所有文章均有打赏，如果有些文章你不需要，请在文章对应的md文件里设置no_reward:true</span><br><span class="line">reward_type: 2</span><br><span class="line"># 打赏wording</span><br><span class="line">reward_wording: &quot;请我喝杯咖啡吧~&quot;</span><br><span class="line"># 支付宝二维码图片地址，跟你设置logo的方式一样。比如：/images/alipay.jpg</span><br><span class="line">alipay: /images/alipay.jpg</span><br><span class="line"># 微信二维码图片地址</span><br><span class="line">weixin: /images/wechat.jpg</span><br><span class="line"></span><br><span class="line"># 版权声明</span><br><span class="line"># 版权声明type设定：0-关闭版权声明； 1-文章对应的md文件里有copyright: true属性，才有版权声明； 2-所有文章均有版权声明</span><br><span class="line">copyright_type: 2</span><br><span class="line"></span><br><span class="line"># 是否启用搜索</span><br><span class="line">search: true</span><br><span class="line"></span><br><span class="line"># RSS订阅(先安装hexo-generator-feed插件，再去博客根目录config进行配置)</span><br><span class="line"># 不想显示可以直接留空</span><br><span class="line">rss: /atom.xml</span><br><span class="line"></span><br><span class="line"># 是否启用黑夜模式开关</span><br><span class="line">darkmode: true</span><br><span class="line"></span><br><span class="line"># 动态背景效果: 0-关闭，1-动态线条(跟随鼠标)</span><br><span class="line">canvas_bg: 0</span><br><span class="line"></span><br><span class="line"># 自定义鼠标样式，直接替换/images/mouse.cur文件</span><br><span class="line">mouse:</span><br><span class="line">  enable: false</span><br><span class="line">  path: /images/mouse.cur</span><br><span class="line"></span><br><span class="line"># 鼠标点击效果：0-关闭，1-爱心，2-爆炸烟花，3-粒子烟花</span><br><span class="line">click_effect: 0</span><br><span class="line"></span><br><span class="line"># 页面宽度自定义（不建议修改，可能造成布局混乱），article_width文章宽度，sidebar_width侧边栏宽度</span><br><span class="line">layout:</span><br><span class="line">  article_width: 80rem</span><br><span class="line">  sidebar_width: 8rem</span><br><span class="line"></span><br><span class="line"># GitHub Ribbons-封面右上角的forkme，换样式直接在source/images目录下替换forkme图片</span><br><span class="line">github:</span><br><span class="line">  # (关闭请设置为false)</span><br><span class="line">  enable: true</span><br><span class="line">  url: https://github.com/Shen-Yu/hexo-theme-ayer</span><br><span class="line"></span><br><span class="line"># 网易云音乐插件</span><br><span class="line">music:</span><br><span class="line">  enable: false</span><br><span class="line">  # 播放器尺寸类型(1：小尺寸、2：大尺寸)</span><br><span class="line">  type: 1</span><br><span class="line">  id: 22707008 # 网易云分享的音乐ID(更换音乐请更改此配置项)</span><br><span class="line">  autoPlay: true # 是否开启自动播放</span><br><span class="line"></span><br><span class="line"># 访问量统计(不蒜子)</span><br><span class="line">busuanzi:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line"># 友盟cnzz统计(url填js代码src链接)</span><br><span class="line">cnzz:</span><br><span class="line">  enable: true</span><br><span class="line">  url: #</span><br><span class="line"></span><br><span class="line"># Google Analytics</span><br><span class="line">google_analytics: &quot;&quot;</span><br><span class="line"># 百度统计</span><br><span class="line">baidu_analytics: &quot;&quot;</span><br><span class="line"></span><br><span class="line"># Mathjax数学公式</span><br><span class="line">mathjax: true</span><br><span class="line"></span><br><span class="line"># Katex数学公式(allpost设置为false时只有头部设置math:true的文章才开启)</span><br><span class="line"># 需要更换hexo渲染器，npm un hexo-renderer-marked -S &amp;&amp; npm i hexo-renderer-markdown-it-katex -S</span><br><span class="line">katex:</span><br><span class="line">  enable: false # true</span><br><span class="line">  allpost: true</span><br><span class="line">  copy_tex: false</span><br><span class="line"></span><br><span class="line"># mermaid流程图 三个选项缺一不可(https://mermaid-js.github.io/mermaid/#/)</span><br><span class="line">mermaid:</span><br><span class="line">  enable: false</span><br><span class="line">  cdn: https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js</span><br><span class="line">  theme: forest</span><br><span class="line"></span><br><span class="line"># 网站成立年份(默认为 2019，若填入年份小于当前年份，则显示为 2018-2019 类似的格式)</span><br><span class="line">since: 2019</span><br><span class="line"></span><br><span class="line"># ICP备案信息尾部显示</span><br><span class="line">icp:</span><br><span class="line">  enable: false</span><br><span class="line">  url: &quot;http://www.beian.miit.gov.cn/&quot; # 备案链接</span><br><span class="line">  text: &quot;浙ICP备88888888&quot; # 备案信息</span><br><span class="line"># 公安备案信息尾部显示</span><br><span class="line">gongan:</span><br><span class="line">  enable: true</span><br><span class="line">  img: /images/beian.png #公安备案图片</span><br><span class="line">  url: &quot;http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=01234567890123&quot; #公安备案链接</span><br><span class="line">  text: &quot;浙公网安备01234567890123号&quot; #公安备案信息</span><br><span class="line"></span><br><span class="line"># 友情链接</span><br><span class="line">friends_link:</span><br><span class="line">  Ayer主题: #网站名称</span><br><span class="line">    #网站地址</span><br><span class="line">    url: https://github.com/Shen-Yu/hexo-theme-ayer</span><br><span class="line">    #网站图片(可忽略不写)</span><br><span class="line">    img: /images/ayer.png</span><br><span class="line">  GitHub:</span><br><span class="line">    url: https://github.com/Shen-Yu</span><br><span class="line">    img: https://i.loli.net/2020/09/07/indb4PRYDA98EkN.png</span><br><span class="line">  码云:</span><br><span class="line">    url: https://gitee.com/shen-yu</span><br><span class="line">    img: https://i.loli.net/2020/09/07/K3AqO7h6krQFlRX.png</span><br><span class="line">  Hexo官网:</span><br><span class="line">    url: https://hexo.io</span><br><span class="line">    img: https://i.loli.net/2020/09/07/UYGzjo7h68CRWny.png</span><br><span class="line">  Hexo图表插件:</span><br><span class="line">    url: https://github.com/Shen-Yu/hexo-tag-chart</span><br><span class="line">    img: https://i.loli.net/2020/09/07/GIXBYE5SoylhR1r.png</span><br><span class="line"></span><br><span class="line"># 评论：1、Valine(推荐)；2、Gitalk；3、Twikoo; 4.MiniValine</span><br><span class="line"></span><br><span class="line"># 1、Valine[一款快速、简洁且高效的无后端评论系统](https://github.com/xCss/Valine)</span><br><span class="line"># 启用Valine必须先创建leancloud应用， 获取 id|key 填入即可</span><br><span class="line">leancloud:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: #</span><br><span class="line">  app_key: #</span><br><span class="line"># Valine配置</span><br><span class="line">valine:</span><br><span class="line">  enable: true # 是否启用</span><br><span class="line">  avatar: monsterid # 头像样式(https://valine.js.org/avatar.html)</span><br><span class="line">  placeholder: 给我的文章加点评论吧~ # placeholder</span><br><span class="line"></span><br><span class="line"># 2、Gitalk(https://github.com/gitalk/gitalk)</span><br><span class="line">gitalk:</span><br><span class="line">  enable: false # true</span><br><span class="line">  clientID: # GitHub Application Client ID</span><br><span class="line">  clientSecret: # Client Secret</span><br><span class="line">  repo: # Repository name</span><br><span class="line">  owner: # GitHub ID</span><br><span class="line">  admin: # GitHub ID</span><br><span class="line"></span><br><span class="line"># 3、Twikoo(https://github.com/imaegoo/twikoo)</span><br><span class="line">twikoo:</span><br><span class="line">  enable: false</span><br><span class="line">  envId: #</span><br><span class="line"></span><br><span class="line"># 4、MiniValine</span><br><span class="line"># See: https://github.com/MiniValine/MiniValine</span><br><span class="line">minivaline:</span><br><span class="line">  enable: false</span><br><span class="line">  serverURL: https://minivaline.your-domain.com</span><br><span class="line"></span><br><span class="line"># 首页广告配置</span><br><span class="line"># 可以根据需要自行增加ad_3，ad_4...，留空则不显示</span><br><span class="line">ads:</span><br><span class="line">  ad_1:</span><br><span class="line">    title: vultr优惠vps</span><br><span class="line">    img: https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/vultr.png</span><br><span class="line">    url: https://www.vultr.com/?ref=8630075</span><br><span class="line">    width: 300</span><br><span class="line">  ad_2:</span><br><span class="line">    title: 云服务器全球购低至2折</span><br><span class="line">    img: https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/ad_2.jpg</span><br><span class="line">    url: https://curl.qcloud.com/kvO7hb43</span><br><span class="line">    width: 300</span><br><span class="line"></span><br><span class="line"># 网站开启加密访问，密码可设置任何字符</span><br><span class="line">lock:</span><br><span class="line">  enable: false</span><br><span class="line">  password: 123456</span><br></pre></td></tr></table></figure>

<h2 id="4-插件-可选"><a href="#4-插件-可选" class="headerlink" title="4 插件(可选)"></a>4 插件(可选)</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/netcan/hexo-generator-index-pin-top">hexo-generator-index-pin-top</a> 用于文章置顶</li>
<li><a target="_blank" rel="noopener" href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md">hexo-blog-encrypt</a> 用于文章加密</li>
<li><a target="_blank" rel="noopener" href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md">hexo-tag-aplayer</a> 用于播放音乐</li>
<li><a target="_blank" rel="noopener" href="https://github.com/MoePlayer/hexo-tag-dplayer">hexo-tag-dplayer</a> 用于播放视频</li>
<li><a target="_blank" rel="noopener" href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md">hexo-helper-live2d</a> 二次元看板娘</li>
</ul>
<h2 id="5-分类"><a href="#5-分类" class="headerlink" title="5.分类"></a>5.分类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>然后将以下复制到 &#x2F;source&#x2F;categories&#x2F;index.md 文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="6-标签"><a href="#6-标签" class="headerlink" title="6.标签"></a>6.标签</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>配置同分类一样</p>
<h2 id="7-友情链接"><a href="#7-友情链接" class="headerlink" title="7. 友情链接"></a>7. 友情链接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page friends</span><br></pre></td></tr></table></figure>

<p>然后将以下复制到 &#x2F;source&#x2F;friends&#x2F;index.md 文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: friends</span><br><span class="line">type: friends</span><br><span class="line">layout: &quot;friends&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>然后在 ayer 主题目录下的 <code>_config.yml</code> 中自定义 <code>friends_link</code> 配置项即可</p>
<h2 id="8-相册"><a href="#8-相册" class="headerlink" title="8.相册"></a>8.相册</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page photos</span><br></pre></td></tr></table></figure>

<p>然后将以下复制到 &#x2F;source&#x2F;photos&#x2F;index.md 文件，<code>img_url</code> 替换成图片路径，<code>caption</code> 替换成图片名称</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Gallery</span><br><span class="line"></span><br><span class="line">albums: [[&quot;img_url&quot;, &quot;img_caption&quot;], [&quot;img_url&quot;, &quot;img_caption&quot;]]</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h2><p>用 Tocbot 解析文章标题并生成目录</p>
<ul>
<li>将以下配置复制到你 ayer 主题目录下的 <code>_config.yml</code> 里：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Toc</span><br><span class="line">toc: true</span><br></pre></td></tr></table></figure>

<ul>
<li>当然你可能并不想所有文章都生成悬浮目录，你可以在文章顶部的配置中加一行来进行关闭：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">no_toc: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/10/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/12/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="热爱学习的未来酱"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>