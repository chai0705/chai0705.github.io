<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="永远年轻，永远热泪盈眶" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 热爱学习的未来酱</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="热爱学习的未来酱" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover3.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">热爱学习的未来酱</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '向上的路，并不拥挤。拥挤是因为，大部分人选择了安逸', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-预处理过程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/%E9%A2%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/"
    >预处理过程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/%E9%A2%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/" class="article-date">
  <time datetime="2023-09-04T23:45:08.000Z" itemprop="datePublished">2023-09-05</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
   
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-3-2-GCC命令参数"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/3-2-GCC%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0/"
    >3.2 GCC命令参数</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/3-2-GCC%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0/" class="article-date">
  <time datetime="2023-09-04T23:44:56.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">c高级编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
   
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BF%90%E8%A1%8C/" rel="tag">程序的编译、链接和运行</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-2023-0905-反思"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/2023-0905-%E5%8F%8D%E6%80%9D/"
    >2023 0905 反思</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/2023-0905-%E5%8F%8D%E6%80%9D/" class="article-date">
  <time datetime="2023-09-04T23:38:35.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8F%8D%E6%80%9D/">反思</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>日期：9月5日<br>星期：星期二<br>时间：6:51</p>
<p>时间过得真快啊，在这段往昔时光中，我们又将前往何方呢？</p>
<p>刚刚想到了是不是应该考个研究生的问题，研究生可以让我再次接触到新的知识、拓宽视野，但现在的生活还有很多要提升的地方，学习的方法，对于自己的控制力量等等，</p>
<p>在目前的生活中，我其实并无所追求，工资多少也并不重要，生活差不多就足够了。吃的东西不难吃，不饿就可以，有时甚至想着干净的平平凡凡的过一生就够了。</p>
<p>然后回到现实，现在就认真的完成一天的工作，看看书，提升自己就可以了，以后有机会把握住才好呀，你说对吗。</p>
<p>再回到现在的博客中，问题有点大，就像昨天整理的那个驱动一样，一部分一个markdown是不太好的。如果有机会的话，还是需要将每一章作为一个整体，这不仅仅是分开的问题，毕竟谁愿意看太多的字呢？</p>
<p>好了，新的一天已经开始了，请继续加油！</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%8D%E6%80%9D/" rel="tag">反思</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-3-1-程序的编译与可执行文件"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/04/3-1-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"
    >程序的编译与可执行文件</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/3-1-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/" class="article-date">
  <time datetime="2023-09-04T13:19:52.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">c高级编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="3-1-程序的编译与可执行文件"><a href="#3-1-程序的编译与可执行文件" class="headerlink" title="3.1 程序的编译与可执行文件"></a>3.1 程序的编译与可执行文件</h1><h2 id="3-1-1-可执行文件的组装"><a href="#3-1-1-可执行文件的组装" class="headerlink" title="3.1.1 可执行文件的组装"></a>3.1.1 可执行文件的组装</h2><p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042146452.png" alt="image-20230904214608380"></p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042146097.png" alt="image-20230904214623995"></p>
<p>编译过程的特点可以总结如下：</p>
<p>非一步到位：编译过程不是一次性完成的，而是分为多个阶段逐步完成的。</p>
<p>环环相扣：每个阶段的输出作为下一个阶段的输入，各个阶段之间有着紧密的联系和依赖关系。</p>
<p>分为预编译、编译、汇编、链接阶段：编译过程可以划分为预处理、编译、汇编和链接几个主要阶段。</p>
<p>调用不同的工具：每个阶段都调用不同的工具或编译器来完成特定的任务。</p>
<ul>
<li><p>预处理：在预处理阶段，预处理器将源文件进行处理，如宏展开、头文件包含等，生成处理后的源文件。</p>
</li>
<li><p>编译：在编译阶段，编译器将处理后的源文件转换为汇编语言代码，进行语法分析、语义分析、优化等操作。</p>
</li>
<li><p>汇编：在汇编阶段，汇编器将生成的汇编语言代码转换为机器语言指令，并生成目标文件。</p>
</li>
<li><p>链接：在链接阶段，链接器将多个目标文件和库文件进行链接，解析符号引用，生成可执行目标文件（如ELF格式）。</p>
</li>
</ul>
<p>生成可执行文件是编译过程中的最终目标，但为什么编译过程中不直接生成可执行文件，而是分为多个阶段呢？</p>
<p>首先是GNU的思想，即”一个工具只干一件事情”。GNU工具链以及许多其他编译工具都遵循这个原则。将编译过程分为多个阶段，每个阶段有专门的工具来处理，可以使得每个工具更加专注于自己的任务。例如，预处理器负责处理宏展开、头文件包含等，编译器负责将源代码转换为汇编代码，汇编器负责将汇编代码转换为机器代码，链接器负责将目标文件链接为可执行文件。这样的分工可以简化每个工具的实现和复杂度，使得工具更加可靠、可维护，并提高了工具的复用性。</p>
<p>其次是计算机工业思维中的标准接口和分层原则。将编译过程分为多个阶段，每个阶段的输入和输出都有明确定义的接口，使得每个阶段都可以独立进行开发和优化。这样的分层结构可以适配更多的平台、CPU架构和指令集，使得编译器可以在不同的系统上使用相同的前端和中间表示，通过后端进行特定平台的代码生成。这种模块化和分层的设计使得编译器更加灵活、可扩展，并能够适应不断变化的计算机体系结构和需求。</p>
<h2 id="3-1-2-从源程序到可执行文件"><a href="#3-1-2-从源程序到可执行文件" class="headerlink" title="3.1.2 从源程序到可执行文件"></a>3.1.2 从源程序到可执行文件</h2><p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042152389.png" alt="image-20230904215208244"></p>
<ol>
<li>预处理：源程序中的 <code>#include&lt;stdio.h&gt;</code> 被预处理器处理，将对应的头文件内容插入到源程序中，生成处理后的源程序。</li>
<li>编译：编译器将处理后的源程序进行语法分析、语义分析、优化等操作，生成目标文件。在目标文件中，包括以下部分：<ul>
<li>ELF header：ELF（可执行与可链接格式）头部，包含关于文件格式的信息。</li>
<li>Program header table：程序头表，描述程序的段（段包含代码、数据等）。</li>
<li>.text 段：包含程序的机器代码。</li>
<li>.rodata 段：包含只读数据，如字符串常量。</li>
<li>.data 段：包含已初始化的全局和静态变量。</li>
<li>.bss 段：包含未初始化的全局和静态变量。</li>
</ul>
</li>
<li>链接：链接器将目标文件进行链接，生成可执行文件。在可执行文件中，包括以下部分：<ul>
<li>ELF header：与目标文件相同，包含关于文件格式的信息。</li>
<li>Program header table：与目标文件相同，描述程序的段。</li>
<li>.text 段：与目标文件相同，包含程序的机器代码。</li>
<li>.rodata 段：与目标文件相同，包含只读数据。</li>
<li>.data 段：与目标文件相同，包含已初始化的全局和静态变量。</li>
<li>.bss 段：与目标文件相同，包含未初始化的全局和静态变量。</li>
<li>符号表（.symtab）：包含程序中定义的全局和静态符号的信息。</li>
<li>字符串表（.strtab）：保存符号表中的字符串。</li>
<li>调试信息（.debug）：包含调试器使用的信息。</li>
<li>行号信息（.line）：包含源代码的行号信息。</li>
</ul>
</li>
</ol>
<p>最终生成的可执行文件包含了程序的机器代码、数据、符号表等信息，可以在计算机上执行。编译过程中的中间文件和信息都嵌入到最终的可执行文件中，以便在运行时进行处理和调试。</p>
<h2 id="3-1-3-目标文件"><a href="#3-1-3-目标文件" class="headerlink" title="3.1.3 目标文件"></a>3.1.3 目标文件</h2><p>目标文件（Object file）是编译器生成的中间文件，它包含了编译后的机器代码、数据和符号信息，用于最终生成可执行文件或共享目标文件。目标文件的类型可以通过命令 <code>file</code> 进行查看。</p>
<p>常见的目标文件类型包括：</p>
<ul>
<li>可重定位目标文件（Relocatable files）：这种类型的目标文件包含了编译后的机器代码、数据和符号信息，但是它们的内部地址是相对于起始地址的偏移量，还没有进行最终的地址分配和链接。可重定位目标文件可以作为其他可重定位目标文件或可执行目标文件的输入，用于生成最终的可执行文件或共享目标文件。</li>
<li>可执行目标文件（Executable files）：这种类型的目标文件是经过链接的最终可执行文件，包含了所有的机器代码、数据和符号信息，可以直接在操作系统上执行。</li>
<li>可被共享目标文件（Shared object file）：也被称为动态链接库（Dynamic Linking Library）或共享库（Shared Library）。这种类型的目标文件包含了可被多个可执行文件或其他共享库共享使用的代码和数据，可以在运行时动态加载到内存中，并与其他程序共享使用。</li>
<li>可执行文件（ELF，Executable and Linkable Format）：这是一种可执行文件的格式，广泛用于类UNIX系统。可执行文件可以直接在操作系统上执行，包含了机器代码、数据和符号信息，以及其他与执行相关的信息（如程序入口点等）。</li>
</ul>
<h2 id="3-1-4-ELF可执行文件的结构"><a href="#3-1-4-ELF可执行文件的结构" class="headerlink" title="3.1.4 ELF可执行文件的结构"></a>3.1.4 ELF可执行文件的结构</h2><ol>
<li>ELF header（ELF 头）：包含了关于文件格式的信息，如文件类型、目标体系结构、入口点地址等。</li>
<li>Program header table（程序头表）：描述了可执行文件的段（segment）信息，每个段对应一个或多个节（section），包括代码段、只读数据段、可读写数据段等。程序头表记录了每个段的起始地址、大小、访问权限等信息。</li>
<li>.init 段：包含了可执行文件在加载到内存后需要执行的初始化代码，如全局变量的初始化和动态链接器的初始化等。</li>
<li>.text、.rodata、.data、.bss 等段：这些段包含了实际的代码和数据。<ul>
<li>.text 段：包含了可执行代码的机器指令，也就是程序的代码段。</li>
<li>.rodata 段：包含了只读数据，如字符串常量等。</li>
<li>.data 段：包含了已初始化的全局和静态变量。</li>
<li>.bss 段：包含了未初始化的全局和静态变量，这些变量在运行时会被初始化为 0。</li>
</ul>
</li>
<li>符号表（.symtab）：记录了程序中定义和引用的全局和静态符号的信息，如函数和变量。符号表中包含了符号的名称、类型、大小、地址等信息。</li>
<li>调试信息（.debug）：包含了调试器使用的信息，如源代码的行号信息、变量和函数的调试信息等。</li>
<li>行号信息（.line）：包含了源代码的行号信息，用于将机器代码映射回源代码的行号。</li>
<li>字符串表（.strtab）：保存了符号表和调试信息中使用的字符串。</li>
<li>Section header table（节头表）：描述了各个节的信息，包括名称、类型、偏移量、大小等。</li>
</ol>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_val = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> uninit_val;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> local_val = <span class="number">2</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> uninit_local_val;</span><br><span class="line">    </span><br><span class="line">    a = add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    b = sub(<span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sub.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用以下命令编译成目标文件，但是不进行链接</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c main.c sub.c</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042209197.png" alt="image-20230904220907171"></p>
<p>使用以下命令读取ELF header</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -h main.o</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042211626.png" alt="image-20230904221103590"></p>
<p>然后使用以下命令查看节头表（section heads）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -S main.o</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042213386.png" alt="image-20230904221310333"></p>
<p>最后使用以下命令进行链接,生成可执行文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.o sub.o</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042215351.png" alt="image-20230904221504326"></p>
<p>重新读取elf头和section heads</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">topeet@ubuntu:~/demo$ readelf -h a.out </span><br><span class="line">ELF 头：</span><br><span class="line">  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  类别:                              ELF64</span><br><span class="line">  数据:                              2 补码，小端序 (little endian)</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          0</span><br><span class="line">  类型:                              DYN (共享目标文件)</span><br><span class="line">  系统架构:                          Advanced Micro Devices X86-64</span><br><span class="line">  版本:                              0x1</span><br><span class="line">  入口点地址：               0x1060</span><br><span class="line">  程序头起点：          64 (bytes into file)</span><br><span class="line">  Start of section headers:          15016 (bytes into file)</span><br><span class="line">  标志：             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         13</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         31</span><br><span class="line">  Section header string table index: 30</span><br><span class="line">topeet@ubuntu:~/demo$ read</span><br><span class="line">read         readarray    readelf      readlink     readonly     readprofile  </span><br><span class="line">topeet@ubuntu:~/demo$ readelf -S a.out </span><br><span class="line">There are 31 section headers, starting at offset 0x3aa8:</span><br><span class="line"></span><br><span class="line">节头：</span><br><span class="line">  [号] 名称              类型             地址              偏移量</span><br><span class="line">       大小              全体大小          旗标   链接   信息   对齐</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .interp           PROGBITS         0000000000000318  00000318</span><br><span class="line">       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">  [ 2] .note.gnu.propert NOTE             0000000000000338  00000338</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE             0000000000000358  00000358</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .note.ABI-tag     NOTE             000000000000037c  0000037c</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 5] .gnu.hash         GNU_HASH         00000000000003a0  000003a0</span><br><span class="line">       0000000000000028  0000000000000000   A       6     0     8</span><br><span class="line">  [ 6] .dynsym           DYNSYM           00000000000003c8  000003c8</span><br><span class="line">       00000000000000c0  0000000000000018   A       7     1     8</span><br><span class="line">  [ 7] .dynstr           STRTAB           0000000000000488  00000488</span><br><span class="line">       0000000000000088  0000000000000000   A       0     0     1</span><br><span class="line">  [ 8] .gnu.version      VERSYM           0000000000000510  00000510</span><br><span class="line">       0000000000000010  0000000000000002   A       6     0     2</span><br><span class="line">  [ 9] .gnu.version_r    VERNEED          0000000000000520  00000520</span><br><span class="line">       0000000000000020  0000000000000000   A       7     1     8</span><br><span class="line">  [10] .rela.dyn         RELA             0000000000000540  00000540</span><br><span class="line">       00000000000000c0  0000000000000018   A       6     0     8</span><br><span class="line">  [11] .rela.plt         RELA             0000000000000600  00000600</span><br><span class="line">       0000000000000018  0000000000000018  AI       6    24     8</span><br><span class="line">  [12] .init             PROGBITS         0000000000001000  00001000</span><br><span class="line">       000000000000001b  0000000000000000  AX       0     0     4</span><br><span class="line">  [13] .plt              PROGBITS         0000000000001020  00001020</span><br><span class="line">       0000000000000020  0000000000000010  AX       0     0     16</span><br><span class="line">  [14] .plt.got          PROGBITS         0000000000001040  00001040</span><br><span class="line">       0000000000000010  0000000000000010  AX       0     0     16</span><br><span class="line">  [15] .plt.sec          PROGBITS         0000000000001050  00001050</span><br><span class="line">       0000000000000010  0000000000000010  AX       0     0     16</span><br><span class="line">  [16] .text             PROGBITS         0000000000001060  00001060</span><br><span class="line">       0000000000000225  0000000000000000  AX       0     0     16</span><br><span class="line">  [17] .fini             PROGBITS         0000000000001288  00001288</span><br><span class="line">       000000000000000d  0000000000000000  AX       0     0     4</span><br><span class="line">  [18] .rodata           PROGBITS         0000000000002000  00002000</span><br><span class="line">       0000000000000014  0000000000000000   A       0     0     4</span><br><span class="line">  [19] .eh_frame_hdr     PROGBITS         0000000000002014  00002014</span><br><span class="line">       0000000000000064  0000000000000000   A       0     0     4</span><br><span class="line">  [20] .eh_frame         PROGBITS         0000000000002078  00002078</span><br><span class="line">       0000000000000188  0000000000000000   A       0     0     8</span><br><span class="line">  [21] .init_array       INIT_ARRAY       0000000000003db8  00002db8</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [22] .fini_array       FINI_ARRAY       0000000000003dc0  00002dc0</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [23] .dynamic          DYNAMIC          0000000000003dc8  00002dc8</span><br><span class="line">       00000000000001f0  0000000000000010  WA       7     0     8</span><br><span class="line">  [24] .got              PROGBITS         0000000000003fb8  00002fb8</span><br><span class="line">       0000000000000048  0000000000000008  WA       0     0     8</span><br><span class="line">  [25] .data             PROGBITS         0000000000004000  00003000</span><br><span class="line">       0000000000000018  0000000000000000  WA       0     0     8</span><br><span class="line">  [26] .bss              NOBITS           0000000000004018  00003018</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     4</span><br><span class="line">  [27] .comment          PROGBITS         0000000000000000  00003018</span><br><span class="line">       000000000000002b  0000000000000001  MS       0     0     1</span><br><span class="line">  [28] .symtab           SYMTAB           0000000000000000  00003048</span><br><span class="line">       00000000000006f0  0000000000000018          29    49     8</span><br><span class="line">  [29] .strtab           STRTAB           0000000000000000  00003738</span><br><span class="line">       0000000000000255  0000000000000000           0     0     1</span><br><span class="line">  [30] .shstrtab         STRTAB           0000000000000000  0000398d</span><br><span class="line">       000000000000011a  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br><span class="line">topeet@ubuntu:~/demo$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-1-5-动态库和静态库的生成"><a href="#3-1-5-动态库和静态库的生成" class="headerlink" title="3.1.5 动态库和静态库的生成"></a>3.1.5 动态库和静态库的生成</h2><p>使用以下命令可以生成静态库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libsub.a sub.o</span><br></pre></td></tr></table></figure>

<p>其中库的名字必须以lib开头，使用readelf重新读取以下该库的elf头，如下所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042226316.png" alt="image-20230904222640273"></p>
<p>使用以下命令生成动态库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC -o libsub.so sub.c</span><br></pre></td></tr></table></figure>

<p>然后使用readelf 读取elf头如下所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042227936.png" alt="image-20230904222725900"></p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BF%90%E8%A1%8C/" rel="tag">程序的编译、链接和运行</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-rk3568-驱动开发第一篇-驱动基础-1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%80%E7%AF%87-%E9%A9%B1%E5%8A%A8%E5%9F%BA%E7%A1%80-1/"
    >rk3568 驱动开发第一篇 驱动基础</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%80%E7%AF%87-%E9%A9%B1%E5%8A%A8%E5%9F%BA%E7%A1%80-1/" class="article-date">
  <time datetime="2023-09-04T13:15:13.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第1章-前言"><a href="#第1章-前言" class="headerlink" title="第1章 前言"></a>第1章 前言</h1><p>磨刀不误砍柴工！在学习驱动之前先和同学们交流下学习方法和学习态度。</p>
<h2 id="1-1-学习方法"><a href="#1-1-学习方法" class="headerlink" title="1.1 学习方法"></a>1.1 学习方法</h2><p>在学习驱动的过程中，同学们难免会遇到很多问题，例如编译环境的问题造成内核编译不通过、交叉编译器或者架构类型没有设置导致驱动编译失败、内核版本和驱动版本不统一造成驱动加载不成功等多种问题。</p>
<p>在遇到问题的时候，同学们一定不要灰心，要敢于去尝试用自己的思路去解决问题。机遇与挑战往往是并存的。当同学们解决一个问题以后，自然就会前进一步。水滴石穿，才可以真正掌握linux驱动。</p>
<p> 所以一定要养成独立思考的好习惯！遇到问题之后，同学们可以先自己根据问题的具体表现，来找到问题的源头，仔细分析问题产生的原因和解决的方法，自主思考无果之后可以尝试去谷歌、百度、CSDN等各大检索网站上寻求帮助，Linux已经发展了很多年，前辈们在之前进行了无数的探索，总有许多类似的经验，能解决绝大多数的问题。</p>
<p>并且在学习过程中千万不要好高骛远，比如对于一些有基础的同学来说，学习过相似的知识点就一目十行甚至直接跳过，这种行为是不可取的，学习一遍和学习两遍的知识点，在认知和运用程度上是完全不一样的。读书要从薄到厚,再厚到薄，学习亦是如此。</p>
<p>端正学习态度后还要有一个好的学习方法，迅为公司在多年培训和产品开发中总结出来了一套适合初学者的学习方式，具体含义解释为框架化学习，快速原型。运用到嵌入式Linux驱动学习上就是从一开始先看到Linux驱动知识领域的外貌，然后逐渐深入！以了解北京这座城市为例，如果在胡同里转来转去，可能几年都搞不清楚这个城市是什么情况，但是如果先通过北京地图学习一下，了解天安门在什么地方，鸟巢在什么地方，香山八达岭在哪里，然后到这些地方看一看，可能很快就能掌握这座城市的全貌。所以运用框架学习法，在对不同层次的框架进行学习过程中，逐渐了解和掌握整个系统。 如果不注意方法，每天在胡同里面来回转悠，肯定是事倍功半，很长时间将不得要领。</p>
<p>需要注意的是，即便有了地图，也需要一些基础，比如知道什么是天安门，知道鸟巢的来历，明白八达岭是怎么回事，实际上这些就是基础知识。也就是说在学习系统框架之前要具备一定的基础，否则这张地图也是看不懂的。学习驱动知识也是需要一定的基础的，所以驱动学习是有门槛的！</p>
<p>对于学习方法和学习态度就先说这样多，关于基础方面，下一节会专门讨论。 </p>
<h2 id="1-2-基础准备"><a href="#1-2-基础准备" class="headerlink" title="1.2 基础准备"></a>1.2 基础准备</h2><p>首先，不要脱离硬件。就好比用仿真软件学习51单片机是永远掌握不了单片机的精髓的。所以有一块硬件开发板是学习驱动的前提。</p>
<p>第二，有了开发板之后，要掌握开发板的基本操作。如开发板的启动，烧写镜像等操作。</p>
<p>第三，能够成功编译开发板的系统源码。在驱动的学习过程中，是避免不了的要对内核的某些功能进行使能、修改设备树添加对应的设备，这些操作都需要进行源码编译。</p>
<p>第四，掌握C语言。驱动程序是由C语言编写的，而且内核源码中绝大多数的代码也都是由C语言编写的，在学习驱动的过程中，或多或少的要对源码进行阅读。所以C语言基础是学习驱动的必要条件之一。</p>
<p>第五，掌握Linux环境搭建以及shell命令的使用。</p>
<p>第六，驱动最后必然要落实到相应的硬件上，所以肯定要对底层电路有所了解，以驱动LED灯为例，必然要了解其控制电路，找到相应的控制引脚，要能读懂简单的硬件原理图。</p>
<h1 id="第2章-你好！内核源码"><a href="#第2章-你好！内核源码" class="headerlink" title="第2章 你好！内核源码"></a>第2章 你好！内核源码</h1><p>本章我们来认识Linux内核源码，开始真正进入到驱动的世界里面，不知道各位小伙伴们有没有做好准备呢？ </p>
<h2 id="2-1-初识内核源码"><a href="#2-1-初识内核源码" class="headerlink" title="2.1 初识内核源码"></a>2.1 初识内核源码</h2><p>Linux内核源码的官方网站为<a target="_blank" rel="noopener" href="https://www.kernel.org/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%AF%A5%E7%BD%91%E7%AB%99%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%9A%84Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E3%80%82%E8%BF%9B%E5%85%A5%E8%AF%A5%E7%BD%91%E7%AB%99%E4%B9%8B%E5%90%8E%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%88%E5%9B%BE2-1%EF%BC%89%E6%89%80%E7%A4%BA%EF%BC%9A">https://www.kernel.org/，可以在该网站下载最新的Linux内核源码。进入该网站之后如下图（图2-1）所示：</a></p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115782.png"></p>
<p>图 2-1</p>
<p>从上图（图1）可以看到多个版本的内核分支，分别为主线版本（mainline）、稳定版本（stable）和长期支持版本（longterm）。以上各个支线和主线是由linus torvalds（Linux之父）所领导。半导体厂商和一些内核爱好者会在官网下载相应版本的内核源码，对该源码进行打补丁等操作。以此让官网的内核源码可以在半导体厂家设计的主控（CPU）上跑起来，所以在开发和学习的过程中，我们并不会直接去Linux内核官网下去下载源码，而且是使用半导体厂家提供的源码包。</p>
<p>但是不论是Linux官网的内核源码还是半导体厂家提供的内核源码不影响我们来看它的庐山真面目！作者下载了Linux官方网站的4.19.262分支源码，下载好的源码存放在“iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\01_Linux内核官方源码”如下图（图2-2）所示： </p>
<p>将Linux内核官方源码拷贝到虚拟机ubuntu上如下图（图2-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115757.jpeg" alt="img"> </p>
<p>图 2-3</p>
<p>使用以下命令对内核官方源码进行解压，解压完成如下图（图2-4）所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -vxf linux-4.19.262.tar.xz </span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115774.jpeg" alt="img"> </p>
<p>图 2-4</p>
<p>解压完成后我们会看到非常多的文件夹，这些文件夹放的就是Linux内核源码，在下一小节中作者来介绍Linux内核源码的结构和每个目录的作用。</p>
<h2 id="2-2-内核源码结构"><a href="#2-2-内核源码结构" class="headerlink" title="2.2 内核源码结构"></a>2.2 内核源码结构</h2><p>上一小节解压的目录下的内核源码目录都是用来做什么的呢？如下图（图2-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115788.jpeg" alt="img"> </p>
<p>图 2-5</p>
<p>目录的内容如下表（表2-6）所示：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>arch</td>
<td>存放不同平台体系相关代码</td>
</tr>
<tr>
<td>block</td>
<td>存放块设备相关代码</td>
</tr>
<tr>
<td>crypto</td>
<td>存放加密、压缩、CRC校验等算法相关代码</td>
</tr>
<tr>
<td>Documentation</td>
<td>存放相关说明文档，很多实用文档，包括驱动编写等</td>
</tr>
<tr>
<td>drivers</td>
<td>存放Linux 内核设备驱动程序源码。该目录包含众多驱动，目录按照设备类别进行分类，如 char、block 、input、i2c、spi、pci、usb等。</td>
</tr>
<tr>
<td>firmware</td>
<td>存放处理器相关的一些特殊固件</td>
</tr>
<tr>
<td>fs</td>
<td>存放虚拟文件系统代码</td>
</tr>
<tr>
<td>include</td>
<td>存放内核所需、与平台无关的头文件</td>
</tr>
<tr>
<td>init</td>
<td>Linux系统启动初始化相关的代码</td>
</tr>
<tr>
<td>ipc</td>
<td>存放进程间通信代码</td>
</tr>
<tr>
<td>kernel</td>
<td>Linux内核的核心代码，包含了进程调度子系统，以及和进程调度相关的模块。</td>
</tr>
<tr>
<td>lib</td>
<td>库文件代码， 实现需要在内核中使用的库函数，例如CRC、FIFO、list、MD5等。</td>
</tr>
<tr>
<td>mm</td>
<td>实现存放内存管理代码</td>
</tr>
<tr>
<td>net</td>
<td>存放网络相关代码</td>
</tr>
<tr>
<td>samples</td>
<td>存放提供的一些内核编程范例</td>
</tr>
<tr>
<td>scripts</td>
<td>存放一些脚本文件</td>
</tr>
<tr>
<td>security</td>
<td>存放系统安全性相关代码</td>
</tr>
<tr>
<td>sound</td>
<td>存放声音、声卡相关驱动</td>
</tr>
<tr>
<td>tools</td>
<td>一些常用工具，如性能剖析、自测试等</td>
</tr>
<tr>
<td>usr</td>
<td>用于生成initramfs的代码。</td>
</tr>
<tr>
<td>virt</td>
<td>提供虚拟机技术（KVM等）的支持</td>
</tr>
</tbody></table>
<p>表 2-6</p>
<h2 id="2-3-编译内核源码"><a href="#2-3-编译内核源码" class="headerlink" title="2.3 编译内核源码"></a>2.3 编译内核源码</h2><p>本小节使用的内核源码是半导体厂家提供的内核源码，是我们学习和开发要使用的内核源码。在进行驱动学习之前需要将此内核源码编译成功。</p>
<p>内核源码存放路径为“iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\02_Linux_SDK源码”，将对应目录下的内核源码拷贝到虚拟机ubuntu目录下，如下图（图2-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115736.jpeg" alt="img"></p>
<p>图 2-7</p>
<p>注：编译环境使用的是迅为搭建好的编译环境，迅为的环境经过测试在不进行修改的前提下，可以直接将内核源码编译通过。</p>
<p>使用以下命令对内核源码的进行解压，解压完成如下图（图2-8）所示：</p>
<p>tar -vxf linux_sdk.tar.gz</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115720.jpeg" alt="img"></p>
<p>图 2-8</p>
<p>使用“cd linux_sdk”命令进入内核源码目录，如下图（图2-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115085.jpeg" alt="img"></p>
<p>图 2-9</p>
<p>使用命令“.&#x2F;build.sh kernel”进行内核源码的编译，编译过程如下图（图2-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115089.jpeg" alt="img"></p>
<p>图 2-10</p>
<p>编译时间和电脑虚拟机配置相关，编译完成如下图（图2-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115144.jpeg" alt="img"></p>
<p>图 2-11</p>
<p>通过对内核源码官网的探索，内核源码的目录结构讲解以及内核源码的编译。我相信大家对Linux内核源码应该有了一个初步的认识了。下一章我们来学习第一个驱动helloworld。</p>
<h1 id="第3章-helloworld-驱动实验"><a href="#第3章-helloworld-驱动实验" class="headerlink" title="第3章 helloworld 驱动实验"></a>第3章 helloworld 驱动实验</h1><p>在学习C语言或者其他语言的时候，我们通常是打印一句“helloworld”来开启编程世界的大门。学习驱动程序编程亦可以如此，使用helloworld作为我们的第一个驱动程序。</p>
<p>接下来开始编写第一个驱动程序—helloworld。</p>
<h2 id="3-1-驱动编写"><a href="#3-1-驱动编写" class="headerlink" title="3.1 驱动编写"></a>3.1 驱动编写</h2><p>本小节来编写一个最简单的驱动——helloworld驱动。helloworld.c如下（图3-1）所示代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);<span class="comment">//注意：内核打印用printk而不是printf</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);    <span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(helloworld_exit);    <span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    <span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);    <span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>



<p>图 3-1</p>
<p>看似非常简单的helloworld驱动代码，却五脏俱全。一个简单的helloworld驱动包含驱动的基本框架。我们继续往下看。</p>
<h2 id="3-2-驱动的基本框架"><a href="#3-2-驱动的基本框架" class="headerlink" title="3.2 驱动的基本框架"></a>3.2 驱动的基本框架</h2><p>Linux驱动的基本框架主要由模块加载函数，模块卸载函数，模块许可证声明，模块参数，模块导出符号，模块作者信息等几部分组成，其中模块参数，模块导出符号，模块作者信息是可选的部分，也就是可要可不要。剩余部分是必须有的。我们来看一下这几个部分的作用：</p>
<p>1 模块加载函数</p>
<p>当使用加载驱动模块时，内核会执行模块加载函数，完成模块加载函数中的初始化工作。</p>
<p>2 模块卸载函数</p>
<p>当卸载某模块时，内核会执行模块卸载函数，完成模块卸载函数中的退出工作。</p>
<p>3 模块许可证声明</p>
<p>许可证声明描述了内核模块的许可权限，如果不声明模块许可，模块在加载的时候，会收到“内核被污染（kernel tainted）”的警告。可接受的内核模块声明许可包括“GPL”“GPL v2”。</p>
<p>4 模块参数（可选择）</p>
<p>模块参数是模块被加载的时候可以传递给它的值。</p>
<p>5 模块导出符号（可选择）</p>
<p>内核模块可以导出的符号，如果导出，其他模块可以使用本模块中的变量或函数。</p>
<p>6 模块作者信息等说明（可选择）</p>
<p>上一小节我们说，helloworld驱动麻雀虽小五脏俱全，我们来分析helloworld驱动。通过helloworld代码再来看驱动框架。</p>
<p>（1）模块加载函数：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">module_init(helloworld_init);    <span class="comment">//注册入口函数</span></span><br></pre></td></tr></table></figure>

<p>（2）模块卸载函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_exit(helloworld_exit);    <span class="comment">//注册出口函数</span></span><br></pre></td></tr></table></figure>

<p>（3）模块许可证声明</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    <span class="comment">//同意GPL开源协议</span></span><br></pre></td></tr></table></figure>

<p>（4）模块作者信息</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);    <span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>（5）头文件</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">//模块加载函数和卸载函数需要的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>通过上面的分析，helloworld驱动是不是包含了驱动框架的所有必要的部分呢。因此helloworld驱动我们可以看作是驱动代码的模板。任何一个驱动代码都用它作为基础来编写实现。同学们要将他记忆下来！</p>
<h1 id="第4章-内核模块实验"><a href="#第4章-内核模块实验" class="headerlink" title="第4章 内核模块实验"></a>第4章 内核模块实验</h1><p>在上一章节我们编写了最简单的helloworld驱动程序。有了驱动程序以后，要如何编译并使用驱动呢。编译驱动有俩种方法，分别是将驱动编译成内核和将驱动编译成内核模块。我们先来学习如何将驱动编译成内核模块、</p>
<h2 id="4-1-设置交叉编译器"><a href="#4-1-设置交叉编译器" class="headerlink" title="4.1 设置交叉编译器"></a>4.1 设置交叉编译器</h2><p>1 下载网盘资料下的交叉编译器，网盘路径为：“XXX”，将下载的交叉编译器拷贝到Ubuntu的&#x2F;usr&#x2F;local目录下，如下图（图4-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115189.jpeg" alt="img"></p>
<p>图 4-1</p>
<p>2 输入以下命令，解压交叉编译编译器压缩包，解压完毕会生成“gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu”文件夹，这是实验需要的交叉编译工具，如下图（图4-2）所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -vxf gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115207.jpeg" alt="img"></p>
<p>图 4-2</p>
<p>3 在终端输入“sudo vi &#x2F;etc&#x2F;profile”命令，在文件最后输入以下命令修改环境变量。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115170.jpeg" alt="img"></p>
<p>图 4-3</p>
<p>4 保存退出，在终端输入“reboot”命令重新启动Ubuntu系统，使交叉编译环境生效。Ubuntu系统重新启动之后，登录到系统后，打开终端，输入命令“aarch64-linux-gnu-gcc -v”，如果终端有如下图（图4-4）所示的打印信息，说明交叉编译环境搭建成功。如果没有出现如下图（图4-4）的打印信息，需要检查上一步骤是否设置正确。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115469.jpeg" alt="img"></p>
<p>图 4-4</p>
<h2 id="4-2-编写Makefile"><a href="#4-2-编写Makefile" class="headerlink" title="4.2 编写Makefile"></a>4.2 编写Makefile</h2><p>编译驱动程序还需要使用Makefile文件。我们为helloworld.c编写一个简单的Makefile，Makefile文件和源文件helloworld.c位于同一级目录，代码如下（图4-5）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64  </span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-  </span><br><span class="line">obj-m += helloworld.o    <span class="comment">#helloworld.c对应.o文件的名称。名称要保持一致。</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#内核源码所在虚拟机ubuntu的实际路径</span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>图 4-5</p>
<p>代码解释如下：</p>
<p>第1行设置ARCH变量为arm64</p>
<p>第2行设置交叉编译器前缀为aarch64-linux-gnu-</p>
<p>第3行obj-m +&#x3D; &lt;文件&gt;：将指定的文件（需要是以.o结尾）设为编译时以模块形式编译</p>
<p>第4行是设备树内核的源码路径，请大家根据实际内核路径进行修改。</p>
<p>第5行是获取当前目录的变量</p>
<p>第7行是编译make操作，会进入内核源码的路径，然后把当前路径下的代码编译成模块。</p>
<p>第9行是清除编译文件</p>
<p>编写完成如下图（图4-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115551.jpeg" alt="img"></p>
<p>图 4-6</p>
<h2 id="4-3-编译模块"><a href="#4-3-编译模块" class="headerlink" title="4.3 编译模块"></a>4.3 编译模块</h2><p>有了Makefile以后，输入“make”命令就可以编译helloworld驱动模块，如下图（图4-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115536.jpeg" alt="img"></p>
<p>图 4-7</p>
<p>编译完生成helloworld.ko目标文件就是我们需要的内核模块。内核模块是以ko为后缀名，如下图（图4-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115548.jpeg" alt="img"></p>
<p>图 4-8</p>
<p>输入“make clean”命令清除编译文件，如下图（图4-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115544.jpeg" alt="img"></p>
<p>图 4-9</p>
<h2 id="4-4-模块加载与卸载"><a href="#4-4-模块加载与卸载" class="headerlink" title="4.4 模块加载与卸载"></a>4.4 模块加载与卸载</h2><p>有了内核模块以后，我们要如何使用呢？编译驱动有俩种方式，那Linux驱动的运行方式也肯定有俩种。一种就是将驱动编译进内核，这样Linux系统启动后会自动运行程序。第二种就是将驱动编译成模块，在Linux系统启动以后使用“insmod”命令加载驱动模块。</p>
<p>在上个小节中编译了驱动模块helloworld.ko，在RK3568开发板上通过“insmod helloworld.ko”命令可以加载驱动，在加载驱动模块的时候会执行驱动入口的函数，也就是helloworld程序中的helloworld_init函数，所以可以看到打印出来的字符串信息“helloworld_init”。如下图（图4-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115579.jpeg" alt="img"></p>
<p>图 4-10</p>
<p>如果要卸载helloworld内核模块，可以通过“rmmod helloworld”命令来卸载驱动模块，同理在卸载驱动模块的时候会执行驱动出口的函数，所以可以看到驱动出口函数打印出来的字符串信息“helloworld_exit”，如下图（图4-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115931.jpeg" alt="img"></p>
<p>图 4-11</p>
<p>加载驱动模块也可以使用modprobe命令，它比insmod命令更强大，modprobe命令在加载驱动模块的时候，会同时加载该模块依赖的其他模块。比如helloworld.ko依赖before.ko，使用insmod加载的时候，就必须先加载before.ko，然后在加载helloworld.ko才可以加载成功从。但是使用modprobe加载的时候，他会自动分析模块的依赖关系，然后将所有的依赖的模块都加载到内核当中。比较“聪明”。</p>
<p>同样，在卸载驱动模块的时候，如果模块存在依赖关系，如果使用insmod命令，需要手动卸载依赖的内核模块，但是使用modprobe命令可以自动卸载驱动模块所依赖的其他模块。</p>
<p>所以，如果驱动模块是以“modprobe helloworld.ko”命令加载的，卸载的时候使用“modprobe -r helloworld.ko”命令卸载。</p>
<p>但是使用modprobe卸载存在一个问题，如果所依赖的模块被其他模块所使用，比如刚才例子中的before.ko还被其他的模块使用，这时候就不能使用modprobe卸载。所以还是推荐使用rmmod命令来卸载。</p>
<h2 id="4-5查看模块信息"><a href="#4-5查看模块信息" class="headerlink" title="4.5查看模块信息"></a>4.5查看模块信息</h2><p>在驱动模块加载之后，使用“modinfo helloworld.ko”命令可以获得模块的信息，包括模块作者，模块说明，模块支持的参数等等。</p>
<p>lsmod 命令可以列出已经载入Linux内核模块，在helloworld驱动加载之后，查看内核中加载的模块，如下（图4-12）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115860.jpeg" alt="img"></p>
<p>图 4-12</p>
<h1 id="第5章-驱动模块传参实验"><a href="#第5章-驱动模块传参实验" class="headerlink" title="第5章 驱动模块传参实验"></a>第5章 驱动模块传参实验</h1><p>经过前两章实验的实战操作，我们已经完成最简单的helloworld驱动实验和模块驱动实验，加载模块可以使用“insmod”函数，使用“insmod”函数进行模块加载时也能进行参数的传递。运用得当可以极大提升内核测试速度。本节就来学习一下如何进行驱动模块的传参。</p>
<h2 id="5-1-驱动模块传参简介"><a href="#5-1-驱动模块传参简介" class="headerlink" title="5.1 驱动模块传参简介"></a>5.1 驱动模块传参简介</h2><p> 驱动模块传参是一种可以随时向内核模块传递、修改参数的方法。例如可以传递串口驱动的波特率、数据位数、校验位、停止位等参数，进行功能的设置，以此节省编译模块的时间，大大提高调试速度。</p>
<p> Linux内核提供了 module_param(name, type, perm)、module_param_array(name, type, nump, perm)宏和module_param_string(name, string, len, perm)宏，分别进行基本类型、数组和字符串参数的传递。它们定义在 “内核源码&#x2F;include&#x2F;linux&#x2F;moduleparam.h”文件中(在module.h文件中已经对export.h进行引用，所以不需要单独引用moduleparam.h文件),详细定义如下（图5-1）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> module_param(name, type, perm)              \</span></span><br><span class="line"><span class="meta">    module_param_named(name, name, type, perm)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_param_array(name, type, nump, perm)      \</span></span><br><span class="line"><span class="meta">module_param_array_named(name, name, type, nump, perm)  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_param_string(name, string, len, perm)            \</span></span><br><span class="line"><span class="meta">    static const struct kparam_string __param_string_##name     \                                                                                                                                                                                           </span></span><br><span class="line">        = &#123; len, <span class="built_in">string</span> &#125;;                  \</span><br><span class="line">    __module_param_call(MODULE_PARAM_PREFIX, name,          \</span><br><span class="line">                &amp;param_ops_string,              \</span><br><span class="line">                .str = &amp;__param_string_#<span class="meta">#name, perm, -1, 0);\</span></span><br><span class="line"><span class="meta">    __MODULE_PARM_TYPE(name, <span class="string">&quot;string&quot;</span>) </span></span><br></pre></td></tr></table></figure>

<p>图5-1</p>
<p>以上宏定义中的 module_param ()函数可以用来进行基本类型参数的传递，传入的三个参数定义如下：</p>
<p>l name：模块参数的名称</p>
<p>l type： 模块参数的数据类型</p>
<p>l perm： 模块参数的访问权限</p>
<p>参数type可以取以下任意一种情况：</p>
<ul>
<li>bool <strong>:</strong> 布尔型</li>
<li>inbool <strong>:</strong> 布尔反值</li>
<li>charp**:** 字符指针（相当于char *,不超过1024字节的字符串）</li>
<li>short**:** 短整型</li>
<li>ushort <strong>:</strong> 无符号短整型</li>
<li>int <strong>:</strong> 整型</li>
<li>uint <strong>:</strong> 无符号整型</li>
<li>long <strong>:</strong> 长整型</li>
<li>ulong**:** 无符号长整型。</li>
</ul>
<p>参数perm表示该参数在sysfs文件系统中所对应的文件节点的属性，其权限定义在“内核源码&#x2F;include&#x2F;linux&#x2F;stat.h”文件中。可以用宏定义和数字法两种方式来表示。详细宏定义如下（图5-2）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRUSR 00400 <span class="comment">/*文件所有者可读*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWUSR 00200 <span class="comment">/*文件所有者可写*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXUSR 00100 <span class="comment">/*文件所有者可执行*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRGRP 00040 <span class="comment">/*与文件所有者同组的用户可读*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWGRP 00020 <span class="comment">/*与文件所有者同组的用户可写*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXGRP 00010 <span class="comment">/*与文件所有者同组的用户可执行*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IROTH 00004 <span class="comment">/*与文件所有者不同组的用户可读*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWOTH 00002 <span class="comment">/*与文件所有者不同组的用户可写*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXOTH 00001 <span class="comment">/*与文件所有者不同组的用户可可执行*/</span></span></span><br></pre></td></tr></table></figure>

<p>图5-2</p>
<p>如果要传递数组类型参数可以使用 module_param_array ()函数，相较于 module_param ()函数多了n_para参数，用来表示传递参数个数;n_para参数值会根据输入的参数个数而改变,n_para的最终值为传递的数组元素个数。</p>
<p>最后是 module_param_string(name, string, len, perm)函数，用来传递字符串类型的变量，四个参数的定义如下所示：</p>
<ul>
<li>name：外部传入的参数名，即加载模块时的传入值</li>
<li>string:内部的变量名，即程序内定义的参数名</li>
<li>len:以string命名的buffer大小(可以小于buffer的大小，但是没有意义)</li>
<li>perm:模块参数的访问权限</li>
</ul>
<p>至此，关于驱动模块传参所使用的函数就讲解完成了，在下一小节中将编写驱动模块传参函数代码。</p>
<h2 id="5-2-实验程序的编写"><a href="#5-2-实验程序的编写" class="headerlink" title="5.2 实验程序的编写"></a>5.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\02。</p>
<p>本章实验将编写Linux下的驱动传参实例代码，通过“insmod”命令进行参数的传递，并将相应的参数打印到串口终端上。</p>
<p>编写完成的parameter.c代码如下（图5-3）所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> number;<span class="comment">//定义int类型变量number</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *name;<span class="comment">//定义char类型变量name</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> para[<span class="number">8</span>];<span class="comment">//定义int类型的数组</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> str1[<span class="number">10</span>];<span class="comment">//定义char类型字符串str1</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> n_para;<span class="comment">//定义int类型的用来记录module_param_array函数传递数组元素个数的变量n_para</span></span><br><span class="line">module_param(number, <span class="type">int</span>, S_IRUGO);<span class="comment">//传递int类型的参数number，S_IRUGO表示权限为可读</span></span><br><span class="line">module_param(name, charp, S_IRUGO);<span class="comment">//传递char类型变量name</span></span><br><span class="line">module_param_array(para , <span class="type">int</span> , &amp;n_para , S_IRUGO);<span class="comment">//传递int类型的数组变量para</span></span><br><span class="line">module_param_string(str, str1 ,<span class="keyword">sizeof</span>(str1), S_IRUGO);<span class="comment">//传递字符串类型的变量str1</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">parameter_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;%d\n&quot;</span>,number);</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;%s\n&quot;</span>,name);                                                                                                                                                          </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n_para; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_EMERG <span class="string">&quot;para[%d] : %d \n&quot;</span>, i, para[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;%s\n&quot;</span>,str1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">parameter_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;parameter_exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(parameter_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(parameter_exit);<span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>); <span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>图5-3</p>
<p>以上代码将传递int类型参数number、char类型参数name、int类型的数组para和char类型字符串str1，并在驱动入口函数中，对各个参数进行打印。在下一小节会进行驱动加载测试。</p>
<h2 id="5-3-运行测试"><a href="#5-3-运行测试" class="headerlink" title="5.3 运行测试"></a>5.3 运行测试</h2><h3 id="5-3-1-编译驱动程序"><a href="#5-3-1-编译驱动程序" class="headerlink" title="5.3.1 编译驱动程序"></a>5.3.1 编译驱动程序</h3><p>在上一小节中的parameter.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图5-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += parameter.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>图5-4</p>
<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放parameter.c和Makefile文件目录下，如下图（图5-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115943.jpeg" alt="img"> </p>
<p>图5-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图5-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115870.jpeg" alt="img"> </p>
<p>图5-6</p>
<p>编译完生成 parameter.ko目标文件，如下图（图5-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115920.jpeg" alt="img"> </p>
<p>图5-7</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h3 id="5-3-2-运行测试"><a href="#5-3-2-运行测试" class="headerlink" title="5.3.2 运行测试"></a>5.3.2 运行测试</h3><p>在上一章节中已经学习了使用insmod命令加载模块，而驱动模块传参的命令格式为</p>
<p>insmod 对应的模块 参数</p>
<p>parameter.ko 驱动加载可以传递3个参数，分别为int类型的参数number，char类型的参数name和int数组类型的参数para。使用以下命令进行驱动的加载，加载完成之后的打印信息如下图（图5-8）所示：</p>
<p>insmod parameter.ko number&#x3D;100 name&#x3D;”topeet” para&#x3D;0,1,2,3,4,5,6,7 str&#x3D;”itop”</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115895.jpeg" alt="img"> </p>
<p>图5-8</p>
<p>可以看到传递的参数都分别打印了出来。最后可以输入以下命令进行驱动的卸载，如下图（图5-9）所示：</p>
<p>rmmod parameter.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115187.jpeg" alt="img"> </p>
<p>图5-9</p>
<h1 id="第6章-内核模块符号导出实验"><a href="#第6章-内核模块符号导出实验" class="headerlink" title="第6章 内核模块符号导出实验"></a>第6章 内核模块符号导出实验</h1><p>在上一小节中，给大家讲解了驱动模块传参实验，使用insmod命令加载驱动时可以进行参数的传递，但是每一个内核模块之间是相互独立的，那模块间的符号传递要怎样进行呢，让我们带着疑问来进行本章节的学习吧！</p>
<h2 id="6-1-内核模块符号导出简介"><a href="#6-1-内核模块符号导出简介" class="headerlink" title="6.1 内核模块符号导出简介"></a>6.1 内核模块符号导出简介</h2><p>驱动程序编译生成的ko文件是相互独立的，即模块之间变量或者函数在正常情况下无法进行互相访问。而一些复杂的驱动模块需要分层进行设计，这时候就需要用到内核模块符号导出。</p>
<p>内核符号导出指的是在内核模块中导出相应的函数和变量，在加载模块时被记录在公共内核符号表中，以供其他模块调用。符号导出所使用的宏为EXPORT_SYMBOL(sym)和EXPORT_SYMBOL_GPL(sym)。它们定义在 “内核源码&#x2F;include&#x2F;linux&#x2F;export.h”文件中（在module.h文件中已经对export.h进行引用，所以不需要单独引用export.h文件）,详细定义如下（图6-1）所示： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT_SYMBOL(sym)                  \</span></span><br><span class="line"><span class="meta">__EXPORT_SYMBOL(sym, <span class="string">&quot;&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT_SYMBOL_GPL(sym)                  \</span></span><br><span class="line"><span class="meta">    __EXPORT_SYMBOL(sym, <span class="string">&quot;_gpl&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<p>图6-1</p>
<p>EXPORT_SYMBOL(sym)和EXPORT_SYMBOL_GPL(sym)两个宏使用方法相同，而EXPORT_SYMBOL_GPL(sym)导出的模块只能被 GPL 许可的模块使用，所以绝大多数的情况都使用EXPORT_SYMBOL(sym)进行符号导出。sym为函数的唯一参数，表示要导出的函数或变量名称。</p>
<p>至此，关于内核模块符号导出函数就讲解完成了，在下一小节中将会编写两个驱动代码来进行内核模块符号导出实验。</p>
<h2 id="6-2-实验程序的编写"><a href="#6-2-实验程序的编写" class="headerlink" title="6.2 实验程序的编写"></a>6.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\03。</p>
<p>本章实验将编写Linux下的内核模块符号导出实例代码，总共有两个驱动程序，第一个驱动文件名为mathmodule.c，用来定义参数num和函数add(a,b)，第二个驱动文件名为hello.c,会引用mathmodule.c驱动程序中的参数num和数学函数add(a,b)，并将相应的参数值和函数返回值打印到串口终端上。</p>
<p>编写完成的mathmodule.c代码如下（图6-2）所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;<span class="comment">//定义参数num</span></span><br><span class="line">EXPORT_SYMBOL(num);<span class="comment">//导出参数num</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//定义数学函数add()，用来实现加法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(add);<span class="comment">//导出数学函数add()</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">math_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;math_moudle init\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">math_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;math_module exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(math_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(math_exit);<span class="comment">//注册出口函数</span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);<span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>图6-2</p>
<p>以上代码定义了一个int类型的num变量和add()数学函数，并使用EXPORT_SYMBOL宏进行导出。</p>
<p>编写完成的hello.c代码如下（图6-3）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> num;<span class="comment">//导入int类型变量num</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;<span class="comment">//导入函数add</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> sum;</span><br><span class="line">    printk(<span class="string">&quot;num = %d\n&quot;</span>, num);<span class="comment">//打印num值</span></span><br><span class="line">    sum = add(<span class="number">3</span>, <span class="number">4</span>);<span class="comment">//使用add函数进行3+4的运算                                                                                                                                                                          </span></span><br><span class="line">    printk(<span class="string">&quot;sum = %d\n&quot;</span>, sum);<span class="comment">//打印add函数的运算值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;Goodbye hello module\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(hello_exit);<span class="comment">//注册出口函数</span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);<span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>图6-3</p>
<p>程序导入了int类型的变量num和add()函数，并在驱动入口函数中打印相应了num的参数值并对add()函数进行了调用。</p>
<p>至此两个驱动代码就编写完成了，代码较为简单，实现了内核模块符号的导出和导出符号的使用，具体的驱动加载运行测试会在下个小节进行。</p>
<h2 id="6-3-运行测试"><a href="#6-3-运行测试" class="headerlink" title="6.3 运行测试"></a>6.3 运行测试</h2><h3 id="6-3-1-编译驱动程序"><a href="#6-3-1-编译驱动程序" class="headerlink" title="6.3.1 编译驱动程序"></a>6.3.1 编译驱动程序</h3><p>在mathmodule.c和hello.c的同一目录下创建Makefile文件，Makefile文件内容如下（图6-4）所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m := mathmodule.o</span><br><span class="line">obj-m += hello.o</span><br><span class="line"></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    #make操作</span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    #make clean操作</span><br></pre></td></tr></table></figure>

<p>图6-4</p>
<p>对于Makefile的内容注释已在上图进行添加，这里要注意的是在hello.c代码中使用了mathmodule.c所导出的符号，所以mathmodule.c要在hello.c之前进行编译，即第3行和第4行顺序不能交换。保存退出之后，来到相应的文件目录下，如下图（图6-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115183.jpeg" alt="img"> </p>
<p>图6-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图6-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115229.jpeg" alt="img"> </p>
<p>图6-6</p>
<p>编译完后会生成hello.ko和mathmodule.ko目标文件，如下图（图6-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115254.jpeg" alt="img"> </p>
<p>图6-7</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的加载运行测试。</p>
<h3 id="6-3-2-运行测试"><a href="#6-3-2-运行测试" class="headerlink" title="6.3.2 运行测试"></a>6.3.2 运行测试</h3><p>这里要注意的是，由于 hello.ko依赖于mathmodule.ko，所以mathmodule.ko需要先加载，分别使用以下命令进行模块的加载（加载顺序不能变），如下（图6-8）所示：</p>
<p>insmod mathmodule.ko</p>
<p>insmod  hello.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115250.jpeg" alt="img"> </p>
<p>图6-8</p>
<p>可以看到 hello.ko驱动加载的时候，mathmodule.ko模块中定义的num参数值和调用sum()函数的后正确的返回值都被打印了出来。至此内核模块符号导出实验就完成了。</p>
<p>最后可以输入以下命令进行驱动的卸载，如下图（图6-9）所示：</p>
<p>rmmod  hello.ko</p>
<p>rmmod mathmodule.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309042115362.jpeg" alt="img"> </p>
<p>图6-9</p>
<p>注意：由于hello.ko文件使用了mathmodule.ko导出的符号，所以要先卸载hello.ko，卸载完成之后再卸载mathmodule.ko。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A9%B1%E5%8A%A8%E5%9F%BA%E7%A1%80/" rel="tag">驱动基础</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-rk3568-驱动开发第七篇-设备树"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%83%E7%AF%87-%E8%AE%BE%E5%A4%87%E6%A0%91/"
    >rk3568 驱动开发第七篇 设备树</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%83%E7%AF%87-%E8%AE%BE%E5%A4%87%E6%A0%91/" class="article-date">
  <time datetime="2023-09-04T12:56:21.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第55章-初识设备树"><a href="#第55章-初识设备树" class="headerlink" title="第55章 初识设备树"></a>第55章 初识设备树</h1><h2 id="55-1-设备树的由来"><a href="#55-1-设备树的由来" class="headerlink" title="55.1 设备树的由来"></a>55.1 设备树的由来</h2><p>设备树（Device Tree）是一种硬件描述机制，用于在嵌入式系统和操作系统中描述硬件设备的特性、连接关系和配置信息。它提供了一种与平台无关的方式来描述硬件，使得内核与硬件之间的耦合度降低，提高了系统的可移植性和可维护性。</p>
<p>在上一篇平台总线内容的学习中，我们使用platform_device结构体来对硬件设备进行描述，这是一种传统的平台总线设备描述方式。每个platform_device结构表示一个特定的硬件设备，并通过注册到平台总线上来使得内核能够与该设备进行通信和交互。该结构包含设备的名称、资源（如内存地址、中断号等）、设备驱动程序等信息。</p>
<p>然而，随着时间的推移，Linux内核中的ARM部分存在着大量的平台相关配置代码，这些代码通常是杂乱而重复的，导致了维护的困难和工作量的增加。在2011年3月17日，Linux的创始人Linus Torvalds在ARM Linux邮件列表中发表了一封帖子，他表达了对ARM架构配置方式的不满，并宣称”Gaah. Guys, this whole ARM thing is a f*cking pain in the ass”。这引起了广泛的讨论和反思。ARM社区中的开发者们开始认识到，传统的平台相关配置方式已经变得不可持续，需要一种更加先进和可扩展的方法来解决这个问题。</p>
<p>为了应对这一挑战，ARM社区开始探索新的硬件描述机制，并逐渐形成了设备树的概念。设备树提供了一种更加灵活和可移植的描述硬件的机制，将设备的描述信息转移到设备树中。设备树使用一种结构化的数据格式，通过描述设备节点、属性和连接关系等信息，使得硬件的描述与具体的平台无关，同时允许多个平台共享相同的设备树描述。</p>
<p>设备树的引入为ARM架构上的Linux内核带来了革命性的变化。它提供了一种统一的硬件描述方式，使得不同芯片和板级的支持更加简单和灵活。此外，设备树还提供了硬件配置的可视化和可读性，方便开发者理解和调试硬件。</p>
<p>随着时间的推移，设备树逐渐成为了嵌入式系统和Linux内核中描述硬件的标准方式。它不仅在ARM架构上得到了广泛应用，也被扩展到其他架构和平台上。</p>
<h2 id="55-2-设备树基础知识"><a href="#55-2-设备树基础知识" class="headerlink" title="55.2 设备树基础知识"></a>55.2 设备树基础知识</h2><p>当描述设备树（Device Tree）时，通常会涉及到以下几个关键术语：DTS、DTSI、DTB和DTC。下面来对每个术语进行介绍。</p>
<p>DTS（Device Tree Source）：DTS是设备树的源文件，采用一种类似于文本的语法来描述硬件设备的结构、属性和连接关系。DTS文件以.dts为扩展名，通常由开发人员编写。它是人类可读的形式，用于描述设备树的层次结构和属性信息。</p>
<p>DTSI（Device Tree Source Include）：DTSI文件是设备树源文件的包含文件。它扩展了DTS文件的功能，用于定义可重用的设备树片段。DTSI文件以.dtsi为扩展名，可以在多个DTS文件中包含和共享。通过使用DTSI，可以提高设备树的可重用性和可维护性（和C语言中头文件的作用相同）。</p>
<p>DTB（Device Tree Blob）：DTB是设备树的二进制表示形式。DTB文件是通过将DTS或DTSI文件编译而成的二进制文件，以.dtb为扩展名。DTB文件包含了设备树的结构、属性和连接信息，被操作系统加载和解析。在运行时，操作系统使用DTB文件来动态识别和管理硬件设备。</p>
<p>DTC（Device Tree Compiler）：DTC是设备树的编译器。它是一个命令行工具，用于将DTS和DTSI文件编译成DTB文件。DTC将文本格式的设备树源代码转换为二进制的设备树表示形式，以便操作系统能够加载和解析。DTC是设备树开发中一个重要的工具。</p>
<p>DTS、DTSI、DTB和DTC之间的关系：</p>
<p>（1）开发人员使用文本编辑器编写DTS和DTSI文件，描述硬件设备的层次结构、属性和连接关系。</p>
<p>（2）DTSI文件可以在多个DTS文件中包含和共享，以提高设备树的可重用性和可维护性。</p>
<p>（3）使用DTC编译器，开发人员将DTS和DTSI文件编译成二进制的DTB文件，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps1.jpg" alt="img"> </p>
<p>（4）操作系统在启动过程中加载和解析DTB文件，以识别和管理硬件设备。</p>
<p>设备树文件存放路径</p>
<p>ARM体系结构：</p>
<p>ARM体系结构下的设备树源文件通常存放在arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;目录中。该目录是设备树源文件的根目录。如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps2.jpg" alt="img"> </p>
<p>ARM64体系结构：</p>
<p>设备树源文件路径：ARM64体系结构下的设备树源文件通常存放在arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;目录及其子目录中。该目录也是设备树源文件的根目录，并包含了针对不同ARM64平台和设备的子目录，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps3.jpg" alt="img"> </p>
<p>子目录结构：在ARM64的子目录中，同样会按照硬件平台、设备类型或制造商进行组织和分类。这些子目录的命名可能与特定芯片厂商（如Qualcomm、NVIDIA、Samsung）有关，由于我们本手册使用的soc是瑞芯微的rk3568，所以匹配的设备树目录为arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip。每个子目录中可能包含多个设备树文件，用于描述不同的硬件配置和设备类型，这里以rockchip目录内容如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps4.jpg" alt="img"> </p>
<h2 id="55-3-设备树的编译"><a href="#55-3-设备树的编译" class="headerlink" title="55.3 设备树的编译"></a>55.3 设备树的编译</h2><p>​	设备树的编译是将设备树源文件（如上述的.dts文件）转换为二进制的设备树表示形式（.dtb文件）的过程。编译器通常被称为DTC（Device Tree Compiler）。</p>
<p>在Linux内核源码中，DTC（Device Tree Compiler）的源代码和相关工具通常存放在scripts&#x2F;dtc&#x2F;目录中，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps5.jpg" alt="img"> </p>
<p>在编译完源码之后dtc设备树编译器会默认生成，如果没有生成相应的dtc可执行文件，可以查看在内核默认配置文件种CONFIG_DTC是否使能。</p>
<p>设备树的编译：</p>
<p>在Linux环境中，可以使用以下命令将设备树源文件编译为二进制设备树文件：</p>
<p>dtc -I dts -O dtb -o output.dtb input.dts</p>
<p>其中，<code>input.dts</code>是输入的设备树源文件，<code>output.dtb</code>是编译后的二进制设备树文件。</p>
<p>编译器会验证设备树源文件的语法和语义，生成与硬件描述相对应的设备树表示形式。</p>
<p>设备树的反编译：<br>    设备树的反编译是将二进制设备树文件转换回设备树源文件的过程，以便进行查看、编辑或修改。反编译器通常也是DTC。</p>
<p>在Linux环境中，可以使用以下命令将二进制设备树文件反编译为设备树源文件：</p>
<p>dtc -I dtb -O dts -o output.dts input.dtb</p>
<p>其中，input.dtb是输入的二进制设备树文件，output.dts是反编译后的设备树源文件。</p>
<p>反编译器会将二进制设备树文件解析并还原为文本形式的设备树源文件，使其可读性更好。</p>
<p>下面来进行一下实际的设备树编译和反编译的演示，首先创建一个名为test.dts的设备树文件，文件内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">/ &#123;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建完成如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps6.jpg" alt="img"> </p>
<p>这个设备树很简单，只包含了根节点&#x2F;，而根节点中没有任何子节点或属性。这个示例并没有描述任何具体的硬件设备或连接关系，它只是一个最基本的设备树框架，在本小节只是为了测试设备树的编译和反编译。</p>
<p>然后使用以下命令进行设备树的编译，编译完成如下图所示：</p>
<p>&#x2F;home&#x2F;topeet&#x2F;Linux&#x2F;linux_sdk&#x2F;kernel&#x2F;scripts&#x2F;dtc&#x2F;dtc -I dts -O dtb -o test.dtb test.dts</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps7.jpg" alt="img"> </p>
<p>可以看到test.dtb就生成了，然后继续使用以下命令对test.dtb进行反编译，反编译完成如下图所示：</p>
<p>&#x2F;home&#x2F;topeet&#x2F;Linux&#x2F;linux_sdk&#x2F;kernel&#x2F;scripts&#x2F;dtc&#x2F;dtc -I dtb -O dts -o 1.dts test.dtb </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps8.jpg" alt="img"> </p>
<p>可以看到反编译出的1.dts跟之前的test.dts内容相同。</p>
<h1 id="第56章-设备树基本语法"><a href="#第56章-设备树基本语法" class="headerlink" title="第56章 设备树基本语法"></a><strong>第56章</strong> 设备树基本语法</h1><h2 id="56-1设备树语法讲解1"><a href="#56-1设备树语法讲解1" class="headerlink" title="56.1设备树语法讲解1"></a>56.1设备树语法讲解1</h2><h3 id="56-1-1根节点"><a href="#56-1-1根节点" class="headerlink" title="56.1.1根节点"></a>56.1.1根节点</h3><p>设备树使用一种层次结构，其中的根节点（Root Node）是整个设备树的起始点和顶层节点。根节点由一个以&#x2F;开头的标识符来表示，然后使用{}来包含根节点所在的内容，一个最简单的根节点示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;  <span class="comment">// 设备树版本信息</span></span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    <span class="comment">// 根节点开始</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在这里可以添加注释，描述根节点的属性和配置</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中第一行的设备树中的版本信息行 dts-v1 是可选的，可以根据需要选择是否保留。这行注释通常用于指定设备树的语法版本。如果您不需要在设备树中指定版本信息，可以将其删除。</p>
<h3 id="56-1-2子节点"><a href="#56-1-2子节点" class="headerlink" title="56.1.2子节点"></a>56.1.2子节点</h3><p>设备树中的子节点是根节点的直接子项，用于描述具体的硬件设备或设备集合。子节点采用以下特定的格式来表示，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[label:] node-name@[unit-address] &#123;</span><br><span class="line">	[properties definitions]</span><br><span class="line">	[child nodes]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下是对这些部分的详细介绍：</p>
<p>（1）节点标签（Label）（可选）：节点标签是一个可选的标识符，用于在设备树中引用该节点。标签允许其他节点直接引用此节点，以便在设备树中建立引用关系。</p>
<p>（2）节点名称（Node Name）：节点名称是一个字符串，用于唯一标识该节点在设备树中的位置。节点名称通常是硬件设备的名称，但必须在设备树中是唯一的。</p>
<p>（3）单元地址（Unit Address）（可选）：单元地址用于标识设备的实例。它可以是一个整数、一个十六进制值或一个字符串，具体取决于设备的要求。单元地址的目的是区分相同类型的设备的不同实例，例如在下图中名为 cpu 的节点通过它们的单元地址值 0 和 1 来区分，名称为 ethernet 的节点通过其单元地址值 fe002000 和 fe003000 来区分。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps9.jpg" alt="img"> </p>
<p>（4）属性定义（Properties Definitions）：属性定义是一组键值对，用于描述设备的配置和特性。属性可以根据设备的需求进行定义，例如寄存器地址、中断号、时钟频率等，关于这些属性会在后面的小节中进行讲解</p>
<p>（5）子节点（Child Nodes）：子节点是当前节点的子项，用于进一步描述硬件设备的子组件或配置。子节点可以包含自己的属性定义和更深层次的子节点，形成设备树的层次结构。</p>
<h3 id="56-1-3-reg属性"><a href="#56-1-3-reg属性" class="headerlink" title="56.1.3 reg属性"></a>56.1.3 reg属性</h3><p>reg 属性用于在设备树中指定设备的寄存器地址和大小，提供了与设备树中的物理设备之间的寄存器映射关系。</p>
<p>reg 属性可以在设备节点中有单个值格式和列表值格式这两种常见格式，接下来将对这两种格式进行介绍：</p>
<p>（1）单个值格式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg = &lt;address size&gt;;</span><br></pre></td></tr></table></figure>

<p>这种格式适用于描述单个寄存器的情况。其中，address 是设备的起始寄存器地址，可以是一个整数或十六进制值。size 表示寄存器的大小，即占用的字节数。</p>
<p>例如，假设有一个设备节点 my_device，使用单个值格式的 reg 属性来描述一个 4 字节寄存器的地址和大小，可以这样定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;vendor,device&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x1000</span> <span class="number">0x4</span>&gt;;</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>my_device</code> 设备节点的 <code>reg</code> 属性值为 <code>&lt;0x1000 0x4&gt;</code>，表示从地址 <code>0x1000</code> 开始的 4 字节寄存器区域。</p>
<p>（2）列表值格式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg = &lt;address1 size1 address2 size2 ...&gt;;</span><br></pre></td></tr></table></figure>

<p>当设备具有多个寄存器区域时，可以使用列表值格式的 reg 属性来描述每个寄存器区域的地址和大小。通过这种方式，可以指定多个寄存器的位置和大小，以描述设备的完整寄存器映射。</p>
<p>例如，考虑一个设备节点 my_device，它具有两个寄存器区域，分别是 8 字节和 4 字节大小的寄存器。可以使用列表值格式的 reg 属性来描述这种情况：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;vendor,device&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x1000</span> <span class="number">0x8</span> <span class="number">0x2000</span> <span class="number">0x4</span>&gt;;</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，my_device 设备节点的 reg 属性值为 &lt;0x1000 0x8 0x2000 0x4&gt;，表示设备有两个寄存器区域。第一个寄存器区域从地址 0x1000 开始，大小为 8 字节；第二个寄存器区域从地址 0x2000 开始，大小为 4 字节。</p>
<p>通过使用 reg 属性，设备树可以提供有关设备寄存器布局和寄存器访问方式的信息。这对于操作系统的设备驱动程序很重要，因为它们需要了解设备的寄存器映射以正确地与设备进行交互和配置。</p>
<h3 id="56-1-4-address-cell和size-cells属性"><a href="#56-1-4-address-cell和size-cells属性" class="headerlink" title="56.1.4 address-cell和size-cells属性"></a>56.1.4 address-cell和size-cells属性</h3><p>#address-cells 和 #size-cells 属性用于指定在上个小节中要设置的设备树中地址单元和大小单元的位数。它们提供了设备树解析软件所需的元数据，以正确解释设备的地址和大小信息。下面对两个属性分别进行介绍：</p>
<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em><em><strong>*#address-cells*</strong></em><em><strong>*2*</strong></em> <em><strong>*属性：*</strong></em></p>
<p>#address-cells 属性是一个位于设备树根节点的特殊属性，它指定了设备树中地址单元的位数。地址单元是设备树中用于表示设备地址的单个单位。它通常是一个整数，可以是十进制或十六进制值。</p>
<p>#address-cells 属性的值告诉解析设备树的软件在解释设备地址时应该使用多少位来表示一个地址单元。</p>
<p>默认情况下，#address-cells 的值为 2，表示使用两个单元来表示一个设备地址。这意味着设备的地址将由两个整数（每个整数使用指定位数的位）组成。</p>
<p>例如，对于一个使用两个 32 位（4字节）整数表示地址的设备，可以在设备树的根节点中设置 #address-cells 属性为 &lt;2&gt;。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em><em><strong>*#size-cells 属性：*</strong></em></p>
<p>#size-cells 属性也是一个位于设备树根节点的特殊属性，它指定了设备树中大小单元的位数。大小单元是设备树中用于表示设备大小的单个单位。它通常是一个整数，可以是十进制或十六进制值。</p>
<p>#size-cells 属性的值告诉解析设备树的软件在解释设备大小时应该使用多少位来表示一个大小单元。</p>
<p>默认情况下，#size-cells 的值为 1，表示使用一个单元来表示一个设备的大小。这意味着设备的大小将由一个整数（使用指定位数的位）表示。</p>
<p>例如，对于一个使用一个 32 位（4 字节）整数表示大小的设备，可以在设备树的根节点中设置 #size-cells 属性为 &lt;1&gt;。</p>
<p>这两个属性的存在是为了使设备树能够灵活地描述各种设备的地址和大小表示方式。通过在设备树的根节点中设置适当的 #address-cells 和 #size-cells 值，设备树解析软件能够正确地解释设备节点中的地址和大小信息。</p>
<p>以下是两个个示例，展示了根节点中 #address-cells 和 #size-cells 属性的使用：</p>
<p><em><strong>*示例1：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">node1 &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    node1-child &#123;</span><br><span class="line">        reg = &lt;<span class="number">0x02200000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">        <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，node1-child 节点的 reg 属性使用了 &lt;0x02200000 0x4000&gt; 表示地址和大小。由于 #address-cells 的值为 &lt;1&gt;，表示使用一个单元来表示地址。#size-cells 的值也为 &lt;1&gt;，表示使用一个单元来表示大小。</p>
<p>解释后的地址和大小值如下：</p>
<p>地址部分：0x02200000 被解释为一个地址单元，地址为 0x02200000。</p>
<p>大小部分：0x4000 被解释为一个大小单元，大小为 0x4000。</p>
<p><em><strong>*示例2：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">node1 &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">    node1-child &#123;</span><br><span class="line">        reg = &lt;<span class="number">0x0000</span> <span class="number">0x0001</span>&gt;;</span><br><span class="line">        <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，node1-child 节点的 reg 属性使用了 &lt;0x0000 0x0001&gt; 表示地址。由于 #address-cells 的值为 &lt;2&gt;，表示使用两个单元来表示地址。#size-cells 的值为 &lt;0&gt;，表示不使用单元来表示大小。</p>
<p>解释后的地址值如下：</p>
<p>地址部分：0x0000 0x0001 被解释为两个地址单元，其中第一个地址单元为 0x0000，第二个地址单元为 0x0001。</p>
<p>这种使用 #address-cells 和 #size-cells 属性的方式使得设备树可以适应不同设备的寄存器映射和大小表示方式，并确保设备树解析软件能够正确解释设备的地址和大小信息。</p>
<h3 id="56-1-5-model属性"><a href="#56-1-5-model属性" class="headerlink" title="56.1.5 model属性"></a>56.1.5 model属性</h3><p>在设备树中，model 属性用于描述设备的型号或者名称。它通常作为设备节点的一个属性，用来提供关于设备的标识信息。model 属性是可选的，但在实际应用中经常被使用。</p>
<p>model 属性的值是一个字符串，可以是设备的型号、名称、或者其他标识符，用来识别设备。该值通常由设备的厂商定义，并且在设备树中使用。</p>
<p>以下是一个示例，展示了如何在设备树中使用 model 属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;vendor,device&quot;</span>;</span><br><span class="line">    model = <span class="string">&quot;My Device XYZ&quot;</span>;</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，my_device 节点具有 model 属性，其值为 “My Device XYZ”。这个值描述了设备的型号或名称为 “My Device XYZ”。</p>
<p>model 属性通常用于标识和区分不同的设备，特别是当设备节点的 compatible 属性相同或相似时。通过使用不同的 model 属性值，可以更加准确地确定所使用的设备类型。</p>
<h3 id="56-1-6-status属性"><a href="#56-1-6-status属性" class="headerlink" title="56.1.6 status属性"></a>56.1.6 status属性</h3><p>在设备树中，status 属性用于描述设备或节点的状态。它是设备树中常见的属性之一，用于表示设备或节点的可用性或操作状态。</p>
<p>status 属性的值可以是以下几种：</p>
<p>“okay”：表示设备或节点正常工作，可用。</p>
<p>“disabled”：表示设备或节点被禁用，不可用。</p>
<p>“reserved”：表示设备或节点已被保留，暂时不可用。</p>
<p>“fail”：表示设备或节点初始化或操作失败，不可用。</p>
<p>以下是一个示例，展示了如何在设备树中使用 status 属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;vendor,device&quot;</span>;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，my_device 节点具有 status 属性，其值为 “okay”。这表示设备处于正常工作状态，可用。</p>
<p>通过使用 status 属性，设备树可以动态地控制设备的启用和禁用状态。这对于在系统启动过程中选择性地启用或禁用设备，或者在运行时根据特定条件调整设备状态非常有用。</p>
<h3 id="56-1-7-compatible属性"><a href="#56-1-7-compatible属性" class="headerlink" title="56.1.7 compatible属性"></a>56.1.7 compatible属性</h3><p>在设备树中，compatible 属性用于描述设备的兼容性信息。它是设备树中重要的属性之一，用于识别设备节点与驱动程序之间的匹配关系。</p>
<p>compatible 属性的值是一个字符串或字符串列表，用于指定设备节点与相应的驱动程序或设备描述符兼容的规则。通常，compatible 属性的值由设备的厂商定义，并且在设备树中使用。</p>
<p>以下是一些常见的 compatible 属性值的示例：</p>
<p>（1）单个字符串值：例如 “vendor,device”，用于指定设备节点与特定厂商的特定设备兼容。</p>
<p>（2）字符串列表：例如 [“vendor,device1”, “vendor,device2”]，用于指定设备节点与多个设备兼容，通常用于设备节点具有多种变体或配置。</p>
<p>（3）通配符匹配：例如 “vendor,*”，用于指定设备节点与特定厂商的所有设备兼容，不考虑具体的设备标识。</p>
<p>以下是一个示例，展示了如何在设备树中使用 compatible 属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;vendor,device&quot;</span>;</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，my_device 节点具有 compatible 属性，其值为 “vendor,device”。这个值用于标识设备节点与特定厂商的特定设备兼容。</p>
<p>compatible 属性也可以具有多个匹配值，用于指定设备节点与多个设备或驱动程序的兼容性规则。这种情况下，compatible 属性的值是一个字符串列表，每个字符串表示一个匹配值。</p>
<p>以下是一个示例，展示了具有多个匹配值的 compatible 属性的用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = [<span class="string">&quot;vendor,device1&quot;</span>, <span class="string">&quot;vendor,device2&quot;</span>];</span><br><span class="line">    <span class="comment">// 其他属性和子节点的定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，my_device 节点具有 compatible 属性，其值为 [“vendor,device1”, “vendor,device2”]。这表示设备节点与厂商的 device1 和 device2 兼容。</p>
<p>通过使用 compatible 属性，设备树可以提供设备和驱动程序之间的匹配信息。当设备树被操作系统或设备管理软件解析时，会根据设备节点的 compatible 属性值来选择适合的驱动程序进行设备的初始化和配置。</p>
<h2 id="56-2设备树语法讲解2"><a href="#56-2设备树语法讲解2" class="headerlink" title="56.2设备树语法讲解2"></a>56.2设备树语法讲解2</h2><h3 id="56-2-1-aliases节点"><a href="#56-2-1-aliases节点" class="headerlink" title="56.2.1 aliases节点"></a>56.2.1 aliases节点</h3><p> aliases 节点是一个特殊的节点，用于定义设备别名。该节点位于设备树的根部，并具有节点路径 &#x2F;aliases。</p>
<p>aliases 节点是一个容器节点，包含一组属性，每个属性都代表一个设备别名。每个属性的名称是别名的标识符，而属性的值是被引用设备节点的路径或设备树中其他节点的路径。</p>
<p>以下是一个示例，演示了如何在设备树中使用 aliases 节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line">    mmc0 = &amp;sdmmc0;</span><br><span class="line">    mmc1 = &amp;sdmmc1;</span><br><span class="line">    mmc2 = &amp;sdhci;</span><br><span class="line">    serial0 = <span class="string">&quot;/simple@fe000000/seria1@11c500&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在给定的例子中，有四个别名的定义：</p>
<p>（1）mmc0 别名与设备树中的 sdmmc0 节点相关联。通过使用别名 mmc0，其他设备节点或客户端程序可以更方便地引用 sdmmc0 节点，而不必直接使用其完整路径。</p>
<p>（2）mmc1 别名与设备树中的 sdmmc1 节点相关联。通过使用别名 mmc1，其他设备节点或客户端程序可以更方便地引用 sdmmc1 节点，而不必直接使用其完整路径。</p>
<p>（3）mmc2 别名与设备树中的 sdhci 节点相关联。通过使用别名 mmc2，其他设备节点或客户端程序可以更方便地引用 sdhci 节点，而不必直接使用其完整路径。</p>
<p>（4）serial0 别名与设备树中的路径 &#x2F;simple@fe000000&#x2F;seria1@11c500 相关联。通过使用别名 serial0，其他设备节点或客户端程序可以更方便地引用该路径，而不必记住整个路径字符串。</p>
<p>在别名的定义中，&amp; 符号用于引用设备树中的节点。别名的目的是提供可读性更高的名称，使设备树更易于理解和维护。通过使用别名，可以简化设备节点之间的关联，并减少重复输入设备节点的路径。</p>
<p>客户端程序可以使用别名属性名称来引用完整的设备路径或部分路径。当客户端程序将别名字符串视为设备路径时，应检测并使用别名。这样，设备树的使用者可以更方便地引用设备节点，而不必记住复杂的路径结构。</p>
<p>需要注意的是，aliases 节点中定义的别名只在设备树内部可见，不能在设备树之外引用。它们主要用于设备树的内部组织和引用，以提高可读性和可维护性。</p>
<h3 id="56-2-2-chosen节点"><a href="#56-2-2-chosen节点" class="headerlink" title="56.2.2 chosen节点"></a>56.2.2 chosen节点</h3><p>chosen节点是设备树中的一个特殊节点，用于传递和存储系统引导和配置的相关信息。它位于设备树的根部，并具有路径&#x2F;chosen。</p>
<p>chosen节点通常包含以下子节点和属性：</p>
<p>（1）bootargs：这是一个属性，用于存储引导内核时传递的命令行参数。它可以包含诸如内核参数、设备树参数等信息。在引导过程中，操作系统或引导加载程序可以读取该属性来获取启动参数。</p>
<p>（2）stdout-path：这是一个属性，用于指定用于标准输出的设备路径。在引导过程中，操作系统可以使用该属性来确定将控制台输出发送到哪个设备，例如串口或显示屏。</p>
<p>（3）firmware-name：这是一个属性，用于指定系统固件的名称。它可以用于标识所使用的引导加载程序或固件的类型和版本。</p>
<p>（4）linux,initrd-start和linux,initrd-end：这些属性用于指定Linux内核初始化RAM磁盘（initrd）的起始地址和结束地址。这些信息在引导过程中被引导加载程序使用，以将initrd加载到内存中供内核使用。</p>
<p>（5）其他自定义属性：chosen节点还可以包含其他自定义属性，用于存储特定于系统引导和配置的信息。这些属性的具体含义和用法取决于设备树的使用和上下文。</p>
<p>关于chosen节点的实际例子如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chosen &#123;</span><br><span class="line">    bootargs = <span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0,115200&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，chosen 节点具有一个属性 bootargs，其值为”root&#x3D;&#x2F;dev&#x2F;nfs rw nfsroot&#x3D;192.168.1.1 console&#x3D;ttyS0,115200”。</p>
<p>通过这些命令行参数，操作系统或引导加载程序可以配置内核在引导过程中正确地加载 NFS 根文件系统，并将控制台输出发送到指定的串口设备。</p>
<p>通过使用chosen节点，系统引导过程中的相关信息可以方便地传递给操作系统或引导加载程序。这样，系统引导和配置的各个组件可以共享和访问这些信息，从而实现更灵活和可配置的系统引导流程。chosen节点提供了一种通用的机制，使得不同的设备树和引导系统可以在传递信息方面保持一致性，并且可以根据具体需求扩展和自定义。</p>
<h3 id="56-2-3-device-type节点"><a href="#56-2-3-device-type节点" class="headerlink" title="56.2.3 device_type节点"></a>56.2.3 device_type节点</h3><p>在设备树中，device_type 节点是用于描述设备类型的节点。它通常作为设备节点的一个属性存在。device_type 属性的值是一个字符串，用于标识设备的类型。</p>
<p>device_type 节点的存在有助于操作系统或其他软件识别和处理设备。它提供了设备的基本分类信息，使得驱动程序、设备树解析器或其他系统组件能够根据设备的类型执行相应的操作。</p>
<p>常见的设备类型包括但不限于：</p>
<p>（1）cpu：表示中央处理器。</p>
<p>（2）memory：表示内存设备。</p>
<p>（3）display：表示显示设备，如液晶显示屏。</p>
<p>（4）serial：表示串行通信设备，如串口。</p>
<p>（5）ethernet：表示以太网设备。</p>
<p>（6）usb：表示通用串行总线设备。</p>
<p>（7）i2c：表示使用 I2C (Inter-Integrated Circuit) 总线通信的设备。</p>
<p>（8）spi：表示使用 SPI (Serial Peripheral Interface) 总线通信的设备。</p>
<p>（9）gpio：表示通用输入&#x2F;输出设备。</p>
<p>（10）pwm：表示脉宽调制设备。</p>
<p>这些只是一些常见的设备类型示例，实际上，设备类型可以根据具体的硬件和设备树的使用情况进行自定义和扩展。根据设备类型，操作系统或其他软件可以加载适当的驱动程序、配置设备资源、建立设备之间的连接等。</p>
<h3 id="56-2-4-自定义属性"><a href="#56-2-4-自定义属性" class="headerlink" title="56.2.4 自定义属性"></a>56.2.4 自定义属性</h3><p>设备树中的自定义属性是用户根据特定需求添加的属性。这些属性可以用于提供额外的信息、配置参数或元数据，以满足设备或系统的特定要求。</p>
<p>在设备树中添加自定义属性时，可以在设备节点或其他适当的节点下定义新的属性。自定义属性可以是整数、字符串、布尔值或其他数据类型。它们的命名应遵循设备树的命名约定，并且应该与已有的属性名称避免冲突。</p>
<p>例如可以在设备树中自定义一个管脚标号的属性pinnum，添加好的设备树源码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;my_device&quot;</span>;</span><br><span class="line">    pinnum = &lt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，my_device 是一个自定义设备节点，并添加了一个自定义属性 pinnum。该属性的值 &lt;0 1 2 3 4&gt; 是一个整数数组，表示管脚的标号（PIN number）。</p>
<p>通过这样定义 pinnum 属性，您可以在设备树中为特定设备指定管教标号，以便操作系统、驱动程序或其他软件组件使用。这可以用于在设备初始化或配置过程中对特定管教进行操作或控制。</p>
<h1 id="第57章-实例分析：中断"><a href="#第57章-实例分析：中断" class="headerlink" title="第57章 实例分析：中断"></a><strong>第57章</strong> 实例分析：中断</h1><h2 id="57-1-中断相关属性"><a href="#57-1-中断相关属性" class="headerlink" title="57.1 中断相关属性"></a>57.1 中断相关属性</h2><h3 id="57-1-1-RK-ft5x06设备树节点"><a href="#57-1-1-RK-ft5x06设备树节点" class="headerlink" title="57.1.1 RK ft5x06设备树节点"></a>57.1.1 RK ft5x06设备树节点</h3><p>下面展示的是iTOP-RK3568开发板SDK源码中的ft5x06设备树，其中蓝色字体部分就是关于中断相关的描述，包括了interrupts、 interrupt-controller、#interrupt-cells、interrupt-parent四种常见属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">gpio0: gpio@fdd60000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;rockchip,gpio-bank&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0</span> <span class="number">0xfdd60000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">33</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    clocks = &lt;&amp;pmucru PCLK_GPI00&gt;, &lt;&amp;pmucru DBCLK_GPI00&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    gpio-ranges = &lt;&amp;pinctrl <span class="number">0</span> <span class="number">0</span> <span class="number">32</span>&gt;;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06@<span class="number">38</span> &#123; </span><br><span class="line">    status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    compatible = <span class="string">&quot;edt,edt-ft5306&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">    touch-gpio = &lt;&amp;gpio0 RK_PB5 IRQ_TYPE_EDGE_RISING&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio0&gt;;</span><br><span class="line">    interrupts = &lt;RK_PB5 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">    reset-gpios = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    touchscreen-size-x = &lt;<span class="number">800</span>&gt;;</span><br><span class="line">    touchscreen-size-y = &lt;<span class="number">1280</span>&gt;;</span><br><span class="line">    touch_type = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中gpio0节点是在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568.dtsi”设备树的3549-3560行定义的，而ft5x06: ft5x06@38触摸芯片节点是在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;topeet_rk3568_lcds.dtsi”设备树的301-313行定义的。接下来将会对设备树常见的四个中断属性进行介绍。</p>
<h3 id="57-1-2-interrupts"><a href="#57-1-2-interrupts" class="headerlink" title="57.1.2 interrupts"></a>57.1.2 interrupts</h3><p>interrupts 属性用于指定设备的中断相关信息。它描述了中断控制器的类型、中断号以及中断触发类型。下面将对interrupts 属性的各个方面进行介绍。</p>
<p>在第一小节中列举的设备树源码中的gpio0节点和ft5x06节点都涉及到了interrupts 属性，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gpio0: gpio@fdd60000 &#123;</span><br><span class="line">    ....</span><br><span class="line">interrupts = &lt;GIC_SPI <span class="number">33</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06@<span class="number">38</span> &#123; </span><br><span class="line">    ....</span><br><span class="line">interrupts = &lt;RK_PB5 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>gpio0节点的interrupts具有三个参数，分别表示中断控制器类型、中断号和中断触发类型，每个参数的具体描述如下所示：</p>
<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em><em><strong>*中断控制器类型：*</strong></em></p>
<p>interrupts 属性的第一个参数指定了中断控制器的类型。常见的类型包括 GIC (Generic Interrupt Controller)、IRQ (Basic Interrupt Handling) 等。例如，在给定的代码片段中，GIC_SPI 表示中断控制器的类型为 GIC SPI 中断。</p>
<p>中断控制器负责管理系统中的中断信号，它可以是硬件中的专用中断控制器，也可以是处理器内部的中断控制器。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em><em><strong>*中断号：*</strong></em></p>
<p>interrupts 属性的第二个参数指定了设备所使用的中断号。中断号是一个唯一标识符，用于区分不同的中断信号源。系统使用中断号来识别中断源并进行相应的中断处理。</p>
<p>中断号可以是一个整数值，也可以是一个宏定义或符号引用。在给定的代码片段中，33 表示该设备使用中断号为 33。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em><em><strong>*中断触发类型：*</strong></em></p>
<p>interrupts 属性的第三个参数指定了中断的触发类型，即中断信号的触发条件。常见的触发类型包括边沿触发和电平触发。</p>
<p>边沿触发表示中断信号在从低电平到高电平或从高电平到低电平的变化时触发。触发类型可以是上升沿触发、下降沿触发或双边沿触发。电平触发表示中断信号在保持特定电平状态时触发，可以是高电平触发或低电平触发。</p>
<p>在给定的代码片段中，IRQ_TYPE_LEVEL_HIGH 表示中断的触发类型为高电平触发。触发类型的宏定义在内核源码“include&#x2F;dt-bindings&#x2F;interrupt-controller&#x2F;irq.h”目录下，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_NONE           0   <span class="comment">// 无中断触发类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_RISING    1   <span class="comment">// 上升沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_FALLING   2   <span class="comment">// 下降沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_BOTH    (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING)<span class="comment">// 双边沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_LEVEL_HIGH     4   <span class="comment">// 高电平触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_LEVEL_LOW      8   <span class="comment">// 低电平触发</span></span></span><br></pre></td></tr></table></figure>

<p>而在ft5x06节点中只有中断号和中断触发类型两个参数，这是为什么呢，带着疑问我们继续学习下面的几个属性。</p>
<h3 id="57-1-3-interrupt-controller"><a href="#57-1-3-interrupt-controller" class="headerlink" title="57.1.3 interrupt-controller"></a>57.1.3 interrupt-controller</h3><p>interrupt-controller 属性是设备树中用于描述中断控制器的属性之一。它提供了关于中断控制器的相关信息，以便操作系统和其他设备能够正确配置和使用中断系统。<br>    interrupt-controller 属性用于标识当前节点所描述的设备是一个中断控制器。中断控制器是硬件或软件模块，负责管理和分发中断信号。它接收来自各种设备的中断请求，并根据优先级和配置规则分发中断给相应的处理器或设备。<br>    interrupt-controller&#96;属性本身没有特定的属性值，只需出现在节点的属性列表中即可。出现该属性的存在即表示该节点描述的设备是中断控制器。</p>
<h3 id="57-1-4-interrupt-parent"><a href="#57-1-4-interrupt-parent" class="headerlink" title="57.1.4 interrupt-parent"></a>57.1.4 interrupt-parent</h3><p>interrupt-parent 属性是设备树中用于建立中断信号源与中断控制器之间关联的属性。它指定了中断信号源所属的中断控制器节点，以确保正确的中断处理和分发。<br>    interrupt-parent<code>属性用于指定中断信号源所属的中断控制器。中断信号源是产生中断的设备或其他中断源节点。通过指定中断控制器，操作系统可以正确地将中断请求传递给相应的中断控制器节点进行处理和分发。     interrupt-parent属性值是一个引用，它指向中断控制器节点的路径或标签。可以使用路径来引用中断控制器节点，如/interrupt-controller-node，或使用标签来引用中断控制器节点，如 &amp;interrupt-controller-label</code>，在第一小节例子中的 ft5x06就是通过中断控制器节点和gpio0中断控制器建立了联系，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ft5x06: ft5x06@38 &#123; </span><br><span class="line">    ....</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio0&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	中断信号源节点（例如设备节点或其他中断源节点）中的 interrupt-parent 属性用于指定中断信号源所属的中断控制器节点。这样，中断信号源就可以将中断请求传递给正确的中断控制器进行处理。中断信号源节点的 interrupts 属性中的中断号和其他相关信息将与指定的中断控制器关联起来。</p>
<p>在某些情况下，中断控制器可以形成多级结构，其中一个中断控制器节点可能是另一个中断控制器的父节点。在这种情况下，interrupt-parent 属性可以用于指定层次结构中的上级中断控制器。</p>
<h3 id="57-1-5-interrupt-cells"><a href="#57-1-5-interrupt-cells" class="headerlink" title="57.1.5 #interrupt-cells"></a>57.1.5 #interrupt-cells</h3><p>#interrupt-cells属性用于描述中断控制器中每个中断信号源的中断编号单元的数量。中断编号单元是指用于表示中断号和其他相关信息的固定大小的单元。通过指定中断编号单元的数量，操作系统可以正确解析和处理中断信息，并将其与中断控制器和中断信号源进行关联。<br>    #interrupt-cells属性的值是一个整数，表示中断编号单元的数量。通常，这个值是一个正整数，例如 1、2 或 3，取决于中断控制器和设备的要求。</p>
<p>在gpio0的中断控制器为gic，在gic节点中#interrupt-cells属性被设置为3，这也就是为什么在gpio0节点中interrupts 属性有三个值，而ft5x06的中断控制器为gpio0，在gpio0节点中#interrupt-cells属性被设置为2，所以ft5x06节点的interrupts 属性只有两个值。</p>
<h2 id="57-2-中断实例编写"><a href="#57-2-中断实例编写" class="headerlink" title="57.2 中断实例编写"></a>57.2 中断实例编写</h2><p>在上一个小节中对设备树中断要用到的属性进行了讲解，而在本小节将会编写一个在RK3568上ft5x06的中断设备树。</p>
<p>首先确定ft5x06的中断引脚号，由于iTOP-RK3568有1.2和1.7两个版本，所以这里展示两个版本的原理图：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps10.jpg" alt="img"> </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps11.jpg" alt="img"> </p>
<p>第一张图为V1.2版本的原理图，触摸引脚网络标号为TP_INT_L_GPIO0_B5，对应的CPU管脚为GPIO0_B5，第二张图为V1.7版本的原理图，触摸引脚网络标号为TP_INT_L_GPIO3_A5，对应的CPU管脚为GPIO3_A5。</p>
<p>然后来查看内核源码目录下的“drivers&#x2F;input&#x2F;touchscreen&#x2F;edt-ft5x06.c”文件，这是ft5x06的驱动文件，然后找到compatible匹配值相关的部分，如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps12.jpg" alt="img"> </p>
<p>这里的compatible匹配值都可以选择，我这里在后面编写设备树的时候会选择edt,edt-ft5206，选择其他compatible也是可以的。</p>
<p>最后在内核源码目录下的“include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h”头文件中，定义了RK引脚名和gpio编号的宏定义，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps13.jpg" alt="img"> </p>
<p>通过宏定义可以减少在编写设备树的过程中换算的时间。</p>
<p>至此，我们关于编写ft5x06设备树的前置内容就查找完成了，接下来进行设备树的编写。</p>
<p>  编写完成的设备树如下所示：<br>V1.2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/pinctrl/rockchip.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/interrupt-controller/irq.h&quot;</span></span></span><br><span class="line">/&#123;</span><br><span class="line">	model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line"></span><br><span class="line">	ft5x06@<span class="number">38</span> &#123;</span><br><span class="line">		compatible = <span class="string">&quot;edt,edt-ft5206&quot;</span>;</span><br><span class="line">		interrupt-parent = &lt;&amp;gpio0&gt;;</span><br><span class="line">		interrupts = &lt;RK_PB5 IRQ_TYPE_EDGE_RISING&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>V1.7</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/pinctrl/rockchip.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/interrupt-controller/irq.h&quot;</span></span></span><br><span class="line">/&#123;</span><br><span class="line">	model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line"></span><br><span class="line">	ft5x06@<span class="number">38</span> &#123;</span><br><span class="line">		compatible = <span class="string">&quot;edt,edt-ft5206&quot;</span>;</span><br><span class="line">		interrupt-parent = &lt;&amp;gpio3&gt;;</span><br><span class="line">		interrupts = &lt;RK_PA5 IRQ_TYPE_EDGE_RISING&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第1行: 设备树文件的头部，指定了使用的设备树语法版本。</p>
<p>第3行：用于定义 Rockchip 平台的引脚控制器相关的绑定。</p>
<p>第4行：用于定义中断控制器相关的绑定。</p>
<p>第5行：表示设备树的根节点开始。</p>
<p>第6行：指定了设备树的模型名称，描述为 “This is my devicetree!”。</p>
<p>第9行：指定了设备节点的兼容性字符串，表示该设备与 “edt,edt-ft5206” 兼容。</p>
<p>第10行：指定了中断的父节点，即中断控制器所在的节点。这里使用了一个引用（&amp;gpio0）来表示父节点。</p>
<p>第11行：指定了中断信号的配置。RK_PB5 表示中断信号的引脚编号，IRQ_TYPE_EDGE_RISING 表示中断类型为上升沿触发。</p>
<p>至此，关于ft5x06的设备树就讲解完成了。</p>
<h2 id="57-3-其他SOC设备树对比"><a href="#57-3-其他SOC设备树对比" class="headerlink" title="57.3 其他SOC设备树对比"></a>57.3 其他SOC设备树对比</h2><p>而无论使用的是瑞芯微SOC还是恩智浦、三星的SOC，在设备树关于中断相关的描述都是上面提到的四个属性，关于在恩智浦和三星源码中的ft5x06设备树如下所示：</p>
<p><em><strong>*恩智浦*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">gpio1: gpio@<span class="number">0209</span>c000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;fsl,inx6ul-gpio&quot;</span>, <span class="string">&quot;fsl,imx35-gpio&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0209c000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">66</span> IRQ_TYPE_LEVEL_HIGH&gt;, &lt;GIC_SPI <span class="number">67</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    edt-ft5x06@<span class="number">38</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;edt,edt-ft5306&quot;</span>, <span class="string">&quot;edt,edt-ft5x06&quot;</span>, <span class="string">&quot;edt,edt-ft5406&quot;</span>;</span><br><span class="line">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        pinctrl<span class="number">-0</span> = &lt;&amp;ts_int_pin &amp;ts_reset_pin&gt;;</span><br><span class="line">        reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">        interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">        interrupts = &lt;<span class="number">9</span> <span class="number">0</span>&gt;;</span><br><span class="line">        reset-gpios = &lt;&amp;gpio5 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">        irq-gpios = &lt;&amp;gpio1 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em><strong>*三星*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">gpio_c: gpioc &#123;</span><br><span class="line">    compatible = <span class="string">&quot;gpio-controller&quot;</span>;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06038 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;edt,edt-ft5406&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(RGB_1024x600) || defined(RGB_800x480)</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;tsc2007_irq&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio_c&gt;;</span><br><span class="line">    interrupts = &lt;<span class="number">26</span> IRQ_TYPE_EDGE_FALLING&gt;;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(LvDs_800×1280) || defined(LvDS_1024x768)</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;gt911_irq&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio_b&gt;;</span><br><span class="line">    interrupts = &lt;<span class="number">29</span> IRQ_TYPE_EDGE_FALLING&gt;;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    reset-gpios = &lt;&amp;gpio_e <span class="number">30</span> <span class="number">0</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对比之后会发现，不同厂商对于中断属性的配置都是类似的，只是里面的参数有些许区别，如果大家在之后遇到了其他平台，只需要稍加区分即可。</p>
<h1 id="第58章-实例分析：时钟"><a href="#第58章-实例分析：时钟" class="headerlink" title="第58章 实例分析：时钟"></a><strong>第58章</strong> 实例分析：时钟</h1><p>时钟（Clock）用于描述硬件设备和系统中的时钟源以及时钟相关的配置和连接关系。时钟在计算机系统中起着至关重要的作用，用于同步和定时各种硬件设备的操作。时钟可以分为两个主要角色：时钟生产者（clock provider）和时钟消费者（clock consumer）。</p>
<p><em><strong>*时钟生产者（Clock Provider）：*</strong></em></p>
<p>定义：时钟生产者是负责生成和提供时钟信号的硬件或软件模块。它可以是时钟控制器、PLL、时钟发生器等。</p>
<p>设备树节点：时钟生产者在设备树中以时钟节点的形式表示。</p>
<p>时钟节点属性：</p>
<p>****（1）clock-cells：****该属性用于指定时钟编号的位数。它是一个整数值，表示时钟编号的位数。通常情况下，当 clock-cells 为 0 时表示一个时钟，为 1 表示多个时钟。具体示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例<span class="number">1</span>：单个时钟</span><br><span class="line">osc24m: osc24m &#123;</span><br><span class="line">    compatible = <span class="string">&quot;clock&quot;</span>;</span><br><span class="line">    clock-frequency = &lt;<span class="number">24000000</span>&gt;;</span><br><span class="line">    clock-output-names = <span class="string">&quot;osc24m&quot;</span>;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;O&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">示例<span class="number">2</span>：多个时钟</span><br><span class="line">clock: clock &#123;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    clock-output-names = <span class="string">&quot;clock1&quot;</span>, <span class="string">&quot;clock2&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em><strong>*（2）clock-frequency*</strong></em> 属性是设备树中用于指定时钟频率的属性。它用于描述时钟节点所提供的时钟信号的频率，使用 Hertz (Hz) 作为单位。对于时钟生产者节点，clock-frequency 属性表示该节点生成的时钟信号的频率。它用于描述时钟控制器、晶振、PLL 等产生时钟信号的硬件或软件模块的输出频率，例如指定时钟频率为24000000的具体示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">osc24m: osc24m &#123;</span><br><span class="line">    compatible = <span class="string">&quot;clock&quot;</span>;</span><br><span class="line">    clock-frequency = &lt;<span class="number">24000000</span>&gt;;</span><br><span class="line">    clock-output-names = <span class="string">&quot;osc24m&quot;</span>;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;O&gt;</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em><em><strong>*assigned-clocks*</strong></em> <em><strong>*和 assigned-clock-rates*</strong></em> 是设备树中用于描述多路时钟的属性，通常一起使用。</p>
<p>assigned-clocks 属性用于标识时钟消费者节点所使用的时钟源。它是一个整数数组，每个元素对应一个时钟编号。时钟编号是指时钟生产者节点（如时钟控制器）所提供的时钟源的编号。通过在时钟消费者节点中使用 assigned-clocks 属性，可以指定该节点所需的时钟源。</p>
<p>assigned-clock-rates 属性用于指定每个时钟源的时钟频率。它是一个整数数组，每个元素对应一个时钟源的频率。时钟频率以 Hz (赫兹) 为单位表示。assigned-clock-rates 属性的元素数量和顺序应与 assigned-clocks 属性中的时钟编号相对应。</p>
<p>关于assigned-clocks 和 assigned-clock-rates 属性的一个具体示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cru: clock-controller@fdd20000 &#123;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    assigned-clocks = &lt;&amp;pmucru CLK_RTC_32K&gt;, &lt;&amp;cru ACLK_RKVDEC_PRE&gt;;</span><br><span class="line">    assigned-clock-rates = &lt;<span class="number">32768</span>&gt;, &lt;<span class="number">300000000</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em><strong>*（4）clock-indices*</strong></em>****：****clock-indices 属性用于指定时钟消费者节点所使用的时钟源的索引值。它是一个整数数组，每个元素对应一个时钟源的索引。</p>
<p>时钟索引是指时钟生产者节点（如时钟控制器）所提供的时钟源的编号。通过在时钟消费者节点中使用 clock-indices 属性，可以明确指定该节点所需的时钟源，并按照特定的顺序进行匹配。一个clock-indices示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scpi_dvfs: clocks<span class="number">-0</span> &#123;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    clock-indices = &lt;<span class="number">0</span>&gt;, &lt;<span class="number">1</span>&gt;, &lt;<span class="number">2</span>&gt;;</span><br><span class="line">    clock-output-names = <span class="string">&quot;atlclk&quot;</span>, <span class="string">&quot;aplclk&quot;</span>, <span class="string">&quot;gpuclk&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">scpi_clk: clocks<span class="number">-1</span> &#123;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    clock-indices = &lt;<span class="number">3</span>&gt;;</span><br><span class="line">    clock-output-names = <span class="string">&quot;pxlclk&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在第一个节点中”atlclk”, “aplclk”, “gpuclk”三个时钟源的索引就分别被设置为了0、1、2，在第二个节点中”pxlclk”时钟源的索引值被设置为了3.</p>
<p><em><strong>*（5）*</strong></em><em><strong>*assigned-clock-parents*</strong></em> 属性用于指定时钟消费者节点所使用的时钟源的父时钟源。它是一个时钟源引用的数组，每个元素对应一个父时钟源的引用。在时钟的层次结构中，某些时钟源可能是其他时钟源的父时钟源，即它们提供时钟信号给其他时钟源作为输入。通过在时钟消费者节点中使用 assigned-clock-parents 属性，可以明确指定该节点所需的父时钟源，并按照特定的顺序进行匹配。一个实际的 assigned-clock-parents 属性例子如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clock: clock &#123;</span><br><span class="line">    assigned-clocks = &lt;&amp;clkcon <span class="number">0</span>&gt;, &lt;&amp;pll <span class="number">2</span>&gt;;</span><br><span class="line">    assigned-clock-parents = &lt;&amp;pll <span class="number">2</span>&gt;;</span><br><span class="line">    assigned-clock-rates = &lt;<span class="number">115200</span>&gt;, &lt;<span class="number">9600</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述设备树表示了一个名为 clock 的时钟消费者节点，具有以下属性：</p>
<p>assigned-clocks 属性指定了该节点使用的时钟源，引用了两个时钟源节点：clkcon 0 和 pll 2。</p>
<p>assigned-clock-parents 属性指定了这些时钟源的父时钟源，引用了 pll 2 时钟源节点。</p>
<p>assigned-clock-rates 属性指定了每个时钟源的时钟频率，分别是 115200 和 9600。</p>
<p><em><strong>*时钟消费者（Clock Consumer）：*</strong></em></p>
<p>定义：时钟消费者是依赖时钟信号的硬件设备或模块。它们通过引用时钟生产者节点提供的时钟源来获取时钟信号。</p>
<p>设备树节点：时钟消费者在设备树中的节点中使用属性来引用时钟生产者的时钟源。</p>
<p>时钟消费者属性：</p>
<p>（1）clocks：该属性用于指定时钟消费者节点所需的时钟源。它是一个整数数组，每个元素是一个时钟编号，表示时钟消费者需要的一个时钟源。</p>
<p>（2）clock-names：可选属性，用于指定时钟消费者节点所需时钟源的名称。它是一个字符串数组，与 clocks 数组一一对应，用于提供时钟源的描述性名称。</p>
<p>一个时钟消费者示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clock: clock &#123;</span><br><span class="line">    clocks = &lt;&amp;cru CLK_VOP&gt;;</span><br><span class="line">    clock-names = <span class="string">&quot;clk_vop&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>clocks 属性指定了该节点使用的时钟源，引用了 cru 节点中的 CLK_VOP 时钟源。</p>
<p>clock-names 属性指定了时钟源的名称，这里是 “clk_vop”。</p>
<h1 id="第59章-实例分析：CPU"><a href="#第59章-实例分析：CPU" class="headerlink" title="第59章 实例分析：CPU"></a><strong>第59章</strong> 实例分析：CPU</h1><h2 id="59-1-cpus节点"><a href="#59-1-cpus节点" class="headerlink" title="59.1 cpus节点"></a>59.1 cpus节点</h2><p>设备树的 cpus 节点是用于描述系统中的处理器的一个重要节点。它是处理器拓扑结构的顶层节点，包含了所有处理器相关的信息。下面将详细介绍设备树的 cpus 节点的各个方面。</p>
<p><em><strong>*节点结构：*</strong></em><br>    cpus 节点是一个容器节点，其下包含了系统中每个处理器的子节点。每个子节点的名称通常为 cpu@X，其中 X 是处理器的索引号。每个子节点都包含了与处理器相关的属性，例如时钟频率、缓存大小等。</p>
<p><em><strong>*处理器属性：*</strong></em><br>cpu@X 子节点中的属性可以包括以下信息：</p>
<p>（1）device_type：指示设备类型为处理器（”cpu”）。</p>
<p>（2）reg：指定处理器的地址范围，通常是物理地址或寄存器地址。</p>
<p>（3）compatible：指定处理器的兼容性信息，用于匹配相应的设备驱动程序。</p>
<p>（4）clock-frequency：指定处理器的时钟频率。</p>
<p>（5）cache-size：指定处理器的缓存大小。</p>
<p><em><strong>*处理器拓扑关系：*</strong></em><br>    除了处理器的基本属性，cpus 节点还可以包含其他用于描述处理器拓扑关系的节点，以提供更详细的处理器拓扑信息。这些节点可以帮助操作系统和软件了解处理器之间的连接关系、组织结构和特性。</p>
<p>cpu-map 节点：描述处理器的映射关系，通常在多核处理器系统中使用。</p>
<p>socket 节点：描述多处理器系统中的物理插槽或芯片组。</p>
<p>cluster 节点：描述处理器集群，即将多个处理器组织在一起形成的逻辑组。</p>
<p>core 节点：描述处理器核心，即一个物理处理器内的独立执行单元。</p>
<p>thread 节点：描述处理器线程，即一个物理处理器核心内的线程。</p>
<p>这些节点的嵌套关系可以在 cpus 节点下形成一个层次结构，反映了处理器的拓扑结构。上述这些节点会在后面的小节进行介绍。一个单核CPU设备树和一个四核CPU设备树示例如下所示：</p>
<p>单核CPU示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;0&gt;;</span><br><span class="line"></span><br><span class="line">    cpu0: cpu@0 &#123;</span><br><span class="line">        compatible = &quot;arm,cortex-a7&quot;;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        // 其他属性...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多核CPU示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;0&gt;;</span><br><span class="line"></span><br><span class="line">    cpu0: cpu@0 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a9&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@1 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a9&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu2: cpu@2 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a9&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu3: cpu@3 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a9&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cpus 节点是一个容器节点，包含了 cpu0 子节点。该节点使用了 #address-cells 和 #size-cells 属性来指定地址和大小的单元数量。</p>
<p>cpu0 子节点代表第一个处理器，具有以下属性：</p>
<p>compatible 属性指定了处理器的兼容性信息</p>
<p>device_type 属性指示设备类型为处理器。</p>
<p>你可以在此基础上继续添加其他属性来描述处理器的特性，如时钟频率、缓存大小等。</p>
<h2 id="59-2-cpu-map、socket、cluster节点"><a href="#59-2-cpu-map、socket、cluster节点" class="headerlink" title="59.2 cpu-map、socket、cluster节点"></a>59.2 cpu-map、socket、cluster节点</h2><p>cpu-map 节点是设备树中用于描述大小核架构处理器的映射关系的节点之一。它的父节点必须是 cpus 节点，而子节点可以是一个或多个 cluster 和 socket 节点。通过 cpu-map 节点，可以定义不同核心和集群之间的连接和组织结构。</p>
<p>socket 节点用于描述处理器插槽（socket）之间的映射关系。每个 socket 子节点表示一个处理器插槽，可以使用 cpu-map-mask 属性来指定该插槽使用的核心。通过为每个 socket 子节点指定适当的 cpu-map-mask，可以定义不同插槽中使用的核心。这样，操作系统和软件可以了解到不同插槽之间的核心分配情况。</p>
<p>cluster 节点用于描述核心（cluster）之间的映射关系。每个 cluster 子节点表示一个核心集群，可以使用 cpu-map-mask 属性来指定该集群使用的核心。通过为每个 cluster 子节点指定适当的 cpu-map-mask，可以定义每个集群中使用的核心。这样，操作系统和软件可以了解到不同集群之间的核心分配情况。</p>
<p>通过在 cpu-map 节点中定义 socket 和 cluster 子节点，并为它们指定适当的 cpu-map-mask，可以提供处理器的拓扑结构信息。这对于操作系统和软件来说非常有用，因为它们可以根据这些信息进行任务调度和资源分配的优化，以充分利用大小核架构处理器的性能和能效特性。</p>
<p>一个大小核架构的具体示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">    cpu-<span class="built_in">map</span> &#123;</span><br><span class="line">        cluster0 &#123;</span><br><span class="line">            core0 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_l0&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">            core1 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_l1&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">            core2 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_l2&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">            core3 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_l3&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        cluster1 &#123;</span><br><span class="line">            core0 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_b0&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">            core1 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_b1&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">	cpu_l0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_l1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_l2: cpu@<span class="number">2</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_l3: cpu@<span class="number">3</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_b0: cpu@<span class="number">100</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a72&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_b1: cpu@<span class="number">101</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a72&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个设备树描述了一个具有多个 CPU 核心的系统，包括四个 Cortex-A53 核心和两个 Cortex-A72 核心。下面是对设备树中各个部分的简要介绍：</p>
<p>#address-cells &#x3D; &lt;2&gt;; 和 #size-cells &#x3D; &lt;0&gt;;：这些属性指定了设备树中地址和大小的编码方式。</p>
<p>cpu-map：这个节点定义了 CPU 的映射关系。它包含了两个簇（clusters）：cluster0 和 cluster1。cluster0 包含了四个核心：core0、core1、core2 和 core3，分别对应 cpu_l0、cpu_l1、cpu_l2 和 cpu_l3。cluster1 包含了两个核心：core0 和 core1，分别对应 cpu_b0 和 cpu_b1。</p>
<p>cpu_l0、cpu_l1、cpu_l2 和 cpu_l3：这些节点描述了 Cortex-A53 核心。它们具有相同的设备类型 cpu 和兼容性属性 “arm,cortex-a53”, “arm,armv8”。</p>
<p>cpu_b0 和 cpu_b1：这些节点描述了 Cortex-A72 核心。它们具有相同的设备类型 cpu 和兼容性属性 “arm,cortex-a72”, “arm,armv8”。</p>
<h2 id="59-3-core、thread节点"><a href="#59-3-core、thread节点" class="headerlink" title="59.3 core、thread节点"></a>59.3 core、thread节点</h2><p>“core” 和 “thread” 节点通常用于描述处理器核心和线程的配置。下面是对这两个节点的详细介绍：</p>
<p>Core 节点用于描述处理器的核心。一个处理器通常由多个核心组成，每个核心可以独立执行指令和任务。</p>
<p>Thread 节点用于描述处理器的线程。线程是在处理器核心上执行的基本执行单元，每个核心可以支持多个线程。</p>
<p>通过使用 Core 和 Thread 节点，设备树可以准确描述处理器的核心和线程的配置，例如可以使用设备树来描述一个具有16个核心的CPU，一个物理插槽，每个集群中有两个核心，每个核心有两个线程的设备树示例，具体设备树如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    cpu-<span class="built_in">map</span> &#123;</span><br><span class="line">        socket0 &#123;</span><br><span class="line">            cluster0 &#123;</span><br><span class="line">                core0 &#123;</span><br><span class="line">                    thread0 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU0&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    thread1 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU1&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">                core1 &#123;</span><br><span class="line">                    thread0 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU2&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    thread1 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU3&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            cluster1 &#123;</span><br><span class="line">                core0 &#123;</span><br><span class="line">                    thread0 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU4&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    thread1 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU5&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">                core1 &#123;</span><br><span class="line">                    thread0 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU6&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    thread1 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU7&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        socket1 &#123;</span><br><span class="line">			cluster0 &#123;</span><br><span class="line">				core0 &#123;</span><br><span class="line">					thread0 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU8&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">					thread1 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU9&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;;</span><br><span class="line">				core1 &#123;</span><br><span class="line">					thread0 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU10&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">					thread1 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU11&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">			cluster1 &#123;</span><br><span class="line">				core0 &#123;</span><br><span class="line">					thread0 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU12&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">					thread1 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU13&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;;</span><br><span class="line">				core1 &#123;</span><br><span class="line">					thread0 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU14&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">					thread1 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU15&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="第60章-实例分析：GPIO"><a href="#第60章-实例分析：GPIO" class="headerlink" title="第60章 实例分析：GPIO"></a><strong>第60章</strong> 实例分析：GPIO</h1><h2 id="60-1-中断相关属性"><a href="#60-1-中断相关属性" class="headerlink" title="60.1 中断相关属性"></a>60.1 中断相关属性</h2><h3 id="60-1-1-RK-ft5x06设备树节点"><a href="#60-1-1-RK-ft5x06设备树节点" class="headerlink" title="60.1.1 RK ft5x06设备树节点"></a>60.1.1 RK ft5x06设备树节点</h3><p>下面展示的是iTOP-RK3568开发板SDK源码中的ft5x06设备树，其中蓝色字体部分就是关于gpio相关的描述，包括了interrupts、 interrupt-controller、#interrupt-cells、interrupt-parent四种常见属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">gpio0: gpio@fdd60000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;rockchip,gpio-bank&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0</span> <span class="number">0xfdd60000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">33</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    clocks = &lt;&amp;pmucru PCLK_GPI00&gt;, &lt;&amp;pmucru DBCLK_GPI00&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    gpio-ranges = &lt;&amp;pinctrl <span class="number">0</span> <span class="number">0</span> <span class="number">32</span>&gt;;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06@<span class="number">38</span> &#123; </span><br><span class="line">    status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    compatible = <span class="string">&quot;edt,edt-ft5306&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">    touch-gpio = &lt;&amp;gpio0 RK_PB5 IRQ_TYPE_EDGE_RISING&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio0&gt;;</span><br><span class="line">    interrupts = &lt;RK_PB5 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">    reset-gpios = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    touchscreen-size-x = &lt;<span class="number">800</span>&gt;;</span><br><span class="line">    touchscreen-size-y = &lt;<span class="number">1280</span>&gt;;</span><br><span class="line">    touch_type = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中gpio0节点是在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568.dtsi”设备树的3549-3560行定义的，而ft5x06: ft5x06@38触摸芯片节点是在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;topeet_rk3568_lcds.dtsi”设备树的301-313行定义的。接下来将会对设备树常见的四个gpio属性进行介绍。</p>
<h3 id="60-1-2-gpio-controller"><a href="#60-1-2-gpio-controller" class="headerlink" title="60.1.2 gpio-controller"></a>60.1.2 gpio-controller</h3><p>gpio-controller属性用于标识一个设备节点作为GPIO控制器。GPIO控制器是负责管理和控制GPIO引脚的硬件模块或驱动程序。</p>
<p>gpio-controller属性通常作为设备节点的一个属性出现，位于设备节点的属性列表中。</p>
<p>当一个设备节点被标识为GPIO控制器时，它通常会定义一组GPIO引脚，并提供相关的GPIO控制和配置功能。其他设备节点可以使用该GPIO控制器来控制和管理其GPIO引脚。</p>
<p>通过使用gpio-controller属性，设备树可以明确标识出GPIO控制器设备节点，使系统可以正确识别和管理GPIO引脚的配置和控制。</p>
<h3 id="60-1-3-gpio-cells"><a href="#60-1-3-gpio-cells" class="headerlink" title="60.1.3 #gpio-cells"></a>60.1.3 #gpio-cells</h3><p>#gpio-cells属性用于指定GPIO引脚描述符的编码方式。GPIO引脚描述符是用于标识和配置GPIO引脚的一组值，例如引脚编号、引脚属性等。</p>
<p>#gpio-cells属性的属性值是一个整数，表示用于编码GPIO引脚描述符的单元数。通常，这个值为2。</p>
<p>在第一小节的示例中有1个gpio引脚描述属性,由于#gpio-cells属性被设置为了2，所以每个引脚描述属性中会有两个整数，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ft5x06: ft5x06@<span class="number">38</span> &#123; </span><br><span class="line">    .....</span><br><span class="line">    reset-gpios = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>RK_PB6、GPIO_ACTIVE_LOW都属于恒定义，会在下面的小节进行讲解。</p>
<p>通过使用#gpio-cells属性，设备树可以指定GPIO引脚描述符的编码方式，使系统能够正确识别和解析GPIO引脚的配置和控制。</p>
<h3 id="60-1-4-gpio-ranges"><a href="#60-1-4-gpio-ranges" class="headerlink" title="60.1.4 gpio-ranges"></a>60.1.4 gpio-ranges</h3><p>gpio-ranges属性是设备树中一个用于描述GPIO范围映射的属性。它通常用于描述具有大量GPIO引脚的GPIO控制器，以简化GPIO引脚的编码和访问。</p>
<p>在设备树中，GPIO控制器的每个引脚都有一个本地编号，用于在控制器内部进行引脚寻址。然而，这些本地编号并不一定与外部引脚的物理编号或其他系统中使用的编号一致。为了解决这个问题，可以使用gpio-ranges属性将本地编号映射到实际的引脚编号。</p>
<p>gpio-ranges属性是一个包含一系列整数值的列表，每个整数值对应于设备树中的一个GPIO控制器。列表中的每个整数值按照特定的顺序提供以下信息：</p>
<p>（1）外部引脚编号的起始值。	</p>
<p>（2）GPIO控制器内部本地编号的起始值。</p>
<p>（3）引脚范围的大小（引脚数量）。</p>
<p>在第一小节的示例中gpio-ranges属性的值为&lt;&amp;pinctrl 0 0 32&gt;，其中&lt;&amp;pinctrl&gt;表示引用了名为pinctrl的引脚控制器节点，0 0 32表示外部引脚从0开始，控制器本地编号从0开始，共映射了32个引脚。</p>
<p>这样，gpio-ranges属性将GPIO控制器的本地编号直接映射到外部引脚编号，使得GPIO引脚的编码和访问更加简洁和直观。</p>
<h3 id="60-1-5-gpio引脚描述属性"><a href="#60-1-5-gpio引脚描述属性" class="headerlink" title="60.1.5 gpio引脚描述属性"></a>60.1.5 gpio引脚描述属性</h3><p>第一小节的设备树中关于gpio引脚描述属性相关内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ft5x06: ft5x06@38 &#123; </span><br><span class="line">    .....</span><br><span class="line">    reset-gpios = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>gpio引脚描述属性个数由#gpio-cells所决定，因为gpio0节点中的#gpio-cells属性设置为了2，所以上面设备树gpio引脚描述属性个数也为2。</p>
<p>其中RK_PB6 定义在内核源码目录下的“include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h”头文件中，定义了RK引脚名和gpio编号的宏定义，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps14.jpg" alt="img"> </p>
<p>GPIO_ACTIVE_LOW定义在源码目录下的“include&#x2F;dt-bindings&#x2F;gpio&#x2F;gpio.h”中，表示设置为低电平，同理GPIO_ACTIVE_HIGH就表示将这个GPIO设置为高电平，但这里只是对设备的描述，具体的设置还是要跟驱动相匹配。</p>
<h3 id="60-1-6-其他属性"><a href="#60-1-6-其他属性" class="headerlink" title="60.1.6 其他属性"></a>60.1.6 其他属性</h3><p>本小节将根据下面的设备树示例讲解一下gpio的其他属性，设备树具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gpio-controller@<span class="number">00000000</span> &#123;</span><br><span class="line">    compatible = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x00000000</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    ngpios = &lt;<span class="number">18</span>&gt;;</span><br><span class="line">    gpio-reserved-ranges = &lt;<span class="number">0</span> <span class="number">4</span>&gt;, &lt;<span class="number">12</span> <span class="number">2</span>&gt;;</span><br><span class="line">    gpio-line-names = <span class="string">&quot;MMC-CD&quot;</span>, <span class="string">&quot;MMC-WP&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;voD eth&quot;</span>, <span class="string">&quot;RST eth&quot;</span>, <span class="string">&quot;LED R&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;LED G&quot;</span>, <span class="string">&quot;LED B&quot;</span>, <span class="string">&quot;col A&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;col B&quot;</span>, <span class="string">&quot;col C&quot;</span>, <span class="string">&quot;col D&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;NMI button&quot;</span>, <span class="string">&quot;Row A&quot;</span>, <span class="string">&quot;Row B&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;Row C&quot;</span>, <span class="string">&quot;Row D&quot;</span>, <span class="string">&quot;poweroff&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;reset&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第6行的ngpios 属性指定了 GPIO 控制器所支持的 GPIO 引脚数量。它表示该设备上可用的 GPIO 引脚的总数。在这个例子中，ngpios&#96; 的值为 18，意味着该 GPIO 控制器支持 18 个 GPIO 引脚。</p>
<p>第7行的gpio-reserved-ranges属性定义了保留的GPIO范围。每个范围由两个整数值表示，用尖括号括起来。保留的GPIO范围意味着这些GPIO引脚不可用或已被其他设备或功能保留。在这个例子中，有两个保留范围：&lt;0 4&gt;和&lt;12 2&gt;。&lt;0 4&gt;表示从第0个引脚开始的连续4个引脚被保留，而&lt;12 2&gt;表示从第12个引脚开始的连续2个引脚被保留。<br>    第8行的gpio-line-names 属性定义了GPIO引脚的名称，以逗号分隔。每个名称对应一个 GPIO 引脚。这些名称用于标识和识别每个GPIO引脚的作用或连接的设备。在这个例子中，gpio-line-names属性列出了多个GPIO引脚的名称，如 “MMC-CD”、”MMC-WP”、”voD eth” 等等。通过这些名称，可以清楚地了解每个GPIO引脚的功能或用途。</p>
<h2 id="60-2-中断实例编写"><a href="#60-2-中断实例编写" class="headerlink" title="60.2 中断实例编写"></a>60.2 中断实例编写</h2><p>在上一个小节中对设备树中断要用到的属性进行了讲解，而在本小节将会编写一个在RK3568上LED灯的中断设备树。</p>
<p>首先确定LED的引脚编号，LED原理图如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps119.jpg" alt="img"> </p>
<p>从上面的原理图可以得到LED灯的引脚网络标号为Working_LEDEN_H_GPIO0_B7，对应的引脚为GPIO0_B7。</p>
<p>然后来查看内核源码目录下的“drivers&#x2F;drivers&#x2F;leds&#x2F;leds-gpio.c”文件，这是led的驱动文件，然后找到compatible匹配值相关的部分，如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps120.jpg" alt="img"> </p>
<p>可以看到compatible匹配值为gpio-leds。</p>
<p>最后在内核源码目录下的“include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h”头文件中，定义了RK引脚名和gpio编号的宏定义，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps121.jpg" alt="img"> </p>
<p>在源码目录下的“include&#x2F;dt-bindings&#x2F;gpio&#x2F;gpio.h”文件中定义了引脚极性设置宏定义，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps122.jpg" alt="img"> </p>
<p>其中GPIO_ACTIVE_HIGH表示将该引脚设置为高电平，GPIO_ACTIVE_LOW表示将该引脚设置为低电平。</p>
<p>至此，我们关于编写LED设备树的前置内容就查找完成了，接下来进行设备树的编写。</p>
<p>  编写完成的设备树如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/pinctrl/rockchip.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/gpio/gpio.h&quot;</span></span></span><br><span class="line">/&#123;</span><br><span class="line">	model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line"></span><br><span class="line">	led led@<span class="number">1</span> &#123;</span><br><span class="line">		compatible = <span class="string">&quot;gpio-leds&quot;</span>;</span><br><span class="line">		gpios = &lt;&amp;gpio0 RK_PB7 GPIO_ACTIVE_HIGH&gt;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第1行: 设备树文件的头部，指定了使用的设备树语法版本。</p>
<p>第3行：用于定义 Rockchip 平台的引脚控制器相关的绑定。</p>
<p>第4行：用于定义中断控制器相关的绑定。</p>
<p>第5行：表示设备树的根节点开始。</p>
<p>第6行：指定了设备树的模型名称，描述为 “This is my devicetree!”。</p>
<p>第9行：指定了设备节点的兼容性字符串，表示该设备与 “gpio-leds” 兼容。</p>
<p>第10行：指定了该 LED 设备所使用的 GPIO 引脚。&amp;gpio0 是引脚控制器的引用，RK_PB7 是引脚的编号或标识，GPIO_ACTIVE_HIGH 表示该 GPIO 引脚的活动电平是高电平。</p>
<p>至此，关于led的设备树就讲解完成了。</p>
<h2 id="60-3-其他SOC设备树对比"><a href="#60-3-其他SOC设备树对比" class="headerlink" title="60.3 其他SOC设备树对比"></a>60.3 其他SOC设备树对比</h2><p>而无论使用的是瑞芯微SOC还是恩智浦、三星的SOC，在设备树关于gpio相关的描述都是类似的，关于在恩智浦和三星源码中的ft5x06设备树如下所示（关于gpio相关的属性已经标记为了蓝色）：</p>
<p><em><strong>*恩智浦*</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">gpio1: gpio@0209c000 &#123;</span><br><span class="line">    compatible = &quot;fsl,inx6ul-gpio&quot;, &quot;fsl,imx35-gpio&quot;;</span><br><span class="line">    reg = &lt;0x0209c000 0x4000&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH&gt;, &lt;GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    #gpio-cells = &lt;2&gt;;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">    #interrupt-cells = &lt;2&gt;;</span><br><span class="line"></span><br><span class="line">    edt-ft5x06@38 &#123;</span><br><span class="line">        compatible = &quot;edt,edt-ft5306&quot;, &quot;edt,edt-ft5x06&quot;, &quot;edt,edt-ft5406&quot;;</span><br><span class="line">        pinctrl-names = &quot;default&quot;;</span><br><span class="line">        pinctrl-0 = &lt;&amp;ts_int_pin &amp;ts_reset_pin&gt;;</span><br><span class="line">        reg = &lt;0x38&gt;;</span><br><span class="line">        interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">        interrupts = &lt;9 0&gt;;</span><br><span class="line">        reset-gpios = &lt;&amp;gpio5 9 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">        irq-gpios = &lt;&amp;gpio1 9 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">        status = &quot;disabled&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em><strong>*三星*</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">gpio_c: gpioc &#123;</span><br><span class="line">    compatible = &quot;gpio-controller&quot;;</span><br><span class="line">    #gpio-cells = &lt;2&gt;;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">    #interrupt-cells = &lt;2&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06038 &#123;</span><br><span class="line">    compatible = &quot;edt,edt-ft5406&quot;;</span><br><span class="line">    reg = &lt;0x38&gt;;</span><br><span class="line">    pinctrl-names = &quot;default&quot;;</span><br><span class="line"></span><br><span class="line">    #if defined(RGB_1024x600) || defined(RGB_800x480)</span><br><span class="line">    pinctrl-0 = &lt;&amp;tsc2007_irq&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio_c&gt;;</span><br><span class="line">    interrupts = &lt;26 IRQ_TYPE_EDGE_FALLING&gt;;</span><br><span class="line">    #endif</span><br><span class="line"></span><br><span class="line">    #if defined(LvDs_800×1280) || defined(LvDS_1024x768)</span><br><span class="line">    pinctrl-0 = &lt;&amp;gt911_irq&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio_b&gt;;</span><br><span class="line">    interrupts = &lt;29 IRQ_TYPE_EDGE_FALLING&gt;;</span><br><span class="line">    #endif</span><br><span class="line"> reset-gpios = &lt;&amp;gpio_e 30 0&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对比之后会发现，不同厂商对于gpio的配置都是类似的，只是里面的参数有些许区别，如果大家在之后遇到了其他平台，只需要稍加区分即可。</p>
<h1 id="第61章-实例分析：pinctrl"><a href="#第61章-实例分析：pinctrl" class="headerlink" title="第61章 实例分析：pinctrl"></a><strong>第61章</strong> 实例分析：pinctrl</h1><h2 id="61-1-pinmux介绍"><a href="#61-1-pinmux介绍" class="headerlink" title="61.1 pinmux介绍"></a>61.1 pinmux介绍</h2><p>Pinmux（引脚复用）是指在系统中配置和管理引脚功能的过程。在许多现代集成电路中，单个引脚可以具有多个功能，例如作为 GPIO、UART、SPI 或 I2C 等。通过使用引脚复用功能，可以在这些不同的功能之间切换。</p>
<p>引脚复用通过硬件和软件的方式实现。硬件层面，芯片设计会为每个引脚提供多个功能的选择。这些功能通常由芯片厂商在芯片规格文档中定义。通过编程设置寄存器或开关，可以选择某个功能来连接引脚。这种硬件层面的配置通常是由引脚控制器（Pin Controller）或引脚复用控制器（Pin Mux Controller）负责管理。</p>
<p>软件层面，操作系统或设备驱动程序需要了解和配置引脚的功能。它们使用设备树（Device Tree）或设备树绑定（Device Tree Bindings）来描述和配置引脚的功能。在设备树中，可以指定引脚的复用功能，将其连接到特定的硬件接口或功能。操作系统或设备驱动程序在启动过程中解析设备树，并根据配置对引脚进行初始化和设置。</p>
<p>那我们要怎样知晓每一个管脚都可以复用成什么功能呢，一般在核心板原理图都会标注出每个管脚的复用功能，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps123.jpg" alt="img"> </p>
<p>从上图可以看到UART4_RX_M1对应的引脚可以复用为以下6个功能LCDC_D16、VOP_BT1120_D7、GMAC1_RXD0_M0、UART4_RX_M1、PWM8_M0、GPIO3_B1_d，对应的BGA引脚标号为AG1,那这里的AG1是如何定位的呢。</p>
<p>在 BGA（Ball Grid Array，球栅阵列）封装中，引脚标号是用于唯一标识每个引脚的标识符。这些标号通常由芯片制造商定义，并在芯片的规格文档或数据手册中提供。</p>
<p>BGA 芯片的引脚标号通常由字母和数字的组合构成。它们用于在芯片的封装底部的焊盘上进行标记。每个引脚标号都与芯片内部的功能或信号相对应，以便正确连接到印刷电路板（PCB）上的目标位置。RK3568的引脚标号图如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps124.jpg" alt="img"> </p>
<p>可以看到纵向为A-AH的28个字母类型标号，横向为1-28的28个字母类型标号，瑞芯微也在对应的3568数据手册中加入了根据BGA位置制作的复用功能图，部分内容如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps125.jpg" alt="img"> </p>
<p>其中黑色框代表被保留的引脚，其他有颜色的框一般为电源和地，白色的框代表有具体复用功能的引脚。</p>
<p>最后对引脚复用的优点进行整理，引脚复用提高了芯片的灵活性和可重用性，通过允许同一个引脚在不同的功能之间切换，可以减少硬件设计的复杂性和成本。此外，引脚复用还使得在使用相同芯片的不同应用中可以更加灵活地配置和定制引脚功能。会在下一个小节中讲解如何使用pinctrl在设备树中配置引脚的复用。</p>
<h2 id="61-2使用pinctrl设置复用关系"><a href="#61-2使用pinctrl设置复用关系" class="headerlink" title="61.2使用pinctrl设置复用关系"></a>61.2使用pinctrl设置复用关系</h2><p>pinctrl（引脚控制）用于描述和配置硬件设备上的引脚功能和连接方式。它是设备树的一部分，用于在启动过程中传递引脚配置信息给操作系统和设备驱动程序，以便正确地初始化和控制引脚。</p>
<p>在设备树中，pinctrl（引脚控制）使用了客户端和服务端的概念来描述引脚控制的关系和配置。</p>
<h3 id="61-2-1-客户端（Client）"><a href="#61-2-1-客户端（Client）" class="headerlink" title="61.2.1 客户端（Client）"></a>61.2.1 客户端（Client）</h3><p>接下来将使用三个例子对客户端要用到的属性进行讲解。</p>
<p>例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node &#123;</span><br><span class="line">    pinctrl-names = &quot;default&quot;;</span><br><span class="line">    pinctrl-0 = &lt;&amp;pinctrl_hog_1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在例1中，pinctrl-names 属性定义了一个状态名称：default。</p>
<p>pinctrl-0 属性指定了第一个状态 default 对应的引脚配置。</p>
<p>&lt;&amp;pinctrl_hog_1&gt; 是一个引脚描述符，它引用了一个名为 pinctrl_hog_1 的引脚控制器节点。这表示在 default 状态下，设备的引脚配置将使用 pinctrl_hog_1 节点中定义的配置。</p>
<p>例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node &#123;</span><br><span class="line">    pinctrl-names = &quot;default&quot;, &quot;wake up&quot;;</span><br><span class="line">    pinctrl-0 = &lt;&amp;pinctrl_hog_1&gt;;</span><br><span class="line">    pinctrl-1 = &lt;&amp;pinctrl_hog_2&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在例2中，pinctrl-names 属性定义了两个状态名称：default 和 wake up。</p>
<p>pinctrl-0 属性指定了第一个状态 default 对应的引脚配置，引用了 pinctrl_hog_1 节点。</p>
<p>pinctrl-1 属性指定了第二个状态 wake up 对应的引脚配置，引用了 pinctrl_hog_2 节点。</p>
<p>这意味着设备可以处于两个不同的状态之一，每个状态分别使用不同的引脚配置。</p>
<p>例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node &#123;</span><br><span class="line">    pinctrl-names = &quot;default&quot;;</span><br><span class="line">    pinctrl-0 = &lt;&amp;pinctrl_hog_1 &amp;pinctrl_hog_2&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，pinctrl-names 属性仍然定义了一个状态名称：default。</p>
<p>pinctrl-0 属性指定了第一个状态 default 对应的引脚配置，但与之前的例子不同的是，它引用了两个引脚描述符：pinctrl_hog_1 和 pinctrl_hog_2。</p>
<p>这表示在 default 状态下，设备的引脚配置将使用 pinctrl_hog_1 和 pinctrl_hog_2 两个节点中定义的配置。这种方式可以将多个引脚控制器的配置组合在一起，以满足特定状态下的引脚需求。</p>
<p>至此关于客户端的内容就讲解完成了，低于客户端的内容，不同厂家的编写格式是相同的，而服务端每个厂家就有区别了，在下一个小节将以rk3568的pinctrl服务端为例进行讲解。</p>
<h3 id="62-2-2-服务端（Server）"><a href="#62-2-2-服务端（Server）" class="headerlink" title="62.2.2 服务端（Server）"></a>62.2.2 服务端（Server）</h3><p>服务端是设备树中定义引脚配置的部分。它包含引脚组和引脚描述符，为客户端提供引脚配置选择。服务端在设备树中定义了 pinctrl 节点，其中包含引脚组和引脚描述符的定义。</p>
<p>这里以瑞芯微的RK3568为例进行pinctrl服务端的讲解，瑞芯微原厂BSP工程师为了方便用户通过pinctrl设置管脚的复用关系，将包含所有复用关系的配置写在了内核目录下的“arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568-pinctrl.dtsi”设备树中，具体内容如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps126.jpg" alt="img"> </p>
<p>在pinctrl节点中就是每个节点的复用功能，然后我们以uart4的引脚复用为例进行讲解，uart4的pinctrl服务端内容如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps127.jpg" alt="img"> </p>
<p>其中&lt;3 RK_PB1 4 &amp;pcfg_pull_up&gt;和&lt;3 RK_PB2 4 &amp;pcfg_pull_up&gt;分别表示将GPIO3的PB1引脚设置为功能4，将GPIO3的PB2也设置为功能4，且电器属性都会设置为上拉。通过查找原理图可以得到两个引脚在BGA封装位置分别为AG1和AF2，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps128.jpg" alt="img"> </p>
<p>然后在rk3568的数据手册中找到引脚复用表对应的位置，具体内容如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps129.jpg" alt="img"><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps130.jpg" alt="img"> </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps131.jpg" alt="img"> </p>
<p>可以看到功能4对应串口4的发送端和接收端，那如果要将RK_PB1和RK_PB2设置为GPIO功能要如何设置呢，从上图可以看到GPIO对应功能0，所以可以通过以下pinctrl内容将设置RK_PB1和RK_PB2设置为GPIO功能（事实上如果不对该管脚进行功能复用该引脚默认就会设置为GPIO功能）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;3 RK_PB1 0 &amp;pcfg_pull_up&gt;,                                                                                                                                                                                           </span><br><span class="line">&lt;3 RK_PB2 0 &amp;pcfg_pull_up&gt;;</span><br></pre></td></tr></table></figure>

<p>最后来看客户端对uart4服务端的引用，具体内容在内核源码目录“arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568-evb1-ddr4-v10-linux.dts”：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps132.jpg" alt="img"> </p>
<p>通过在客户端中引用服务端的引脚描述符，设备树可以将客户端和服务端的引脚配置关联起来。这样，在设备树被解析和处理时，操作系统和设备驱动程序可以根据客户端的需求，查找并应用适当的引脚配置。</p>
<h2 id="61-3-pinctrl实例编写"><a href="#61-3-pinctrl实例编写" class="headerlink" title="61.3 pinctrl实例编写"></a>61.3 pinctrl实例编写</h2><p>本小节将会对通过上面学到的pinctrl相关知识，将led的控制引脚设置成GPIO的模式。</p>
<p>首先来对rk3568的设备树结构进行以下介绍，根据sdk源码目录下的“device&#x2F;rockchip&#x2F;rk356x&#x2F;BoardConfig-rk3568-evb1-ddr4-v10.mk”默认配置文件可以了解到编译的设备树为rk3568-evb1-ddr4-v10-linux.dts,根据设备树之间的包含关系列出了下面的表格。</p>
<table>
<thead>
<tr>
<th>顶层设备树</th>
<th>rk3568-evb1-ddr4-v10-linux.dts</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>第二级设备树</td>
<td>rk3568-evb1-ddr4-v10.dtsi</td>
<td>rk3568-linux.dtsi</td>
</tr>
<tr>
<td>第三级设备树</td>
<td>rk3568.dtsirk3568-evb.dtsi                                                                                                     topeet_screen_choose.dtsitopeet_rk3568_lcds.dtsi</td>
<td></td>
</tr>
</tbody></table>
<p>Led在rk3568-evb.dtsi设备树中已经被正常配置了，如下图所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps133.jpg" alt="img"></p>
<p>这时候可能大家就有问题了，这里也并没有配置pinctrl呀，那为什么led最后能正常使用呢，这个原因在上节课中其实我们已经提到了，当一个引脚没有被复用为任何功能时，默认就是GPIO功能，所以这里没有pinctrl led功能也可以正常使用。</p>
<p>但这里我们仍旧使用pinctrl对led进行配置，从而熟练pinctrl，首先注释掉leds节点，注释完成如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps134.jpg" alt="img"> </p>
<p>保存退出之后，然后进入到rk3568-evb1-ddr4-v10.dtsi设备树中，找到rk_485_ctl节点，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps135.jpg" alt="img"> </p>
<p>这是根节点的最后一个节点，而且也是用来控制一个GPIO的，我们完全可以仿照该节点，在该节点下方编写led控制节点，仿写完成的设备树内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_led: led &#123;</span><br><span class="line">   compatible = &quot;topeet,led&quot;;</span><br><span class="line">   gpios = &lt;&amp;gpio0 RK_PB7 GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">   pinctrl-names = &quot;default&quot;;</span><br><span class="line">   pinctrl-0 = &lt;&amp;rk_led_gpio&gt;;</span><br><span class="line">   &#125;; </span><br></pre></td></tr></table></figure>

<p>第1行：节点名称为 led，标签名为my_led。</p>
<p>第2行：compatible 属性指定了设备的兼容性标识，即设备与驱动程序之间的匹配规则。在这里，设备标识为 “topeet,led”，表示该 LED 设备与名为 “topeet,led” 的驱动程序兼容。</p>
<p>第3行：gpios 属性指定了与LED相关的GPIO（通用输入&#x2F;输出）引脚配置。</p>
<p>第4行：pinctrl-names 属性指定了与引脚控制相关的命名。default表示状态 0</p>
<p>第5行：pinctrl-0 属性指定了与 pinctrl-names 属性中命名的引脚控制相关联的实际引脚控制器配置。&lt;&amp;rk_led_gpio&gt; 表示引用了名为 rk_led_gpio 的引脚控制器配置。</p>
<p>添加完成如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps136.jpg" alt="img"> </p>
<p>然后继续找到在同一设备树文件的485 pinctrl服务端节点，具体内容如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps137.jpg" alt="img"> </p>
<p>然后在该节点下方仿写led控制引脚pinctrl服务端节点，仿写完成的节点内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rk_led&#123;</span><br><span class="line">		rk_led_gpio:rk-led-gpio &#123;</span><br><span class="line">			rockchip,pins = &lt;0 RK_PB7 RK_FUNC_GPIO &amp;pcfg_pull_none&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p>添加完成之后如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps138.jpg" alt="img"> </p>
<p>至此，led的控制引脚就通过pinctrl被复用为了GPIO功能，保存退出之后，重新编译内核，没有报错就证明我们的实验完成了。</p>
<h1 id="第62章-dtb文件格式讲解"><a href="#第62章-dtb文件格式讲解" class="headerlink" title="第62章 dtb文件格式讲解"></a><strong>第62章</strong> dtb文件格式讲解</h1><p>设备树 Blob (DTB) 格式是设备树数据的平面二进制编码。它用于在软件程序之间交换设备树数据。例如，在启动操作系统时，固件会将 DTB 传递给操作系统内核。</p>
<p>DTB 格式在单个、线性、无指针数据结构中对设备树数据进行编码。它由一个小头部和三个可变大小的部分组成：内存保留块、结构块和字符串块。这些应该以该顺序出现在展平的设备树中。因此，设备树结构作为一个整体，当加载到内存地址时，将类似于下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps139.jpg" alt="img"> </p>
<p>本节课将以下面的设备树为例对设备树的二进制文件格式进行讲解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = <span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0, 115200&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a35&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x1</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    aliases &#123;</span><br><span class="line">        led1 = <span class="string">&quot;/gpio@22020101&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node1 &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">        gpio@<span class="number">22020102</span> &#123;</span><br><span class="line">            reg = &lt;<span class="number">0x20220102</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node2 &#123;</span><br><span class="line">        node1-child &#123;</span><br><span class="line">            pinnum = &lt;<span class="number">01234</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@<span class="number">22020101</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;led&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x20220101</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而我们之后要分析的是二进制的dtb文件，所以需要使用dtc工具将上面的dts文件编译成dtb文件，具体命令如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps140.jpg" alt="img"> </p>
<p>为了方便用户学习，已经将本章节要讲解的设备树dts文件和dtb文件放在了对应的网盘路径下，同时也将pxBinaryViewerSetup二进制分析软件放在了同一目录下，iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\49_dt_format，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps141.jpg" alt="img"> </p>
<p>使用二进制分析软件打开deb文件并设置大端模式之后如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps142.jpg" alt="img"> </p>
<p>在接下来的小节中将会对读取出的设备树二进制内容进行讲解。</p>
<h2 id="62-1-Header"><a href="#62-1-Header" class="headerlink" title="62.1 Header"></a>62.1 Header</h2><p>devicetree 的头布局由以下 C 结构定义。所有的头字段都是 32 位整数，以大端格式存储。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdt_header</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> magic;                 <span class="comment">// 设备树头部的魔数</span></span><br><span class="line">    <span class="type">uint32_t</span> totalsize;             <span class="comment">// 设备树文件的总大小</span></span><br><span class="line">    <span class="type">uint32_t</span> off_dt_struct;         <span class="comment">// 设备树结构体（节点数据）相对于文件开头的偏移量</span></span><br><span class="line">    <span class="type">uint32_t</span> off_dt_strings;        <span class="comment">// 设备树字符串表相对于文件开头的偏移量</span></span><br><span class="line">    <span class="type">uint32_t</span> off_mem_rsvmap;        <span class="comment">// 内存保留映射表相对于文件开头的偏移量</span></span><br><span class="line">    <span class="type">uint32_t</span> version;               <span class="comment">// 设备树版本号</span></span><br><span class="line">    <span class="type">uint32_t</span> last_comp_version;     <span class="comment">// 最后一个兼容版本号</span></span><br><span class="line">    <span class="type">uint32_t</span> boot_cpuid_phys;       <span class="comment">// 启动 CPU 的物理 ID</span></span><br><span class="line">    <span class="type">uint32_t</span> size_dt_strings;       <span class="comment">// 设备树字符串表的大小</span></span><br><span class="line">    <span class="type">uint32_t</span> size_dt_struct;        <span class="comment">// 设备树结构体（节点数据）的大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个字段的描述如下所示：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>magic</td>
<td>该字段为固定值 0xd00dfeed（大端）。</td>
</tr>
<tr>
<td>totalsize</td>
<td>该字段包含设备树数据结构的总大小（以字节为单位）。此大小应包含结构的所有部分：标题、内存保留块、结构块和字符串块，以及块之间或最后一个块之后的任何空闲空间间隙。</td>
</tr>
<tr>
<td>off_dt_struct</td>
<td>该字段包含结构块从头开始的以字节为单位的偏移量。</td>
</tr>
<tr>
<td>off_dt_strings</td>
<td>该字段包含字符串块从头开始的以字节为单位的偏移量。</td>
</tr>
<tr>
<td>off_mem_rsvmap</td>
<td>该字段包含从头开始的内存保留块的字节偏移量。</td>
</tr>
<tr>
<td>version</td>
<td>该字段包含设备树数据结构的版本。</td>
</tr>
<tr>
<td>last_comp_version</td>
<td>向后兼容的设备树数据结构的最低版本。</td>
</tr>
<tr>
<td>boot_cpuid_phys</td>
<td>与设备树CPU 节点的reg属性对应</td>
</tr>
<tr>
<td>size_dt_strings</td>
<td>设备树字符串块部分的字节长度。</td>
</tr>
<tr>
<td>size_dt_struct</td>
<td>设备树结构块部分的字节长度。</td>
</tr>
</tbody></table>
<p>然后来查看二进制文件，其中4个字节表示一个单位，前十个单位分别代表上述的十个字段如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps143.jpg" alt="img"> </p>
<table>
<thead>
<tr>
<th>字段</th>
<th>十六进制数值</th>
<th>代表含义</th>
</tr>
</thead>
<tbody><tr>
<td>magic</td>
<td>D00DFEED</td>
<td>固定值</td>
</tr>
<tr>
<td>totalsize</td>
<td>000002A4</td>
<td>转换为十进制之后为676，表示该文件大小为676字节</td>
</tr>
<tr>
<td>off_dt_struct</td>
<td>00000038</td>
<td>表示结构块从00000038这个地址开始，和后面的size_dt_struct结构块大小参数一起可以确定结构块的存储范围</td>
</tr>
<tr>
<td>off_dt_strings</td>
<td>0000024C</td>
<td>表示字符串块从0000024C这个地址开始，和后面的size_dt_strings字符串块大小参数一起可以确定字符串块的存储范围</td>
</tr>
<tr>
<td>off_mem_rsvmap</td>
<td>00000028</td>
<td>表示内存保留块的偏移为00000028， header之后结构快之前都是属于内存保留块。</td>
</tr>
<tr>
<td>version</td>
<td>00000011</td>
<td>11转换为十进制之后为17，表示当前设备树结构版本为17</td>
</tr>
<tr>
<td>last_comp_version</td>
<td>00000010</td>
<td>10转换为十进制之后为16，表示向前兼容的设备树结构版本为16</td>
</tr>
<tr>
<td>boot_cpuid_phys</td>
<td>00000000</td>
<td>表示设备树的teg属性为0</td>
</tr>
<tr>
<td>size_dt_strings</td>
<td>00000058</td>
<td>表示字符串块的大小为00000058 ，和前面的off_dt_strings字符串块偏移值一起可以确定字符串块的范围</td>
</tr>
<tr>
<td>size_dt_struct</td>
<td>00000214</td>
<td>表示结构块的大小为00000214，和前面的off_dt_struct结构块偏移值一起可以确定结构块的范围</td>
</tr>
</tbody></table>
<p>在接下来的小节中将会对header提到的内存保留块、结构块和字符串块进行更详细的讲解。</p>
<h2 id="62-2-内存保留块"><a href="#62-2-内存保留块" class="headerlink" title="62.2 内存保留块"></a>62.2 内存保留块</h2><p>内存保留块（Memory Reserved Block）是用于客户端程序的保护和保留物理内存区域的列表。这些保留区域不应被用于一般的内存分配，而是用于保护重要数据结构，以防止客户端程序覆盖这些数据。内存保留块的目的是确保特定的内存区域在客户端程序运行时不被修改或使用。由于在示例设备树中没有设置内存保留块，所以相应的区域都为0，如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps144.jpg" alt="img"> </p>
<p><em><strong>*保留区域列表：*</strong></em> 内存保留块是一个由一组 64 位大端整数对构成的列表。每对整数对应一个保留内存区域，其中包含物理地址和区域的大小（以字节为单位）。这些保留区域应该彼此不重叠。</p>
<p><em><strong>*保留区域的用途：*</strong></em> 客户端程序不应访问内存保留块中的保留区域，除非引导程序提供的其他信息明确指示可以访问。引导程序可以使用特定的方式来指示客户端程序可以访问保留内存的部分内容。引导程序可能会在文档、可选的扩展或特定于平台的文档中说明保留内存的特定用途。</p>
<p><em><strong>*格式：*</strong></em> 内存保留块中的每个保留区域由一个64位大端整数对表示。每对由以下 C 结构表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdt_reserve_entry</span> &#123;</span> </span><br><span class="line">	<span class="type">uint64_t</span> address; </span><br><span class="line">	<span class="type">uint64_t</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的第一个整数表示保留区域的物理地址，第二个整数表示保留区域的大小（以字节为单位）。每个整数都以 64 位的形式表示，即使在32位架构上也是如此。在32位CPU上，整数的高 32 位将被忽略。</p>
<p>内存保留块为设备树提供了保护和保留物理内存区域的功能。它确保了特定的内存区域在客户端程序运行时不被修改或使用。这样可以确保引导程序和其他关键组件在需要的情况下能够访问保留内存的特定部分，并保护关键数据结构免受意外修改。</p>
<h2 id="62-3-结构块"><a href="#62-3-结构块" class="headerlink" title="62.3 结构块"></a>62.3 结构块</h2><p>结构块是设备树中描述设备树本身结构和内容的部分。它由一系列带有数据的令牌序列组成，这些令牌按照线性树结构进行组织。</p>
<p><strong>（1）</strong><em><strong>*令牌类型*</strong></em></p>
<p> 结构块中的令牌分为五种类型，每种类型用于不同的目的。</p>
<p>a. FDT_BEGIN_NODE (0x00000001): FDT_BEGIN_NODE 标记表示一个节点的开始。它后面跟着节点的单元名称作为额外数据。节点名称以以空字符结尾的字符串形式存储，并且可以包括单元地址。节点名称后可能需要填充零字节以对齐，然后是下一个标记，可以是除了 FDT_END 之外的任何标记。</p>
<p>b. FDT_END_NODE (0x00000002): FDT_END_NODE 标记表示一个节点的结束。该标记没有额外的数据，紧随其后的是下一个标记，可以是除了 FDT_PROP 之外的任何标记。</p>
<p>c. FDT_PROP (0x00000003): FDT_PROP 标记表示设备树中属性的开始。它后面跟着描述属性的额外数据，该数据首先由属性的长度和名称组成，表示为以下 C 结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">	uint32_t len; </span><br><span class="line">	uint32_t nameoff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>长度表示属性值的字节长度，名称偏移量指向字符串块中存储属性名称的位置。在这个结构之后，属性的值作为字节字符串给出。属性值后可能需要填充零字节以对齐，然后是下一个令牌，可以是除了 FDT_END 之外的任何标记。</p>
<p>d. FDT_NOP (0x00000004): FDT_NOP 令牌可以被解析设备树的程序忽略。该令牌没有额外的数据，紧随其后的是下一个令牌，可以是任何有效的令牌。使用 FDT_NOP 令牌可以覆盖树中的属性或节点定义，从而将其从树中删除，而无需移动设备树 blob 中的其他部分。</p>
<p>e. FDT_END (0x00000009): FDT_END 标记表示结构块的结束。应该只有一个 FDT_END 标记，并且应该是结构块中的最后一个标记。该标记没有额外的数据，紧随其后的字节应该位于结构块的开头偏移处，该偏移等于设备树 blob 标头中的 size_dt_struct 字段的值。</p>
<p><strong>（2）</strong><em><strong>*树状结构：*</strong></em></p>
<p>设备树的结构以线性树的形式表示。每个节点由 FDT_BEGIN_NODE 标记开始，由 FDT_END_NODE 标记结束。节点的属性和子节点在 FDT_END_NODE 之前表示，因此子节点的 FDT_BEGIN_NODE 和 FDT_END_NODE 令牌嵌套在父节点的令牌中。</p>
<p><strong>（3）</strong><em><strong>*结构块的结束*</strong></em></p>
<p>结构块以单个 FDT_END 标记结束。该标记没有额外的数据，它位于结构块的末尾，并且是结构块中的最后一个标记。FDT_END 标记之后的字节应位于结构块的开头偏移处，该偏移等于设备树 blob 标头中的 size_dt_struct 字段的值。</p>
<p>最后对结构块开头的部分内容进行讲解，具体内容如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps145.jpg" alt="img"> </p>
<table>
<thead>
<tr>
<th>十六进制数值</th>
<th>代表含义</th>
</tr>
</thead>
<tbody><tr>
<td>00000001</td>
<td>根节点的开始</td>
</tr>
<tr>
<td>00000000</td>
<td>根节点没有节点名，所以这里名字为0</td>
</tr>
<tr>
<td>00000003</td>
<td>设备树中属性的开始</td>
</tr>
<tr>
<td>00000017</td>
<td>代表该属性的大小，换算成十进制为23，也就是”This is my devicetree!”这一字符串的长度</td>
</tr>
<tr>
<td>00000000</td>
<td>代表该属性在字符串块的偏移量，这里为0，表示无偏移</td>
</tr>
<tr>
<td>54686973-65210000</td>
<td>model的具体值</td>
</tr>
</tbody></table>
<p>通过使用结构块，设备树可以以一种层次化的方式组织和描述系统中的设备和资源。每个节点可以包含属性和子节点，从而实现更加灵活和可扩展的设备树表示。</p>
<h2 id="62-4-字符串块"><a href="#62-4-字符串块" class="headerlink" title="62.4 字符串块"></a>62.4 字符串块</h2><p>字符串块用于存储设备树中使用的所有属性名称。它由一系列以空字符结尾的字符串组成，这些字符串在字符串块中简单地连接在一起，具体示例如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps146.jpg" alt="img"> </p>
<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em><em><strong>*字符串连接*</strong></em></p>
<p> 字符串块中的字符串以空字符（\0）作为终止符来连接。这意味着每个字符串都以空字符结尾，并且下一个字符串紧跟在上一个字符串的末尾。这种连接方式使得字符串块中的所有字符串形成一个连续的字符序列。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em><em><strong>*偏移量引用*</strong></em> </p>
<p>在结构块中，属性的名称是通过偏移量来引用字符串块中的相应字符串的。偏移量是一个无符号整数值，它表示字符串在字符串块中的位置。通过使用偏移量引用，设备树可以节省空间，并且在属性名称发生变化时也更加灵活，因为只需要更新偏移量，而不需要修改结构块中的属性引用。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em><em><strong>*对齐约束：*</strong></em></p>
<p>字符串块没有对齐约束，这意味着它可以出现在设备树 blob 的任何偏移处。这使得字符串块的位置在设备树 blob 中是灵活的，并且可以根据需要进行调整，而不会对设备树的解析和处理造成影响。</p>
<p>字符串块是设备树中用于存储属性名称的部分。它由字符串连接而成，并通过偏移量在结构块中进行引用。字符串块的灵活位置使得设备树的表示更加紧凑和可扩展。</p>
<h1 id="第63章-dtb展开成device-node实验"><a href="#第63章-dtb展开成device-node实验" class="headerlink" title="第63章 dtb展开成device_node实验"></a><strong>第63章</strong> dtb展开成device_node实验</h1><p>在上个小节中我们讲解了设备树deb的文件格式，那deb文件是怎样传递给内核的呢，那就进入到本小节的学习吧。</p>
<h2 id="63-1-dtb展开流程"><a href="#63-1-dtb展开流程" class="headerlink" title="63.1 dtb展开流程"></a>63.1 dtb展开流程</h2><p>dtb展开流程图如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps147.jpg" alt="img"> </p>
<p>接下来将会根据上图对deb的展开流程进行详细的讲解：</p>
<p>****（1）设备树源文件编写****：根据之前的章节中讲解的设备树的基本语法和相关知识编写符合规范的设备树。</p>
<p><em><strong>*（2）*</strong></em>****设备树编译：****设备树源文件经过设备树编译器（dtc）进行编译，生成设备树二进制文件（.dtb）。设备树编译器会检查源文件的语法和语义，并将其转换为二进制格式，以便内核能够解析和使用。</p>
<p><em><strong>*（3）b*</strong></em>****oot.img镜像生成****：boot.img是一个包含内核镜像、设备树二进制文件和其他一些资源文件的镜像文件（目前只是适用于瑞芯微的soc上，其他厂商的soc需要具体问题具体分析）。在生成boot.img时，通常会将内核镜像、设备树二进制文件和其他一些资源文件打包在一起。这个过程可以使用特定的工具或脚本完成。</p>
<p><em><strong>*（4）*</strong></em>****U-Boot加载：****U-Boot（Universal Bootloader）是一种常用的开源引导加载程序，用于引导嵌入式系统。在系统启动过程中，U-Boot会将boot.img中的内核和设备树的二进制文件加载到系统内存的特定地址。</p>
<p><em><strong>*（5）*</strong></em>****内核初始化：****U-Boot将内核和设备树的二进制文件加载到系统内存的特定地址后，控制权会转交给内核。在内核初始化的过程中，会解析设备树二进制文件，将其展开为内核可以识别的数据结构，以便内核能够正确地初始化和管理硬件资源。</p>
<p><em><strong>*（6）*</strong></em>****设备树展开：****设备树展开是指将设备树二进制文件解析成内核中的设备节点（device_node）的过程。内核会读取设备树二进制文件的内容，并根据设备树的描述信息，构建设备树数据结构，例如设备节点、中断控制器、寄存器、时钟等。这些设备树数据结构将在内核运行时用于管理和配置硬件资源。</p>
<p>而本章节要讲解的重点就在上面的第6步“设备树的展开”，最终设备树二进制文件会被解析成device_node，device_node结构体定义在内核源码的“&#x2F;include&#x2F;linux&#x2F;of.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;                <span class="comment">// 设备节点的名称</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *type;                <span class="comment">// 设备节点的类型</span></span><br><span class="line">	phandle phandle;                  <span class="comment">// 设备节点的句柄</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *full_name;           <span class="comment">// 设备节点的完整名称</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> <span class="title">fwnode</span>;</span>     <span class="comment">// 设备节点的固件节点句柄</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">properties</span>;</span>     <span class="comment">// 设备节点的属性列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">deadprops</span>;</span>      <span class="comment">// 已删除的属性列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">parent</span>;</span>      <span class="comment">// 父设备节点指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span>       <span class="comment">// 子设备节点指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">sibling</span>;</span>     <span class="comment">// 兄弟设备节点指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_KOBJ)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>             <span class="comment">// 内核对象（用于 sysfs）</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> _flags;            <span class="comment">// 设备节点的标志位</span></span><br><span class="line">	<span class="type">void</span> *data;                      <span class="comment">// 与设备节点相关的数据指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SPARC)</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *path_component_name; <span class="comment">// 设备节点的路径组件名称</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> unique_id;          <span class="comment">// 设备节点的唯一标识</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">of_irq_controller</span> *<span class="title">irq_trans</span>;</span> <span class="comment">// 设备节点的中断控制器</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后对该结构体的重要参数进行讲解：</p>
<p>（1）name：name 字段表示设备节点的名称。设备节点的名称是在设备树中唯一标识该节点的字符串。它通常用于在设备树中引用设备节点。</p>
<p>（2）type：type 字段表示设备节点的类型。设备节点的类型提供了关于设备节点功能和所属设备类别的信息。它可以用于识别设备节点的用途和特性。</p>
<p>（3）properties：properties 字段是指向设备节点属性列表的指针。设备节点的属性包含了与设备节点相关联的配置和参数信息。属性以键值对的形式存在，可以提供设备的特定属性、寄存器地址、中断信息等。property字段同样定义在内核源码的“&#x2F;include&#x2F;linux&#x2F;of.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> *name;                    <span class="comment">// 属性的名称</span></span><br><span class="line">	<span class="type">int</span> length;                    <span class="comment">// 属性值的长度（字节数）</span></span><br><span class="line">	<span class="type">void</span> *value;                   <span class="comment">// 属性值的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">next</span>;</span>         <span class="comment">// 下一个属性节点指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_DYNAMIC) || defined(CONFIG_SPARC)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> _flags;          <span class="comment">// 属性的标志位</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_PROMTREE)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> unique_id;        <span class="comment">// 属性的唯一标识</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_KOBJ)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bin_attribute</span> <span class="title">attr</span>;</span>     <span class="comment">// 内核对象二进制属性</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（4）parent：parent 字段指向父设备节点。设备树中的设备节点按照层次结构组织，父设备节点是当前设备节点的直接上级。通过 parent 字段，可以在设备树中遍历设备节点的父子关系。</p>
<p>（5）child：child 字段指向子设备节点。在设备树中，一个设备节点可以拥有多个子设备节点。通过 child 字段，可以遍历设备节点的所有子设备节点。</p>
<p>（6）sibling：sibling 字段指向兄弟设备节点。在设备树中，同一级别的兄弟设备节点共享相同的父设备节点。通过 sibling 字段，可以在同级设备节点之间进行遍历。</p>
<p>至此，关于device_node的相关讲解就完成了，虽然我们现在知道了，dtb文件最终会展开成device_node这一可以让内核识别的格式，那更具体的实现流程是怎样的呢，让我们进入下一小节的学习吧。</p>
<h2 id="63-2-dtb解析过程源码分析"><a href="#63-2-dtb解析过程源码分析" class="headerlink" title="63.2 dtb解析过程源码分析"></a>63.2 dtb解析过程源码分析</h2><p>首先来到源码目录下的“&#x2F;init&#x2F;main.c”文件，找到其中的start_kernel 函数，start_kernel 函数是 Linux 内核启动的入口点，它是Linux内核的核心函数之一，负责完成内核的初始化和启动过程，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __init <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *command_line;</span><br><span class="line">    <span class="type">char</span> *after_dashes;</span><br><span class="line"></span><br><span class="line">    set_task_stack_end_magic(&amp;init_task);    <span class="comment">// 设置任务栈的魔数</span></span><br><span class="line">    smp_setup_processor_id();    <span class="comment">// 设置处理器ID</span></span><br><span class="line">    debug_objects_early_init();    <span class="comment">// 初始化调试对象</span></span><br><span class="line">    cgroup_init_early();    <span class="comment">// 初始化cgroup（控制组）</span></span><br><span class="line"></span><br><span class="line">    local_irq_disable();    <span class="comment">// 禁用本地中断</span></span><br><span class="line">    early_boot_irqs_disabled = <span class="literal">true</span>;     <span class="comment">// 标记早期引导期间中断已禁用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 中断仍然被禁用。进行必要的设置，然后启用它们。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    boot_cpu_init();    <span class="comment">// 初始化引导CPU</span></span><br><span class="line">    page_address_init();    <span class="comment">// 设置页地址</span></span><br><span class="line">    pr_notice(<span class="string">&quot;%s&quot;</span>, linux_banner);    <span class="comment">// 打印Linux内核版本信息</span></span><br><span class="line">    setup_arch(&amp;command_line);    <span class="comment">// 架构相关的初始化</span></span><br><span class="line">    mm_init_cpumask(&amp;init_mm);    <span class="comment">// 初始化内存管理的cpumask（CPU掩码）</span></span><br><span class="line">    setup_command_line(command_line);    <span class="comment">// 设置命令行参数</span></span><br><span class="line">    setup_nr_cpu_ids();    <span class="comment">// 设置CPU个数</span></span><br><span class="line">    setup_per_cpu_areas();    <span class="comment">// 设置每个CPU的区域</span></span><br><span class="line">    smp_prepare_boot_cpu();    <span class="comment">// 准备启动CPU（架构特定的启动CPU钩子）</span></span><br><span class="line">    boot_cpu_hotplug_init();    <span class="comment">// 初始化热插拔的引导CPU</span></span><br><span class="line"></span><br><span class="line">    build_all_zonelists(<span class="literal">NULL</span>);    <span class="comment">// 构建所有内存区域列表</span></span><br><span class="line">    page_alloc_init();    <span class="comment">// 初始化页面分配器</span></span><br><span class="line">	........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中跟设备树相关的函数为第20行的 setup_arch**(&amp;<strong>command_line</strong>);**该函数定义在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;setup.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">setup_arch</span><span class="params">(<span class="type">char</span> **cmdline_p)</span></span><br><span class="line">&#123;</span><br><span class="line">	init_mm.start_code = (<span class="type">unsigned</span> <span class="type">long</span>) _text;</span><br><span class="line">	init_mm.end_code   = (<span class="type">unsigned</span> <span class="type">long</span>) _etext;</span><br><span class="line">	init_mm.end_data   = (<span class="type">unsigned</span> <span class="type">long</span>) _edata;</span><br><span class="line">	init_mm.brk	   = (<span class="type">unsigned</span> <span class="type">long</span>) _end;</span><br><span class="line"></span><br><span class="line">	*cmdline_p = boot_command_line;</span><br><span class="line"></span><br><span class="line">	early_fixmap_init();    <span class="comment">// 初始化 early fixmap</span></span><br><span class="line">	early_ioremap_init();    <span class="comment">// 初始化 early ioremap</span></span><br><span class="line"></span><br><span class="line">	setup_machine_fdt(__fdt_pointer);    <span class="comment">// 设置机器的 FDT（平台设备树）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化静态密钥，早期可能会被 cpufeature 代码和早期参数启用</span></span><br><span class="line">	jump_label_init();</span><br><span class="line">	parse_early_param();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在启动可能的早期控制台后，解除屏蔽异步中断和 FIQ（一旦我们可以报告发生的系统错误）</span></span><br><span class="line">	local_daif_restore(DAIF_PROCCTX_NOIRQ);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在这个阶段，TTBR0仅用于身份映射。将其指向零页面，以避免做出猜测性的新条目获取。</span></span><br><span class="line">	cpu_uninstall_idmap();</span><br><span class="line"></span><br><span class="line">	xen_early_init();    <span class="comment">// Xen 平台的早期初始化</span></span><br><span class="line">	efi_init();    <span class="comment">// EFI 平台的初始化</span></span><br><span class="line">	arm64_memblock_init();    <span class="comment">// ARM64 内存块的初始化</span></span><br><span class="line"></span><br><span class="line">	paging_init();    <span class="comment">// 分页初始化</span></span><br><span class="line"></span><br><span class="line">	acpi_table_upgrade();    <span class="comment">// ACPI 表的升级</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析 ACPI 表以进行可能的引导时配置</span></span><br><span class="line">	acpi_boot_table_init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (acpi_disabled)</span><br><span class="line">		unflatten_device_tree();    <span class="comment">// 展开设备树</span></span><br><span class="line"></span><br><span class="line">	bootmem_init();    <span class="comment">// 引导内存的初始化</span></span><br><span class="line">	............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在setup_arch函数中与设备树相关的函数分别为第13行的setup_machine_fdt(__fdt_pointer)和第37行的unflatten_device_tree()，接下来将对上述两个函数进行详细的介绍</p>
<p><strong>1.</strong> setup_machine_fdt(__fdt_pointer)</p>
<p>其中__fdt_pointer是dtb二进制文件加载到内存的地址，该地址由bootloader启动kernel时透过x0寄存器传递过来的，具体的汇编代码在内核源码目录下的“&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;head.S”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">preserve_boot_args:</span><br><span class="line">	mov	x21, x0				<span class="comment">// x21=FDT</span></span><br><span class="line"></span><br><span class="line">__primary_switched:</span><br><span class="line">	str_l	x21, __fdt_pointer, x5		<span class="comment">// Save FDT pointer</span></span><br></pre></td></tr></table></figure>

<p>第2行: 将寄存器 x0 的值复制到寄存器 x21。x0 寄存器中保存了一个指针，该指针指向设备树（Device Tree）。</p>
<p>第4行: 将寄存器 x21 的值存储到内存地址 __fdt_pointer 中。</p>
<p>然后来看setup_machine_fdt函数，该函数定义在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;setup.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化设置机器的设备树</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">setup_machine_fdt</span><span class="params">(<span class="type">phys_addr_t</span> dt_phys)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 将设备树物理地址映射到内核虚拟地址空间</span></span><br><span class="line">    <span class="type">void</span> *dt_virt = fixmap_remap_fdt(dt_phys, &amp;size, PAGE_KERNEL);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果映射成功</span></span><br><span class="line">    <span class="keyword">if</span> (dt_virt) &#123;</span><br><span class="line">        <span class="comment">// 保留设备树占用的内存区域</span></span><br><span class="line">        memblock_reserve(dt_phys, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设备树映射失败或者设备树解析失败</span></span><br><span class="line">    <span class="keyword">if</span> (!dt_virt || !early_init_dt_scan(dt_virt)) &#123;</span><br><span class="line">        <span class="comment">// 输出错误信息</span></span><br><span class="line">		pr_crit(<span class="string">&quot;\n&quot;</span></span><br><span class="line">			<span class="string">&quot;Error: invalid device tree blob at physical address %pa (virtual address 0x%p)\n&quot;</span></span><br><span class="line">			<span class="string">&quot;The dtb must be 8-byte aligned and must not exceed 2 MB in size\n&quot;</span></span><br><span class="line">			<span class="string">&quot;\nPlease check your bootloader.&quot;</span>,</span><br><span class="line">			&amp;dt_phys, dt_virt);</span><br><span class="line">        <span class="comment">// 无限循环，等待系统崩溃</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            cpu_relax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 早期修复完成，将设备树映射为只读模式</span></span><br><span class="line">    fixmap_remap_fdt(dt_phys, &amp;size, PAGE_KERNEL_RO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取设备树的机器名</span></span><br><span class="line">    name = of_flat_dt_get_machine_name();</span><br><span class="line">    <span class="comment">// 如果设备树没有机器名，则返回</span></span><br><span class="line">    <span class="keyword">if</span> (!name)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	    pr_info(<span class="string">&quot;Machine model: %s\n&quot;</span>, name); <span class="comment">// 输出机器型号信息</span></span><br><span class="line">    dump_stack_set_arch_desc(<span class="string">&quot;%s (DT)&quot;</span>, name); <span class="comment">// 设置栈转储的架构描述为机器型号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数用于在内核启动过程中设置机器的设备树。在此函数中，将执行以下步骤： </p>
<p>1.使用 fixmap_remap_fdt() 将设备树映射到内核虚拟地址空间中的 fixmap 区域。 </p>
<p>2.如果映射成功，则使用 memblock_reserve() 保留设备树占用的物理内存区域。 </p>
<p>3.检查设备树的有效性和完整性，通过调用early_init_dt_scan()进行早期扫描。 如果设备树无效或扫描失败，则会输出错误信息并进入死循环。 </p>
<p>4.早期修复已完成，现在将设备树映射为只读，通过调用 fixmap_remap_fdt() 实现。</p>
<p>5.获取设备树中的机器模型名称，通过调用 of_flat_dt_get_machine_name()。</p>
<p>6.如果机器模型名称存在，则输出机器模型的信息，并通过 dump_stack_set_arch_desc() 设置堆栈描述信息。</p>
<p>其中上面的第3步调用的early_init_dt_scan() 需要详细的讲解一下，该函数定义在内核源码的“drivers&#x2F;of&#x2F;fdt.c”目录下，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __init <span class="title function_">early_init_dt_scan</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证设备树的兼容性和完整性</span></span><br><span class="line">    status = early_init_dt_verify(params);</span><br><span class="line">    <span class="keyword">if</span> (!status)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描设备树节点</span></span><br><span class="line">    early_init_dt_scan_nodes();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，调用 early_init_dt_verify() 函数对设备树进行兼容性和完整性验证。该函数可能会检查设备树中的一致性标记、版本信息以及必需的节点和属性是否存在。如果验证失败，函数会返回 false。该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __init <span class="title function_">early_init_dt_verify</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 验证传入的参数是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!params)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查设备树头部的有效性</span></span><br><span class="line">    <span class="comment">// 如果设备树头部无效，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (fdt_check_header(params))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置指向设备树的指针为传入的参数</span></span><br><span class="line">    initial_boot_params = params;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算设备树的 CRC32 校验值</span></span><br><span class="line">    <span class="comment">// 并将结果保存在全局变量 of_fdt_crc32 中</span></span><br><span class="line">    of_fdt_crc32 = crc32_be(~<span class="number">0</span>, initial_boot_params, fdt_totalsize(initial_boot_params));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 true，表示设备树验证和初始化成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第4行：该进行参数的有效性检查，如果 params 为空，则直接返回 false，表示参数无效。</p>
<p>第9行：检查设备树头部的有效性。fdt_check_header 是一个用于检查设备树头部的函数，如果设备树头部无效，则返回 false，表示设备树不合法。</p>
<p>第13行：如果设备树头部有效，程序继续执行，将传入的 params 赋值给全局变量 initial_boot_params，用来保存设备树的指针。</p>
<p>第17行，使用 crc32_be 函数计算设备树的 CRC32 校验值，其中 crc32_be 是一个用于计算 CRC32 校验值的函数，~0 表示初始值为全1的位模式。计算完成后，将结果保存在全局变量 of_fdt_crc32 中。</p>
<p>然后继续回到early_init_dt_scan() 函数中，如果设备树验证成功（即 status 为真），则调用 early_init_dt_scan_nodes() 函数。这个函数的作用是扫描设备树的节点并进行相应的处理，该函数的具体内容如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">early_init_dt_scan_nodes</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 从 /chosen 节点中检索各种信息 */</span></span><br><span class="line">	of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化 &#123;size,address&#125;-cells 信息 */</span></span><br><span class="line">	of_scan_flat_dt(early_init_dt_scan_root, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置内存信息，调用 early_init_dt_add_memory_arch 函数 */</span></span><br><span class="line">	of_scan_flat_dt(early_init_dt_scan_memory, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数early_init_dt_scan_nodes被声明为__init，这表示它是在内核初始化阶段被调用，并且在初始化完成后不再需要。该函数的目的是在早期阶段扫描设备树节点，并执行一些初始化操作。</p>
<p>函数中主要调用了of_scan_flat_dt函数，该函数用于扫描平面设备树（flat device tree）。平面设备树是一种将设备树以紧凑形式表示的数据结构，它不使用树状结构，而是使用线性结构，以节省内存空间。</p>
<p>具体来看，early_init_dt_scan_nodes函数的执行步骤如下：</p>
<p>（1）of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line)：从设备树的&#x2F;chosen节点中检索各种信息。&#x2F;chosen节点通常包含了一些系统的全局配置参数，比如命令行参数。early_init_dt_scan_chosen是一个回调函数，用于处理&#x2F;chosen节点的信息。boot_command_line是一个参数，表示内核启动时的命令行参数。</p>
<p>（2）of_scan_flat_dt(early_init_dt_scan_root, NULL)：初始化{size,address}-cells信息。{size,address}-cells描述了设备节点中地址和大小的编码方式。early_init_dt_scan_root是一个回调函数，用于处理设备树的根节点。</p>
<p>（3）of_scan_flat_dt(early_init_dt_scan_memory, NULL)：设置内存信息，并调用early_init_dt_add_memory_arch函数。这个步骤主要用于在设备树中获取内存的相关信息，并将其传递给内核的内存管理模块。early_init_dt_scan_memory是一个回调函数，用于处理内存信息。</p>
<p>至此，关于setup_machine_fdt(__fdt_pointer)代码的分析就完成了。</p>
<p><strong>2.</strong> <em><strong>*unflatten_device_tree*</strong></em></p>
<p>该函数用于解析设备树，将紧凑的设备树数据结构转换为树状结构的设备树，该函数定义在内核源码目录下的“&#x2F;drivers&#x2F;of&#x2F;fdt.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">unflatten_device_tree</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 解析设备树 */</span></span><br><span class="line">    __unflatten_device_tree(initial_boot_params, <span class="literal">NULL</span>, &amp;of_root,</span><br><span class="line">                            early_init_dt_alloc_memory_arch, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取指向 &quot;/chosen&quot; 和 &quot;/aliases&quot; 节点的指针，以供全局使用 */</span></span><br><span class="line">    of_alias_scan(early_init_dt_alloc_memory_arch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 运行设备树的单元测试 */</span></span><br><span class="line">    unittest_unflatten_overlay_base();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数主要用于解析设备树，并将解析后的设备树存储在全局变量of_root中。</p>
<p>函数首先调用__unflatten_device_tree函数来执行设备树的解析操作。解析后的设备树将使用of_root指针进行存储。</p>
<p>接下来，函数调用of_alias_scan函数。这个函数用于扫描设备树中的&#x2F;chosen和&#x2F;aliases节点，并为它们分配内存。这样，其他部分的代码可以通过全局变量访问这些节点。</p>
<p>最后，函数调用unittest_unflatten_overlay_base函数，用于运行设备树的单元测试。</p>
<p>然后对__unflatten_device_tree这一设备树的解析函数进行详细的介绍，该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__unflatten_device_tree(<span class="type">const</span> <span class="type">void</span> *blob,</span><br><span class="line">		      <span class="keyword">struct</span> device_node *dad,</span><br><span class="line">			      <span class="keyword">struct</span> device_node **mynodes,</span><br><span class="line">			      <span class="type">void</span> *(*dt_alloc)(u64 size, u64 align),</span><br><span class="line">			      <span class="type">bool</span> detached)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	<span class="type">void</span> *mem;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot; -&gt; unflatten_device_tree()\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!blob) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;No device tree pointer\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;Unflattening device tree:\n&quot;</span>);</span><br><span class="line">	pr_debug(<span class="string">&quot;magic: %08x\n&quot;</span>, fdt_magic(blob));</span><br><span class="line">	pr_debug(<span class="string">&quot;size: %08x\n&quot;</span>, fdt_totalsize(blob));</span><br><span class="line">	pr_debug(<span class="string">&quot;version: %08x\n&quot;</span>, fdt_version(blob));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fdt_check_header(blob)) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;Invalid device tree blob header\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 第一遍扫描，计算大小 */</span></span><br><span class="line">	size = unflatten_dt_nodes(blob, <span class="literal">NULL</span>, dad, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (size &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	size = ALIGN(size, <span class="number">4</span>);</span><br><span class="line">	pr_debug(<span class="string">&quot;  大小为 %d，正在分配内存...\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 为展开的设备树分配内存 */</span></span><br><span class="line">	mem = dt_alloc(size + <span class="number">4</span>, <span class="keyword">alignof</span>(<span class="keyword">struct</span> device_node));</span><br><span class="line">	<span class="keyword">if</span> (!mem)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(mem, <span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line">	*(__be32 *)(mem + size) = cpu_to_be32(<span class="number">0xdeadbeef</span>);</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;  正在展开 %p...\n&quot;</span>, mem);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 第二遍扫描，实际展开设备树 */</span></span><br><span class="line">	unflatten_dt_nodes(blob, mem, dad, mynodes);</span><br><span class="line">	<span class="keyword">if</span> (be32_to_cpup(mem + size) != <span class="number">0xdeadbeef</span>)</span><br><span class="line">		pr_warning(<span class="string">&quot;End of tree marker overwritten: %08x\n&quot;</span>,</span><br><span class="line">			   be32_to_cpup(mem + size));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (detached &amp;&amp; mynodes) &#123;</span><br><span class="line">		of_node_set_flag(*mynodes, OF_DETACHED);</span><br><span class="line">		pr_debug(<span class="string">&quot;unflattened tree is detached\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot; &lt;- unflatten_device_tree()\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的重点在两次设备树的扫描上，第一遍扫描的目的是计算展开设备树所需的内存大小。</p>
<p>第29行：unflatten_dt_nodes函数的作用是递归地遍历设备树数据块，并计算展开设备树所需的内存大小。它接受四个参数：blob（设备树数据块指针）、start（当前节点的起始地址，初始为NULL）、dad（父节点指针）和mynodes（用于存储节点指针数组的指针，初始为NULL）。</p>
<p>第一遍扫描完成后，unflatten_dt_nodes函数会返回展开设备树所需的内存大小，然后在对大小进行对齐操作，并为展开的设备树分配内存。</p>
<p>第二遍扫描的目的是实际展开设备树，并填充设备节点的名称、类型和属性等信息。</p>
<p>第49行：再次调用了unflatten_dt_nodes函数进行第二遍扫描。通过这样的过程，第二遍扫描会将设备树数据块中的节点展开为真正的设备节点，并填充节点的名称、类型和属性等信息。这样就完成了设备树的展开过程。</p>
<p>最后我们来对unflatten_dt_nodes函数内容进行一下深究，unflatten_dt_nodes函数具体定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">unflatten_dt_nodes</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *blob,</span></span><br><span class="line"><span class="params">			      <span class="type">void</span> *mem,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> device_node *dad,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> device_node **nodepp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">root</span>;</span>  <span class="comment">// 根节点</span></span><br><span class="line">	<span class="type">int</span> offset = <span class="number">0</span>, depth = <span class="number">0</span>, initial_depth = <span class="number">0</span>;  <span class="comment">// 偏移量、深度和初始深度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_MAX_DEPTH	64  <span class="comment">// 最大深度</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nps</span>[<span class="title">FDT_MAX_DEPTH</span>];</span>  <span class="comment">// 设备节点数组</span></span><br><span class="line">	<span class="type">void</span> *base = mem;  <span class="comment">// 基地址，用于计算偏移量</span></span><br><span class="line">	<span class="type">bool</span> dryrun = !base;  <span class="comment">// 是否只是模拟运行，不实际处理</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nodepp)</span><br><span class="line">		*nodepp = <span class="literal">NULL</span>;  <span class="comment">// 如果指针不为空，将其置为空指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果 @dad 有效，则表示正在展开设备子树。</span></span><br><span class="line"><span class="comment">	 * 在第一层深度可能有多个节点。</span></span><br><span class="line"><span class="comment">	 * 将 @depth 设置为 1，以使 fdt_next_node() 正常工作。</span></span><br><span class="line"><span class="comment">	 * 当发现负的 @depth 时，该函数会立即退出。</span></span><br><span class="line"><span class="comment">	 * 否则，除第一个节点外的设备节点将无法成功展开。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dad)</span><br><span class="line">		depth = initial_depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	root = dad;  <span class="comment">// 根节点为 @dad</span></span><br><span class="line">	nps[depth] = dad;  <span class="comment">// 将根节点放入设备节点数组</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (offset = <span class="number">0</span>;</span><br><span class="line">	     offset &gt;= <span class="number">0</span> &amp;&amp; depth &gt;= initial_depth;</span><br><span class="line">	     offset = fdt_next_node(blob, offset, &amp;depth)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(depth &gt;= FDT_MAX_DEPTH))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果未启用 CONFIG_OF_KOBJ 并且节点不可用，则跳过该节点</span></span><br><span class="line">		<span class="keyword">if</span> (!IS_ENABLED(CONFIG_OF_KOBJ) &amp;&amp;</span><br><span class="line">		    !of_fdt_device_is_available(blob, offset))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 填充节点信息，并将子节点添加到设备节点数组</span></span><br><span class="line">		<span class="keyword">if</span> (!populate_node(blob, offset, &amp;mem, nps[depth],</span><br><span class="line">				   &amp;nps[depth+<span class="number">1</span>], dryrun))</span><br><span class="line">			<span class="keyword">return</span> mem - base;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!dryrun &amp;&amp; nodepp &amp;&amp; !*nodepp)</span><br><span class="line">			*nodepp = nps[depth+<span class="number">1</span>];  <span class="comment">// 将子节点指针赋值给 @nodepp</span></span><br><span class="line">		<span class="keyword">if</span> (!dryrun &amp;&amp; !root)</span><br><span class="line">			root = nps[depth+<span class="number">1</span>];  <span class="comment">// 如果根节点为空，则将子节点设置为根节点</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset &lt; <span class="number">0</span> &amp;&amp; offset != -FDT_ERR_NOTFOUND) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;Error %d processing FDT\n&quot;</span>, offset);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 反转子节点列表。一些驱动程序假设节点顺序与 .dts 文件中的节点顺序一致</span></span><br><span class="line">	<span class="keyword">if</span> (!dryrun)</span><br><span class="line">		reverse_nodes(root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mem - base;  <span class="comment">// 返回处理的字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unflatten_dt_nodes 函数的作用我们在上面已经讲解过了，这里重点介绍第31行的 fdt_next_node()函数和第41行的populate_node函数。</p>
<p>fdt_next_node() 函数用来遍历设备树的节点。从偏移量为 0 开始，只要偏移量大于等于 0 且深度大于等于初始深度，就执行循环。循环中的每次迭代都会处理一个设备树节点。</p>
<p>在每次迭代中，首先检查深度是否超过了最大深度 FDT_MAX_DEPTH，如果超过了，则跳过该节点。</p>
<p>如果未启用 CONFIG_OF_KOBJ 并且节点不可用（通过 of_fdt_device_is_available() 函数判断），则跳过该节点。</p>
<p>随后调用 populate_node() 函数填充节点信息，并将子节点添加到设备节点数组 nps 中。 populate_node() 函数定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">populate_node</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *blob,</span></span><br><span class="line"><span class="params">			  <span class="type">int</span> offset,</span></span><br><span class="line"><span class="params">			  <span class="type">void</span> **mem,</span></span><br><span class="line"><span class="params">			  <span class="keyword">struct</span> device_node *dad,</span></span><br><span class="line"><span class="params">			  <span class="keyword">struct</span> device_node **pnp,</span></span><br><span class="line"><span class="params">			  <span class="type">bool</span> dryrun)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span>  <span class="comment">// 设备节点指针</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *pathp;  <span class="comment">// 节点路径字符串指针</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> l, allocl;  <span class="comment">// 路径字符串长度和分配的内存大小</span></span><br><span class="line"></span><br><span class="line">	pathp = fdt_get_name(blob, offset, &amp;l);  <span class="comment">// 获取节点路径和长度</span></span><br><span class="line">	<span class="keyword">if</span> (!pathp) &#123;</span><br><span class="line">		*pnp = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	allocl = ++l;  <span class="comment">// 分配内存大小为路径长度加一，用于存储节点路径字符串</span></span><br><span class="line"></span><br><span class="line">	np = unflatten_dt_alloc(mem, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> device_node) + allocl,</span><br><span class="line">				__alignof__(<span class="keyword">struct</span> device_node));  <span class="comment">// 分配设备节点内存</span></span><br><span class="line">	<span class="keyword">if</span> (!dryrun) &#123;</span><br><span class="line">		<span class="type">char</span> *fn;</span><br><span class="line">		of_node_init(np);  <span class="comment">// 初始化设备节点</span></span><br><span class="line">		np-&gt;full_name = fn = ((<span class="type">char</span> *)np) + <span class="keyword">sizeof</span>(*np);  <span class="comment">// 设置设备节点的完整路径名</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">memcpy</span>(fn, pathp, l);  <span class="comment">// 将节点路径字符串复制到设备节点的完整路径名中</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dad != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			np-&gt;parent = dad;  <span class="comment">// 设置设备节点的父节点</span></span><br><span class="line">			np-&gt;sibling = dad-&gt;child;  <span class="comment">// 设置设备节点的兄弟节点</span></span><br><span class="line">			dad-&gt;child = np;  <span class="comment">// 将设备节点添加为父节点的子节点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	populate_properties(blob, offset, mem, np, pathp, dryrun);  <span class="comment">// 填充设备节点的属性信息</span></span><br><span class="line">	<span class="keyword">if</span> (!dryrun) &#123;</span><br><span class="line">		np-&gt;name = of_get_property(np, <span class="string">&quot;name&quot;</span>, <span class="literal">NULL</span>);  <span class="comment">// 获取设备节点的名称属性</span></span><br><span class="line">		np-&gt;type = of_get_property(np, <span class="string">&quot;device_type&quot;</span>, <span class="literal">NULL</span>);  <span class="comment">// 获取设备节点的设备类型属性</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!np-&gt;name)</span><br><span class="line">			np-&gt;name = <span class="string">&quot;&lt;NULL&gt;&quot;</span>;  <span class="comment">// 如果设备节点没有名称属性，则设置为&quot;&lt;NULL&gt;&quot;</span></span><br><span class="line">		<span class="keyword">if</span> (!np-&gt;type)</span><br><span class="line">			np-&gt;type = <span class="string">&quot;&lt;NULL&gt;&quot;</span>;  <span class="comment">// 如果设备节点没有设备类型属性，则设置为&quot;&lt;NULL&gt;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*pnp = np;  <span class="comment">// 将设备节点指针赋值给*pnp</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在populate_node 函数中首先会调用第18行的 unflatten_dt_alloc 函数分配设备节点内存。分配的内存大小为 sizeof(struct device_node) + allocl 字节，并使用 <strong>alignof</strong>(struct device_node) 对齐。然后调用 populate_properties 函数填充设备节点的属性信息。该函数会解析设备节点的属性，并根据需要分配内存来存储属性值。</p>
<p>至此，关于dtb二进制文件的解析过程就讲解完成了，完整的源码分析流程图如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps148.jpg" alt="img"> </p>
<h1 id="第64章-device-node转换成platform-device实验"><a href="#第64章-device-node转换成platform-device实验" class="headerlink" title="第64章  device_node转换成platform_device实验"></a>第64章  device_node转换成platform_device实验</h1><p>在上一章中，我们学习了dtb二进制文件展开成device_node的具体流程，而device_node这时候还并不能跟内核中的platform_driver进行对接，而为了让操作系统能够识别和管理设备，需要将设备节点转换为平台设备。</p>
<h2 id="64-1-转换规格"><a href="#64-1-转换规格" class="headerlink" title="64.1 转换规格"></a>64.1 转换规格</h2><p>在之前学习的平台总线模型中，device部分是用platform_device结构体来描述硬件资源的，所以内核最终会将内核认识的device_node树转换platform_ device，但是并不是所有的device_node都会被转换成platform_ device，只有满足要求的才会转换成platform_ device,转换成platform_device的节点可以在&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;devices下查看，那device_node节点要满足什么要求才会被转换成platform_device呢? </p>
<p>根据规则1，首先遍历根节点下包含 compatible 属性的子节点，对于每个子节点，创建一个对应的 platform_device。</p>
<p>根据规则2，遍历包含 compatible 属性为 “simple-bus”、”simple-mfd” 或 “isa” 的节点以及它们的子节点。如果子节点包含 compatible 属性值则会创建一个对应的platform_device。</p>
<p>根据规则3，检查节点的 compatible 属性是否包含 “arm” 或 “primecell”。如果是，则不将该节点转换为 platform_device，而是将其识别为 AMBA 设备。</p>
<p>接下来将通过几个设备树示例对上述规则进行实践。</p>
<p><em><strong>*举例1：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = <span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0, 115200&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a35&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x1</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    aliases &#123;</span><br><span class="line">        led1 = <span class="string">&quot;/gpio@22020101&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node1 &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">        gpio@<span class="number">22020102</span> &#123;</span><br><span class="line">            reg = &lt;<span class="number">0x20220102</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node2 &#123;</span><br><span class="line">        node1-child &#123;</span><br><span class="line">            pinnum = &lt;<span class="number">01234</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@<span class="number">22020101</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;led&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x20220101</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的设备树中，总共有chosen、cpu1: cpu@1、aliases、node1、node2、gpio@22020101</p>
<p>这六个节点，其中前五个节点都没有compatible属性，所以并不会被转换为platform_device，而最后一个gpio@22020101节点符合规则一，在根节点下，且有compatible属性，所以最后会转换为platform_device。</p>
<p><em><strong>*举例2：*</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = &quot;This is my devicetree!&quot;;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;1&gt;;</span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = &quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0, 115200&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@1 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a35&quot;, &quot;arm,armv8&quot;;</span><br><span class="line">        reg = &lt;0x0 0x1&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    aliases &#123;</span><br><span class="line">        led1 = &quot;/gpio@22020101&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node1 &#123;</span><br><span class="line">        #address-cells = &lt;1&gt;;</span><br><span class="line">        #size-cells = &lt;1&gt;;</span><br><span class="line">		    compatible = &quot;simple-bus&quot;;</span><br><span class="line">        gpio@22020102 &#123;</span><br><span class="line">            reg = &lt;0x20220102 0x40&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node2 &#123;</span><br><span class="line">        node1-child &#123;</span><br><span class="line">            pinnum = &lt;01234&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@22020101 &#123;</span><br><span class="line">        compatible = &quot;led&quot;;</span><br><span class="line">        reg = &lt;0x20220101 0x40&gt;;</span><br><span class="line">        status = &quot;okay&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相较于示例1的设备树，这里在node1节点中添加了 compatible 属性，但是这个compatible属性值为simple-bus，我们需要继续看他的子节点，子节点 gpio@22020102 并没有compatible属性值，所以这里的node1节点不会被转换。</p>
<p><em><strong>*举例3：*</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = &quot;This is my devicetree!&quot;;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;1&gt;;</span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = &quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0, 115200&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@1 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a35&quot;, &quot;arm,armv8&quot;;</span><br><span class="line">        reg = &lt;0x0 0x1&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    aliases &#123;</span><br><span class="line">        led1 = &quot;/gpio@22020101&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node1 &#123;</span><br><span class="line">        #address-cells = &lt;1&gt;;</span><br><span class="line">        #size-cells = &lt;1&gt;;</span><br><span class="line">		    compatible = &quot;simple-bus&quot;;</span><br><span class="line">        gpio@22020102 &#123;</span><br><span class="line">			compatible = &quot;gpio&quot;;</span><br><span class="line">            reg = &lt;0x20220102 0x40&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node2 &#123;</span><br><span class="line">        node1-child &#123;</span><br><span class="line">            pinnum = &lt;01234&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@22020101 &#123;</span><br><span class="line">        compatible = &quot;led&quot;;</span><br><span class="line">        reg = &lt;0x20220101 0x40&gt;;</span><br><span class="line">        status = &quot;okay&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相较于示例2的设备树，这里在node1节点的子节点 gpio@22020102 中添加了 compatible 属性，node1节点的compatible属性值为simple-bus，然后需要继续看他的子节点，子节点 gpio@22020102 的compatible属性值为gpio，所以这里的gpio@22020102节点会被转换成platform_device。</p>
<p><em><strong>*举例4：*</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = &quot;This is my devicetree!&quot;;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;1&gt;;</span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = &quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0,115200&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpul: cpu@1 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a35&quot;, &quot;arm,armv8&quot;;</span><br><span class="line">        reg = &lt;0x0 0x1&gt;;</span><br><span class="line"></span><br><span class="line">        amba &#123;</span><br><span class="line">            compatible = &quot;simple-bus&quot;;</span><br><span class="line">            #address-cells = &lt;2&gt;;</span><br><span class="line">            #size-cells = &lt;2&gt;;</span><br><span class="line">            ranges;</span><br><span class="line"></span><br><span class="line">            dmac_peri: dma-controller@ff250000 &#123;</span><br><span class="line">                compatible = &quot;arm,p1330&quot;, &quot;arm,primecell&quot;;</span><br><span class="line">                reg = &lt;0x0 0xff250000 0x0 0x4000&gt;;</span><br><span class="line">                interrupts = &lt;GIC_SPI 2 IRQ_TYPE_LEVEL_HIGH&gt;,</span><br><span class="line">                             &lt;GIC_SPI 3 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">                #dma-cells = &lt;1&gt;;</span><br><span class="line">                arm,pl330-broken-no-flushp;</span><br><span class="line">                arm,p1330-periph-burst;</span><br><span class="line">                clocks = &lt;&amp;cru ACLK DMAC_PERI&gt;;</span><br><span class="line">                clock-names = &quot;apb_pclk&quot;;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            dmac_bus: dma-controller@ff600000 &#123;</span><br><span class="line">                compatible = &quot;arm,p1330&quot;, &quot;arm,primecell&quot;;</span><br><span class="line">                reg = &lt;0x0 0xff600000 0x0 0x4000&gt;;</span><br><span class="line">                interrupts = &lt;GIC_SPI 0 IRQ_TYPE_LEVEL_HIGH&gt;,</span><br><span class="line">                             &lt;GIC_SPI 1 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">                #dma-cells = &lt;1&gt;;</span><br><span class="line">                arm,pl330-broken-no-flushp;</span><br><span class="line">                arm,pl330-periph-burst;</span><br><span class="line">                clocks = &lt;&amp;cru ACLK_DMAC_BUS&gt;;</span><br><span class="line">                clock-names = &quot;apb_pclk&quot;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>amba 节点的compatible值为simple-bus，不会被转换为 platform_device，而是作为父节点用于组织其他设备，所以需要来查看他的子节点。</p>
<p>dmac_peri: dma-controller@ff250000 节点: 该节点的 compatible 属性包含 “arm,p1330” 和 “arm,primecell”，根据规则3，该节点不会被转换为 platform_device，而是被识别为 AMBA 设备。</p>
<p>dmac_bus: dma-controller@ff600000 节点: 该节点的 compatible 属性包含 “arm,p1330” 和 “arm,primecell”，根据规则3，该节点不会被转换为 platform_device，而是被识别为 AMBA 设备。</p>
<h2 id="64-2-转换流程源码分析"><a href="#64-2-转换流程源码分析" class="headerlink" title="64.2 转换流程源码分析"></a>64.2 转换流程源码分析</h2><p>首先进入到内核源码目录下的“drivers&#x2F;of&#x2F;platform.c”文件中，找到第555行，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch_initcall_sync(of_platform_default_populate_init);</span><br></pre></td></tr></table></figure>

<p>arch_initcall_sync 是 Linux 内核中的一个函数，用于在内核初始化过程中执行架构相关的初始化函数。它属于内核的初始化调用机制，用于确保在系统启动过程中适时地调用特定架构的初始化函数。</p>
<p>在Linux内核的初始化过程中，各个子系统和架构会注册自己的初始化函数。这些初始化函数负责完成特定子系统或架构相关的初始化工作，例如初始化硬件设备、注册中断处理程序、设置内存映射等。而 arch_initcall_sync 函数则用于调用与当前架构相关的初始化函数。</p>
<p>当内核启动时，调用 rest_init() 函数来启动初始化过程。在初始化过程中，arch_initcall_sync 函数会被调用，以确保所有与当前架构相关的初始化函数按照正确的顺序执行。这样可以保证在启动过程中，特定架构相关的初始化工作得到正确地完成。</p>
<p>而of_platform_default_populate_init函数的作用是在内核初始化过程中自动解析设备树，并根据设备树中的设备节点创建对应的 platform_device 结构。它会遍历设备树中的设备节点，并为每个设备节点创建一个对应的 platform_device 结构，然后将其注册到内核中，使得设备驱动程序能够识别和操作这些设备。该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">of_platform_default_populate_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂停设备链接供应商同步状态</span></span><br><span class="line">    device_links_supplier_sync_state_pause();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设备树尚未填充，则返回错误码</span></span><br><span class="line">    <span class="keyword">if</span> (!of_have_populated_dt())</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 显式处理某些兼容性，因为我们不想为/reserved-memory中的每个具有“compatible”的节点创建platform_device。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    for_each_matching_node(node, reserved_mem_matches)</span><br><span class="line">        of_platform_device_create(node, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找节点 &quot;/firmware&quot;</span></span><br><span class="line">    node = of_find_node_by_path(<span class="string">&quot;/firmware&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="comment">// 使用该节点进行设备树平台设备的填充</span></span><br><span class="line">        of_platform_populate(node, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        of_node_put(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充其他设备</span></span><br><span class="line">    fw_devlink_pause();</span><br><span class="line">    of_platform_default_populate(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    fw_devlink_resume();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第6行：暂停设备链接供应商的同步状态，确保设备链接的状态不会在此过程中被改变。</p>
<p>第9行：检查设备树是否已经被填充。如果设备树尚未填充，则返回错误码 -ENODEV。</p>
<p>第16行：遍历设备树中与 reserved_mem_matches 匹配的节点。这些节点是 &#x2F;reserved-memory 中具有 “compatible” 属性的节点。</p>
<p>第17行：为 &#x2F;reserved-memory 中匹配的节点创建 platform_device 结构。这些节点不会为每个节点都创建 platform_device，而是根据需要进行显式处理。</p>
<p>第20行：在设备树中查找路径为 “&#x2F;firmware” 的节点。</p>
<p>第23行：使用找到的节点填充设备树中的平台设备。这些节点可能包含与固件相关的设备。</p>
<p>第28行：暂停固件设备链接，确保在填充其他设备时链接状态不会改变。</p>
<p>第29行：填充设备树中的其他设备。</p>
<p>第30行：恢复固件设备链接。</p>
<p>上诉内容中我们要着重关注的是第29行的of_platform_default_populate(NULL, NULL, NULL)函数，找到该函数的定义之后如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int of_platform_default_populate(struct device_node *root,</span><br><span class="line">				 const struct of_dev_auxdata *lookup,</span><br><span class="line">				 struct device *parent)</span><br><span class="line">&#123;</span><br><span class="line">	return of_platform_populate(root, of_default_bus_match_table, lookup,</span><br><span class="line">				    parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的作用是调用 of_platform_populate 函数来填充设备树中的平台设备，并使用默认的设备匹配表 of_default_bus_match_table，设备匹配表内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_default_bus_match_table</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;simple-bus&quot;</span>, &#125;,</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;simple-mfd&quot;</span>, &#125;,</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;isa&quot;</span>, &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM_AMBA</span></span><br><span class="line">	&#123; .compatible = <span class="string">&quot;arm,amba-bus&quot;</span>, &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_ARM_AMBA */</span></span></span><br><span class="line">	&#123;&#125; <span class="comment">/* Empty terminated list */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述的设备匹配表就是我们在第一小节中第2条规则，，函数将自动根据设备树节点的属性匹配相应的设备驱动程序，并填充内核的平台设备列表。接下来找到of_platform_populate函数的定义，该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_platform_populate</span><span class="params">(<span class="keyword">struct</span> device_node *root,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> of_device_id *matches,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> of_dev_auxdata *lookup,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> device *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span></span><br><span class="line">	<span class="type">int</span> rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 root 不为空，则增加 root 节点的引用计数；否则，在设备树中根据路径查找 root 节点</span></span><br><span class="line">	root = root ? of_node_get(root) : of_find_node_by_path(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!root)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;%s()\n&quot;</span>, __func__);</span><br><span class="line">	pr_debug(<span class="string">&quot; starting at: %pOF\n&quot;</span>, root);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 暂停设备链接供应商同步状态</span></span><br><span class="line">	device_links_supplier_sync_state_pause();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历 root 节点的所有子节点</span></span><br><span class="line">	for_each_child_of_node(root, child) &#123;</span><br><span class="line">		<span class="comment">// 创建平台设备并添加到设备树总线</span></span><br><span class="line">		rc = of_platform_bus_create(child, matches, lookup, parent, <span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">if</span> (rc) &#123;</span><br><span class="line">			of_node_put(child);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 恢复设备链接供应商同步状态</span></span><br><span class="line">	device_links_supplier_sync_state_resume();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置 root 节点的 OF_POPULATED_BUS 标志</span></span><br><span class="line">	of_node_set_flag(root, OF_POPULATED_BUS);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放 root 节点的引用计数</span></span><br><span class="line">	of_node_put(root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的具体执行步骤如下：</p>
<p>第10行：检查给定的设备树节点 node 是否为有效节点。如果节点为空，函数将立即返回。</p>
<p>第21行：遍历设备树节点的子节点，查找与平台设备相关的节点。这些节点通常具有 compatible 属性，用于匹配设备驱动程序。</p>
<p>第23行：对于每个找到的平台设备节点，创建一个 platform_device 结构，并根据设备树节点的属性设置该结构的各个字段。</p>
<p>第25行：将创建的 platform_device 添加到内核的平台设备列表中，以便设备驱动程序能够识别和操作这些设备。</p>
<p>接下来对该函数的第23行核心代码of_platform_bus_create(child, matches, lookup, parent, true)函数进行讲解，该函数的具体定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">static int of_platform_bus_create(struct device_node *bus,</span><br><span class="line">				  const struct of_device_id *matches,</span><br><span class="line">				  const struct of_dev_auxdata *lookup,</span><br><span class="line">				  struct device *parent, bool strict)</span><br><span class="line">&#123;</span><br><span class="line">	const struct of_dev_auxdata *auxdata;</span><br><span class="line">	struct device_node *child;</span><br><span class="line">	struct platform_device *dev;</span><br><span class="line">	const char *bus_id = NULL;</span><br><span class="line">	void *platform_data = NULL;</span><br><span class="line">	int rc = 0;</span><br><span class="line"></span><br><span class="line">	/* 确保设备节点具有 compatible 属性 */</span><br><span class="line">	if (strict &amp;&amp; (!of_get_property(bus, &quot;compatible&quot;, NULL))) &#123;</span><br><span class="line">		pr_debug(&quot;%s() - skipping %pOF, no compatible prop\n&quot;,</span><br><span class="line">			 __func__, bus);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 跳过不想创建设备的节点 */</span><br><span class="line">	if (unlikely(of_match_node(of_skipped_node_table, bus))) &#123;</span><br><span class="line">		pr_debug(&quot;%s() - skipping %pOF node\n&quot;, __func__, bus);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	if (of_node_check_flag(bus, OF_POPULATED_BUS)) &#123;</span><br><span class="line">		pr_debug(&quot;%s() - skipping %pOF, already populated\n&quot;,</span><br><span class="line">			__func__, bus);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	auxdata = of_dev_lookup(lookup, bus);</span><br><span class="line">	if (auxdata) &#123;</span><br><span class="line">		bus_id = auxdata-&gt;name;</span><br><span class="line">		platform_data = auxdata-&gt;platform_data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (of_device_is_compatible(bus, &quot;arm,primecell&quot;)) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * 在此处不返回错误以保持与旧设备树文件的兼容性。</span><br><span class="line">		 */</span><br><span class="line">		of_amba_device_create(bus, bus_id, platform_data, parent);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent);</span><br><span class="line">	if (!dev || !of_match_node(matches, bus))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	for_each_child_of_node(bus, child) &#123;</span><br><span class="line">		pr_debug(&quot;   create child: %pOF\n&quot;, child);</span><br><span class="line">		rc = of_platform_bus_create(child, matches, lookup, &amp;dev-&gt;dev, strict);</span><br><span class="line">		if (rc) &#123;</span><br><span class="line">			of_node_put(child);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	of_node_set_flag(bus, OF_POPULATED_BUS);</span><br><span class="line">	return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第14行：如果 strict 为真且设备节点 bus 没有兼容性属性，则输出调试信息并返回 0。这个条件判断确保设备节点具有 compatible 属性，因为 compatible 属性用于匹配设备驱动程序，对应我们在上一小节的第1条规则。</p>
<p>第21行：如果设备节点 bus 在被跳过的节点表中，则输出调试信息并返回 0。这个条件判断用于跳过不想创建设备的节点。</p>
<p>第27行：如果设备节点 bus 的 OF_POPULATED_BUS 标志已经设置，则输出调试信息并返回 0。这个条件判断用于避免重复创建已经填充的设备节点。</p>
<p>第34行：使用 lookup 辅助数据结构查找设备节点 bus 的特定配置信息，并将其赋值给变量 bus_id 和 platform_data。这个步骤用于获取设备节点的特定配置信息，以便在创建平台设备时使用，由于这里传入的参数为NULL，所以下面的条件判断并不会被执行。</p>
<p>第39行：如果设备节点 bus 兼容于 “arm,primecell”，则调用 of_amba_device_create 函数创建 AMBA 设备，并返回 0，对应我们在上一小节学习的第3条规则。</p>
<p>第47行：调用 of_platform_device_create_pdata函数创建平台设备，并将其赋值给变量 dev。然后，检查设备节点 bus是否与给定的匹配表 <code>matches</code> 匹配。如果平台设备创建失败或者设备节点不匹配，那么返回 0。</p>
<p>第51行-第58行：遍历设备节点 bus 的每个子节点 child，并递归调用 of_platform_bus_create 函数来创建子节点的平台设备。</p>
<p>接下来对该函数的第47行 of_platform_device_create_pdata函数进行讲解，该函数的具体定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> platform_device *<span class="title function_">of_platform_device_create_pdata</span><span class="params">(</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">					<span class="type">const</span> <span class="type">char</span> *bus_id,</span></span><br><span class="line"><span class="params">					<span class="type">void</span> *platform_data,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> device *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查设备节点是否可用或已填充 */</span></span><br><span class="line">	<span class="keyword">if</span> (!of_device_is_available(np) ||</span><br><span class="line">	    of_node_test_and_set_flag(np, OF_POPULATED))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 分配平台设备结构体 */</span></span><br><span class="line">	dev = of_device_alloc(np, bus_id, parent);</span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">goto</span> err_clear_flag;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置平台设备的一些属性 */</span></span><br><span class="line">	dev-&gt;dev.coherent_dma_mask = DMA_BIT_MASK(<span class="number">32</span>);</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;dev.dma_mask)</span><br><span class="line">		dev-&gt;dev.dma_mask = &amp;dev-&gt;dev.coherent_dma_mask;</span><br><span class="line">	dev-&gt;dev.bus = &amp;platform_bus_type;</span><br><span class="line">	dev-&gt;dev.platform_data = platform_data;</span><br><span class="line">	of_msi_configure(&amp;dev-&gt;dev, dev-&gt;dev.of_node);</span><br><span class="line">	of_reserved_mem_device_init_by_idx(&amp;dev-&gt;dev, dev-&gt;dev.of_node, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将平台设备添加到设备模型中 */</span></span><br><span class="line">	<span class="keyword">if</span> (of_device_add(dev) != <span class="number">0</span>) &#123;</span><br><span class="line">		platform_device_put(dev);</span><br><span class="line">		<span class="keyword">goto</span> err_clear_flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev;</span><br><span class="line"></span><br><span class="line">err_clear_flag:</span><br><span class="line">	<span class="comment">/* 清除设备节点的已填充标志 */</span></span><br><span class="line">	of_node_clear_flag(np, OF_POPULATED);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>第10行：函数会检查设备节点的可用性，即检查设备树对应节点的status属性。如果设备节点不可用或已经被填充，则直接返回 NULL。</p>
<p>第15行：函数调用 of_device_alloc 分配一个平台设备结构体，并将设备节点指针、设备标识符和父设备指针传递给它。如果分配失败，则跳转到 err_clear_flag 标签处进行错误处理。</p>
<p>第19行，函数设置平台设备的一些属性。它将 coherent_dma_mask 属性设置为 32 位的 DMA 位掩码，并检查 dma_mask 属性是否为 NULL。如果 dma_mask 为 NULL，则将其指向 coherent_dma_mask。然后，函数设置平台设备的总线类型为 platform_bus_type，并将平台数据指针存储在 platform_data 属性中。接着，函数调用 of_msi_configure 和 of_reserved_mem_device_init_by_idx 来配置设备的 MSI 和保留内存信息。</p>
<p>第29行：函数调用 of_device_add 将平台设备添加到设备模型中。如果添加失败，则释放已分配的平台设备，并跳转到 err_clear_flag 标签处进行错误处理。</p>
<p>至此，关于device_node转换成platform_device的具体流程就分析完成了，函数调用流程图如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps149.jpg" alt="img"> </p>
<h1 id="第65章-设备树下platform-device和platform-driver匹配实验"><a href="#第65章-设备树下platform-device和platform-driver匹配实验" class="headerlink" title="第65章 设备树下platform_device和platform_driver匹配实验"></a>第65章 设备树下platform_device和platform_driver匹配实验</h1><p>在上一章节中我们学习了从device_node到platform_device的转换流程，转换完成之后操作系统才能够识别和管理设备，从而与platform_driver进行匹配，在本章将将会对设备树下platform_device和platform_driver的匹配进行讲解。</p>
<h2 id="65-1-of-match-table"><a href="#65-1-of-match-table" class="headerlink" title="65.1 of_match_table"></a>65.1 of_match_table</h2><p>在前面平台总线相关章节的学习中，了解到只有platform_device结构体中的name 属性与platform_driver结构体中嵌套的driver结构体name属性或者id_table相同才能加载probe初始化函数。</p>
<p>而为了使设备树能够与驱动程序进行匹配，需要在platform_driver驱动程序中添加driver结构体的of_match_table 属性。这个属性是一个指向 const struct of_device_id 结构的指针，用于描述设备树节点和驱动程序之间的匹配规则。of_device_id 结构体定义在内核源码的“&#x2F;include&#x2F;linux&#x2F;mod_devicetable.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>	name[<span class="number">32</span>];</span><br><span class="line">	<span class="type">char</span>	type[<span class="number">32</span>];</span><br><span class="line">	<span class="type">char</span>	compatible[<span class="number">128</span>];</span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct of_device_id 结构体通常作为一个数组在驱动程序中定义，用于描述设备树节点和驱动程序之间的匹配规则。数组的最后一个元素必须是一个空的结构体，以标记数组的结束。</p>
<p>以下是一个示例，展示了如何在驱动程序中使用 struct of_device_id 进行设备树匹配：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">my_driver_match</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;vendor,device-1&quot;</span> &#125;,</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;vendor,device-2&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，my_driver_match 是一个 struct of_device_id 结构体数组。每个数组元素都包含了一个 compatible 字段，用于指定设备树节点的兼容性字符串。驱动程序将根据这些兼容性字符串与设备树中的节点进行匹配。</p>
<h2 id="65-2-实验程序编写"><a href="#65-2-实验程序编写" class="headerlink" title="65.2 实验程序编写"></a>65.2 实验程序编写</h2><p>本实验修改完成的dts文件和编译完成的boot.img镜像对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\54_devicetree_probe\dts。</p>
<p>本次实验的要求为使用设备树描述下面的内存资源：<br><em><strong>*内存资源：*</strong></em></p>
<p>起始地址：0xFDD60000</p>
<p>结束地址：0xFDD60004</p>
<p>标记：IORESOURCE_MEM</p>
<p>随后编写对应的platform_driver驱动程序，要求跟上述内存资源所创建的节点进行匹配，验证 of_match_table 属性。</p>
<h3 id="65-2-1-设备树的编写"><a href="#65-2-1-设备树的编写" class="headerlink" title="65.2.1 设备树的编写"></a>65.2.1 设备树的编写</h3><p>首先来对rk3568的设备树结构进行以下介绍，根据sdk源码目录下的“device&#x2F;rockchip&#x2F;rk356x&#x2F;BoardConfig-rk3568-evb1-ddr4-v10.mk”默认配置文件可以了解到编译的设备树为rk3568-evb1-ddr4-v10-linux.dts,根据设备树之间的包含关系列出了下面的表格。</p>
<table>
<thead>
<tr>
<th>顶层设备树</th>
<th>rk3568-evb1-ddr4-v10-linux.dts</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>第二级设备树</td>
<td>rk3568-evb1-ddr4-v10.dtsi</td>
<td>rk3568-linux.dtsi</td>
</tr>
<tr>
<td>第三级设备树</td>
<td>rk3568.dtsirk3568-evb.dtsi                                                                                                     topeet_screen_choose.dtsitopeet_rk3568_lcds.dtsi</td>
<td></td>
</tr>
</tbody></table>
<p>rk3568-evb1-ddr4-v10-linux.dts是顶层设备树，为了便于理解我们之后在该设备树下进行节点的添加（当然这里也可以修改其他设备树），进入该设备树文件之后如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps150.jpg" alt="img"> </p>
<p>然后将根据需求编写的设备树节点添加到rk3568-evb1-ddr4-v10-linux.dts中，要添加的内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">    topeet&#123;</span><br><span class="line">        #address-cells = &lt;1&gt;;</span><br><span class="line">        #size-cells = &lt;1&gt;;</span><br><span class="line">        compatible = &quot;simple-bus&quot;;</span><br><span class="line"></span><br><span class="line">        myLed&#123;</span><br><span class="line">            compatible = &quot;my devicetree&quot;;</span><br><span class="line">            reg = &lt;0xFDD60000 0x00000004&gt;;</span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;;       </span><br></pre></td></tr></table></figure>

<p>为了避免#address-cells &#x3D; <l>; 和 #size-cells &#x3D; &lt;1&gt;;这两个属性改变根节点其他的节点的属性，所以在这里创建了一个topeet节点。在这个示例中，#address-cells 设置为 1表示地址使用一个 32 位的单元，#size-cells 也设置为 1 表示大小使用一个 32 位的单元。</p>
<p>第5行：将compatible属性设置为”simple-bus”用于表示 topeet 节点的兼容性，指明它是一个简单总线设备，在转换platform_device的过程中，会继续查找该节点的子节点。</p>
<p>第8行：myLed 节点下的compatible属性为”my devicetree”，表明该节点将会被转换为platform_device。</p>
<p>第9行：这个属性用于描述 myLed 节点的寄存器信息。reg 属性的值 &lt;0xFDD60000 0x00000004&gt; 表示 myLed 设备的寄存器起始地址为 0xFDD60000，大小为 0x00000004。</p>
<p>添加完成如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps151.jpg" alt="img"> </p>
<p>保存退出之后，重新编译内核源码，编译完成之后将生成的boot.img烧写到开发板即可。</p>
<h3 id="66-2-2-驱动程序的编写"><a href="#66-2-2-驱动程序的编写" class="headerlink" title="66.2.2 驱动程序的编写"></a>66.2.2 驱动程序的编写</h3><p>本实验驱动对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\54_devicetree_probe\module。</p>
<p>本小节驱动程序是由“第52章 注册platform驱动实验”程序修改而来，相较于源程序只是添加了of_match_table相关代码，用来与设备树节点进行匹配。</p>
<p>编写完成的platform_driver.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mod_devicetable.h&gt;</span></span></span><br><span class="line"><span class="comment">// 平台设备的初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_probe: Probing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Removing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table_id</span>[]  =</span> &#123;</span><br><span class="line">	&#123;.compatible=<span class="string">&quot;my devicetree&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">		.of_match_table =  of_match_table_id,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="65-3-运行测试"><a href="#65-3-运行测试" class="headerlink" title="65.3 运行测试"></a>65.3 运行测试</h2><h3 id="65-3-1-编译驱动程序"><a href="#65-3-1-编译驱动程序" class="headerlink" title="65.3.1 编译驱动程序"></a>65.3.1 编译驱动程序</h3><p>在上一小节中的platform_driver.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m += platform_driver.o    #此处要和你的驱动源文件同名</span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    <span class="meta">#make操作</span></span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    <span class="meta">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_driver.c和Makefile文件目录下，如下图（图65-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps152.jpg" alt="img"> </p>
<p>图 65-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图65-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps153.jpg" alt="img"> </p>
<p>图 65-2</p>
<p>编译完生成platform_driver.ko目标文件，如下图（图65-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps154.jpg" alt="img"> </p>
<p>图 65-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="65-3-2-运行测试"><a href="#65-3-2-运行测试" class="headerlink" title="65.3.2 运行测试"></a>65.3.2 运行测试</h3><p>在进行实验之前，首先要确保开发板烧写的是我们在65.2.1小节中编译出来的boot.img。开发板启动之后，首先进入到“&#x2F;proc&#x2F;device-tree”目录下，查看是否已经存在了topeet目录，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps155.jpg" alt="img"> </p>
<p>只有在设备树节点编写正确的前提下，这里才会生成topeet目录，如果没有出现topeet目录就要回头检查看看了。</p>
<p>然后使用以下命令进行驱动模块的加载，如下图（图65-4）所示：</p>
<p>insmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps156.jpg" alt="img"> </p>
<p>图 65-4</p>
<p>可以看到成功打印了在probe函数中的打印，证明我们添加的设备树节点和platform_driver驱动匹配成功了。</p>
<p>然后使用以下命令进行驱动模块的卸载，如下图（图65-5）所示：</p>
<p>rmmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps157.jpg" alt="img"> </p>
<p>图 65-5</p>
<p>至此，设备树下platform_device和platform_driver匹配实验就完成了。</p>
<h1 id="第66章-of操作函数实验：获取设备树节点"><a href="#第66章-of操作函数实验：获取设备树节点" class="headerlink" title="第66章 of操作函数实验：获取设备树节点"></a><strong>第66章</strong> of操作函数实验：获取设备树节点</h1><p>在上一章节的学习中，我们学习了设备树下platform_device和platform_driver匹配，现在也只是让他们匹配在了一起，但这样显然是不够的，为了完成一些和硬件相关的需求，我们还需要获取到在设备树中编写的一些属性，那设备树中的属性要如何获取呢，让我们一起进入后续章节的学习吧。</p>
<h2 id="66-1-of操作：获取设备树节点"><a href="#66-1-of操作：获取设备树节点" class="headerlink" title="66.1 of操作：获取设备树节点"></a>66.1 of操作：获取设备树节点</h2><p>在Linux内核源码中提供了一系列的of操作函数来帮助我们获取到设备树中编写的属性，</p>
<p>在内核中以device_node结构体来对设备树进行描述，所以of操作函数实际上就是获取device_node结构体，所以接下来我们学习的of操作函数的返回值都是device_node结构体，关于device_node结构体的具体内容已经在63.1小节讲解过了，这里不再进行赘述。</p>
<h3 id="66-1-1-of-find-node-by-name"><a href="#66-1-1-of-find-node-by-name" class="headerlink" title="66.1.1 of_find_node_by_name"></a>66.1.1 of_find_node_by_name</h3><p>of_find_node_by_name 是Linux内核中用于通过节点名称查找设备树节点的函数。下面是对of_find_node_by_name 函数的详细介绍：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>struct device_node *of_find_node_by_name(struct device_node *from, const char *name);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;of.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em><br>    该函数通过指定的节点名称在设备树中进行查找，返回匹配的节点的 struct device_node 指针。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>from：指定起始节点，表示从哪个节点开始查找。如果 from 参数为 NULL，则从设备树的根节点开始查找。</p>
<p>name：要查找的节点名称。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>如果未找到匹配的节点，则返回 NULL。</p>
<p>会在接下来的实验小节中，对该函数进行实际演示。</p>
<h3 id="66-1-2-of-find-node-by-path"><a href="#66-1-2-of-find-node-by-path" class="headerlink" title="66.1.2 of_find_node_by_path"></a>66.1.2 of_find_node_by_path</h3><p>of_find_node_by_path 是Linux内核中用于通过节点路径查找设备树节点的函数。下面是对of_find_node_by_path函数的详细介绍：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>struct device_node *of_find_node_by_path(const char *path);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;of.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em><br>    该函数根据节点路径在设备树中进行查找，返回匹配的节点的 struct device_node 指针。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>path：节点的路径，以斜杠分隔的字符串表示。路径格式为设备树节点的绝对路径，例如 &#x2F;topeet&#x2F;myLed。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>如果未找到匹配的节点，则返回 NULL。</p>
<p>of_find_node_by_path 函数通过节点路径在设备树中进行查找。路径是设备树节点从根节点到目标节点的完整路径。可以通过指定正确的路径来准确地访问设备树中的特定节点。</p>
<p>使用 of_find_node_by_path 函数时，可以直接传递节点的完整路径作为 path 参数，函数会在设备树中查找匹配的节点。这对于已知节点路径的情况非常有用。</p>
<h3 id="66-1-3-of-get-parent"><a href="#66-1-3-of-get-parent" class="headerlink" title="66.1.3 of_get_parent"></a>66.1.3 of_get_parent</h3><p>在Linux内核中，of_get_parent 函数用于获取设备树节点的父节点。下面是对of_get_parent函数的详细介绍：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>struct device_node *of_get_parent(const struct device_node *node);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;of.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em><br>    该函数接收一个指向设备树节点的指针 node，并返回该节点的父节点的指针。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>node：要获取父节点的设备树节点指针。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>如果未找到匹配的节点，则返回 NULL。</p>
<p>使用 of_get_parent 函数时，可以将特定的设备树节点作为参数传递给函数，然后它将返回该节点的父节点。这对于在设备树中导航和访问节点之间的层次关系非常有用。</p>
<p>父节点在设备树中表示了节点之间的层次结构关系。通过获取父节点，你可以访问上一级节点的属性和配置信息，从而更好地理解设备树中的节点之间的关系。</p>
<h3 id="66-1-4-of-get-next-child"><a href="#66-1-4-of-get-next-child" class="headerlink" title="66.1.4 of_get_next_child"></a>66.1.4 of_get_next_child</h3><p>在Linux内核中，of_get_next_child 函数用于获取设备树节点的下一个子节点。下面是对of_get_next_child 函数的详细介绍：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>struct device_node *of_get_next_child(const struct device_node *node, struct device_node *prev);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;of.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em><br>    该函数接收两个参数：node 是当前节点，prev 是上一个子节点。它返回下一个子节点的指针。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>node：当前节点，用于指定要获取子节点的起始节点。</p>
<p>prev：上一个子节点，用于指定从哪个子节点开始获取下一个子节点。如果为 NULL，则从起始节点的第一个子节点开始。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>如果未找到匹配的节点，则返回 NULL。</p>
<p>使用 of_get_next_child 函数时，可以传递当前节点以及上一个子节点作为参数。函数将从上一个子节点的下一个节点开始，查找并返回下一个子节点。</p>
<p>设备树中的子节点表示了节点之间的层次关系。通过获取子节点，你可以遍历和访问当前节点的所有子节点，以便进一步处理它们的属性和配置信息。</p>
<h3 id="64-1-5-of-find-compatible-node函数"><a href="#64-1-5-of-find-compatible-node函数" class="headerlink" title="64.1.5 of_ find_ compatible_ node函数"></a>64.1.5 of_ find_ compatible_ node函数</h3><p>当设备树中存在多个设备节点，需要根据设备的兼容性字符串进行匹配时，可以使用 of_find_compatible_node 函数。该函数用于在设备树中查找与指定兼容性字符串匹配的节点。</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>struct device_node *of_find_compatible_node(struct device_node *from, const char *type, const char *compatible);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;of.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em><br>    在设备树中查找与指定兼容性字符串匹配的节点。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>from：指定起始节点，表示从哪个节点开始查找。如果 from 参数为 NULL，则从设备树的根节点开始查找。</p>
<p>type：要匹配的设备类型字符串，通常是 compatible 属性中的一部分。</p>
<p>compatible：要匹配的兼容性字符串，通常是设备树节点的 compatible 属性中的值。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>如果未找到匹配的节点，则返回 NULL。</p>
<p>使用 of_find_compatible_node 函数时，可以指定起始节点和需要匹配的设备类型字符串以及兼容性字符串。函数会从起始节点开始遍历设备树，查找与指定兼容性字符串匹配的节点，并返回匹配节点的指针。</p>
<h3 id="64-1-6-of-find-matching-node-and-match函数"><a href="#64-1-6-of-find-matching-node-and-match函数" class="headerlink" title="64.1.6 of_ find matching node_ and_ match函数"></a>64.1.6 of_ find matching node_ and_ match函数</h3><p>在Linux内核中，of_ find matching node_ and_ match函数用于根据给定的of_device_id匹配表在设备树中查找匹配的节点。</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>struct device_node *of_find_matching_node_and_match(struct device_node *from,const struct of_device_id *matches, const struct of_device_id **match);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;of.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em><br>    根据给定的of_device_id匹配表在设备树中查找匹配的节点。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>from：表示从哪个节点开始搜索。通常将上一次调用该函数返回的节点作为参数传递给from，以便从上一次的下一个节点开始搜索。如果要从设备树的根节点开始搜索，可以将from参数设置为NULL。</p>
<p>matches：指向一个of_device_id类型的匹配表，该表包含要搜索的匹配项。</p>
<p>match：用于输出匹配到的of_device_id条目的指针。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>如果未找到匹配的节点，则返回 NULL。</p>
<p>of_find_matching_node_and_match函数在设备树中遍历节点，对每个节点使用__of_match_node函数进行匹配。如果找到匹配的节点，将返回该节点的指针，并将match指针更新为匹配到的of_device_id条目，函数会自动增加匹配节点的引用计数。以下是使用of_find_matching_node_and_match函数的示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">my_match_table</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;vendor,device&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">match</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从根节点开始查找匹配的节点</span></span><br><span class="line">np = of_find_matching_node_and_match(<span class="literal">NULL</span>, my_match_table, &amp;match);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个of_device_id匹配表my_match_table，其中包含了一个兼容性字符串为”vendor,device”的匹配项。然后，我们使用of_find_matching_node_and_match函数从根节点开始查找匹配的节点。</p>
<h2 id="66-2-实验程序编写"><a href="#66-2-实验程序编写" class="headerlink" title="66.2 实验程序编写"></a>66.2 实验程序编写</h2><p>本实验驱动对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\55_of_01。</p>
<p>本小节驱动程序是由上一章程序修改而来，相较于源程序只是在probe函数中添加了本章节学习的of操作相关代码，用来获取设备树节点。</p>
<p>编写完成的platform_driver.c代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/platform_device.h&gt;</span><br><span class="line">#include &lt;linux/mod_devicetable.h&gt;</span><br><span class="line">#include &lt;linux/of.h&gt;</span><br><span class="line"></span><br><span class="line">struct device_node *mydevice_node;      </span><br><span class="line">const struct of_device_id *mynode_match;</span><br><span class="line">struct of_device_id mynode_of_match[] = &#123;</span><br><span class="line">	&#123;.compatible=&quot;my devicetree&quot;&#125;,</span><br><span class="line">	&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 平台设备的初始化函数</span><br><span class="line">static int my_platform_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO &quot;my_platform_probe: Probing platform device\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 通过节点名称查找设备树节点</span><br><span class="line">    mydevice_node = of_find_node_by_name(NULL, &quot;myLed&quot;);</span><br><span class="line">	printk(&quot;mydevice node is %s\n&quot;, mydevice_node-&gt;name);</span><br><span class="line">    </span><br><span class="line">	// 通过节点路径查找设备树节点</span><br><span class="line">    mydevice_node = of_find_node_by_path(&quot;/topeet/myLed&quot;);</span><br><span class="line">    printk(&quot;mydevice node is %s\n&quot;, mydevice_node-&gt;name);</span><br><span class="line">        </span><br><span class="line">    // 获取父节点</span><br><span class="line">    mydevice_node = of_get_parent(mydevice_node);</span><br><span class="line">    printk(&quot;myled&#x27;s parent node is %s\n&quot;, mydevice_node-&gt;name);</span><br><span class="line">            </span><br><span class="line">    // 获取子节点</span><br><span class="line">    mydevice_node = of_get_next_child(mydevice_node, NULL);</span><br><span class="line">    printk(&quot;myled&#x27;s sibling node is %s\n&quot;, mydevice_node-&gt;name);</span><br><span class="line"></span><br><span class="line">	// 使用compatible值查找节点</span><br><span class="line">	mydevice_node=of_find_compatible_node(NULL ,NULL, &quot;my devicetree&quot;);</span><br><span class="line">	printk(&quot;mydevice node is %s\n&quot; , mydevice_node-&gt;name);</span><br><span class="line">	</span><br><span class="line">	//根据给定的of_device_id匹配表在设备树中查找匹配的节点</span><br><span class="line">	mydevice_node=of_find_matching_node_and_match(NULL , mynode_of_match, &amp;mynode_match);</span><br><span class="line">	printk(&quot;mydevice node is %s\n&quot; ,mydevice_node-&gt;name);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 平台设备的移除函数</span><br><span class="line">static int my_platform_remove(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO &quot;my_platform_remove: Removing platform device\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 清理设备特定的操作</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const struct of_device_id of_match_table_id[]  = &#123;</span><br><span class="line">	&#123;.compatible=&quot;my devicetree&quot;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义平台驱动结构体</span><br><span class="line">static struct platform_driver my_platform_driver = &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = &quot;my_platform_device&quot;,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">		.of_match_table =  of_match_table_id,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 模块初始化函数</span><br><span class="line">static int __init my_platform_driver_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    // 注册平台驱动</span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;Failed to register platform driver\n&quot;);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO &quot;my_platform_driver: Platform driver initialized\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 模块退出函数</span><br><span class="line">static void __exit my_platform_driver_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 注销平台驱动</span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line">    printk(KERN_INFO &quot;my_platform_driver: Platform driver exited\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;topeet&quot;);</span><br></pre></td></tr></table></figure>



<h2 id="66-3-运行测试"><a href="#66-3-运行测试" class="headerlink" title="66.3 运行测试"></a>66.3 运行测试</h2><h3 id="66-3-1-编译驱动程序"><a href="#66-3-1-编译驱动程序" class="headerlink" title="66.3.1 编译驱动程序"></a>66.3.1 编译驱动程序</h3><p>在上一小节中的platform_driver.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m += platform_driver.o    #此处要和你的驱动源文件同名</span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    <span class="meta">#make操作</span></span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    <span class="meta">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_driver.c和Makefile文件目录下，如下图（图66-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps158.jpg" alt="img"> </p>
<p>图 66-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图66-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps159.jpg" alt="img"> </p>
<p>图 66-2</p>
<p>编译完生成platform_driver.ko目标文件，如下图（图66-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps160.jpg" alt="img"> </p>
<p>图 66-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="66-3-2-运行测试"><a href="#66-3-2-运行测试" class="headerlink" title="66.3.2 运行测试"></a>66.3.2 运行测试</h3><p>在进行实验之前，首先要确保开发板烧写的是我们在65.2.1小节中编译出来的boot.img，开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图66-4）所示：</p>
<p>insmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps161.jpg" alt="img"> </p>
<p>图 66-4</p>
<p>可以看到总共有4个打印，前两个打印都是查找的myLed节点，第三个打印是查找的myLed的父节点，也就是topeet节点，第四个打印是查找的topeet的子节点，也就又回到了myLed节点。第5个打印是通过compatible属性查找到的myLed节点，第6个打印是通过of_device_id匹配表查找到的myLed节点.</p>
<p>然后使用以下命令进行驱动模块的卸载，如下图（图66-5）所示：</p>
<p>rmmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps162.jpg" alt="img"> </p>
<p>图 66-5</p>
<p>至此，使用of操作函数获取设备树节点实验就完成了。</p>
<h1 id="第67章-of操作函数实验：获取属性"><a href="#第67章-of操作函数实验：获取属性" class="headerlink" title="第67章 of操作函数实验：获取属性"></a>第67章 of操作函数实验：获取属性</h1><h2 id="67-1-of操作：获取属性"><a href="#67-1-of操作：获取属性" class="headerlink" title="67.1 of操作：获取属性"></a>67.1 of操作：获取属性</h2><h3 id="67-1-1-of-find-property"><a href="#67-1-1-of-find-property" class="headerlink" title="67.1.1 of_find_property"></a>67.1.1 of_find_property</h3><p>of_find_property函数用于在设备树中查找节点 下具有指定名称的属性。如果找到了该属性，可以通过返回的属性结构体指针进行进一步的操作，比如获取属性值、属性长度等。</p>
<p>函数原型: <code>struct property *of_find_property(const struct device_node *np, const char *name, int *lenp)</code></p>
<p>头文件：</p>
<p>​		#include &lt;linux&#x2F;of.h&gt;</p>
<p>函数作用: 该函数用于在节点 <code>np</code> 下查找指定名称 <code>name</code> 的属性。</p>
<p>函数参数和返回值:</p>
<ul>
<li><code>np</code>: 要查找的节点。</li>
<li><code>name</code>: 要查找的属性的属性名。</li>
<li><code>lenp</code>: 一个指向整数的指针，用于接收属性值的字节数。</li>
</ul>
<p>返回值: 如果成功找到了指定名称的属性，则返回对应的属性结构体指针 <code>struct property *</code>；如果未找到，则返回 <code>NULL</code>。</p>
<h3 id="67-1-2-of-property-count-elems-of-size"><a href="#67-1-2-of-property-count-elems-of-size" class="headerlink" title="67.1.2 of_property_count_elems_of_size"></a>67.1.2 of_property_count_elems_of_size</h3><p>该函数在设备树中的设备节点下查找指定名称的属性，并获取该属性中元素的数量。调用该函数可以用于获取设备树属性中某个属性的元素数量，比如一个字符串列表的元素数量或一个整数数组的元素数量等。	</p>
<p>函数原型: <code>int of_property_count_elems_of_size(const struct device_node *np, const char *propname, int elem_size)</code></p>
<p>头文件：</p>
<p>​		#include &lt;linux&#x2F;of.h&gt;</p>
<p>函数作用: 该函数用于获取属性中指定元素的数量。</p>
<p>函数参数和返回值:</p>
<ul>
<li><code>np</code>: 设备节点。</li>
<li><code>propname</code>: 需要获取元素数量的属性名。</li>
<li><code>elem_size</code>: 单个元素的尺寸。</li>
</ul>
<p>返回值: 如果成功获取了指定属性中元素的数量，则返回该数量；如果未找到属性或属性中没有元素，则返回 0。</p>
<h3 id="67-1-3-of-property-read-u32-index"><a href="#67-1-3-of-property-read-u32-index" class="headerlink" title="67.1.3 of_property_read_u32_index"></a>67.1.3 of_property_read_u32_index</h3><p>该函数在设备树中的设备节点下查找指定名称的属性，并获取该属性在给定索引位置处的 u32 类型的数据值。</p>
<p>这个函数通常用于从设备树属性中读取特定索引位置的整数值。通过指定属性名和索引，可以获取属性中指定位置的具体数值。</p>
<p>函数原型: <code>int of_property_read_u32_index(const struct device_node *np, const char *propname, u32 index, u32 *out_value)</code></p>
<p>头文件：</p>
<p>​		#include &lt;linux&#x2F;of.h&gt;</p>
<p>函数作用: 该函数用于从指定属性中获取指定索引位置的 u32 类型的数据值。</p>
<p>函数参数和返回值:</p>
<ul>
<li><code>np</code>: 设备节点。</li>
<li><code>propname</code>: 要读取的属性名。</li>
<li><code>index</code>: 要读取的属性值在属性中的索引，索引从 0 开始。</li>
<li><code>out_value</code>: 用于存储读取到的值的指针。</li>
</ul>
<p>返回值: 如果成功读取到了指定属性指定索引位置的 u32 类型的数据值，则返回 0；如果未找到属性或读取失败，则返回相应的错误码。</p>
<h3 id="67-1-4-of-property-read-u64-index"><a href="#67-1-4-of-property-read-u64-index" class="headerlink" title="67.1.4 of_property_read_u64_index"></a>67.1.4 of_property_read_u64_index</h3><p>该函数在设备树中的设备节点下查找指定名称的属性，并获取该属性在给定索引位置处的 u64 类型的数据值。</p>
<p>这个函数通常用于从设备树属性中读取特定索引位置的 64 位整数值。通过指定属性名和索引，可以获取属性中指定位置的具体数值。</p>
<p>函数原型: </p>
<p><code>static inline int of_property_read_u64_index(const struct device_node *np, const char *propname, u32 index, u64 *out_value)</code></p>
<p>头文件：</p>
<p>​		#include &lt;linux&#x2F;of.h&gt;</p>
<p>函数作用: 该函数用于从指定属性中获取指定索引位置的 u64 类型的数据值。</p>
<p>函数参数和返回值:</p>
<ul>
<li><code>np</code>: 设备节点。</li>
<li><code>propname</code>: 要读取的属性名。</li>
<li><code>index</code>: 要读取的属性值在属性中的索引，索引从 0 开始。</li>
<li><code>out_value</code>: 用于存储读取到的值的指针。</li>
</ul>
<p>返回值: 如果成功读取到了指定属性指定索引位置的 u64 类型的数据值，则返回 0；如果未找到属性或读取失败，则返回相应的错误码。</p>
<h3 id="67-1-5-of-property-read-variable-u32-array"><a href="#67-1-5-of-property-read-variable-u32-array" class="headerlink" title="67.1.5 of_property_read_variable_u32_array"></a>67.1.5 of_property_read_variable_u32_array</h3><p>该函数用于从设备树中读取指定属性名的变长数组。通过提供设备节点、属性名和输出数组的指针，可以将设备树中的数组数据读取到指定的内存区域中。同时，还需要指定数组的最小大小和最大大小，以确保读取到的数组符合预期的大小范围。</p>
<p>函数原型：</p>
<p> <code>int of_property_read_variable_u32_array(const struct device_node *np, const char *propname, u32 *out_values, size_t SZ_min, size_t SZ_max)</code></p>
<p>函数作用: </p>
<p>​	从指定属性中读取变长的 u32 数组。</p>
<p>函数参数和返回值:</p>
<ul>
<li><code>np</code>: 设备节点。</li>
<li><code>propname</code>: 要读取的属性名。</li>
<li><code>out_values</code>: 用于存储读取到的 u8 数组的指针。</li>
<li><code>SZ_min</code>: 数组的最小大小。</li>
<li><code>SZ_max</code>: 数组的最大大小。</li>
</ul>
<p>返回值：</p>
<p>​	 如果成功读取到了指定属性的 u8 数组，则返回数组的大小。如果未找到属性或读取失败，则返回相应的错误码。</p>
<p>​	上面介绍的函数用于从指定属性中读取变长的 u32 数组，下面是另外三个读取其他数组大小的函数：</p>
<p>这里给出了四个函数，用于从设备树中读取数组类型的属性值：</p>
<p>从指定属性中读取变长的 u8 数组：</p>
<p>int of_property_read_variable_u8_array(const struct device_node *np, const char *propname, u8 *out_values, size_t SZ_min, size_t SZ_max)</p>
<p>从指定属性中读取变长的 u16 数组：</p>
<p>int of_property_read_variable_u16_array(const struct device_node *np, const char *propname, u16 *out_values, size_t SZ_min, size_t SZ_max)</p>
<p>从指定属性中读取变长的 u64 数组：</p>
<p> int of_property_read_variable_u64_array(const struct device_node *np, const char *propname, u64 *out_values, size_t SZ_min, size_t SZ_max)</p>
<h3 id="67-1-6-of-property-read-string"><a href="#67-1-6-of-property-read-string" class="headerlink" title="67.1.6 of_property_read_string"></a>67.1.6 of_property_read_string</h3><p>该函数在设备树中的设备节点下查找指定名称的属性，并获取该属性的字符串值，最后返回读取到的字符串的指针，通常用于从设备树属性中读取字符串值。通过指定属性名，可以获取属性中的字符串数据。</p>
<p>函数原型: </p>
<p>static inline int of_property_read_string(const struct device_node *np, const char *propname, const char **out_string)</p>
<p>头文件：</p>
<p>​		#include &lt;linux&#x2F;of.h&gt;</p>
<p>函数作用: 该函数用于从指定属性中读取字符串。</p>
<p>函数参数和返回值:</p>
<ul>
<li><code>np</code>: 设备节点。</li>
<li><code>propname</code>: 要读取的属性名。</li>
<li><code>out_string</code>: 用于存储读取到的字符串的指针。</li>
</ul>
<p>返回值: 如果成功读取到了指定属性的字符串，则返回 0；如果未找到属性或读取失败，则返回相应的错误码。</p>
<h2 id="67-2-实验程序编写"><a href="#67-2-实验程序编写" class="headerlink" title="67.2 实验程序编写"></a>67.2 实验程序编写</h2><p>本实验驱动对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\55_of_02。</p>
<p>本小节驱动程序是由65章驱动程序修改而来，由于本章节获取设备树属性的函数需要在查找到设备树节点的前提下使用，所以在下面的程序中，先在probe函数中添加查获取设备树节点，然后添加了本章节学习的of操作相关代码，用来获取设备树节点相关属性。</p>
<p>编写完成的platform_driver.c代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="67-3-运行测试"><a href="#67-3-运行测试" class="headerlink" title="67.3 运行测试"></a>67.3 运行测试</h2><h3 id="67-3-1-编译驱动程序"><a href="#67-3-1-编译驱动程序" class="headerlink" title="67.3.1 编译驱动程序"></a>67.3.1 编译驱动程序</h3><p>在上一小节中的platform_driver.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_driver.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_driver.c和Makefile文件目录下，如下图（图66-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps171.jpg" alt="img"></p>
<p>图 67-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图66-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/image-20230904181227189.png" alt="image-20230904181227189"></p>
<p>图 67-2</p>
<p>编译完生成platform_driver.ko目标文件，如下图（图66-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps160.jpg" alt="img"> </p>
<p>图 67-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="67-3-2-运行测试"><a href="#67-3-2-运行测试" class="headerlink" title="67.3.2 运行测试"></a>67.3.2 运行测试</h3><p>在进行实验之前，首先要确保开发板烧写的是我们在65.2.1小节中编译出来的boot.img，开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图66-4）所示：</p>
<p>insmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps161.jpg" alt="img"> </p>
<p>图 67-4</p>
<p>可以看到总共有4个打印，前两个打印都是查找的myLed节点，第三个打印是查找的myLed的父节点，也就是topeet节点，第四个打印是查找的topeet的子节点，也就又回到了myLed节点。第5个打印是通过compatible属性查找到的myLed节点，第6个打印是通过of_device_id匹配表查找到的myLed节点.</p>
<p>然后使用以下命令进行驱动模块的卸载，如下图（图66-5）所示：</p>
<p>rmmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps162.jpg" alt="img"> </p>
<p>图 67-5</p>
<p>至此，使用of操作函数获取设备树节点实验就完成了。</p>
<h1 id="第68章-ranges属性实验"><a href="#第68章-ranges属性实验" class="headerlink" title="第68章 ranges属性实验"></a>第68章 ranges属性实验</h1><h1 id="第69章-of操作函数实验：获取中断资源"><a href="#第69章-of操作函数实验：获取中断资源" class="headerlink" title="第69章 of操作函数实验：获取中断资源"></a>第69章 of操作函数实验：获取中断资源</h1><h1 id="第70章-参考文档：设备树bindings"><a href="#第70章-参考文档：设备树bindings" class="headerlink" title="第70章 参考文档：设备树bindings"></a>第70章 参考文档：设备树bindings</h1><h1 id="第71章-讨论：为什么学不会设备树"><a href="#第71章-讨论：为什么学不会设备树" class="headerlink" title="第71章 讨论：为什么学不会设备树"></a>第71章 讨论：为什么学不会设备树</h1> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E5%A4%87%E6%A0%91/" rel="tag">设备树</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-rk3568-驱动开发第六篇-平台总线"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E5%85%AD%E7%AF%87-%E5%B9%B3%E5%8F%B0%E6%80%BB%E7%BA%BF/"
    >rk3568 驱动开发第六篇 平台总线</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E5%85%AD%E7%AF%87-%E5%B9%B3%E5%8F%B0%E6%80%BB%E7%BA%BF/" class="article-date">
  <time datetime="2023-09-04T12:56:12.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第50章-平台总线模型介绍"><a href="#第50章-平台总线模型介绍" class="headerlink" title="**** ****第50章 平台总线模型介绍"></a>**** ****第50章 平台总线模型介绍</h1><p>在前面所有章节中，无论要完成何种需求，我们都编写了一个独立的驱动程序，但这样编写出来的驱动程序在重用性和可移植性上是很低的，无论之后要编写一个同类型的驱动还是将该驱动更换一个平台，都要花费时间重新修改驱动代码，而驱动的分离和分层这一软件思路的提出（即本章节要讲解的平台总线模型），就是为了解决这个问题，下面让我们一起进入平台总线模型的学习吧。</p>
<h2 id="50-1-什么是平台总线？"><a href="#50-1-什么是平台总线？" class="headerlink" title="50.1 什么是平台总线？"></a>50.1 什么是平台总线？</h2><p>平台总线（Platform bus）是Linux内核中提供的一种虚拟总线，用于管理和组织与特定硬件平台相关的设备和驱动。它充当了平台设备（platform device）和平台驱动（platform driver）之间的桥梁，负责将它们进行匹配和绑定。</p>
<p>当系统注册一个平台设备时，平台总线会寻找与之匹配的平台驱动。它会遍历已注册的平台驱动列表，尝试与每个平台驱动进行匹配，直到找到与平台设备匹配的驱动为止。一旦找到匹配的驱动，平台总线会将平台设备与平台驱动进行绑定，使得设备可以被正确地初始化和操作。</p>
<p>同样地，当系统注册一个平台驱动时，平台总线会寻找与之匹配的平台设备。它会遍历已注册的平台设备列表，尝试与每个平台设备进行匹配，直到找到与平台驱动匹配的设备为止。一旦找到匹配的设备，平台总线会将平台设备与平台驱动进行绑定，使得驱动可以管理和控制与该设备相关的操作。</p>
<p>设备、平台总线、驱动的关系如下图（图 50-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps1.jpg" alt="img"> </p>
<p>图 50-1</p>
<p>通过引入平台总线，Linux内核提供了一种通用的机制来管理和组织与特定硬件平台相关的设备和驱动。它使得设备和驱动之间的匹配过程更加自动化和灵活，同时也提高了嵌入式系统的可移植性和可扩展性。</p>
<h2 id="50-2-平台总线的优势"><a href="#50-2-平台总线的优势" class="headerlink" title="50.2 平台总线的优势"></a>50.2 平台总线的优势</h2><p>在前面的章节中，我们编写的驱动程序将驱动和设备相关的内容放在一起，但是当涉及到多个相同类型的设备时，这种方法会引发一系列问题。举个例子，假设我们有一个硬件平台，该硬件平台上存在了500个模块，这些模块都使用了LED灯。如果我们使用杂项设备来编写驱动，虽然相比字符设备，杂项设备的代码量较少，但我们仍旧需要编写500份类似的代码，从而生成相应的设备节点，以供上层应用在不同模块上控制LED灯。</p>
<p>编写500份重复的代码会带来两个问题。首先，会造成大量重复劳动。其次，代码的重用性较差。如果我们需要将这些驱动从一个平台移植到另一个平台，就需要逐个修改驱动代码，尽管只需修改与硬件相关的部分，但仍旧是一个很大的工作量</p>
<p>而在引入了平台总线模型后，这些问题就得到了很好地解决。通过使用平台总线模型，将设备驱动和平台设备进行了分离。这样一来，我们只需编写一份通用的驱动代码即可，然后针对不同的平台设备进行配置，这就大大减少了重复编写代码的工作量，并提高了驱动代码的重用性。当我们需要将驱动移植到不同的平台时，只需对硬件相关的部分进行适配即可，其他部分可以保持不变。</p>
<p>整理出来的平台总线优势如下所示：</p>
<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em>****设备与驱动的分离：****传统的设备驱动模型将设备和驱动代码合并在同一个文件中，导致代码冗余和可维护性差。而平台总线模型将设备代码和驱动代码分离，设备代码放在device.c文件中，驱动代码放在driver.c文件中。这种分离使得设备和驱动的职责更加清晰，提高了代码的可读性和可维护性。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em>****提高代码的重用性：****平台总线模型使得相同类型的设备可以共享相同的驱动代码。例如，在一个硬件平台上存在多个相同类型的设备，传统的驱动模型需要为每个设备编写独立的驱动代码。而使用平台总线模型，只需编写一个通用的驱动代码，然后为每个设备创建相应的device.c文件，将设备特定的代码放在其中。这样可以减少代码的重复性，提高了代码的重用性和可维护性。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em>****减少重复性代码：****在传统的设备驱动模型中，如果有多个相同类型的设备存在，就需要为每个设备编写独立的驱动代码。而使用平台总线模型，只需编写一个通用的驱动代码，然后为每个设备创建相应的device.c文件，将设备特定的代码放在其中。这样可以避免大量的重复性代码，简化了驱动开发过程。</p>
<p><em><strong>*（*</strong></em><em><strong>*4*</strong></em><em><strong>*）*</strong></em>****提高可移植性：****平台总线模型可以提高驱动的可移植性。开发者可以编写适应平台总线的平台驱动程序，从而支持特定的外设，而无需依赖于特定的标准总线。这使得驱动可以更容易地在不同的硬件平台之间进行移植和重用。</p>
<h1 id="第51章-注册platform设备实验"><a href="#第51章-注册platform设备实验" class="headerlink" title="**** ****第51章 注册platform设备实验"></a>**** ****第51章 注册platform设备实验</h1><h2 id="51-1-注册platform设备"><a href="#51-1-注册platform设备" class="headerlink" title="51.1 注册platform设备"></a>51.1 注册platform设备</h2><h3 id="51-1-1-platform-device-register-函数"><a href="#51-1-1-platform-device-register-函数" class="headerlink" title="51.1.1 platform_device_register 函数"></a>51.1.1 platform_device_register 函数</h3><p>platform_device_register函数用于将platform_device结构体描述的平台设备注册到内核中。下面是对platform_device_register函数的详细介绍：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int platform_device_register(struct platform_device *pdev);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;platform_device.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em><br>    platform_device_register函数用于将platform_device结构体描述的平台设备注册到内核中，使其能够参与设备的资源分配和驱动的匹配。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>pdev：指向platform_device结构体的指针，描述要注册的平台设备的信息。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>成功：返回0，表示设备注册成功。</p>
<p>失败：返回负数，表示设备注册失败，返回的负数值表示错误代码。</p>
<p>pdev参数是一个指向platform_device结构体的指针，其中包含了描述平台设备的各种属性和信息。platform_device结构体包含了设备名称、设备资源、设备ID等信息，用于描述和标识平台设备，会在接下来的小节对该结构体进行详细的介绍。</p>
<p>该函数在内核源码目录下的“&#x2F;include&#x2F;linux&#x2F;platform_device.h”文件中，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern int platform_device_register(struct platform_device *);</span><br></pre></td></tr></table></figure>

<p>函数声明中的extern关键字表示该函数在其他地方定义，而不是在当前文件中实现。这样的声明通常出现在头文件中，用于告诉编译器该函数的定义存在于其他源文件中，以便在编译时能够正确引用该函数。</p>
<p>而platform_device_register实际定义在“&#x2F;drivers&#x2F;base&#x2F;platform.c”文件中，相关定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int platform_device_register(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">	device_initialize(&amp;pdev-&gt;dev);</span><br><span class="line">	arch_setup_pdev_archdata(pdev);</span><br><span class="line">	return platform_device_add(pdev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数内部有三个主要的操作。</p>
<p>第3行：调用了device_initialize函数，用于对pdev-&gt;dev进行初始化。pdev-&gt;dev是struct platform_device结构体中的一个成员，它表示平台设备对应的struct device结构体。通过调用device_initialize函数，对pdev-&gt;dev进行一些基本的初始化工作，例如设置设备的引用计数、设备的类型等。</p>
<p>第4行：调用了arch_setup_pdev_archdata函数，用于根据平台设备的架构数据来设置pdev的架构相关数据。这个函数的具体实现可能与具体的架构相关，它主要用于在不同的架构下对平台设备进行特定的设置。</p>
<p>第5行：调用了platform_device_add函数，将平台设备pdev添加到内核中。platform_device_add函数会完成平台设备的添加操作，包括将设备添加到设备层级结构中、添加设备的资源等。它会返回一个int类型的结果，表示设备添加的结果。</p>
<p>platform_device_register函数的主要作用是将platform_device结构体描述的平台设备注册到内核中，包括设备的初始化、添加到platform总线和设备层级结构、添加设备资源等操作。通过该函数，平台设备被注册后，就能够参与设备的资源分配和驱动的匹配过程。函数的返回值可以用于判断设备注册是否成功。</p>
<h3 id="51-1-2-platform-device-unregister-函数"><a href="#51-1-2-platform-device-unregister-函数" class="headerlink" title="51.1.2 platform_device_unregister 函数"></a>51.1.2 platform_device_unregister 函数</h3><p>platform_device_unregister函数用于取消注册已经注册的平台设备，即从内核中移除设备。在设备不再需要时，调用该函数可以进行设备的清理和释放操作。</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>void platform_device_unregister(struct platform_device *pdev);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;platform_device.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em><br>    platform_device_unregister函数用于取消注册已经注册的平台设备，从内核中移除设备。</p>
<p>参数含义：</p>
<p>pdev：指向要取消注册的平台设备的platform_device结构体指针。</p>
<p>返回值：<br>无返回值。</p>
<p>该函数在内核源码目录下的“&#x2F;include&#x2F;linux&#x2F;platform_device.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">platform_device_unregister</span><span class="params">(<span class="keyword">struct</span> platform_device *)</span>;</span><br></pre></td></tr></table></figure>

<p>函数声明中的extern关键字表示该函数在其他地方定义，而不是在当前文件中实现。这样的声明通常出现在头文件中，用于告诉编译器该函数的定义存在于其他源文件中，以便在编译时能够正确引用该函数。</p>
<p>而platform_device_unregister实际定义在“&#x2F;drivers&#x2F;base&#x2F;platform.c”文件中，相关定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">platform_device_unregister</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	platform_device_del(pdev);</span><br><span class="line">	platform_device_put(pdev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数内部有两个主要的操作：</p>
<p>第3行：调用了platform_device_del函数，用于将设备从platform总线的设备列表中移除。它会将设备从设备层级结构中移除，停止设备的资源分配和驱动的匹配。</p>
<p>第4行：这一步调用了platform_device_put函数，用于减少对设备的引用计数。这个函数会检查设备的引用计数，如果引用计数减为零，则会释放设备结构体和相关资源。通过减少引用计数，可以确保设备在不再被使用时能够被释放。</p>
<p>platform_device_unregister函数的作用是取消注册已经注册的平台设备，从内核中移除设备。它先调用platform_device_del函数将设备从设备层级结构中移除，然后调用platform_device_put函数减少设备的引用计数，确保设备在不再被使用时能够被释放。</p>
<h3 id="51-1-3-platform-device结构体"><a href="#51-1-3-platform-device结构体" class="headerlink" title="51.1.3 platform_device结构体"></a>51.1.3 platform_device结构体</h3><p>platform_device结构体是用于描述平台设备的数据结构。它包含了平台设备的各种属性和信息，用于在内核中表示和管理平台设备。该结构体定义在内核的“&#x2F;include&#x2F;linux&#x2F;platform_device.h”文件中，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct platform_device &#123;</span><br><span class="line">	const char *name;  // 设备的名称，用于唯一标识设备</span><br><span class="line">	int	id;        // 设备的ID，可以用于区分同一种设备的不同实例</span><br><span class="line">	bool	 id_auto;  // 表示设备的ID是否自动生成</span><br><span class="line">	struct device dev;  // 表示平台设备对应的 struct device 结构体，用于设备的基本管理和操作</span><br><span class="line">	u32	num_resources;   // 设备资源的数量</span><br><span class="line">	struct resource	*resource;   // 指向设备资源的指针</span><br><span class="line"></span><br><span class="line">	const struct platform_device_id *id_entry; // 指向设备的ID表项的指针，用于匹配设备和驱动</span><br><span class="line">	char *driver_override; // 强制设备与指定驱动匹配的驱动名称</span><br><span class="line"></span><br><span class="line">	/* MFD cell pointer */</span><br><span class="line">	struct mfd_cell *mfd_cell;   // 指向多功能设备（MFD）单元的指针，用于多功能设备的描述</span><br><span class="line"></span><br><span class="line">	/* arch specific additions */</span><br><span class="line">	struct pdev_archdata	archdata;    // 用于存储特定于架构的设备数据</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面对于几个重要的参数和结构体进行讲解</p>
<p>const char *name：设备的名称，用于唯一标识设备。必须提供一个唯一的名称，以便内核能够正确识别和管理该设备。</p>
<p>int id：设备的ID，可以用于区分同一种设备的不同实例。这个参数是可选的，如果不需要使用ID进行区分，可以将其设置为-1，</p>
<p>struct device dev：表示平台设备对应的struct device结构体，用于设备的基本管理和操作。必须为该参数提供一个有效的struct device对象，该结构体的release方法必须要实现，否则在编译的时候会报错。</p>
<p>u32 num_resources：设备资源的数量。如果设备具有资源（如内存区域、中断等），则需要提供资源的数量。</p>
<p>struct resource *resource：指向设备资源的指针。如果设备具有资源，需要提供一个指向资源数组的指针，会在下个小节对该结构体进行详细的讲解。</p>
<h3 id="51-1-4-resource结构体"><a href="#51-1-4-resource结构体" class="headerlink" title="51.1.4 resource结构体"></a>51.1.4 resource结构体</h3><p>struct resource结构体用于描述系统中的设备资源，包括内存区域、I&#x2F;O 端口、中断等，该结构体定义在内核的“&#x2F;include&#x2F;linux&#x2F;ioport.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line">    <span class="type">resource_size_t</span> start;          <span class="comment">/* 资源的起始地址 */</span></span><br><span class="line">    <span class="type">resource_size_t</span> end;            <span class="comment">/* 资源的结束地址 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;               <span class="comment">/* 资源的名称 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;            <span class="comment">/* 资源的标志位 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> desc;             <span class="comment">/* 资源的描述信息 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>;</span>        <span class="comment">/* 指向父资源的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">sibling</span>;</span>       <span class="comment">/* 指向同级兄弟资源的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">child</span>;</span>         <span class="comment">/* 指向子资源的指针 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以下宏定义用于保留未使用的字段 */</span></span><br><span class="line">    ANDROID_KABI_RESERVE(<span class="number">1</span>);</span><br><span class="line">    ANDROID_KABI_RESERVE(<span class="number">2</span>);</span><br><span class="line">    ANDROID_KABI_RESERVE(<span class="number">3</span>);</span><br><span class="line">    ANDROID_KABI_RESERVE(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中最重要的是前四个参数，每个参数的具体介绍如下所示：</p>
<p>（1）resource_size_t start：资源的起始地址。它表示资源的起始位置或者起始寄存器的地址。</p>
<p>（2）resource_size_t end：资源的结束地址。它表示资源的结束位置或者结束寄存器的地址。</p>
<p>（3）const char *name：资源的名称。它是一个字符串，用于标识和描述资源。</p>
<p>（4）unsigned long flags：资源的标志位。它包含了一些特定的标志，用于表示资源的属性或者特征。例如，可以用标志位来指示资源的可用性、共享性、缓存属性等。flags参数的具体取值和含义可以根据系统和驱动的需求进行定义和解释，但通常情况下，它用于表示资源的属性、特征或配置选项。下面是一些常见的标志位及其可能的含义：</p>
<p><em><strong>*1. 资源类型相关标志位：*</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IORESOURCE_IO：表示资源是I/O端口资源。</span><br><span class="line">IORESOURCE_MEM：表示资源是内存资源。</span><br><span class="line">IORESOURCE_REG：表示资源是寄存器偏移量。</span><br><span class="line">IORESOURCE_IRQ：表示资源是中断资源。</span><br><span class="line">IORESOURCE_DMA：表示资源是DMA（直接内存访问）资源。</span><br></pre></td></tr></table></figure>

<p><em><strong>*2. 资源属性和特征相关标志位：*</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IORESOURCE_PREFETCH：表示资源是无副作用的预取资源。</span><br><span class="line">IORESOURCE_READONLY：表示资源是只读的。</span><br><span class="line">IORESOURCE_CACHEABLE：表示资源支持缓存。</span><br><span class="line">IORESOURCE_RANGELENGTH：表示资源的范围长度。</span><br><span class="line">IORESOURCE_SHADOWABLE：表示资源可以被影子资源替代。</span><br><span class="line">IORESOURCE_SIZEALIGN：表示资源的大小表示对齐。</span><br><span class="line">IORESOURCE_STARTALIGN：表示起始字段是对齐的。</span><br><span class="line">IORESOURCE_MEM_64：表示资源是64位内存资源。</span><br><span class="line">IORESOURCE_WINDOW：表示资源由桥接器转发。</span><br><span class="line">IORESOURCE_MUXED：表示资源是软件复用的。</span><br><span class="line">IORESOURCE_SYSRAM：表示资源是系统RAM（修饰符）。</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> <em><strong>*其他状态和控制标志位：*</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IORESOURCE_EXCLUSIVE：表示用户空间无法映射此资源。</span><br><span class="line">IORESOURCE_DISABLED：表示资源当前被禁用。</span><br><span class="line">IORESOURCE_UNSET：表示尚未分配地址给资源。</span><br><span class="line">IORESOURCE_AUTO：表示地址由系统自动分配。</span><br><span class="line">IORESOURCE_BUSY：表示驱动程序将此资源标记为繁忙。</span><br></pre></td></tr></table></figure>

<h2 id="51-2-实验程序的编写"><a href="#51-2-实验程序的编写" class="headerlink" title="51.2 实验程序的编写"></a>51.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\40_platform_device\。</p>
<p>本实验将注册一个名为 “my_platform_device” 的平台设备，当注册平台设备时，该驱动程序提供了两个资源：一个内存资源和一个中断资源。这些资源被定义在名为 my_resources 的结构体数组中,具体内容如下：</p>
<p><em><strong>*内存资源：*</strong></em></p>
<p>起始地址：MEM_START_ADDR（0xFDD60000）</p>
<p>结束地址：MEM_END_ADDR（0xFDD60004）</p>
<p>标记：IORESOURCE_MEM</p>
<p><em><strong>*中断资源：*</strong></em></p>
<p>中断资源号：IRQ_NUMBER（101）</p>
<p>标记：IORESOURCE_IRQ</p>
<p>编写完成的platform_device.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_START_ADDR 0xFDD60000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_END_ADDR   0xFDD60004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_NUMBER     101</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">my_resources</span>[] =</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .start = MEM_START_ADDR,    <span class="comment">// 内存资源起始地址</span></span><br><span class="line">        .end = MEM_END_ADDR,        <span class="comment">// 内存资源结束地址</span></span><br><span class="line">        .flags = IORESOURCE_MEM,    <span class="comment">// 标记为内存资源</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .start = IRQ_NUMBER,        <span class="comment">// 中断资源号</span></span><br><span class="line">        .end = IRQ_NUMBER,          <span class="comment">// 中断资源号</span></span><br><span class="line">        .flags = IORESOURCE_IRQ,    <span class="comment">// 标记为中断资源</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_platform_device_release</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 释放资源的回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">my_platform_device</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_platform_device&quot;</span>,                  <span class="comment">// 设备名称</span></span><br><span class="line">    .id = <span class="number">-1</span>,                                      <span class="comment">// 设备ID</span></span><br><span class="line">    .num_resources = ARRAY_SIZE(my_resources),     <span class="comment">// 资源数量</span></span><br><span class="line">    .resource = my_resources,                      <span class="comment">// 资源数组</span></span><br><span class="line">    .dev.release = my_platform_device_release,     <span class="comment">// 释放资源的回调函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_device_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = platform_device_register(&amp;my_platform_device);   <span class="comment">// 注册平台设备</span></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Platform device registered\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_device_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_device_unregister(&amp;my_platform_device);   <span class="comment">// 注销平台设备</span></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Platform device unregistered\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_device_init);</span><br><span class="line">module_exit(my_platform_device_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="51-3-运行测试"><a href="#51-3-运行测试" class="headerlink" title="51.3 运行测试"></a>51.3 运行测试</h2><h3 id="51-3-1-编译驱动程序"><a href="#51-3-1-编译驱动程序" class="headerlink" title="51.3.1 编译驱动程序"></a>51.3.1 编译驱动程序</h3><p>在上一小节中的platform_device.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_device.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_device.c和Makefile文件目录下，如下图（图51-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps2.jpg" alt="img"> </p>
<p>图 51-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图51-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps3.jpg" alt="img"> </p>
<p>图 51-2</p>
<p>编译完生成platform_device.ko目标文件，如下图（图51-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps4.jpg" alt="img"> </p>
<p>图 51-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="51-3-2-运行测试"><a href="#51-3-2-运行测试" class="headerlink" title="51.3.2 运行测试"></a>51.3.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图51-4）所示：</p>
<p>insmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps5.jpg" alt="img"> </p>
<p>图 51-4</p>
<p>然后来到&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;devices目录下，可以看到我们创建的my_platform_device设备文件夹就成功生成了。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps6.jpg" alt="img"> </p>
<p>图 51-5</p>
<p>然后使用以下命令进行驱动模块的卸载，如下图（图51-6）所示：</p>
<p>rmmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps7.jpg" alt="img"> </p>
<p>图 51-6</p>
<p>至此，注册platform设备实验就完成了。</p>
<h1 id="第52章-注册platform驱动实验"><a href="#第52章-注册platform驱动实验" class="headerlink" title="第52章 注册platform驱动实验"></a>第52章 注册platform驱动实验</h1><p>在上个章节我们学习了如何注册platform设备，而本章节就要学习如何注册platform驱动了。</p>
<h2 id="52-1注册platform驱动"><a href="#52-1注册platform驱动" class="headerlink" title="52.1注册platform驱动"></a>52.1注册platform驱动</h2><h3 id="52-1-1-platform-driver-register-函数"><a href="#52-1-1-platform-driver-register-函数" class="headerlink" title="52.1.1 platform_driver_register 函数"></a>52.1.1 platform_driver_register 函数</h3><p>platform_driver_register 函数用于在 Linux 内核中注册一个平台驱动程序。下面是对该函数的详细介绍：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int platform_driver_register(struct platform_driver *driver);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;platform_device.h&gt;</p>
<p><em><strong>*函数作用*</strong></em><em><strong>*：*</strong></em></p>
<p>platform_driver_register 函数用于将一个平台驱动程序注册到内核中。通过注册平台驱动程序，内核可以识别并与特定的平台设备进行匹配，并在需要时调用相应的回调函数。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>driver：指向 struct platform_driver 结构体的指针，描述了要注册的平台驱动程序的属性和回调函数（会在下面的小节对该结构体进行详细的讲解）。</p>
<p>****返回值****：</p>
<p>返回一个整数值，表示函数的执行状态。如果注册成功，返回 0；如果注册失败，返回一个负数错误码。</p>
<p>该函数在内核源码目录下的“&#x2F;include&#x2F;linux&#x2F;platform_device.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> platform_driver_register(drv) \</span></span><br><span class="line"><span class="meta">	__platform_driver_register(drv, THIS_MODULE)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __platform_driver_register(<span class="keyword">struct</span> platform_driver *,					<span class="keyword">struct</span> module *);</span><br></pre></td></tr></table></figure>

<p>这个宏用于简化平台驱动程序的注册过程。它将实际的注册函数 __platform_driver_register 与当前模块（驱动程序）关联起来。宏的参数 drv 是一个指向 struct platform_driver 结构体的指针，描述了要注册的平台驱动程序的属性和回调函数。THIS_MODULE 是一个宏，用于获取当前模块的指针。</p>
<p>而__platform_driver_register实际定义在“&#x2F;drivers&#x2F;base&#x2F;platform.c”文件中，相关定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __platform_driver_register(<span class="keyword">struct</span> platform_driver *drv, <span class="keyword">struct</span> module *owner)</span><br><span class="line">&#123;</span><br><span class="line">    drv-&gt;driver.owner = owner;                   <span class="comment">// 将平台驱动程序的所有权设置为当前模块</span></span><br><span class="line">    drv-&gt;driver.bus = &amp;platform_bus_type;    <span class="comment">// 将平台驱动程序的总线类型设置为平台总线</span></span><br><span class="line">    drv-&gt;driver.probe = platform_drv_probe;      <span class="comment">// 设置平台驱动程序的探测函数</span></span><br><span class="line">    drv-&gt;driver.remove = platform_drv_remove;    <span class="comment">// 设置平台驱动程序的移除函数</span></span><br><span class="line">    drv-&gt;driver.shutdown = platform_drv_shutdown;<span class="comment">// 设置平台驱动程序的关机函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> driver_register(&amp;drv-&gt;driver);        <span class="comment">// 将平台驱动程序注册到内核</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第3行：将指向当前模块的指针 owner 赋值给平台驱动程序的 owner 成员。这样做是为了将当前模块与平台驱动程序关联起来，以确保模块的生命周期和驱动程序的注册和注销相关联。</p>
<p>第4行：将指向平台总线类型的指针 &amp;platform_bus_type 赋值给平台驱动程序的 bus 成员。这样做是为了指定该驱动程序所属的总线类型为平台总线，以便内核能够将平台设备与正确的驱动程序进行匹配。</p>
<p>第5行：将指向平台驱动程序探测函数 platform_drv_probe 的指针赋值给平台驱动程序的 probe 成员。这样做是为了指定当内核发现与驱动程序匹配的平台设备时，要调用的驱动程序探测函数。</p>
<p>第6行：将指向平台驱动程序移除函数 platform_drv_remove 的指针赋值给平台驱动程序的 remove 成员。这样做是为了指定当内核需要从系统中移除与驱动程序匹配的平台设备时，要调用的驱动程序移除函数。</p>
<p>第7行 &#x3D; platform_drv_shutdown;：将指向平台驱动程序关机函数 platform_drv_shutdown 的指针赋值给平台驱动程序的 shutdown 成员。这样做是为了指定当系统关机时，要调用的驱动程序关机函数。</p>
<p>第9行：调用 driver_register 函数，将平台驱动程序的 driver 成员注册到内核中。该函数负责将驱动程序注册到相应的总线上，并在注册成功时返回 0，注册失败时返回一个负数错误码。</p>
<p>通过这些操作，__platform_driver_register 函数将平台驱动程序与内核关联起来，并确保内核能够正确识别和调用驱动程序的各种回调函数，以实现与平台设备的交互和管理。函数的返回值表示注册过程的执行状态，以便在需要时进行错误处理。</p>
<h3 id="52-1-2-platform-device-unregister-函数"><a href="#52-1-2-platform-device-unregister-函数" class="headerlink" title="52.1.2 platform_device_unregister 函数"></a>52.1.2 platform_device_unregister 函数</h3><p>platform_device_unregister函数用于取消注册已经注册的平台设备，即从内核中移除设备。在设备不再需要时，调用该函数可以进行设备的清理和释放操作。</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>void platform_device_unregister(struct platform_device *pdev);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;platform_device.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em><br>    platform_device_unregister 函数用于从内核中注销平台设备。通过调用该函数，可以将指定的平台设备从系统中移除。</p>
<p>****参数含义****：</p>
<p>pdev：指向要注销的平台设备的指针。</p>
<p><em><strong>*返回值：*</strong></em><br>    无返回值。</p>
<p>该函数在内核源码目录下的“&#x2F;include&#x2F;linux&#x2F;platform_device.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">platform_driver_unregister</span><span class="params">(<span class="keyword">struct</span> platform_driver *)</span>;</span><br></pre></td></tr></table></figure>

<p>函数声明中的extern关键字表示该函数在其他地方定义，而不是在当前文件中实现。这样的声明通常出现在头文件中，用于告诉编译器该函数的定义存在于其他源文件中，以便在编译时能够正确引用该函数。</p>
<p>而platform_driver_unregister实际定义在“&#x2F;drivers&#x2F;base&#x2F;platform.c”文件中，相关定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">platform_driver_unregister</span><span class="params">(<span class="keyword">struct</span> platform_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">	driver_unregister(&amp;drv-&gt;driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数又调用了driver_unregister函数进行嵌套，追踪之后找到定义在“&#x2F;drivers&#x2F;base&#x2F;driver.c”目录下的driver_unregister函数，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">driver_unregister</span><span class="params">(<span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查传入的设备驱动程序指针和 p 成员是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (!drv || !drv-&gt;p) &#123;</span><br><span class="line">        WARN(<span class="number">1</span>, <span class="string">&quot;Unexpected driver unregister!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    driver_remove_groups(drv, drv-&gt;groups); <span class="comment">// 移除与设备驱动程序关联的属性组</span></span><br><span class="line">    bus_remove_driver(drv);    <span class="comment">// 从总线中移除设备驱动程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数内部有三个主要的操作：</p>
<p>第4-7行：检查传入的设备驱动程序指针 drv 是否为空，或者驱动程序的 p 成员是否为空。如果其中任何一个条件为真，表示传入的参数无效，会发出警告并返回。</p>
<p>第9行：调用 driver_remove_groups 函数，用于从内核中移除与设备驱动程序关联的属性组。drv-&gt;groups 是指向属性组的指针，指定了要移除的属性组列表。</p>
<p>第10行：调用 bus_remove_driver 函数，用于从总线中移除设备驱动程序。该函数会执行以下操作：</p>
<p>（1）从总线驱动程序列表中移除指定的设备驱动程序。</p>
<p>（2）调用与设备驱动程序关联的 remove 回调函数（如果有定义）。</p>
<p>（3）释放设备驱动程序所占用的资源和内存。</p>
<p>（4）最终销毁设备驱动程序的数据结构。</p>
<p>通过调用 driver_unregister 函数，可以正确地注销设备驱动程序，并在注销过程中进行必要的清理工作。这样可以避免资源泄漏和其他问题。在调用该函数后，应避免继续使用已注销的设备驱动程序指针，因为该驱动程序已不再存在于内核中。</p>
<h3 id="52-1-3-platform-driver结构体"><a href="#52-1-3-platform-driver结构体" class="headerlink" title="52.1.3 platform_driver结构体"></a>52.1.3 platform_driver结构体</h3><p>platform_driver 结构体是Linux内核中用于编写平台设备驱动程序的重要数据结构。它提供了与平台设备驱动相关的函数和数据成员，以便与平台设备进行交互和管理。该结构体定义在内核的“&#x2F;include&#x2F;linux&#x2F;platform_device.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*probe)(<span class="keyword">struct</span> platform_device *); <span class="comment">/* 平台设备的探测函数指针 */</span></span><br><span class="line">	<span class="type">int</span> (*remove)(<span class="keyword">struct</span> platform_device *); <span class="comment">/* 平台设备的移除函数指针 */</span></span><br><span class="line">	<span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> platform_device *);<span class="comment">/* 平台设备的关闭函数指针 */</span></span><br><span class="line">	<span class="type">int</span> (*suspend)(<span class="keyword">struct</span> platform_device *, <span class="type">pm_message_t</span> state);<span class="comment">/* 平台设备的挂起函数指针 */</span></span><br><span class="line">	<span class="type">int</span> (*resume)(<span class="keyword">struct</span> platform_device *);<span class="comment">/* 平台设备的恢复函数指针 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span><span class="comment">/* 设备驱动程序的通用数据 */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_table</span>;</span><span class="comment">/* 平台设备与驱动程序的关联关系表 */</span></span><br><span class="line">	<span class="type">bool</span> prevent_deferred_probe; <span class="comment">/* 是否阻止延迟探测 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>probe：平台设备的探测函数指针。当系统检测到一个平台设备与该驱动程序匹配时，该函数将被调用以初始化和配置设备。</p>
<p>remove：平台设备的移除函数指针。当平台设备从系统中移除时，该函数将被调用以执行清理和释放资源的操作。</p>
<p>shutdown：平台设备的关闭函数指针。当系统关闭时，该函数将被调用以执行与平台设备相关的关闭操作。</p>
<p>suspend：平台设备的挂起函数指针。当系统进入挂起状态时，该函数将被调用以执行与平台设备相关的挂起操作。</p>
<p>resume：平台设备的恢复函数指针。当系统从挂起状态恢复时，该函数将被调用以执行与平台设备相关的恢复操作。</p>
<p>driver：包含了与设备驱动程序相关的通用数据，它是 struct device_driver 类型的实例。其中包括驱动程序的名称、总线类型、模块拥有者、属性组数组指针等信息，该结构体的name参数需要与上个章节的platform_device的.name参数相同才能匹配成功，从而进入probe函数。</p>
<p>id_table：指向 struct platform_device_id 结构体数组的指针，用于匹配平台设备和驱动程序之间的关联关系。通过该关联关系，可以确定哪个平台设备与该驱动程序匹配，和.driver.name起到相同的作用，但是优先级高于.driver.name。</p>
<p>prevent_deferred_probe：一个布尔值，用于确定是否阻止延迟探测。如果设置为 true，则延迟探测将被禁用。</p>
<p>使用 struct platform_driver 结构体，开发人员可以定义平台设备驱动程序，并将其注册到内核中。当系统检测到与该驱动程序匹配的平台设备时，内核将调用相应的函数来执行设备的初始化、配置、操作和管理。驱动程序可以利用提供的函数指针和通用数据与平台设备进行交互，并提供必要的功能和服务。</p>
<p>需要注意的是，struct platform_driver 结构体继承了 struct device_driver 结构体，因此可以直接访问 struct device_driver 中定义的成员。这使得平台驱动程序可以利用通用的驱动程序机制，并与其他类型的设备驱动程序共享代码和功能。</p>
<h2 id="52-2-实验程序的编写"><a href="#52-2-实验程序的编写" class="headerlink" title="52.2 实验程序的编写"></a>52.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\41。</p>
<p>本小节的实验只是编写一个platform驱动的一个大体框架，在下一个章节中再讲解platform设备和platform驱动的匹配</p>
<p>编写完成的platform_driver.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的探测函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_probe: Probing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Removing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="52-3-运行测试"><a href="#52-3-运行测试" class="headerlink" title="52.3 运行测试"></a>52.3 运行测试</h2><h3 id="52-3-1-编译驱动程序"><a href="#52-3-1-编译驱动程序" class="headerlink" title="52.3.1 编译驱动程序"></a>52.3.1 编译驱动程序</h3><p>在上一小节中的platform_driver.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_driver.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_driver.c和Makefile文件目录下，如下图（图52-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps8.jpg" alt="img"> </p>
<p>图 52-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图52-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps9.jpg" alt="img"> </p>
<p>图 51-2</p>
<p>编译完生成platform_driver.ko目标文件，如下图（图52-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps10.jpg" alt="img"> </p>
<p>图 52-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="52-3-2-运行测试"><a href="#52-3-2-运行测试" class="headerlink" title="52.3.2 运行测试"></a>52.3.2 运行测试</h3><p>本小节的测试需要用到两个驱动ko文件，即上一章节的注册platform设备ko文件和本章节的注册platform驱动ko文件。</p>
<p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图21-7）所示：</p>
<p>insmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps11.jpg" alt="img"> </p>
<p>然后来到&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;drivers目录下，可以看到我们创建的my_platform_driver驱动文件夹就成功生成了。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps12.jpg" alt="img"> </p>
<p>然后使用以下命令加载注册platform设备ko文件，加载成功之后如下图所示：</p>
<p> insmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps13.jpg" alt="img"> </p>
<p>可以看到匹配成功之后就会进入probe函数，显示出了相应的打印（加载上述两个ko文件不分先后顺序）。然后使用以下命令进行驱动模块的卸载，如下图（图21-7）所示：</p>
<p>rmmod platform_driver.ko</p>
<p>rmmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps14.jpg" alt="img"> </p>
<p>至此，注册platform驱动实验就完成了。</p>
<h1 id="第53章-probe函数编写实验"><a href="#第53章-probe函数编写实验" class="headerlink" title="第53章 probe函数编写实验"></a>第53章 probe函数编写实验</h1><p>在上面的两个章节中分别注册了platform设备和platform驱动，匹配成功之后会进入在注册platform驱动程序中编写的probe函数，在上个章节只是为了验证是否匹配成功，所以只是在probe中加入了一句相关打印，而驱动是要控制硬件的，但是平台总线模型对硬件的描述写在了platform_device.c中,platform设备和platform驱动匹配成功之后，那我们如何在驱动platform_driver.c的probe函数中，得到platform_device.c中编写的硬件资源呢。下面开始本节课程的学习吧。</p>
<h2 id="53-1-获取device资源"><a href="#53-1-获取device资源" class="headerlink" title="53.1 获取device资源"></a>53.1 获取device资源</h2><p><em><strong>*方法*</strong></em><em><strong>*1*</strong></em><em><strong>*：直接访问 platform_device 结构体的资源数组*</strong></em></p>
<p>在上一章节的讲解中提到：struct platform_driver 结构体继承了 struct device_driver 结构体，因此可以直接访问 struct device_driver 中定义的成员。实例代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (pdev-&gt;num_resources &gt;= 2) &#123;</span><br><span class="line">      struct resource *res_mem = &amp;pdev-&gt;resource[0];</span><br><span class="line">      struct resource *res_irq = &amp;pdev-&gt;resource[1];</span><br><span class="line"></span><br><span class="line">      // 使用获取到的硬件资源进行处理</span><br><span class="line">      printk(&quot;Method 1: Memory Resource: start = 0x%lld, end = 0x%lld\n&quot;,</span><br><span class="line">              res_mem-&gt;start, res_mem-&gt;end);</span><br><span class="line">      printk(&quot;Method 1: IRQ Resource: number = %lld\n&quot;, res_irq-&gt;start);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在这种方法中，直接访问platform_device结构体的资源数组来获取硬件资源。pdev-&gt;resource是一个资源数组，其中存储了设备的硬件资源信息。通过访问数组的不同索引，可以获取到特定的资源。</p>
<p>在这个示例中，假设资源数组的第一个元素是内存资源，第二个元素是中断资源。所以我们将第一个元素的指针赋值给res_mem，第二个元素的指针赋值给res_irq。</p>
<p><em><strong>*方法*</strong></em><em><strong>*2*</strong></em><em><strong>*：使用 platform_get_resource() 获取硬件资源*</strong></em></p>
<p>platform_get_resource()函数用于获取设备的资源信息。它的声明位于&lt;linux&#x2F;platform_device.h&gt;头文件中，与平台设备（platform_device）相关。</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>struct resource *platform_get_resource(struct platform_device *pdev,                    unsigned int type, unsigned int num);</p>
<p><em><strong>*参数说明：*</strong></em></p>
<p>pdev：指向要获取资源的平台设备（platform_device）结构体的指针。</p>
<p>type：指定资源的类型，可以是以下值之一：</p>
<p>IORESOURCE_MEM：表示内存资源。</p>
<p>IORESOURCE_IO：表示I&#x2F;O资源。</p>
<p>IORESOURCE_IRQ：表示中断资源。</p>
<p>其他资源类型的宏定义可在&lt;linux&#x2F;ioport.h&gt;和&lt;linux&#x2F;irq.h&gt;头文件中找到。</p>
<p>num：指定要获取的资源的索引。在一个设备中可能存在多个相同类型的资源，通过索引可以选择获取特定的资源。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>如果成功获取资源，则返回指向资源（struct resource）的指针。</p>
<p>如果获取资源失败，或者指定的资源不存在，则返回NULL。</p>
<p>platform_get_resource()函数用于从平台设备的资源数组中获取指定类型和索引的资源。在平台设备的资源数组中，每个元素都是一个struct resource结构体，描述了一个资源的信息，如起始地址、结束地址、中断号等。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line"></span><br><span class="line">res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!res) &#123;</span><br><span class="line">    <span class="comment">// 处理获取内存资源失败的情况</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用获取到的内存资源进行处理</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> start = res-&gt;start;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> end = res-&gt;end;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在上述示例中，首先通过platform_get_resource()函数获取平台设备的第一个内存资源（索引为0）。如果获取资源失败（返回NULL），则可以根据实际情况进行错误处理。如果获取资源成功，则可以使用返回的资源指针来访问资源的信息，如起始地址和结束地址。</p>
<p>通过platform_get_resource()函数，可以方便地在驱动程序中获取平台设备的资源信息，并根据这些信息进行后续的操作和配置。</p>
<h2 id="53-2-实验程序的编写"><a href="#53-2-实验程序的编写" class="headerlink" title="53.2 实验程序的编写"></a>53.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\42_probe。</p>
<p>在上一章程序的基础上，添加第一小节两种获取设备资源的方式并打印出来。</p>
<p>编写完成的probe.c代码如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_driver_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res_mem</span>, *<span class="title">res_irq</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法1：直接访问 platform_device 结构体的资源数组</span></span><br><span class="line">    <span class="keyword">if</span> (pdev-&gt;num_resources &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res_mem</span> =</span> &amp;pdev-&gt;resource[<span class="number">0</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res_irq</span> =</span> &amp;pdev-&gt;resource[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用获取到的硬件资源进行处理</span></span><br><span class="line">        printk(<span class="string">&quot;Method 1: Memory Resource: start = 0x%llx, end = 0x%llx\n&quot;</span>,</span><br><span class="line">                res_mem-&gt;start, res_mem-&gt;end);</span><br><span class="line">        printk(<span class="string">&quot;Method 1: IRQ Resource: number = %lld\n&quot;</span>, res_irq-&gt;start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法2：使用 platform_get_resource() 获取硬件资源</span></span><br><span class="line">    res_mem = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!res_mem) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get memory resource\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res_irq = platform_get_resource(pdev, IORESOURCE_IRQ, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!res_irq) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get IRQ resource\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用获取到的硬件资源进行处理</span></span><br><span class="line">    printk(<span class="string">&quot;Method 2: Memory Resource: start = 0x%llx, end = 0x%llx\n&quot;</span>,</span><br><span class="line">            res_mem-&gt;start, res_mem-&gt;end);</span><br><span class="line">    printk(<span class="string">&quot;Method 2: IRQ Resource: number = %lld\n&quot;</span>, res_irq-&gt;start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_driver_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设备移除操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>, <span class="comment">// 与 platform_device.c 中的设备名称匹配</span></span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = my_platform_driver_probe,</span><br><span class="line">    .remove = my_platform_driver_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver); <span class="comment">// 注册平台驱动</span></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;Platform driver registered\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver); <span class="comment">// 注销平台驱动</span></span><br><span class="line">    printk(<span class="string">&quot;Platform driver unregistered\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="53-3-运行测试"><a href="#53-3-运行测试" class="headerlink" title="53.3 运行测试"></a>53.3 运行测试</h2><h3 id="53-3-1-编译驱动程序"><a href="#53-3-1-编译驱动程序" class="headerlink" title="53.3.1 编译驱动程序"></a>53.3.1 编译驱动程序</h3><p>在上一小节中的probe.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += probe.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放probe.c和Makefile文件目录下，如下图（图53-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps15.jpg" alt="img"> </p>
<p>图 53-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图53-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps16.jpg" alt="img"> </p>
<p>图 53-2</p>
<p>编译完生成probe.ko目标文件，如下图（图53-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps17.jpg" alt="img"> </p>
<p>图 53-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="53-3-2-运行测试"><a href="#53-3-2-运行测试" class="headerlink" title="53.3.2 运行测试"></a>53.3.2 运行测试</h3><p>本小节的测试要使用两个ko文件，第一个ko文件为第53章编译出来的platform_device.ko驱动，第二个ko文件为在上一小节编译出的probe.ko驱动文件。</p>
<p>开发板启动之后，首先使用以下命令进行platform设备的注册，如下图（图53-4）所示：</p>
<p>insmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps18.jpg" alt="img"> </p>
<p>图 53-4</p>
<p>然后继续使用以下命令加载probe.ko驱动，打印如下图（53-5）所示：</p>
<p>insmod probe.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps19.jpg" alt="img"> </p>
<p>图 53-5</p>
<p>在上图中，打印了两种方式下获取得到的内存信息和中断信息，最后可以使用以下命令进行驱动的卸载，如下图（图53-6）所示：</p>
<p>rmmod  probe.ko</p>
<p>rmmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps20.jpg" alt="img"> </p>
<p>图 53-6</p>
<h1 id="第54章-点亮LED灯实验（平台总线）"><a href="#第54章-点亮LED灯实验（平台总线）" class="headerlink" title="第54章 点亮LED灯实验（平台总线）"></a>第54章 点亮LED灯实验（平台总线）</h1><p>在上个章节中，我们成功在platform驱动程序中读取到了设备资源信息，在本章节将进行具体的项目实践，要求在上节platform驱动程序的基础上，加入控制LED灯相关的代码（这部分代码可以参考“第18章 点亮LED灯实验”）。</p>
<h2 id="54-1-实验程序的编写"><a href="#54-1-实验程序的编写" class="headerlink" title="54.1 实验程序的编写"></a>54.1 实验程序的编写</h2><h3 id="54-1-1-驱动程序编写"><a href="#54-1-1-驱动程序编写" class="headerlink" title="54.1.1 驱动程序编写"></a>54.1.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\43_platform_led\module。</p>
<p>编写完成的platform_led.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *vir_gpio_dr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(test_dev-&gt;kbuf[<span class="number">0</span>]==<span class="number">1</span>)&#123;   <span class="comment">//如果应用层传入的数据是1，则打开灯</span></span><br><span class="line">            *(test_dev-&gt;vir_gpio_dr) = <span class="number">0x8000c040</span>;   <span class="comment">//设置数据寄存器的地址</span></span><br><span class="line">              printk(<span class="string">&quot;test_dev-&gt;kbuf [0]  is %d\n&quot;</span>,test_dev-&gt;kbuf[<span class="number">0</span>]);  <span class="comment">//打印传入的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(test_dev-&gt;kbuf[<span class="number">0</span>]==<span class="number">0</span>)  <span class="comment">//如果应用层传入的数据是0，则关闭灯</span></span><br><span class="line">    &#123;</span><br><span class="line">            *(test_dev-&gt;vir_gpio_dr) = <span class="number">0x80004040</span>; <span class="comment">//设置数据寄存器的地址</span></span><br><span class="line">            printk(<span class="string">&quot;test_dev-&gt;kbuf [0]  is %d\n&quot;</span>,test_dev-&gt;kbuf[<span class="number">0</span>]); <span class="comment">//打印传入的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_driver_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res_mem</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!res_mem) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get memory resource\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line">    dev1.vir_gpio_dr=ioremap(res_mem-&gt;start,<span class="number">4</span>);  <span class="comment">//将物理地址转化为虚拟地址</span></span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.vir_gpio_dr))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.vir_gpio_dr);  <span class="comment">//PTR_ERR()来返回错误代码</span></span><br><span class="line">        <span class="keyword">goto</span> err_ioremap;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_ioremap:</span><br><span class="line">        iounmap(dev1.vir_gpio_dr);</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_driver_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设备移除操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>, <span class="comment">// 与 platform_device.c 中的设备名称匹配</span></span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = my_platform_driver_probe,</span><br><span class="line">    .remove = my_platform_driver_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver); <span class="comment">// 注册平台驱动</span></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;Platform driver registered\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">	platform_driver_unregister(&amp;my_platform_driver); <span class="comment">// 注销平台驱动</span></span><br><span class="line">    printk(<span class="string">&quot;Platform driver unregistered\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="54-1-2-编写测试-APP"><a href="#54-1-2-编写测试-APP" class="headerlink" title="54.1.2 编写测试 APP"></a>54.1.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\43_platform_led\app。</p>
<p>编写测试app,led驱动加载成功之后会生成&#x2F;dev&#x2F;test节点，应用程序APP通过操作&#x2F;dev&#x2F;test文件来完成对LED设备的控制。向&#x2F;dev&#x2F;test文件写入0表示关闭LED灯，写入1表示打开LED灯。编写完成的应用程序app.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开led驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// atoi()将字符串转为整型，这里将第一个参数转化为整型后，存放在 buf[0]中</span></span><br><span class="line">buf[<span class="number">0</span>] =atoi(argv[<span class="number">1</span>]);  </span><br><span class="line">write(fd,buf,<span class="keyword">sizeof</span>(buf));  <span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="54-2-运行测试"><a href="#54-2-运行测试" class="headerlink" title="54.2 运行测试"></a>54.2 运行测试</h2><h3 id="54-2-1-编译驱动程序"><a href="#54-2-1-编译驱动程序" class="headerlink" title="54.2.1 编译驱动程序"></a>54.2.1 编译驱动程序</h3><p>在上一小节中的platform_led.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_led.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_led.c和Makefile文件目录下，如下图（图54-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps21.jpg" alt="img"> </p>
<p>图 54-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图54-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps22.jpg" alt="img"> </p>
<p>图 54-2</p>
<p>编译完生成platform_led.ko目标文件，如下图（图54-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps23.jpg" alt="img"> </p>
<p>图 54-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="54-2-2-编译应用程序"><a href="#54-2-2-编译应用程序" class="headerlink" title="54.2.2 编译应用程序"></a>54.2.2 编译应用程序</h3><p>下面进行应用程序编译，因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图54-4）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps24.jpg" alt="img"> </p>
<p>图 54-4</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="54-2-3-运行测试"><a href="#54-2-3-运行测试" class="headerlink" title="54.2.3 运行测试"></a>54.2.3 运行测试</h3><p>本小节的测试要使用两个ko文件和一个测试应用程序，第一个ko文件为第53章编译出来的platform_device.ko驱动，第二个ko文件为在上一小节编译出的probe.ko驱动文件，应用程序为上一小节编译出来的app。</p>
<p>开发板启动之后，首先使用以下命令进行platform设备的注册，如下图（图54-5）所示：</p>
<p>insmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps25.jpg" alt="img"> </p>
<p>图 54-5</p>
<p>然后继续使用以下命令加载platform_led.ko驱动，打印如下图（54-6）所示：</p>
<p>insmod platform_led.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps26.jpg" alt="img"> </p>
<p>图 54-6</p>
<p>可以看到led字符设备成功注册了，主设备号为236，次设备号为0，相应的test节点也成功创建了，如下图（54-7）所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps27.jpg" alt="img"></p>
<p>图 54-7</p>
<p>默认情况下led灯的状态为常亮，然后输入“.&#x2F;app 0”命令LED灯熄灭，如下图（图 54-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps28.jpg" alt="img"> </p>
<p>图 54-8</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps29.jpg" alt="img"> </p>
<p>图 54-9</p>
<p>然后输入“.&#x2F;app 0”，LED灯点亮，如下图（图 54-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps30.jpg" alt="img"> </p>
<p>图 54-10</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps31.jpg" alt="img"> </p>
<p>图 54-11</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图54-12）所示：</p>
<p>rmmod platform_led.ko</p>
<p>rmmod platform_device.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps32.jpg" alt="img"> </p>
<p>图 54-12</p>
<p>至此，使用平台总线的点亮LCD灯实验就完成了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B3%E5%8F%B0%E6%80%BB%E7%BA%BF/" rel="tag">平台总线</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-rk3568-驱动开发第五篇-中断"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%94%E7%AF%87-%E4%B8%AD%E6%96%AD/"
    >rk3568 驱动开发第五篇 中断</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%94%E7%AF%87-%E4%B8%AD%E6%96%AD/" class="article-date">
  <time datetime="2023-09-04T12:55:48.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第39章-中断实验"><a href="#第39章-中断实验" class="headerlink" title="第39章 中断实验"></a>第39章 中断实验</h1><p>在前面的课程中，我们深入学习了高级字符设备的进阶知识，包括IO模型、定时器原理、llseek设备定位和通过ioctl传递参数等。通过这些课程，我们对高级字符设备有了深入的理解，并掌握了一些实用的技术和编程方法。从今天开始，我们就进入中断课程的学习了。中断是操作系统中至关重要的机制，它能够显著提高系统的响应性能和并发处理能力。</p>
<h2 id="39-1什么是中断？"><a href="#39-1什么是中断？" class="headerlink" title="39.1什么是中断？"></a>39.1什么是中断？</h2><h3 id="39-1-1-中断的概念"><a href="#39-1-1-中断的概念" class="headerlink" title="39.1.1 中断的概念"></a>39.1.1 中断的概念</h3><p>中断是指在CPU正常运行期间，由外部或内部事件引起的一种机制。当中断发生时，CPU会停止当前正在执行的程序，并转而执行触发该中断的中断处理程序。处理完中断处理程序后，CPU会返回到中断发生的地方，继续执行被中断的程序。中断机制允许CPU在实时响应外部或内部事件的同时，保持对其他任务的处理能力。</p>
<p>可以想象这样一幅画面，你正在烹饪一顿美味的晚餐，准备了各种食材，点燃了炉灶，开始了幸福的烹饪过程，突然，你的手机响起，有人打来了一个紧急电话，打破了你正常的烹饪流程，这时候你需要立刻停止手中的工作，迅速接起电话，与对方进行交流，在接完电话之后，再回到厨房继续之前的烹饪流程。这就是一个在实际生活中的中断案例，中断的概念流程图如下（39-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps33.jpg" alt="img"> </p>
<p>图 39-1</p>
<h3 id="39-1-2-中断的重要性"><a href="#39-1-2-中断的重要性" class="headerlink" title="39.1.2 中断的重要性"></a>39.1.2 中断的重要性</h3><p>在上面的场景中，作为唯一具有处理能力的主体，我们一次只能专注于一个任务，可以等待水烧开、看电视等等。然而，当我们专心致志地完成一项任务时，常常会有紧迫或不紧迫的其他事情突然出现，需要我们关注和处理。有些情况甚至要求我们立即停下手头的工作来应对。只有在处理完这些中断事件之后，我们才能回到先前的任务。</p>
<p>中断机制赋予了我们处理意外情况的能力，而且如果我们能充分利用这个机制，就能够同时完成多个任务。回到烧水的例子，无论我们是否在厨房，煤气灶都会将水烧开。我们只需要在水烧开后及时关掉煤气。为了避免在厨房等待的时间，而水烧开时产生的声音就是中断信号，提醒我们炉子上的水已经烧开。这样，我们就可以在等待的时间里做其他事情，比如看电视。当水壶烧开发出声音之后，它会打断当前的任务，提醒水已经烧开，这时只需要前往厨房关掉煤气即可。</p>
<p>中断机制使我们能够有条不紊地同时处理多个任务，从而提高了并发处理能力。类似地，计算机系统中也使用中断机制来应对各种外部事件。例如，在键盘输入时，会发送一个中断信号给CPU，以便及时响应用户的操作。这样，CPU就不必一直轮询键盘的状态，而可以专注于其他任务。中断机制还可以用于处理硬盘读写完成、网络数据包接收等事件，提高了系统的资源利用率和并发处理能力。</p>
<h3 id="39-1-3-中断的上下半部"><a href="#39-1-3-中断的上下半部" class="headerlink" title="39.1.3 中断的上下半部"></a>39.1.3 中断的上下半部</h3><p>中断的执行需要快速响应，但并不是所有中断都能迅速完成。此外，Linux中的中断不支持嵌套，意味着在正式处理中断之前会屏蔽其他中断，直到中断处理完成后再重新允许接收中断，如果中断处理时间过长，将会引发问题。</p>
<p>这里仍旧以烹饪的过程中接电话进行举例：当你正在烹饪一顿美味的晚餐时，所有的食材都准备好了，炉灶上的火焰跳跃着，你正享受着烹饪的乐趣。突然，你的手机响起，发出紧急电话的铃声，打破了你正常的烹饪流程，接电话的时间很短并不会对烹饪产生很大的影响，而接电话的时候可能就有问题了，水烧开之后可能会煮干、错过了最好的添加调味料的时间等等。</p>
<p>而为了让系统可以更好地处理中断事件，提高实时性和响应能力，将中断服务程序划分为上下文两部分：</p>
<p>中断上文是中断服务程序的第一部分，它主要处理一些紧急且需要快速响应的任务。中断上文的特点是执行时间较短，旨在尽快完成对中断的处理。这些任务可能包括保存寄存器状态、更新计数器等，以便在中断处理完成后能够正确地返回到中断前的执行位置。</p>
<p>中断下文是中断服务程序的第二部分，它主要处理一些相对耗时的任务。由于中断上文需要尽快完成，因此中断下文负责处理那些不能立即完成的、需要更多时间的任务。这些任务可能包括复杂的计算、访问外部设备或进行长时间的数据处理等。</p>
<h2 id="39-2中断子系统框架"><a href="#39-2中断子系统框架" class="headerlink" title="39.2中断子系统框架"></a>39.2中断子系统框架</h2><p>一个完整的中断子系统框架可以分为四个层次，由上到下分别为用户层、通用层、硬件相关层和硬件层，每个层相关的介绍如下（图39-2）所示：</p>
<p>****用户层：****用户层是中断的使用者，主要包括各类设备驱动。这些驱动程序通过中断相关的接口进行中断的申请和注册。当外设触发中断时，用户层驱动程序会进行相应的回调处理，执行特定的操作。</p>
<p>****通用层：****通用层也可称为框架层，它是硬件无关的层次。通用层的代码在所有硬件平台上都是通用的，不依赖于具体的硬件架构或中断控制器。通用层提供了统一的接口和功能，用于管理和处理中断，使得驱动程序能够在不同的硬件平台上复用。</p>
<p>****硬件相关层：****硬件相关层包含两部分代码。一部分是与特定处理器架构相关的代码，比如ARM64处理器的中断处理相关代码。这些代码负责处理特定架构的中断机制，包括中断向量表、中断处理程序等。另一部分是中断控制器的驱动代码，用于与中断控制器进行通信和配置。这些代码与具体的中断控制器硬件相关。</p>
<p>****硬件层：****硬件层位于最底层，与具体的硬件连接相关。它包括外设与SoC（系统片上芯片）的物理连接部分。中断信号从外设传递到中断控制器，由中断控制器统一管理和路由到处理器。硬件层的设计和实现决定了中断信号的传递方式和硬件的中断处理能力。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps34.jpg" alt="img"> </p>
<p>图 39-2</p>
<p>本小节的重点会聚集在硬件层各部分的详细讲解以及用户层编写驱动程序所用到的接口函数。</p>
<h3 id="39-2-1-中断控制器GIC"><a href="#39-2-1-中断控制器GIC" class="headerlink" title="39.2.1 中断控制器GIC"></a>39.2.1 中断控制器GIC</h3><p>中断控制器GIC（Generic Interrupt Controller）是中断子系统框架硬件层中的一个关键组件，用于管理和控制中断。它接收来自各种中断源的中断请求，并根据预先配置的中断优先级、屏蔽和路由规则，将中断请求分发给适当的处理器核心或中断服务例程。</p>
<p>GIC是由ARM公司提出设计规范，当前有四个版本，GIC V1-v4。设计规范中最常用的，有3个版本V2.0、V3.1、V4.1，GICv3版本设计主要运行在Armv8-A, Armv9-A等架构上。ARM公司并给出一个实际的控制器设计参考，比如GIC-400(支持GIC v2架构)、gic500(支持GIC v3架构)、GIC-600(支持GIC v3和GIC v4架构)。最终芯片厂商可以自己实现GIC或者直接购买ARM提供的设计。</p>
<p>每个GIC版本及相应特性如下表（表 39-3）所示：</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>关键特性</th>
<th>常用核心</th>
</tr>
</thead>
<tbody><tr>
<td>GICv1</td>
<td>-支持最多八个处理器核心（PE）- 支持最多1020个中断ID</td>
<td>ARM Cortex-A5 MPCoreARM Cortex-A9 MPCoreARM Cortex-R7 MPCore</td>
</tr>
<tr>
<td>GICv2</td>
<td>- GICv1的所有关键特性-支持虚拟化</td>
<td>ARM Cortex-A7 MPCoreARM Cortex-A15 MPCoreARM Cortex-A53 MPCoreARM Cortex-A57 MPCore</td>
</tr>
<tr>
<td>GICv3</td>
<td>- GICv2的所有关键特性-支持超过8个处理器核心-支持基于消息的中断-支持超过1020个中断ID- CPU接口寄存器的系统寄存器访问-增强的安全模型，分离安全和非安全的Group 1中断</td>
<td>ARM Cortex-A53MPCoreARM Cortex-A57MPCoreARM Cortex-A72 MPCore</td>
</tr>
<tr>
<td>GICv4</td>
<td>- GICv3的所有关键特性-虚拟中断的直接注入</td>
<td>ARM Cortex-A53 MPCoreARMCortex-A57MPCoreARM Cortex-A72 MPCore</td>
</tr>
</tbody></table>
<p>表 39-3</p>
<p>在RK3568上使用的GIC版本为GICv3，相应的中断控制器模型如下（图 39-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps35.jpg" alt="img"> </p>
<p>图 39-4</p>
<p>GIC中断控制器可以分为Distributor接口、Redistributor接口和CPU接口，下面是每个部分的说明：</p>
<p><em><strong>*Distributor*</strong></em><em><strong>*中断仲裁器：*</strong></em></p>
<p>包含影响所有处理器核心中断的全局设置。包含以下编程接口：</p>
<p>●启用和禁用SPI。</p>
<p>●设置每个SPI的优先级级别。</p>
<p>●每个SPI的路由信息。</p>
<p>●将每个SPI设置为电平触发或边沿触发。</p>
<p>●生成基于消息的SPI。</p>
<p>●控制SPI的活动和挂起状态。</p>
<p>●用于确定在每个安全状态中使用的程序员模型的控制（亲和性路由或遗留模型）。</p>
<p>****Redistributor重新分配器****：</p>
<p>对于每个连接的处理器核心（PE），都有一个重新分配器（Redistributor）。重新分配器提供以下编程接口：</p>
<p>●启用和禁用SGI（软件生成的中断）和PPI（处理器专用中断）。</p>
<p>●设置SGI和PPI的优先级级别。</p>
<p>●将每个PPI设置为电平触发或边沿触发。</p>
<p>●将每个SGI和PPI分配给一个中断组。</p>
<p>●控制SGI和PPI的状态。</p>
<p>●对支持关联LPI（低功耗中断）的中断属性和挂起状态的内存中的数据结构进行基址控制。</p>
<p>●支持与连接的处理器核心的电源管理。</p>
<p><em><strong>*CPU接口*</strong></em><em><strong>*：*</strong></em></p>
<p>每个重新分配器都连接到一个CPU接口。CPU接口提供以下编程接口：</p>
<p>●通用控制和配置，用于启用中断处理。</p>
<p>●确认中断。</p>
<p>●执行中断的优先级降低和停用。</p>
<p>●为处理器核心设置中断优先级屏蔽。</p>
<p>●定义处理器核心的抢占策略。</p>
<p>●确定处理器核心最高优先级的挂起中断。</p>
<h3 id="39-2-2-中断类型"><a href="#39-2-2-中断类型" class="headerlink" title="39.2.2 中断类型"></a>39.2.2 中断类型</h3><p>GIC-V3支持四种类型的中断，分别是SGI、PPI、SPI和LPI，每个中断类型的介绍如下：</p>
<p>SGI（Software Generated Interrupt，软件生成中断）：SGI 是通过向 GIC 中的 SGI 寄存器写入来生成的中断。它通常用于处理器之间的通信，允许一个 PE 发送中断给一个或多个指定的 PE，中断号ID0 - ID15用于SGI。</p>
<p>PPI（Private Peripheral Interrupt，私有外设中断）：针对特定 PE 的外设中断。不与其他 PE 共享，中断号ID16 - ID31用于PPI。</p>
<p>SPI（Shared Peripheral Interrupt，共享外设中断）：全局外设中断，可以路由到指定的处理器核心（PE）或一组 PE，它允许多个 PE 接收同一个中断。中断号ID32 - ID1019用于SPI，</p>
<p>LPI（Locality-specific Peripheral Interrupt，特定局部外设中断）：LPI 是 GICv3 中引入的一种中断类型，与其他类型的中断有几个不同之处。LPI 总是基于消息的中断，其配置存储在内存表中，而不是寄存器中。</p>
<table>
<thead>
<tr>
<th>INTID范围</th>
<th>中断类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>0 - 15</td>
<td>SGI（软件生成中断）</td>
<td>每个核心分别存储</td>
</tr>
<tr>
<td>16 - 31</td>
<td>PPI（私有外设中断）</td>
<td>每个核心分别存储</td>
</tr>
<tr>
<td>32 - 1019</td>
<td>SPI（共享外设中断）</td>
<td></td>
</tr>
<tr>
<td>1020 - 1023</td>
<td>特殊中断号</td>
<td>用于表示特殊情况</td>
</tr>
<tr>
<td>1024 - 8191</td>
<td>保留</td>
<td></td>
</tr>
<tr>
<td>8192及更大</td>
<td>LPI（特定局部外设中断）</td>
<td>上限由实现定义</td>
</tr>
</tbody></table>
<p>表 39-5</p>
<p>中断处理的状态机如下图（图 39-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps36.jpg" alt="img"> </p>
<p>图 39-6</p>
<p>Inactive（非活动状态）：中断源当前未被触发。</p>
<p>Pending（等待状态）：中断源已被触发，但尚未被处理器核心确认。</p>
<p>Active（活动状态）：中断源已被触发，并且已被处理器核心确认。</p>
<p>Active and Pending（活动且等待状态）：已确认一个中断实例，同时另一个中断实例正在等待处理。</p>
<p>每个外设中断可以是以下两种类型之一：<br><em><strong>*边沿触发（Edge-triggered）*</strong></em><em><strong>*：*</strong></em><br>    这是一种在检测到中断信号上升沿时触发的中断，然后无论信号状态如何，都保持触发状态，直到满足本规范定义的条件来清除中断。</p>
<p><em><strong>*电平触发（Level-sensitive）*</strong></em><em><strong>*：*</strong></em><br>    这是一种在中断信号电平处于活动状态时触发的中断，并且在电平不处于活动状态时取消触发。</p>
<h3 id="39-2-3-中断号"><a href="#39-2-3-中断号" class="headerlink" title="39.2.3 中断号"></a>39.2.3 中断号</h3><p>在linux 内核中，我们使用IRQ number和HW interrupt ID两个ID来标识一个来自外设的中断：</p>
<p>****IRQ number****：CPU需要为每一个外设中断编号，我们称之IRQ Number。这个IRQ number是一个虚拟的interrupt ID，和硬件无关，仅仅是被CPU用来标识一个外设中断。</p>
<p>****HW interrupt ID：****对于GIC中断控制器而言，它收集了多个外设的interrupt request line并向上传递，因此，GIC中断控制器需要对外设中断进行编码。GIC中断控制器用HW interrupt ID来标识外设的中断。如果只有一个GIC中断控制器，那IRQ number和HW interrupt ID是可以一一对应的，如下图（图 39-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps37.jpg" alt="img"> </p>
<p>图 39-7</p>
<p>但如果是在GIC中断控制器级联的情况下，仅仅用HW interrupt ID就不能唯一标识一个外设中断，还需要知道该HW interrupt ID所属的GIC中断控制器（HW interrupt ID在不同的Interrupt controller上是会重复编码的）。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps38.jpg" alt="img"> </p>
<p>图 39-8</p>
<p>这样，CPU和中断控制器在标识中断上就有了一些不同的概念，但是，对于驱动工程师而言，我们和CPU视角是一样的，我们只希望得到一个IRQ number，而不关系具体是那个GIC中断控制器上的那个HW interrupt ID。这样一个好处是在中断相关的硬件发生变化的时候，驱动软件不需要修改。因此，linux kernel中的中断子系统需要提供一个将HW interrupt ID映射到IRQ number上来的机制，也就是irq domain。</p>
<h3 id="39-2-4-中断申请函数"><a href="#39-2-4-中断申请函数" class="headerlink" title="39.2.4 中断申请函数"></a>39.2.4 中断申请函数</h3><h4 id="（1）-request-irq"><a href="#（1）-request-irq" class="headerlink" title="（1）****request_irq"></a><strong>（<strong><strong>1</strong></strong>）****request_irq</strong></h4><p>request_irq 函数是在 Linux 内核中用于注册中断处理程序的函数。它用于请求一个中断号（IRQ number）并将一个中断处理程序与该中断关联起来。下面是对 request_irq 函数的详细介绍：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>  int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev);</p>
<p>****头文件****：</p>
<p>  #include &lt;linux&#x2F;interrupt.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>request_irq 函数的主要功能是请求一个中断号，并将一个中断处理程序与该中断号关联起来。当中断事件发生时，与该中断号关联的中断处理程序会被调用执行。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>irq：要请求的中断号（IRQ number）。</p>
<p>handler：指向中断处理程序的函数指针。</p>
<p>flags：标志位，用于指定中断处理程序的行为和属性，如中断触发方式、中断共享等。</p>
<p>name：中断的名称，用于标识该中断。</p>
<p>dev：指向设备或数据结构的指针，可以在中断处理程序中使用。</p>
<p>返回值：</p>
<p>成功：0 或正数，表示中断请求成功。</p>
<p>失败：负数，表示中断请求失败，返回的负数值表示错误代码。</p>
<p>irq参数用来指定要请求的中断号，中断号需要通过gpio_to_irq 函数映射 GPIO 引脚来获得（gpio_to_irq 函数接下来会进行介绍）。</p>
<p>irq_handler_t handler参数是一个函数指针，指向了中断处理程序的函数。中断处理程序是在中断事件发生时调用的函数，用于处理中断事件（关于中断处理程序会在下个小节进行详细的讲解）。</p>
<p>unsigned long flags：中断处理程序的标志位</p>
<p>这个参数用于指定中断处理程序的行为和属性，如中断触发方式、中断共享等。可以使用不同的标志位进行位运算来组合多个属性。常用的标志位包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IRQF_TRIGGER_NONE：无触发方式，表示中断不会被触发。</span><br><span class="line">IRQF_TRIGGER_RISING：上升沿触发方式，表示中断在信号上升沿时触发。</span><br><span class="line">IRQF_TRIGGER_FALLING：下降沿触发方式，表示中断在信号下降沿时触发。</span><br><span class="line">IRQF_TRIGGER_HIGH：高电平触发方式，表示中断在信号为高电平时触发。</span><br><span class="line">IRQF_TRIGGER_LOW：低电平触发方式，表示中断在信号为低电平时触发。</span><br><span class="line">IRQF_SHARED：中断共享方式，表示中断可以被多个设备共享使用。</span><br></pre></td></tr></table></figure>



<h4 id="（2）-gpio-to-irq"><a href="#（2）-gpio-to-irq" class="headerlink" title="（2）****gpio_to_irq"></a><strong>（2）****gpio_to_irq</strong></h4><p>gpio_to_irq 函数用于将 GPIO 引脚的编号（GPIO pin number）转换为对应的中断请求号（interrupt request number）。</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>unsigned int gpio_to_irq(unsigned int gpio);</p>
<p>****头文件****：</p>
<p>#include &lt;linux&#x2F;gpio.h&gt;</p>
<p><em><strong>*函数功能：*</strong></em><br>    gpio_to_irq 是一个用于将 GPIO 引脚映射到对应中断号的函数。它的作用是根据给定的 GPIO 引脚号，获取与之关联的中断号。</p>
<p><em><strong>*参数说明：*</strong></em></p>
<p>gpio：要映射的 GPIO 引脚号。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>成功：返回值为该 GPIO 引脚所对应的中断号。</p>
<p>失败：返回值为负数，表示映射失败或无效的 GPIO 引脚号。</p>
<h4 id="（3）free-irq"><a href="#（3）free-irq" class="headerlink" title="（3）free_irq"></a>（3）<strong>free_irq</strong></h4><p>free_irq 函数用于释放之前通过 request_irq 函数注册的中断处理程序。它的作用是取消对中断的注册并释放相关的系统资源。下面是关于该函数的详细解释：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>void free_irq(unsigned int irq, void *dev_id);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;interrupt.h&gt;</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>free_irq 函数用于释放之前通过 request_irq 函数注册的中断处理程序。它会取消对中断的注册并释放相关的系统资源，包括中断号、中断处理程序和设备标识等。</p>
<p><em><strong>*参数说明：*</strong></em></p>
<p>irq：要释放的中断号。</p>
<p>dev_id：设备标识，用于区分不同的中断请求。它通常是在 request_irq 函数中传递的设备特定数据指针。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>free_irq 函数没有返回值。</p>
<h3 id="39-2-5-中断服务函数"><a href="#39-2-5-中断服务函数" class="headerlink" title="39.2.5 中断服务函数"></a>39.2.5 中断服务函数</h3><p>中断处理程序是在中断事件发生时自动调用的函数。它负责处理与中断相关的操作，例如读取数据、清除中断标志、更新状态等。</p>
<p>irqreturn_t handler(int irq, void *dev_id) 是一个典型的中断服务函数的函数原型。下面对该函数原型及其参数进行详细解释：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>irqreturn_t handler(int irq, void *dev_id);</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>handler 函数是一个中断服务函数，用于处理特定中断事件。它在中断事件发生时被操作系统或硬件调用，执行必要的操作来响应和处理中断请求。</p>
<p><em><strong>*参数说明：*</strong></em></p>
<p>irq：表示中断号或中断源的标识符。它指示引发中断的硬件设备或中断控制器。</p>
<p>dev_id：是一个 void 类型的指针，用于传递设备特定的数据或标识符。它通常用于在中断处理程序中区分不同的设备或资源。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>irqreturn_t 是一个特定类型的枚举值，用于表示中断服务函数的返回状态。它可以有以下几种取值：</p>
<p>IRQ_NONE：表示中断服务函数未处理该中断，中断控制器可以继续处理其他中断请求。</p>
<p>IRQ_HANDLED：表示中断服务函数已成功处理该中断，中断控制器无需进一步处理。</p>
<p>IRQ_WAKE_THREAD：表示中断服务函数已处理该中断，并且请求唤醒一个内核线程来继续执行进一步的处理。这在一些需要长时间处理的中断情况下使用。</p>
<p>在处理程序中，通常需要注意以下几个方面：</p>
<p>（1）处理程序应该尽可能地快速执行，以避免中断丢失或过多占用 CPU 时间。</p>
<p>（2）如果中断源是共享的，处理程序需要处理多个设备共享同一个中断的情况。</p>
<p>（3）处理程序可能需要与其他部分的代码进行同步，例如访问共享数据结构或使用同步机制来保护临界区域。</p>
<p>（4）处理程序可能需要与其他线程或进程进行通信，例如唤醒等待的线程或发送信号给其他进程。</p>
<h2 id="39-3实验程序编写"><a href="#39-3实验程序编写" class="headerlink" title="39.3实验程序编写"></a>39.3实验程序编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\30_interrupt\03_中断驱动例程。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中会打印申请的GPIO号和This is irq_handler。</p>
<p>iTOP-RK3568有 5 组 GPIO bank：GPIO0<del>GPIO4，每组又以 A0</del>A7, B0<del>B7, C0</del>C7, D0~D7 作为编号区分,常用以下公式计算引脚：</p>
<ul>
<li>GPIO pin脚计算公式：pin <strong>&#x3D;</strong> bank ***** 32 <strong>+</strong> number   &#x2F;&#x2F;bank为组号，number为小组编号</li>
<li>GPIO 小组编号计算公式：number <strong>&#x3D;</strong> group ***** 8 <strong>+</strong> X</li>
</ul>
<p>LCD触摸屏对应的中断引脚标号为TP_INT_L_GPIO3_A5，对应的计算过程如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bank = <span class="number">3</span>;       <span class="comment">//GPIO3_A5=&gt; 3, bank ∈ [0,4]</span></span><br><span class="line">group = <span class="number">0</span>;      <span class="comment">//GPIO3_A5 =&gt; 0, group ∈ &#123;(A=0), (B=1), (C=2), (D=3)&#125;</span></span><br><span class="line">X = <span class="number">5</span>;         <span class="comment">//GPIO3_A5 =&gt; 5, X ∈ [0,7]</span></span><br><span class="line">number = group * <span class="number">8</span> + X = <span class="number">0</span> * <span class="number">8</span> + <span class="number">5</span> =<span class="number">5</span></span><br><span class="line">pin = bank*<span class="number">32</span> + number= <span class="number">3</span> * <span class="number">32</span> + <span class="number">5</span> = <span class="number">101</span>;</span><br></pre></td></tr></table></figure>

<p> 得到中断引脚的引脚标号后，下面开始编写对应的驱动程序，编写完成的interrupt.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN 101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_irq_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt occurred on GPIO %d\n&quot;</span>, GPIO_PIN);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;This is irq_handler\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">interrupt_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> irq_num;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Initializing GPIO Interrupt Driver\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将GPIO引脚映射到中断号</span></span><br><span class="line">    irq_num = gpio_to_irq(GPIO_PIN);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;GPIO %d mapped to IRQ %d\n&quot;</span>, GPIO_PIN, irq_num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求中断</span></span><br><span class="line">    <span class="keyword">if</span> (request_irq(irq_num, gpio_irq_handler, IRQF_TRIGGER_RISING, <span class="string">&quot;irq_test&quot;</span>, <span class="literal">NULL</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to request IRQ %d\n&quot;</span>, irq_num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求中断失败，释放GPIO引脚</span></span><br><span class="line">        gpio_free(GPIO_PIN);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">interrupt_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;                                                                                                                                                                                                                                     </span><br><span class="line">    <span class="type">int</span> irq_num = gpio_to_irq(GPIO_PIN);</span><br><span class="line">    <span class="comment">// 释放中断</span></span><br><span class="line">    free_irq(irq_num, <span class="literal">NULL</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;GPIO Interrupt Driver exited successfully\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(interrupt_init);</span><br><span class="line">module_exit(interrupt_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="39-4-运行测试"><a href="#39-4-运行测试" class="headerlink" title="39.4 运行测试"></a>39.4 运行测试</h2><h3 id="39-4-1-编译驱动程序"><a href="#39-4-1-编译驱动程序" class="headerlink" title="39.4.1 编译驱动程序"></a>39.4.1 编译驱动程序</h3><p>在上一小节中的timer_mod.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m +=interrupt.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图(图 39-9)所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps39.jpg" alt="img"> </p>
<p>图 39-9</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 39-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps40.jpg" alt="img"> </p>
<p>图 39-10</p>
<p>编译完生成 interrupt.ko目标文件，如下图（图 39-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps41.jpg" alt="img"> </p>
<p>图 39-11</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="39-4-2-运行测试"><a href="#39-4-2-运行测试" class="headerlink" title="39.4.2 运行测试"></a>39.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 39-12）所示：</p>
<p>insmod interrupt.ko </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps42.jpg" alt="img"> </p>
<p>图 39-12</p>
<p>可以看到驱动加载之后，打印了“Initializing GPIO Interrupt Driver”表示程序加载成功了，在后面又打印了gpio映射后的中断请求号为113，然后触摸LCD屏，触发中断服务程序，打印如下图（图 39-13）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps43.jpg" alt="img"> </p>
<p>图 39-13</p>
<p>成功打印了GPIO的引脚编号以及“This is irq_handler”，证明编写的驱动程序没有问题，最后使用以下命令卸载相应的驱动，如下图（图 39-14）所示：</p>
<p>rmmod  interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps44.jpg" alt="img"> </p>
<p>图 39-14</p>
<h1 id="第40章-中断申请流程"><a href="#第40章-中断申请流程" class="headerlink" title="第40章 中断申请流程"></a>第40章 中断申请流程</h1><p>在上一章中，我们简单的认识了一下中断以及中断子系统框架，最后编写了中断申请和中断服务函数的实验，大家会发现虽然前面讲解的只是点很多，但实际用起来只需要两三个函数就可以了，但中断的具体申请流程是怎样的呢，大家就不是很清楚了，在本章节将带领大家研究中断的申请流程。</p>
<h2 id="40-1-request-irq函数"><a href="#40-1-request-irq函数" class="headerlink" title="40.1 request_irq函数"></a>40.1 request_irq函数</h2><p>中断申请使用的是request_irq 函数，它用于请求一个中断号（IRQ number）并将一个中断处理程序与该中断关联起来，它定义在内核源码的“&#x2F;include&#x2F;linux&#x2F;interrupt.h”目录下，具体定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">request_irq(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span><br><span class="line">	    <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的内容可以得到request_irq()函数实际上是调用了request_threaded_irq()函数来完成中断申请的过程。request_threaded_irq()函数提供了线程化的中断处理方式，可以在中断上下文中执行中断处理函数。</p>
<h2 id="40-2-request-threaded-irq函数"><a href="#40-2-request-threaded-irq函数" class="headerlink" title="40.2 request_threaded_irq函数"></a>40.2 request_threaded_irq函数</h2><p>request_threaded_irq 函数是 Linux 内核提供的一个功能强大的函数，用于请求分配一个中断，并将中断处理程序与该中断关联起来。该函数的主要作用是在系统中注册中断处理函数，以响应对应中断的发生。以下是 request_threaded_irq 函数的功能和作用的详细介绍：</p>
<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em>****中断请求****：request_threaded_irq 函数用于请求一个中断。它会向内核注册对应中断号的中断处理函数，并为该中断分配必要的资源。中断号是标识特定硬件中断的唯一标识符。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em>****中断处理函数关联：****通过 handler 参数，将中断处理函数与中断号关联起来。中断处理函数是一个预定义的函数，用于处理中断事件。当中断发生时，内核将调用该函数来处理中断事件。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em>****线程化中断处理****：request_threaded_irq 函数还支持使用线程化中断处理函数。通过指定 thread_fn 参数，可以在一个内核线程上下文中异步执行较长时间的中断处理或延迟敏感的工作。这有助于避免在中断上下文中阻塞时间过长。</p>
<p><em><strong>*（*</strong></em><em><strong>*4*</strong></em><em><strong>*）*</strong></em>****中断属性设置：****通过 irqflags 参数，可以设置中断处理的各种属性和标志。例如，可以指定中断触发方式（上升沿、下降沿、边沿触发等）、中断类型（边沿触发中断、电平触发中断等）以及其他特定的中断行为。</p>
<p><em><strong>*（*</strong></em><em><strong>*5*</strong></em><em><strong>*）*</strong></em>****设备标识关联：****通过 dev_id 参数，可以将中断处理与特定设备关联起来。这样可以在中断处理函数中访问与设备相关的数据。设备标识符可以是指向设备结构体或其他与设备相关的数据的指针。</p>
<p><em><strong>*（*</strong></em><em><strong>*6*</strong></em><em><strong>*）*</strong></em>****错误处理：****request_threaded_irq 函数会返回一个整数值，用于指示中断请求的结果。如果中断请求成功，返回值为 0；如果中断请求失败，则返回一个负数错误代码，表示失败的原因。</p>
<p>request_threaded_irq 函数定义在内核源码目录下的“&#x2F;kernel&#x2F;irq&#x2F;manage.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span>  <span class="comment">// 中断动作结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span>  <span class="comment">// 中断描述符指针</span></span><br><span class="line">	<span class="type">int</span> retval;  <span class="comment">// 返回值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查中断号是否为未连接状态</span></span><br><span class="line">	<span class="keyword">if</span> (irq == IRQ_NOTCONNECTED)</span><br><span class="line">		<span class="keyword">return</span> -ENOTCONN;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查中断标志的有效性</span></span><br><span class="line">	<span class="keyword">if</span> (((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id) ||</span><br><span class="line">	    (!(irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)) ||</span><br><span class="line">	    ((irqflags &amp; IRQF_NO_SUSPEND) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据中断号获取中断描述符</span></span><br><span class="line">	desc = irq_to_desc(irq);</span><br><span class="line">	<span class="keyword">if</span> (!desc)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查中断设置是否可以进行中断请求，以及是否为每个CPU分配唯一设备ID</span></span><br><span class="line">	<span class="keyword">if</span> (!irq_settings_can_request(desc) ||</span><br><span class="line">	    WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果未指定中断处理函数，则使用默认的主处理函数</span></span><br><span class="line">	<span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!thread_fn)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		handler = irq_default_primary_handler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配并初始化中断动作数据结构</span></span><br><span class="line">	action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!action)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	action-&gt;handler = handler;  <span class="comment">// 中断处理函数</span></span><br><span class="line">	action-&gt;thread_fn = thread_fn;  <span class="comment">// 线程处理函数</span></span><br><span class="line">	action-&gt;flags = irqflags;  <span class="comment">// 中断标志</span></span><br><span class="line">	action-&gt;name = devname;  <span class="comment">// 设备名称</span></span><br><span class="line">	action-&gt;dev_id = dev_id;  <span class="comment">// 设备ID</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取中断的电源管理引用计数</span></span><br><span class="line">	retval = irq_chip_pm_get(&amp;desc-&gt;irq_data);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		kfree(action);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置中断并将中断动作与中断描述符关联</span></span><br><span class="line">	retval = __setup_irq(irq, desc, action);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理中断设置失败的情况</span></span><br><span class="line">	<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">		irq_chip_pm_put(&amp;desc-&gt;irq_data);</span><br><span class="line">		kfree(action-&gt;secondary);</span><br><span class="line">		kfree(action);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SHIRQ_FIXME</span></span><br><span class="line">	<span class="keyword">if</span> (!retval &amp;&amp; (irqflags &amp; IRQF_SHARED)) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">		disable_irq(irq);</span><br><span class="line">		local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">		handler(irq, dev_id);</span><br><span class="line"></span><br><span class="line">		local_irq_restore(flags);</span><br><span class="line">		enable_irq(irq);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> retval;  <span class="comment">// 返回设置中断的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em><em><strong>*声明变量和初始化：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span>  <span class="comment">// 中断动作结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span>  <span class="comment">// 中断描述符指针</span></span><br><span class="line"><span class="type">int</span> retval;  <span class="comment">// 返回值</span></span><br></pre></td></tr></table></figure>

<p>第5行：用于存储中断动作结构体的指针（会在下面的小节进行详细的讲解）。</p>
<p>第6行：用于存储中断描述符的指针（会在下面的小节进行详细的讲解）。</p>
<p>第7行：用于存储函数的返回值。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em><em><strong>*参数检查：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查中断号是否为未连接状态</span></span><br><span class="line"><span class="keyword">if</span> (irq == IRQ_NOTCONNECTED)</span><br><span class="line">	<span class="keyword">return</span> -ENOTCONN;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查中断标志的有效性</span></span><br><span class="line"><span class="keyword">if</span> (((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id) ||</span><br><span class="line">    (!(irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)) ||</span><br><span class="line">    ((irqflags &amp; IRQF_NO_SUSPEND) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)))</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br></pre></td></tr></table></figure>

<p>第10行：检查中断号是否为未连接状态（IRQ_NOTCONNECTED）。</p>
<p>第14-17行：检查中断标志的有效性，包括共享标志与设备ID的关联性，条件挂起标志的有效性，以及无挂起标志与条件挂起标志的关联性。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em><em><strong>*获取中断描述符：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据中断号获取中断描述符</span></span><br><span class="line">desc = irq_to_desc(irq);</span><br><span class="line"><span class="keyword">if</span> (!desc)</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br></pre></td></tr></table></figure>

<p>第20行：根据中断号调用irq_to_desc函数获取对应的中断描述符。</p>
<p>第21行：如果获取中断描述符失败，则返回-EINVAL表示无效的参数。</p>
<p><em><strong>*（*</strong></em><em><strong>*4*</strong></em><em><strong>*）*</strong></em><em><strong>*检查中断设置：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查中断设置是否可以进行中断请求，以及是否为每个CPU分配唯一设备ID</span></span><br><span class="line"><span class="keyword">if</span> (!irq_settings_can_request(desc) ||</span><br><span class="line">    WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br></pre></td></tr></table></figure>

<p>第25-26行：检查中断设置是否可以进行中断请求，以及是否为每个CPU分配唯一设备ID。如果中断设置不满足要求，则返回-EINVAL表示无效的参数。</p>
<p><em><strong>*（*</strong></em><em><strong>*5*</strong></em><em><strong>*）*</strong></em><em><strong>*处理中断处理函数和线程处理函数：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果未指定中断处理函数，则使用默认的主处理函数</span></span><br><span class="line"><span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!thread_fn)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	handler = irq_default_primary_handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果未指定中断处理函数，则将默认的主处理函数（irq_default_primary_handler）赋值给handler。</p>
<p><em><strong>*（*</strong></em><em><strong>*6*</strong></em><em><strong>*）*</strong></em><em><strong>*分配并初始化中断动作数据结构：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配并初始化中断动作数据结构</span></span><br><span class="line">action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!action)</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">action-&gt;handler = handler;  <span class="comment">// 中断处理函数</span></span><br><span class="line">action-&gt;thread_fn = thread_fn;  <span class="comment">// 线程处理函数</span></span><br><span class="line">action-&gt;flags = irqflags;  <span class="comment">// 中断标志</span></span><br><span class="line">action-&gt;name = devname;  <span class="comment">// 设备名称</span></span><br><span class="line">action-&gt;dev_id = dev_id;  <span class="comment">// 设备ID</span></span><br></pre></td></tr></table></figure>

<p>第37行：调用kzalloc函数分配内存空间，大小为sizeof(struct irqaction)。	</p>
<p>第38行：如果分配内存失败，则返回-ENOMEM表示内存不足。</p>
<p>第41行-第45行：将中断处理函数、线程处理函数、中断标志、设备名称和设备ID赋值给相应的字段。</p>
<p><em><strong>*（*</strong></em><em><strong>*7*</strong></em><em><strong>*）*</strong></em><em><strong>*获取中断的电源管理引用计数：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取中断的电源管理引用计数</span></span><br><span class="line">retval = irq_chip_pm_get(&amp;desc-&gt;irq_data);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	kfree(action);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第48行：调用irq_chip_pm_get函数获取中断的电源管理引用计数。</p>
<p>第49行：如果获取失败，则释放先前分配的内存空间，并返回获取失败的结果。</p>
<p><em><strong>*（*</strong></em><em><strong>*8*</strong></em><em><strong>*）*</strong></em><em><strong>*设置中断并关联中断动作：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置中断并将中断动作与中断描述符关联</span></span><br><span class="line">retval = __setup_irq(irq, desc, action);</span><br></pre></td></tr></table></figure>

<p>第55行：调用__setup_irq函数设置中断并将中断动作与中断描述符关联。</p>
<p><em><strong>*（*</strong></em><em><strong>*9*</strong></em><em><strong>*）*</strong></em><em><strong>*处理设置中断失败的情况：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理中断设置失败的情况</span></span><br><span class="line"><span class="keyword">if</span> (retval) &#123;</span><br><span class="line">	irq_chip_pm_put(&amp;desc-&gt;irq_data);</span><br><span class="line">	kfree(action-&gt;secondary);</span><br><span class="line">	kfree(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第59行：调用irq_chip_pm_put函数释放中断的电源管理引用计数。</p>
<p>第60行：释放次要中断动作的内存空间。</p>
<p>第61行：释放中断动作的内存空间。</p>
<p><em><strong>*（*</strong></em><em><strong>*10*</strong></em><em><strong>*）*</strong></em><em><strong>*可选的共享中断处理：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SHIRQ_FIXME</span></span><br><span class="line">	<span class="keyword">if</span> (!retval &amp;&amp; (irqflags &amp; IRQF_SHARED)) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">		disable_irq(irq);</span><br><span class="line">		local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">		handler(irq, dev_id);</span><br><span class="line"></span><br><span class="line">		local_irq_restore(flags);</span><br><span class="line">		enable_irq(irq);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>第65行：如果设置中断成功且中断标志中包含共享标志（IRQF_SHARED），则执行以下操作：</p>
<p>第68行：禁用中断。</p>
<p>第69行：保存当前中断状态并禁用本地中断。</p>
<p>第70行：调用主处理函数处理中断。</p>
<p>第73行：恢复中断状态。</p>
<p>第74行）：重新使能中断。</p>
<h2 id="40-3-irq-desc结构体"><a href="#40-3-irq-desc结构体" class="headerlink" title="40.3 irq_desc结构体"></a>40.3 irq_desc结构体</h2><p>irq_desc 结构体是 Linux 内核中用于描述中断的数据结构之一。每个硬件中断都有一个对应的 irq_desc 实例，它用于记录与该中断相关的各种信息和状态。该结构体的主要功能是管理中断处理函数、中断行为以及与中断处理相关的其他数据。</p>
<p>以下是 irq_desc 结构体的主要作用和功能：</p>
<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em>****中断处理函数管理****：irq_desc 结构体中的 handle_irq 字段保存中断处理函数的指针。当硬件触发中断时，内核会调用该函数来处理中断事件。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em>****中断行为管理：****irq_desc 结构体中的 action 字段是一个指向中断行为列表的指针。中断行为是一组回调函数，用于注册、注销和处理与中断相关的事件。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em>****中断统计信息：****irq_desc 结构体中的 kstat_irqs 字段是一个指向中断统计信息的指针。该信息用于记录中断事件的发生次数和处理情况，可以帮助分析中断的性能和行为。</p>
<p><em><strong>*（*</strong></em><em><strong>*4*</strong></em><em><strong>*）*</strong></em>****中断数据管理：****irq_desc 结构体中的 irq_data 字段保存了与中断相关的数据，如中断号、中断类型等。这些数据用于识别和管理中断。</p>
<p><em><strong>*（*</strong></em><em><strong>*5*</strong></em><em><strong>*）*</strong></em>****通用中断数据管理：****irq_desc 结构体中的 irq_common_data 字段保存了与中断处理相关的通用数据，如中断控制器、中断屏蔽等。这些数据用于处理和控制中断的行为。</p>
<p><em><strong>*（*</strong></em><em><strong>*6*</strong></em><em><strong>*）*</strong></em>****中断状态管理：****irq_desc 结构体中的其他字段用于管理中断的状态，如嵌套中断禁用计数、唤醒使能计数等。这些状态信息帮助内核跟踪和管理中断的状态变化。</p>
<p>通过使用 irq_desc 结构体，内核可以有效地管理和处理系统中的硬件中断。它提供了一个统一的接口，用于注册和处理中断处理函数、管理中断行为，并提供了必要的信息和数据结构来监视和控制中断的行为和状态。</p>
<p> irq_desc 结构体定义在内核源码目录的“include&#x2F;linux&#x2F;irqdesc.h”文件，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_common_data</span>	<span class="title">irq_common_data</span>;</span>    <span class="comment">/* 通用中断数据 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span>		<span class="title">irq_data</span>;</span>  <span class="comment">/* 中断数据 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> __percpu	*kstat_irqs;  <span class="comment">/* 中断统计信息 */</span></span><br><span class="line">	<span class="type">irq_flow_handler_t</span>	handle_irq;    <span class="comment">/* 中断处理函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IRQ_PREFLOW_FASTEOI</span></span><br><span class="line">	<span class="type">irq_preflow_handler_t</span>	preflow_handler;   <span class="comment">/* 预处理中断处理函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">action</span>;</span>   * IRQ action <span class="built_in">list</span> */</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		status_use_accessors;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		core_internal_state__do_not_mess_with_it; <span class="comment">/* 内核内部状态标志位，请勿修改 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		depth;     <span class="comment">/* 嵌套中断禁用计数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		wake_depth;   <span class="comment">/* 嵌套唤醒使能计数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		tot_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq_count;     <span class="comment">/* 用于检测损坏的IRQ计数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		last_unhandled;  <span class="comment">/* 未处理计数的老化计时器 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irqs_unhandled; <span class="comment">/* 未处理的中断计数 */</span></span><br><span class="line">	<span class="type">atomic_t</span>		threads_handled;   <span class="comment">/* 处理中断的线程计数 */</span></span><br><span class="line">	<span class="type">int</span>			threads_handled_last;</span><br><span class="line">	<span class="type">raw_spinlock_t</span>		lock;        <span class="comment">/* 自旋锁 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>		*<span class="title">percpu_enabled</span>;</span>      <span class="comment">/* 指向每个CPU的使能掩码 */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>	*<span class="title">percpu_affinity</span>;</span>     <span class="comment">/* 指向每个CPU亲和性掩码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>	*<span class="title">affinity_hint</span>;</span>   <span class="comment">/* CPU亲和性提示 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_affinity_notify</span> *<span class="title">affinity_notify</span>;</span>  <span class="comment">/* CPU亲和性变化通知 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PENDING_IRQ</span></span><br><span class="line">	<span class="type">cpumask_var_t</span>		pending_mask;          <span class="comment">/* 等待处理的中断掩码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		threads_oneshot;</span><br><span class="line">	<span class="type">atomic_t</span>		threads_active;    <span class="comment">/* 活动中的线程计数 */</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span>       wait_for_threads;   <span class="comment">/* 等待线程的等待队列头 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		nr_actions;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		no_suspend_depth;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		cond_suspend_depth;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		force_resume_depth;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>	*<span class="title">dir</span>;</span>       <span class="comment">/* proc文件系统目录项 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_IRQ_DEBUGFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>		*<span class="title">debugfs_file</span>;</span>    <span class="comment">/* 调试文件系统文件 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*dev_name;           <span class="comment">/* 设备名称 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSE_IRQ</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		<span class="title">kobj</span>;</span>  <span class="comment">/* 内核对象 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">request_mutex</span>;</span>   <span class="comment">/* 请求互斥锁 */</span></span><br><span class="line">	<span class="type">int</span>			parent_irq;     <span class="comment">/* 父中断号 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span>        <span class="comment">/* 模块拥有者 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*name;          <span class="comment">/* 中断名称 */</span></span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<p>在irq_desc 结构体中最重要的就是 action 字段，会在下个小节对action 字段进行详细的讲解。</p>
<h2 id="40-4-irqaction-结构体"><a href="#40-4-irqaction-结构体" class="headerlink" title="40.4 irqaction 结构体"></a>40.4 irqaction 结构体</h2><p>irqaction 结构体是 Linux 内核中用于描述中断行为的数据结构之一。它用于定义中断处理过程中的回调函数和相关属性。irqaction 结构体的主要功能是管理与特定中断相关的行为和处理函数。</p>
<p>以下是 irqaction 结构体的主要作用和功能：</p>
<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em>****中断处理函数管理****：irqaction 结构体中的 handler 字段保存中断处理函数的指针。该函数在中断发生时被调用，用于处理中断事件。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em>****中断处理标志管理：****irqaction 结构体中的 flags 字段用于指定中断处理的各种属性和标志。这些标志控制中断处理的行为，例如触发方式、中断类型等。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em>****设备标识符管理****：irqaction 结构体中的 dev_id 字段用于保存与中断处理相关的设备标识符。它可以是指向设备结构体或其他与设备相关的数据的指针，用于将中断处理与特定设备关联起来。</p>
<p><em><strong>*（*</strong></em><em><strong>*4*</strong></em><em><strong>*）*</strong></em>****中断行为链表管理****：irqaction 结构体中的 next 字段是一个指向下一个 irqaction 结构体的指针，用于构建中断行为的链表。这样可以将多个中断处理函数链接在一起，以便在中断发生时按顺序调用它们。</p>
<p>通过使用 irqaction 结构体，内核可以灵活地定义和管理与特定中断相关的行为和处理函数。它提供了一个统一的接口，用于注册和注销中断处理函数，并提供了必要的属性和数据结构来控制中断处理的行为和顺序。</p>
<p>irqaction 体定义在内核源码的“include&#x2F;linux&#x2F;interrupt.h”文件中如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> &#123;</span></span><br><span class="line">	<span class="type">irq_handler_t</span>		handler;          <span class="comment">// 中断处理函数</span></span><br><span class="line">	<span class="type">void</span>			*dev_id;          <span class="comment">// 设备ID</span></span><br><span class="line">	<span class="type">void</span> __percpu		*percpu_dev_id;   <span class="comment">// 每个CPU的设备ID</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">next</span>;</span>            <span class="comment">// 下一个中断动作结构体</span></span><br><span class="line">	<span class="type">irq_handler_t</span>		thread_fn;        <span class="comment">// 线程处理函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">thread</span>;</span>          <span class="comment">// 线程结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">secondary</span>;</span>       <span class="comment">// 次要中断动作结构体</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq;              <span class="comment">// 中断号</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		flags;            <span class="comment">// 中断标志</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		thread_flags;     <span class="comment">// 线程标志</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		thread_mask;      <span class="comment">// 线程掩码</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*name;            <span class="comment">// 设备名称</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>	*<span class="title">dir</span>;</span>             <span class="comment">// proc文件系统目录项指针</span></span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<h1 id="第41章-中断下文tasklet实验"><a href="#第41章-中断下文tasklet实验" class="headerlink" title="第41章 中断下文tasklet实验"></a>第41章 中断下文tasklet实验</h1><p>在上一个章节中，我们申请GPIO中断，使用的是request_irq,但是request_irq绑定的中断服务程序指的是中断上文。在之前的中断视频中讲解了：中断分为俩个部分——中断上文和中断下文。本章节我们来学习中断下文的一种实现方式——tasklet。</p>
<h2 id="41-1-什么是tasklet"><a href="#41-1-什么是tasklet" class="headerlink" title="41.1 什么是tasklet"></a>41.1 什么是tasklet</h2><p>在Linux内核中，tasklet是一种特殊的软中断机制，被广泛用于处理中断下文相关的任务。它是一种常见且有效的方法，在多核处理系统上可以避免并发问题。Tasklet绑定的函数在同一时间只能在一个CPU上运行，因此不会出现并发冲突。然而，需要注意的是，tasklet绑定的函数中不能调用可能导致休眠的函数，否则可能引起内核异常。</p>
<p>在Linux内核中，tasklet结构体的定义位于include&#x2F;linux&#x2F;interrupt.h头文件中。其原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> state;</span><br><span class="line">    <span class="type">atomic_t</span> count;</span><br><span class="line">    <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet_t</span>;</span></span><br></pre></td></tr></table></figure>

<p>tasklet_struct结构体包含以下成员：</p>
<p>l next:指向下一个tasklet的指针，用于形成链表结构，以便内核中可以同时管理多个tasklet。</p>
<p>l state:表示tasklet的当前状态。</p>
<p>l count:用于引用计数，用于确保tasklet在多个地方调度或取消调度时的正确处理。</p>
<p>l func:指向tasklet绑定的函数的指针，该函数将在tasklet执行时被调用。</p>
<p>l data:传递给tasklet绑定函数的参数</p>
<p>此外，为了方便，还定义了tasklet_t类型作为struct tasklet_struct的别名。这样我们可以使用tasklet_t来声明tasklet变量，而不是直接使用struct tasklet_struct。</p>
<h2 id="41-2-tasklet相关接口函数"><a href="#41-2-tasklet相关接口函数" class="headerlink" title="41.2 tasklet相关接口函数"></a>41.2 tasklet相关接口函数</h2><h3 id="41-2-1-静态初始化函数"><a href="#41-2-1-静态初始化函数" class="headerlink" title="41.2.1 静态初始化函数"></a>41.2.1 静态初始化函数</h3><p>在Linux内核中，有一个用于静态初始化tasklet的宏函数：DECLARE_TASKLET。这个宏函数可以帮助我们更方便地进行tasklet的静态初始化。</p>
<p>宏函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，name是tasklet的名称，func是tasklet的处理函数，data是传递给处理函数的参数。</p>
<p>初始化状态为使能状态。</p>
<p>如果tasklet初始化函数为非使能状态，使用以下宏定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，name是tasklet的名称，func是tasklet的处理函数，data是传递给处理函数的参数。</p>
<p>初始化状态为非使能状态。</p>
<p>下面是一个示例，展示了如何使用DECLARE_TASKLET宏函数进行tasklet的静态初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，my_tasklet是tasklet的名称，my_tasklet_handler是tasklet的处理函数，0是传递给处理函数的参数。但是需要注意的是，使用DECLARE_TASKLET静态初始化的tasklet无法在运行时动态销毁，因此在不需要tasklet时，应该避免使用此方法。如果需要在运行时销毁tasklet，应使用tasklet_init和tasklet_kill函数进行动态初始化和销毁，接下来我们来学习动态初始化函数。</p>
<h3 id="41-2-2-动态初始化函数"><a href="#41-2-2-动态初始化函数" class="headerlink" title="41.2.2 动态初始化函数"></a>41.2.2 动态初始化函数</h3><p> 在Linux内核中，可以使用tasklet_init函数对tasklet进行动态初始化。该函数原型为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，t是指向tasklet结构体的指针，func是tasklet的处理函数，data是传递给处理函数的参数</p>
<p>以下是一个示例，tasklet_init函数进行动态初始化如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在示例中，我们首先定义了my_tasklet_handler作为tasklet的处理函数。然后，声明了一个名为my_tasklet的tasklet结构体。接下来，通过调用tasklet_init函数，进行动态初始化。</p>
<p>通过使用tasklet_init函数，我们可以在运行时动态创建和初始化tasklet。这样，我们可以根据需要灵活地管理和控制tasklet的生命周期。在不再需要tasklet时，可以使用tasklet_kill函数进行销毁，以释放相关资源。</p>
<h3 id="41-2-3-关闭函数"><a href="#41-2-3-关闭函数" class="headerlink" title="41.2.3 关闭函数"></a>41.2.3 关闭函数</h3><p>在Linux内核中，可以使用tasklet_disabled函数来关闭一个已经初始化的tasklet。该函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，t是指向tasklet结构体的指针。</p>
<p>以下是一个示例，使用tasklet_disable函数来关闭tasklet。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先定义了my_tasklet_handler作为tasklet的处理函数。然后，声明了一个名为my_tasklet的tasklet结构体，并使用tasklet_init函数对其进行初始化。最后，通过调用tasklet_disable函数，我们关闭了my_tasklet。</p>
<p>关闭tasklet后，即使调用tasklet_schedule函数触发tasklet，tasklet的处理函数也不会再被执行。这可以用于临时暂停或停止tasklet的执行，直到再次启用（通过调用tasklet_enable函数）。</p>
<p>需要注意的是，关闭tasklet并不会销毁tasklet结构体，因此可以随时通过调用tasklet_enable函数重新启用tasklet，或者调用tasklet_kill函数来销毁tasklet。</p>
<h3 id="41-2-4-使能函数"><a href="#41-2-4-使能函数" class="headerlink" title="41.2.4 使能函数"></a>41.2.4 使能函数</h3><p>在Linux内核中，可以使用tasklet_enable函数来使能（启用）一个已经初始化的tasklet。该函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，t是指向tasklet结构体的指针。</p>
<p>以下是一个示例，展示如何使用tasklet_enable函数来使能tasklet：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先定义了my_tasklet_handler作为tasklet的处理函数。然后，声明了一个名为my_tasklet的tasklet结构体，并使用tasklet_init函数对其进行初始化。最后，通过调用tasklet_enable函数，我们使能（启用）了my_tasklet。</p>
<p>使能tasklet后，如果调用tasklet_schedule函数触发tasklet，则tasklet的处理函数将会被执行。这样，tasklet将开始按计划执行其处理逻辑。</p>
<p>需要注意的是，使能tasklet并不会自动触发tasklet的执行，而是通过调用tasklet_schedule函数来触发。同时，可以使用tasklet_disable函数来临时暂停或停止tasklet的执行。如果需要永久停止tasklet的执行并释放相关资源，则应调用tasklet_kill函数来销毁tasklet。</p>
<h3 id="41-2-5-调度函数"><a href="#41-2-5-调度函数" class="headerlink" title="41.2.5 调度函数"></a>41.2.5 调度函数</h3><p>在Linux内核中，可以使用tasklet_schedule函数来调度（触发）一个已经初始化的tasklet执行。该函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	其中，t是指向tasklet结构体的指针。</p>
<p>以下是一个示例，展示如何使用tasklet_schedule函数来调度tasklet执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先定义了my_tasklet_handler作为tasklet的处理函数。然后，声明了一个名为my_tasklet的tasklet结构体，并使用tasklet_init函数对其进行初始化。最后，通过调用tasklet_schedule函数，我们调度（触发）了my_tasklet的执行。</p>
<p>需要注意的是，调度tasklet只是将tasklet标记为需要执行，并不会立即执行tasklet的处理函数。实际的执行时间取决于内核的调度和处理机制。</p>
<h3 id="41-2-6-销毁函数"><a href="#41-2-6-销毁函数" class="headerlink" title="41.2.6 销毁函数"></a>41.2.6 销毁函数</h3><p>​	在Linux内核中，可以使用tasklet_kill函数来销毁一个已经初始化的tasklet，释放相关资源。该函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，t是指向tasklet结构体的指针。</p>
<p>以下是一个示例，展示如何使用tasklet_kill函数来销毁tasklet：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先定义了my_tasklet_handler作为tasklet的处理函数。然后，声明了一个名为my_tasklet的tasklet结构体，并使用tasklet_init函数对其进行初始化。最后，通过调用tasklet_kill函数，我们销毁了my_tasklet。</p>
<p>调用tasklet_kill函数会释放tasklet所占用的资源，并将tasklet标记为无效。因此，销毁后的tasklet不能再被使用。</p>
<p>需要注意的是，在销毁tasklet之前，应该确保该tasklet已经被停止（通过调用tasklet_disable函数）。否则，销毁一个正在执行的tasklet可能导致内核崩溃或其他错误。</p>
<p>一旦销毁了tasklet，如果需要再次使用tasklet，需要重新进行初始化（通过调用tasklet_init函数）。在下一小节中我们将使用上述tasklet函数相关接口函数进行相应的实验。</p>
<h2 id="41-3-实验程序的编写"><a href="#41-3-实验程序的编写" class="headerlink" title="41.3 实验程序的编写"></a>41.3 实验程序的编写</h2><h3 id="41-3-1-驱动程序编写"><a href="#41-3-1-驱动程序编写" class="headerlink" title="41.3.1 驱动程序编写"></a>41.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\32_tasklet\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中调度中断下文tasklet处理函数，打印“This id test_interrupt”和“<em><strong>*data is*</strong></em> ****1****”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO转换为中断号，并使用request_irq函数请求中断，然后对tasklet进行初始化。在中断处理函数中，我们调度tasklet执行，使得当中断触发时，tasklet会被调度执行。在模块退出函数中，我们释放中断资源，并使能tasklet销毁tasklet。</p>
<p>编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="41-4-运行测试"><a href="#41-4-运行测试" class="headerlink" title="41.4 运行测试"></a>41.4 运行测试</h2><h3 id="41-4-1-编译驱动程序"><a href="#41-4-1-编译驱动程序" class="headerlink" title="41.4.1 编译驱动程序"></a>41.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图41-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps45.jpg" alt="img"></p>
<p>图 41-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图41-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps46.jpg" alt="img"></p>
<p>图 41-2</p>
<p>编译完生成interrupt.ko目标文件，如下图（图41-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps47.jpg" alt="img"></p>
<p>图 41-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="41-4-2-运行测试"><a href="#41-4-2-运行测试" class="headerlink" title="41.4.2 运行测试"></a>41.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 41-4）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps48.jpg" alt="img"> </p>
<p>图 41-4</p>
<p>看到驱动加载之后，可以看到申请的中断号（113）被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，触发中断服务程序，打印如下图（41-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps49.jpg" alt="img"></p>
<p>图 41-5</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”和tasklet处理函数中添加的打印“data is 1”，说明成功执行了中断下文tasklet处理函数。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图图 41-6）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps50.jpg" alt="img"></p>
<p>图 41-6</p>
<p>之前的理论章节我们强调说tasklet函数中不能调用休眠的函数，在此我们在上述驱动实验的基础上实验一下，驱动文件中添加休眠函数，如下（图 41-7）所示：</p>
<p>​	<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps51.png" alt="img"></p>
<p>图 41-7</p>
<p>同理，进行编译驱动模块，卸载掉之前的驱动模块后，加载新编译的驱动模块，如下图（图 41-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps52.jpg" alt="img"></p>
<p>图 41-8</p>
<p>然后用手触摸连接的LVDS 7寸屏幕，打印如下图（41-9）所示，内核会崩溃。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps53.jpg" alt="img"></p>
<p>图 41-9</p>
<p>至此，中断下文tasklet实验就完成了。</p>
<h1 id="第42章-软中断实验"><a href="#第42章-软中断实验" class="headerlink" title="第42章 软中断实验"></a>第42章 软中断实验</h1><p>在上个章节我们学习了中断下文的一种实验方式——tasklet，本章节我们来学习中断下文的另一种实现方式——软中断。软中断的资料有限，对应的中断号不多，一般用在网络设备驱动，块设备驱动当中。这时本章节要学习的软中断就闪耀登场了。</p>
<h2 id="42-1-什么是软中断"><a href="#42-1-什么是软中断" class="headerlink" title="42.1 什么是软中断"></a>42.1 什么是软中断</h2><p>打开Linux源码linux_sdk&#x2F;kernel&#x2F;include&#x2F;linux&#x2F;interrupt.h文件，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上代码定义了一个枚举类型，用于标识软中断的不同类型或优先级。每个枚举常量对应一个特定的软中断类型。</p>
<p>以下是每个枚举常量的含义：</p>
<p>HI_SOFTIRQ：高优先级软中断</p>
<p>TIMER_SOFTIRQ：定时器软中断</p>
<p>NET_TX_SOFTIRQ：网络传输发送软中断</p>
<p>NET_RX_SOFTIRQ：网络传输接收软中断</p>
<p>BLOCK_SOFTIRQ：块设备软中断</p>
<p>IRQ_POLL_SOFTIRQ：中断轮询软中断</p>
<p>TASKLET_SOFTIRQ：任务软中断</p>
<p>SCHED_SOFTIRQ：调度软中断</p>
<p>HRTIMER_SOFTIRQ, &#x2F;* Unused, but kept as tools rely on the numbering. Sigh! *&#x2F;</p>
<p>RCU_SOFTIRQ,   &#x2F;* Preferable RCU should always be the last softirq *&#x2F;</p>
<p>NR_SOFTIRQS：表示软中断的总数，用于指示软中断类型的数据</p>
<p>中断号的优先级越小，代表优先级越高。在驱动代码中，我们可以使用Linux驱动代码中上述的软中断，当然我们也可以自己添加软中断。我们添加一个自定义的软中断，如下所示，TEST_SOFTIRQ为自定义添加的软中断。</p>
<p>enum</p>
<p>{</p>
<p>​	HI_SOFTIRQ&#x3D;0,</p>
<p>​	TIMER_SOFTIRQ,</p>
<p>​	NET_TX_SOFTIRQ,</p>
<p>​	NET_RX_SOFTIRQ,</p>
<p>​	BLOCK_SOFTIRQ,</p>
<p>​	IRQ_POLL_SOFTIRQ,</p>
<p>​	TASKLET_SOFTIRQ,</p>
<p>​	SCHED_SOFTIRQ,</p>
<p>​	HRTIMER_SOFTIRQ, &#x2F;* Unused, but kept as tools rely on the</p>
<p>​			  numbering. Sigh! *&#x2F;</p>
<p>​	RCU_SOFTIRQ,   &#x2F;* Preferable RCU should always be the last softirq *&#x2F;</p>
<p>​	TEST_SOFTIRQ, &#x2F;&#x2F;添加的自定义软中断</p>
<p>​	NR_SOFTIRQS</p>
<p>};</p>
<p>这里要注意：尽管我们添加一个自定义的软中断非常简单，但是Linux内核的开发者并不希望我们这样去做，如果我们要用软中断，建议使用tasklet。虽然Linux内核开发者不建议自定义软中断，但是我们抱着学习的态度，了解学习下软中断还是很有必要的。上述修改之后，重新编译内核源码，接下来我们来学习下软中断的使用方法。</p>
<h2 id="42-2-软中断接口函数"><a href="#42-2-软中断接口函数" class="headerlink" title="42.2 软中断接口函数"></a>42.2 软中断接口函数</h2><p>软中断的接口函数非常简单，介绍如下所示：</p>
<p>1 注册软中断，使用open_softirq函数，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数的参数如下所示：</p>
<p>nr: 软中断的编号或优先级。它是一个整数，表示要注册的软中断的标识符。</p>
<p>action: 指向一个函数的指针，这个函数将作为软中断的处理程序。该函数接受一个struct softirq_action类型的参数。</p>
<p>2 触发软中断，使用 raise_softirq函数，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数的参数如下所示：</p>
<p>nr: 软中断的编号或优先级。它是一个整数，表示要注册的软中断的标识符。</p>
<p>3 在禁用硬件中断的情况下，触发软中断使用raise_softirq_irqoff函数，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数的参数如下所示：</p>
<p>nr: 软中断的编号或优先级。它是一个整数，表示要注册的软中断的标识符。</p>
<p>在下一小节中将使用上述软中断API进行相应的实验。</p>
<h2 id="42-3-实验程序的编写"><a href="#42-3-实验程序的编写" class="headerlink" title="42.3 实验程序的编写"></a>42.3 实验程序的编写</h2><h3 id="42-3-1-驱动程序编写"><a href="#42-3-1-驱动程序编写" class="headerlink" title="42.3.1 驱动程序编写"></a>42.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\33_softirq\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中触发软中断，打印“This id test_interrupt”和“****This is testsoft_func****”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO转换为中断号，并使用request_irq函数请求中断，然后注册软中断函数。在中断处理函数中，我们触发软中断，使得当中断触发时，软中断处理函数会被调度执行。</p>
<p>接下来我们编写驱动代码，使用软中断来实现中断的下半部分。编写完成的interrupt.c代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="42-4-运行测试"><a href="#42-4-运行测试" class="headerlink" title="42.4 运行测试"></a>42.4 运行测试</h2><h3 id="42-4-1-编译驱动程序"><a href="#42-4-1-编译驱动程序" class="headerlink" title="42.4.1 编译驱动程序"></a>42.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图42-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps54.jpg" alt="img"></p>
<p>图 42-1</p>
<p>然后使用命令“make”进行驱动的编译，编译如下图（图42-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps55.jpg" alt="img"></p>
<p>图 42-2</p>
<p>上图中提示open_softirq和raise_softirq没有被定义，但是为什么还会提示这样的错误呢？</p>
<p>这是因为Linux内核开发者不希望驱动工程师擅自在枚举类型中添加软中断。我们将这俩个函数导出到符号表，修改linux_sdk&#x2F;kernel&#x2F;kernel&#x2F;softirq.c，修改内容如下（图42-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps56.jpg" alt="img"></p>
<p>图42-3</p>
<p>修改完成后，重新编译内核源码，编译源码通过后，再次编译驱动模块，如下图（图 42-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps57.jpg" alt="img"></p>
<p>图 42-4</p>
<p>编译完生成interrupt.ko目标文件，如下图（图42-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps58.jpg" alt="img"></p>
<p>图 42-5</p>
<h3 id="42-4-2-运行测试"><a href="#42-4-2-运行测试" class="headerlink" title="42.4.2 运行测试"></a>42.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图42-6）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps59.jpg" alt="img"></p>
<p>图42-6</p>
<p>驱动加载成功之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，触发中断服务程序，打印如下图（42-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps60.jpg" alt="img"></p>
<p>图 42-7</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”和软中断处理函数中添加的打印“This is testsoft_func”</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图42-8）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps61.jpg" alt="img"></p>
<p>图 42-8</p>
<p>至此，软中断实验就完成了。</p>
<h1 id="第43章-特殊的软中断tasklet分析实验"><a href="#第43章-特殊的软中断tasklet分析实验" class="headerlink" title="第43章 特殊的软中断tasklet分析实验"></a>第43章 特殊的软中断tasklet分析实验</h1><p>Tasklet是Linux内核中的一种软中断机制，它可以被看作是一种轻量级的延迟处理机制。它是通过软中断控制结构来实现的，因此也被称为软中断。本章节我们来从代码层面分析一下为什么tasklet是一个特殊的软中断呢？</p>
<p>软中断处理函数的定义内核源码kernel&#x2F;kernel&#x2F;softirq.c文件中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面开始对上述代码详细解释：</p>
<p>l for_each_possible_cpu(cpu)：遍历每个可能的CPU。在多核系统中，此循环用于初始化每个CPU的tasklet_vec和tasklet_hi_vec。</p>
<p>l per_cpu(tasklet_vec, cpu).tail &#x3D; &amp;per_cpu(tasklet_vec, cpu).head;：将每个CPU的tasklet_vec的tail指针设置为对应的head指针的初始位置。这样做是为了确保tasklet_vec的初始状态是空的。</p>
<p>l per_cpu(tasklet_hi_vec, cpu).tail &#x3D; &amp;per_cpu(tasklet_hi_vec, cpu).head;：将每个CPU的tasklet_hi_vec的tail指针设置为对应的head指针的初始位置。这样做是为了确保tasklet_hi_vec的初始状态是空的。</p>
<p>l open_softirq(TASKLET_SOFTIRQ, tasklet_action);：注册TASKLET_SOFTIRQ软中断，并指定对应的处理函数为tasklet_action。这样，在TASKLET_SOFTIRQ被触发时，将会调用tasklet_action函数来处理相应的任务。</p>
<p>l open_softirq(HI_SOFTIRQ, tasklet_hi_action);：注册HI_SOFTIRQ软中断，并指定对应的处理函数为tasklet_hi_action。这样，在HI_SOFTIRQ被触发时，将会调用tasklet_hi_action函数来处理相应的任务。</p>
<p>在执行__init softirq_init函数时，会触发TASKLET_SOFTIRQ，然后会调用tasklet_action函数，tasklet_action函数如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述函数中调用了tasklet_action_common函数，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>tasklet_action_common函数，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>在上面的代码中，tasklet_action_common()函数对任务链表中的每个tasklet进行处理。它首先禁用本地中断，获取任务链表头指针，清空任务链表，并重新设置尾指针。然后它循环遍历任务链表，对每个tasklet进行处理。如果tasklet的锁获取成功，并且计数器为0，它将执行tasklet的处理函数，并清除状态标志位。如果锁获取失败或计数不为0，它将tasklet添加到任务链表的尾部，并触发指定的软中断。最后，它启用本地中断，完成任务处理过程。</p>
<p>那么tasklet在什么时候加到链表里面的呢？tasklet是通__tasklet_schedule_common()函数加入到链表中的。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过上述代码，__tasklet_schedule_common()函数将tasklet成功添加到链表的末尾。当软中断被触发时，系统会遍历链表并处理每个tasklet。因此，在添加到链表后，tasklet将在适当的时机被系统调度和执行。</p>
<p>经过上述分析，所以说tasklet是一个特殊的软中断。</p>
<p>内核开发者不希望我们去添加软中断的软中断号，更希望我们使用tasklet。那么tasklet相比自己添加软中断有哪些优点和缺点呢？</p>
<p>使用Tasklet相比自己添加软中断有一些优点和缺点。以下是它们的比较：</p>
<p>优点：</p>
<p>\1. 简化的接口和编程模型：Tasklet提供了一个简单的接口和编程模型，使得在内核中处理延迟工作变得更加容易。相比自己添加软中断，Tasklet提供了更高级的抽象。</p>
<p>\2. 低延迟：Tasklet在软中断上下文中执行，避免了内核线程的上下文切换开销，因此具有较低的延迟。这对于需要快速响应的延迟敏感任务非常重要。</p>
<p>\3. 自适应调度：Tasklet具有自适应调度的特性，当多个Tasklet处于等待状态时，内核会合并它们以减少不必要的上下文切换。这种调度机制可以提高系统的效率。</p>
<p>缺点：</p>
<p>\1. 无法处理长时间运行的任务：Tasklet适用于短时间运行的延迟工作，如果需要处理长时间运行的任务，可能会阻塞其他任务的执行。对于较长的操作，可能需要使用工作队列或内核线程来处理。</p>
<p>\2. 缺乏灵活性：Tasklet的执行受限于软中断的上下文，不适用于所有类型的延迟工作。某些情况下，可能需要更灵活的调度和执行机制，这时自定义软中断可能更加适合。</p>
<p>\3. 资源限制：Tasklet的数量是有限的，系统中可用的Tasklet数量取决于架构和内核配置。如果需要大量的延迟工作处理，可能会受到Tasklet数量的限制。</p>
<p>综上所述，Tasklet提供了一种简单且低延迟的延迟工作处理机制，适用于短时间运行的任务和对响应时间敏感的场景。然而，对于长时间运行的任务和需要更灵活调度的情况，自定义软中断可能更合适。在选择使用Tasklet还是自定义软中断时，需要根据具体的需求和系统特性进行权衡和决策。</p>
<h1 id="第44章-共享工作队列实验"><a href="#第44章-共享工作队列实验" class="headerlink" title="第44章 共享工作队列实验"></a>第44章 共享工作队列实验</h1><p>在上个章节我们学习了中断下文的一种实验方式——软中断，本章节我们来学习中断下文的另一种实现方式——工作队列。工作队列是操作系统中管理和调度异步任务执行的一种机制，接下来开始学习工作队列吧。	</p>
<h2 id="44-1-什么是工作队列"><a href="#44-1-什么是工作队列" class="headerlink" title="44.1 什么是工作队列"></a>44.1 什么是工作队列</h2><p>工作队列是实现中断下半部分的机制之一，是一种用于管理任务的数据结构或机制。它通常用于多线程，多进程或分布式系统中，用于协调和分配****待处理的任务*<em><strong>给</strong></em>*可用的工作线程或工作进程****。</p>
<p>工作队列的基本原理是将需要执行的任务按顺序排列在队列中，并提供一组工作线程或者工作进程来处理队列中的任务。当有新的任务到达时，它们会被添加到队列的末尾，工作线程或工作进程从队列的头部获取任务，并执行相应的处理操作。</p>
<p>工作队列和之前学习的tasklet有什么不同呢？tasklet也是实现中断下半部分的机制之一。他们最主要的区别是tasklet不能休眠，而工作队列是可以休眠的，所以tasklet可以用来处理比较耗时间的事情，而工作队列可以处理更耗时间的事情。</p>
<p>工作队列将工作推后以后，会交给内核线程去执行。Linux在启动过程中会创建一个工作者内核线程，这个线程创建以后处于sleep状态。当有工作需要处理的时候，会唤醒这个线程去处理工作。</p>
<p>在内核中，工作队列包括共享工作队列和自定义工作队列这俩种类型。这两种类型的工作队列具有不同的特点和用途。</p>
<p>1  共享队列是由****内核管理****的全局工作队列，用于处理内核中一些系统级任务。共享工作队列是内核中一个默认工作队列，可以由多个内核组件和驱动程序共享使用。</p>
<p>2 自定义工作队列是由****内核或驱动程序创建的****特定工作队列，用于处理特定的任务。自定义工作队列通常与特定的内核模块或驱动程序相关联，用于执行该模块或驱动程序相关的任务。</p>
<p> 本章节我们先来学习共享工作队列相关的知识。 </p>
<p>在Linux 内核中，使用 work_struct 结构体表示一个工作项，这些工作组织成工作队列，工作队列使用 workqueue_struct 结构体表示，如下图所示，流水线相当于工作队列，流水线上一个个等待处理的物料相当于一个个工作。机器相当于内核线程或进程。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps62.jpg" alt="img"> </p>
<p>图 44-1</p>
<p>work_struct 结构体表示一个工作项，定义在include&#x2F;linux&#x2F;workqueue.h中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		</p>
<h2 id="44-2-工作队列相关接口函数"><a href="#44-2-工作队列相关接口函数" class="headerlink" title="44.2 工作队列相关接口函数"></a>44.2 工作队列相关接口函数</h2><h3 id="44-2-1-初始化函数"><a href="#44-2-1-初始化函数" class="headerlink" title="44.2.1 初始化函数"></a>44.2.1 初始化函数</h3><p>在实际的驱动开发中，我们只需要定义工作项(work_struct)即可，关于工作队列和工作者线程我们基本不用去管。简单创建工作很简单，直接定义一个 work_struct 结构体变量即可，然后使用 INIT_WORK 宏来初始化工作，INIT_WORK 宏定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>INIT_WORK 宏接受两个参数：_work 和 _func，分别表示要初始化的工作项和工作项的处理函数。</p>
<p>也可以使用 DECLARE_WORK 宏一次性完成工作的创建和初始化，宏定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数n 表示定义的工作(work_struct)，f 表示工作对应的处理函数。</p>
<h3 id="44-2-2-调度-取消调度工作队列函数"><a href="#44-2-2-调度-取消调度工作队列函数" class="headerlink" title="44.2.2 调度&#x2F;取消调度工作队列函数"></a>44.2.2 调度&#x2F;取消调度工作队列函数</h3><p>和 tasklet 一样，工作也是需要调度才能运行的，工作的调度函数为 schedule_work，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数是指向工作项的指针。这个函数作用是将工作项提交到工作队列中，并请求调度器在合适的时机执行工作项。该函数会返回一个布尔值，表示工作项是否成功被提交到工作队列。</p>
<p>如果想要取消该工作项的调度，使用以下函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数是指向工作项的指针。这个函数的作用是取消该工作项的调度。如果工作项已经在工作队列中，它将被从队列中移除。如果工作项已经在工作队列中，它将被从队列中移除，并等待工作项执行完成。函数返回一个布尔值，表示工作项是否成功取消。</p>
<h2 id="44-3-实验程序的编写"><a href="#44-3-实验程序的编写" class="headerlink" title="44.3 实验程序的编写"></a>44.3 实验程序的编写</h2><h3 id="44-3-1-驱动程序编写"><a href="#44-3-1-驱动程序编写" class="headerlink" title="44.3.1 驱动程序编写"></a>44.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\34_workqueue\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中提交工作项到共享工作队列中，打印“This id test_interrupt”和“****This is test_work****”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO转换为中断号，并使用request_irq函数请求中断，然后初始化工作项。当中断被触发时，中断处理函数被调用，并将工作项提交到共享工作队列中，最终由工作项处理函数异步执行。编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="44-4-运行测试"><a href="#44-4-运行测试" class="headerlink" title="44.4 运行测试"></a>44.4 运行测试</h2><h3 id="44-4-1-编译驱动程序"><a href="#44-4-1-编译驱动程序" class="headerlink" title="44.4.1 编译驱动程序"></a>44.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图44-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps63.jpg" alt="img"></p>
<p>图 44-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图44-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps64.jpg" alt="img"> </p>
<p>图 44-3</p>
<p>编译完生成interrupt.ko目标文件，如下图（图44-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps65.jpg" alt="img"> </p>
<p>图 44-4</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="44-4-2-运行测试"><a href="#44-4-2-运行测试" class="headerlink" title="44.4.2 运行测试"></a>44.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图44-5）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps66.jpg" alt="img"></p>
<p>图44-5</p>
<p>加载驱动之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（44-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps67.jpg" alt="img"></p>
<p>图 44-6</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”被多次打印，说明触发了好几次中断上文，那么中断上文会多次调度中断下文，所以也会打印工作项处理函数中添加的打印“This is test_work”。但是为什么只会打印俩次“This is test_work”呢？这是因为在中断上文调度工作项处理函数之后，内核没有来得及去执行工作项处理函数，没有执行相当于无效操作，有效的执行则打印了俩次“This is test_work”。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图44-7）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps68.jpg" alt="img"></p>
<p>图 44-7</p>
<p>至此，共享工作队列实验就完成了。	</p>
<h1 id="第45章-自定义工作队列实验"><a href="#第45章-自定义工作队列实验" class="headerlink" title="第45章 自定义工作队列实验"></a>第45章 自定义工作队列实验</h1><p>在上一章节中对工作队列以及共享工作队列知识进行了学习，并使用共享队列进行了实验。共享队列是由****内核管理*<em><strong>的全局工作队列，自定义工作队列是由</strong></em>*内核或驱动程序创建的****特定工作队列，用于处理特定的任务。下面就让我们一起来进行自定义工作队列的学习吧。</p>
<h2 id="45-1-工作队列相关结构体"><a href="#45-1-工作队列相关结构体" class="headerlink" title="45.1 工作队列相关结构体"></a>45.1 工作队列相关结构体</h2><p>在Linux内核中，结构体struct work_struct描述的是要延迟执行的工作项，定义在include&#x2F;linux&#x2F;workqueue.h当中，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>  这些工作组织成工作队列，内核使用struct workqueue_struct结构体描述一个工作队列，定义在include&#x2F;linux&#x2F;workqueue.h 当中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="45-2-工作队列相关接口函数"><a href="#45-2-工作队列相关接口函数" class="headerlink" title="45.2 工作队列相关接口函数"></a>45.2 工作队列相关接口函数</h2><p>在Linux内核中，create_workqueue函数用于创建一个工作队列，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数name是创建的工作队列的名字。使用这个函数可以给每个CPU都创建一个CPU相关的工作队列。创建成功返回一个struct workqueue_struct类型指针，创建失败返回NULL。</p>
<p>如果只给一个CPU创建一个CPU相关的工作队列，使用以下函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数name是创建的工作队列的名字。使用这个函数只会给一个CPU创建一个CPU相关的工作队列。创建成功之后返回一个struct workqueue_struct 类型指针，创建失败返回NULL。 </p>
<p>当工作队列创建好之后，需要将要延迟执行的工作项放在工作队列上，调度工作队列，使用queue_work_on函数，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>  该函数有三个参数，第一个参数是一个整数cpu，第二个参数是一个指向struct workqueue_struct的指针wq，第三个参数是一个指向struct work_struct的指针work。</p>
<p>该函数的返回类型是布尔值，表示是否成功调度工作队列。 queue_work_on函数还有其他变种，比如queue_work函数，这里略过，其实思路是一致的，用于将定义好的工作项立即添加到工作队列中，并在工作队列可用时立即执行。</p>
<p>​	如果要取消一个已经调度的工作，使用函数bool cancel_work_sync，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>  函数的作用是取消一个已经调度的工作，如果被取消的工作已经正在执行，则会等待他执行完成再返回。</p>
<p>在Linux 内核中，使用flush_workqueue函数将刷新该工作队列中所有已提交但未执行的工作项。函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p> 该函数参数是一个指向struct workqueue_struct类型的指针wq。函数的作用是刷新工作队列，告诉内核尽快处理工作队列上的工作。</p>
<p>如果要删除自定义的工作队列，使用destroy_workqueue函数，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>  该函数参数是一个指向struct workqueue_struct类型的指针wq。</p>
<p>在下一小节中将使用上述工作队列API函数进行相应的实验。</p>
<h2 id="45-3-实验程序的编写"><a href="#45-3-实验程序的编写" class="headerlink" title="45.3 实验程序的编写"></a>45.3 实验程序的编写</h2><h3 id="45-3-1-驱动程序编写"><a href="#45-3-1-驱动程序编写" class="headerlink" title="45.3.1 驱动程序编写"></a>45.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\35_workqueue_share\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中提交工作项到工作队列中，打印“This id test_interrupt”和“****This is test_work****”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO转换为中断号，并使用request_irq函数请求中断，然后创建自定义工作队列，初始化工作项。当中断被触发时，中断处理函数被调用，并将工作项提交到自定义工作队列中，最终由工作项处理函数异步执行。编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="45-4-运行测试"><a href="#45-4-运行测试" class="headerlink" title="45.4 运行测试"></a>45.4 运行测试</h2><h3 id="45-4-1-编译驱动程序"><a href="#45-4-1-编译驱动程序" class="headerlink" title="45.4.1 编译驱动程序"></a>45.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图45-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps69.jpg" alt="img"> </p>
<p>图 45-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图45-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps70.jpg" alt="img"></p>
<p>图 45-2</p>
<p>编译完生成interrupt.ko目标文件，如下图（图45-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps71.jpg" alt="img"></p>
<p>图 45-3</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="45-4-2-运行测试"><a href="#45-4-2-运行测试" class="headerlink" title="45.4.2 运行测试"></a>45.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图45-4）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps72.jpg" alt="img"> </p>
<p>图45-4</p>
<p>加载驱动之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（45-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps73.jpg" alt="img"> </p>
<p>图 45-5</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”被打印了俩次，说明触发了2次中断上文，那么中断上文会调度2次中断下文，所以也会打印2次工作项处理函数中添加的打印“This is test_work”。</p>
<p>在按屏幕之后，立即输入ps -aux|grep test_workqueue命令可以查看自己创建的工作队列，如下（图 45-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps74.jpg" alt="img"></p>
<p>图 45-6</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图45-7）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps75.jpg" alt="img"></p>
<p>图 45-7</p>
<p>至此，自定义工作队列实验就完成了。</p>
<h1 id="第46章-延迟工作实验"><a href="#第46章-延迟工作实验" class="headerlink" title="第46章 延迟工作实验 * *"></a>第46章 延迟工作实验 <em><strong>* *</strong></em></h1><p>在之前的章节中，我们学习了共享工作队列和自定义工作队列，为了更形象地理解学习，将流水线比作工作队列，流水线上一个个等待处理的物料比作一个个工作。机器比作内核线程或进程。本章节我们即将学习的延迟工作，可以类比为将物料延迟一定时间，再放到生产线上加工。延迟工作不仅可以在自定义工作队列中实现 也可以在共享工作队列上实现。现在，我们对延迟工作有了一个感性的认识，接下来详细的学习下延迟工作吧。</p>
<h2 id="46-1-什么是延迟工作"><a href="#46-1-什么是延迟工作" class="headerlink" title="46.1 什么是延迟工作"></a>46.1 什么是延迟工作</h2><p>延迟工作是一种将工作的执行延迟到稍后时间点进行处理的技术。通常情况下，当某个任务需要花费较长时间，不需要立即执行或需要按时执行时，延迟工作就会派上用场。</p>
<p>延迟工作的基本思想是将任务放入一个队列中，然后由后台的工作进程会任务调度程序来处理队列中的任务。任务可以在指定的延迟时间后执行，也可以根据优先级，任务类型或者其他条件进行排序和处理。</p>
<p>延迟工作在许多应用场景中都非常有用，尤其是在需要处理大量任务，提供系统性能和可靠性的情况下。以下是一些常用的应用场景：</p>
<p>1 延迟工作常用于处理那些需要花费较长时间的任务，比如发送电子邮件，处理图像等。通过将这些任务放入队列中并延迟执行，可以避免阻塞应用程序的主线程，提高系统的响应速度。</p>
<p>2 延迟工作可以用来执行定时任务，比如定时备份数据库，通过将任务设置为在未来的某个时间点执行，提高系统的可靠性和效率。</p>
<p>为了方便大家理解，我们再举个形象点的例子，比如说开发板上的按键，现在我们想通过驱动程序读取按键的状态，那么只需要读取这个按键所连接的GPIO的状态就可以了。</p>
<p>理想型的按键电压变化过程如图（图 46-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps76.png" alt="img"> </p>
<p>图 46-1</p>
<p>在上图中，按键没有按下的时候按键值为 1，当按键在 t1 时刻按键被按下以后按键值就变为 0，这是最理想的状态。但是实际的按键是机械结构，加上刚按下去的一瞬间人手可能也有抖动，实际的按键电压变化过程如下图（图 46-2）所示：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\ksohtml17816\wps77.png" alt="img"> </p>
<p>图 46-2</p>
<p>在上图中，t1 时刻按键被按下，但是由于抖动的原因，直到 t2 时刻才稳定下来，t1 到t2 这段时间就是抖动。一般这段时间就是十几 ms 左右，从上图中可以看出在抖动期间会有多次触发，如果不消除这段抖动的话软件就会误判，本来按键就按下了一次，结果软件读取IO 值发现电平多次跳变以为按下了多次。所以我们需要跳过这段抖动时间再去读取按键的 IO值，也就是至少要在 t2 时刻以后再去读 IO 值。在之前的驱动视频中，我们使用了定时器来实现消抖。按键采用中断驱动方式，当按键按下以后触发按键中断，在按键中断中开启一个定时器，定时周期为 10ms，当定时时间到了以后就会触发定时器中断，最后在定时器中断处理函数中读取按键的值，如果按键值还是按下状态那就表示这是一次有效的按键。定时器按键消抖如下图（图 46-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps78.png" alt="img"> </p>
<p>图 46-3</p>
<p>在上图中t1<del>t3 这一段时间就是按键抖动，是需要消除的。设置按键为下降沿触发，因此会在 t1、t2 和 t3 这三个时刻会触发按键中断，每次进入中断处理函数都会重新开器定时器中断，所以会在 t1、t2 和 t3 这三个时刻开器定时器中断。但是 t1</del>t2 和 t2~t3 这两个时间段是小于我们设置的定时器中断周期(也就是消抖时间，比如 10ms)，所以虽然 t1 开启了定时器，但是定时器定时时间还没到呢 t2 时刻就重置了定时器，最终只有 t3 时刻开启的定时器能完整的完成整个定时周期并触发中断，我们就可以在中断处理函数里面做按键处理了，这就是定时器实现按键防抖的原理，Linux 里面的按键驱动用的就是这个原理！</p>
<p>除了使用定时器方式进行消抖，也可以使用本章节讲述的延迟工作。在中断下文中将工作延迟3秒之后，再去读GPIO电平状态。</p>
<p>在Linux内核中，使用struct delayed_work来描述延迟工作，定义在include&#x2F;linux&#x2F;workqueue.h当中，原型定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>struct delayed_work结构体包含了两个成员：</p>
<p>1  work：这是一个struct work_struct类型的成员，用于表示延迟工作的基本工作结构。struct work_struct是表示工作的常见数据结构，用于定义要执行的工作内容。</p>
<p>2  timer：这是一个struct timer_list类型的成员，用于管理延迟工作的定时器。struct timer_list是Linux内核中的定时器结构，用于设置延迟时间和触发工作执行的时机。</p>
<p>  使用struct delayed_work结构体，可以将需要执行的工作封装成一个延迟工作，并使用定时器来控制工作的延迟执行。通过设置定时器的延迟时间，可以指定工作在一定时间后执行。</p>
<p>接下来我们学习下延迟工作相关的接口函数吧。</p>
<h2 id="46-2-延迟工作相关接口函数"><a href="#46-2-延迟工作相关接口函数" class="headerlink" title="46.2 延迟工作相关接口函数"></a>46.2 延迟工作相关接口函数</h2><h3 id="46-2-1-初始化延迟工作函数"><a href="#46-2-1-初始化延迟工作函数" class="headerlink" title="46.2.1 初始化延迟工作函数"></a>46.2.1 初始化延迟工作函数</h3><p>静态定义并初始化延迟工作使用宏DECLARE_DELAYED_WORK，函数原型如下所示：	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用宏定义后，可以将上述代码简化为#define DECLARE_DELAYED_WORK(n,f)，n代表延迟工作的变量名，f是延迟工作的处理函数。</p>
<p>动态定义并初始化延迟工作使用宏INIT_DELAYED_WORK，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用宏定义后，可以将上述代码简化为#define INIT_DELAYED_WORK(_work, _func)， n代表延迟工作的变量名，f是延迟工作的处理函数。</p>
<h3 id="46-2-2-调度-取消调度-延迟工作函数"><a href="#46-2-2-调度-取消调度-延迟工作函数" class="headerlink" title="46.2.2 调度&#x2F;取消调度 延迟工作函数"></a>46.2.2 调度&#x2F;取消调度 延迟工作函数</h3><p>如果是在共享工作队列上调度延迟工作，使用以下函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数是一个内联函数，用于在给定的延迟时间后调度延迟工作执行。</p>
<p>函数参数dwork:是指向延迟工作的指针，即要被调度的延迟工作。</p>
<p>delay:表示延迟的时间长度，以内核时钟节拍数jiffies为单位。</p>
<p>如果是在自定义工作队列上调度延迟工作，使用以下函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数是一个内联函数，用于将延迟工作加入工作队列后在指定的延迟时间后执行。</p>
<p>函数参数wq是指向工作队列结构的指针，即要将延迟工作加入的目标工作队列。</p>
<p>dwork:指向延迟工作的指针，也就是要被加入工作队列的延迟工作。</p>
<p>delay: 表示延迟的时间长度，以内核时钟节拍数jiffies为单位。</p>
<p>如果要取消调度函数，使用以下函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数是一个外部声明的函数，用于取消延迟工作并等待其完成。dwork参数是指向延迟工作的指针，也就是要被取消的延迟工作。函数如果返回true，说明成功取消延迟工作并等待其完成。函数如果返回false，说明无法取消延迟工作或等待其完成。</p>
<p>在下一小节中将在自定义工作队列实验的基础上修改驱动，进行延迟工作实验。</p>
<h2 id="46-3-实验程序的编写"><a href="#46-3-实验程序的编写" class="headerlink" title="46.3 实验程序的编写"></a>46.3 实验程序的编写</h2><h3 id="46-3-1-驱动程序编写"><a href="#46-3-1-驱动程序编写" class="headerlink" title="46.3.1 驱动程序编写"></a>46.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\36_workqueue_delay\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中提交延迟工作项到工作队列中，打印“This id test_interrupt”，并延迟打印“****This is test_work****”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO转换为中断号，并使用request_irq函数请求中断，然后创建自定义工作队列，初始化延迟工作项。当中断被触发时，中断处理函数被调用，并将延迟工作项提交到自定义工作队列中，最终由工作项处理函数异步执行。编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="46-4-运行测试"><a href="#46-4-运行测试" class="headerlink" title="46.4 运行测试"></a>46.4 运行测试</h2><h3 id="46-4-1-编译驱动程序"><a href="#46-4-1-编译驱动程序" class="headerlink" title="46.4.1 编译驱动程序"></a>46.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图46-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps79.jpg" alt="img"></p>
<p>图 46-4</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图46-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps80.jpg" alt="img"></p>
<p>图46-5</p>
<p>编译完生成interrupt.ko目标文件，如下图（图46-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps81.jpg" alt="img"></p>
<p>图 46-6</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="46-4-2-运行测试"><a href="#46-4-2-运行测试" class="headerlink" title="46.4.2 运行测试"></a>46.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图46-7）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps82.jpg" alt="img"></p>
<p>图46-7</p>
<p>加载驱动之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（46-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps83.jpg" alt="img"></p>
<p>图46-8</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”被打印了多次，说明触发了多次中断上文，在4秒之后，打印工作项处理函数中的“This is test_work”。4秒之后打印“This is test_work”是因为调度延迟工作函数写了延迟3秒，再加上工作项处理函数中延迟了一秒，所以一共是4秒。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图46-9）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps84.jpg" alt="img"></p>
<p>图 46-9</p>
<p>至此，延迟工作实验就完成了。</p>
<h1 id="第47章-工作队列传参实验"><a href="#第47章-工作队列传参实验" class="headerlink" title="**** ****第47章 工作队列传参实验"></a>**** ****第47章 工作队列传参实验</h1><p>在41章节中，我们使用tasklet来实现中断下文，并使用tasklet给中断下文传参，如果我们使用工作队列来实现中断的下半部分，那么如何用工作队列给中断下文传参呢？本章节我们来一探究竟！</p>
<h2 id="47-1-工作队列传参"><a href="#47-1-工作队列传参" class="headerlink" title="47.1 工作队列传参"></a>47.1 工作队列传参</h2><p>在Linux内核的工作队列中，可以通过使用工作项的方式向工作队列传递参数。工作项是一个抽象的结构，可以用于封装需要执行的工作及其相关的参数。</p>
<p>首先我们定义工作项结构，如下所示，在结构体struct work_data中定义了需要传递给工作项处理函数的参数a和b，然后定义一个类型为struct work_data 的变量test_workqueue_work。</p>
<p>struct work_data {</p>
<p> struct work_struct test_work;</p>
<p> int a;</p>
<p> int b;</p>
<p>};  </p>
<p>struct work_data test_workqueue_work;</p>
<p>接下来在模块初始化函数interrupt_irq_init 中创建了一个工作队列test_workqueue 和一个工作项 test_workqueue_work。</p>
<p>test_workqueue &#x3D; create_workqueue(“test_workqueue”); &#x2F;&#x2F; 创建工作队列</p>
<p>INIT_WORK(&amp;test_workqueue_work.test_work, test_work); &#x2F;&#x2F; 初始化工作项</p>
<p>然后在模块初始化函数中，为工作项的参数 a 和 b 赋值。</p>
<p>test_workqueue_work.a &#x3D; 1;</p>
<p>test_workqueue_work.b &#x3D; 2;</p>
<p>当中断触发时，在中断处理函数 test_interrupt 中，通过调用 queue_work 函数将工作项 test_workqueue_work.test_work 提交到工作队列 test_workqueue 中。</p>
<p>queue_work(test_workqueue, &amp;test_workqueue_work.test_work);</p>
<p>然后工作项处理函数 test_work 定义了一个指针 pdata，将工作项转换为 struct work_data 结构，并通过该结构访问参数 a 和 b。如下所示：</p>
<p>void test_work(struct work_struct *work)</p>
<p>{</p>
<p> struct work_data *pdata;</p>
<p> pdata &#x3D; container_of(work, struct work_data, test_work);</p>
<p> printk(“a is %d\n”, pdata-&gt;a);</p>
<p> printk(“b is %d\n”, pdata-&gt;b);</p>
<p>}</p>
<p>这样，当工作队列被调度执行时，工作项处理函数test_work将能够访问到传递给工作项的参数a和b,并在内核日志中打印他们的值。</p>
<p>注意，工作项处理函数中的 container_of 宏用于从工作项结构的指针获取整个 struct work_data 结构的指针。这样可以通过指针偏移来访问工作项结构中的其他字段，例如参数 a 和 b。</p>
<p>详细的驱动代码编写见下一小节。</p>
<h2 id="47-2实验程序的编写"><a href="#47-2实验程序的编写" class="headerlink" title="47.2实验程序的编写"></a>47.2实验程序的编写</h2><h3 id="47-2-1-驱动程序编写"><a href="#47-2-1-驱动程序编写" class="headerlink" title="47.2.1 驱动程序编写"></a>47.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\37_workqueue_data\module。</p>
<p>编写完成的interrupt.c代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="47-3-运行测试"><a href="#47-3-运行测试" class="headerlink" title="47.3 运行测试"></a>47.3 运行测试</h2><h3 id="47-3-1-编译驱动程序"><a href="#47-3-1-编译驱动程序" class="headerlink" title="47.3.1 编译驱动程序"></a>47.3.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>.对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图47-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps85.jpg" alt="img"></p>
<p>图 47-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图47-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps86.jpg" alt="img"></p>
<p>图 47-2</p>
<p>编译完生成interrupt.ko目标文件，如下图（图47-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps87.jpg" alt="img"></p>
<p>图 47-3</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="47-3-2-运行测试"><a href="#47-3-2-运行测试" class="headerlink" title="47.3.2 运行测试"></a>47.3.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图47-4）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps88.jpg" alt="img"> </p>
<p>图47-4</p>
<p>驱动加载之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（47-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps89.jpg" alt="img"> </p>
<p>图 47-5</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”和传递给工作项的参数a和b的值。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图47-6）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps90.jpg" alt="img"> </p>
<p>图 47-6</p>
<p>至此，工作队列传参实验就完成了。</p>
<h1 id="第48章-并发管理工作队列实验"><a href="#第48章-并发管理工作队列实验" class="headerlink" title="第48章 并发管理工作队列实验"></a>第48章 并发管理工作队列实验</h1><p>在现代的软件开发中，我们常常面临着需要同时处理多个任务的挑战。这些任务可能是并行的、独立的，或者需要以某种顺序进行处理。为了高效地管理这些并发任务，我们需要一种有效的机制来协调它们的执行。这就是并发管理工作队列发挥作用的地方。本章节我们来学习并发管理工作队列。</p>
<h2 id="48-1工作队列的实现"><a href="#48-1工作队列的实现" class="headerlink" title="48.1工作队列的实现"></a>48.1工作队列的实现</h2><p>在44章节和45章节，我们学习了共享工作队列和自定义工作队列，在使用工作队列时，我们首先定义一个work结构体，然后将work添加到workqueue(工作队列)中，最后worker thread 执行workqueue。当工作队列中有新work产生时，工作线程（worker thread）会执行工作队列中每个work。当执行完结束的时候，worker thread会睡眠，等到新的中断产生，work再继续添加到工作队列，然后工作线程执行每个工作，周而复始。</p>
<p>在单核线程的系统中，通常会为每个 CPU（核心）初始化一个工作线程并关联一个工作队列。这种默认设置确保每个CPU都有一个专门的线程来处理与其绑定的工作队列上的工作项。如下图（48-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps91.jpg" alt="img"> </p>
<p>图 48-1</p>
<p>在多核线程系统中，工作队列的设计与单核线程系统有所不同。在多核线程系统中，通常会存在多个工作队列，每个工作队列与一个工作线程（Worker Thread）绑定。这样可以充分利用多个核心的并行处理能力。如下图（48-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps92.jpg" alt="img"></p>
<p>图 48-2</p>
<p>当有新的工作项产生时，系统需要决定将其分配给哪个工作队列。一种常见的策略是使用负载均衡算法，根据工作队列的负载情况来平衡分配工作项，以避免某个工作队列过载而导致性能下降。每个工作队列独立管理自己的工作项。当有新的工作项添加到工作队列时，工作线程会从其关联的工作队列中获取待执行的工作项，并执行相应的处理函数。在多核线程系统中，多个工作线程可以同时执行各自绑定的工作队列中的工作项。这样可以实现并行处理，提高系统的整体性能和响应速度。</p>
<p>了解了工作队列是如何实现的，接下来我们看看传统的工作队列有什么弊端呢？</p>
<h2 id="48-2-workqueue队列弊端"><a href="#48-2-workqueue队列弊端" class="headerlink" title="48.2 workqueue队列弊端"></a>48.2 workqueue队列弊端</h2><p>假如说有三个work放到了同一个工作队列上，接下来CPU会启动工作线程去执行这三个work，如下图（48-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps93.jpg" alt="img"> </p>
<p>图 48-3</p>
<p>在上图中，工作项w0、w1、w2被排队到同一个CPU上的绑定工作队列上。w0工作项执行的时候，先工作 5毫秒，然后睡觉10毫秒，然后再工作CPU 5毫秒，然后完成。工作项w1和w2都是工作5ms，然后睡眠10 ms，然后完成。传统工作队列的弊端如下所示：</p>
<p>1 在工作项w0 工作甚至是睡眠时，工作项w1 w2是排队等待的，在繁忙的系统中，工作队列可能会积累大量的待处理工作项，导致任务调度的延迟，这可能会影响系统的响应性能，并增加工作项的处理时间。</p>
<p>2 在工作队列中，不同的工作项可能具有不同的处理时间和资源需求。如果工作项的处理时间差异很大，一些工作线程可能会一直忙于处理长时间的工作项，而其他工作线程则处于空闲状态，导致资源利用不均衡。</p>
<p>3 在多线程环境下，多个工作线程同时访问和修改工作队列可能会导致竞争条件的发生。为了确保数据的一致性和正确性，需要采用适当的同步机制，如锁或原子操作，来保护共享数据，但这可能会引入额外的同步开销。</p>
<p>4 工作队列通常按照先进先出（FIFO）的方式处理工作项，缺乏对工作项优先级的细粒度控制。在某些场景下，可能需要根据工作项的重要性或紧急程度进行优先级调度，而工作队列本身无法提供这种级别的优先级控制。</p>
<p>5 当工作线程从工作队列中获取工作项并执行时，可能需要频繁地进行上下文切换，将处理器的执行上下文从一个线程切换到另一个线程。这种上下文切换开销可能会影响系统的性能和效率。</p>
<h2 id="48-2-什么是并发管理工作队列"><a href="#48-2-什么是并发管理工作队列" class="headerlink" title="48.2 什么是并发管理工作队列"></a>48.2 什么是并发管理工作队列</h2><p>通过上一小节的学习，我们认识到传统的工作队列无论是单核系统还是多核系统上都是有缺陷的。比如无法充分利用多核处理器的计算能力以及对于不同优先级的工作项无法提供公平的调度。为了解决这些问题，Con Kolivas提出了CMWQ调度算法。</p>
<p>CMWQ 全称是concurrency Managed Workqueue，意为并发管理工作队列。并发管理工作队列是一种并发编程模式，用于有效地管理和调度待执行的任务或工作项。它通常用于多线程或多进程环境中，以实现并发执行和提高系统的性能。CMWQ 工作实现如下图（48-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps94.jpg" alt="img"> </p>
<p>图 48-4</p>
<p>当我们需要在一个系统中同时处理多个任务或工作时，使用并发管理工作队列是一种有效的方式。</p>
<p>想象一下，你是一个餐厅的服务员，有很多顾客同时来到餐厅用餐。为了提高效率，你需要将顾客的点菜请求放到一个队列中，这就是工作队列。然后，你和其他服务员可以从队列中获取顾客的点菜请求，每个服务员独立地为顾客提供服务。通过这种方式，你们可以并发地处理多个顾客的点菜请求，而不需要等待上一个顾客点完菜再去处理下一个顾客的请求。每个服务员可以独立地从队列中获取任务，并根据需要执行相应的服务。这种独立获取任务的过程就是从工作队列中取出任务并执行的过程。</p>
<p>通过并发管理工作队列，你们能够更高效地处理顾客的点菜请求，提高服务的速度和质量。同时，这种方式也能够更好地利用你们的工作能力，因为每个服务员都可以独立处理任务，而不会相互干扰或等待。</p>
<p>总的来说，通过并发管理工作队列，我们可以同时处理多个任务或工作，提高系统的并发性和性能。每个任务独立地从队列中获取并执行，这种解耦使得整个系统更加高效、灵活，并且能够更好地应对多任务的需求。</p>
<h2 id="48-3-并发管理工作队列接口函数"><a href="#48-3-并发管理工作队列接口函数" class="headerlink" title="48.3 并发管理工作队列接口函数"></a>48.3 并发管理工作队列接口函数</h2><p>​	alloc_workqueue是Linux内核中的一个函数，用于创建和分配一个工作队列。工作队列是一种用于管理和调度工作项的机制，可用于实现并发处理和异步任务处理。alloc_workqueue函数的原型如下：</p>
<p>struct workqueue_struct *alloc_workqueue(const char *fmt, unsigned int flags, int max_active);</p>
<p>参数说明：</p>
<p>****fmt：****指定工作队列的名称格式。</p>
<p>****flags****：指定工作队列的标志，可以控制工作队列的行为和属性，如WQ_UNBOUND表示无绑定的工作队列，WQ_HIGHPRI表示高优先级的工作队列等。</p>
<p>****max_active****：指定工作队列中同时活跃的最大工作项数量。</p>
<p>函数返回一个指向工作队列结构体（struct workqueue_struct）的指针，或者返回NULL表示创建失败。</p>
<p>在下一小节中将使用上述API进行相应的实验。</p>
<h2 id="48-4-实验程序的编写"><a href="#48-4-实验程序的编写" class="headerlink" title="48.4 实验程序的编写"></a>48.4 实验程序的编写</h2><h3 id="45-4-1-驱动程序编写"><a href="#45-4-1-驱动程序编写" class="headerlink" title="45.4.1 驱动程序编写"></a>45.4.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\38_CMWQ\module。</p>
<p>本实验在35自定义工作队列实验的基础上进行修改，使用alloc_workqueue函数创建和分配一个工作队列。编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="48-5-运行测试"><a href="#48-5-运行测试" class="headerlink" title="48.5 运行测试"></a>48.5 运行测试</h2><h3 id="48-5-1-编译驱动程序"><a href="#48-5-1-编译驱动程序" class="headerlink" title="48.5.1 编译驱动程序"></a>48.5.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图48-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps95.jpg" alt="img"> </p>
<p>图 48-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图48-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps96.jpg" alt="img"></p>
<p>图 48-6</p>
<p>编译完生成interrupt.ko目标文件，如下图（图48-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps97.jpg" alt="img"> </p>
<p>图 48-7</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="48-5-2-运行测试"><a href="#48-5-2-运行测试" class="headerlink" title="48.5.2 运行测试"></a>48.5.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图48-8）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps98.jpg" alt="img"></p>
<p>图48-8</p>
<p>驱动加载之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（48-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps99.jpg" alt="img"></p>
<p>图 48-9</p>
<p>我们按一下屏幕，立即输入“ps -aux | grep test_workqueue”,可以看到工作线程，如下图（48-10）所示，u代表无绑定的工作队列。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps100.jpg" alt="img"></p>
<p>图 48-10</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图48-11）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps101.jpg" alt="img"></p>
<p>图 48-11</p>
<p>至此，并发管理工作队列实验就完成了。	</p>
<h1 id="第49章-中断线程化实验"><a href="#第49章-中断线程化实验" class="headerlink" title="第49章 中断线程化实验"></a>第49章 中断线程化实验</h1><p>中断线程化是实时Linux项目开发的一个新特性，目的是降低中断处理对系统实时延迟的影响。本章节我们来一项新技术——中断线程化。</p>
<h2 id="49-1什么是中断线程化"><a href="#49-1什么是中断线程化" class="headerlink" title="49.1什么是中断线程化"></a>49.1什么是中断线程化</h2><p>中断线程化是一种优化技术，用于提高多线程程序的性能。</p>
<p>想象一下，你正在做一项任务，但是总是被别人的打扰所中断，每次都要停下手头的工作去处理别人的事情。这样频繁的中断会让你的工作效率变低，因为你需要反复切换任务，无法专心做好自己的工作。</p>
<p>在多线程程序中，也存在类似的问题。有时硬件或其他事件会发出中断信号，打断正在执行的线程，需要切换到中断处理程序去处理这些事件。这种频繁的中断切换会导致额外的开销和延迟，影响程序的性能。</p>
<p>为了解决这个问题，中断线程化提出了一种优化方案。它将中断处理程序从主线程中独立出来，创建一个专门的线程来处理这些中断事件。这样，主线程就不再受到中断的干扰，可以专注于自己的工作，不再频繁地被打断。</p>
<p>中断线程化的核心思想是将中断处理和主线程的工作分开，让它们可以并行执行。中断线程负责处理中断事件，而主线程负责执行主要的工作任务。这样一来，不仅可以减少切换的开销，还可以提高整个程序的响应速度和性能。</p>
<p>需要注意的是，中断线程化还需要处理线程之间的同步和数据共享问题。因为中断线程和主线程可能会同时访问和修改共享的数据，所以需要合理地进行同步操作，确保数据的一致性和正确性。</p>
<p>总而言之，中断线程化是一种优化技术，通过将中断处理和主线程的工作分开，提高多线程程序的性能。让主线程不再频繁被中断，可以专注于自己的工作，从而提高程序的效率和响应速度。</p>
<p>中断线程化的处理仍然可以看作是将原来的中断上半部分和中断下半部分。上半部分还是用来处理紧急的事情，下半部分也是出路比较耗时的操作，但是下半部分会交给一个专门的内核线程来处理。这个内核线程只用于这个中断。当发生中断的时候，会唤醒这个内核线程，然后由这个内核线程来执行中断下半部分的函数。</p>
<h2 id="49-2-中断线程化接口函数"><a href="#49-2-中断线程化接口函数" class="headerlink" title="49.2 中断线程化接口函数"></a>49.2 中断线程化接口函数</h2><p>request_threaded_irq 是 Linux 内核中用于请求并注册一个线程化的中断处理函数的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p><em><strong>*参数说明*</strong></em></p>
<p>****irq****：中断号，表示要请求的中断线路。</p>
<p>****handler****：是在发生中断时首先要执行的处理程序，非常类似于顶半部，该函数最后会返回IRQ_WAKE_THREAD来唤醒中断，一般handler设为NULL，用系统提供的默认处理。</p>
<p>****thread_fn****：线程化的中断处理函数，非常类似于底半部。如果此处设置为NULL 则表示没有使用中断线程化。</p>
<p>****irqflags****：中断标志，用于指定中断的属性和行为。</p>
<p>****devname****：中断的名称，用于标识中断请求的设备。</p>
<p>****dev_id****：设备标识符，用于传递给中断处理函数的参数。</p>
<p><em><strong>*函数返回值*</strong></em></p>
<p>  函数返回一个整数值，表示中断请求的结果。如果中断请求成功，返回值为0，否则返回一个负数错误代码。</p>
<p>在下一小节中将使用上述API进行相应的实验，利用中断线程化相关知识来对共享工作队列实验进行优化。</p>
<h2 id="49-3-实验程序的编写"><a href="#49-3-实验程序的编写" class="headerlink" title="49.3 实验程序的编写"></a>49.3 实验程序的编写</h2><h3 id="49-3-1-驱动程序编写"><a href="#49-3-1-驱动程序编写" class="headerlink" title="49.3.1 驱动程序编写"></a>49.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\39_request_threaded_irq\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中提交工作项到工作队列中，打印“This id test_interrupt”，并打印“****This is test_work****”。</p>
<p>我们要实现一个简单的中断处理的例子，用于展示中断的顶半部和底半部处理的概念，并通过线程化的工作队列实现了底半部的延时处理。编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="49-4-运行测试"><a href="#49-4-运行测试" class="headerlink" title="49.4 运行测试"></a>49.4 运行测试</h2><h3 id="49-4-1-编译驱动程序"><a href="#49-4-1-编译驱动程序" class="headerlink" title="49.4.1 编译驱动程序"></a>49.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图49-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps102.jpg" alt="img"></p>
<p>图 49-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图49-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps103.jpg" alt="img"></p>
<p>图 49-2</p>
<p>编译完生成interrupt.ko目标文件，如下图（图49-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps104.jpg" alt="img"></p>
<p>图 49-3</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="49-4-2-运行测试"><a href="#49-4-2-运行测试" class="headerlink" title="49.4.2 运行测试"></a>49.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图49-4）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps105.jpg" alt="img"></p>
<p>图49-4</p>
<p>可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（49-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps106.jpg" alt="img"></p>
<p>图 49-5</p>
<p>我们按一下屏幕，立即输入“ps -aux | grep test_workqueue”,可以看到工作线程，如下图（49-6）所示，u代表无绑定的工作队列。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps107.jpg" alt="img"></p>
<p>图 49-6</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图49-7）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps108.jpg" alt="img"></p>
<p>图 49-7</p>
<p>至此，中断线程化实验就完成了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD/" rel="tag">中断</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-rk3568-驱动开发第四篇-高级字符设备进阶"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E5%9B%9B%E7%AF%87-%E9%AB%98%E7%BA%A7%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E8%BF%9B%E9%98%B6/"
    >rk3568 驱动开发第四篇 高级字符设备进阶</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E5%9B%9B%E7%AF%87-%E9%AB%98%E7%BA%A7%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E8%BF%9B%E9%98%B6/" class="article-date">
  <time datetime="2023-09-04T12:55:36.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第25章-IO模型引入实验"><a href="#第25章-IO模型引入实验" class="headerlink" title="第25章 IO模型引入实验"></a>第25章 IO模型引入实验</h1><p>我们经常提到 IO、NIO 这些名词。那么，到底什么是 IO 呢？什么又是 NIO 呢？另外，我们平时又会听到两组很相似的概念：阻塞&#x2F;非阻塞、同步&#x2F;异步。那么，阻塞和非阻塞有什么区别呢？同步和异步的差别又在哪里呢？</p>
<p>为了更好的理解IO模型，在本章节将对IO的概念、IO的执行过程及IO模型的分类进行详细分析，下面就让我们一起进入IO的世界吧！</p>
<h2 id="25-1-IO的概念"><a href="#25-1-IO的概念" class="headerlink" title="25.1 IO的概念"></a>25.1 IO的概念</h2><p>IO是英文Input和Output的首字母，代表了输入和输出，当然这样的描述有一点点抽象，更直观的意思是计算机的输入与输出。在冯.诺依曼结构中，将计算机分成了5个部分，分别是运算器，控制器，存储器，输入设备，输出设备。如下图（图 25-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps173.jpg" alt="img"> </p>
<p>图 25-1</p>
<p>上图中的输入设备指的是鼠标和键盘等向计算机输入数据和信息的设备，输出设备指的是电脑显示器等用于计算机信息输出的设备，下面对计算机输入输出过程进行实际举例，当敲击键盘（输入设备）任意按键后，按键的数据会传递给计算机，计算机CPU会对数据进行运算，运算完成之后会将数据输出到显示器（输出设备）上，整个过程如下图（图 25-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps174.jpg" alt="img"> </p>
<p>图 25-2</p>
<p>上述事例中，鼠标、显示器只是输入输出的直观表现形式，而在计算机架构层面上，IO是涉及计算机核心与其他设备间数据迁移的过程。以磁盘IO为例，内存读取磁盘数据和将内存数据写入磁盘，就是一对输入输出的过程。</p>
<p>至此，对于IO的概念就讲解完成了，在下一小节中将对IO执行过程进行分析。</p>
<h2 id="25-2-IO执行过程"><a href="#25-2-IO执行过程" class="headerlink" title="25.2 IO执行过程"></a>25.2 IO执行过程</h2><p>操作系统（Linux）负责对计算机的资源进行管理和对进程进行调度，应用程序运行在操作系统上，处于用户空间。应用程序不能直接对硬件进行操作，只能通过操作系统提供的API来操作硬件。需要将进程切换到内核空间，才能进行IO操作，并且应用程序不能直接操作内核空间的数据，需要把内核空间的数据拷贝到用户空间。</p>
<p>应用程序运行在用户空间，它不存在实质的IO过程，真正的IO是在操作系统执行的。那么应用程序操作IO就会有两个动作：IO调用和IO执行。IO调用是应用程序向操作系统内核发起调用，IO执行是操作系统内核完成的IO操作。</p>
<p>一个完整的IO过程需要包含以下三个步骤，如下图（图25-3）所示：</p>
<p>（1） 用户空间的应用程序向内核发起IO调用请求(系统调用)</p>
<p>（2） 内核操作系统准备数据，把IO设备的数据加载到内核缓冲区</p>
<p>（3） 操作系统拷贝数据，把内核缓冲区的数据拷贝到用户进程缓冲区</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps175.jpg" alt="img"> </p>
<p>图 25-2</p>
<h2 id="25-3-IO模型的分类"><a href="#25-3-IO模型的分类" class="headerlink" title="25.3 IO模型的分类"></a>25.3 IO模型的分类</h2><p>假设有这样一个场景，从磁盘中循环读取100M的数据并处理，磁盘读取100M需要花费20秒的时间，CPU同样也需要20秒的时间处理完这些数据。如果采用传统的模式编写代码：读数据-&gt;等待数据读取完毕-&gt;数据处理，可以发现，数据的读取花费了一半的时间，而这就导致该任务的效率极其低下，那么能不能在等待数据的同时对数据进行处理呢？当然可以！这时候就轮到IO编程模型来出场了。</p>
<p>IO模型根据实现的功能可以划分为为阻塞IO、非阻塞IO、信号驱动IO， IO多路复用和异步IO。根据等待IO的执行结果进行划分，前四个IO模型又被称为同步IO，如下图（图 25-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps176.jpg" alt="img"> </p>
<p>图 25-4</p>
<p>所谓同步，即发出一个功能调用后，只有得到结果该调用才会返回。异步的概念和同步相对。当一个异步过程调用发出后，调用者并不能立刻得到结果，实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>
<p>以现实生活去餐馆吃饭为例，根据菜单进行点餐之后，这时会存在两个选择，第一个选择是在餐馆等待饭菜制作完毕，这就是同步IO的具体表现。第二个选择是，离开餐馆去做其他的事情，工作人员会在饭菜制作完成之后提醒你回餐馆取餐，这就是异步IO的具体表现。</p>
<p>下面让我们来认识一下这五种IO模型。</p>
<p><em><strong>*1 阻塞IO*</strong></em></p>
<p>以****阻塞读****为例：进程进行IO操作时(如read操作)，首先会发起一个系统调用，从而转到内核空间进行处理，内核空间的数据没有准备就绪时，进程会被阻塞，不会继续向下执行，直到内核空间的数据准备完成后，数据才会从内核空间拷贝到用户空间，最后返回用户进程，由用户空间进行数据的处理，如下图（图 25-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps177.jpg" alt="img"> </p>
<p>图 25-6</p>
<p>以现实生活中的钓鱼为例，在做好相应准备抛下鱼钩之后，需要耐心等待鱼儿的上钩，等待的过程中必须聚精会神的关注鱼竿的状态，鱼儿上钩之后立刻扬竿，这就是阻塞IO在实际生活中的事例。</p>
<p>通过上述例子可以总结出阻塞IO的优势与不足，首先可以及时的获取结果，并立刻对获取到的结果进行处理，然而在获取结果之前，无法去处理其他任务，需要时刻对结果进行监听。</p>
<p>阻塞IO比较有代表性的是C语言中的scanf()函数。编写好的io.c文件，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>,i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，scanf函数用于从键盘上接收数据，如果键盘不进行数据的输入，该任务会持续阻塞，只有键盘输入数据之后，才会有相应的输入值打印到系统终端上。输入以下命令进行可执行文件的编译，如下（图 25-7）所示</p>
<p>gcc io.c -o io</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps178.jpg" alt="img"> </p>
<p>图 25-8</p>
<p>编译完成之后，输入“.&#x2F;io”运行可执行文件，如下所示，键盘没有输入数据时，该任务会持续阻塞，当在键盘上输入“123”之后，输入的值才会被打印出来，如下（图 25-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps179.jpg" alt="img"> </p>
<p>图 25-9</p>
<p><em><strong>*2 非阻塞IO*</strong></em></p>
<p>和阻塞IO模型不同，非阻塞IO进行IO操作时，如果内核数据没有准备好，内核会立即向进程返回err，不会进行阻塞；如果内核空间数据准备就绪，内核会立即把数据返回给用户空间的进程，如下图（图 25-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps180.jpg" alt="img"> </p>
<p>图 25-10</p>
<p>仍旧以现实生活中钓鱼为例，在做好相应准备抛下鱼钩之后，这次并没有持续不断的关注鱼竿的状态，而是去做其他的事情（不阻塞等待结果），每隔几分钟对鱼竿的状态进行检查，如果没有鱼儿上钩，就继续去做其他事情，如果上钩了就把鱼钓上来,这就是非阻塞IO在实际生活中的事例。</p>
<p>从上述案例中可以看出非阻塞IO的优点是效率高，同样的时间可以做更多的事。但是缺点也很明显，需要不断对结果进行轮询查看，从而导致结果获取不及时（结果可能在两次轮询之间就已经准备完毕，但是只能在发起轮询的时候才能知道），如果要增加非阻塞IO的实时性，就要加快轮询的频率，但这样无疑也会增加CPU的负担。</p>
<p><em><strong>*3 IO多路复用*</strong></em></p>
<p>通常情况下使用select()、poll()、epoll()函数实现IO多路复用。这里以select函数为例进行讲解，使用时可以对select传入多个描述符，并设置超时时间。当执行select的时候，系统会发起一个系统调用，内核会遍历检查传入的描述符是否有事件发生（如可读、可写事件）。如有，立即返回，否则进入睡眠状态，使进程进入阻塞状态，直到任何一个描述符事件产生后（或者等待超时）立刻返回。此时用户空间需要对全部描述符进行遍历，以确认具体是哪个发生了事件，这样就能使用一个进程对多个IO进行管理，如下图（图 25-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps181.jpg" alt="img"> </p>
<p>图 25-11</p>
<p>继续以现实生活中的钓鱼为例，和之前案例只有一个鱼竿不同，这次会在十个不同的地方做好相应准备抛下鱼钩，并把十个鱼竿连在了一个铃铛上，这样只要铃铛响了就表示有鱼上钩，只需挨个检查到底是哪个鱼竿有鱼上钩即可。</p>
<p>这样的优点是一个进程&#x2F;线程可以同时监听和处理多路IO，效率成倍提高。但是IO多路复用并不是能医治百病的良药，虽然IO多路复用可以监听多个IO，但是实际上对结果的处理也只能依次进行，比较适合IO密集但是每一路IO数据量不多且到达时间分散的场合（如网络聊天）。</p>
<p>另外select监听的描述符有上限（一般描述符最大不超过1024），而且需要遍历究竟是哪一个IO产生了数据。因此IO较多时，效率不高（这个问题被epoll解决，感兴趣的读者可以自行了解）。</p>
<p><em><strong>*4 信号驱动*</strong></em></p>
<p>信号驱动IO顾名思义与信号相关。系统在一些事件发生之后，会对进程发出特定的信号，而信号与处理函数相绑定，当信号产生时就会调用绑定的处理函数。例如在Linux系统任务执行的过程中可以按下ctrl+C来对任务进行终止，系统实际上是对该进程发送一个SIGINT信号，该信号的默认处理函数就是退出当前程序。</p>
<p>具体到IO模型上，可以对SIGIO信号注册相应的信号处理函数，并打开对应描述符的信号驱动。每当有IO数据产生时，系统就会发送一个SIGIO信号，进而调用相应的信号处理函数，从而在这个处理函数中对数据进行读取，如下图（图 25-12）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps182.jpg" alt="img"> </p>
<p>图 25-12</p>
<p>仍旧以现实生活中的钓鱼为例，在做好相应准备抛下鱼钩之后，这次同样没有持续不断的关注鱼竿的状态，而是去做其他的事情（不阻塞等待结果），与之前不同的是，在鱼竿处绑定了一个提醒铃铛，当鱼咬钩之后，铃铛就会响(有SIGIO信号)，进而得知到鱼儿上钩的消息之，这样就可以及时把鱼钓上来了(调用处理函数)。</p>
<p><em><strong>*5 异步IO*</strong></em></p>
<p>aio_read函数常常用于异步IO，当进程使用aio_read读取数据时，如果数据尚未准备就绪就立即返回，不会阻塞。若数据准备就绪就会把数据从内核空间拷贝到用户空间的缓冲区中，然后执行定义好的回调函数对接收到的数据进行处理。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps183.jpg" alt="img"> </p>
<p>图 25-13</p>
<p>最后，还是以钓鱼为例。小马同学喜欢吃新鲜的鱼，但是不想自己钓，所以他请了一个助手来帮他钓鱼，他自己去忙其他的事情（进程不阻塞，立即返回）。如果有鱼上钩助手会帮忙钓上来（将数据拷贝到指定的缓冲区），并立即通知小马同学回来把鱼取走（处理数据）。</p>
<h1 id="第26章-阻塞IO实验"><a href="#第26章-阻塞IO实验" class="headerlink" title="第26章  阻塞IO实验"></a>第26章  阻塞IO实验</h1><p>在上一章节，对IO的相关概念和五种IO模型分类进行了学习，在接下来的章节中将分别对四种同步IO进行详细的讲解和实验，本章节要讲解的IO模型是阻塞IO，阻塞IO在Linux内核中是非常常用的IO模型，所依赖的机制是等待队列。下面让我们来开始阻塞IO的学习吧。</p>
<h2 id="26-1-什么是等待队列"><a href="#26-1-什么是等待队列" class="headerlink" title="26.1 什么是等待队列"></a>26.1 什么是等待队列</h2><p>在Linux驱动程序中，阻塞进程可以使用等待队列来实现。等待队列是内核实现阻塞和唤醒的内核机制，以双循环链表为基础结构，由链表头和链表项两部分组成，分别表示等待队列头和等待队列元素，如下图（图26-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps184.jpg" alt="img"> </p>
<p>图26-1</p>
<p>等待队列头使用结构体wait_queue_head_t 来表示，等待队列头是一个等待队列的头部，这个结构体定义在文件include&#x2F;linux&#x2F;wait.h里面，结构体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">wait_queue_head</span>&#123;</span></span><br><span class="line"><span class="type">spinlock_t</span> lock;    <span class="comment">//自旋锁</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span> //链表头</span></span><br><span class="line"><span class="class">&#125;；</span></span><br><span class="line"><span class="class"><span class="title">typefef</span> <span class="keyword">struct</span> _<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br></pre></td></tr></table></figure>

<p>等待队列项使用结构体wait_queue_t来表示，等待队列项是等待队列元素，该结构体同样定义在文件include&#x2F;linux&#x2F;wait.h里面，结构体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">wait_queue</span>&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">void</span> *private;</span><br><span class="line"><span class="type">wait_queue_func_t</span> func;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">wait_queue</span> <span class="title">wait_queue_t</span>;</span></span><br></pre></td></tr></table></figure>

<h2 id="26-2-等待队列API函数"><a href="#26-2-等待队列API函数" class="headerlink" title="26.2 等待队列API函数"></a>26.2 等待队列API函数</h2><p><em><strong>*1 定义并初始化等待队列头*</strong></em></p>
<p>等待队列要想被使用，第一步就是对等待队列头进行初始化，有俩种办法如下所示：</p>
<p>方法一：使用 DECLARE_WAIT_QUEUE_HEAD宏静态创建等待队列头，宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WAIT_QUEUE_HEAD(name) \</span></span><br><span class="line"><span class="meta">wait_queue_head_t name = __WAIT_QUEUE_HEAD_INITIALIZER(name)</span></span><br></pre></td></tr></table></figure>

<p>参数name表示要定义的队列头名字。通常以全局变量的方式定义,如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_WAIT_QUEUE_HEAD(head);</span><br></pre></td></tr></table></figure>

<p>方法二：使用init_waitqueue_head宏动态初始化等待队列头，宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> init_waitqueue_head(q)				\</span></span><br><span class="line"><span class="meta">	do &#123;						\</span></span><br><span class="line"><span class="meta">		static struct lock_class_key __key;	\</span></span><br><span class="line"><span class="meta">							\</span></span><br><span class="line"><span class="meta">		__init_waitqueue_head((q), #q, &amp;__key);	\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>参数q表示需要初始化的队列头指针。使用宏定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wait_queue_head_t</span> head;       <span class="comment">//等待队列头</span></span><br><span class="line">init_waitqueue_head(&amp;head);    <span class="comment">//初始化等待队列头指针</span></span><br></pre></td></tr></table></figure>



<p>然后再来学习如何创建等待队列元素，也就是等待队列项。</p>
<p><em><strong>*2 创建等待队列项*</strong></em></p>
<p>一般使用宏 DECLARE_WAITQUEUE(name,tsk)给当前正在运行的进程创建并初始化一个等待队列项，宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WAITQUEUE(name, tsk)						\</span></span><br><span class="line"><span class="meta">struct wait_queue_entry name = __WAITQUEUE_INITIALIZER(name, tsk)</span></span><br></pre></td></tr></table></figure>

<p>第一个参数name是等待队列项的名字，第二个参数tsk表示此等待队列项属于哪个任务（进程），一般设置为current。在Linux内核中current相当于一个全局变量，表示当前进程。创建等待队列项如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_WAITQUEUE(wait,current);  <span class="comment">//给当前正在运行的进程创建一个名为wait的等待队列项。</span></span><br><span class="line">add_wait_queue(wq,&amp;wait); <span class="comment">//将wait这个等待队列项加到wq这个等待队列当中</span></span><br></pre></td></tr></table></figure>

<p><em><strong>*3添加&#x2F;删除队列*</strong></em></p>
<p>当设备没有准备就绪（如没有可读数据）而需要进程阻塞的时候，就需要将进程对应的等待队列项添加到前面创建的等待队列中，只有添加到等待队列中以后进程才能进入休眠态。当设备可以访问时（如有可读数据），再将进程对应的****等待队列项****从等待队列中移除即可。</p>
<p>等待队列项添加队列函数如下所示：</p>
<p><em><strong>*函数原型:*</strong></em></p>
<p>  void add_wait_queue(wait_queue_head_t *q,wait_queue_t *wait)</p>
<p><em><strong>*函数功能:*</strong></em></p>
<p> (通过等待队列头)向等待队列中添加队列项</p>
<p><em><strong>*参数含义:*</strong></em></p>
<p> wq_head表示等待队列项要加入等待队列的等待队列头</p>
<p>wq_entry表示要加入的等待队列项</p>
<p><em><strong>*函数返回值*</strong></em>  </p>
<p>无</p>
<p>等待队列项移除队列函数如下所示：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>void remove_wait_queue(wait_queue_head_t *q,wait_queue_t *wait)</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>要删除的等待队列项所处的等待队列头</p>
<p><em><strong>*函数含义：*</strong></em></p>
<p>第一个参数q表示等待队列项要加入等待队列的等待队列头</p>
<p>第二个参数wait表示要加入的等待队列项</p>
<p><em><strong>*函数返回值：*</strong></em></p>
<p>无</p>
<p><em><strong>*4等待事件*</strong></em></p>
<p>除了主动唤醒以外，也可以设置等待队列等待某个事件，当这个事件满足以后就自动唤醒等待队列中的进程，使用如下所示的宏，是不可中断的阻塞等待。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __wait_event(wq_head, condition)					\</span></span><br><span class="line"><span class="meta">(void)___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 0, 0,	\</span></span><br><span class="line"><span class="meta">schedule())</span></span><br></pre></td></tr></table></figure>

<p><em><strong>*宏定义功能：*</strong></em></p>
<p>不可中断的阻塞等待，让调用进程进入不可中断的睡眠状态，在等待队列里面睡眠直到condition变成真，被内核唤醒。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>第一个参数wq: wait_queue_head_t 类型变量</p>
<p>第二个参数condition : 等待条件，为假时才可以进入休眠。如果condition为真，则不会休眠</p>
<p>除此之外，wait_event_interruptible的宏是可中断的阻塞等待。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __wait_event_interruptible(wq_head, condition)				\</span></span><br><span class="line"><span class="meta">___wait_event(wq_head, condition, TASK_INTERRUPTIBLE, 0, 0,		\</span></span><br><span class="line"><span class="meta">schedule())</span></span><br></pre></td></tr></table></figure>



<p><em><strong>*宏含义功能：*</strong></em></p>
<p>可中断的阻塞等待，让调用进程进入可中断的睡眠状态，直到condition变成真被内核唤醒或信号打断唤醒。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>第一个参数wq :wait_queue_head_t 类型变量</p>
<p>第二个参数condition :等待条件。为假时才可以进入休眠。如果condition为真，则不会休眠。</p>
<p>wait_event_timeout() 宏也与 wait_event()类似.不过如果所给的睡眠时间为负数则立即返回.如果在睡眠期间被唤醒,且condition 为真则返回剩余的睡眠时间,否则继续睡眠直到到达或超过给定的睡眠时间,然后返回 0。</p>
<p>wait_event_interruptible_timeout() 宏与 wait_event_timeout()类似,不过如果在睡眠期间被信号打断则返回 ERESTARTSYS 错误码。</p>
<p>wait_event_interruptible_exclusive() 宏同样和 wait_event_interruptible()一样,不过该睡眠的进程是一个互斥进程</p>
<p>注意：调用的时要确认 condition 值是真还是假，如果调用 condition 为真，则不会休眠。</p>
<p><em><strong>*5等待队列唤醒*</strong></em></p>
<p>当设备可以使用的时候就要唤醒进入休眠态的进程，唤醒可以使用如下俩个函数</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>wake_up(wait_queue_head_t *q)</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>唤醒所有休眠进程</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>q表示要唤醒的等待队列的等待队列头</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>wake_up_interruptible(wait_queue_head_t *q)</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>唤醒可中断的休眠进程</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>q表示要唤醒的等待队列的等待队列头</p>
<h2 id="26-3-等待队列使用方法"><a href="#26-3-等待队列使用方法" class="headerlink" title="26.3 等待队列使用方法"></a>26.3 等待队列使用方法</h2><p>步骤一：初始化等待队列头，并将条件置成假(condition&#x3D;0)。</p>
<p>步骤二：在需要阻塞的地方调用wait_event()，使进程进入休眠状态。</p>
<p>步骤三：当条件满足时，需要解除休眠，先将条件(condition&#x3D;1),然后调用wake_up函数唤醒等待队列中的休眠进程。</p>
<h2 id="26-4-实验程序编写"><a href="#26-4-实验程序编写" class="headerlink" title="26.4 实验程序编写"></a>26.4 实验程序编写</h2><h3 id="26-4-1-驱动程序编写"><a href="#26-4-1-驱动程序编写" class="headerlink" title="26.4.1 驱动程序编写"></a>26.4.1 驱动程序编写</h3><p>本实验对应的驱动网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\20\module。</p>
<p>接着编写等待队列的实验代码，在此代码中，按照上一小节等待队列使用方法的三个步骤进行编写，在read函数中调用wait_event_interruptible函数阻塞，使进程进入休眠状态。在write函数中唤醒等待队列中的休眠进程。编写好的驱动程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span>  flag;  <span class="comment">//标志位</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  </span><br><span class="line"></span><br><span class="line">DECLARE_WAIT_QUEUE_HEAD(read_wq); <span class="comment">//定义并初始化等待队列头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test_dev-&gt;flag=<span class="number">1</span>;<span class="comment">//将条件置1</span></span><br><span class="line">    wake_up_interruptible(&amp;read_wq); <span class="comment">//并使用wake_up_interruptible唤醒等待队列中的休眠进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    wait_event_interruptible(read_wq,test_dev-&gt;flag); <span class="comment">//可中断的阻塞等待，使进程进入休眠态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="26-4-2-编写测试-APP"><a href="#26-4-2-编写测试-APP" class="headerlink" title="26.4.2 编写测试 APP"></a>26.4.2 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\20\app。</p>
<p>接下来编写应用程序read.c，此程序实现了从设备读取数据的功能。编写好的应用程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开led驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read before \n&quot;</span>);</span><br><span class="line">    read(fd,buf1,<span class="keyword">sizeof</span>(buf1));  <span class="comment">//从/dev/test文件读取数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf is %s  \n&quot;</span>,buf1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read after \n&quot;</span>);</span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理 ，编写应用程序write.c，实现向设备写入数据的功能，编写好的应用程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开led驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write before \n&quot;</span>);</span><br><span class="line">    write(fd,buf2,<span class="keyword">sizeof</span>(buf2));  <span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;write after\n&quot;</span>);</span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-5运行测试"><a href="#26-5运行测试" class="headerlink" title="26.5运行测试"></a>26.5运行测试</h2><h3 id="26-5-1编译驱动程序"><a href="#26-5-1编译驱动程序" class="headerlink" title="26.5.1编译驱动程序"></a>26.5.1编译驱动程序</h3><p>在上一小节中的wq.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += wq.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放wq.c和Makefile文件目录下，如下图（图 26-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps185.jpg" alt="img"> </p>
<p>图 26-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 26-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps186.jpg" alt="img"> </p>
<p>图 26-3</p>
<p>编译完生成 wq.ko目标文件，如下图（图 26-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps187.jpg" alt="img"> </p>
<p>图 26-4</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="26-5-2-编译应用程序"><a href="#26-5-2-编译应用程序" class="headerlink" title="26.5.2 编译应用程序"></a>26.5.2 编译应用程序</h3><p>来到存放应用程序read.c和write.c的文件夹下，使用以下命令对read.c和write.c进行交叉编译，编译完成如下图（图 26-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o read read.c -static</p>
<p>aarch64-linux-gnu-gcc -o write write.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps188.jpg" alt="img"> </p>
<p>图 26-4</p>
<p>生成的read write文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="26-5-3-运行测试"><a href="#26-5-3-运行测试" class="headerlink" title="26.5.3 运行测试"></a>26.5.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 26-5）所示：</p>
<p>insmod wq.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps189.jpg" alt="img"></p>
<p>图 26-5</p>
<p>输入以下命令运行read可执行文件，如下图（图 26-6）所示，read应用程序进程阻塞</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps190.jpg" alt="img"></p>
<p>图 26-6</p>
<p>然后输入以下命令运行write可执行文件，如下图（图 26-7）所示，使用write函数向设备写入数据，唤醒等待队列中的休眠进程。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps191.jpg" alt="img"></p>
<p>图 26-7</p>
<p>在使用可执行程序write向缓冲区写入数据时，read可执行程序读取到了缓冲区的数据并打印。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps192.jpg" alt="img"></p>
<p>图 26-8</p>
<h1 id="第27章-非阻塞IO实验"><a href="#第27章-非阻塞IO实验" class="headerlink" title="**** ****第27章 非阻塞IO实验"></a>**** ****第27章 非阻塞IO实验</h1><p>上个章节中我们学习了阻塞IO，阻塞IO是通过等待队列来实现的，那么如何让驱动实现非阻塞呢？带着疑问，让我们开始本章节非阻塞IO的学习吧！</p>
<h2 id="27-1-非阻塞IO简介"><a href="#27-1-非阻塞IO简介" class="headerlink" title="27.1 非阻塞IO简介"></a>27.1 非阻塞IO简介</h2><p>应用程序可以使用如下所示示例代码来实现阻塞访问：</p>
<p>int fd;</p>
<p>int data &#x3D; 0;</p>
<p>fd &#x3D; open(“&#x2F;dev&#x2F;xxx_dev”, <em><strong>*O_RDWR*</strong></em>);  &#x2F;* 阻塞方式打开 *&#x2F;</p>
<p>ret &#x3D; read(fd, &amp;data, sizeof(data));   &#x2F;* 读取数据 *&#x2F;</p>
<p>可以看出对于设备驱动文件的默认读取方式就是阻塞式的，所以之前实验例程测试 APP 都是采用阻塞 IO。</p>
<p>如果应用程序要采用非阻塞的方式来访问驱动设备文件，可以使用如下所示代码：</p>
<p>int fd;</p>
<p>int data &#x3D; 0;</p>
<p>fd &#x3D; open(“&#x2F;dev&#x2F;xxx_dev”, <em><strong>*O_RDWR | O_NONBLOCK*</strong></em>); &#x2F;* 非阻塞方式打开 *&#x2F;</p>
<p>ret &#x3D; read(fd, &amp;data, sizeof(data)); &#x2F;* 读取数据 *&#x2F;</p>
<p>使用 open 函数打开“&#x2F;dev&#x2F;xxx_dev”设备文件的时候添加了参数“O_NONBLOCK”，表示以非阻塞方式打开设备，这样从设备中读取数据的时候是非阻塞方式了。</p>
<h2 id="27-2-实验程序编写"><a href="#27-2-实验程序编写" class="headerlink" title="27.2 实验程序编写"></a>27.2 实验程序编写</h2><h3 id="27-2-1-编写测试-APP"><a href="#27-2-1-编写测试-APP" class="headerlink" title="27.2.1 编写测试 APP"></a>27.2.1 编写测试 APP</h3><p>非阻塞IO实验需要应用程序和驱动配合，所以需要编写驱动代码和应用测试代码。</p>
<p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\21\app。</p>
<p>首先来编写应用测试代码read.c，在此代码中使用非阻塞的方式打开设备，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;  <span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//定义读取缓冲区buf</span></span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//定义读取缓冲区buf</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR| O_NONBLOCK);  <span class="comment">//打开/dev/test设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read before \n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         read(fd,buf1,<span class="keyword">sizeof</span>(buf1));  <span class="comment">//从/dev/test文件读取数据</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;buf is %s \n&quot;</span>,buf1);  <span class="comment">//打印读取的数据</span></span><br><span class="line">         sleep(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read after\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着编写应用程序write.c，用来向设备文件写入数据，编写好的应用程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR|O_NONBLOCK);  <span class="comment">//打开/dev/test设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write before \n&quot;</span>);</span><br><span class="line">    write(fd,buf2,<span class="keyword">sizeof</span>(buf2));  <span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;write after\n&quot;</span>);</span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="27-2-1-驱动程序编写"><a href="#27-2-1-驱动程序编写" class="headerlink" title="27.2.1 驱动程序编写"></a>27.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\21\module。</p>
<p> 编写好的驱动程序wq.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span>  flag;  <span class="comment">//标志位</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  </span><br><span class="line"></span><br><span class="line">DECLARE_WAIT_QUEUE_HEAD(read_wq); <span class="comment">//定义并初始化等待队列头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test_dev-&gt;flag=<span class="number">1</span>;    <span class="comment">//将条件置1，并使用wake_up_interruptible唤醒等待队列中的休眠进程</span></span><br><span class="line">    wake_up_interruptible(&amp;read_wq); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span>(file-&gt;f_flags &amp; O_NONBLOCK )&#123;</span><br><span class="line">        <span class="keyword">if</span> (test_dev-&gt;flag !=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    &#125;</span><br><span class="line">    wait_event_interruptible(read_wq,test_dev-&gt;flag); <span class="comment">//可中断的阻塞等待，使进程进入休眠态</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="27-3-运行测试"><a href="#27-3-运行测试" class="headerlink" title="27.3 运行测试"></a>27.3 运行测试</h2><h3 id="27-3-1-编译驱动程序"><a href="#27-3-1-编译驱动程序" class="headerlink" title="27.3.1 编译驱动程序"></a>27.3.1 编译驱动程序</h3><p>在上一小节中的wq.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += wq.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放wq.c和Makefile文件目录下，如下图（图 27-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps193.jpg" alt="img"> </p>
<p>图 27-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图27-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps194.jpg" alt="img"> </p>
<p>图 27-2</p>
<p>编译完生成 wq.ko目标文件，如下图（图 27-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps195.jpg" alt="img"> </p>
<p>图 27-3</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="27-3-2-编译应用程序"><a href="#27-3-2-编译应用程序" class="headerlink" title="27.3.2 编译应用程序"></a>27.3.2 编译应用程序</h3><p>来到存放应用程序read.c和write.c的文件夹下，使用以下命令对read.c和write.c进行交叉编译，编译完成如下图（图 27-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o read read.c -static</p>
<p>aarch64-linux-gnu-gcc -o write write.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps196.jpg" alt="img"> </p>
<p>图 27-4</p>
<p>生成的read write文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="27-3-3-测试"><a href="#27-3-3-测试" class="headerlink" title="27.3.3 测试"></a>27.3.3 测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 27-5）所示：</p>
<p>insmod wq.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps197.jpg" alt="img"></p>
<p>图 27-5</p>
<p>输入以下命令运行read可执行文件，如下图（图 27-6）所示，应用程序进程非阻塞，读取不到数据便返回，然后一直轮询查看是否有数据。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps198.jpg" alt="img"></p>
<p>图 27-6</p>
<p>然后输入以下命令运行write可执行文件向设备文件写入数据，如下图（图 27-7）所示:</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps199.jpg" alt="img"></p>
<p>图 27-7</p>
<p>在使用可执行程序write向缓冲区写入数据时，read可执行程序读取到了缓冲区的数据并打印。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps200.jpg" alt="img"></p>
<p>图 27-8</p>
<h1 id="第28章-IO多路复用实验"><a href="#第28章-IO多路复用实验" class="headerlink" title="**** ****第28章 IO多路复用实验"></a>**** ****第28章 IO多路复用实验</h1><p>在上俩个章节中，我们对阻塞IO和非阻塞IO进行了学习，本章节将学习第三种IO模型-多路复用IO。</p>
<h2 id="28-1-IO多路复用简介"><a href="#28-1-IO多路复用简介" class="headerlink" title="28.1 IO多路复用简介"></a>28.1 IO多路复用简介</h2><p>IO多路复用是一种同步的IO模型。IO多路复用可以实现一个进程监视多个文件描述符。一旦某个文件描述符准备就绪，就通知应用程序进行相应的读写操作。没有文件描述符就绪时就会阻塞应用程序，从而释放出CPU资源。</p>
<p>在第25章中，我们以钓鱼为例，对IO多路复用有了一个简单的认识。下面对钓鱼例子进行回顾：小李同时放置了十个鱼竿，并把十个鱼竿连在了一个铃铛上。这样小李就不必在岸边等待。当铃铛响了就表示有鱼上钩，再回来挨个检查到底是哪个鱼竿有鱼上钩即可。接着进一步体会IO多路复用。</p>
<p>在应用层Linux提供了三种实现IO多路复用的模型，分别是select、poll 和 epoll。在本驱动手册中主要偏重于对驱动的讲解，所以应用层中select、poll 和 epoll函数的使用在这里不做重点讲解。</p>
<p>首先来学习下select、poll 和 epoll函数有什么区别呢？poll函数和seslect函数都可以监听多个文件描述符，通过轮询来获取已经准备好的文件描述符。但是epoll函数将主动轮询变成了被动通知，当事件发生时被动接收通知。为了方便理解，举个形象的例子。假如poll和select是公司的前台，某天一位客户来公司找硬件工程师-小李，请求前台帮忙找人。于是poll和select前台带着这位客户挨个屋子寻找小李，直到找到小李为止。假如epoll是公司的前台，他提前统计了公司每个员工的工位。当客户来找小李的时候，不必像poll select一样，可以直接带着客户到硬件部门去找小李。从上面的俩个例子，明显对比epoll的效率更高。假如公司园区很大，那么poll select需要花费很长时间寻找小李，而epoll已经提前知道小李坐在哪个工位了，直接带客户去找小李即可。</p>
<p>select,poll,epoll有什么区别呢？在单个线程中，select函数最大可以监视1024个文件描述符，而poll函数和select函数并没有什么区别，只是poll函数没有最大文件描述符的限制。在本章节的实验中，以poll为例进行实验。在Linux应用程序中poll函数如下所示：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int poll(struct pollfd *fds,</p>
<p>nfds_t nfds,</p>
<p>int timeout);</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>监视并等待多个文件描述符的属性变化</p>
<p><em><strong>*函数参数：*</strong></em></p>
<p><em><strong>*第一个参数fds*</strong></em>: 要监视的文件描述符集合以及要监视的事件，为一个数组，数组元素都是结构体pollfd类型，pollfd结构体如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"><span class="type">int</span> fd;       <span class="comment">//被监视的文件描述符</span></span><br><span class="line"><span class="type">short</span> events;  <span class="comment">//等待的事件</span></span><br><span class="line"><span class="type">short</span> revents;  <span class="comment">//实际发生的事件</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>在pollfd结构体中，第一个成员fd是被监视的文件描述符。第二个成员events是要监视的事件，可监视的事件类型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POLLIN   有数据可以读取</span><br><span class="line">POLLPRI  有紧急的数据需要读取</span><br><span class="line">POLLOUT  可以写数据</span><br><span class="line">POLLERR   指定的文件描述符发生错误</span><br><span class="line">POLLHUP   指定的文件描述符挂起</span><br><span class="line">POLLNVAL  无效的请求</span><br><span class="line">POLLRDNORM  等同于POLLIN</span><br></pre></td></tr></table></figure>

<p>第三个成员是返回事件，由Linux内核设置具体的返回事件。</p>
<p><em><strong>*第二个参数nfds*</strong></em>: poll函数要监视的文件描述符数量</p>
<p><em><strong>*第三个参数timeout*</strong></em>:指定等待的时间，单位是ms。无论I&#x2F;O是否准备好，时间到POLL就会返回。如果timepoll大于0 等待指定的时间，如果timeout等于0，立即返回。如果timeout等于-1，事件发生以后才返回。</p>
<p><em><strong>*函数返回值：*</strong></em></p>
<p>失败返回-1，成功返回revents不为0的文件描述符个数。</p>
<p>当应用程序使用select或者poll函数对驱动程序进行非阻塞访问时，驱动程序中file_operations操作集的poll函数会执行。所以需要完善驱动中的poll函数。驱动中的poll函数原型如下所示：</p>
<p>unsigned int (*poll)(struct file *filp,struct poll_table_struct *wait);</p>
<p><em><strong>*函数参数：*</strong></em></p>
<p>filp:要打开的文件描述符</p>
<p>wait: 结构体poll_table_struct类型指针，此参数是由应用程序中传递的。一般此参数要传递给poll_wait函数。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>向应用程序返回资源状态，可以返回的资源状态如下：</p>
<p>POLLIN  有数据可以读取</p>
<p>POLLPRI  有紧急的数据需要读取</p>
<p>POLLOUT  可以写数据</p>
<p>POLLERR  指定的文件描述符发生错误</p>
<p>POLLHUP  指定的文件描述符挂起</p>
<p>POLLNVAL  无效的请求</p>
<p>POLLRDNORM 等同于POLLIN，普通数据可读。</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>这个函数要进行下面两项工作。首先，对可能引起设备文件状态变化的等待队列调用poll_wait(),将对应的等待队列头添加到poll_table.然后返回表示是否能对设备进行无阻塞读写访问的掩码。</p>
<p>驱动程序的poll函数中调用poll_wait函数，注意！poll_wait函数是不会引起阻塞的。poll_wait函数原型如下所示：</p>
<p>void poll_wait(struct file *filp,wait_queue_head_t *queue,poll_table *wait);</p>
<p>参数queue是要添加到poll_table中的等待队列头，参数wait是poll_table，也就是file_operations中poll函数的wait参数。</p>
<h2 id="28-2-实验程序编写"><a href="#28-2-实验程序编写" class="headerlink" title="28.2 实验程序编写"></a>28.2 实验程序编写</h2><h3 id="28-2-1-编写测试-APP"><a href="#28-2-1-编写测试-APP" class="headerlink" title="28.2.1 编写测试 APP"></a>28.2.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\22\app。</p>
<p>在应用层Linux提供了三种API函数，分别是select poll和epoll。本次实验使用poll函数进行实验，如果对select 和epoll函数感兴趣，可以查找一些系统编程课程学习。</p>
<p>编写好的应用程序read.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;  <span class="comment">//要监视的文件描述符</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>  <span class="title">fds</span>[1];</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开/dev/test设备，阻塞式访问</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//构造结构体</span></span><br><span class="line">    fds[<span class="number">0</span>] .fd =fd;</span><br><span class="line">    fds[<span class="number">0</span>].events = POLLIN; <span class="comment">//监视数据是否可以读取</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read before \n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = poll(fds,<span class="number">1</span>,<span class="number">3000</span>);  <span class="comment">//轮询文件是否可操作，超时3000ms</span></span><br><span class="line">    <span class="keyword">if</span>(!ret)&#123;  <span class="comment">//超时</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;time out !!\n,&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(fds[<span class="number">0</span>].revents == POLLIN) <span class="comment">//如果返回事件是有数据可读取</span></span><br><span class="line">    &#123;</span><br><span class="line">        read(fd,buf1,<span class="keyword">sizeof</span>(buf1));  <span class="comment">//从/dev/test文件读取数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf is %s \n,&quot;</span>,buf1); <span class="comment">//打印读取的数据</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read after\n&quot;</span>);</span><br><span class="line">close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码第16行，在打开设备节点时不使用非阻塞方式，要使用阻塞方式，所以改为O_RDWR。</p>
<p>在上述代码的第28行，使用poll函数监视并等待多个文件描述符的属性变化。poll函数第一个参数是被监视的文件描述符，是pollfd结构体类型的数组，所以在14行定义了pollfd结构体类型的数组fds。poll函数第2个参数是要监视的文件描述符数量，这里监视的文件描述符为1个。poll函数第3个参数是指定等待的时间 3000ms。</p>
<p>然后编写应用程序write.c，实现向设备文件写入数据的功能，编写好的write.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR);  <span class="comment">//打开/dev/test设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write before \n&quot;</span>);</span><br><span class="line">    write(fd,buf2,<span class="keyword">sizeof</span>(buf2));  <span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;write after\n&quot;</span>);</span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="28-2-2-驱动程序编写"><a href="#28-2-2-驱动程序编写" class="headerlink" title="28.2.2 驱动程序编写"></a>28.2.2 驱动程序编写</h3><p>本实验对应的驱动程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\22\module。</p>
<p>IO多路复用实验需要应用程序和驱动程序进行配合，接下来编写驱动程序。编写好的驱动程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span>  flag;  <span class="comment">//标志位</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  </span><br><span class="line">DECLARE_WAIT_QUEUE_HEAD(read_wq); <span class="comment">//定义并初始化等待队列头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test_dev-&gt;flag=<span class="number">1</span>;</span><br><span class="line">    wake_up_interruptible(&amp;read_wq);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span>(file-&gt;f_flags &amp; O_NONBLOCK )&#123;</span><br><span class="line">        <span class="keyword">if</span> (test_dev-&gt;flag !=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    &#125;</span><br><span class="line">    wait_event_interruptible(read_wq,test_dev-&gt;flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span>  <span class="type">__poll_t</span>  <span class="title function_">cdev_test_poll</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> poll_table_struct *p)</span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;  <span class="comment">//设置私有数据</span></span><br><span class="line">     <span class="type">__poll_t</span> mask=<span class="number">0</span>;    </span><br><span class="line">     poll_wait(file,&amp;read_wq,p);     <span class="comment">//应用阻塞</span></span><br><span class="line">     <span class="keyword">if</span> (test_dev-&gt;flag == <span class="number">1</span>)    </span><br><span class="line">     &#123;</span><br><span class="line">         mask |= POLLIN; </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> mask; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">    .poll = cdev_test_poll,  <span class="comment">//将poll字段指向chrdev_poll(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>首先在第9行代码添加&lt;linux&#x2F;poll.h&gt;头文件。然后在第94行将poll字段指向chrdev_poll(…)函数，最后在73行到84行编写这个函数。</p>
<h2 id="28-3-运行测试"><a href="#28-3-运行测试" class="headerlink" title="28.3 运行测试"></a>28.3 运行测试</h2><h3 id="28-3-1-编译驱动程序"><a href="#28-3-1-编译驱动程序" class="headerlink" title="28.3.1 编译驱动程序"></a>28.3.1 编译驱动程序</h3><p>在上一小节中的poll.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += poll.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放poll.c和Makefile文件目录下，如下图（图 28-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps201.jpg" alt="img"> </p>
<p>图 28-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 28-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps202.jpg" alt="img"> </p>
<p>图 28-2</p>
<p>编译完生成poll.ko目标文件，如下图（图 28-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps203.jpg" alt="img"></p>
<p>图 28-3</p>
<p>至此驱动模块就编译成功了，下面进行应用程序read.c和write.c的编译。</p>
<h3 id="28-3-2-编译应用程序"><a href="#28-3-2-编译应用程序" class="headerlink" title="28.3.2 编译应用程序"></a>28.3.2 编译应用程序</h3><p>来到存放应用程序read.c和write.c的文件夹下，使用以下命令对read.c和write.c进行交叉编译，编译完成如下图（图 28-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o read read.c -static</p>
<p>aarch64-linux-gnu-gcc -o write write.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps204.jpg" alt="img"> </p>
<p>图 28-4</p>
<p>生成的read write文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="28-3-3-测试"><a href="#28-3-3-测试" class="headerlink" title="28.3.3 测试"></a>28.3.3 测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 28-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps205.jpg" alt="img"></p>
<p>图 28-5</p>
<p>在加载驱动程序之后，会生成如下图（图 28-6）所示的设备节点，在应用程序中也是操作这个设备节点。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps206.jpg" alt="img"></p>
<p>图 28-6</p>
<p>首先运行read可执行程序，如下（图 28-7）所示，在三秒钟以后打印“time out”。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps207.jpg" alt="img"></p>
<p>图 28-7</p>
<p>然后运行write可执行程序写入数据，如下（图 28-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps208.jpg" alt="img"></p>
<p>图 28-8</p>
<p>接着可以看到read读取到了数据，如下（图 28-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps209.jpg" alt="img"></p>
<p>图 28-9</p>
<h1 id="第29章-信号驱动IO实验"><a href="#第29章-信号驱动IO实验" class="headerlink" title="第29章 信号驱动IO实验"></a>第29章 信号驱动IO实验</h1><p>本章节要讲解的信号驱动IO是最后一个IO模型，在第25章中我们已经对信号驱动IO有了基本的认识，本章节将对信号驱动IO进行深入的学习，最后通过相应的实验，来加深对信号驱动IO的理解。</p>
<h2 id="29-1-信号驱动IO简介"><a href="#29-1-信号驱动IO简介" class="headerlink" title="29.1 信号驱动IO简介"></a>29.1 信号驱动IO简介</h2><p>信号驱动IO不需要应用程序查询设备的状态，一旦设备准备就绪，会触发SIGIO信号，进而调用注册的处理函数。仍旧以钓鱼为例。小马同学喜欢吃新鲜的鱼，但是不想自己钓，所以他请了一个助手来帮他钓鱼，他自己去忙其他的事情（进程不阻塞，立即返回）。如果有鱼上钩助手会帮忙钓上来（将数据拷贝到指定的缓冲区），并立即通知小马同学回来把鱼取走（处理数据）。</p>
<p>如果要实现信号驱动IO，需要应用程序和驱动程序配合，应用程序使用信号驱动IO的步骤有三步：</p>
<p>步骤1 ：注册信号处理函数 应用程序使用signal函数来注册SIGIO信号的信号处理函数。</p>
<p>步骤2： 设置能够接收这个信号的进程</p>
<p>步骤3： 开启信号驱动IO 通常使用fcntl函数的F_SETFL命令打开FASYNC标志。</p>
<p>fcntl函数如下所示：</p>
<p>****函数原型****： </p>
<p>int fcntl(int fd,int cmd, …)</p>
<p>****函数功能****： </p>
<p>fcntl函数可以用来操作文件描述符</p>
<p><em><strong>*函数参数*</strong></em>:</p>
<p>fd: 被操作的文件描述符</p>
<p>cmd: 操作文件描述符的命令，cmd参数决定了要如何操作文件描述符fd</p>
<p>…: 根据cmd的参数来决定是不是需要使用第三个参数</p>
<p>操作文件描述符的命令如下表（表 29-1）所示：</p>
<table>
<thead>
<tr>
<th>命令名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>F_DUPFD</td>
<td>复制文件描述符</td>
</tr>
<tr>
<td>F_GETFD</td>
<td>获取文件描述符标志</td>
</tr>
<tr>
<td>F_SETFD</td>
<td>设置文件描述符标志</td>
</tr>
<tr>
<td>F_GETFL</td>
<td>获取文件状态标志</td>
</tr>
<tr>
<td>F_SETFL</td>
<td>设置文件状态标志</td>
</tr>
<tr>
<td>F_GETLK</td>
<td>获取文件锁</td>
</tr>
<tr>
<td>F_SETLK</td>
<td>设置文件锁</td>
</tr>
<tr>
<td>F_SETLKW</td>
<td>类似F_SETLK，但等待返回</td>
</tr>
<tr>
<td>F_GETOWN</td>
<td>获取当前接收SIGIO和SIGURG信号的进程ID和进程组ID</td>
</tr>
<tr>
<td>F_SETOWN</td>
<td>设置当前接收SIGIO和SIGURG信号的进程ID和进程组ID</td>
</tr>
</tbody></table>
<p>表 29-2</p>
<p>接下来学习驱动程序实现fasync方法</p>
<p>步骤1 </p>
<p>当应用程序开启信号驱动IO时，会触发驱动中的fasync函数。所以首先在file_operations结构体中实现fasync函数，函数原型如下：</p>
<p>int (*fasync) (int fd,struct file *filp,int on)</p>
<p>步骤2</p>
<p>在驱动中的fasync函数调用fasync_helper函数来操作fasync_struct结构体，fasync_helper函数原型如下：</p>
<p>int fasync_helper(int fd,struct file *filp,int on,struct fasync_struct **fapp)</p>
<p>步骤3：</p>
<p>当设备准备好的时候，驱动程序需要调用kill_fasync函数通知应用程序，此时应用程序的SIGIO信号处理函数就会被执行。kill_fasync负责发送指定的信号，函数原型如下：</p>
<p>void kill_fasync(struct fasync_struct **fp,int sig,int band)</p>
<p><em><strong>*函数参数：*</strong></em></p>
<p>fp: 要操作的fasync_struct</p>
<p>sig: 发送的信号</p>
<p>band: 可读的时候设置成POLLIN ，可写的时候设置成POLLOUT</p>
<h2 id="29-2-实验程序编写"><a href="#29-2-实验程序编写" class="headerlink" title="29.2 实验程序编写"></a>29.2 实验程序编写</h2><h3 id="29-2-1-编写测试-APP"><a href="#29-2-1-编写测试-APP" class="headerlink" title="29.2.1 编写测试 APP"></a>29.2.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\23\app。</p>
<p>编写应用程序write.c，在此代码中，调用write函数向&#x2F;dev&#x2F;test设备写入数据“nihao”。编写好的程序如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    char buf1[32] = &#123;0&#125;;   </span><br><span class="line">    char buf2[32] = &quot;nihao&quot;;</span><br><span class="line">    fd = open(&quot;/dev/test&quot;,O_RDWR);  //打开/dev/test设备</span><br><span class="line">    if (fd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;open error \n&quot;);</span><br><span class="line">        return fd;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;write before \n&quot;);</span><br><span class="line">    write(fd,buf2,sizeof(buf2));  //向/dev/test文件写入数据</span><br><span class="line">    printf(&quot;write after\n&quot;);</span><br><span class="line">    close(fd);     //关闭文件</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后来编写应用程序read.c，在此代码中要使用信号驱动IO读取数据。编写好的应用程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//SIGIO信号的信号处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> signum)</span></span><br><span class="line">&#123;</span><br><span class="line">    read(fd,buf1,<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;buf is %s\n&quot;</span>,buf1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">       fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开led驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signal(SIGIO,func);  <span class="comment">//步骤一：使用signal函数注册SIGIO信号的信号处理函数</span></span><br><span class="line">     <span class="comment">//步骤二：设置能接收这个信号的进程</span></span><br><span class="line">     <span class="comment">//fcntl函数用来操作文件描述符，</span></span><br><span class="line">     <span class="comment">//F_SETOWN 设置当前接收的SIGIO的进程ID</span></span><br><span class="line">     fcntl(fd,F_SETOWN,getpid()); </span><br><span class="line"></span><br><span class="line">    flags = fcntl(fd,F_GETFD); <span class="comment">//获取文件描述符标志</span></span><br><span class="line">    <span class="comment">//步骤三  开启信号驱动IO 使用fcntl函数的F_SETFL命令打开FASYNC标志</span></span><br><span class="line">    fcntl(fd,F_SETFL,flags| FASYNC);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);    </span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="29-2-2-驱动程序编写"><a href="#29-2-2-驱动程序编写" class="headerlink" title="29.2.2 驱动程序编写"></a>29.2.2 驱动程序编写</h3><p>本实验对应的驱动程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\23\module。</p>
<p>接下来编写驱动程序，在29.1小节中介绍了驱动程序中实现fasync方法的三个步骤，按照这个思路，依次实现这三步，编写好的驱动程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span>  flag;  <span class="comment">//标志位</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  </span><br><span class="line"></span><br><span class="line">DECLARE_WAIT_QUEUE_HEAD(read_wq); <span class="comment">//定义并初始化等待队列头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test_dev-&gt;flag=<span class="number">1</span>;</span><br><span class="line">    wake_up_interruptible(&amp;read_wq);</span><br><span class="line">    kill_fasync(&amp;test_dev-&gt;fasync,SIGIO,POLLIN);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span>(file-&gt;f_flags &amp; O_NONBLOCK )&#123;</span><br><span class="line">        <span class="keyword">if</span> (test_dev-&gt;flag !=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    &#125;</span><br><span class="line">    wait_event_interruptible(read_wq,test_dev-&gt;flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span>  <span class="type">__poll_t</span>  <span class="title function_">cdev_test_poll</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> poll_table_struct *p)</span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;  <span class="comment">//设置私有数据</span></span><br><span class="line">     <span class="type">__poll_t</span> mask=<span class="number">0</span>;    </span><br><span class="line">     poll_wait(file,&amp;read_wq,p);     <span class="comment">//应用阻塞</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (test_dev-&gt;flag == <span class="number">1</span>)    </span><br><span class="line">     &#123;</span><br><span class="line">         mask |= POLLIN;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> mask;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_fasync</span> <span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;  <span class="comment">//设置私有数据</span></span><br><span class="line">    <span class="keyword">return</span>  fasync_helper(fd,file,on,&amp;test_dev-&gt;fasync);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">    .poll = cdev_test_poll,  <span class="comment">//将poll字段指向chrdev_poll(...)函数</span></span><br><span class="line">    .fasync = cdev_test_fasync,   <span class="comment">//将fasync字段指向cdev_test_fasync(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="29-3-运行测试"><a href="#29-3-运行测试" class="headerlink" title="29.3 运行测试"></a>29.3 运行测试</h2><h3 id="29-3-1-编译程序"><a href="#29-3-1-编译程序" class="headerlink" title="29.3.1 编译程序"></a>29.3.1 编译程序</h3><p>在上一小节中的fasync.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m +=fasync.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放fasync.c.c和Makefile文件目录下，如下图（图 29-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps210.jpg" alt="img"> </p>
<p>图 29-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图29-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps211.jpg" alt="img"> </p>
<p>图 29-3</p>
<p>编译完生成fasync.ko目标文件，如下图（图 29-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps212.jpg" alt="img"> </p>
<p>图 29-4</p>
<p>至此驱动模块就编译成功了，下面进行交叉编译应用程序。</p>
<h3 id="29-3-2-编译应用程序"><a href="#29-3-2-编译应用程序" class="headerlink" title="29.3.2 编译应用程序"></a>29.3.2 编译应用程序</h3><p>来到存放应用程序read.c和write.c的文件夹下，使用以下命令对read.c和write.c进行交叉编译，编译完成如下图（图 29-5）所示：</p>
<p>aarch64-linux-gnu-gcc -o read read.c -static</p>
<p>aarch64-linux-gnu-gcc -o write write.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps213.jpg" alt="img"> </p>
<p>图 29-5</p>
<p>生成的read write文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="29-3-3-测试"><a href="#29-3-3-测试" class="headerlink" title="29.3.3 测试"></a>29.3.3 测试</h3><p>输入以下命令加载驱动程序。</p>
<p>insmod fasync.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps214.jpg" alt="img"></p>
<p>图 29-6</p>
<p>输入以下命令运行read应用程序，如下图（图 29-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps215.jpg" alt="img"></p>
<p>图 29-7</p>
<p>然后输入以下命令运行write应用程序，如下图（图 29-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps216.jpg" alt="img"></p>
<p>图 29-8</p>
<p>如下图（图29-9）所示，read程序窗口打印读取的数据。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps217.jpg" alt="img"></p>
<p>图 29-9</p>
<h1 id="第30章-定时器实验"><a href="#第30章-定时器实验" class="headerlink" title="第30章 定时器实验"></a>第30章 定时器实验</h1><p>在Linux内核中很多函数是基于定时器进行驱动的，所以时间管理在内核中占有非常重要的地位。本小节将对Linux中的时间管理相关知识进行学习.</p>
<h2 id="30-1-Linux定期器"><a href="#30-1-Linux定期器" class="headerlink" title="30.1 Linux定期器"></a>30.1 Linux定期器</h2><p>硬件为内核提供了一个系统定时器来计算流逝的时间（即基于未来时间点的计时方式，以当前时刻为计时开始的起点，以未来的某一时刻为计时的终点），内核只有在系统定时器的帮助下才能计算和管理时间，但是内核定时器的精度并不高，所以不能作为高精度定时器使用。并且内核定时器的运行没有周期性，到达计时终点后会自动关闭。如果要实现周期性定时，就要在定时处理函数中重新开启定时器。</p>
<p>Linux内核中使用timer_list 结构体表示内核定时器，该结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;timer.h”文件中，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct timer_list &#123;</span><br><span class="line">    struct hlist_node   entry;</span><br><span class="line">    unsigned long       expires;/* 定时器超时时间，单位是节拍数 */</span><br><span class="line">    void            (*function)(struct timer_list *);/* 定时处理函数 */</span><br><span class="line">    u32         flags;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_LOCKDEP</span><br><span class="line">    struct lockdep_map  lockdep_map;</span><br><span class="line">#endif</span><br><span class="line">    ANDROID_KABI_RESERVE(1);</span><br><span class="line">    ANDROID_KABI_RESERVE(2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用以下宏对timer_list结构体进行定义，_name为定义的结构体名称，_function为定时处理函数，该宏同样定义在文件 “内核源码&#x2F;include&#x2F;linux&#x2F;timer.h”文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_TIMER(_name, _function)              \</span></span><br><span class="line"><span class="meta">struct timer_list _name =               \</span></span><br><span class="line"><span class="meta">    __TIMER_INITIALIZER(_function, 0)     </span></span><br></pre></td></tr></table></figure>

<p>例如可以使用以下代码对定时器和相应的定时处理函数进行定义 </p>
<p>DEFINE_TIMER(timer_test,function_test);&#x2F;&#x2F;定义一个定时器</p>
<p>定时器定义完成之后还需要通过一系列的 API 函数来初始化此定时器，部分函数说明如下(表30-1)所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void add_timer(struct timer_list *timer)</td>
<td>向 Linux 内核注册定时器，使用 add_timer 函数向内核注册定时器以后，定时器就会开始运行</td>
</tr>
<tr>
<td>int del_timer(struct timer_list * timer)</td>
<td>删除一个定时器</td>
</tr>
<tr>
<td>int mod_timer(struct timer_list *timer,unsigned long expires)</td>
<td>修改定时值，如果定时器还没有激活的话，mod_timer 函数会激活定时器</td>
</tr>
</tbody></table>
<p>表 	30-1</p>
<p>在使用add_timer()函数向 Linux 内核注册定时器之前，还需要设置定时时间，定时时间由timer_list结构体中的expires参数所确定，单位为节拍数，可以通过图形化界面设置系统节拍的频率，具体路径如下图(图 30-2)所示：</p>
<p>-&gt; Kernel Features</p>
<p>-&gt; Timer frequency (<choice> [&#x3D;y])</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps218.jpg" alt="img"> </p>
<p>图 30-2</p>
<p>​	从上图可以看出可选的系统节拍率为 100Hz、250Hz、300Hz和 1000Hz，默认情况下选择 300Hz。</p>
<p>通过全局变量jiffies来记录自系统启动以来产生节拍的总数。启动时，内核将该变量初始化为0，此后，每次时钟中断处理程序都会增加该变量的值，一秒内jiffes增加的值为设置的系统节拍数，该变量定义在”内核源码&#x2F;include&#x2F;linux&#x2F;jiffies.h”文件中（timer.h文件中已经包含，不需要重复引用），具体定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern u64 __cacheline_aligned_in_smp jiffies_64;</span><br><span class="line">extern unsigned long volatile __cacheline_aligned_in_smp __jiffy_arch_data jiffies;</span><br></pre></td></tr></table></figure>

<p>​	其中jiffies_64用于64位系统，而jiffies用于 32 位系统。为了方便开发，Linux 内核还提供了几个jiffies和ms、us、ns之间的转换函数，如下(表 30-2)所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>int jiffies_to_msecs(const unsigned long j)</td>
<td>将 jiffies 类型的参数 j 分别转换为对应的毫秒</td>
</tr>
<tr>
<td>int jiffies_to_usecs(const unsigned long j)</td>
<td>将 jiffies 类型的参数 j 分别转换为对应的微秒</td>
</tr>
<tr>
<td>u64 jiffies_to_nsecs(const unsigned long j)</td>
<td>将 jiffies 类型的参数 j 分别转换为对应的纳秒</td>
</tr>
<tr>
<td>long msecs_to_jiffies(const unsigned int m)</td>
<td>将毫秒转换为 jiffies 类型</td>
</tr>
<tr>
<td>long usecs_to_jiffies(const unsigned int u)</td>
<td>将微秒转换为 jiffies 类型</td>
</tr>
<tr>
<td>unsigned long nsecs_to_jiffies(u64 n)</td>
<td>将纳秒转换为 jiffies 类型</td>
</tr>
</tbody></table>
<p>表 30-3</p>
<p>​	例如可以使用以下命令进行3秒钟的定时：</p>
<p>timer_test.expires &#x3D; jiffies_64 +msecs_to_jiffies(3000) </p>
<p>至此关于Linux定时器相关的知识就讲解完成了，在下个小节中将进行相应的实验。</p>
<h2 id="30-2-实验程序编写"><a href="#30-2-实验程序编写" class="headerlink" title="30.2 实验程序编写"></a>30.2 实验程序编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\24\module。</p>
<p>本实验将实现五秒钟的计时，五秒钟之后将打印“this is function test”相关字符，为了实现循环打印还需要在定时处理函数中使用mod_timer函数重新设置定时时间。</p>
<p> 编写好的驱动程序timer_mod.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">function_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span>;<span class="comment">//定义function_test定时功能函数</span></span><br><span class="line">DEFINE_TIMER(timer_test,function_test);<span class="comment">//定义一个定时器</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">function_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;this is function test \n&quot;</span>);</span><br><span class="line">	mod_timer(&amp;timer_test,jiffies_64 + msecs_to_jiffies(<span class="number">5000</span>));<span class="comment">//使用mod_timer函数将定时时间设置为五秒后</span></span><br><span class="line">&#125;	</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_mod_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">	timer_test.expires = jiffies_64 + msecs_to_jiffies(<span class="number">5000</span>);<span class="comment">//将定时时间设置为五秒后</span></span><br><span class="line">	add_timer(&amp;timer_test);<span class="comment">//添加一个定时器</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_mod_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">	del_timer(&amp;timer_test);<span class="comment">//删除一个定时器</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_mod_init);</span><br><span class="line">module_exit(timer_mod_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="30-3-运行测试"><a href="#30-3-运行测试" class="headerlink" title="30.3 运行测试"></a>30.3 运行测试</h2><h3 id="30-3-1-编译驱动程序"><a href="#30-3-1-编译驱动程序" class="headerlink" title="30.3.1 编译驱动程序"></a>30.3.1 编译驱动程序</h3><p>在上一小节中的timer_mod.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m += timer_mod.o    #此处要和你的驱动源文件同名</span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    #make操作</span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    #make clean操作</span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放timer_mod.c和Makefile文件目录下，如下图()所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps219.jpg" alt="img"> </p>
<p>图 30-4</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图30-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps220.jpg" alt="img"> </p>
<p>图30-5</p>
<p>编译完生成 timer_mod.ko目标文件，如下图（图 30-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps221.jpg" alt="img"> </p>
<p>图 30-6</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="30-3-2-运行测试"><a href="#30-3-2-运行测试" class="headerlink" title="30.3.2 运行测试"></a>30.3.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 30-7）所示：</p>
<p>insmod timer_mod.ko </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps222.jpg" alt="img"> </p>
<p>图 30-7</p>
<p>可以看到驱动加载之后，每隔五秒钟会打印“this is function test”相关打印，证明编写的驱动程序没有问题，最后使用以下命令卸载相应的驱动，如下图（图30-8）所示：</p>
<p>rmmod timer_mod.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps223.jpg" alt="img"> </p>
<p>图 30-8</p>
<h1 id="第31章-秒字符设备驱动实验"><a href="#第31章-秒字符设备驱动实验" class="headerlink" title="第31章 秒字符设备驱动实验"></a>第31章 秒字符设备驱动实验</h1><p>本章节将实现秒字符设备驱动，以此对之前学习到的知识进行巩固。本章节实验要实现的任务如下：</p>
<p>\1. 实现字符设备驱动框架，自动生成设备节点。</p>
<p>\2. 根据上一小节学到的知识，实现秒计时。</p>
<p>\3. 通过原子变量来记录递增的秒数，避免竞争的发生。</p>
<p>\4. 通过用户空间和内核空间的数据交换，将记录的秒数传递到应用空间，并通过应用程序打印出来。</p>
<h2 id="31-1-实验程序编写"><a href="#31-1-实验程序编写" class="headerlink" title="31.1 实验程序编写"></a>31.1 实验程序编写</h2><h3 id="31-1-1-编写测试-APP"><a href="#31-1-1-编写测试-APP" class="headerlink" title="31.1.1 编写测试 APP"></a>31.1.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\25\app。</p>
<p>首先来编写应用测试代码timer.c，在此代码中每隔一秒钟打印从用户空间传递来的秒数，具体代码内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符fd</span></span><br><span class="line">	<span class="type">int</span> count;<span class="comment">//定义int类型记录秒数的变量count</span></span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR);<span class="comment">//使用open()函数以可读可写的方式打开设备文件</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		read(fd,&amp;count,<span class="keyword">sizeof</span>(count));<span class="comment">//使用read函数读取内核传递来的秒数</span></span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;num is %d\n&quot;</span>,count);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="31-1-2-驱动程序编写"><a href="#31-1-2-驱动程序编写" class="headerlink" title="31.1.2 驱动程序编写"></a>31.1.2 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\25\module。</p>
<p> 编写好的驱动程序timer_dev.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">	<span class="type">int</span> sec; <span class="comment">//秒</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">atomic64_t</span> v = ATOMIC_INIT(<span class="number">0</span>);<span class="comment">//定义原子类型变量v，并定义为0</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">function_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span>;<span class="comment">//定义function_test定时功能函数</span></span><br><span class="line">DEFINE_TIMER(timer_test,function_test);<span class="comment">//定义一个定时器</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">function_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span></span><br><span class="line">&#123;</span><br><span class="line">	atomic64_inc(&amp;v);<span class="comment">//原子变量v自增</span></span><br><span class="line">	dev1.sec = <span class="type">atomic_read</span>(&amp;v);<span class="comment">//将读取到的原子变量v,赋值给sec</span></span><br><span class="line">	<span class="comment">//printk(&quot;the sec is %d\n&quot;,dev1.sec);</span></span><br><span class="line">	mod_timer(&amp;timer_test,jiffies_64 + msecs_to_jiffies(<span class="number">1000</span>));<span class="comment">//使用mod_timer函数将定时时间设置为一秒后</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">	add_timer(&amp;timer_test);	<span class="comment">//添加一个定时器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(copy_to_user(buf,&amp;dev1.sec,<span class="keyword">sizeof</span>(dev1.sec)))&#123;<span class="comment">//使用copy_to_user函数将sec传递到应用层</span></span><br><span class="line">		printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	del_timer(&amp;timer_test);<span class="comment">//删除一个定时器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_dev_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  	dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_dev_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_dev_init);</span><br><span class="line">module_exit(timer_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="31-2-运行测试"><a href="#31-2-运行测试" class="headerlink" title="31.2 运行测试"></a>31.2 运行测试</h2><h3 id="31-2-1-编译驱动程序"><a href="#31-2-1-编译驱动程序" class="headerlink" title="31.2.1 编译驱动程序"></a>31.2.1 编译驱动程序</h3><p>在上一小节中的timer_dev.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += timer_dev.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放timer_dev.c和Makefile文件目录下，如下图（图31-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps224.jpg" alt="img"> </p>
<p>图31-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 31-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps225.jpg" alt="img"> </p>
<p>图 31-2</p>
<p>编译完生成 timer_dev.ko目标文件，如下图（图 31-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps226.jpg" alt="img"> </p>
<p>图 31-3</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="31-2-2-编译应用程序"><a href="#31-2-2-编译应用程序" class="headerlink" title="31.2.2 编译应用程序"></a>31.2.2 编译应用程序</h3><p>然后来到存放应用程序timer.c的文件夹下，使用以下命令对timer.c进行交叉编译，编译完成如下图（图 31-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o timer timer.c</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps227.jpg" alt="img"> </p>
<p>图 31-4</p>
<p>生成的timer文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="31-2-3-运行测试"><a href="#31-2-3-运行测试" class="headerlink" title="31.2.3 运行测试"></a>31.2.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 31-5）所示：</p>
<p>insmod timer_dev.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps228.jpg" alt="img"> </p>
<p>图 31-5</p>
<p>然后输入以下命令进行可执行程序的运行，如下图（图 31-6）所示：</p>
<p>.&#x2F;timer</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps229.jpg" alt="img"> </p>
<p>图 31-6</p>
<p>可以看到每隔一秒钟就会打印由内核空间传递来的秒数，我们要实现的任务就完成了，最后使用以下命令卸载对应的驱动，如下图（图 31-7）所示：</p>
<p>rmmod timer_dev</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps230.jpg" alt="img"> </p>
<p>图 31-7</p>
<p>第32章 Linux内核打印实验 </p>
<p>本手册的实验都是在buildroot系统上完成的，由于buildroot系统已经设置了相应的打印等级，所以驱动的相关打印都能正常显示在串口终端上，如果将实验系统换成了ubuntu，然后加载同样的驱动，会发现打印信息不见了，这一现象的基本原因就是内核打印等级不同，那打印等级是如何修改的呢，查看打印等级的方式又有哪些呢，就让我们进入本章节的学习吧！</p>
<h2 id="32-1-方法一：dmseg-命令"><a href="#32-1-方法一：dmseg-命令" class="headerlink" title="32.1 方法一：dmseg 命令"></a>32.1 方法一：dmseg 命令</h2><p>在终端使用dmseg命令可以获取内核打印信息，该命令的具体使用方法如下所示：</p>
<p>dmesg命令</p>
<p>****英文全称：****display message（显示信息）</p>
<p><em><strong>*作用*</strong></em>****：****kernel 会将打印信息存储在 ring <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=buffer&spm=1001.2101.3001.7020">buffer</a> 中。可以利用 dmesg命令来查看内核打印信息。。</p>
<p><em><strong>*常用参数:*</strong></em></p>
<p>-C，–clear清除内核环形缓冲区</p>
<p>-c，—-read-clear读取并清除所有消息</p>
<p>-T，–显示时间戳</p>
<p>****提示：****dmesg命令也可以与grep命令组合使用。如查找待用usb关键字的打印信息，就可以使用如下命令:dmseg | grep usb</p>
<p>首先在串口终端使用“dmseg”命令，可以看见相应的内核打印信息已经加载了出来，如下图（图 32-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps231.jpg" alt="img"> </p>
<p>图 32-1</p>
<p>然后使用以下组合命令查找nfs相关的打印信息，如下图（图 32-2）所示：</p>
<p>dmesg | grep nfs</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps232.jpg" alt="img"> </p>
<p>图 32-2</p>
<p>至此关于dmesg命令就讲解演示完成了。</p>
<h2 id="32-2-方法二：查看kmsg文件"><a href="#32-2-方法二：查看kmsg文件" class="headerlink" title="32.2 方法二：查看kmsg文件"></a>32.2 方法二：查看kmsg文件</h2><p>内核所有的打印信息都会输出到循环缓冲区 ‘log_buf’，为了能够方便的在用户空间读取 内核打印信息，Linux内核驱动将该循环缓冲区映射到了&#x2F;proc目录下的文件节点kmsg。通过 cat或者其他应用程序读取Log Buffer的时候可以不断的等待新的log，所以访问&#x2F;proc&#x2F;kmsg 的方式适合长时间的读取log，一旦有新的log就可以被打印出来。</p>
<p>首先使用以下命令读取kmsg文件，在没有新的内核打印信息时会阻塞，如下图（图 32-3）所示：</p>
<p>cat &#x2F;proc&#x2F;kmsg</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps233.jpg" alt="img"> </p>
<p>图 32-3</p>
<p>然后在该设备的其他终端加载任意有打印信息的驱动文件（这里使用的是ssh），如下图（图 32-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps234.jpg" alt="img"> </p>
<p>图 32-4</p>
<p>在串口终端中可以看到对应驱动的打印信息就被打印了出来，如下图（图 32-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps235.jpg" alt="img"> </p>
<p>图 32-5</p>
<h2 id="32-3-方法三：调整内核打印等级"><a href="#32-3-方法三：调整内核打印等级" class="headerlink" title="32.3 方法三：调整内核打印等级"></a>32.3 方法三：调整内核打印等级</h2><p>内核的日志打印由相应的打印等级来控制，可以通过调整内核打印等级来控制打印日志的输出。使用以下命令查看当前默认打印等级，如下图（图 32-6）所示:</p>
<p>cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;printk</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps236.jpg" alt="img"> </p>
<p>图 32-6</p>
<p>可以看到内核打印等级由四个数字所决定，“7 4 1 7” 分别对应console_loglevel、default_message_loglevel、minimum_c onsole_loglevel、default_console_loglevel，具体类型说明如下表（表 32-7）所示：</p>
<table>
<thead>
<tr>
<th>终端打印类型</th>
<th>对应类型说明</th>
</tr>
</thead>
<tbody><tr>
<td>console_loglevel</td>
<td>只有当printk打印消息的log优先级高于console_loglevel时，才能输出到终端上</td>
</tr>
<tr>
<td>default_message_loglevel</td>
<td>printk打印消息时默认的log等级</td>
</tr>
<tr>
<td>minimum_console_loglevel</td>
<td>console_loglevel可以被设置的最小值</td>
</tr>
<tr>
<td>default_console_loglevel</td>
<td>console_loglevel的缺省值</td>
</tr>
</tbody></table>
<p>表 32-7</p>
<p>上面的“7 4 1 7”意味着只有优先级高于KERN_DEBUG(7)的打印消息才能输出到终端，在“内核源码&#x2F;include&#x2F;linux&#x2F;kern_levels.h”文件中对于文件打印等级进行了如下打印等级定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_EMERG  KERN_SOH <span class="string">&quot;0&quot;</span>    <span class="comment">/* system is unusable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ALERT  KERN_SOH <span class="string">&quot;1&quot;</span>    <span class="comment">/* action must be taken immediately */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_CRIT   KERN_SOH <span class="string">&quot;2&quot;</span>    <span class="comment">/* critical conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ERR    KERN_SOH <span class="string">&quot;3&quot;</span>    <span class="comment">/* error conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_WARNING    KERN_SOH <span class="string">&quot;4&quot;</span>    <span class="comment">/* warning conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_NOTICE KERN_SOH <span class="string">&quot;5&quot;</span>    <span class="comment">/* normal but significant condition */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_INFO   KERN_SOH <span class="string">&quot;6&quot;</span>    <span class="comment">/* informational */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_DEBUG  KERN_SOH <span class="string">&quot;7&quot;</span>    <span class="comment">/* debug-level messages */</span></span></span><br></pre></td></tr></table></figure>

<p>printk在打印信息前，可以加入相应的打印等级宏定义，具体格式如下所示：</p>
<p>printk(打印等级 “打印信息”)</p>
<p>接下来将使用以下驱动例程进行实际的打印等级测试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot; 0000 KERN_EMERG\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot; 1111 KERN_ALERT\n&quot;</span>);</span><br><span class="line">    printk(KERN_CRIT <span class="string">&quot; 2222 KERN_CRIT\n&quot;</span>);</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot; 3333 KERN_ERR\n&quot;</span>);</span><br><span class="line">    printk(KERN_WARNING <span class="string">&quot; 4444 KERN_WARNING\n&quot;</span>);</span><br><span class="line">    printk(KERN_NOTICE <span class="string">&quot; 5555 KERN_NOTICE\n&quot;</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot; 6666 KERN_INFO\n&quot;</span>);</span><br><span class="line">    printk(KERN_DEBUG <span class="string">&quot; 7777 KERN_DEBUG\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot; 8888 no_fix\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);</span><br><span class="line">module_exit(helloworld_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>加载该驱动之后，第5-11行0-6等级的打印信息就被打印了出来，第13行由于没有设置打印等级，所以会被赋予默认打印等级4，高于console_loglevel打印等级，所以也会被打印出来，最后只有第12行打印等级为7的信息，和console_loglevel打印等级相同，所以不会被打印出来，如下图（图 32-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps237.jpg" alt="img"> </p>
<p>图 32-8</p>
<p>然后使用以下命令将console_loglevel打印等级设置为4，如下图（图 32-9）所示：</p>
<p>echo 4 4 1 7 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;printk</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps238.jpg" alt="img"> </p>
<p>图 32-9</p>
<p>卸载驱动之后，再一次加载驱动，发现只有打印等级高于4的相关信息被打印了出来，如下图（图32-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps239.jpg" alt="img"> </p>
<p>图32-10</p>
<p>至此关于内核打印等级的实验就结束了。</p>
<h1 id="第33章llseek定位设备驱动实验"><a href="#第33章llseek定位设备驱动实验" class="headerlink" title="第33章llseek定位设备驱动实验"></a>第33章llseek定位设备驱动实验</h1><p>相信经过了前面章节的学习，大家已经对内核空间与用户空间的数据交互很是熟悉，但在之前的例子中都是对字符串的全部内容进行读写，假如现在有这样一个场景，将两个字符串依次进行写入，并对写入完成的字符串进行读取，如果仍采用之前的方式，第二次的写入值会覆盖第一次写入值，那要如何来实现上述功能呢？这就要轮到llseek出场了。</p>
<h2 id="33-1-定位设备llseek"><a href="#33-1-定位设备llseek" class="headerlink" title="33.1 定位设备llseek"></a>33.1 定位设备llseek</h2><h3 id="33-1-1-lseek函数的使用"><a href="#33-1-1-lseek函数的使用" class="headerlink" title="33.1.1 lseek函数的使用"></a>33.1.1 lseek函数的使用</h3><p>在应用程序中使用lseek函数进行读写位置的调整，该函数的具体使用说明如下所示：</p>
<p>lseek函数</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>​    off_t lseek(int fd, off_t offset, int whence);</p>
<p>****头文件****：</p>
<p>​    #include &lt;sys&#x2F;types.h&gt;</p>
<p>​    #include &lt;unistd.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>移动文件的读写位置。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>fd:	文件描述符；</p>
<p>off_t offset:	偏移量，单位是字节的数量，可以正负，如果是负值表示向前移动；如果是正值，表示向后移动。</p>
<p>whence：当前位置的基点，可以使用以下三组值。</p>
<p>​				SEEK_SET：相对于文件开头</p>
<p>​				SEEK_CUR:相对于当前的文件读写指针位置</p>
<p>​				SEEK_END:相对于文件末尾</p>
<p>****函数返回值：****成功返回当前位移大小，失败返回-1</p>
<p>函数使用示例：</p>
<p>把文件位置指针设置为5：	</p>
<p>lseek(fd,5,SEEK_SET);</p>
<p>把文件位置设置成文件末尾： </p>
<p>  lseek(fd,0,SEEK_END);</p>
<p>确定当前的文件位置：		</p>
<p>​	 lseek(fd,0,SEEK_CUR);</p>
<h3 id="33-1-2-驱动程序的完善"><a href="#33-1-2-驱动程序的完善" class="headerlink" title="33.1.2 驱动程序的完善"></a>33.1.2 驱动程序的完善</h3><p>上一小节中讲解的lseek函数如果要对设备文件生效，还需要完善相应的驱动程序。lseek函数会调用file_operation结构体中的llseek接口，所以需要对驱动中的llseek函数进行填充，并且完善read和write函数中偏移相关的部分。</p>
<p>下面对相关API接口函数进行填充：</p>
<p><em><strong>*llseek函数完善：*</strong></em></p>
<p>llseek填充完成的函数如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">loff_t</span> <span class="title function_">cdev_test_llseek</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">loff_t</span> offset, <span class="type">int</span> whence)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">loff_t</span> new_offset;<span class="comment">//定义loff_t类型的新的偏移值</span></span><br><span class="line">	<span class="keyword">switch</span>(whence)<span class="comment">//对lseek函数传递的whence参数进行判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> SEEK_SET:</span><br><span class="line">			<span class="keyword">if</span>(offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(offset &gt; BUFSIZE)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;	</span><br><span class="line">			&#125;</span><br><span class="line">			new_offset = offset;<span class="comment">//如果whence参数为SEEK_SET，则新偏移值为offset</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SEEK_CUR:</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &gt; BUFSIZE)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            new_offset = file-&gt;f_pos + offset;<span class="comment">//如果whence参数为SEEK_CUR，则新偏移值为file-&gt;f_pos + offset，file-&gt;f_pos为当前的偏移值</span></span><br><span class="line">			<span class="keyword">break</span>;			</span><br><span class="line">		<span class="keyword">case</span> SEEK_END:</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            new_offset = BUFSIZE + offset;<span class="comment">//如果whence参数为SEEK_END，则新偏移值为BUFSIZE + offset，BUFSIZE为最大偏移量</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	file-&gt;f_pos = new_offset;<span class="comment">//更新file-&gt;f_pos偏移值</span></span><br><span class="line">	<span class="keyword">return</span> new_offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第4行使用switch语句对传递的whence参数进行判断，whence在这里可以有三个取值，分别为SEEK_SET、SEEK_CUR和SEEK_END。</p>
<p>在6-16、17-28、29-38行代码中，分别对三个参数所代表的功能进行实现，其中需要注意的是file-&gt;f_pos指的是当前文件的偏移值。</p>
<p>在第40行和41行分别对f_pos偏移值进行更新，对新的偏移值进行返回。</p>
<p><em><strong>*read接口函数完善：*</strong></em></p>
<p>填充完成的read接口函数如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">loff_t</span> p = *off;<span class="comment">//将读取数据的偏移量赋值给loff_t类型变量p</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">size_t</span> count = size;</span><br><span class="line">	<span class="keyword">if</span>(p &gt; BUFSIZE)&#123;<span class="comment">//如果当前偏移值比最大偏移量大则返回错误</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(count &gt; BUFSIZE - p)&#123;</span><br><span class="line">		count  = BUFSIZE - p;<span class="comment">//如果要读取的偏移值超出剩余的空间，则读取到最后位置</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(copy_to_user(buf,mem+p,count))&#123;<span class="comment">//将mem中的值写入buf，并传递到用户空间</span></span><br><span class="line">		printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">		printk(<span class="string">&quot;buf[%d] is %c\n&quot;</span>,i,mem[i]);<span class="comment">//将mem中的值打印出来</span></span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;mem is %s,p is %llu,count is %d\n&quot;</span>,mem+p,p,count);</span><br><span class="line">	*off = *off + count;<span class="comment">//更新偏移值</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相较于之前的read接口函数，在第7行和第10行分别加入了对偏移值p和读取数量进行判定，在第13行通过偏移值p进行内核空间和用户空间数据的传递，最后在第21行对偏移值进行更新。</p>
<p><em><strong>*write接口函数完善：*</strong></em></p>
<p>write接口函数的完善和read接口函数相似，填充完成的write接口函数如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">loff_t</span> p = *off;<span class="comment">//将写入数据的偏移量赋值给loff_t类型变量p</span></span><br><span class="line">    <span class="type">size_t</span> count = size;</span><br><span class="line">    <span class="keyword">if</span>(p &gt; BUFSIZE)&#123;<span class="comment">//如果当前偏移值比最大偏移量大则返回错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &gt; BUFSIZE - p)&#123;</span><br><span class="line">        count  = BUFSIZE - p;<span class="comment">//如果要写入的偏移值超出剩余的空间，则写入到最后位置</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(copy_from_user(mem+p,buf,count))&#123;<span class="comment">//将buf中的值，从用户空间传递到内核空间</span></span><br><span class="line"> 		printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	printk(<span class="string">&quot;mem is %s,p is %llu\n&quot;</span>,mem+p,p);<span class="comment">//打印写入的值</span></span><br><span class="line">	*off = *off + count;<span class="comment">//更新偏移值</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相较于之前的write接口函数，在第7行和第10行分别加入了对偏移值p和读取数量进行判定，在第13行通过偏移值p进行内核空间和用户空间数据的传递，最后在第18行对偏移值进行更新。</p>
<p>至此，关于定位设备相关的API接口函数就都填充完成了，将在下一小节进行定位设备驱动实验代码的编写。</p>
<h2 id="33-2-实验程序编写"><a href="#33-2-实验程序编写" class="headerlink" title="33.2 实验程序编写"></a>33.2 实验程序编写</h2><h3 id="33-2-1-编写测试-APP"><a href="#33-2-1-编写测试-APP" class="headerlink" title="33.2.1 编写测试 APP"></a>33.2.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\26\app。</p>
<p>首先来编写应用测试代码llseek.c，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型文件描述符</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> off;<span class="comment">//定义读写偏移位置</span></span><br><span class="line">	<span class="type">char</span> readbuf[<span class="number">13</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区readbuf</span></span><br><span class="line">	<span class="type">char</span> readbuf1[<span class="number">19</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区readbuf1</span></span><br><span class="line"></span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR,<span class="number">666</span>);<span class="comment">//打开/dev/test设备</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	write(fd,<span class="string">&quot;hello world&quot;</span>,<span class="number">13</span>);<span class="comment">//向fd写入数据hello world</span></span><br><span class="line">	off = lseek(fd,<span class="number">0</span>,SEEK_CUR);<span class="comment">//读取当前位置的偏移量</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">    off = lseek(fd,<span class="number">0</span>,SEEK_SET);<span class="comment">//将偏移量设置为0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">	read(fd,readbuf,<span class="keyword">sizeof</span>(readbuf));<span class="comment">//将写入的数据读取到readbuf缓冲区</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;read is %s\n&quot;</span>,readbuf);</span><br><span class="line"></span><br><span class="line">    off = lseek(fd,<span class="number">0</span>,SEEK_CUR);<span class="comment">//读取当前位置的偏移量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">	off = lseek(fd,<span class="number">-1</span>,SEEK_CUR);<span class="comment">//将当前位置的偏移量向前挪动一位</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">    write(fd,<span class="string">&quot;Linux&quot;</span>,<span class="number">6</span>);<span class="comment">//向fd写入数据Linux</span></span><br><span class="line">    off = lseek(fd,<span class="number">0</span>,SEEK_CUR);<span class="comment">//读取当前位置的偏移量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">    off = lseek(fd,<span class="number">0</span>,SEEK_SET);<span class="comment">//将偏移量设置为0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">    read(fd,readbuf1,<span class="keyword">sizeof</span>(readbuf1));<span class="comment">//将写入的数据读取到readbuf1缓冲区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read is %s\n&quot;</span>,readbuf1);</span><br><span class="line"></span><br><span class="line">    off = lseek(fd,<span class="number">0</span>,SEEK_CUR);<span class="comment">//读取当前位置的偏移量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="33-2-2-驱动程序编写"><a href="#33-2-2-驱动程序编写" class="headerlink" title="33.2.2 驱动程序编写"></a>33.2.2 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\26\module。</p>
<p> 编写好的驱动程序llseek.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024<span class="comment">//设置最大偏移量为1024</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> mem[BUFSIZE] = &#123;<span class="number">0</span>&#125;;<span class="comment">//设置数据存储数组mem</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">loff_t</span> p = *off;<span class="comment">//将读取数据的偏移量赋值给loff_t类型变量p</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">size_t</span> count = size;</span><br><span class="line">	<span class="keyword">if</span>(p &gt; BUFSIZE)&#123;<span class="comment">//如果当前偏移值比最大偏移量大则返回错误</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(count &gt; BUFSIZE - p)&#123;</span><br><span class="line">		count  = BUFSIZE - p;<span class="comment">//如果要读取的偏移值超出剩余的空间，则读取到最后位置</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(copy_to_user(buf,mem+p,count))&#123;<span class="comment">//将mem中的值写入buf，并传递到用户空间</span></span><br><span class="line">		printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">		printk(<span class="string">&quot;buf[%d] is %c\n&quot;</span>,i,mem[i]);<span class="comment">//将mem中的值打印出来</span></span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;mem is %s,p is %llu,count is %d\n&quot;</span>,mem+p,p,count);</span><br><span class="line">	*off = *off + count;<span class="comment">//更新偏移值</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">loff_t</span> p = *off;<span class="comment">//将写入数据的偏移量赋值给loff_t类型变量p</span></span><br><span class="line">    <span class="type">size_t</span> count = size;</span><br><span class="line">    <span class="keyword">if</span>(p &gt; BUFSIZE)&#123;<span class="comment">//如果当前偏移值比最大偏移量大则返回错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &gt; BUFSIZE - p)&#123;</span><br><span class="line">        count  = BUFSIZE - p;<span class="comment">//如果要写入的偏移值超出剩余的空间，则写入到最后位置</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(copy_from_user(mem+p,buf,count))&#123;<span class="comment">//将buf中的值，从用户空间传递到内核空间</span></span><br><span class="line"> 		printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	printk(<span class="string">&quot;mem is %s,p is %llu\n&quot;</span>,mem+p,p);<span class="comment">//打印写入的值</span></span><br><span class="line">	*off = *off + count;<span class="comment">//更新偏移值</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">loff_t</span> <span class="title function_">cdev_test_llseek</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">loff_t</span> offset, <span class="type">int</span> whence)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">loff_t</span> new_offset;<span class="comment">//定义loff_t类型的新的偏移值</span></span><br><span class="line">	<span class="keyword">switch</span>(whence)<span class="comment">//对lseek函数传递的whence参数进行判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> SEEK_SET:</span><br><span class="line">			<span class="keyword">if</span>(offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(offset &gt; BUFSIZE)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;	</span><br><span class="line">			&#125;</span><br><span class="line">			new_offset = offset;<span class="comment">//如果whence参数为SEEK_SET，则新偏移值为offset</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SEEK_CUR:</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &gt; BUFSIZE)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            new_offset = file-&gt;f_pos + offset;<span class="comment">//如果whence参数为SEEK_CUR，则新偏移值为file-&gt;f_pos + offset，file-&gt;f_pos为当前的偏移值</span></span><br><span class="line">			<span class="keyword">break</span>;			</span><br><span class="line">		<span class="keyword">case</span> SEEK_END:</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            new_offset = BUFSIZE + offset;<span class="comment">//如果whence参数为SEEK_END，则新偏移值为BUFSIZE + offset，BUFSIZE为最大偏移量</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	file-&gt;f_pos = new_offset;<span class="comment">//更新file-&gt;f_pos偏移值</span></span><br><span class="line">	<span class="keyword">return</span> new_offset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">	.llseek = cdev_test_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_dev_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  	dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_dev_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_dev_init);</span><br><span class="line">module_exit(timer_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="33-3-运行测试"><a href="#33-3-运行测试" class="headerlink" title="33.3 运行测试"></a>33.3 运行测试</h2><h3 id="33-3-1-编译驱动程序"><a href="#33-3-1-编译驱动程序" class="headerlink" title="33.3.1 编译驱动程序"></a>33.3.1 编译驱动程序</h3><p>在上一小节中的llseek.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += llseek.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放llseek.c和Makefile文件目录下，如下图（图 33-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps240.jpg" alt="img"> </p>
<p>图 33-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 33-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps241.jpg" alt="img"> </p>
<p>图 33-2</p>
<p>编译完生成 llseek.ko目标文件，如下图（图 33-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps242.jpg" alt="img"> </p>
<p>图 33-3</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="33-3-2-编译应用程序"><a href="#33-3-2-编译应用程序" class="headerlink" title="33.3.2 编译应用程序"></a>33.3.2 编译应用程序</h3><p>来到存放应用程序llseek.c的文件夹下，使用以下命令对llseek.c进行交叉编译，编译完成如下图（图 33-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o read read.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps243.jpg" alt="img"> </p>
<p>图 33-4</p>
<p>生成的llseek文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="33-3-3-运行测试"><a href="#33-3-3-运行测试" class="headerlink" title="33.3.3 运行测试"></a>33.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 33-5）所示：</p>
<p>insmod llseek.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps244.jpg" alt="img"> </p>
<p>图 33-5</p>
<p>然后使用以下命令运行可执行文件llseek，运行结果如下图（图 33-6）所示：</p>
<p>.&#x2F;llseek</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps245.jpg" alt="img"> </p>
<p>图 33-6</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps246.jpg" alt="img"> </p>
<p>图 33-7</p>
<p>然后使用以下命令卸载对应的驱动，如下图（图 33-8）所示：</p>
<p>rmmod timer_dev</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps247.jpg" alt="img"> </p>
<p>图 33-8</p>
<h1 id="第34章-IOCTL驱动传参实验"><a href="#第34章-IOCTL驱动传参实验" class="headerlink" title="第34章 IOCTL驱动传参实验"></a>第34章 IOCTL驱动传参实验</h1><p>用户如果要对外设进行操作，对应的设备驱动不仅要具备读写的能力，还需要对硬件进行控制。以点亮LED灯驱动实验为例，应用程序通过向内核空间写入1和0从而控制LED灯的亮灭，但是读写操作主要是数据流对数据进行操作，而一些复杂的控制通常需要非数据操作，这时本章节要学习的ioctl函数就闪耀登场了。</p>
<h2 id="34-1-ioctl基础"><a href="#34-1-ioctl基础" class="headerlink" title="34.1 ioctl基础"></a>34.1 ioctl基础</h2><p>ioctl是设备驱动程序中用来控制设备的接口函数，一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87&spm=1001.2101.3001.7020">字符设备</a>驱动通常需要实现设备的打开、关闭、读取、写入等功能，而在一些需要细分的情况下，就需要扩展新的功能，通常以增设ioctl()命令的方式来实现。</p>
<p>下面将从应用层和驱动函数两个方面来对ioctl函数进行学习。</p>
<p><em><strong>*应用层：*</strong></em></p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>​    int ioctl(int fd, unsigned int cmd, unsigned long args);</p>
<p>****头文件****：</p>
<p>​    #include &lt;sys&#x2F;ioctl.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>用于向设备发送控制和配置命令。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>fd ：是用户程序打开设备时返回的文件描述符 </p>
<p>cmd ：是用户程序对设备的控制命令，</p>
<p>args：应用程序向驱动程序下发的参数，如果传递的参数为指针类型，则可以接收驱动向用户空间传递的数据（在下面的实验中会进行使用）</p>
<p>上述三个参数中，最重要的是第二个cmd参数，为unsigned int 类型，为了高效的使用cmd参数传递更多的控制信息，一个unsigned int cmd被拆分为了4段，每一段都有各自的意义，unsigned int cmd位域拆分如下：</p>
<p>cmd[31:30]—数据（args）的传输方向（读写）</p>
<p>​	cmd[29:16]—数据（args）的大小</p>
<p>​	cmd[15:8]—&gt;命令的类型，可以理解成命令的密钥，一般为ASCII码（0-255的一个字符，有部分字符已经被占用，每个字符的序号段可能部分被占用）</p>
<p>​	cmd[7:0] —&gt;命令的序号，是一个8bits的数字（序号，0-255之间）</p>
<p>cmd参数由ioctl合成宏定义得到，四个合成宏定义如下所示：</p>
<p>定义一个命令，但是不需要参数：</p>
<p>#define _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)</p>
<p>定义一个命令，应用程序从驱动程序读参数：</p>
<p>#define _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))</p>
<p>定义一个命令，应用程序向驱动程序写参数：</p>
<p>#define _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</p>
<p>定义一个命令，参数是双向传递的：</p>
<p>#define _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</p>
<p>宏定义参数说明如下所示：</p>
<p>type：命令的类型，一般为一个ASCII码值，一个驱动程序一般使用一个type</p>
<p>​	nr：该命令下序号。一个驱动有多个命令，一般他们的type，序号不同</p>
<p>​	size：args的类型</p>
<p>例如可以使用以下代码定义不需要参数、向驱动程序写参数、向驱动程序读参数三个宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST0 _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST1 _IOW(<span class="string">&#x27;L&#x27;</span>,1,int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST2 _IOR(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br></pre></td></tr></table></figure>

<p>至此，关于应用程序的ioctl相关知识就讲解完成了。</p>
<p><em><strong>*驱动函数：*</strong></em></p>
<p>应用程序中ioctl函数会调用file_operation结构体中的unlocked_ioctl接口，接口定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long (*unlocked_ioctl) (struct file *file , unsigned int cmd, unsigned long arg);</span><br></pre></td></tr></table></figure>

<p>参数说明如下所示：</p>
<p>file：文件描述符。</p>
<p>​	cmd：与应用程序的cmd参数对应，在驱动程序中对传递来的cmd参数进行判断从而做出不同的动作。</p>
<p>​	arg：与应用程序的arg参数对应，从而实现内核空间和用户空间参数的传递。</p>
<p>至此，关于驱动函数中的ioctl相关知识就讲解完成了。在下一小节中将进行ioctl驱动传参实验。</p>
<h2 id="34-2-实验程序编写"><a href="#34-2-实验程序编写" class="headerlink" title="34.2 实验程序编写"></a>34.2 实验程序编写</h2><h3 id="34-2-1-编写测试-APP"><a href="#34-2-1-编写测试-APP" class="headerlink" title="34.2.1 编写测试 APP"></a>34.2.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\27\app。</p>
<p>首先来编写应用测试代码ioctl.c，在此代码中使用非阻塞的方式打开设备，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST0 _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST1 _IOW(<span class="string">&#x27;L&#x27;</span>,1,int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST2 _IOR(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符fd</span></span><br><span class="line">	<span class="type">int</span> val;<span class="comment">//定义int类型的传递参数val</span></span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR);<span class="comment">//打开test设备节点</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open fail\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;write&quot;</span>))&#123;</span><br><span class="line">		ioctl(fd,CMD_TEST1,<span class="number">1</span>);<span class="comment">//如果第二个参数为write，向内核空间写入1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;read&quot;</span>))&#123;</span><br><span class="line">		ioctl(fd,CMD_TEST2,&amp;val);<span class="comment">//如果第二个参数为read，则读取内核空间传递向用户空间传递的值</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;val is %d\n&quot;</span>,val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="34-2-2-驱动程序编写"><a href="#34-2-2-驱动程序编写" class="headerlink" title="34.2.2 驱动程序编写"></a>34.2.2 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\27\module。</p>
<p> 编写好的驱动程序ioctl.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST0 _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST1 _IOW(<span class="string">&#x27;L&#x27;</span>,1,int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST2 _IOR(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">cdev_test_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> val;<span class="comment">//定义int类型向应用空间传递的变量val</span></span><br><span class="line">	<span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> CMD_TEST0:</span><br><span class="line">            printk(<span class="string">&quot;this is CMD_TEST0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;		</span><br><span class="line">        <span class="keyword">case</span> CMD_TEST1:</span><br><span class="line">            printk(<span class="string">&quot;this is CMD_TEST1\n&quot;</span>);</span><br><span class="line">			printk(<span class="string">&quot;arg is %ld\n&quot;</span>,arg);<span class="comment">//打印应用空间传递来的arg参数</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CMD_TEST2:</span><br><span class="line">			val = <span class="number">1</span>;<span class="comment">//将要传递的变量val赋值为1</span></span><br><span class="line">            printk(<span class="string">&quot;this is CMD_TEST2\n&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span>(copy_to_user((<span class="type">int</span> *)arg,&amp;val,<span class="keyword">sizeof</span>(val)) != <span class="number">0</span>)&#123;<span class="comment">//通过copy_to_user向用户空间传递数据</span></span><br><span class="line">				printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);	</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">break</span>;			</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	.unlocked_ioctl = cdev_test_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_dev_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  	dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_dev_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_dev_init);</span><br><span class="line">module_exit(timer_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="34-3-运行测试"><a href="#34-3-运行测试" class="headerlink" title="34.3 运行测试"></a>34.3 运行测试</h2><h3 id="34-3-1-编译驱动程序"><a href="#34-3-1-编译驱动程序" class="headerlink" title="34.3.1 编译驱动程序"></a>34.3.1 编译驱动程序</h3><p>在上一小节中的ioctl.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m += ioctl.o    #此处要和你的驱动源文件同名</span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    #make操作</span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    #make clean操作</span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放ioctl.c和Makefile文件目录下，如下图（图 34-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps248.jpg" alt="img"> </p>
<p>图 34-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 34-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps249.jpg" alt="img"> </p>
<p>图 34-2</p>
<p>编译完生成 ioctl.ko目标文件，如下图（图 34-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps250.jpg" alt="img"> </p>
<p>图 34-4</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="34-3-2-编译应用程序"><a href="#34-3-2-编译应用程序" class="headerlink" title="34.3.2 编译应用程序"></a>34.3.2 编译应用程序</h3><p>来到存放应用程序ioctl.c的文件夹下，使用以下命令对ioctl.c进行交叉编译，编译完成如下图（图 34-5）所示：</p>
<p>aarch64-linux-gnu-gcc -o ioctl ioctl.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps251.jpg" alt="img"> </p>
<p>图 34-5</p>
<p>生成的ioctl文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="34-3-3-运行测试"><a href="#34-3-3-运行测试" class="headerlink" title="34.3.3 运行测试"></a>34.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 34-6）所示：</p>
<p>insmod ioctl.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps252.jpg" alt="img"> </p>
<p>图 34-6</p>
<p>然后使用以下命令通过ioctl向内核空间传递arg参数，传递成功如下图（图 34-7）所示：</p>
<p>.&#x2F;ioctl write</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps253.jpg" alt="img"> </p>
<p>图 34-7</p>
<p>然后使用以下命令通过ioctl读取内核空间向用户空间传递的val值，读取成功如下图（图 34-8）所示：</p>
<p>.&#x2F;ioctl read</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps254.jpg" alt="img"> </p>
<p>图 34-8</p>
<p>至此关于iocto驱动传参实验就测试完成了，可以使用以下命令卸载对应的驱动，如下图（图 34-9）所示： </p>
<p>rmmod ioctl.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps255.jpg" alt="img"> </p>
<p>图 34-9</p>
<h1 id="第35章-IOCTL地址传参实验"><a href="#第35章-IOCTL地址传参实验" class="headerlink" title="**** ****第35章 IOCTL地址传参实验"></a>**** ****第35章 IOCTL地址传参实验</h1><p>在上一章节中对ioctl基础知识进行了学习，并通过ioctl进行了驱动传参实验，在本章节将以传递结构体为例，进行地址传参实验，从而加深大家对ioctl的认识。</p>
<h2 id="35-1-实验程序编写"><a href="#35-1-实验程序编写" class="headerlink" title="35.1 实验程序编写"></a>35.1 实验程序编写</h2><h3 id="35-1-1-编写测试-APP"><a href="#35-1-1-编写测试-APP" class="headerlink" title="35.1.1 编写测试 APP"></a>35.1.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\28\app。</p>
<p>首先编写应用程序ioctl.c，用来向设备文件写入数据，编写好的应用程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST0 _IOW(<span class="string">&#x27;L&#x27;</span>,0,int)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span>&#123;</span><span class="comment">//定义要传递的结构体</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型文件描述符</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">test</span>;</span><span class="comment">//定义args类型的结构体变量test</span></span><br><span class="line">	test.a = <span class="number">1</span>;</span><br><span class="line">	test.b = <span class="number">2</span>;</span><br><span class="line">	test.c = <span class="number">3</span>;</span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR,<span class="number">0777</span>);<span class="comment">//打开/dev/test设备</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ioctl(fd,CMD_TEST0,&amp;test);<span class="comment">//使用ioctl函数传递结构体变量test地址</span></span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="35-1-1-驱动程序编写"><a href="#35-1-1-驱动程序编写" class="headerlink" title="35.1.1 驱动程序编写"></a>35.1.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\28\module。</p>
<p> 编写好的驱动程序ioctl.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST0 _IOW(<span class="string">&#x27;L&#x27;</span>,0,int)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">cdev_test_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">test</span>;</span>  </span><br><span class="line">	<span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> CMD_TEST0:</span><br><span class="line">			<span class="keyword">if</span>(copy_from_user(&amp;test,(<span class="type">int</span> *)arg,<span class="keyword">sizeof</span>(test)) != <span class="number">0</span>)&#123;<span class="comment">//将用户空间传递来的arg赋值给test</span></span><br><span class="line">				printk(<span class="string">&quot;copy_from_user error\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			printk(<span class="string">&quot;a = %d\n&quot;</span>,test.a);<span class="comment">//对传递的值进行打印验证</span></span><br><span class="line">  			printk(<span class="string">&quot;b = %d\n&quot;</span>,test.b);</span><br><span class="line">  	  		printk(<span class="string">&quot;c = %d\n&quot;</span>,test.c);</span><br><span class="line">            <span class="keyword">break</span>;			</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	.unlocked_ioctl = cdev_test_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_dev_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line"> dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/*5  创建设备*/</span></span><br><span class="line"> 	dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_dev_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_dev_init);</span><br><span class="line">module_exit(timer_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="35-2-运行测试"><a href="#35-2-运行测试" class="headerlink" title="35.2 运行测试"></a>35.2 运行测试</h2><h3 id="35-2-1-编译驱动程序"><a href="#35-2-1-编译驱动程序" class="headerlink" title="35.2.1 编译驱动程序"></a>35.2.1 编译驱动程序</h3><p>在上一小节中的ioctl.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += ioctl.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放ioctl.c和Makefile文件目录下，如下图（图 35-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps256.jpg" alt="img"> </p>
<p>图 35-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 35-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps257.jpg" alt="img"> </p>
<p>图 35-2</p>
<p>编译完生成 wq.ko目标文件，如下图（图 35-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps258.jpg" alt="img"> </p>
<p>图 35-3</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="35-2-2-编译应用程序"><a href="#35-2-2-编译应用程序" class="headerlink" title="35.2.2 编译应用程序"></a>35.2.2 编译应用程序</h3><p>来到存放应用程序ioctl.c的文件夹下，使用以下命令对ioctl.c进行交叉编译，编译完成如下图（图 35-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o ioctl ioctl.c</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps259.jpg" alt="img"> </p>
<p>图 35-4</p>
<p>生成的ioctl文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="35-2-3-运行测试"><a href="#35-2-3-运行测试" class="headerlink" title="35.2.3 运行测试"></a>35.2.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 35-5）所示：</p>
<p>insmod ioctl.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps260.jpg" alt="img"> </p>
<p>图 35-5</p>
<p>然后使用以下命令运行可执行程序，运行成功如下图（图 35-6）所示：</p>
<p> .&#x2F;ioctl</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps261.jpg" alt="img"> </p>
<p>图 35-6</p>
<p>可以看到结构体类型变量test已经成功传递到了内核空间，a、b、c的值都被正确打印了出来，我们的ioctl地址传参实验就完成了。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps262.jpg" alt="img"> </p>
<p>图 35-7</p>
<h1 id="第36章-封装驱动API接口实验"><a href="#第36章-封装驱动API接口实验" class="headerlink" title="**** ****第36章 封装驱动API接口实验"></a>**** ****第36章 封装驱动API接口实验</h1><p>相信经过前面两个章节的学习已经能够熟练的使用ioctl函数了，在本章节会进行两个实验，每个实验的要完成的任务如下所示：</p>
<p>实验一：通过ioctl对定时器进行控制，分别实现打开定时器、关闭定时器和设置定时时间的功能。</p>
<p>实验二：对实验一的应用程序进行封装，从而让应用编程人员更好的对设备进行编程。</p>
<h2 id="36-1-ioctl控制定时器实验"><a href="#36-1-ioctl控制定时器实验" class="headerlink" title="36.1 ioctl控制定时器实验"></a>36.1 ioctl控制定时器实验</h2><p>首先进行ioctl控制定时器实验，通过该实验可以综合ioctl函数和定时器相关知识，从而进一步加深对ioctl的理解。</p>
<h3 id="36-1-1-编写测试-APP"><a href="#36-1-1-编写测试-APP" class="headerlink" title="36.1.1 编写测试 APP"></a>36.1.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\29\app1。</p>
<p>首先来编写应用测试代码ioctl.c，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_OPEN _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_CLOSE _IO(<span class="string">&#x27;L&#x27;</span>,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_SET _IOW(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR,<span class="number">0777</span>);<span class="comment">//打开test节点</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    ioctl(fd,TIME_SET,<span class="number">1000</span>);</span><br><span class="line">	ioctl(fd,TIME_OPEN);</span><br><span class="line">	sleep(<span class="number">3</span>);</span><br><span class="line">    ioctl(fd,TIME_SET,<span class="number">3000</span>);</span><br><span class="line">	sleep(<span class="number">7</span>);</span><br><span class="line">	ioctl(fd,TIME_CLOSE);</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第8-10行通过合成宏定义了三个ioctl命令，分别代表定时器打开、定时器关闭、定时时间设置。</p>
<p>第18行和第21行将定时时间分别设置为1秒和3秒。</p>
<p>第19行打开定时器。</p>
<p>第23行关闭定时器。</p>
<h3 id="36-1-2-驱动程序编写"><a href="#36-1-2-驱动程序编写" class="headerlink" title="36.1.2 驱动程序编写"></a>36.1.2 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\29\module。</p>
<p> 编写好的驱动程序ioctl_timer.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_OPEN _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_CLOSE _IO(<span class="string">&#x27;L&#x27;</span>,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_SET _IOW(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">	<span class="type">int</span> counter; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">fnction_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span>;<span class="comment">//定义function_test定时功能函数</span></span><br><span class="line">DEFINE_TIMER(timer_test,fnction_test);<span class="comment">//定义一个定时器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fnction_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;this is fnction_test\n&quot;</span>);</span><br><span class="line">    mod_timer(&amp;timer_test,jiffies_64 + msecs_to_jiffies(dev1.counter));<span class="comment">//使用mod_timer函数重新设置定时时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">cdev_test_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span> =</span> (<span class="keyword">struct</span> device_test *)file-&gt;private_data;<span class="comment">//设置私有数据</span></span><br><span class="line">	<span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> TIMER_OPEN:</span><br><span class="line">			add_timer(&amp;timer_test);<span class="comment">//添加一个定时器</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TIMER_CLOSE:</span><br><span class="line">			del_timer(&amp;timer_test);<span class="comment">//删除一个定时器</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TIMER_SET:</span><br><span class="line">			test_dev-&gt;counter = arg;</span><br><span class="line">			timer_test.expires = jiffies_64 + msecs_to_jiffies(test_dev-&gt;counter);<span class="comment">//设置定时时间</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	.open = cdev_test_open,</span><br><span class="line">	.release = cdev_test_release,</span><br><span class="line">	.unlocked_ioctl = cdev_test_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_dev_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line"> dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">&#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  	dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_dev_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_dev_init);</span><br><span class="line">module_exit(timer_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="36-2-运行测试"><a href="#36-2-运行测试" class="headerlink" title="36.2 运行测试"></a>36.2 运行测试</h2><h3 id="36-2-1-编译驱动程序"><a href="#36-2-1-编译驱动程序" class="headerlink" title="36.2.1 编译驱动程序"></a>36.2.1 编译驱动程序</h3><p>在上一小节中的ioctl_timer.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += ioctl_timer.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放ioctl_timer.c和Makefile文件目录下，如下图（图 36-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps263.jpg" alt="img"> </p>
<p>图 36-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 36-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps264.jpg" alt="img"> </p>
<p>图 36-2</p>
<p>编译完生成 ioctl_timer.ko目标文件，如下图（图 36-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps265.jpg" alt="img"> </p>
<p>图 36-3</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="36-2-2-编译应用程序"><a href="#36-2-2-编译应用程序" class="headerlink" title="36.2.2 编译应用程序"></a>36.2.2 编译应用程序</h3><p>来到存放应用程序ioctl.c的文件夹下，使用以下命令对ioctl.c进行交叉编译，编译完成如下图（图 36-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o ioctl ioctl.c</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps266.jpg" alt="img"> </p>
<p>图 36-4</p>
<p>生成的ioctl文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="36-2-3-运行测试"><a href="#36-2-3-运行测试" class="headerlink" title="36.2.3 运行测试"></a>36.2.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 36-5）所示：</p>
<p>insmod ioctl_timer.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps267.jpg" alt="img"> </p>
<p>图 36-5</p>
<p>输入以下命令运行可执行文件,运行成功如下图（图 36-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps268.jpg" alt="img"> </p>
<p>图 36-6</p>
<p>可以看到前面三个打印信息间隔为1秒钟，后面三个打印信息间隔为3秒钟，至此，实验一就结束了，然后使用以下命令卸载驱动模块，如下图（图 36-7）所示：</p>
<p>rmmod ioctl_timer.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps269.jpg" alt="img"> </p>
<p>图 36-7</p>
<h2 id="36-3-封装驱动API接口"><a href="#36-3-封装驱动API接口" class="headerlink" title="36.3 封装驱动API接口"></a>36.3 封装驱动API接口</h2><p>至此，随着ioctl练习的结束，字符设备驱动框架相关的知识也就完结了，相信细心的小伙伴在上一小节应用程序的编写中会发现问题，应用程序是从驱动的角度进行编写的，具体内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_OPEN _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_CLOSE _IO(<span class="string">&#x27;L&#x27;</span>,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_SET _IOW(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR,<span class="number">0777</span>);<span class="comment">//打开test节点</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    ioctl(fd,TIME_SET,<span class="number">1000</span>);</span><br><span class="line">	ioctl(fd,TIME_OPEN);</span><br><span class="line">	sleep(<span class="number">3</span>);</span><br><span class="line">    ioctl(fd,TIME_SET,<span class="number">3000</span>);</span><br><span class="line">	sleep(<span class="number">7</span>);</span><br><span class="line">	ioctl(fd,TIME_CLOSE);</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为驱动工程师的我们当然可以理解每一行代码所要完成的功能，而一般情况下，应用都是由专业的应用工程师来进行编写的，上述代码编写方式很不利于应用工程师的理解和程序的移植，所以对于应用程序API的封装是一件必然的事情。</p>
<p>封装好的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\29\app2。</p>
<p>首先来编写整体库文件timerlib.h，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TIMELIB_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TIMELIB_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_OPEN _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_CLOSE _IO(<span class="string">&#x27;L&#x27;</span>,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_SET _IOW(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_open</span><span class="params">()</span>;<span class="comment">//定义设备打开函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_open</span><span class="params">(<span class="type">int</span> fd)</span>;<span class="comment">//定义定时器打开函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_close</span><span class="params">(<span class="type">int</span> fd)</span>;<span class="comment">//定义定时器关闭函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_set</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> arg)</span>;<span class="comment">//定义设置计时时间函数</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在9-11行使用合成宏定义了三个ioctl命令，分别代表定时器打开、定时器关闭、定时时间设置。</p>
<p>在第12-15行定义了四个功能函数，所代表的功能分别为设备打开、定时器打开、定时器关闭、定时时间设置。</p>
<p>接下来将创建每个功能函数的c文件，最后编译为单独的库，首先编写dev_open.c文件，编写好的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;timerlib.h&quot;</span><br><span class="line">int dev_open()</span><br><span class="line">&#123;</span><br><span class="line">    int fd；</span><br><span class="line">    fd = open(&quot;/dev/test&quot;,O_RDWR,0777);</span><br><span class="line">    if(fd &lt; 0)&#123;</span><br><span class="line">        printf(&quot;file open error \n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写定时器打开函数timeropen.c文件，编写好的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;timerlib.h&quot;</span><br><span class="line">int timer_open(int fd)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	ret = ioctl(fd,TIMER_OPEN);</span><br><span class="line">	if(ret &lt; 0)&#123;</span><br><span class="line">		printf(&quot;ioctl open error \n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写定时器打开函数timerclose.c文件，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timerlib.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_close</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = ioctl(fd,TIMER_CLOSE);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ioctl  close error \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写定时器打开函数timerset.c文件，编写好的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;timerlib.h&quot;</span><br><span class="line">int timer_set(int fd,int arg)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	ret = ioctl(fd,TIMER_SET,arg);</span><br><span class="line">	if(ret &lt; 0)&#123;</span><br><span class="line">		printf(&quot;ioctl error \n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后编写测试要用到的应用程序ioctl.c文件，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timerlib.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	fd = dev_open();</span><br><span class="line">    timer_set(fd,<span class="number">1000</span>);</span><br><span class="line">	timer_open(fd);</span><br><span class="line">	sleep(<span class="number">3</span>);</span><br><span class="line">	timer_set(fd,<span class="number">3000</span>);</span><br><span class="line">	sleep(<span class="number">7</span>);</span><br><span class="line">	timer_close(fd);</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，要用到的文件就都编写完成了，会在下一小节进行库的制作，以及应用程序的编译。</p>
<h2 id="36-4-运行测试"><a href="#36-4-运行测试" class="headerlink" title="36.4 运行测试"></a>36.4 运行测试</h2><h3 id="36-4-1-编译应用程序"><a href="#36-4-1-编译应用程序" class="headerlink" title="36.4.1 编译应用程序"></a>36.4.1 编译应用程序</h3><p>首先使用以下命令将存放功能函数的c文件编译成.o文件，编译完成如下图（图 36-7）所示：</p>
<p>aarch64-linux-gnu-gcc -c dev_open.c</p>
<p>aarch64-linux-gnu-gcc -c timer*.c</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps270.jpg" alt="img"> </p>
<p>图 36-7</p>
<p>然后使用以下命令将相应的.o文件编译成.a静态库（这里要注意库的名称都以lib开头），编译完成如下图（图 36-8）所示：</p>
<p>aarch64-linux-gnu-ar rcs libtime.a timer*.o</p>
<p>aarch64-linux-gnu-ar rcs libopen.a dev_open.o</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps271.jpg" alt="img"> </p>
<p>图 36-8</p>
<p>最后使用以下命令对ioctl.c进行交叉编译，编译完成如下图（图 36-9）所示：</p>
<p>aarch64-linux-gnu-gcc -o ioctl ioctl.c -L.&#x2F; -ltime -lopen</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps272.jpg" alt="img"> </p>
<p>图 36-9</p>
<p>生成的ioctl文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="36-4-2-运行测试"><a href="#36-4-2-运行测试" class="headerlink" title="36.4.2 运行测试"></a>36.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 36-10）所示：</p>
<p>insmod ioctl_timer.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps273.jpg" alt="img"> </p>
<p>图 36-10</p>
<p>输入以下命令运行可执行文件,运行成功如下图（图 36-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps274.jpg" alt="img"> </p>
<p>图 36-11</p>
<p>可以看到前面三个打印信息间隔为1秒钟，后面三个打印信息间隔为3秒钟，至此，实验一就结束了，然后使用以下命令卸载驱动模块，如下图（图 36-12）所示：</p>
<p>rmmod ioctl_timer.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps275.jpg" alt="img"> </p>
<p>图 36-12</p>
<h1 id="第37章-优化驱动稳定性和效率实验"><a href="#第37章-优化驱动稳定性和效率实验" class="headerlink" title="第37章 优化驱动稳定性和效率实验"></a>第37章 优化驱动稳定性和效率实验</h1><p>在Linux中应用程序运行在用户空间，应用程序错误之后，并不会影响其他程序的运行，而驱动工作在内核层，是内核代码的一部分，当驱动出现问题之后，可能会导致整个系统的崩溃。所以在驱动中，需要对各种判断、预处理等进行排查等，在本小节将对如何优化驱动稳定性和提高驱动效率进行学习。</p>
<h2 id="37-1-方法一：检测ioctl命令"><a href="#37-1-方法一：检测ioctl命令" class="headerlink" title="37.1 方法一：检测ioctl命令"></a>37.1 方法一：检测ioctl命令</h2><p>ioctl的cmd命令是由合成宏合成得到的，也有相应的分解宏得到各个参数，四个分解宏如下所示：</p>
<p>分解cmd命令，得到命令的类型：</p>
<p>_IOC_TYPE(cmd)</p>
<p>分解cmd命令，得到数据（args）的传输方向：</p>
<p>_IOC_DIR(cmd)</p>
<p>分解cmd命令，得到命令的序号：</p>
<p>_IOC_NR(cmd)</p>
<p>分解cmd命令，得到数据（args）的大小：</p>
<p>_IOC_SIZE(cmd)</p>
<p>可以在驱动中通过上述分解宏对传入的ioctl命令类型等参数进行判断，从而得到判断传入的参数是否正确，以此优化驱动的稳定性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(_IOC_TYPE(cmd) != <span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">   printk(<span class="string">&quot;cmd type error \n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如可以通过上述代码对传入参数的类型进行判断，如果传入的参数类型不为“L”,就返回错误，其他参数的检测方法相同。</p>
<h2 id="37-2-方法二：检测传递地址是否合理"><a href="#37-2-方法二：检测传递地址是否合理" class="headerlink" title="37.2 方法二：检测传递地址是否合理"></a>37.2 方法二：检测传递地址是否合理</h2><p>access_ok()函数</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>​    access_ok(addr,size);</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>检查用户空间内存块是否可用</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>addr  :  用户空间的指针变量，其指向一个要检查的内存块开始处。</p>
<p>size   :  要检查内存块的大小。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>成功返回1，失败返回0</p>
<p>以第35章的ioctl地址传参实验为例，对传入的args地址进行判断，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">test</span>;</span></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">	<span class="keyword">case</span> CMD_TEST0:</span><br><span class="line">		len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> args);</span><br><span class="line">		<span class="keyword">if</span>(!access_ok(arg,len))&#123;</span><br><span class="line">			 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(copy_from_user(&amp;test,(<span class="type">int</span> *)arg,<span class="keyword">sizeof</span>(test)) != <span class="number">0</span>)&#123;</span><br><span class="line">			 printk(<span class="string">&quot;copy_from_user error\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>在第6行对传入的args参数地址进行判断，如果不合法则返回-1，从而保证了驱动运行的稳定性。</p>
<h2 id="37-3-方法三：分支预测优化"><a href="#37-3-方法三：分支预测优化" class="headerlink" title="37.3 方法三：分支预测优化"></a>37.3 方法三：分支预测优化</h2><p>现在的CPU都有ICache和流水线机制。即运行当前指令时，ICache会预读取后面的指令，从而提升效率。但是如果条件分支的结果是跳转到了其他指令，那预取下一条指令就浪费时间了。而本章节要用到的likely和unlikely宏，会让编译器总是将大概率执行的代码放在靠前的位置，从而提高驱动的效率。</p>
<p>likely和unlikely宏定义在“内核源码&#x2F;include&#x2F;linux&#x2F;compiler.h”文件中，具体定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define likely(x) __builtin_expect(!!(x), 1)</span><br><span class="line">#define unlikely(x) __builtin_expect(!!(x), 0)</span><br></pre></td></tr></table></figure>

<p>__builtin_expect的作用是告知编译器预期表达式exp等于c的可能性更大，编译器可以根据该因素更好的对代码进行优化，所以likely与unlikely的作用就是表达性x为真的可能性更大（likely）和更小（unlikely）。</p>
<p>这里以上一小节添加传递地址检测内容后的代码为例，对copy_from_user函数添加分支预测优化函数，添加完成如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">test</span>;</span></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">	<span class="keyword">case</span> CMD_TEST0:</span><br><span class="line">		len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> args);</span><br><span class="line">		<span class="keyword">if</span>(!access_ok(arg,len))&#123;</span><br><span class="line">			 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(unlikely(copy_from_user(&amp;test,(<span class="type">int</span> *)arg,<span class="keyword">sizeof</span>(test)) != <span class="number">0</span>))&#123;</span><br><span class="line">			 printk(<span class="string">&quot;copy_from_user error\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>传递地址检测成功之后才会使用执行copy_from_user函数，在传递地址正确的前提下copy_from_user函数运行失败为小概率事件，所以这里使用unlikely函数进行驱动效率的优化。</p>
<p>至此，关于分支预测优化相关的知识就讲解完成了。</p>
<h1 id="第38章-驱动调试方法实验"><a href="#第38章-驱动调试方法实验" class="headerlink" title="第38章 驱动调试方法实验"></a>第38章 驱动调试方法实验</h1><p>在之前编写的驱动程序中，通常都使用printk函数打印相应的提示信息从而对驱动进行调试，那有没有其他的方式来调试驱动呢，答案是肯定的，在本章节中将对不同驱动调试方法进行学习。</p>
<h2 id="38-1-方法1：dump-stack函数"><a href="#38-1-方法1：dump-stack函数" class="headerlink" title="38.1 方法1：dump_stack函数"></a>38.1 方法1：dump_stack函数</h2><p>作用:打印内核调用堆栈，并打印函数的调用关系。</p>
<p>这里以最简单的helloworld驱动为例进行dump_stack函数演示，实验代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>        </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">	dump_stack();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);    </span><br><span class="line">module_exit(helloworld_exit);   </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    </span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>和原helloworld驱动程序相比，在第6行添加了dump_stack()，驱动加载之后打印信息如下（图 38-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps276.jpg" alt="img"> </p>
<p>图 38-1</p>
<p>可以看到helloworld_init函数的调用关系就都打印了出来。</p>
<p>至此关于dump_stack函数的测试就完成了。</p>
<h2 id="38-2-方法2：WARN-ON-condition-函数"><a href="#38-2-方法2：WARN-ON-condition-函数" class="headerlink" title="38.2 方法2：WARN_ON(condition)函数"></a>38.2 方法2：WARN_ON(condition)函数</h2><p>WARN_ON (condition)函数作用:在括号中的条件成立时，内核会抛出栈回溯，打印函数的调用关系。通常用于内核抛出一个警告，暗示某种不太合理的事情发生了。</p>
<p>WARN_ON实际上也是调用dump_stack，只是多了参数condition判断条件是否成立，例如WARN_ON (1)则条件判断成功，函数会成功执行。</p>
<p>这里仍然以最简单的helloworld驱动为例进行WARN_ON函数演示，实验代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>        </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">	WARN_ON(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);    </span><br><span class="line">module_exit(helloworld_exit);   </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    </span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);c</span><br></pre></td></tr></table></figure>

<p>和原helloworld驱动程序相比，在第6行添加了WARN_ON(1)，驱动加载之后打印信息如下（图 38-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps277.jpg" alt="img"> </p>
<p>图 38-2</p>
<p>可以看到helloworld_init函数的调用关系以及寄存器值就都打印了出来。</p>
<p>至此关于WARN_ON函数的测试就完成了。</p>
<h2 id="38-3-方法3：BUG-ON-condition-函数"><a href="#38-3-方法3：BUG-ON-condition-函数" class="headerlink" title="38.3 方法3：BUG_ON (condition)函数"></a>38.3 方法3：BUG_ON (condition)函数</h2><p>内核中有许多地方调用类似BUG_ON()的语句，它非常像一个内核运行时的断言，意味着本来不该执行到BUG_ON()这条语句，一旦BUG_ON()执行内核就会立刻抛出oops，导致栈的回溯和错误信息的打印。大部分体系结构把BUG()和BUG_ON()定义成某种非法操作，这样自然会产生需要的oops。参数condition判断条件是否成立，例如BUG_ON (1)则条件判断成功，函数会成功执行。</p>
<p>这里仍然以最简单的helloworld驱动为例进行BUGON函数演示，实验代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>        </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">	BUGON(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);    </span><br><span class="line">module_exit(helloworld_exit);   </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    </span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>和原helloworld驱动程序相比，在第6行添加了BUGON(1)，驱动加载之后打印信息如下（图 38-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps278.jpg" alt="img"> </p>
<p>图 38-3</p>
<p>可以看到helloworld_init函数的调用关系以及寄存器值就都打印了出来。</p>
<p>至此关于BUGON(1)函数的测试就完成了。</p>
<h2 id="38-4-方法4：panic-fmt…-函数"><a href="#38-4-方法4：panic-fmt…-函数" class="headerlink" title="38.4 方法4：panic (fmt…)函数"></a>38.4 方法4：panic (fmt…)函数</h2><p>panic (fmt…)函数:输出打印会造成系统死机并将函数的调用关系以及寄存器值就都打印了出来。</p>
<p>这里仍然以最简单的helloworld驱动为例进行panic 函数的演示，实验代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>        </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">	panic(<span class="string">&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);    </span><br><span class="line">module_exit(helloworld_exit);   </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    </span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>和原helloworld驱动程序相比，在第6行添加了panic(“!!!!!!!!!!!!!!!!!!!!!!!!!!!!”)，驱动加载之后打印信息如下（图 38-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps279.jpg" alt="img"> </p>
<p>图 38-4</p>
<p>可以看到helloworld_init函数的调用关系以及寄存器值就都打印了出来，信息打印完成之后会发现系统已经崩溃了，终端已经无法再进行输入。</p>
<p>至此关于panic函数的测试就完成了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%AB%98%E7%BA%A7%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E8%BF%9B%E9%98%B6/" rel="tag">高级字符设备进阶</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-rk3568-驱动开发第三篇-并发与竞争"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%89%E7%AF%87-%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/"
    >rk3568 驱动开发第三篇 并发与竞争</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%89%E7%AF%87-%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/" class="article-date">
  <time datetime="2023-09-04T12:55:28.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>第19章 并发与竞争实验</p>
<p>在前面章节的学习中，相信大家已经对用户空间与内核空间数据传递进行了实验，假如要传递的数据被存放在了全局变量，该数据就可以作为共享资源被多个任务共同读写，从而造成数据的错误传输，多个程序同时访问一个共享资源产生的问题就叫做竞争。竞争产生的根本原因就是Linux系统的并发访问。</p>
<p>在本章节中首先会对并发与并行的概念进行讲解，随后对竞争产生的原因进行总结，最后以一个实际的竞争实验加深大家的理解。下面就让我们开始本章节的学习吧。</p>
<h2 id="19-1-并发与竞争"><a href="#19-1-并发与竞争" class="headerlink" title="19.1 并发与竞争"></a>19.1 并发与竞争</h2><h3 id="19-1-1并发"><a href="#19-1-1并发" class="headerlink" title="19.1.1并发"></a>19.1.1并发</h3><p>早期计算机大多只有一个CPU核心，一个CPU在同一时间只能执行一个任务，当系统中有多个任务等待执行时，CPU只能执行完一个再执行下一个。而计算机的很多指令会涉及I&#x2F;O操作，执行速度远远低于CPU内高速存储器的存取速度，这就导致CPU经常处于空闲状态，只能等待I&#x2F;O操作完成后才能继续执行后面的指令。为了提高CPU利用率，减少等待时间，提出了CPU并发工作理论。</p>
<p>所谓并发，就是通过算法将CPU资源合理地分配给多个任务，当一个任务执行 I&#x2F;O 操作时，CPU可以转而执行其它的任务，等到 I&#x2F;O 操作完成以后，或者新的任务遇到 I&#x2F;O 操作时，CPU再回到原来的任务继续执行。</p>
<p>下图（图19-1）展示了两个任务并发执行的过程（为了容易理解，这里以两个任务并发执行为例，当然一个CPU核心并不仅仅只能两个任务并发）：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps109.jpg" alt="img"> </p>
<p>图 19-1</p>
<p>虽然CPU在同一时刻只能执行一个任务，但是通过将CPU的使用权在恰当的时机分配给不同的任务，使得多个任务看起来是一起执行的（CPU的执行速度极快，多任务切换的时间也极短）。</p>
<p>至此关于并发的概念就讲解完成了。</p>
<h3 id="19-1-2并行"><a href="#19-1-2并行" class="headerlink" title="19.1.2并行"></a>19.1.2并行</h3><p>并发是针对单核CPU提出的，而并行则是针对多核CPU提出的。和单核CPU不同，多核CPU真正实现了“同时执行多个任务”。多核CPU的每个核心都可以独立地执行一个任务，而且多个核心之间不会相互干扰。在不同核心上执行的多个任务，是真正地同时运行，这种状态就叫做并行。双核CPU的工作状态如下图（图19-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps110.jpg" alt="img"> </p>
<p>图 19-2</p>
<p>双核CPU执行两个任务时，每个核心各自执行一个任务，和单核CPU在两个任务之间不断切换相比，它的执行效率更高。</p>
<p>至此对于并行的概念就讲解完成了。</p>
<h3 id="19-1-3并发-并行"><a href="#19-1-3并发-并行" class="headerlink" title="19.1.3并发+并行"></a>19.1.3并发+并行</h3><p>在并行的工作状态中，两个CPU分别执行两个任务，是一种理想状态。但是在实际场景中，处于运行状态的任务是非常多的，以实际办公电脑为例，windows系统在开机之后会运行几十个任务，而CPU往往只有4核、8核等，远远低于任务的数量，这个时候就会同时存在并发和并行两种情况，即所有核心在并行工作的同时，每个核心还要并发工作。</p>
<p>例如一个双核 CPU 要执行四个任务，它的工作状态如下图（图19-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps111.jpg" alt="img"> </p>
<p>图 19-3</p>
<p>为了容易理解，这里是以两个任务并发执行为例，当然一个CPU核心并不仅仅只能两个任务并发，并发任务的数量和操作系统的分配方式、以及每个任务的工作状态有关系。</p>
<p>至此，对于并发+并行的概念讲解就结束了。</p>
<p>并发可以看作是并行的理想状态，为了便于讲解和避免产生歧义，之后的章节无论是并发还是并行，都会统称为并发。</p>
<h3 id="19-1-4-竞争"><a href="#19-1-4-竞争" class="headerlink" title="19.1.4 竞争"></a>19.1.4 竞争</h3><p>并发可能会造成多个程序同时访问一个共享资源，这时候由并发同时访问一个共享资源产生的问题就叫做竞争。</p>
<p>竞争产生的原因如下所示：</p>
<p>（1）多线程的并发访问。由于Linux 是多任务操作系统，所以多线程访问是竞争产生的基本原因。</p>
<p>（2）中断程序的并发访问。中断任务产生后，CPU会立刻停止当前工作，从而去执行中断中的任务，如果中断任务对共享资源进行了修改，就会产生竞争。</p>
<p>（3）抢占式并发访问。linux2.6及更高版本引入了抢占式内核，高优先级的任务可以打断低优先级的任务。在线程访问共享资源的时候，另一个线程打断了现在正在访问共享资源的线程同时也对共享资源进行操作，从而造成了竞争。</p>
<p>（4）多处理器(SMP）并发访问。多核处理器之间存在核间并发访问。</p>
<h3 id="19-1-5-共享资源的保护"><a href="#19-1-5-共享资源的保护" class="headerlink" title="19.1.5 共享资源的保护"></a>19.1.5 共享资源的保护</h3><p>竞争是由并发访问同一个共享资源产生的。为了防止“竞争”的产生就要对共享资源进行保护，这里提到的共享资源又是什么呢？</p>
<p>以实际生活中的共享资源为例，可以是公共电话，也可以是共享单车、共享充电宝等公共物品，以上都属于共享资源的范畴，以公共电话为例，每个人都可以对它进行使用，但在同一时间内只能由一个人进行使用，如果两个人都要对电话进行使用，则产生了竞争。而在实际的驱动的代码中，共享资源可以是全局变量，也可以是驱动中的设备结构体等，需要根据具体的驱动程序来进行分析。在下一小节的实验中，会以全局变量为例，进行并发与竞争实验。</p>
<h2 id="19-2-实验程序的编写"><a href="#19-2-实验程序的编写" class="headerlink" title="19.2 实验程序的编写"></a>19.2 实验程序的编写</h2><h3 id="19-2-1-驱动程序编写"><a href="#19-2-1-驱动程序编写" class="headerlink" title="19.2.1 驱动程序编写"></a>19.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\14\module。</p>
<p>本实验将编写并发与竞争的驱动代码，首先完善字符设备驱动框架，然后通过copy_from_user(…)函数接收用户空间传递到内核空间的数据并进行判断，如果接收到的字符串数据为“topeet”会在睡眠4秒钟后打印接收到的数据，如果接收到的字符串数据为“itop”会在睡眠2秒钟后打印接收到的数据。</p>
<p>编写完成的example.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;\nthis is open_test \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//printk(&quot;\nthis is release_test \n&quot;);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对于重要逻辑部分已经加粗，后续章节的实验都是对上述并发与竞争实验的改进，以不同的方式来避免竞争的产生。</p>
<h3 id="19-2-2-编写测试-APP"><a href="#19-2-2-编写测试-APP" class="headerlink" title="19.2.2 编写测试 APP"></a>19.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\14\app。</p>
<p>本测试app较为简单，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="19-3-运行测试"><a href="#19-3-运行测试" class="headerlink" title="19.3 运行测试"></a>19.3 运行测试</h2><h3 id="19-3-1-编译驱动程序"><a href="#19-3-1-编译驱动程序" class="headerlink" title="19.3.1 编译驱动程序"></a>19.3.1 编译驱动程序</h3><p>在上一小节中的example.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += example.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放example.c和Makefile文件目录下，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps112.jpg" alt="img"> </p>
<p>图 19-4</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图19-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps113.jpg" alt="img"> </p>
<p>图 19-5</p>
<p>编译完生成example.ko目标文件，如下图（图19-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps114.jpg" alt="img"> </p>
<p>图 19-6</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h3 id="19-3-2-编译应用程序"><a href="#19-3-2-编译应用程序" class="headerlink" title="19.3.2 编译应用程序"></a>19.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图19-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps115.jpg" alt="img"> </p>
<p>图 19-7</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图19-8）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps116.jpg" alt="img"> </p>
<p>图 19-8</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="19-3-3-运行测试"><a href="#19-3-3-运行测试" class="headerlink" title="19.3.3 运行测试"></a>19.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图19-9）所示：</p>
<p>insmod example.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps117.jpg" alt="img"> </p>
<p>图 19-9</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图19-10）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps118.jpg" alt="img"> </p>
<p>图 19-10</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图19-11）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps119.jpg" alt="img"> </p>
<p>图 19-11</p>
<p>可以看到传递的buf值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图19-12）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet &amp;</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test itop &amp;</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps120.jpg" alt="img"> </p>
<p>图 19-12</p>
<p>在不存在竞争的情况下，传递的两个字符串数据应该是topeet和itop，而在上图中的打印信息为两个itop，原因是第二个app应用程序运行之后对共享资源进行了修改，两个app应用程序就产生了竞争关系，会在之后的章节中使用不同的方法对上述驱动程序进行改进，从而避免竞争的产生。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图19-13）所示：</p>
<p>rmmod  example.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps121.jpg" alt="img"> </p>
<p>图 19-13</p>
<p>至此，并发与竞争的实验就完成了。</p>
<h1 id="第20章-原子操作实验"><a href="#第20章-原子操作实验" class="headerlink" title="第20章 原子操作实验"></a>第20章 原子操作实验</h1><p>在上一章节的实验中，对并发与竞争进行了实验，两个app应用程序之间对共享资源的竞争访问引起了数据传输错误，而在Linux内核中，提供了四种处理并发与竞争的常见方法，分别是原子操作、自旋锁、信号量、互斥体，在之后的几个章节中会依次对上述四种方法进行讲解。</p>
<p>本章首先对四种常见方法中的原子操作进行讲解。</p>
<h2 id="20-1-原子操作"><a href="#20-1-原子操作" class="headerlink" title="20.1 原子操作"></a>20.1 原子操作</h2><p>“原子”是化学世界中不可再分的最小微粒，一切物质都由原子组成。在Linux内核中的原子操作可以理解为“不可被拆分的操作”，就是不能被更高等级中断抢夺优先的操作。在C语言中可以使用以下代码对一个整形变量赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> v;<span class="comment">//定义一个int类型的变量v</span></span><br><span class="line">v = <span class="number">1</span>;<span class="comment">//将int类型的变量v赋值为1</span></span><br></pre></td></tr></table></figure>

<p>而上述代码仍然不是“不可拆分的操作”，C语言程序仍然需要翻译成汇编指令，在汇编指令的执行过程中仍可能会有竞争的产生。而原子操作会将整形变量的操作当成一个整体，不可再进行分割。而原子操作又可以进一步细分为“整型原子操作”和“位原子操作”，这里首先对****整型原子操作****进行讲解。</p>
<p>在Linux内核中使用 atomic_t和atomic64_t结构体分别来完成32位系统和64位系统的整形数据原子操作，两个结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;types.h”文件中，具体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     <span class="type">int</span> counter;</span><br><span class="line"> &#125; <span class="type">atomic_t</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     <span class="type">long</span> counter;</span><br><span class="line">&#125; <span class="type">atomic64_t</span>;</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>例如可以使用以下代码定义一个64位系统的原子整形变量：</p>
<p>atomic64_t v;</p>
<p>在成功定义原子变量之后，必然要对原子变量进行读取、加减等动作，原子操作的部分常用API函数如下所示，定义在“内核源码&#x2F;include&#x2F;linux&#x2F;atomic.h”文件中，所以在接下来的实验中需要加入该头文件的引用。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ATOMIC_INIT(int i)</td>
<td>定义原子变量的时候对其初始化，赋值为i</td>
</tr>
<tr>
<td>int atomic_read(atomic_t *v)</td>
<td>读取v的值，并且返回。</td>
</tr>
<tr>
<td>void atomic_set(atomic_t *v, int i)</td>
<td>向原子变量v写入i值。</td>
</tr>
<tr>
<td>void atomic_add(int i, atomic_t *v)</td>
<td>原子变量v加上i值。</td>
</tr>
<tr>
<td>void atomic_sub(int i, atomic_t *v)</td>
<td>原子变量v减去i值。</td>
</tr>
<tr>
<td>void atomic_inc(atomic_t *v)</td>
<td>原子变量v加1</td>
</tr>
<tr>
<td>void atomic_dec(atomic_t *v)</td>
<td>原子变量v减1</td>
</tr>
<tr>
<td>int atomic_dec_return(atomic_t *v)</td>
<td>原子变量v减1，并返回v的值。</td>
</tr>
<tr>
<td>int atomic_inc_return(atomic_t *v)</td>
<td>原子变量v加 1，并返回v的值。</td>
</tr>
<tr>
<td>int atomic_sub_and_test(int i, atomic_t *v)</td>
<td>原子变量v减 i，如果结果为0就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_dec_and_test(atomic_t *v)</td>
<td>原子变量v减 1，如果结果为0就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_inc_and_test(atomic_t *v)</td>
<td>原子变量v加 1，如果结果为0就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_add_negative(int i, atomic_t *v)</td>
<td>原子变量v加 i，如果结果为负就返回真，否则返回假</td>
</tr>
</tbody></table>
<p>图表20- 1</p>
<p>至此，对于整型原子操作的相关API函数就讲解完成了，会在下一小节中使用上述原子整形操作API进行相应的实验。</p>
<p>下面对原子位操作进行讲解，和原子整形变量不同，原子位操作没有 atomic_t 的数据结构，原子位操作是直接对内存进行操作，原子位操作相关API函数如下（图表20-2）所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void set_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位置 1。</td>
</tr>
<tr>
<td>void clear_bit(int nr,void *p)</td>
<td>将 p 地址的第 nr 位清零。</td>
</tr>
<tr>
<td>void change_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位进行翻转。</td>
</tr>
<tr>
<td>int test_bit(int nr, void *p)</td>
<td>获取 p 地址的第 nr 位的值。</td>
</tr>
<tr>
<td>int test_and_set_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位置 1，并且返回 nr 位原来的值。</td>
</tr>
<tr>
<td>int test_and_clear_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位清零，并且返回 nr 位原来的值。</td>
</tr>
<tr>
<td>int test_and_change_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位翻转，并且返回 nr 位原来的值。</td>
</tr>
</tbody></table>
<p>图表20- 2</p>
<p>对于原子位操作的知识就不再深入讲解和实验，感兴趣的同学可以到相关网站上进行自主学习。</p>
<p>在下一小节中，将会使用原子整形操作对19章的并发与竞争实验进行改进。</p>
<h2 id="20-2-实验程序的编写"><a href="#20-2-实验程序的编写" class="headerlink" title="20.2 实验程序的编写"></a>20.2 实验程序的编写</h2><h3 id="20-2-1-驱动程序编写"><a href="#20-2-1-驱动程序编写" class="headerlink" title="20.2.1 驱动程序编写"></a>20.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\15\module。</p>
<p>为了解决第19章实验中并发与竞争的问题，本章节实验将加入原子整形操作相关实验代码，在open()函数和release()函数中加入原子整形变量v的赋值代码，并且在open()函数中加入原子整形变量v的判断代码，从而实现同一时间内只允许一个应用打开该设备节点，以此来防止共享资源竞争的产生。</p>
<p>编写完成的atomic.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">atomic64_t</span> v = ATOMIC_INIT(<span class="number">1</span>);<span class="comment">//初始化原子类型变量v,并设置为1</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(atomic64_read(&amp;v) != <span class="number">1</span>)&#123;<span class="comment">//读取原子类型变量v的值并判断是否等于1</span></span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line">	atomic64_set(&amp;v,<span class="number">0</span>);<span class="comment">//将原子类型变量v的值设置为0</span></span><br><span class="line">	<span class="comment">//printk(&quot;\nthis is open_test \n&quot;);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//printk(&quot;\nthis is release_test \n&quot;);</span></span><br><span class="line">	atomic64_set(&amp;v,<span class="number">1</span>);<span class="comment">//将原子类型变量v的值赋1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">	dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="20-2-2-编写测试-APP"><a href="#20-2-2-编写测试-APP" class="headerlink" title="20.2.2 编写测试 APP"></a>20.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\15\app。</p>
<p>本测试app代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-3-运行测试"><a href="#20-3-运行测试" class="headerlink" title="20.3 运行测试"></a>20.3 运行测试</h2><h3 id="20-3-1-编译驱动程序"><a href="#20-3-1-编译驱动程序" class="headerlink" title="20.3.1 编译驱动程序"></a>20.3.1 编译驱动程序</h3><p>在上一小节中的atomic.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += atomic.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放atomic.c和Makefile文件目录下，如下图（图20-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps122.jpg" alt="img"> </p>
<p>图 20-4</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图20-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps123.jpg" alt="img"> </p>
<p>图 20-5</p>
<p>编译完生成atomic.ko目标文件，如下图（图20-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps124.jpg" alt="img"> </p>
<p>图 20-6</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h3 id="20-3-2-编译应用程序"><a href="#20-3-2-编译应用程序" class="headerlink" title="20.3.2 编译应用程序"></a>20.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图20-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps125.jpg" alt="img"> </p>
<p>图 20-7</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图20-8）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps126.jpg" alt="img"> </p>
<p>图 20-8</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="20-3-3-运行测试"><a href="#20-3-3-运行测试" class="headerlink" title="20.3.3 运行测试"></a>20.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图20-9）所示：</p>
<p>insmod atomic.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps127.jpg" alt="img"> </p>
<p>图 20-9</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图20-10）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps128.jpg" alt="img"> </p>
<p>图 20-10</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图20-11）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps129.jpg" alt="img"> </p>
<p>图 20-11</p>
<p>可以看到传递的buf值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图20-12）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet &amp;</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test itop </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps130.jpg" alt="img"> </p>
<p>图 20-12</p>
<p>​	可以看到应用程序在打开第二次&#x2F;dev&#x2F;device_test 文件的时候，出现了“file open failed”打印，证明文件打开失败，只有在第一个应用关闭相应的文件之后，下一个应用才能打开，通过限制同一时间内设备访问数量，来对共享资源进行保护。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图20-13）所示：</p>
<p>rmmod flag.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps131.jpg" alt="img"> </p>
<p>图 20-13</p>
<p>至此，原子操作实验就完成了。</p>
<h1 id="第21章-自旋锁实验"><a href="#第21章-自旋锁实验" class="headerlink" title="第21章 自旋锁实验"></a>第21章 自旋锁实验</h1><p>在上一节中对原子操作进行了讲解，并使用原子整形操作对并发与竞争实验进行了改进，但是原子操作只能对整形变量或者位进行保护，而对于结构体或者其他类型的共享资源，原子操作就力不从心了，这时候就轮到自旋锁的出场了，下面就让我们一起来进行自旋锁的学习吧。</p>
<h2 id="21-1-自旋锁"><a href="#21-1-自旋锁" class="headerlink" title="21.1 自旋锁"></a>21.1 自旋锁</h2><p>自旋锁是为了保护共享资源提出的一种锁机制。自旋锁（spin lock）是一种非阻塞锁，也就是说，如果某线程需要获取锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取锁。</p>
<p>在有些场景中，同步资源(用来保持一致性的两个或多个资源)的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果计算机有多个CPU核心，能够让两个或以上的线程同时并行执行，这样我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，直到持有锁的线程释放锁，后面请求锁的线程才可以获取锁。</p>
<p>为了让后面那个请求锁的线程“稍等一下”，我们需让它进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么该线程便不必阻塞，并且直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。我们再举个形象生动的例子，以现实生活中银行ATM机办理业务为例，ATM机防护舱在同一时间内只允许一个人进入，当有人进入ATM机防护舱之后，两秒钟之后自动上锁，其他也想要存取款的人员，只能在外部等待，办理完相应的存取款业务之后，舱内人员需要手动打开防护锁，其他人才能进入其中，办理业务。而自旋锁在驱动中的使用和上述ATM机办理业务流程相同，当一个任务要访问某个共享资源之前需要先获取相应的自旋锁，自旋锁只能被一个任务持有，在该任务持有自旋锁的过程中，其他任务只能原地等待该自旋锁的释放，在等待过程中的任务同样会持续占用CPU，消耗CPU资源，所以临界区的代码不能太多。</p>
<p>如果自旋锁被错误使用可能会导致死锁的产生，对于自旋锁死锁会在下一章节进行详细说明，并进行相应的实验。</p>
<p>内核中以spinlock_t结构体来表示自旋锁，定义在“内核源码&#x2F;include&#x2F;linux&#x2F;spinlock_types.h”文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            u8 __padding[LOCK_PADSIZE];</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     &#125;;</span><br><span class="line">&#125; <span class="type">spinlock_t</span>;</span><br></pre></td></tr></table></figure>

<p>自旋锁相关API函数定义在“内核源码&#x2F;include&#x2F;linux&#x2F;spinlock.h”文件中，所以在本章节的实验中要加入该头文件（spinlock.h头文件包含spinlock_types.h等，所以只需加入spinlock.h头文件即可），部分API函数如下（表 21-1）所示，</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_SPINLOCK(spinlock_t lock)</td>
<td>定义并初始化自旋锁。</td>
</tr>
<tr>
<td>int spin_lock_init(spinlock_t *lock)</td>
<td>初始化自旋锁。</td>
</tr>
<tr>
<td>void spin_lock(spinlock_t *lock)</td>
<td>获取指定的自旋锁，也叫做加锁。</td>
</tr>
<tr>
<td>void spin_unlock(spinlock_t *lock)</td>
<td>释放指定的自旋锁。</td>
</tr>
<tr>
<td>int spin_trylock(spinlock_t *lock)</td>
<td>尝试获取指定的自旋锁，如果没有获取到就返回 0</td>
</tr>
<tr>
<td>int spin_is_locked(spinlock_t *lock)</td>
<td>检查指定的自旋锁是否被获取，如果没有被获取就返回非0，否则返回 0。</td>
</tr>
</tbody></table>
<p>表 21-1</p>
<p>除了上述API之外还有其他与终端相关的自旋锁API函数，会在接下来的自旋锁死锁章节进行讲解。</p>
<p>自旋锁的使用步骤：</p>
<p>1 在访问临界资源的时候先申请自旋锁</p>
<p>2 获取到自旋锁之后就进入临界区，获取不到自旋锁就“原地等待”。</p>
<p>3 退出临界区的时候要释放自旋锁。</p>
<p>在下一小节中将使用上述自旋锁API进行相应的实验，利用自旋锁相关知识来对第19章节的并发与竞争实验进行优化。</p>
<h2 id="21-2-实验程序的编写"><a href="#21-2-实验程序的编写" class="headerlink" title="21.2 实验程序的编写"></a>21.2 实验程序的编写</h2><h3 id="21-2-1-驱动程序编写"><a href="#21-2-1-驱动程序编写" class="headerlink" title="21.2.1 驱动程序编写"></a>21.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\16\module。</p>
<p>与上一章节使用原子整形操作避免并发与竞争逻辑相同，在驱动入口函数初始化自旋锁，然后在open函数中使用自旋锁实现对设备的互斥访问，最后在 release 函数中解锁，表示设备被释放了，可以被其他的应用程序使用。上述操作都将共享资源由自旋锁进行保护，从而实现同一时间内只允许一个应用打开该设备节点，以此来防止共享资源竞争的产生。</p>
<p>编写完成的spinlock.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">spinlock_t</span> spinlock_test;<span class="comment">//定义spinlock_t类型的自旋锁变量spinlock_test</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> flag = <span class="number">1</span>;<span class="comment">//定义flag标准为，flag等于1表示设备没有被打开，等于0则证明设备已经被打开了</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//printk(&quot;\nthis is open_test \n&quot;);</span></span><br><span class="line">	spin_lock(&amp;spinlock_test);<span class="comment">//自旋锁加锁</span></span><br><span class="line">	<span class="keyword">if</span>(flag != <span class="number">1</span>)&#123;<span class="comment">//判断标志位flag的值是否等于1</span></span><br><span class="line">spin_unlock(&amp;spinlock_test);<span class="comment">//自旋锁解锁</span></span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line">	 &#125;</span><br><span class="line">	flag = <span class="number">0</span>;<span class="comment">//将标志位的值设置为0</span></span><br><span class="line">	spin_unlock(&amp;spinlock_test);<span class="comment">//自旋锁解锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;\nthis is release_test \n&quot;</span>);</span><br><span class="line">	spin_lock(&amp;spinlock_test);<span class="comment">//自旋锁加锁</span></span><br><span class="line">	flag = <span class="number">1</span>;</span><br><span class="line">	spin_unlock(&amp;spinlock_test);<span class="comment">//自旋锁解锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	spin_lock_init(&amp;spinlock_test);</span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">	dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="21-2-2-编写测试-APP"><a href="#21-2-2-编写测试-APP" class="headerlink" title="21.2.2 编写测试 APP"></a>21.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\16\app。</p>
<p>本测试app代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="21-3-运行测试"><a href="#21-3-运行测试" class="headerlink" title="21.3 运行测试"></a>21.3 运行测试</h2><h3 id="21-3-1-编译驱动程序"><a href="#21-3-1-编译驱动程序" class="headerlink" title="21.3.1 编译驱动程序"></a>21.3.1 编译驱动程序</h3><p>在上一小节中的spinlock.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += spinlock.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放spinlock.c和Makefile文件目录下，如下图（图21-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps132.jpg" alt="img"> </p>
<p>图 21-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图21-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps133.jpg" alt="img"> </p>
<p>图 21-3</p>
<p>编译完生成spinlock.ko目标文件，如下图（图21-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps134.jpg" alt="img"> </p>
<p>图 21-4</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h3 id="21-3-2-编译应用程序"><a href="#21-3-2-编译应用程序" class="headerlink" title="21.3.2 编译应用程序"></a>21.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图21-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps135.jpg" alt="img"> </p>
<p>图 21-5</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图21-6）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps136.jpg" alt="img"> </p>
<p>图 21-6</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="21-3-3-运行测试"><a href="#21-3-3-运行测试" class="headerlink" title="21.3.3 运行测试"></a>21.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图21-7）所示：</p>
<p>insmod spinlock.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps137.jpg" alt="img"> </p>
<p>图21-7</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（21-8）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps138.jpg" alt="img"> </p>
<p>图 21-8</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图21-9）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps139.jpg" alt="img"> </p>
<p>图 21-9</p>
<p>可以看到传递的buf值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图21-10）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet &amp;</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test itop </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps140.jpg" alt="img"> </p>
<p>图 21-10</p>
<p>​	可以看到应用程序在打开第二次&#x2F;dev&#x2F;device_test 文件的时候，出现了“file open failed”打印，证明文件打开失败，只有在第一个应用关闭相应的文件之后，下一个应用才能打开。本次实验的自旋锁只是对标志位flag进行保护，flag用来表示设备的状态，确保同一时间内，该设备只能被一个应用程序打开。进而对共享资源进行保护。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图21-11）所示：</p>
<p>rmmod spinlock.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps141.jpg" alt="img"> </p>
<p>图 21-11</p>
<p>至此，自旋锁实验就完成了。</p>
<h1 id="第22章-自旋锁死锁实验"><a href="#第22章-自旋锁死锁实验" class="headerlink" title="**** ****第22章 自旋锁死锁实验"></a>**** ****第22章 自旋锁死锁实验</h1><p>在上一小节中，学习了内核中自旋锁的使用，而自旋锁若是使用不当就会产生死锁，在本章将会对自旋锁的特殊情况-死锁进行讲解。</p>
<h2 id="22-1-自旋锁死锁"><a href="#22-1-自旋锁死锁" class="headerlink" title="22.1 自旋锁死锁"></a>22.1 自旋锁死锁</h2><p>死锁是指两个或多个事物在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。当多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进，这种情况就是死锁。</p>
<p>自旋锁死锁发生存在两种情况：</p>
<p>（1）第一种情况是拥有自旋锁的进程A在内核态阻塞了，内核调度B进程，碰巧B进程也要获得自旋锁，此时B只能自旋转。而此时抢占已经关闭(在单核条件下)不会调度A进程了，B永远自旋，产生死锁，如下图（图 22-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps142.jpg" alt="img"> </p>
<p>图 22-1</p>
<p>相应的解决办法是，在自旋锁的使用过程中要尽可能短的时间内拥有自旋锁，而且不能在临界区中调用导致线程休眠的函数。</p>
<p>第二种情况是进程A拥有自旋锁，中断到来，CPU执行中断函数，中断处理函数，中断处理函数需要获得自旋锁，访问共享资源，此时无法获得锁，只能自旋，从而产生死锁，如下图（图22-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps143.jpg" alt="img"> </p>
<p>图 22-2</p>
<p>对于中断引发的死锁，最好的解决方法就是在获取锁之前关闭本地中断，Linux内核在“&#x2F;include&#x2F;linux&#x2F;spinlock.h”文件中提供了相应的API 函数，如下（图22-3）所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void spin_lock_irq(spinlock_t *lock)</td>
<td>禁止本地中断，并获取自旋锁。</td>
</tr>
<tr>
<td>void spin_unlock_irq(spinlock_t *lock)</td>
<td>激活本地中断，并释放自旋锁。</td>
</tr>
<tr>
<td>void spin_lock_irqsave(spinlock_t *lock, unsigned long flags)</td>
<td>恢复中断状态，关闭中断并获取自旋锁。</td>
</tr>
<tr>
<td>void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)</td>
<td>将中断状态恢复到以前的状态，打开中断并释放自旋锁</td>
</tr>
<tr>
<td>void spin_lock_bh(spinlock_t *lock)</td>
<td>关闭下半部，获取自旋锁</td>
</tr>
<tr>
<td>void spin_unlock_bh(spinlock_t *lock)</td>
<td>打开下半部，获取自旋锁</td>
</tr>
</tbody></table>
<p>表 22-3</p>
<p>由于Linux内核运行是非常复杂的，很难确定某个时刻的中断状态，因此建议使用 spin_lock_irqsave&#x2F;spin_unlock_irqrestore，因为这一组函数会保存中断状态，在释放锁的时候会恢复中断状态。</p>
<p>在下一小节中将进行自旋锁死锁实验，本次实验所采取的是第一种情况，即拥有自旋锁的进程A在内核态阻塞了，内核调度B进程，碰巧B进程也要获得自旋锁，依次产生死锁。</p>
<h2 id="22-2-实验程序的编写"><a href="#22-2-实验程序的编写" class="headerlink" title="22.2 实验程序的编写"></a>22.2 实验程序的编写</h2><h3 id="22-2-1-驱动程序编写"><a href="#22-2-1-驱动程序编写" class="headerlink" title="22.2.1 驱动程序编写"></a>22.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\17\module。</p>
<p>本章节实验以19章并发与竞争实验为基础，在open()函数中加入了自旋锁加锁，在close()函数中加入了自旋锁解锁，由于在write()函数中存在sleep()睡眠函数，所以会造成内核阻塞，睡眠期间如果使用另一个进程获取该自旋锁，就会造成死锁。</p>
<p>编写完成的dielock.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">spinlock_t</span> spinlock_test;<span class="comment">//定义spinlock_t类型的自旋锁变量spinlock_test</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//printk(&quot;\nthis is open_test \n&quot;);</span></span><br><span class="line">	spin_lock(&amp;spinlock_test);<span class="comment">//自旋锁加锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;\nthis is release_test \n&quot;</span>);</span><br><span class="line">	spin_unlock(&amp;spinlock_test);<span class="comment">//自旋锁解锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	spin_lock_init(&amp;spinlock_test);</span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">	dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="22-2-2-编写测试-APP"><a href="#22-2-2-编写测试-APP" class="headerlink" title="22.2.2 编写测试 APP"></a>22.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\17\app。</p>
<p>本测试app代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于本次测试的CPU为多核心CPU，其他核心仍旧可以调度其他进程，所以需要多次使用taskset函数指定CPU进行进程的运行，以此来产生死锁，在与app.c同级目录下创建名为app.sh的脚本文件，脚本内容如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">taskset -c 0 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 1 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 2 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 3 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 0 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 1 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 2 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 3 ./app /dev/device_test topeet &amp;</span><br></pre></td></tr></table></figure>

<p>保存退出之后，需要使用以下命令赋予脚本可执行权限，如下图（图22-4）所示：</p>
<p>chmod 777 app.sh</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps144.jpg" alt="img"> </p>
<p>图 22-4</p>
<p>至此测试程序app.c和运行脚本app.sh就编写完成了。</p>
<h2 id="22-3-运行测试"><a href="#22-3-运行测试" class="headerlink" title="22.3 运行测试"></a>22.3 运行测试</h2><h3 id="22-3-1-编译驱动程序"><a href="#22-3-1-编译驱动程序" class="headerlink" title="22.3.1 编译驱动程序"></a>22.3.1 编译驱动程序</h3><p>在上一小节中的dielock.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += dielock.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放dielock.c和Makefile文件目录下，如下图（图22-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps145.jpg" alt="img"> </p>
<p>图 22-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图22-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps146.jpg" alt="img"> </p>
<p>图 22-6</p>
<p>编译完生成dielock.ko目标文件，如下图（图22-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps147.jpg" alt="img"> </p>
<p>图 22-7</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h3 id="22-3-2-编译应用程序"><a href="#22-3-2-编译应用程序" class="headerlink" title="22.3.2 编译应用程序"></a>22.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图22-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps148.jpg" alt="img"> </p>
<p>图 22-8</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图22-9）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps149.jpg" alt="img"> </p>
<p>图 22-9</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="22-3-3-运行测试"><a href="#22-3-3-运行测试" class="headerlink" title="22.3.3 运行测试"></a>22.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图22-10）所示：</p>
<p>insmod dielock.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps150.jpg" alt="img"> </p>
<p>图 22-10</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图22-11）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps151.jpg" alt="img"> </p>
<p>图 22-11</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行app.sh脚本，该脚本会指定CPU在加锁之后进入内核休眠状态，如下图（图22-12）所示：</p>
<p>.&#x2F;app.sh</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps152.jpg" alt="img"> </p>
<p>图 22-12</p>
<p>​	在指令输入之后，串口终端无法输入，引发了死锁，进而造成了系统崩溃，所以在编写驱动的过程中，要尽可能的避免死锁的出现。</p>
<p>至此，自旋锁死锁驱动实验就完成了。</p>
<h1 id="第23章-信号量实验"><a href="#第23章-信号量实验" class="headerlink" title="第23章 信号量实验"></a>第23章 信号量实验</h1><p>在上面两个章节对自旋锁和自旋锁死锁进行了学习，自旋锁会让请求的任务原地“自旋”，在等待的过程中会循环检测自旋锁的状态，进而占用系统资源，而本章节要讲解的信号量也是解决竞争的一种常用方法，与自旋锁不同的是，信号量会使等待的线程进入休眠状态，适用于那些占用资源比较久的场合。下面对信号量相关知识的进行讲解。</p>
<h2 id="23-1-信号量"><a href="#23-1-信号量" class="headerlink" title="23.1 信号量"></a>23.1 信号量</h2><p>信号量是操作系统中最典型的用于同步和互斥的手段，本质上是一个全局变量，信号量的值表示控制访问资源的线程数，可以根据实际情况来自行设置，如果在初始化的时候将信号量量值设置为大于1，那么这个信号量就是计数型信号量，允许多个线程同时访问共享资源。如果将信号量量值设置为1，那么这个信号量就是二值信号量，同一时间内只允许一个线程访问共享资源，注意！信号量的值不能小于0。当信号量的值为0时，想访问共享资源的线程必须等待，直到信号量大于0时，等待的线程才可以访问。当访问共享资源时，信号量执行“减一”操作，访问完成后再执行“加一”操作。</p>
<p>相比于自旋锁，信号量具有休眠特性，因此适用长时间占用资源的场合，但由于信号量会引起休眠，所以不能用在中断函数中，最后如果共享资源的持有时间比较短，使用信号量的话会造成频繁的休眠，反而带来更多资源的消耗，使用自旋锁反而效果更好。再同时使用信号量和自旋锁的时候，要先获取信号量，再使用自旋锁，因为信号量会导致睡眠。</p>
<p>以现实生活中的银行办理业务为例，银行的业务办理窗口就是共享资源，业务办理窗口的数量就是信号量量值，进入银行之后，客户需要领取相应的排序码，然后在休息区进行等待，可以看作线程的睡眠阶段，当前面的客户办理完业务之后，相应的窗口会空闲出来，可以看作信号量的释放，之后银行会通过广播，提醒下一位客户到指定的窗口进行业务的办理，可以看作线程的唤醒并获取到信号量，访问共享资源的过程。</p>
<p>Linux 内核使用semaphore结构体来表示信号量，该结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;semaphore.h”文件内（所以在下一章节的信号量实验中需要加入该头文件），结构体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="type">raw_spinlock_t</span>      lock;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 与信号量相关的 API 函数同样定义在semaphore.h文件内，部分常用API函数如下（表23-1）所示： </p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_SEAMPHORE(name)</td>
<td>定义信号量，并且设置信号量的值为 1。</td>
</tr>
<tr>
<td>void sema_init(struct semaphore *sem, int val)</td>
<td>初始化信号量 sem，设置信号量值为 val。</td>
</tr>
<tr>
<td>void down(struct semaphore *sem)</td>
<td>获取信号量，不能被中断打断，如ctrl+c</td>
</tr>
<tr>
<td>int down_interruptible(struct semaphore *sem)</td>
<td>获取信号量，可以被中断打断，如ctrl+c</td>
</tr>
<tr>
<td>void up(struct semaphore *sem)</td>
<td>释放信号量</td>
</tr>
<tr>
<td>int down_trylock(struct semaphore *sem);</td>
<td>尝试获取信号量，如果能获取到信号量就获取，并且返回 0。如果不能就返回非 0</td>
</tr>
</tbody></table>
<p>表 23-1</p>
<p>至此，关于信号量相关的知识就讲解完成了，上述API函数会在下一小节的实验中用到。</p>
<h2 id="23-2-实验程序的编写"><a href="#23-2-实验程序的编写" class="headerlink" title="23.2 实验程序的编写"></a>23.2 实验程序的编写</h2><h3 id="23-2-1-驱动程序编写"><a href="#23-2-1-驱动程序编写" class="headerlink" title="23.2.1 驱动程序编写"></a>23.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\18\module。</p>
<p>与之前章节设置标志位，在同一时间内只允许一个任务对共享资源进行访问的方式所不同，本小节将采用信号量的方式避免竞争的产生。本实验设置的信号量量值为1，所以需要在open()函数中加入信号量获取函数，在release()函数中加入信号量释放函数即可。</p>
<p>编写完成的semaphore.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">semaphore_test</span>;</span><span class="comment">//定义一个semaphore类型的结构体变量semaphore_test</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;\nthis is open_test \n&quot;</span>);</span><br><span class="line">down(&amp;semaphore_test);<span class="comment">//信号量数量减1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">up(&amp;semaphore_test);<span class="comment">//信号量数量加1</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is release_test \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	sema_init(&amp;semaphore_test,<span class="number">1</span>);<span class="comment">//初始化信号量结构体semaphore_test，并设置信号量的数量为1</span></span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">	dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="23-2-2-编写测试-APP"><a href="#23-2-2-编写测试-APP" class="headerlink" title="23.2.2 编写测试 APP"></a>23.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\18\app。</p>
<p>本测试app代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="23-3-运行测试"><a href="#23-3-运行测试" class="headerlink" title="23.3 运行测试"></a>23.3 运行测试</h2><h3 id="23-3-1-编译驱动程序"><a href="#23-3-1-编译驱动程序" class="headerlink" title="23.3.1 编译驱动程序"></a>23.3.1 编译驱动程序</h3><p>在上一小节中的semaphore.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += semaphore.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放semaphore.c和Makefile文件目录下，如下图（图23-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps153.jpg" alt="img"> </p>
<p>图 23-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图23-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps154.jpg" alt="img"> </p>
<p>图 23-3</p>
<p>编译完生成semaphore.ko目标文件，如下图（图23-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps155.jpg" alt="img"> </p>
<p>图 23-4</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的安装。</p>
<h3 id="23-3-2-编译应用程序"><a href="#23-3-2-编译应用程序" class="headerlink" title="23.3.2 编译应用程序"></a>23.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图 23-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps156.jpg" alt="img"> </p>
<p>图 23-5</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图23-6）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps157.jpg" alt="img"> </p>
<p>图23-6</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="23-3-3-运行测试"><a href="#23-3-3-运行测试" class="headerlink" title="23.3.3 运行测试"></a>23.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 23-7）所示：</p>
<p>insmod semaphore.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps158.jpg" alt="img"> </p>
<p>图 23-7</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图23-8）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps159.jpg" alt="img"> </p>
<p>图 23-8</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图23-9）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps160.jpg" alt="img"> </p>
<p>图 23-9</p>
<p>可以看到传递的buf值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图23-10）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet &amp;</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test itop </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps161.jpg" alt="img"> </p>
<p>图 23-10</p>
<p>​	上述打印信息正常，证明数据被正确传递了，没有发生共享资源的竞争，第一个任务运行之后，由于设置的信号量量值为1，所以第二个任务会进入休眠状态，第一个任务执行完毕之后，会唤醒第二个任务去执行，所以避免了并发与竞争。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图 23-11）所示：</p>
<p>rmmod semaphore.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps162.jpg" alt="img"> </p>
<p>图 23-11</p>
<p>至此，信号量实验就完成了。</p>
<h1 id="第24章-互斥锁实验"><a href="#第24章-互斥锁实验" class="headerlink" title="第24章 互斥锁实验"></a>第24章 互斥锁实验</h1><p>在上一章节中对信号量进行了学习，而本章节要学习的互斥锁可以说是“量值”为 1 的信号量，最终实现的效果相同，既然有了信号量，那为什么还要有互斥锁呢，带着疑问，让我们来进行本章节的学习吧！</p>
<h2 id="24-1-互斥锁"><a href="#24-1-互斥锁" class="headerlink" title="24.1 互斥锁"></a>24.1 互斥锁</h2><p>在上一章节中，将信号量量值设置为1，最终实现的就是互斥效果，与本章节要学习的互斥锁功能相同，虽然两者功能相同但是具体的实现方式是不同的，但是使用互斥锁效率更高、更简洁，所以如果使用到的信号量“量值”为 1，一般将其修改为使用互斥锁实现。</p>
<p>当有多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制。线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。互斥锁为资源引入一个状态：锁定或者非锁定。某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性，能够保证多个线程访问共享数据不会出现资源竞争及数据错误。</p>
<p>为了方便大家理解，这里举个例子来说明。比如公司部门里，我在使用着打印机打印东西的同时（还没有打印完），别人刚好也在此刻使用打印机打印东西，如果不做任何处理的话，打印出来的东西肯定是错乱的。那么怎么解决这种情况呢？只要我在打印着的时候别人是不允许打印的，只有等我打印结束后别人才允许打印。这个过程有点类似于，把打印机放在一个房间里，给这个房间安把锁，这个锁默认是打开的。当 A 需要打印时，他先过来检查这把锁有没有锁着，没有的话就进去，同时上锁在房间里打印。而在这时，刚好 B 也需要打印，B 同样先检查锁，发现锁是锁住的，他就在门外等着。而当 A 打印结束后，他会开锁出来，这时候 B 才进去上锁打印。看了这个例子，相信大家已经理解了互斥锁。</p>
<p>互斥锁会导致休眠，所以在中断里面不能用互斥锁。同一时刻只能有一个线程持有互斥锁，并且只有持有者才可以解锁，并且不允许递归上锁和解锁。</p>
<p>内核中以mutex结构体来表示互斥体，定义在“内核源码&#x2F;include&#x2F;linux&#x2F;mutex.h”文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_long_t</span>       owner;</span><br><span class="line">    <span class="type">spinlock_t</span>      wait_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MUTEX_SPIN_ON_OWNER</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">optimistic_spin_queue</span> <span class="title">osq</span>;</span> <span class="comment">/* Spinner MCS lock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">    <span class="type">void</span>            *magic;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>  <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一些和互斥体相关的API函数也定义在mutex.h文件中，常用API函数如下（表24-1）所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_MUTEX(name)</td>
<td>定义并初始化一个 mutex 变量。</td>
</tr>
<tr>
<td>void mutex_init(mutex *lock)</td>
<td>初始化 mutex。</td>
</tr>
<tr>
<td>void mutex_lock(struct mutex *lock)</td>
<td>获取 mutex，也就是给 mutex 上锁。如果获取不到就进休眠。</td>
</tr>
<tr>
<td>void mutex_unlock(struct mutex *lock)</td>
<td>释放 mutex，也就给 mutex 解锁。</td>
</tr>
<tr>
<td>int mutex_is_locked(struct mutex *lock)</td>
<td>判断 mutex 是否被获取，如果是的话就返回1，否则返回 0。</td>
</tr>
</tbody></table>
<p>表 24-1</p>
<p>至此，关于互斥体相关的知识就讲解完成了，在下一小节的实验中会对上述API函数进行运用。</p>
<h2 id="24-2-实验程序的编写"><a href="#24-2-实验程序的编写" class="headerlink" title="24.2 实验程序的编写"></a>24.2 实验程序的编写</h2><h3 id="24-2-1-驱动程序编写"><a href="#24-2-1-驱动程序编写" class="headerlink" title="24.2.1 驱动程序编写"></a>24.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\19\module。</p>
<p>本小节实验将使用互斥体对19章的并发与竞争实验进行改进，由于互斥体在同一时间内只允许一个任务对共享资源进行，所以除了在atomic_init()函数内加入初始化互斥锁函数之外，只需要在open()函数中加入互斥锁加锁函数，在release()函数中加入互斥锁解锁函数即可。</p>
<p>编写完成的mutex.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex_test</span>;</span><span class="comment">//定义mutex类型的互斥锁结构体变量mutex_test</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;\nthis is open_test \n&quot;</span>);</span><br><span class="line">	mutex_lock(&amp;mutex_test);<span class="comment">//互斥锁加锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex_unlock(&amp;mutex_test);<span class="comment">//互斥锁解锁</span></span><br><span class="line">printk(<span class="string">&quot;\nthis is release_test \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex_init(&amp;mutex_test);<span class="comment">//对互斥体进行初始化</span></span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">	dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="24-2-2-编写测试-APP"><a href="#24-2-2-编写测试-APP" class="headerlink" title="24.2.2 编写测试 APP"></a>24.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\19\app。</p>
<p>本测试app代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24-3-运行测试"><a href="#24-3-运行测试" class="headerlink" title="24.3 运行测试"></a>24.3 运行测试</h2><h3 id="24-3-1-编译驱动程序"><a href="#24-3-1-编译驱动程序" class="headerlink" title="24.3.1 编译驱动程序"></a>24.3.1 编译驱动程序</h3><p>在上一小节中的mutex.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += mutex.c    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放mutex.c和Makefile文件目录下，如下图（图24-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps163.jpg" alt="img"> </p>
<p>图 24-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图24-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps164.jpg" alt="img"> </p>
<p>图24-3</p>
<p>编译完生成mutex.ko目标文件，如下图（图 24-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps165.jpg" alt="img"> </p>
<p>图 24-4</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h3 id="24-3-2-编译应用程序"><a href="#24-3-2-编译应用程序" class="headerlink" title="24.3.2 编译应用程序"></a>24.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图 24-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps166.jpg" alt="img"> </p>
<p>图 24-5</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图 24-6）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps167.jpg" alt="img"> </p>
<p>图 24-6</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="24-3-3-运行测试"><a href="#24-3-3-运行测试" class="headerlink" title="24.3.3 运行测试"></a>24.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图24-7）所示：</p>
<p>insmod mutex.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps168.jpg" alt="img"> </p>
<p>图 24-7</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图24-8）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps169.jpg" alt="img"> </p>
<p>图 24-8</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图24-9）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps170.jpg" alt="img"> </p>
<p>图 24-9</p>
<p>可以看到传递的buf值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图24-10）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet &amp;</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test itop </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps171.jpg" alt="img"> </p>
<p>图 24-10</p>
<p>​	与23章实验测试现象相同，两个app被同时运行，最终打印信息正常，证明数据被正确传递了，没有发生共享资源的竞争，证明互斥量就起到了作用。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图24-11）所示：</p>
<p>rmmod mutex.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps172.jpg" alt="img"> </p>
<p>图 24-11</p>
<p>至此，互斥体实验就完成了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/" rel="tag">并发与竞争</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="热爱学习的未来酱"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>