<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="永远年轻，永远热泪盈眶" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 热爱学习的未来酱</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="热爱学习的未来酱" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover3.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">热爱学习的未来酱</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '向上的路，并不拥挤。拥挤是因为，大部分人选择了安逸', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-1-68-ranges属性实验"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/1-68-ranges%E5%B1%9E%E6%80%A7%E5%AE%9E%E9%AA%8C/"
    >1-68-ranges属性实验</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/1-68-ranges%E5%B1%9E%E6%80%A7%E5%AE%9E%E9%AA%8C/" class="article-date">
  <time datetime="2023-09-05T00:01:42.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第68章-ranges属性实验"><a href="#第68章-ranges属性实验" class="headerlink" title="第68章 ranges属性实验"></a>第68章 ranges属性实验</h1><h1 id="68-1-platform-get-resource获取设备树资源"><a href="#68-1-platform-get-resource获取设备树资源" class="headerlink" title="68.1 platform_get_resource获取设备树资源"></a>68.1 platform_get_resource获取设备树资源</h1><p>在上个章节中讲解了使用of操作函数来获取设备树的属性，由于设备树在系统启动的时候都会转化为platform设备，那我们能不能直接在驱动中使用在53.1小节中讲解的platform_get_resource函数直接获取platform_device资源呢？</p>
<h3 id="68-1-1-驱动程序编写"><a href="#68-1-1-驱动程序编写" class="headerlink" title="68.1.1 驱动程序编写"></a>68.1.1 驱动程序编写</h3><p>带着疑惑我们这里仍旧以65章的驱动程序为原型，在probe函数中加入使用platform_get_resource函数获取reg资源的函数，添加完成的驱动程序内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mod_devicetable.h&gt;</span></span></span><br><span class="line"><span class="comment">// 平台设备的初始化函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">myresources</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_probe: Probing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取平台设备的资源</span></span><br><span class="line">    myresources = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (myresources == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果获取资源失败，打印value_compatible的值</span></span><br><span class="line">        printk(<span class="string">&quot;platform_get_resource is error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">&quot;reg valus is %llx\n&quot;</span> , myresources-&gt;start); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Removing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table_id</span>[]  =</span> &#123;</span><br><span class="line">	&#123;.compatible=<span class="string">&quot;my devicetree&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">		.of_match_table =  of_match_table_id,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>编译成模块之后，放到开发板上进行加载，打印信息如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025476.jpeg" alt="img"> </p>
<p>可以看到使用platform_get_resource函数获取reg资源的函数失败了，在下一个小节中将分析获取资源失败的原因。</p>
<h3 id="68-1-2-分析获取资源失败"><a href="#68-1-2-分析获取资源失败" class="headerlink" title="68.1.2 分析获取资源失败"></a>68.1.2 分析获取资源失败</h3><p>platform_get_resource定义在内核源码目录下的”&#x2F;drivers&#x2F;base&#x2F;platform.c”目录下，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *dev,</span></span><br><span class="line"><span class="params">				       <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dev-&gt;num_resources; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">r</span> =</span> &amp;dev-&gt;resource[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (type == resource_type(r) &amp;&amp; num-- == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数返回NULL符合第一小节中的情况，返回NULL的情况有两种可能性，一种是没进入上面的for循环直接返回了NULL，另外一种是进入了for循环，但是类型匹配不正确，跳出for循环之后再返回NULL。这里的类型一定是匹配的，所以我们就来寻找为什么没有进入for循环，这里只有一种可能，也就是dev-&gt;num_resources为0。</p>
<p>所以现在的目标来到了寻找dev-&gt;num_resources是在哪里进行的赋值，前面已经讲解过了由设备树转换为platform的过程，而且在系统启动后，在对应目录下也有了相应的节点： <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025423.png"></p>
<p>​	证明转换是没问题的，所以继续寻找中间转换过程中有关资源数量的相关函数，定位到了of_platform_device_create_pdata函数，该函数定义在内核源码目录下的“drivers&#x2F;of&#x2F;platform.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> platform_device *<span class="title function_">of_platform_device_create_pdata</span><span class="params">(</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">					<span class="type">const</span> <span class="type">char</span> *bus_id,</span></span><br><span class="line"><span class="params">					<span class="type">void</span> *platform_data,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> device *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查设备节点是否可用或已填充 */</span></span><br><span class="line">	<span class="keyword">if</span> (!of_device_is_available(np) ||</span><br><span class="line">	    of_node_test_and_set_flag(np, OF_POPULATED))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 分配平台设备结构体 */</span></span><br><span class="line">	dev = of_device_alloc(np, bus_id, parent);</span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">goto</span> err_clear_flag;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置平台设备的一些属性 */</span></span><br><span class="line">	dev-&gt;dev.coherent_dma_mask = DMA_BIT_MASK(<span class="number">32</span>);</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;dev.dma_mask)</span><br><span class="line">		dev-&gt;dev.dma_mask = &amp;dev-&gt;dev.coherent_dma_mask;</span><br><span class="line">	dev-&gt;dev.bus = &amp;platform_bus_type;</span><br><span class="line">	dev-&gt;dev.platform_data = platform_data;</span><br><span class="line">	of_msi_configure(&amp;dev-&gt;dev, dev-&gt;dev.of_node);</span><br><span class="line">	of_reserved_mem_device_init_by_idx(&amp;dev-&gt;dev, dev-&gt;dev.of_node, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将平台设备添加到设备模型中 */</span></span><br><span class="line">	<span class="keyword">if</span> (of_device_add(dev) != <span class="number">0</span>) &#123;</span><br><span class="line">		platform_device_put(dev);</span><br><span class="line">		<span class="keyword">goto</span> err_clear_flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev;</span><br><span class="line"></span><br><span class="line">err_clear_flag:</span><br><span class="line">	<span class="comment">/* 清除设备节点的已填充标志 */</span></span><br><span class="line">	of_node_clear_flag(np, OF_POPULATED);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>​	第15行：函数调用 of_device_alloc 分配一个平台设备结构体，并将设备节点指针、设备标识符和父设备指针传递给它，正是该函数决定的resource.num,然后找到该函数的定义，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> platform_device *<span class="title function_">of_device_alloc</span><span class="params">(<span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">				  <span class="type">const</span> <span class="type">char</span> *bus_id,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> device *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">int</span> rc, i, num_reg = <span class="number">0</span>, num_irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>, <span class="title">temp_res</span>;</span></span><br><span class="line"></span><br><span class="line">	dev = platform_device_alloc(<span class="string">&quot;&quot;</span>, PLATFORM_DEVID_NONE);</span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* count the io and irq resources */</span></span><br><span class="line">	<span class="keyword">while</span> (of_address_to_resource(np, num_reg, &amp;temp_res) == <span class="number">0</span>)</span><br><span class="line">		num_reg++;</span><br><span class="line">	num_irq = of_irq_count(np);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Populate the resource table */</span></span><br><span class="line">	<span class="keyword">if</span> (num_irq || num_reg) &#123;</span><br><span class="line">		res = kcalloc(num_irq + num_reg, <span class="keyword">sizeof</span>(*res), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!res) &#123;</span><br><span class="line">			platform_device_put(dev);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		dev-&gt;num_resources = num_reg + num_irq;</span><br><span class="line">		dev-&gt;resource = res;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_reg; i++, res++) &#123;</span><br><span class="line">			rc = of_address_to_resource(np, i, res);</span><br><span class="line">			WARN_ON(rc);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (of_irq_to_resource_table(np, res, num_irq) != num_irq)</span><br><span class="line">			pr_debug(<span class="string">&quot;not all legacy IRQ resources mapped for %pOFn\n&quot;</span>,</span><br><span class="line">				 np);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev-&gt;dev.of_node = of_node_get(np);</span><br><span class="line">	dev-&gt;dev.fwnode = &amp;np-&gt;fwnode;</span><br><span class="line">	dev-&gt;dev.parent = parent ? : &amp;platform_bus;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bus_id)</span><br><span class="line">		dev_set_name(&amp;dev-&gt;dev, <span class="string">&quot;%s&quot;</span>, bus_id);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		of_device_make_bus_id(&amp;dev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第26行出现了for循环的dev-&gt;num_resources &#x3D; num_reg + num_irq;reg的number和irq的number，由于在设备树中并没有添加中断相关的属性num_irq为0，那这里的num_reg是哪里确定的呢。</p>
<p>我们向上找到14、15行，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while (of_address_to_resource(np, num_reg, &amp;temp_res) == 0)</span><br><span class="line">	num_reg++;</span><br></pre></td></tr></table></figure>

<p>然后跳转到while循环中的of_address_to_resource函数，该函数定义在内核源码目录的drivers&#x2F;of&#x2F;address.c文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_address_to_resource</span><span class="params">(<span class="keyword">struct</span> device_node *dev, <span class="type">int</span> index,</span></span><br><span class="line"><span class="params">			   <span class="keyword">struct</span> resource *r)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> __be32	*addrp;</span><br><span class="line">	u64		size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	flags;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>	*name = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	addrp = of_get_address(dev, index, &amp;size, &amp;flags);</span><br><span class="line">	<span class="keyword">if</span> (addrp == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get optional &quot;reg-names&quot; property to add a name to a resource */</span></span><br><span class="line">	of_property_read_string_index(dev, <span class="string">&quot;reg-names&quot;</span>,	index, &amp;name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __of_address_to_resource(dev, addrp, size, flags, name, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	第9行，获取reg属性的地址、大小和类型，在设备树中reg属性已经存在了，所以这里会正确返回。</p>
<p>第14行，读取reg-names属性，由于设备树中没有定义这个属性，所以该函数不会有影响。</p>
<p>最后具有决定性作用的函数就是返回的__of_address_to_resource函数了，跳转到该函数的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __of_address_to_resource(<span class="keyword">struct</span> device_node *dev,</span><br><span class="line">		<span class="type">const</span> __be32 *addrp, u64 size, <span class="type">unsigned</span> <span class="type">int</span> flags,</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> resource *r)</span><br><span class="line">&#123;</span><br><span class="line">	u64 taddr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; IORESOURCE_MEM)</span><br><span class="line">		taddr = of_translate_address(dev, addrp);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; IORESOURCE_IO)</span><br><span class="line">		taddr = of_translate_ioport(dev, addrp, size);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (taddr == OF_BAD_ADDR)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="built_in">memset</span>(r, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> resource));</span><br><span class="line"></span><br><span class="line">	r-&gt;start = taddr;</span><br><span class="line">	r-&gt;end = taddr + size - <span class="number">1</span>;</span><br><span class="line">	r-&gt;flags = flags;</span><br><span class="line">	r-&gt;name = name ? name : dev-&gt;full_name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	reg属性的flags为IORESOURCE_MEM，所以又会执行第9行的of_translate_address函数，跳转到该函数，该函数的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">u64 <span class="title function_">of_translate_address</span><span class="params">(<span class="keyword">struct</span> device_node *dev, <span class="type">const</span> __be32 *in_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">host</span>;</span></span><br><span class="line">	u64 ret;</span><br><span class="line"></span><br><span class="line">	ret = __of_translate_address(dev, in_addr, <span class="string">&quot;ranges&quot;</span>, &amp;host);</span><br><span class="line">	<span class="keyword">if</span> (host) &#123;</span><br><span class="line">		of_node_put(host);</span><br><span class="line">		<span class="keyword">return</span> OF_BAD_ADDR;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	该函数的重点在第6行，上述函数实际上是__of_translate_address函数的封装，其中传入的第三个参数“ranges”是我们要关注的重点，继续跳转到该函数的定义，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u64 __of_translate_address(<span class="keyword">struct</span> device_node *dev,</span><br><span class="line">				  <span class="type">const</span> __be32 *in_addr, <span class="type">const</span> <span class="type">char</span> *rprop,</span><br><span class="line">				  <span class="keyword">struct</span> device_node **host)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">of_bus</span> *<span class="title">bus</span>, *<span class="title">pbus</span>;</span></span><br><span class="line">	__be32 addr[OF_MAX_ADDR_CELLS];</span><br><span class="line">	<span class="type">int</span> na, ns, pna, pns;</span><br><span class="line">	u64 result = OF_BAD_ADDR;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;** translation for device %pOF **\n&quot;</span>, dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Increase refcount at current level */</span></span><br><span class="line">	of_node_get(dev);</span><br><span class="line"></span><br><span class="line">	*host = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/* Get parent &amp; match bus type */</span></span><br><span class="line">	parent = of_get_parent(dev);</span><br><span class="line">	<span class="keyword">if</span> (parent == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> bail;</span><br><span class="line">	bus = of_match_bus(parent);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Count address cells &amp; copy address locally */</span></span><br><span class="line">	bus-&gt;count_cells(dev, &amp;na, &amp;ns);</span><br><span class="line">	<span class="keyword">if</span> (!OF_CHECK_COUNTS(na, ns)) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;Bad cell count for %pOF\n&quot;</span>, dev);</span><br><span class="line">		<span class="keyword">goto</span> bail;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(addr, in_addr, na * <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;bus is %s (na=%d, ns=%d) on %pOF\n&quot;</span>,</span><br><span class="line">	    bus-&gt;name, na, ns, parent);</span><br><span class="line">	of_dump_addr(<span class="string">&quot;translating address:&quot;</span>, addr, na);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Translate */</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">logic_pio_hwaddr</span> *<span class="title">iorange</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Switch to parent bus */</span></span><br><span class="line">		of_node_put(dev);</span><br><span class="line">		dev = parent;</span><br><span class="line">		parent = of_get_parent(dev);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If root, we have finished */</span></span><br><span class="line">		<span class="keyword">if</span> (parent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			pr_debug(<span class="string">&quot;reached root node\n&quot;</span>);</span><br><span class="line">			result = of_read_number(addr, na);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * For indirectIO device which has no ranges property, get</span></span><br><span class="line"><span class="comment">		 * the address from reg directly.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		iorange = find_io_range_by_fwnode(&amp;dev-&gt;fwnode);</span><br><span class="line">		<span class="keyword">if</span> (iorange &amp;&amp; (iorange-&gt;flags != LOGIC_PIO_CPU_MMIO)) &#123;</span><br><span class="line">			result = of_read_number(addr + <span class="number">1</span>, na - <span class="number">1</span>);</span><br><span class="line">			pr_debug(<span class="string">&quot;indirectIO matched(%pOF) 0x%llx\n&quot;</span>,</span><br><span class="line">				 dev, result);</span><br><span class="line">			*host = of_node_get(dev);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Get new parent bus and counts */</span></span><br><span class="line">		pbus = of_match_bus(parent);</span><br><span class="line">		pbus-&gt;count_cells(dev, &amp;pna, &amp;pns);</span><br><span class="line">		<span class="keyword">if</span> (!OF_CHECK_COUNTS(pna, pns)) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;Bad cell count for %pOF\n&quot;</span>, dev);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pr_debug(<span class="string">&quot;parent bus is %s (na=%d, ns=%d) on %pOF\n&quot;</span>,</span><br><span class="line">		    pbus-&gt;name, pna, pns, parent);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Apply bus translation */</span></span><br><span class="line">		<span class="keyword">if</span> (of_translate_one(dev, bus, pbus, addr, na, ns, pna, rprop))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Complete the move up one level */</span></span><br><span class="line">		na = pna;</span><br><span class="line">		ns = pns;</span><br><span class="line">		bus = pbus;</span><br><span class="line"></span><br><span class="line">		of_dump_addr(<span class="string">&quot;one level translation:&quot;</span>, addr, na);</span><br><span class="line">	&#125;</span><br><span class="line"> bail:</span><br><span class="line">	of_node_put(parent);</span><br><span class="line">	of_node_put(dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	第18行，获取父节点和匹配的总线类型</p>
<p>第24行，获取address-cell和size-cells</p>
<p>然后是一个for循环，在76行使用of_translate_one函数进行转换，其中rprop参数表示要转换的资源属性，该参数的值为传入的“ranges”，然后我们继续跳转到该函数，该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">of_translate_one</span><span class="params">(<span class="keyword">struct</span> device_node *parent, <span class="keyword">struct</span> of_bus *bus,</span></span><br><span class="line"><span class="params">			    <span class="keyword">struct</span> of_bus *pbus, __be32 *addr,</span></span><br><span class="line"><span class="params">			    <span class="type">int</span> na, <span class="type">int</span> ns, <span class="type">int</span> pna, <span class="type">const</span> <span class="type">char</span> *rprop)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> __be32 *ranges;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> rlen;</span><br><span class="line">	<span class="type">int</span> rone;</span><br><span class="line">	u64 offset = OF_BAD_ADDR;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Normally, an absence of a &quot;ranges&quot; property means we are</span></span><br><span class="line"><span class="comment">	 * crossing a non-translatable boundary, and thus the addresses</span></span><br><span class="line"><span class="comment">	 * below the current cannot be converted to CPU physical ones.</span></span><br><span class="line"><span class="comment">	 * Unfortunately, while this is very clear in the spec, it&#x27;s not</span></span><br><span class="line"><span class="comment">	 * what Apple understood, and they do have things like /uni-n or</span></span><br><span class="line"><span class="comment">	 * /ht nodes with no &quot;ranges&quot; property and a lot of perfectly</span></span><br><span class="line"><span class="comment">	 * useable mapped devices below them. Thus we treat the absence of</span></span><br><span class="line"><span class="comment">	 * &quot;ranges&quot; as equivalent to an empty &quot;ranges&quot; property which means</span></span><br><span class="line"><span class="comment">	 * a 1:1 translation at that level. It&#x27;s up to the caller not to try</span></span><br><span class="line"><span class="comment">	 * to translate addresses that aren&#x27;t supposed to be translated in</span></span><br><span class="line"><span class="comment">	 * the first place. --BenH.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * As far as we know, this damage only exists on Apple machines, so</span></span><br><span class="line"><span class="comment">	 * This code is only enabled on powerpc. --gcl</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ranges = of_get_property(parent, rprop, &amp;rlen);</span><br><span class="line">	<span class="keyword">if</span> (ranges == <span class="literal">NULL</span> &amp;&amp; !of_empty_ranges_quirk(parent)) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;no ranges; cannot translate\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ranges == <span class="literal">NULL</span> || rlen == <span class="number">0</span>) &#123;</span><br><span class="line">		offset = of_read_number(addr, na);</span><br><span class="line">		<span class="built_in">memset</span>(addr, <span class="number">0</span>, pna * <span class="number">4</span>);</span><br><span class="line">		pr_debug(<span class="string">&quot;empty ranges; 1:1 translation\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> finish;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;walking ranges...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now walk through the ranges */</span></span><br><span class="line">	rlen /= <span class="number">4</span>;</span><br><span class="line">	rone = na + pna + ns;</span><br><span class="line">	<span class="keyword">for</span> (; rlen &gt;= rone; rlen -= rone, ranges += rone) &#123;</span><br><span class="line">		offset = bus-&gt;<span class="built_in">map</span>(addr, ranges, na, ns, pna);</span><br><span class="line">		<span class="keyword">if</span> (offset != OF_BAD_ADDR)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (offset == OF_BAD_ADDR) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;not found !\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(addr, ranges + na, <span class="number">4</span> * pna);</span><br><span class="line"></span><br><span class="line"> finish:</span><br><span class="line">	of_dump_addr(<span class="string">&quot;parent translation for:&quot;</span>, addr, pna);</span><br><span class="line">	pr_debug(<span class="string">&quot;with offset: %llx\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)offset);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Translate it into parent bus space */</span></span><br><span class="line">	<span class="keyword">return</span> pbus-&gt;translate(addr, offset, pna);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该函数的第26行使用of_get_property函数获取“ranges”属性，但由于在我们添加的设备树节点中并没有该属性，所以这里的ranges值就为NULL，第27行的条件判断成立，也就会返回1。</p>
<p>接下来再根据这个返回值继续分析上级函数:</p>
<p>of_translate_one函数返回1之后，上一级的_of_translate_address的返回值就为OF BAD ADDR，再上一级的of_translate_address返回值也是OF BAD <em>ADDR，继续向上查找_of_address_to_resource函数会返回EINVAL，of address</em> to resource 返回EINVAL，所以num_reg 为0;到这里关于为什么platform_get_resource函数获取资源失败的问题就找到了，只是因为在设备树中并没有这个名为ranges这个属性，所以只需要对设备树进行ranges属性的添加即可，要修改的设备树为arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568-evb1-ddr4-v10-linux.dts，修改完成如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025548.jpeg" alt="img"> </p>
<p>然后重新编译内核，将编译生成的boot.img烧写进开发板之后重新加载上面编写的驱动程序，可以看到之前获取失败的打印就消失了，而且成功打印出了reg属性的第一个值，如下图所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062025507.jpeg" alt="img"></p>
<p>虽然这里的问题解决了，但引起的思考并没有结束，那我们在这里添加的ranges属性的作用是啥呢，带着疑问，开始下一小节的学习吧。</p>
<h1 id="68-2-ranges-属性"><a href="#68-2-ranges-属性" class="headerlink" title="68.2 ranges 属性"></a>68.2 ranges 属性</h1><h3 id="68-2-1-ranges属性介绍"><a href="#68-2-1-ranges属性介绍" class="headerlink" title="68.2.1 ranges属性介绍"></a>68.2.1 ranges属性介绍</h3><p>ranges 属性是一种用于描述设备之间地址映射关系的属性。它在设备树（Device Tree）中使用，用于描述子设备地址空间如何映射到父设备地址空间。设备树是一种硬件描述语言，用于描述嵌入式系统中的硬件组件和它们之间的连接关系。</p>
<p>设备树中的每个设备节点都可以具有 ranges 属性，其中包含了地址映射的信息。下面是一个常见的格式：</p>
<p>ranges &#x3D; <child-bus-address parent-bus-address length>;</p>
<p>或者</p>
<p>ranges;</p>
<p>然后对上述格式中每个部分进行解释：</p>
<p>child-bus-address：子设备地址空间的起始地址。它指定了子设备在父设备地址空间中的位置。具体的字长由 ranges 所在节点的 #address-cells 属性决定。</p>
<p>parent-bus-address：父设备地址空间的起始地址。它指定了父设备中用于映射子设备的地址范围。具体的字长由 ranges 的父节点的 #address-cells 属性决定。</p>
<p>length：映射的大小。它指定了子设备地址空间在父设备地址空间中的长度。具体的字长由 ranges 的父节点的 #size-cells 属性决定。</p>
<p>当 ranges 属性的值为空时，表示子设备地址空间和父设备地址空间具有完全相同的映射，即1:1映射。这通常用于描述内存区域，其中子设备和父设备具有相同的地址范围。</p>
<p>当 ranges 属性的值不为空时，按照指定的映射规则将子设备地址空间映射到父设备地址空间。具体的映射规则取决于设备树的结构和设备的特定要求。</p>
<p>然后以下面的设备树为例进行ranges属性的讲解，设备树内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">  compatible = <span class="string">&quot;acme,coyotes-revenge&quot;</span>;</span><br><span class="line">  <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">  <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">  ....</span><br><span class="line">  external-bus &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    ranges = &lt;<span class="number">0</span> <span class="number">0</span> <span class="number">0x10100000</span> <span class="number">0x10000</span></span><br><span class="line">              <span class="number">1</span> <span class="number">0</span> <span class="number">0x10160000</span> <span class="number">0x10000</span></span><br><span class="line">              <span class="number">2</span> <span class="number">0</span> <span class="number">0x30000000</span> <span class="number">0x30000000</span>&gt;;</span><br><span class="line">    <span class="comment">// Chipselect 1, Ethernet</span></span><br><span class="line">    <span class="comment">// Chipselect 2, i2c controller</span></span><br><span class="line">    <span class="comment">// Chipselect 3, NOR Flash</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure>

<p>这里以ranges的第一个属性值为例进行具体解释如下：</p>
<p>在 external-bus 节点中#address-cells 属性值为2表示child-bus-address由两个值表示，也就是0和0，父节点的 #address-cells 属性值和#size-cells 属性值为1，表示parent-bus-address和length都由一个表示，也就是0x10100000和0x10000，该ranges值表示将子地址空间（0x0-0xFFFF）映射到父地址空间0x10100000 - 0x1010FFFF，这里的例子为带参数ranges属性映射，不带参数的ranges属性为1：1映射，较为简单，这里不再进行举例。</p>
<p>在嵌入式系统中，不同的设备可能连接到相同的总线或总线控制器上，它们需要在物理地址空间中进行正确的映射，以便进行数据交换和通信。例如，一个设备可能通过总线连接到主处理器或其他设备，而这些设备的物理地址范围可能不同。ranges 属性就是用来描述这种地址映射关系的。</p>
<h3 id="68-2-2设备分类"><a href="#68-2-2设备分类" class="headerlink" title="68.2.2设备分类"></a>68.2.2设备分类</h3><p>根据上面讲解的映射关系可以将设备分为两类：内存映射型设备和非内存映射型设备。</p>
<p><strong>内存映射型设备：</strong><br>    内存映射型设备是指可以通过内存地址进行直接访问的设备。这类设备在物理地址空间中的一部分被映射到系统的内存地址空间中，使得CPU可以通过读写内存地址的方式与设备进行通信和控制。</p>
<p>特点：</p>
<p>（1）直接访问：内存映射型设备可以被CPU直接访问，类似于访问内存中的数据。这种直接访问方式提供了高速的数据传输和低延迟的设备操作。</p>
<p>（2）内存映射：设备的寄存器、缓冲区等资源被映射到系统的内存地址空间中，使用读写内存的方式与设备进行通信。</p>
<p>（3）读写操作：CPU可以通过读取和写入映射的内存地址来与设备进行数据交换和控制操作。</p>
<p>在设备树中，内存映射型设备的设备树举例如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">/ &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    ranges;</span><br><span class="line"></span><br><span class="line">    serial@<span class="number">101f</span>0000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;arm,pl011&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x101f0000</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@<span class="number">101f</span>3000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;arm,pl061&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x101f3000</span> <span class="number">0x1000</span></span><br><span class="line">                <span class="number">0x101f4000</span> <span class="number">0x10</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    spi@<span class="number">10115000</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;arm,pl022&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x10115000</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第5行的ranges属性表示该设备树中会进行1：1的地址范围映射。</p>
<p>非内存映射型设备：<br>    非内存映射型设备是指不能通过内存地址直接访问的设备。这类设备可能采用其他方式与CPU进行通信，例如通过I&#x2F;O端口、专用总线或特定的通信协议。</p>
<p>特点：</p>
<p>（1）非内存访问：非内存映射型设备不能像内存映射型设备那样直接通过内存地址进行访问。它们可能使用独立的I&#x2F;O端口或专用总线进行通信。</p>
<p>（2）特定接口：设备通常使用特定的接口和协议与CPU进行通信和控制，例如SPI、I2C、UART等。</p>
<p>（3）驱动程序：非内存映射型设备通常需要特定的设备驱动程序来实现与CPU的通信和控制。</p>
<p>在设备树中，非内存映射型设备的设备树举例如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">  compatible = <span class="string">&quot;acme,coyotes-revenge&quot;</span>;</span><br><span class="line">  <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">  <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">  ....</span><br><span class="line">  external-bus &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    ranges = &lt;<span class="number">0</span> <span class="number">0</span> <span class="number">0x10100000</span> <span class="number">0x10000</span></span><br><span class="line">              <span class="number">1</span> <span class="number">0</span> <span class="number">0x10160000</span> <span class="number">0x10000</span></span><br><span class="line">              <span class="number">2</span> <span class="number">0</span> <span class="number">0x30000000</span> <span class="number">0x30000000</span>&gt;;</span><br><span class="line">    <span class="comment">// Chipselect 1, Ethernet</span></span><br><span class="line">    <span class="comment">// Chipselect 2, i2c controller</span></span><br><span class="line">    <span class="comment">// Chipselect 3, NOR Flash</span></span><br><span class="line"></span><br><span class="line">    ethernet@<span class="number">0</span>,<span class="number">0</span> &#123;</span><br><span class="line">      compatible = <span class="string">&quot;smc,smc91c111&quot;</span>;</span><br><span class="line">      reg = &lt;<span class="number">0</span> <span class="number">0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    i2c@<span class="number">1</span>,<span class="number">0</span> &#123;</span><br><span class="line">      compatible = <span class="string">&quot;acme,a1234-i2c-bus&quot;</span>;</span><br><span class="line">      <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">      <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">      reg = &lt;<span class="number">1</span> <span class="number">0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line"></span><br><span class="line">      rtc@<span class="number">58</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;maxim,ds1338&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x58</span>&gt;;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; ;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h3 id="68-2-3-映射地址计算"><a href="#68-2-3-映射地址计算" class="headerlink" title="68.2.3 映射地址计算"></a>68.2.3 映射地址计算</h3><p>接下来以上面列举的非内存映射型设备的设备树中的ethernet@0节点为例，计算该网卡设备的映射地址。</p>
<p>首先，找到ethernet@0所在的节点，并查看其reg属性。在给定的设备树片段中，ethernet@0的reg属性为&lt;0 0 0x1000&gt;。在根节点中，#address-cells的值为1，表示地址由一个单元格组成。</p>
<p>接下来，根据ranges属性进行地址映射计算。在external-bus节点的ranges属性中，有三个映射条目：</p>
<p>第一个映射条目为“0 0 0x10100000 0x10000”，表示外部总线的地址范围为0x10100000到0x1010FFFF。该映射条目的第一个值为0，表示与external-bus节点的第一个子节点（ethernet@0,0）相关联。</p>
<p>第二个映射条目：“1 0 0x10160000 0x10000”，表示外部总线的地址范围为0x10160000到0x1016FFFF。该映射条目的第一个值为1，表示与external-bus节点的第二个子节点（i2c@1,0）相关联。</p>
<p>第三个映射条目：“2 0 0x30000000 0x30000000”，表示外部总线的地址范围为0x30000000到0x5FFFFFFF。该映射条目的第一个值为2，表示与external-bus节点的第三个子节点相关联。</p>
<p>由于ethernet@0与external-bus的第一个子节点相关联，并且它的reg属性为&lt;0 0 0x1000&gt;，我们可以进行以下计算：</p>
<p>ethernet@0的物理地址 &#x3D; 外部总线地址起始值 + ethernet@0的reg属性的第二个值<br>&#x3D; 0x10100000 + 0x1000<br>&#x3D; 0x10101000</p>
<p>因此，ethernet@0的物理起始地址为0x10101000，又根据0x1000的地址范围可以确定ethernet@0的结束起始地址为0x10101FFF，至此，关于映射地址的计算就讲解完成了，大家可以根据同样的方法计算i2c@1的物理地址。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rk3568-%E9%A9%B1%E5%8A%A8/" rel="tag">rk3568 驱动</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-1-67-of操作函数实验-获取属性"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/1-67-of%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E5%AE%9E%E9%AA%8C-%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7/"
    >1-67-of操作函数实验:获取属性</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/1-67-of%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E5%AE%9E%E9%AA%8C-%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7/" class="article-date">
  <time datetime="2023-09-05T00:01:40.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第67章-of操作函数实验：获取属性"><a href="#第67章-of操作函数实验：获取属性" class="headerlink" title="第67章 of操作函数实验：获取属性"></a>第67章 of操作函数实验：获取属性</h1><h2 id="67-1-of操作：获取属性"><a href="#67-1-of操作：获取属性" class="headerlink" title="67.1 of操作：获取属性"></a>67.1 of操作：获取属性</h2><h3 id="67-1-1-of-find-property"><a href="#67-1-1-of-find-property" class="headerlink" title="67.1.1 of_find_property"></a>67.1.1 of_find_property</h3><p>of_find_property函数用于在设备树中查找节点 下具有指定名称的属性。如果找到了该属性，可以通过返回的属性结构体指针进行进一步的操作，比如获取属性值、属性长度等。</p>
<p><strong>函数原型:</strong></p>
<p>​	struct property *of_find_property(const struct device_node *np, const char *name, int *lenp)</p>
<p><strong>头文件：</strong></p>
<p>​	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用</strong>:</p>
<p>​	该函数用于在节点 np 下查找指定名称 name 的属性。</p>
<p><strong>函数参数</strong>:</p>
<p>​	np: 要查找的节点。</p>
<p>​	name: 要查找的属性的属性名。</p>
<p>​	lenp: 一个指向整数的指针，用于接收属性值的字节数。</p>
<p><strong>返回值</strong>:</p>
<p>​	如果成功找到了指定名称的属性，则返回对应的属性结构体指针 struct property *；如果未找到，则返回 NULL。</p>
<h3 id="67-1-2-of-property-count-elems-of-size"><a href="#67-1-2-of-property-count-elems-of-size" class="headerlink" title="67.1.2 of_property_count_elems_of_size"></a>67.1.2 of_property_count_elems_of_size</h3><p>该函数在设备树中的设备节点下查找指定名称的属性，并获取该属性中元素的数量。调用该函数可以用于获取设备树属性中某个属性的元素数量，比如一个字符串列表的元素数量或一个整数数组的元素数量等。 </p>
<p><strong>函数原型:</strong></p>
<p>​	int of_property_count_elems_of_size(const struct device_node *np, const char *propname, int elem_size)</p>
<p><strong>头文件</strong>：</p>
<p>\	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用</strong></p>
<p>​	该函数用于获取属性中指定元素的数量。</p>
<p><strong>函数参数</strong>:</p>
<p>​	np: 设备节点。</p>
<p>​	propname: 需要获取元素数量的属性名。</p>
<p>​	elem_size: 单个元素的尺寸。</p>
<p><strong>返回值</strong>:</p>
<p>如果成功获取了指定属性中元素的数量，则返回该数量；如果未找到属性或属性中没有元素，则返回 0。</p>
<h3 id="67-1-3-of-property-read-u32-index"><a href="#67-1-3-of-property-read-u32-index" class="headerlink" title="67.1.3 of_property_read_u32_index"></a>67.1.3 of_property_read_u32_index</h3><p>该函数在设备树中的设备节点下查找指定名称的属性，并获取该属性在给定索引位置处的 u32 类型的数据值。</p>
<p>这个函数通常用于从设备树属性中读取特定索引位置的整数值。通过指定属性名和索引，可以获取属性中指定位置的具体数值。</p>
<p><strong>函数原型</strong>:</p>
<p>​	int of_property_read_u32_index(const struct device_node *np, const char *propname, u32 index, u32 *out_value)</p>
<p><strong>头文件</strong>：</p>
<p>\	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用</strong>:</p>
<p>​	该函数用于从指定属性中获取指定索引位置的 u32 类型的数据值。</p>
<p><strong>函数参数</strong>:</p>
<p>​	np: 设备节点。</p>
<p>​	propname: 要读取的属性名。</p>
<p>​	index: 要读取的属性值在属性中的索引，索引从 0 开始。</p>
<p>​	out_value: 用于存储读取到的值的指针。</p>
<p><strong>返回值</strong>: </p>
<p>​	如果成功读取到了指定属性指定索引位置的 u32 类型的数据值，则返回 0；如果未找到属性或读取失败，则返回相应的错误码。</p>
<h3 id="67-1-4-of-property-read-u64-index"><a href="#67-1-4-of-property-read-u64-index" class="headerlink" title="67.1.4 of_property_read_u64_index"></a>67.1.4 of_property_read_u64_index</h3><p>该函数在设备树中的设备节点下查找指定名称的属性，并获取该属性在给定索引位置处的 u64 类型的数据值。</p>
<p>这个函数通常用于从设备树属性中读取特定索引位置的 64 位整数值。通过指定属性名和索引，可以获取属性中指定位置的具体数值。</p>
<p><strong>函数原型</strong>: </p>
<p>​	static inline int of_property_read_u64_index(const struct device_node *np, const char *propname, u32 index, u64 *out_value)</p>
<p><strong>头文件</strong>：</p>
<p>\	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用</strong>:</p>
<p>​	该函数用于从指定属性中获取指定索引位置的 u64 类型的数据值。</p>
<p><strong>函数参数和返回值</strong>:</p>
<p>​	np: 设备节点。</p>
<p>​	propname: 要读取的属性名。</p>
<p>​	index: 要读取的属性值在属性中的索引，索引从 0 开始。</p>
<p>​	out_value: 用于存储读取到的值的指针。</p>
<p><strong>返回值</strong>:</p>
<p>​	如果成功读取到了指定属性指定索引位置的 u64 类型的数据值，则返回 0；如果未找到属性或读取失败，则返回相应的错误码。</p>
<h3 id="67-1-5-of-property-read-variable-u32-array"><a href="#67-1-5-of-property-read-variable-u32-array" class="headerlink" title="67.1.5 of_property_read_variable_u32_array"></a>67.1.5 of_property_read_variable_u32_array</h3><p>该函数用于从设备树中读取指定属性名的变长数组。通过提供设备节点、属性名和输出数组的指针，可以将设备树中的数组数据读取到指定的内存区域中。同时，还需要指定数组的最小大小和最大大小，以确保读取到的数组符合预期的大小范围。</p>
<p><strong>函数原型</strong>：</p>
<p>​	int of_property_read_variable_u32_array(const struct device_node *np, const char *propname, u32 *out_values, size_t SZ_min, size_t SZ_max)</p>
<p><strong>函数作用</strong>: </p>
<p>​	从指定属性中读取变长的 u32 数组。</p>
<p><strong>函数参数</strong>:</p>
<p>​	np: 设备节点。</p>
<p>​	propname: 要读取的属性名。</p>
<p>​	out_values: 用于存储读取到的 u8 数组的指针。</p>
<p>​	SZ_min: 数组的最小大小。</p>
<p>​	SZ_max: 数组的最大大小。</p>
<p><strong>返回值</strong>：</p>
<p>如果成功读取到了指定属性的 u8 数组，则返回数组的大小。如果未找到属性或读取失败，则返回相应的错误码。</p>
<p>上面介绍的函数用于从指定属性中读取变长的 u32 数组，下面是另外三个读取其他数组大小的函数：</p>
<p>这里给出了四个函数，用于从设备树中读取数组类型的属性值：</p>
<p>从指定属性中读取变长的 u8 数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int of_property_read_variable_u8_array(const struct device_node *np, const char *propname, u8 *out_values, size_t SZ_min, size_t SZ_max)</span><br></pre></td></tr></table></figure>

<p>从指定属性中读取变长的 u16 数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int of_property_read_variable_u16_array(const struct device_node *np, const char *propname, u16 *out_values, size_t SZ_min, size_t SZ_max)</span><br></pre></td></tr></table></figure>

<p>从指定属性中读取变长的 u64 数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int of_property_read_variable_u64_array(const struct device_node *np, const char *propname, u64 *out_values, size_t SZ_min, size_t SZ_max)</span><br></pre></td></tr></table></figure>

<h3 id="67-1-6-of-property-read-string"><a href="#67-1-6-of-property-read-string" class="headerlink" title="67.1.6 of_property_read_string"></a>67.1.6 of_property_read_string</h3><p>该函数在设备树中的设备节点下查找指定名称的属性，并获取该属性的字符串值，最后返回读取到的字符串的指针，通常用于从设备树属性中读取字符串值。通过指定属性名，可以获取属性中的字符串数据。</p>
<p><strong>函数原型</strong>:</p>
<p>​	static inline int of_property_read_string(const struct device_node *np, const char *propname, const char **out_string)</p>
<p><strong>头文件</strong>：</p>
<p>\	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用</strong>:</p>
<p>​	该函数用于从指定属性中读取字符串。</p>
<p><strong>函数参数</strong>:</p>
<p>​	np: 设备节点。</p>
<p>​	propname: 要读取的属性名。</p>
<p>​	out_string: 用于存储读取到的字符串的指针。</p>
<p><strong>返回值</strong>:</p>
<p>​	如果成功读取到了指定属性的字符串，则返回 0；如果未找到属性或读取失败，则返回相应的错误码。</p>
<h2 id="67-2-实验程序编写"><a href="#67-2-实验程序编写" class="headerlink" title="67.2 实验程序编写"></a>67.2 实验程序编写</h2><p>本实验驱动对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\56_of_02。</p>
<p>本小节驱动程序是由65章驱动程序修改而来，由于本章节获取设备树属性的函数需要在查找到设备树节点的前提下使用，所以在下面的程序中，先在probe函数中添加查获取设备树节点，然后添加了本章节学习的of操作相关代码，用来获取设备树节点相关属性。</p>
<p>编写完成的platform_driver.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mod_devicetable.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">mydevice_node</span>;</span>      </span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">u32 value_u32;</span><br><span class="line">u64 value_u64;</span><br><span class="line">u32 out_value[<span class="number">2</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *value_compatible;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">my_property</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的探测函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_probe: Probing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过节点名称查找设备树节点</span></span><br><span class="line">    mydevice_node = of_find_node_by_name(<span class="literal">NULL</span>, <span class="string">&quot;myLed&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;mydevice node is %s\n&quot;</span>, mydevice_node-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找compatible属性</span></span><br><span class="line">    my_property = of_find_property(mydevice_node, <span class="string">&quot;compatible&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    printk(<span class="string">&quot;my_property name is %s\n&quot;</span>, my_property-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取reg属性的元素数量</span></span><br><span class="line">    num = of_property_count_elems_of_size(mydevice_node, <span class="string">&quot;reg&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    printk(<span class="string">&quot;reg num is %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取reg属性的值</span></span><br><span class="line">    of_property_read_u32_index(mydevice_node, <span class="string">&quot;reg&quot;</span>, <span class="number">0</span>, &amp;value_u32);</span><br><span class="line">    of_property_read_u64_index(mydevice_node, <span class="string">&quot;reg&quot;</span>, <span class="number">0</span>, &amp;value_u64);</span><br><span class="line">    printk(<span class="string">&quot;value u32 is 0x%X\n&quot;</span>, value_u32);</span><br><span class="line">    printk(<span class="string">&quot;value u64 is 0x%llx\n&quot;</span>, value_u64);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取reg属性的变长数组</span></span><br><span class="line">    of_property_read_variable_u32_array(mydevice_node, <span class="string">&quot;reg&quot;</span>, out_value, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    printk(<span class="string">&quot;out_value[0] is 0x%X\n&quot;</span>, out_value[<span class="number">0</span>]);</span><br><span class="line">    printk(<span class="string">&quot;out_value[1] is 0x%X\n&quot;</span>, out_value[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取compatible属性的字符串值</span></span><br><span class="line">    of_property_read_string(mydevice_node, <span class="string">&quot;compatible&quot;</span>, &amp;value_compatible);</span><br><span class="line">    printk(<span class="string">&quot;compatible value is %s\n&quot;</span>, value_compatible);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Removing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table_id</span>[]  =</span> &#123;</span><br><span class="line">	&#123;.compatible=<span class="string">&quot;my devicetree&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">		.of_match_table =  of_match_table_id,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="67-3-运行测试"><a href="#67-3-运行测试" class="headerlink" title="67.3 运行测试"></a>67.3 运行测试</h2><h3 id="67-3-1-编译驱动程序"><a href="#67-3-1-编译驱动程序" class="headerlink" title="67.3.1 编译驱动程序"></a>67.3.1 编译驱动程序</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_driver.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_driver.c和Makefile文件目录下，如下图（图67-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024437.png" alt="img"></p>
<p>图 67-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图67-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024375.jpeg" alt="img"></p>
<p>图 67-2</p>
<p>编译完生成platform_driver.ko目标文件，如下图（图67-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024393.jpeg" alt="img"> </p>
<p>图 67-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="67-3-2-运行测试"><a href="#67-3-2-运行测试" class="headerlink" title="67.3.2 运行测试"></a>67.3.2 运行测试</h3><p>在进行实验之前，首先要确保开发板烧写的是我们在65.2.1小节中编译出来的boot.img，开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图67-4）所示：</p>
<p>insmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024402.jpeg" alt="img"> </p>
<p>图 67-4</p>
<p>可以看到总共有8个打印，第一个打印表示查找到的节点为myLed,接下来的打印都是使用该节点进行的属性查找。第二个打印表示查找的属性名为“compatible”，第三个打印表示查找的reg属性数量为2，第四个和第五个分别表示读取到的32位和64位的reg属性值，第6个和第7个打印表示reg的第一个属性值和第二个属性值，第8个打印表示compatite属性值为“my devicetree”。</p>
<p>然后使用以下命令进行驱动模块的卸载，如下图（图66-5）所示：</p>
<p>rmmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024444.png" alt="img"></p>
<p>图 67-5</p>
<p>至此，使用of操作函数获取设备树节点实验就完成了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rk3568-%E9%A9%B1%E5%8A%A8/" rel="tag">rk3568 驱动</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-1-66-of操作函数实验-获取设备树节点"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/1-66-of%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E5%AE%9E%E9%AA%8C-%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87%E6%A0%91%E8%8A%82%E7%82%B9/"
    >1-62-dtb文件格式讲解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/1-66-of%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E5%AE%9E%E9%AA%8C-%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87%E6%A0%91%E8%8A%82%E7%82%B9/" class="article-date">
  <time datetime="2023-09-05T00:01:36.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第66章of操作函数实验：获取设备树节点"><a href="#第66章of操作函数实验：获取设备树节点" class="headerlink" title="第66章of操作函数实验：获取设备树节点"></a>第66章of操作函数实验：获取设备树节点</h1><p>在上一章节的学习中，我们学习了设备树下platform_device和platform_driver匹配，现在也只是让他们匹配在了一起，但这样显然是不够的，为了完成一些和硬件相关的需求，我们还需要获取到在设备树中编写的一些属性，那驱动是如何获取设备树中的属性呢，让我们一起进入后续章节的学习吧。</p>
<h2 id="66-1-of操作：获取设备树节点"><a href="#66-1-of操作：获取设备树节点" class="headerlink" title="66.1 of操作：获取设备树节点"></a>66.1 of操作：获取设备树节点</h2><h3 id="66-1-1-of-find-node-by-name函数"><a href="#66-1-1-of-find-node-by-name函数" class="headerlink" title="66.1.1 of_find_node_by_name函数"></a>66.1.1 of_find_node_by_name函数</h3><p>of_find_node_by_name 是Linux内核中用于通过节点名称查找设备树节点的函数。下面是对of_find_node_by_name 函数的详细介绍：</p>
<p><strong>函数原型：</strong></p>
<p>​	struct device_node *of_find_node_by_name(struct device_node *from, const char *name);</p>
<p><strong>头文件：</strong></p>
<p>​	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用：</strong><br>        该函数通过指定的节点名称在设备树中进行查找，返回匹配的节点的 struct device_node 指针。</p>
<p><strong>参数含义：</strong></p>
<p>​	from：指定起始节点，表示从哪个节点开始查找。如果 from 参数为 NULL，则从设备树的根节点开始查找。</p>
<p>​	name：要查找的节点名称。</p>
<p><strong>返回值：</strong></p>
<p>​	如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>​	如果未找到匹配的节点，则返回 NULL。</p>
<p>会在接下来的实验小节中，对该函数进行实际演示。</p>
<h3 id="66-1-2-of-find-node-by-path函数"><a href="#66-1-2-of-find-node-by-path函数" class="headerlink" title="66.1.2 of_find_node_by_path函数"></a>66.1.2 of_find_node_by_path函数</h3><p>of_find_node_by_path 是Linux内核中用于通过节点路径查找设备树节点的函数。下面是对of_find_node_by_path函数的详细介绍：</p>
<p><strong>函数原型：</strong></p>
<p>​	struct device_node *of_find_node_by_path(const char *path);</p>
<p><strong>头文件：</strong></p>
<p>​	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用：</strong><br>    该函数根据节点路径在设备树中进行查找，返回匹配的节点的 struct device_node 指针。</p>
<p><strong>参数含义：</strong></p>
<p>​	path：节点的路径，以斜杠分隔的字符串表示。路径格式为设备树节点的绝对路径，例如 &#x2F;topeet&#x2F;myLed。</p>
<p><strong>返回值：</strong></p>
<p>​	如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>​	如果未找到匹配的节点，则返回 NULL。</p>
<p>​	of_find_node_by_path 函数通过节点路径在设备树中进行查找。路径是设备树节点从根节点到目标节点的完整路径。可以通过指定正确的路径来准确地访问设备树中的特定节点。</p>
<p>​	使用 of_find_node_by_path 函数时，可以直接传递节点的完整路径作为 path 参数，函数会在设备树中查找匹配的节点。这对于已知节点路径的情况非常有用。</p>
<h3 id="66-1-3-of-get-parent函数"><a href="#66-1-3-of-get-parent函数" class="headerlink" title="66.1.3 of_get_parent函数"></a>66.1.3 of_get_parent函数</h3><p>在Linux内核中，of_get_parent 函数用于获取设备树节点的父节点。下面是对of_get_parent函数的详细介绍：</p>
<p><strong>函数原型：</strong></p>
<p>​	struct device_node *of_get_parent(const struct device_node *node);</p>
<p><strong>头文件：</strong></p>
<p>​	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用：</strong><br>    该函数接收一个指向设备树节点的指针 node，并返回该节点的父节点的指针。</p>
<p><strong>参数含义：</strong></p>
<p>​	node：要获取父节点的设备树节点指针。</p>
<p><strong>返回值：</strong></p>
<p>​	如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>​	如果未找到匹配的节点，则返回 NULL。</p>
<p>​	使用 of_get_parent 函数时，可以将特定的设备树节点作为参数传递给函数，然后它将返回该节点的父节点。这对于在设备树中导航和访问节点之间的层次关系非常有用。</p>
<p>​	父节点在设备树中表示了节点之间的层次结构关系。通过获取父节点，你可以访问上一级节点的属性和配置信息，从而更好地理解设备树中的节点之间的关系。</p>
<h3 id="66-1-4-of-get-next-child函数"><a href="#66-1-4-of-get-next-child函数" class="headerlink" title="66.1.4 of_get_next_child函数"></a>66.1.4 of_get_next_child函数</h3><p>在Linux内核中，of_get_next_child 函数用于获取设备树节点的下一个子节点。下面是对of_get_next_child 函数的详细介绍：</p>
<p><strong>函数原型：</strong></p>
<p>​	struct device_node *of_get_next_child(const struct device_node *node, struct device_node *prev);</p>
<p><strong>头文件：</strong></p>
<p>​	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用：</strong><br>    该函数接收两个参数：node 是当前节点，prev 是上一个子节点。它返回下一个子节点的指针。</p>
<p><strong>参数含义：</strong></p>
<p>​	node：当前节点，用于指定要获取子节点的起始节点。</p>
<p>​	prev：上一个子节点，用于指定从哪个子节点开始获取下一个子节点。如果为 NULL，则从起始节点的第一个子节点开始。</p>
<p><strong>返回值：</strong></p>
<p>​	如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>​	如果未找到匹配的节点，则返回 NULL。</p>
<p>​	使用 of_get_next_child 函数时，可以传递当前节点以及上一个子节点作为参数。函数将从上一个子节点的下一个节点开始，查找并返回下一个子节点。</p>
<p>​	设备树中的子节点表示了节点之间的层次关系。通过获取子节点，你可以遍历和访问当前节点的所有子节点，以便进一步处理它们的属性和配置信息。</p>
<h3 id="64-1-5-of-find-compatible-node函数"><a href="#64-1-5-of-find-compatible-node函数" class="headerlink" title="64.1.5 of_ find_ compatible_ node函数"></a>64.1.5 of_ find_ compatible_ node函数</h3><p>当设备树中存在多个设备节点，需要根据设备的兼容性字符串进行匹配时，可以使用 of_find_compatible_node 函数。该函数用于在设备树中查找与指定兼容性字符串匹配的节点。</p>
<p><strong>函数原型：</strong></p>
<p>​	struct device_node *of_find_compatible_node(struct device_node *from, const char *type, const char *compatible);</p>
<p><strong>头文件：</strong></p>
<p>​	#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用：</strong><br>    在设备树中查找与指定兼容性字符串匹配的节点。</p>
<p><strong>参数含义：</strong></p>
<p>​	from：指定起始节点，表示从哪个节点开始查找。如果 from 参数为 NULL，则从设备树的根节点开始查找。</p>
<p>​	type：要匹配的设备类型字符串，通常是 compatible 属性中的一部分。</p>
<p>​	compatible：要匹配的兼容性字符串，通常是设备树节点的 compatible 属性中的值。</p>
<p><strong>返回值：</strong></p>
<p>​	如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>​	如果未找到匹配的节点，则返回 NULL。</p>
<p>​	使用 of_find_compatible_node 函数时，可以指定起始节点和需要匹配的设备类型字符串以及兼容性字符串。函数会从起始节点开始遍历设备树，查找与指定兼容性字符串匹配的节点，并返回匹配节点的指针。</p>
<h3 id="64-1-6-of-find-matching-node-and-match函数"><a href="#64-1-6-of-find-matching-node-and-match函数" class="headerlink" title="64.1.6 of_ find matching node_ and_ match函数"></a>64.1.6 of_ find matching node_ and_ match函数</h3><p>在Linux内核中，of_ find matching node_ and_ match函数用于根据给定的of_device_id匹配表在设备树中查找匹配的节点。</p>
<p><strong>函数原型：</strong></p>
<p>​	struct device_node *of_find_matching_node_and_match(struct device_node *from,const struct of_device_id *matches, const struct of_device_id **match);</p>
<p><strong>头文件：</strong></p>
<p>#include &lt;linux&#x2F;of.h&gt;</p>
<p><strong>函数作用：</strong><br>    根据给定的of_device_id匹配表在设备树中查找匹配的节点。</p>
<p><strong>参数含义：</strong></p>
<p>​	from：表示从哪个节点开始搜索。通常将上一次调用该函数返回的节点作为参数传递给from，以便从上一次的下一个节点开始搜索。如果要从设备树的根节点开始搜索，可以将from参数设置为NULL。</p>
<p>​	matches：指向一个of_device_id类型的匹配表，该表包含要搜索的匹配项。</p>
<p>​	match：用于输出匹配到的of_device_id条目的指针。</p>
<p><strong>返回值：</strong></p>
<p>​	如果找到匹配的节点，则返回对应的 struct device_node 指针。</p>
<p>​	如果未找到匹配的节点，则返回 NULL。</p>
<p>of_find_matching_node_and_match函数在设备树中遍历节点，对每个节点使用__of_match_node函数进行匹配。如果找到匹配的节点，将返回该节点的指针，并将match指针更新为匹配到的of_device_id条目，函数会自动增加匹配节点的引用计数。以下是使用of_find_matching_node_and_match函数的示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">my_match_table</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;vendor,device&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">match</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从根节点开始查找匹配的节点</span></span><br><span class="line">np = of_find_matching_node_and_match(<span class="literal">NULL</span>, my_match_table, &amp;match);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个of_device_id匹配表my_match_table，其中包含了一个兼容性字符串为”vendor,device”的匹配项。然后，我们使用of_find_matching_node_and_match函数从根节点开始查找匹配的节点。</p>
<h2 id="66-2实验程序编写"><a href="#66-2实验程序编写" class="headerlink" title="66.2实验程序编写"></a>66.2实验程序编写</h2><p>本实验驱动对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\55_of_01。</p>
<p>本小节驱动程序是由上一章程序修改而来，相较于源程序只是在probe函数中添加了本章节学习的of操作相关代码，用来获取设备树节点。</p>
<p>编写完成的platform_driver.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mod_devicetable.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">mydevice_node</span>;</span>      </span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">mynode_match</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">mynode_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123;.compatible=<span class="string">&quot;my devicetree&quot;</span>&#125;,</span><br><span class="line">	&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_probe: Probing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过节点名称查找设备树节点</span></span><br><span class="line">    mydevice_node = of_find_node_by_name(<span class="literal">NULL</span>, <span class="string">&quot;myLed&quot;</span>);</span><br><span class="line">	printk(<span class="string">&quot;mydevice node is %s\n&quot;</span>, mydevice_node-&gt;name);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 通过节点路径查找设备树节点</span></span><br><span class="line">    mydevice_node = of_find_node_by_path(<span class="string">&quot;/topeet/myLed&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;mydevice node is %s\n&quot;</span>, mydevice_node-&gt;name);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 获取父节点</span></span><br><span class="line">    mydevice_node = of_get_parent(mydevice_node);</span><br><span class="line">    printk(<span class="string">&quot;myled&#x27;s parent node is %s\n&quot;</span>, mydevice_node-&gt;name);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 获取子节点</span></span><br><span class="line">    mydevice_node = of_get_next_child(mydevice_node, <span class="literal">NULL</span>);</span><br><span class="line">    printk(<span class="string">&quot;myled&#x27;s sibling node is %s\n&quot;</span>, mydevice_node-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用compatible值查找节点</span></span><br><span class="line">	mydevice_node=of_find_compatible_node(<span class="literal">NULL</span> ,<span class="literal">NULL</span>, <span class="string">&quot;my devicetree&quot;</span>);</span><br><span class="line">	printk(<span class="string">&quot;mydevice node is %s\n&quot;</span> , mydevice_node-&gt;name);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//根据给定的of_device_id匹配表在设备树中查找匹配的节点</span></span><br><span class="line">	mydevice_node=of_find_matching_node_and_match(<span class="literal">NULL</span> , mynode_of_match, &amp;mynode_match);</span><br><span class="line">	printk(<span class="string">&quot;mydevice node is %s\n&quot;</span> ,mydevice_node-&gt;name);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Removing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table_id</span>[]  =</span> &#123;</span><br><span class="line">	&#123;.compatible=<span class="string">&quot;my devicetree&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">		.of_match_table =  of_match_table_id,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="66-3-运行测试"><a href="#66-3-运行测试" class="headerlink" title="66.3 运行测试"></a>66.3 运行测试</h2><h3 id="66-3-1-编译驱动程序"><a href="#66-3-1-编译驱动程序" class="headerlink" title="66.3.1 编译驱动程序"></a>66.3.1 编译驱动程序</h3><p>在上一小节中的platform_driver.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_driver.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_driver.c和Makefile文件目录下，如下图（图66-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024273.jpeg" alt="img"> </p>
<p>图 66-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图66-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024325.jpeg" alt="img"> </p>
<p>图 66-2</p>
<p>编译完生成platform_driver.ko目标文件，如下图（图66-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024321.jpeg" alt="img"> </p>
<p>图 66-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="66-3-2-运行测试"><a href="#66-3-2-运行测试" class="headerlink" title="66.3.2 运行测试"></a>66.3.2 运行测试</h3><p>在进行实验之前，首先要确保开发板烧写的是我们在65.2.1小节中编译出来的boot.img，开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图66-4）所示：</p>
<p>insmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024311.jpeg" alt="img"> </p>
<p>图 66-4</p>
<p>可以看到总共有4个打印，前两个打印都是查找的myLed节点，第三个打印是查找的myLed的父节点，也就是topeet节点，第四个打印是查找的topeet的子节点，也就又回到了myLed节点。第5个打印是通过compatible属性查找到的myLed节点，第6个打印是通过of_device_id匹配表查找到的myLed节点.</p>
<p>然后使用以下命令进行驱动模块的卸载，如下图（图66-5）所示：</p>
<p>rmmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024287.jpeg" alt="img"> </p>
<p>图 66-5</p>
<p>至此，使用of操作函数获取设备树节点实验就完成了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rk3568-%E9%A9%B1%E5%8A%A8/" rel="tag">rk3568 驱动</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-1-65-设备树下platform-device和platform-driver匹配实验"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/1-65-%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B8%8Bplatform-device%E5%92%8Cplatform-driver%E5%8C%B9%E9%85%8D%E5%AE%9E%E9%AA%8C/"
    >1-62-dtb文件格式讲解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/1-65-%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B8%8Bplatform-device%E5%92%8Cplatform-driver%E5%8C%B9%E9%85%8D%E5%AE%9E%E9%AA%8C/" class="article-date">
  <time datetime="2023-09-05T00:01:35.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第65章-设备树下platform-device和platform-driver匹配实验"><a href="#第65章-设备树下platform-device和platform-driver匹配实验" class="headerlink" title="第65章 设备树下platform_device和platform_driver匹配实验"></a>第65章 设备树下platform_device和platform_driver匹配实验</h1><p>在上一章节中我们学习了从device_node到platform_device的转换流程，转换完成之后操作系统才能够识别和管理设备，从而与platform_driver进行匹配，在本章将将会对设备树下platform_device和platform_driver的匹配进行讲解。</p>
<h2 id="65-1-of-match-table"><a href="#65-1-of-match-table" class="headerlink" title="65.1 of_match_table"></a>65.1 of_match_table</h2><p>在前面平台总线相关章节的学习中，了解到只有platform_device结构体中的name 属性与platform_driver结构体中嵌套的driver结构体name属性或者id_table相同才能加载probe初始化函数。</p>
<p>而为了使设备树能够与驱动程序进行匹配，需要在platform_driver驱动程序中添加driver结构体的of_match_table 属性。这个属性是一个指向 const struct of_device_id 结构的指针，用于描述设备树节点和驱动程序之间的匹配规则。of_device_id 结构体定义在内核源码的“&#x2F;include&#x2F;linux&#x2F;mod_devicetable.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>	name[<span class="number">32</span>];</span><br><span class="line">	<span class="type">char</span>	type[<span class="number">32</span>];</span><br><span class="line">	<span class="type">char</span>	compatible[<span class="number">128</span>];</span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct of_device_id 结构体通常作为一个数组在驱动程序中定义，用于描述设备树节点和驱动程序之间的匹配规则。数组的最后一个元素必须是一个空的结构体，以标记数组的结束。</p>
<p>以下是一个示例，展示了如何在驱动程序中使用 struct of_device_id 进行设备树匹配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">my_driver_match</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;vendor,device-1&quot;</span> &#125;,</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;vendor,device-2&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，my_driver_match 是一个 struct of_device_id 结构体数组。每个数组元素都包含了一个 compatible 字段，用于指定设备树节点的兼容性字符串。驱动程序将根据这些兼容性字符串与设备树中的节点进行匹配。</p>
<h2 id="65-2实验程序编写"><a href="#65-2实验程序编写" class="headerlink" title="65.2实验程序编写"></a>65.2实验程序编写</h2><p>本次实验的要求使用设备树描述下面的内存资源：<br><strong>内存资源：</strong></p>
<p>起始地址：0xFDD60000</p>
<p>结束地址：0xFDD60004</p>
<p>然后编写对应的platform_driver驱动程序，要求跟上述内存资源所创建的节点进行匹配，从而验证 上一小节讲解的of_match_table 属性。</p>
<h3 id="65-2-1-设备树的编写"><a href="#65-2-1-设备树的编写" class="headerlink" title="65.2.1 设备树的编写"></a>65.2.1 设备树的编写</h3><p>​	修改完成的dts文件和编译完成的boot.img镜像对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\54_devicetree_probe\dts。</p>
<p>首先来对rk3568的设备树结构进行以下介绍，根据sdk源码目录下的“device&#x2F;rockchip&#x2F;rk356x&#x2F;BoardConfig-rk3568-evb1-ddr4-v10.mk”默认配置文件可以了解到编译的设备树为rk3568-evb1-ddr4-v10-linux.dts,设备树之间的包含关系如下表所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024599.png" alt="image-20230906172158251"></p>
<p>rk3568-evb1-ddr4-v10-linux.dts是顶层设备树，为了便于理解我们之后在该设备树下进行节点的添加（当然这里也可以修改其他设备树），进入该设备树文件之后如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024627.jpeg" alt="img"> </p>
<p>然后将根据需求编写的设备树节点添加到rk3568-evb1-ddr4-v10-linux.dts中，要添加的内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">    topeet&#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        compatible = <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line"></span><br><span class="line">        myLed&#123;</span><br><span class="line">            compatible = <span class="string">&quot;my devicetree&quot;</span>;</span><br><span class="line">            reg = &lt;<span class="number">0xFDD60000</span> <span class="number">0x00000004</span>&gt;;</span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;;      </span><br></pre></td></tr></table></figure>

<p>为了避免#address-cells &#x3D; &lt;1&gt;; 和 #size-cells &#x3D; &lt;1&gt;;这两个属性改变根节点其他的节点的属性，所以在这里创建了一个topeet节点。在这个示例中，#address-cells 设置为 1表示地址使用一个32位的单元，#size-cells 也设置为 1 表示大小使用一个32位的单元。</p>
<p>第5行：将compatible属性设置为”simple-bus”用于表示 topeet 节点的兼容性，指明它是一个简单总线设备，在转换platform_device的过程中，会继续查找该节点的子节点。</p>
<p>第8行：myLed 节点下的compatible属性为”my devicetree”，表明该节点将会被转换为platform_device。</p>
<p>第9行：这个属性用于描述 myLed 节点的寄存器信息。reg 属性的值 &lt;0xFDD60000 0x00000004&gt; 表示 myLed 设备的寄存器起始地址为 0xFDD60000，大小为 0x00000004。</p>
<p>添加完成如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024665.jpeg" alt="img"> </p>
<p>保存退出之后，重新编译内核源码，编译完成之后将生成的boot.img烧写到开发板即可。</p>
<h3 id="66-2-2-驱动程序的编写"><a href="#66-2-2-驱动程序的编写" class="headerlink" title="66.2.2 驱动程序的编写"></a>66.2.2 驱动程序的编写</h3><p>本实验驱动对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\54_devicetree_probe\module。</p>
<p>本小节驱动程序是由“第52章 注册platform驱动实验”程序修改而来，相较于源程序只是添加了of_match_table相关代码，用来与设备树节点进行匹配。</p>
<p>编写完成的platform_driver.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mod_devicetable.h&gt;</span></span></span><br><span class="line"><span class="comment">// 平台设备的初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_probe: Probing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Removing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table_id</span>[]  =</span> &#123;</span><br><span class="line">	&#123;.compatible=<span class="string">&quot;my devicetree&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">		.of_match_table =  of_match_table_id,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="65-3-运行测试"><a href="#65-3-运行测试" class="headerlink" title="65.3 运行测试"></a>65.3 运行测试</h2><p>在上一小节中的platform_driver.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += platform_driver.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<h3 id="65-3-1-编译驱动程序"><a href="#65-3-1-编译驱动程序" class="headerlink" title="65.3.1 编译驱动程序"></a>65.3.1 编译驱动程序</h3><p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放platform_driver.c和Makefile文件目录下，如下图（图65-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024622.jpeg" alt="img"> </p>
<p>图 65-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图65-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024694.jpeg" alt="img"> </p>
<p>图 65-2</p>
<p>编译完生成platform_driver.ko目标文件，如下图（图65-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024642.jpeg" alt="img"> </p>
<p>图 65-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="65-3-2-运行测试"><a href="#65-3-2-运行测试" class="headerlink" title="65.3.2 运行测试"></a>65.3.2 运行测试</h3><p>在进行实验之前，首先要确保开发板烧写的是我们在65.2.1小节中编译出来的boot.img。开发板启动之后，首先进入到“&#x2F;proc&#x2F;device-tree”目录下，查看是否已经存在了topeet目录，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024040.jpeg" alt="img"> </p>
<p>只有在设备树节点编写正确的前提下，这里才会生成topeet目录，如果没有出现topeet目录就要回头检查看看了。</p>
<p>然后使用以下命令进行驱动模块的加载，如下图（图65-4）所示：</p>
<p>insmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024018.jpeg" alt="img"> </p>
<p>图 65-4</p>
<p>可以看到成功打印了在probe函数中的打印，证明我们添加的设备树节点和platform_driver驱动匹配成功了。</p>
<p>然后使用以下命令进行驱动模块的卸载，如下图（图65-5）所示：</p>
<p>rmmod platform_driver.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024031.jpeg" alt="img"> </p>
<p>图 65-5</p>
<p>至此，设备树下platform_device和platform_driver匹配实验就完成了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rk3568-%E9%A9%B1%E5%8A%A8/" rel="tag">rk3568 驱动</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-1-64-device-node转换成platform-device实验"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/1-64-device-node%E8%BD%AC%E6%8D%A2%E6%88%90platform-device%E5%AE%9E%E9%AA%8C/"
    >1-62-dtb文件格式讲解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/1-64-device-node%E8%BD%AC%E6%8D%A2%E6%88%90platform-device%E5%AE%9E%E9%AA%8C/" class="article-date">
  <time datetime="2023-09-05T00:01:34.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第64章-device-node转换成platform-device实验"><a href="#第64章-device-node转换成platform-device实验" class="headerlink" title="第64章 device_node转换成platform_device实验"></a>第64章 device_node转换成platform_device实验</h1><p>在上一章中，我们学习了dtb二进制文件展开成device_node的具体流程，而device_node这时候还并不能跟内核中的platform_driver进行对接，而为了让操作系统能够识别和管理设备，需要将设备节点转换为平台设备。</p>
<h2 id="64-1-转换规格"><a href="#64-1-转换规格" class="headerlink" title="64.1 转换规格"></a>64.1 转换规格</h2><p>在之前学习的平台总线模型中，device部分是用platform_device结构体来描述硬件资源的，所以内核最终会将内核认识的device_node树转换platform_ device，但是并不是所有的device_node都会被转换成platform_ device，只有满足要求的才会转换成platform_ device,转换成platform_device的节点可以在&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;devices下查看，那device_node节点要满足什么要求才会被转换成platform_device呢? </p>
<p>根据规则1，首先遍历根节点下包含 compatible 属性的子节点，对于每个子节点，创建一个对应的 platform_device。</p>
<p>根据规则2，遍历包含 compatible 属性为 “simple-bus”、”simple-mfd” 或 “isa” 的节点以及它们的子节点。如果子节点包含 compatible 属性值则会创建一个对应的platform_device。</p>
<p>根据规则3，检查节点的 compatible 属性是否包含 “arm” 或 “primecell”。如果是，则不将该节点转换为 platform_device，而是将其识别为 AMBA 设备。</p>
<p>接下来将通过几个设备树示例对上述规则进行实践。</p>
<p><strong>举例1：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = <span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0, 115200&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a35&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x1</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    aliases &#123;</span><br><span class="line">        led1 = <span class="string">&quot;/gpio@22020101&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node1 &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">        gpio@<span class="number">22020102</span> &#123;</span><br><span class="line">            reg = &lt;<span class="number">0x20220102</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node2 &#123;</span><br><span class="line">        node1-child &#123;</span><br><span class="line">            pinnum = &lt;<span class="number">01234</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@<span class="number">22020101</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;led&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x20220101</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的设备树中，总共有chosen、cpu1: cpu@1、aliases、node1、node2、gpio@22020101</p>
<p>这六个节点，其中前五个节点都没有compatible属性，所以并不会被转换为platform_device，而最后一个gpio@22020101节点符合规则一，在根节点下，且有compatible属性，所以最后会转换为platform_device。</p>
<p><strong>举例2：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = <span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0, 115200&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a35&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x1</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    aliases &#123;</span><br><span class="line">        led1 = <span class="string">&quot;/gpio@22020101&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node1 &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">		    compatible = <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line">        gpio@<span class="number">22020102</span> &#123;</span><br><span class="line">            reg = &lt;<span class="number">0x20220102</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node2 &#123;</span><br><span class="line">        node1-child &#123;</span><br><span class="line">            pinnum = &lt;<span class="number">01234</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@<span class="number">22020101</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;led&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x20220101</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相较于示例1的设备树，这里在node1节点中添加了 compatible 属性，但是这个compatible属性值为simple-bus，我们需要继续看他的子节点，子节点 gpio@22020102 并没有compatible属性值，所以这里的node1节点不会被转换。</p>
<p><strong>举例3：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = <span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0, 115200&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a35&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x1</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    aliases &#123;</span><br><span class="line">        led1 = <span class="string">&quot;/gpio@22020101&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node1 &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">		    compatible = <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line">        gpio@<span class="number">22020102</span> &#123;</span><br><span class="line">			compatible = <span class="string">&quot;gpio&quot;</span>;</span><br><span class="line">            reg = &lt;<span class="number">0x20220102</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node2 &#123;</span><br><span class="line">        node1-child &#123;</span><br><span class="line">            pinnum = &lt;<span class="number">01234</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@<span class="number">22020101</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;led&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x20220101</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相较于示例2的设备树，这里在node1节点的子节点 gpio@22020102 中添加了 compatible 属性，node1节点的compatible属性值为simple-bus，然后需要继续看他的子节点，子节点 gpio@22020102 的compatible属性值为gpio，所以这里的gpio@22020102节点会被转换成platform_device。</p>
<p>示例4：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = <span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0,115200&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpul: cpu@<span class="number">1</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a35&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x1</span>&gt;;</span><br><span class="line"></span><br><span class="line">        amba &#123;</span><br><span class="line">            compatible = <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line">            <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">            <span class="meta">#size-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">            ranges;</span><br><span class="line"></span><br><span class="line">            dmac_peri: dma-controller@ff250000 &#123;</span><br><span class="line">                compatible = <span class="string">&quot;arm,p1330&quot;</span>, <span class="string">&quot;arm,primecell&quot;</span>;</span><br><span class="line">                reg = &lt;<span class="number">0x0</span> <span class="number">0xff250000</span> <span class="number">0x0</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">                interrupts = &lt;GIC_SPI <span class="number">2</span> IRQ_TYPE_LEVEL_HIGH&gt;,</span><br><span class="line">                             &lt;GIC_SPI <span class="number">3</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">                <span class="meta">#dma-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">                arm,pl330-broken-no-flushp;</span><br><span class="line">                arm,p1330-periph-burst;</span><br><span class="line">                clocks = &lt;&amp;cru ACLK DMAC_PERI&gt;;</span><br><span class="line">                clock-names = <span class="string">&quot;apb_pclk&quot;</span>;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            dmac_bus: dma-controller@ff600000 &#123;</span><br><span class="line">                compatible = <span class="string">&quot;arm,p1330&quot;</span>, <span class="string">&quot;arm,primecell&quot;</span>;</span><br><span class="line">                reg = &lt;<span class="number">0x0</span> <span class="number">0xff600000</span> <span class="number">0x0</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">                interrupts = &lt;GIC_SPI <span class="number">0</span> IRQ_TYPE_LEVEL_HIGH&gt;,</span><br><span class="line">                             &lt;GIC_SPI <span class="number">1</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">                <span class="meta">#dma-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">                arm,pl330-broken-no-flushp;</span><br><span class="line">                arm,pl330-periph-burst;</span><br><span class="line">                clocks = &lt;&amp;cru ACLK_DMAC_BUS&gt;;</span><br><span class="line">                clock-names = <span class="string">&quot;apb_pclk&quot;</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>amba 节点的compatible值为simple-bus，不会被转换为 platform_device，而是作为父节点用于组织其他设备，所以需要来查看他的子节点。</p>
<p>dmac_peri: dma-controller@ff250000 节点: 该节点的 compatible 属性包含 “arm,p1330” 和 “arm,primecell”，根据规则3，该节点不会被转换为 platform_device，而是被识别为 AMBA 设备。</p>
<p>dmac_bus: dma-controller@ff600000 节点: 该节点的 compatible 属性包含 “arm,p1330” 和 “arm,primecell”，根据规则3，该节点不会被转换为 platform_device，而是被识别为 AMBA 设备。</p>
<h2 id="64-2-转换流程源码分析"><a href="#64-2-转换流程源码分析" class="headerlink" title="64.2 转换流程源码分析"></a>64.2 转换流程源码分析</h2><p>首先进入到内核源码目录下的“drivers&#x2F;of&#x2F;platform.c”文件中，找到第555行，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch_initcall_sync(of_platform_default_populate_init);</span><br></pre></td></tr></table></figure>

<p>arch_initcall_sync 是 Linux 内核中的一个函数，用于在内核初始化过程中执行架构相关的初始化函数。它属于内核的初始化调用机制，用于确保在系统启动过程中适时地调用特定架构的初始化函数。</p>
<p>在Linux内核的初始化过程中，各个子系统和架构会注册自己的初始化函数。这些初始化函数负责完成特定子系统或架构相关的初始化工作，例如初始化硬件设备、注册中断处理程序、设置内存映射等。而 arch_initcall_sync 函数则用于调用与当前架构相关的初始化函数。</p>
<p>当内核启动时，调用 rest_init() 函数来启动初始化过程。在初始化过程中，arch_initcall_sync 函数会被调用，以确保所有与当前架构相关的初始化函数按照正确的顺序执行。这样可以保证在启动过程中，特定架构相关的初始化工作得到正确地完成。</p>
<p>而of_platform_default_populate_init函数的作用是在内核初始化过程中自动解析设备树，并根据设备树中的设备节点创建对应的 platform_device 结构。它会遍历设备树中的设备节点，并为每个设备节点创建一个对应的 platform_device 结构，然后将其注册到内核中，使得设备驱动程序能够识别和操作这些设备。该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">of_platform_default_populate_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂停设备链接供应商同步状态</span></span><br><span class="line">    device_links_supplier_sync_state_pause();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设备树尚未填充，则返回错误码</span></span><br><span class="line">    <span class="keyword">if</span> (!of_have_populated_dt())</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 显式处理某些兼容性，因为我们不想为/reserved-memory中的每个具有“compatible”的节点创建platform_device。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    for_each_matching_node(node, reserved_mem_matches)</span><br><span class="line">        of_platform_device_create(node, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找节点 &quot;/firmware&quot;</span></span><br><span class="line">    node = of_find_node_by_path(<span class="string">&quot;/firmware&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="comment">// 使用该节点进行设备树平台设备的填充</span></span><br><span class="line">        of_platform_populate(node, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        of_node_put(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充其他设备</span></span><br><span class="line">    fw_devlink_pause();</span><br><span class="line">    of_platform_default_populate(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    fw_devlink_resume();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第6行：暂停设备链接供应商的同步状态，确保设备链接的状态不会在此过程中被改变。</p>
<p>第9行：检查设备树是否已经被填充。如果设备树尚未填充，则返回错误码 -ENODEV。</p>
<p>第16行：遍历设备树中与 reserved_mem_matches 匹配的节点。这些节点是 &#x2F;reserved-memory 中具有 “compatible” 属性的节点。</p>
<p>第17行：为 &#x2F;reserved-memory 中匹配的节点创建 platform_device 结构。这些节点不会为每个节点都创建 platform_device，而是根据需要进行显式处理。</p>
<p>第20行：在设备树中查找路径为 “&#x2F;firmware” 的节点。</p>
<p>第23行：使用找到的节点填充设备树中的平台设备。这些节点可能包含与固件相关的设备。</p>
<p>第28行：暂停固件设备链接，确保在填充其他设备时链接状态不会改变。</p>
<p>第29行：填充设备树中的其他设备。</p>
<p>第30行：恢复固件设备链接。</p>
<p>上诉内容中我们要着重关注的是第29行的of_platform_default_populate(NULL, NULL, NULL)函数，找到该函数的定义之后如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_platform_default_populate</span><span class="params">(<span class="keyword">struct</span> device_node *root,</span></span><br><span class="line"><span class="params">				 <span class="type">const</span> <span class="keyword">struct</span> of_dev_auxdata *lookup,</span></span><br><span class="line"><span class="params">				 <span class="keyword">struct</span> device *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> of_platform_populate(root, of_default_bus_match_table, lookup,</span><br><span class="line">				    parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的作用是调用 of_platform_populate 函数来填充设备树中的平台设备，并使用默认的设备匹配表 of_default_bus_match_table，设备匹配表内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_default_bus_match_table</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;simple-bus&quot;</span>, &#125;,</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;simple-mfd&quot;</span>, &#125;,</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;isa&quot;</span>, &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM_AMBA</span></span><br><span class="line">	&#123; .compatible = <span class="string">&quot;arm,amba-bus&quot;</span>, &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_ARM_AMBA */</span></span></span><br><span class="line">	&#123;&#125; <span class="comment">/* Empty terminated list */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述的设备匹配表就是我们在第一小节中第2条规则，，函数将自动根据设备树节点的属性匹配相应的设备驱动程序，并填充内核的平台设备列表。接下来找到of_platform_populate函数的定义，该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_platform_populate</span><span class="params">(<span class="keyword">struct</span> device_node *root,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> of_device_id *matches,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> of_dev_auxdata *lookup,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> device *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span></span><br><span class="line">	<span class="type">int</span> rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 root 不为空，则增加 root 节点的引用计数；否则，在设备树中根据路径查找 root 节点</span></span><br><span class="line">	root = root ? of_node_get(root) : of_find_node_by_path(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!root)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;%s()\n&quot;</span>, __func__);</span><br><span class="line">	pr_debug(<span class="string">&quot; starting at: %pOF\n&quot;</span>, root);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 暂停设备链接供应商同步状态</span></span><br><span class="line">	device_links_supplier_sync_state_pause();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历 root 节点的所有子节点</span></span><br><span class="line">	for_each_child_of_node(root, child) &#123;</span><br><span class="line">		<span class="comment">// 创建平台设备并添加到设备树总线</span></span><br><span class="line">		rc = of_platform_bus_create(child, matches, lookup, parent, <span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">if</span> (rc) &#123;</span><br><span class="line">			of_node_put(child);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 恢复设备链接供应商同步状态</span></span><br><span class="line">	device_links_supplier_sync_state_resume();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置 root 节点的 OF_POPULATED_BUS 标志</span></span><br><span class="line">	of_node_set_flag(root, OF_POPULATED_BUS);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放 root 节点的引用计数</span></span><br><span class="line">	of_node_put(root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的具体执行步骤如下：</p>
<p>第10行：检查给定的设备树节点 node 是否为有效节点。如果节点为空，函数将立即返回。</p>
<p>第21行：遍历设备树节点的子节点，查找与平台设备相关的节点。这些节点通常具有 compatible 属性，用于匹配设备驱动程序。</p>
<p>第23行：对于每个找到的平台设备节点，创建一个 platform_device 结构，并根据设备树节点的属性设置该结构的各个字段。</p>
<p>第25行：将创建的 platform_device 添加到内核的平台设备列表中，以便设备驱动程序能够识别和操作这些设备。</p>
<p>接下来对该函数的第23行核心代码of_platform_bus_create(child, matches, lookup, parent, true)函数进行讲解，该函数的具体定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">of_platform_bus_create</span><span class="params">(<span class="keyword">struct</span> device_node *bus,</span></span><br><span class="line"><span class="params">				  <span class="type">const</span> <span class="keyword">struct</span> of_device_id *matches,</span></span><br><span class="line"><span class="params">				  <span class="type">const</span> <span class="keyword">struct</span> of_dev_auxdata *lookup,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> device *parent, <span class="type">bool</span> strict)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_dev_auxdata</span> *<span class="title">auxdata</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *bus_id = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">void</span> *platform_data = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 确保设备节点具有 compatible 属性 */</span></span><br><span class="line">	<span class="keyword">if</span> (strict &amp;&amp; (!of_get_property(bus, <span class="string">&quot;compatible&quot;</span>, <span class="literal">NULL</span>))) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;%s() - skipping %pOF, no compatible prop\n&quot;</span>,</span><br><span class="line">			 __func__, bus);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 跳过不想创建设备的节点 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(of_match_node(of_skipped_node_table, bus))) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;%s() - skipping %pOF node\n&quot;</span>, __func__, bus);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (of_node_check_flag(bus, OF_POPULATED_BUS)) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;%s() - skipping %pOF, already populated\n&quot;</span>,</span><br><span class="line">			__func__, bus);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	auxdata = of_dev_lookup(lookup, bus);</span><br><span class="line">	<span class="keyword">if</span> (auxdata) &#123;</span><br><span class="line">		bus_id = auxdata-&gt;name;</span><br><span class="line">		platform_data = auxdata-&gt;platform_data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (of_device_is_compatible(bus, <span class="string">&quot;arm,primecell&quot;</span>)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 在此处不返回错误以保持与旧设备树文件的兼容性。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		of_amba_device_create(bus, bus_id, platform_data, parent);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent);</span><br><span class="line">	<span class="keyword">if</span> (!dev || !of_match_node(matches, bus))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	for_each_child_of_node(bus, child) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;   create child: %pOF\n&quot;</span>, child);</span><br><span class="line">		rc = of_platform_bus_create(child, matches, lookup, &amp;dev-&gt;dev, strict);</span><br><span class="line">		<span class="keyword">if</span> (rc) &#123;</span><br><span class="line">			of_node_put(child);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	of_node_set_flag(bus, OF_POPULATED_BUS);</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第14行：如果 strict 为真且设备节点 bus 没有兼容性属性，则输出调试信息并返回 0。这个条件判断确保设备节点具有 compatible 属性，因为 compatible 属性用于匹配设备驱动程序，对应我们在上一小节的第1条规则。</p>
<p>第21行：如果设备节点 bus 在被跳过的节点表中，则输出调试信息并返回 0。这个条件判断用于跳过不想创建设备的节点。</p>
<p>第27行：如果设备节点 bus 的 OF_POPULATED_BUS 标志已经设置，则输出调试信息并返回 0。这个条件判断用于避免重复创建已经填充的设备节点。</p>
<p>第34行：使用 lookup 辅助数据结构查找设备节点 bus 的特定配置信息，并将其赋值给变量 bus_id 和 platform_data。这个步骤用于获取设备节点的特定配置信息，以便在创建平台设备时使用，由于这里传入的参数为NULL，所以下面的条件判断并不会被执行。</p>
<p>第39行：如果设备节点 bus 兼容于 “arm,primecell”，则调用 of_amba_device_create 函数创建 AMBA 设备，并返回 0，对应我们在上一小节学习的第3条规则。</p>
<p>第47行：调用 of_platform_device_create_pdata函数创建平台设备，并将其赋值给变量 dev。然后，检查设备节点 bus是否与给定的匹配表 <code>matches</code> 匹配。如果平台设备创建失败或者设备节点不匹配，那么返回 0。</p>
<p>第51行-第58行：遍历设备节点 bus 的每个子节点 child，并递归调用 of_platform_bus_create 函数来创建子节点的平台设备。</p>
<p>接下来对该函数的第47行 of_platform_device_create_pdata函数进行讲解，该函数的具体定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> platform_device *<span class="title function_">of_platform_device_create_pdata</span><span class="params">(</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">					<span class="type">const</span> <span class="type">char</span> *bus_id,</span></span><br><span class="line"><span class="params">					<span class="type">void</span> *platform_data,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> device *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查设备节点是否可用或已填充 */</span></span><br><span class="line">	<span class="keyword">if</span> (!of_device_is_available(np) ||</span><br><span class="line">	    of_node_test_and_set_flag(np, OF_POPULATED))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 分配平台设备结构体 */</span></span><br><span class="line">	dev = of_device_alloc(np, bus_id, parent);</span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">goto</span> err_clear_flag;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置平台设备的一些属性 */</span></span><br><span class="line">	dev-&gt;dev.coherent_dma_mask = DMA_BIT_MASK(<span class="number">32</span>);</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;dev.dma_mask)</span><br><span class="line">		dev-&gt;dev.dma_mask = &amp;dev-&gt;dev.coherent_dma_mask;</span><br><span class="line">	dev-&gt;dev.bus = &amp;platform_bus_type;</span><br><span class="line">	dev-&gt;dev.platform_data = platform_data;</span><br><span class="line">	of_msi_configure(&amp;dev-&gt;dev, dev-&gt;dev.of_node);</span><br><span class="line">	of_reserved_mem_device_init_by_idx(&amp;dev-&gt;dev, dev-&gt;dev.of_node, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将平台设备添加到设备模型中 */</span></span><br><span class="line">	<span class="keyword">if</span> (of_device_add(dev) != <span class="number">0</span>) &#123;</span><br><span class="line">		platform_device_put(dev);</span><br><span class="line">		<span class="keyword">goto</span> err_clear_flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev;</span><br><span class="line"></span><br><span class="line">err_clear_flag:</span><br><span class="line">	<span class="comment">/* 清除设备节点的已填充标志 */</span></span><br><span class="line">	of_node_clear_flag(np, OF_POPULATED);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>第10行：函数会检查设备节点的可用性，即检查设备树对应节点的status属性。如果设备节点不可用或已经被填充，则直接返回 NULL。</p>
<p>第15行：函数调用 of_device_alloc 分配一个平台设备结构体，并将设备节点指针、设备标识符和父设备指针传递给它。如果分配失败，则跳转到 err_clear_flag 标签处进行错误处理。</p>
<p>第19行，函数设置平台设备的一些属性。它将 coherent_dma_mask 属性设置为 32 位的 DMA 位掩码，并检查 dma_mask 属性是否为 NULL。如果 dma_mask 为 NULL，则将其指向 coherent_dma_mask。然后，函数设置平台设备的总线类型为 platform_bus_type，并将平台数据指针存储在 platform_data 属性中。接着，函数调用 of_msi_configure 和 of_reserved_mem_device_init_by_idx 来配置设备的 MSI 和保留内存信息。</p>
<p>第29行：函数调用 of_device_add 将平台设备添加到设备模型中。如果添加失败，则释放已分配的平台设备，并跳转到 err_clear_flag 标签处进行错误处理。</p>
<p>至此，关于device_node转换成platform_device的具体流程就分析完成了，函数调用流程图如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024870.jpeg" alt="img"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rk3568-%E9%A9%B1%E5%8A%A8/" rel="tag">rk3568 驱动</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-1-63-dtb展开成device-node实验"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/1-63-dtb%E5%B1%95%E5%BC%80%E6%88%90device-node%E5%AE%9E%E9%AA%8C/"
    >1-62-dtb文件格式讲解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/1-63-dtb%E5%B1%95%E5%BC%80%E6%88%90device-node%E5%AE%9E%E9%AA%8C/" class="article-date">
  <time datetime="2023-09-05T00:01:33.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第63章-dtb展开成device-node实验"><a href="#第63章-dtb展开成device-node实验" class="headerlink" title="第63章 dtb展开成device_node实验"></a>第63章 dtb展开成device_node实验</h1><p>在上个小节中我们讲解了设备树deb的文件格式，那deb文件是怎样传递给内核的呢，那就进入到本小节的学习吧。</p>
<h2 id="63-1-dtb展开流程"><a href="#63-1-dtb展开流程" class="headerlink" title="63.1 dtb展开流程"></a>63.1 dtb展开流程</h2><p>dtb展开流程图如下所示：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\ksohtml13380\wps224.jpg" alt="img"> </p>
<p>接下来将会根据上图对deb的展开流程进行详细的讲解：</p>
<p><strong>（1）设备树源文件编写：</strong>根据之前的章节中讲解的设备树的基本语法和相关知识编写符合规范的设备树。</p>
<p><strong>（2）设备树编译：</strong>设备树源文件经过设备树编译器（dtc）进行编译，生成设备树二进制文件（.dtb）。设备树编译器会检查源文件的语法和语义，并将其转换为二进制格式，以便内核能够解析和使用。</p>
<p><strong>（3）boot.img</strong>镜像生成：boot.img是一个包含内核镜像、设备树二进制文件和其他一些资源文件的镜像文件（目前只是适用于瑞芯微的soc上，其他厂商的soc需要具体问题具体分析）。在生成boot.img时，通常会将内核镜像、设备树二进制文件和其他一些资源文件打包在一起。这个过程可以使用特定的工具或脚本完成。</p>
<p>（<strong>4）U-Boot加载：</strong>U-Boot（Universal Bootloader）是一种常用的开源引导加载程序，用于引导嵌入式系统。在系统启动过程中，U-Boot会将boot.img中的内核和设备树的二进制文件加载到系统内存的特定地址。</p>
<p><strong>（5）内核初始化：</strong>U-Boot将内核和设备树的二进制文件加载到系统内存的特定地址后，控制权会转交给内核。在内核初始化的过程中，会解析设备树二进制文件，将其展开为内核可以识别的数据结构，以便内核能够正确地初始化和管理硬件资源。</p>
<p><strong>（6）设备树展开：</strong>设备树展开是指将设备树二进制文件解析成内核中的设备节点（device_node）的过程。内核会读取设备树二进制文件的内容，并根据设备树的描述信息，构建设备树数据结构，例如设备节点、中断控制器、寄存器、时钟等。这些设备树数据结构将在内核运行时用于管理和配置硬件资源。</p>
<p>而本章节要讲解的重点就在上面的第6步“设备树的展开”，最终设备树二进制文件会被解析成device_node，device_node结构体定义在内核源码的“&#x2F;include&#x2F;linux&#x2F;of.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;                <span class="comment">// 设备节点的名称</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *type;                <span class="comment">// 设备节点的类型</span></span><br><span class="line">	phandle phandle;                  <span class="comment">// 设备节点的句柄</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *full_name;           <span class="comment">// 设备节点的完整名称</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> <span class="title">fwnode</span>;</span>     <span class="comment">// 设备节点的固件节点句柄</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">properties</span>;</span>     <span class="comment">// 设备节点的属性列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">deadprops</span>;</span>      <span class="comment">// 已删除的属性列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">parent</span>;</span>      <span class="comment">// 父设备节点指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span>       <span class="comment">// 子设备节点指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">sibling</span>;</span>     <span class="comment">// 兄弟设备节点指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_KOBJ)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>             <span class="comment">// 内核对象（用于 sysfs）</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> _flags;            <span class="comment">// 设备节点的标志位</span></span><br><span class="line">	<span class="type">void</span> *data;                      <span class="comment">// 与设备节点相关的数据指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SPARC)</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *path_component_name; <span class="comment">// 设备节点的路径组件名称</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> unique_id;          <span class="comment">// 设备节点的唯一标识</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">of_irq_controller</span> *<span class="title">irq_trans</span>;</span> <span class="comment">// 设备节点的中断控制器</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后对该结构体的重要参数进行讲解：</p>
<p>（1）name：name 字段表示设备节点的名称。设备节点的名称是在设备树中唯一标识该节点的字符串。它通常用于在设备树中引用设备节点。</p>
<p>（2）type：type 字段表示设备节点的类型。设备节点的类型提供了关于设备节点功能和所属设备类别的信息。它可以用于识别设备节点的用途和特性。</p>
<p>（3）properties：properties 字段是指向设备节点属性列表的指针。设备节点的属性包含了与设备节点相关联的配置和参数信息。属性以键值对的形式存在，可以提供设备的特定属性、寄存器地址、中断信息等。property字段同样定义在内核源码的“&#x2F;include&#x2F;linux&#x2F;of.h”文件中，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct property &#123;</span><br><span class="line">	char *name;                    // 属性的名称</span><br><span class="line">	int length;                    // 属性值的长度（字节数）</span><br><span class="line">	void *value;                   // 属性值的指针</span><br><span class="line">	struct property *next;         // 下一个属性节点指针</span><br><span class="line">#if defined(CONFIG_OF_DYNAMIC) || defined(CONFIG_SPARC)</span><br><span class="line">	unsigned long _flags;          // 属性的标志位</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_OF_PROMTREE)</span><br><span class="line">	unsigned int unique_id;        // 属性的唯一标识</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_OF_KOBJ)</span><br><span class="line">	struct bin_attribute attr;     // 内核对象二进制属性</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（4）parent：parent 字段指向父设备节点。设备树中的设备节点按照层次结构组织，父设备节点是当前设备节点的直接上级。通过 parent 字段，可以在设备树中遍历设备节点的父子关系。</p>
<p>（5）child：child 字段指向子设备节点。在设备树中，一个设备节点可以拥有多个子设备节点。通过 child 字段，可以遍历设备节点的所有子设备节点。</p>
<p>（6）sibling：sibling 字段指向兄弟设备节点。在设备树中，同一级别的兄弟设备节点共享相同的父设备节点。通过 sibling 字段，可以在同级设备节点之间进行遍历。</p>
<p>至此，关于device_node的结构体讲解就完成了，虽然我们现在知道了，dtb文件最终会展开成device_node这一可以让内核识别的格式，那更具体的实现流程是怎样的呢，让我们进入下一小节的学习吧。</p>
<h2 id="63-2-dtb解析过程源码分析"><a href="#63-2-dtb解析过程源码分析" class="headerlink" title="63.2 dtb解析过程源码分析"></a>63.2 dtb解析过程源码分析</h2><p>首先来到源码目录下的“&#x2F;init&#x2F;main.c”文件，找到其中的start_kernel 函数，start_kernel 函数是 Linux 内核启动的入口点，它是Linux内核的核心函数之一，负责完成内核的初始化和启动过程，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __init <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *command_line;</span><br><span class="line">    <span class="type">char</span> *after_dashes;</span><br><span class="line"></span><br><span class="line">    set_task_stack_end_magic(&amp;init_task);    <span class="comment">// 设置任务栈的魔数</span></span><br><span class="line">    smp_setup_processor_id();    <span class="comment">// 设置处理器ID</span></span><br><span class="line">    debug_objects_early_init();    <span class="comment">// 初始化调试对象</span></span><br><span class="line">    cgroup_init_early();    <span class="comment">// 初始化cgroup（控制组）</span></span><br><span class="line"></span><br><span class="line">    local_irq_disable();    <span class="comment">// 禁用本地中断</span></span><br><span class="line">    early_boot_irqs_disabled = <span class="literal">true</span>;     <span class="comment">// 标记早期引导期间中断已禁用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 中断仍然被禁用。进行必要的设置，然后启用它们。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    boot_cpu_init();    <span class="comment">// 初始化引导CPU</span></span><br><span class="line">    page_address_init();    <span class="comment">// 设置页地址</span></span><br><span class="line">    pr_notice(<span class="string">&quot;%s&quot;</span>, linux_banner);    <span class="comment">// 打印Linux内核版本信息</span></span><br><span class="line">    setup_arch(&amp;command_line);    <span class="comment">// 架构相关的初始化</span></span><br><span class="line">    mm_init_cpumask(&amp;init_mm);    <span class="comment">// 初始化内存管理的cpumask（CPU掩码）</span></span><br><span class="line">    setup_command_line(command_line);    <span class="comment">// 设置命令行参数</span></span><br><span class="line">    setup_nr_cpu_ids();    <span class="comment">// 设置CPU个数</span></span><br><span class="line">    setup_per_cpu_areas();    <span class="comment">// 设置每个CPU的区域</span></span><br><span class="line">    smp_prepare_boot_cpu();    <span class="comment">// 准备启动CPU（架构特定的启动CPU钩子）</span></span><br><span class="line">    boot_cpu_hotplug_init();    <span class="comment">// 初始化热插拔的引导CPU</span></span><br><span class="line"></span><br><span class="line">    build_all_zonelists(<span class="literal">NULL</span>);    <span class="comment">// 构建所有内存区域列表</span></span><br><span class="line">    page_alloc_init();    <span class="comment">// 初始化页面分配器</span></span><br><span class="line">	........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中跟设备树相关的函数为第20行的 setup_arch**(&amp;<strong>command_line</strong>);**该函数定义在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;setup.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">setup_arch</span><span class="params">(<span class="type">char</span> **cmdline_p)</span></span><br><span class="line">&#123;</span><br><span class="line">	init_mm.start_code = (<span class="type">unsigned</span> <span class="type">long</span>) _text;</span><br><span class="line">	init_mm.end_code   = (<span class="type">unsigned</span> <span class="type">long</span>) _etext;</span><br><span class="line">	init_mm.end_data   = (<span class="type">unsigned</span> <span class="type">long</span>) _edata;</span><br><span class="line">	init_mm.brk	   = (<span class="type">unsigned</span> <span class="type">long</span>) _end;</span><br><span class="line"></span><br><span class="line">	*cmdline_p = boot_command_line;</span><br><span class="line"></span><br><span class="line">	early_fixmap_init();    <span class="comment">// 初始化 early fixmap</span></span><br><span class="line">	early_ioremap_init();    <span class="comment">// 初始化 early ioremap</span></span><br><span class="line"></span><br><span class="line">	setup_machine_fdt(__fdt_pointer);    <span class="comment">// 设置机器的 FDT（平台设备树）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化静态密钥，早期可能会被 cpufeature 代码和早期参数启用</span></span><br><span class="line">	jump_label_init();</span><br><span class="line">	parse_early_param();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在启动可能的早期控制台后，解除屏蔽异步中断和 FIQ（一旦我们可以报告发生的系统错误）</span></span><br><span class="line">	local_daif_restore(DAIF_PROCCTX_NOIRQ);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在这个阶段，TTBR0仅用于身份映射。将其指向零页面，以避免做出猜测性的新条目获取。</span></span><br><span class="line">	cpu_uninstall_idmap();</span><br><span class="line"></span><br><span class="line">	xen_early_init();    <span class="comment">// Xen 平台的早期初始化</span></span><br><span class="line">	efi_init();    <span class="comment">// EFI 平台的初始化</span></span><br><span class="line">	arm64_memblock_init();    <span class="comment">// ARM64 内存块的初始化</span></span><br><span class="line"></span><br><span class="line">	paging_init();    <span class="comment">// 分页初始化</span></span><br><span class="line"></span><br><span class="line">	acpi_table_upgrade();    <span class="comment">// ACPI 表的升级</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析 ACPI 表以进行可能的引导时配置</span></span><br><span class="line">	acpi_boot_table_init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (acpi_disabled)</span><br><span class="line">		unflatten_device_tree();    <span class="comment">// 展开设备树</span></span><br><span class="line"></span><br><span class="line">	bootmem_init();    <span class="comment">// 引导内存的初始化</span></span><br><span class="line">	............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在setup_arch函数中与设备树相关的函数分别为第13行的setup_machine_fdt(__fdt_pointer)和第37行的unflatten_device_tree()，接下来将对上述两个函数进行详细的介绍。</p>
<h3 id="63-2-1-setup-machine-fdt-fdt-pointer"><a href="#63-2-1-setup-machine-fdt-fdt-pointer" class="headerlink" title="63.2.1 setup_machine_fdt(__fdt_pointer)"></a>63.2.1 setup_machine_fdt(__fdt_pointer)</h3><p>setup_machine_fdt(__fdt_pointer)中的__fdt_pointer是dtb二进制文件加载到内存的地址，该地址由bootloader启动kernel时透过x0寄存器传递过来的，具体的汇编代码在内核源码目录下的“&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;head.S”文件中，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">preserve_boot_args:</span><br><span class="line">	mov	x21, x0				// x21=FDT</span><br><span class="line"></span><br><span class="line">__primary_switched:</span><br><span class="line">	str_l	x21, __fdt_pointer, x5		// Save FDT pointer</span><br></pre></td></tr></table></figure>

<p>第2行: 将寄存器 x0 的值复制到寄存器 x21。x0 寄存器中保存了一个指针，该指针指向设备树（Device Tree）。</p>
<p>第4行: 将寄存器 x21 的值存储到内存地址 __fdt_pointer 中。</p>
<p>然后来看setup_machine_fdt函数，该函数定义在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;setup.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化设置机器的设备树</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">setup_machine_fdt</span><span class="params">(<span class="type">phys_addr_t</span> dt_phys)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 将设备树物理地址映射到内核虚拟地址空间</span></span><br><span class="line">    <span class="type">void</span> *dt_virt = fixmap_remap_fdt(dt_phys, &amp;size, PAGE_KERNEL);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果映射成功</span></span><br><span class="line">    <span class="keyword">if</span> (dt_virt) &#123;</span><br><span class="line">        <span class="comment">// 保留设备树占用的内存区域</span></span><br><span class="line">        memblock_reserve(dt_phys, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设备树映射失败或者设备树解析失败</span></span><br><span class="line">    <span class="keyword">if</span> (!dt_virt || !early_init_dt_scan(dt_virt)) &#123;</span><br><span class="line">        <span class="comment">// 输出错误信息</span></span><br><span class="line">		pr_crit(<span class="string">&quot;\n&quot;</span></span><br><span class="line">			<span class="string">&quot;Error: invalid device tree blob at physical address %pa (virtual address 0x%p)\n&quot;</span></span><br><span class="line">			<span class="string">&quot;The dtb must be 8-byte aligned and must not exceed 2 MB in size\n&quot;</span></span><br><span class="line">			<span class="string">&quot;\nPlease check your bootloader.&quot;</span>,</span><br><span class="line">			&amp;dt_phys, dt_virt);</span><br><span class="line">        <span class="comment">// 无限循环，等待系统崩溃</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            cpu_relax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 早期修复完成，将设备树映射为只读模式</span></span><br><span class="line">    fixmap_remap_fdt(dt_phys, &amp;size, PAGE_KERNEL_RO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取设备树的机器名</span></span><br><span class="line">    name = of_flat_dt_get_machine_name();</span><br><span class="line">    <span class="comment">// 如果设备树没有机器名，则返回</span></span><br><span class="line">    <span class="keyword">if</span> (!name)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	    pr_info(<span class="string">&quot;Machine model: %s\n&quot;</span>, name); <span class="comment">// 输出机器型号信息</span></span><br><span class="line">    dump_stack_set_arch_desc(<span class="string">&quot;%s (DT)&quot;</span>, name); <span class="comment">// 设置栈转储的架构描述为机器型号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数用于在内核启动过程中设置机器的设备树。在此函数中，将执行以下步骤： </p>
<p>1.使用 fixmap_remap_fdt() 将设备树映射到内核虚拟地址空间中的 fixmap 区域。 </p>
<p>2.如果映射成功，则使用 memblock_reserve() 保留设备树占用的物理内存区域。 </p>
<p>3.检查设备树的有效性和完整性，通过调用early_init_dt_scan()进行早期扫描。 如果设备树无效或扫描失败，则会输出错误信息并进入死循环。 </p>
<p>4.早期修复已完成，现在将设备树映射为只读，通过调用 fixmap_remap_fdt() 实现。</p>
<p>5.获取设备树中的机器模型名称，通过调用 of_flat_dt_get_machine_name()。</p>
<p>6.如果机器模型名称存在，则输出机器模型的信息，并通过 dump_stack_set_arch_desc() 设置堆栈描述信息。</p>
<p>其中上面的第3步调用的early_init_dt_scan() 需要详细的讲解一下，该函数定义在内核源码的“drivers&#x2F;of&#x2F;fdt.c”目录下，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __init <span class="title function_">early_init_dt_scan</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证设备树的兼容性和完整性</span></span><br><span class="line">    status = early_init_dt_verify(params);</span><br><span class="line">    <span class="keyword">if</span> (!status)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描设备树节点</span></span><br><span class="line">    early_init_dt_scan_nodes();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，调用 early_init_dt_verify() 函数对设备树进行兼容性和完整性验证。该函数可能会检查设备树中的一致性标记、版本信息以及必需的节点和属性是否存在。如果验证失败，函数会返回 false。该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __init <span class="title function_">early_init_dt_verify</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 验证传入的参数是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!params)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查设备树头部的有效性</span></span><br><span class="line">    <span class="comment">// 如果设备树头部无效，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (fdt_check_header(params))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置指向设备树的指针为传入的参数</span></span><br><span class="line">    initial_boot_params = params;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算设备树的 CRC32 校验值</span></span><br><span class="line">    <span class="comment">// 并将结果保存在全局变量 of_fdt_crc32 中</span></span><br><span class="line">    of_fdt_crc32 = crc32_be(~<span class="number">0</span>, initial_boot_params, fdt_totalsize(initial_boot_params));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 true，表示设备树验证和初始化成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第4行：该进行参数的有效性检查，如果 params 为空，则直接返回 false，表示参数无效。</p>
<p>第9行：检查设备树头部的有效性。fdt_check_header 是一个用于检查设备树头部的函数，如果设备树头部无效，则返回 false，表示设备树不合法。</p>
<p>第13行：如果设备树头部有效，程序继续执行，将传入的 params 赋值给全局变量 initial_boot_params，用来保存设备树的指针。</p>
<p>第17行，使用 crc32_be 函数计算设备树的 CRC32 校验值，其中 crc32_be 是一个用于计算 CRC32 校验值的函数，~0 表示初始值为全1的位模式。计算完成后，将结果保存在全局变量 of_fdt_crc32 中。</p>
<p>然后继续回到early_init_dt_scan() 函数中，如果设备树验证成功（即 status 为真），则调用 early_init_dt_scan_nodes() 函数。这个函数的作用是扫描设备树的节点并进行相应的处理，该函数的具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void __init early_init_dt_scan_nodes(void)</span><br><span class="line">&#123;</span><br><span class="line">	/* 从 /chosen 节点中检索各种信息 */</span><br><span class="line">	of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);</span><br><span class="line"></span><br><span class="line">	/* 初始化 &#123;size,address&#125;-cells 信息 */</span><br><span class="line">	of_scan_flat_dt(early_init_dt_scan_root, NULL);</span><br><span class="line"></span><br><span class="line">	/* 设置内存信息，调用 early_init_dt_add_memory_arch 函数 */</span><br><span class="line">	of_scan_flat_dt(early_init_dt_scan_memory, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数early_init_dt_scan_nodes被声明为__init，这表示它是在内核初始化阶段被调用，并且在初始化完成后不再需要。该函数的目的是在早期阶段扫描设备树节点，并执行一些初始化操作。</p>
<p>函数中主要调用了of_scan_flat_dt函数，该函数用于扫描平面设备树（flat device tree）。平面设备树是一种将设备树以紧凑形式表示的数据结构，它不使用树状结构，而是使用线性结构，以节省内存空间。</p>
<p>具体来看，early_init_dt_scan_nodes函数的执行步骤如下：</p>
<p>（1）of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line)：从设备树的&#x2F;chosen节点中检索各种信息。&#x2F;chosen节点通常包含了一些系统的全局配置参数，比如命令行参数。early_init_dt_scan_chosen是一个回调函数，用于处理&#x2F;chosen节点的信息。boot_command_line是一个参数，表示内核启动时的命令行参数。</p>
<p>（2）of_scan_flat_dt(early_init_dt_scan_root, NULL)：初始化{size,address}-cells信息。{size,address}-cells描述了设备节点中地址和大小的编码方式。early_init_dt_scan_root是一个回调函数，用于处理设备树的根节点。</p>
<p>（3）of_scan_flat_dt(early_init_dt_scan_memory, NULL)：设置内存信息，并调用early_init_dt_add_memory_arch函数。这个步骤主要用于在设备树中获取内存的相关信息，并将其传递给内核的内存管理模块。early_init_dt_scan_memory是一个回调函数，用于处理内存信息。</p>
<p>至此，关于setup_machine_fdt(__fdt_pointer)代码的分析就完成了。</p>
<h3 id="63-2-2-unflatten-device-tree"><a href="#63-2-2-unflatten-device-tree" class="headerlink" title="63.2.2 unflatten_device_tree"></a>63.2.2 unflatten_device_tree</h3><p>该函数用于解析设备树，将紧凑的设备树数据结构转换为树状结构的设备树，该函数定义在内核源码目录下的“&#x2F;drivers&#x2F;of&#x2F;fdt.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">unflatten_device_tree</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 解析设备树 */</span></span><br><span class="line">    __unflatten_device_tree(initial_boot_params, <span class="literal">NULL</span>, &amp;of_root,</span><br><span class="line">                            early_init_dt_alloc_memory_arch, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取指向 &quot;/chosen&quot; 和 &quot;/aliases&quot; 节点的指针，以供全局使用 */</span></span><br><span class="line">    of_alias_scan(early_init_dt_alloc_memory_arch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 运行设备树的单元测试 */</span></span><br><span class="line">    unittest_unflatten_overlay_base();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数主要用于解析设备树，并将解析后的设备树存储在全局变量of_root中。</p>
<p>函数首先调用__unflatten_device_tree函数来执行设备树的解析操作。解析后的设备树将使用of_root指针进行存储。</p>
<p>接下来，函数调用of_alias_scan函数。这个函数用于扫描设备树中的&#x2F;chosen和&#x2F;aliases节点，并为它们分配内存。这样，其他部分的代码可以通过全局变量访问这些节点。</p>
<p>最后，函数调用unittest_unflatten_overlay_base函数，用于运行设备树的单元测试。</p>
<p>然后对__unflatten_device_tree这一设备树的解析函数进行详细的介绍，该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__unflatten_device_tree(<span class="type">const</span> <span class="type">void</span> *blob,</span><br><span class="line">		      <span class="keyword">struct</span> device_node *dad,</span><br><span class="line">			      <span class="keyword">struct</span> device_node **mynodes,</span><br><span class="line">			      <span class="type">void</span> *(*dt_alloc)(u64 size, u64 align),</span><br><span class="line">			      <span class="type">bool</span> detached)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	<span class="type">void</span> *mem;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot; -&gt; unflatten_device_tree()\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!blob) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;No device tree pointer\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;Unflattening device tree:\n&quot;</span>);</span><br><span class="line">	pr_debug(<span class="string">&quot;magic: %08x\n&quot;</span>, fdt_magic(blob));</span><br><span class="line">	pr_debug(<span class="string">&quot;size: %08x\n&quot;</span>, fdt_totalsize(blob));</span><br><span class="line">	pr_debug(<span class="string">&quot;version: %08x\n&quot;</span>, fdt_version(blob));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fdt_check_header(blob)) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;Invalid device tree blob header\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 第一遍扫描，计算大小 */</span></span><br><span class="line">	size = unflatten_dt_nodes(blob, <span class="literal">NULL</span>, dad, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (size &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	size = ALIGN(size, <span class="number">4</span>);</span><br><span class="line">	pr_debug(<span class="string">&quot;  大小为 %d，正在分配内存...\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 为展开的设备树分配内存 */</span></span><br><span class="line">	mem = dt_alloc(size + <span class="number">4</span>, <span class="keyword">alignof</span>(<span class="keyword">struct</span> device_node));</span><br><span class="line">	<span class="keyword">if</span> (!mem)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(mem, <span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line">	*(__be32 *)(mem + size) = cpu_to_be32(<span class="number">0xdeadbeef</span>);</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;  正在展开 %p...\n&quot;</span>, mem);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 第二遍扫描，实际展开设备树 */</span></span><br><span class="line">	unflatten_dt_nodes(blob, mem, dad, mynodes);</span><br><span class="line">	<span class="keyword">if</span> (be32_to_cpup(mem + size) != <span class="number">0xdeadbeef</span>)</span><br><span class="line">		pr_warning(<span class="string">&quot;End of tree marker overwritten: %08x\n&quot;</span>,</span><br><span class="line">			   be32_to_cpup(mem + size));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (detached &amp;&amp; mynodes) &#123;</span><br><span class="line">		of_node_set_flag(*mynodes, OF_DETACHED);</span><br><span class="line">		pr_debug(<span class="string">&quot;unflattened tree is detached\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot; &lt;- unflatten_device_tree()\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的重点在两次设备树的扫描上，第一遍扫描的目的是计算展开设备树所需的内存大小。</p>
<p>第29行：unflatten_dt_nodes函数的作用是递归地遍历设备树数据块，并计算展开设备树所需的内存大小。它接受四个参数：blob（设备树数据块指针）、start（当前节点的起始地址，初始为NULL）、dad（父节点指针）和mynodes（用于存储节点指针数组的指针，初始为NULL）。</p>
<p>第一遍扫描完成后，unflatten_dt_nodes函数会返回展开设备树所需的内存大小，然后在对大小进行对齐操作，并为展开的设备树分配内存。</p>
<p>第二遍扫描的目的是实际展开设备树，并填充设备节点的名称、类型和属性等信息。</p>
<p>第49行：再次调用了unflatten_dt_nodes函数进行第二遍扫描。通过这样的过程，第二遍扫描会将设备树数据块中的节点展开为真正的设备节点，并填充节点的名称、类型和属性等信息。这样就完成了设备树的展开过程。</p>
<p>最后我们来对unflatten_dt_nodes函数内容进行一下深究，unflatten_dt_nodes函数具体定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">unflatten_dt_nodes</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *blob,</span></span><br><span class="line"><span class="params">			      <span class="type">void</span> *mem,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> device_node *dad,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> device_node **nodepp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">root</span>;</span>  <span class="comment">// 根节点</span></span><br><span class="line">	<span class="type">int</span> offset = <span class="number">0</span>, depth = <span class="number">0</span>, initial_depth = <span class="number">0</span>;  <span class="comment">// 偏移量、深度和初始深度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_MAX_DEPTH	64  <span class="comment">// 最大深度</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nps</span>[<span class="title">FDT_MAX_DEPTH</span>];</span>  <span class="comment">// 设备节点数组</span></span><br><span class="line">	<span class="type">void</span> *base = mem;  <span class="comment">// 基地址，用于计算偏移量</span></span><br><span class="line">	<span class="type">bool</span> dryrun = !base;  <span class="comment">// 是否只是模拟运行，不实际处理</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nodepp)</span><br><span class="line">		*nodepp = <span class="literal">NULL</span>;  <span class="comment">// 如果指针不为空，将其置为空指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果 @dad 有效，则表示正在展开设备子树。</span></span><br><span class="line"><span class="comment">	 * 在第一层深度可能有多个节点。</span></span><br><span class="line"><span class="comment">	 * 将 @depth 设置为 1，以使 fdt_next_node() 正常工作。</span></span><br><span class="line"><span class="comment">	 * 当发现负的 @depth 时，该函数会立即退出。</span></span><br><span class="line"><span class="comment">	 * 否则，除第一个节点外的设备节点将无法成功展开。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dad)</span><br><span class="line">		depth = initial_depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	root = dad;  <span class="comment">// 根节点为 @dad</span></span><br><span class="line">	nps[depth] = dad;  <span class="comment">// 将根节点放入设备节点数组</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (offset = <span class="number">0</span>;</span><br><span class="line">	     offset &gt;= <span class="number">0</span> &amp;&amp; depth &gt;= initial_depth;</span><br><span class="line">	     offset = fdt_next_node(blob, offset, &amp;depth)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(depth &gt;= FDT_MAX_DEPTH))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果未启用 CONFIG_OF_KOBJ 并且节点不可用，则跳过该节点</span></span><br><span class="line">		<span class="keyword">if</span> (!IS_ENABLED(CONFIG_OF_KOBJ) &amp;&amp;</span><br><span class="line">		    !of_fdt_device_is_available(blob, offset))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 填充节点信息，并将子节点添加到设备节点数组</span></span><br><span class="line">		<span class="keyword">if</span> (!populate_node(blob, offset, &amp;mem, nps[depth],</span><br><span class="line">				   &amp;nps[depth+<span class="number">1</span>], dryrun))</span><br><span class="line">			<span class="keyword">return</span> mem - base;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!dryrun &amp;&amp; nodepp &amp;&amp; !*nodepp)</span><br><span class="line">			*nodepp = nps[depth+<span class="number">1</span>];  <span class="comment">// 将子节点指针赋值给 @nodepp</span></span><br><span class="line">		<span class="keyword">if</span> (!dryrun &amp;&amp; !root)</span><br><span class="line">			root = nps[depth+<span class="number">1</span>];  <span class="comment">// 如果根节点为空，则将子节点设置为根节点</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset &lt; <span class="number">0</span> &amp;&amp; offset != -FDT_ERR_NOTFOUND) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;Error %d processing FDT\n&quot;</span>, offset);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 反转子节点列表。一些驱动程序假设节点顺序与 .dts 文件中的节点顺序一致</span></span><br><span class="line">	<span class="keyword">if</span> (!dryrun)</span><br><span class="line">		reverse_nodes(root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mem - base;  <span class="comment">// 返回处理的字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unflatten_dt_nodes 函数的作用我们在上面已经讲解过了，这里重点介绍第31行的 fdt_next_node()函数和第41行的populate_node函数。</p>
<p>fdt_next_node() 函数用来遍历设备树的节点。从偏移量为 0 开始，只要偏移量大于等于 0 且深度大于等于初始深度，就执行循环。循环中的每次迭代都会处理一个设备树节点。</p>
<p>在每次迭代中，首先检查深度是否超过了最大深度 FDT_MAX_DEPTH，如果超过了，则跳过该节点。</p>
<p>如果未启用 CONFIG_OF_KOBJ 并且节点不可用（通过 of_fdt_device_is_available() 函数判断），则跳过该节点。</p>
<p>随后调用 populate_node() 函数填充节点信息，并将子节点添加到设备节点数组 nps 中。 populate_node() 函数定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">static bool populate_node(const void *blob,</span><br><span class="line">			  int offset,</span><br><span class="line">			  void **mem,</span><br><span class="line">			  struct device_node *dad,</span><br><span class="line">			  struct device_node **pnp,</span><br><span class="line">			  bool dryrun)</span><br><span class="line">&#123;</span><br><span class="line">	struct device_node *np;  // 设备节点指针</span><br><span class="line">	const char *pathp;  // 节点路径字符串指针</span><br><span class="line">	unsigned int l, allocl;  // 路径字符串长度和分配的内存大小</span><br><span class="line"></span><br><span class="line">	pathp = fdt_get_name(blob, offset, &amp;l);  // 获取节点路径和长度</span><br><span class="line">	if (!pathp) &#123;</span><br><span class="line">		*pnp = NULL;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	allocl = ++l;  // 分配内存大小为路径长度加一，用于存储节点路径字符串</span><br><span class="line"></span><br><span class="line">	np = unflatten_dt_alloc(mem, sizeof(struct device_node) + allocl,</span><br><span class="line">				__alignof__(struct device_node));  // 分配设备节点内存</span><br><span class="line">	if (!dryrun) &#123;</span><br><span class="line">		char *fn;</span><br><span class="line">		of_node_init(np);  // 初始化设备节点</span><br><span class="line">		np-&gt;full_name = fn = ((char *)np) + sizeof(*np);  // 设置设备节点的完整路径名</span><br><span class="line"></span><br><span class="line">		memcpy(fn, pathp, l);  // 将节点路径字符串复制到设备节点的完整路径名中</span><br><span class="line"></span><br><span class="line">		if (dad != NULL) &#123;</span><br><span class="line">			np-&gt;parent = dad;  // 设置设备节点的父节点</span><br><span class="line">			np-&gt;sibling = dad-&gt;child;  // 设置设备节点的兄弟节点</span><br><span class="line">			dad-&gt;child = np;  // 将设备节点添加为父节点的子节点</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	populate_properties(blob, offset, mem, np, pathp, dryrun);  // 填充设备节点的属性信息</span><br><span class="line">	if (!dryrun) &#123;</span><br><span class="line">		np-&gt;name = of_get_property(np, &quot;name&quot;, NULL);  // 获取设备节点的名称属性</span><br><span class="line">		np-&gt;type = of_get_property(np, &quot;device_type&quot;, NULL);  // 获取设备节点的设备类型属性</span><br><span class="line"></span><br><span class="line">		if (!np-&gt;name)</span><br><span class="line">			np-&gt;name = &quot;&lt;NULL&gt;&quot;;  // 如果设备节点没有名称属性，则设置为&quot;&lt;NULL&gt;&quot;</span><br><span class="line">		if (!np-&gt;type)</span><br><span class="line">			np-&gt;type = &quot;&lt;NULL&gt;&quot;;  // 如果设备节点没有设备类型属性，则设置为&quot;&lt;NULL&gt;&quot;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*pnp = np;  // 将设备节点指针赋值给*pnp</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在populate_node 函数中首先会调用第18行的 unflatten_dt_alloc 函数分配设备节点内存。分配的内存大小为 sizeof(struct device_node) + allocl 字节，并使用 <strong>alignof</strong>(struct device_node) 对齐。然后调用 populate_properties 函数填充设备节点的属性信息。该函数会解析设备节点的属性，并根据需要分配内存来存储属性值。</p>
<p>至此，关于dtb二进制文件的解析过程就讲解完成了，完整的源码分析流程图如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024648.jpeg" alt="img"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rk3568-%E9%A9%B1%E5%8A%A8/" rel="tag">rk3568 驱动</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-1-62-dtb文件格式讲解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/1-62-dtb%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%AE%B2%E8%A7%A3/"
    >1-62-dtb文件格式讲解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/1-62-dtb%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%AE%B2%E8%A7%A3/" class="article-date">
  <time datetime="2023-09-05T00:01:32.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第62章-dtb文件格式讲解"><a href="#第62章-dtb文件格式讲解" class="headerlink" title="第62章 dtb文件格式讲解"></a>第62章 dtb文件格式讲解</h1><p>设备树 Blob (DTB) 格式是设备树数据的平面二进制编码。它用于在软件程序之间交换设备树数据。例如，在启动操作系统时，固件会将 DTB 传递给操作系统内核。</p>
<p>DTB 格式在单个、线性、无指针数据结构中对设备树数据进行编码。它由一个小头部和三个可变大小的部分组成：内存保留块、结构块和字符串块。这些应该以该顺序出现在展平的设备树中。因此，设备树结构作为一个整体，当加载到内存地址时，将类似于下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022286.jpeg" alt="img"> </p>
<p>本节课将以下面的设备树为例对设备树的二进制文件格式进行讲解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">    model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    chosen &#123;</span><br><span class="line">        bootargs = <span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0, 115200&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a35&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x1</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    aliases &#123;</span><br><span class="line">        led1 = <span class="string">&quot;/gpio@22020101&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node1 &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">        gpio@<span class="number">22020102</span> &#123;</span><br><span class="line">            reg = &lt;<span class="number">0x20220102</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    node2 &#123;</span><br><span class="line">        node1-child &#123;</span><br><span class="line">            pinnum = &lt;<span class="number">01234</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gpio@<span class="number">22020101</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;led&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x20220101</span> <span class="number">0x40</span>&gt;;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而我们之后要分析的是二进制的dtb文件，所以需要使用dtc工具将上面的dts文件编译成dtb文件，具体命令如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022423.jpeg" alt="img"> </p>
<p>为了方便用户学习，已经将本章节要讲解的设备树dts文件和dtb文件放在了对应的网盘路径下，同时也将pxBinaryViewerSetup二进制分析软件放在了同一目录下，iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\49_dt_format，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022265.jpeg" alt="img"> </p>
<p>使用二进制分析软件打开deb文件并设置大端模式之后如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022400.jpeg" alt="img"></p>
<p>在接下来的小节中将会对读取出的设备树二进制内容进行讲解。</p>
<h2 id="62-1-Header"><a href="#62-1-Header" class="headerlink" title="62.1 Header"></a>62.1 Header</h2><p>devicetree 的头布局由以下 C 结构定义。所有的头字段都是 32 位整数，以大端格式存储。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct fdt_header &#123;</span><br><span class="line">    uint32_t magic;                 // 设备树头部的魔数</span><br><span class="line">    uint32_t totalsize;             // 设备树文件的总大小</span><br><span class="line">    uint32_t off_dt_struct;         // 设备树结构体（节点数据）相对于文件开头的偏移量</span><br><span class="line">    uint32_t off_dt_strings;        // 设备树字符串表相对于文件开头的偏移量</span><br><span class="line">    uint32_t off_mem_rsvmap;        // 内存保留映射表相对于文件开头的偏移量</span><br><span class="line">    uint32_t version;               // 设备树版本号</span><br><span class="line">    uint32_t last_comp_version;     // 最后一个兼容版本号</span><br><span class="line">    uint32_t boot_cpuid_phys;       // 启动 CPU 的物理 ID</span><br><span class="line">    uint32_t size_dt_strings;       // 设备树字符串表的大小</span><br><span class="line">    uint32_t size_dt_struct;        // 设备树结构体（节点数据）的大小</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个字段的描述如下所示：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>magic</td>
<td>该字段为固定值 0xd00dfeed（大端）。</td>
</tr>
<tr>
<td>totalsize</td>
<td>该字段包含设备树数据结构的总大小（以字节为单位）。此大小应包含结构的所有部分：标题、内存保留块、结构块和字符串块，以及块之间或最后一个块之后的任何空闲空间间隙。</td>
</tr>
<tr>
<td>off_dt_struct</td>
<td>该字段包含结构块从头开始的以字节为单位的偏移量。</td>
</tr>
<tr>
<td>off_dt_strings</td>
<td>该字段包含字符串块从头开始的以字节为单位的偏移量。</td>
</tr>
<tr>
<td>off_mem_rsvmap</td>
<td>该字段包含从头开始的内存保留块的字节偏移量。</td>
</tr>
<tr>
<td>version</td>
<td>该字段包含设备树数据结构的版本。</td>
</tr>
<tr>
<td>last_comp_version</td>
<td>向后兼容的设备树数据结构的最低版本。</td>
</tr>
<tr>
<td>boot_cpuid_phys</td>
<td>与设备树CPU 节点的reg属性对应</td>
</tr>
<tr>
<td>size_dt_strings</td>
<td>设备树字符串块部分的字节长度。</td>
</tr>
<tr>
<td>size_dt_struct</td>
<td>设备树结构块部分的字节长度。</td>
</tr>
</tbody></table>
<p>然后来查看二进制文件，其中4个字节表示一个单位，前十个单位分别代表上述的十个字段如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022323.jpeg" alt="img"> </p>
<table>
<thead>
<tr>
<th>字段</th>
<th>十六进制数值</th>
<th>代表含义</th>
</tr>
</thead>
<tbody><tr>
<td>magic</td>
<td>D00DFEED</td>
<td>固定值</td>
</tr>
<tr>
<td>totalsize</td>
<td>000002A4</td>
<td>转换为十进制之后为676，表示该文件大小为676字节</td>
</tr>
<tr>
<td>off_dt_struct</td>
<td>00000038</td>
<td>表示结构块从00000038这个地址开始，和后面的size_dt_struct结构块大小参数一起可以确定结构块的存储范围</td>
</tr>
<tr>
<td>off_dt_strings</td>
<td>0000024C</td>
<td>表示字符串块从0000024C这个地址开始，和后面的size_dt_strings字符串块大小参数一起可以确定字符串块的存储范围</td>
</tr>
<tr>
<td>off_mem_rsvmap</td>
<td>00000028</td>
<td>表示内存保留块的偏移为00000028， header之后结构快之前都是属于内存保留块。</td>
</tr>
<tr>
<td>version</td>
<td>00000011</td>
<td>11转换为十进制之后为17，表示当前设备树结构版本为17</td>
</tr>
<tr>
<td>last_comp_version</td>
<td>00000010</td>
<td>10转换为十进制之后为16，表示向前兼容的设备树结构版本为16</td>
</tr>
<tr>
<td>boot_cpuid_phys</td>
<td>00000000</td>
<td>表示设备树的teg属性为0</td>
</tr>
<tr>
<td>size_dt_strings</td>
<td>00000058</td>
<td>表示字符串块的大小为00000058 ，和前面的off_dt_strings字符串块偏移值一起可以确定字符串块的范围</td>
</tr>
<tr>
<td>size_dt_struct</td>
<td>00000214</td>
<td>表示结构块的大小为00000214，和前面的off_dt_struct结构块偏移值一起可以确定结构块的范围</td>
</tr>
</tbody></table>
<p>在接下来的小节中将会对header提到的内存保留块、结构块和字符串块进行更详细的讲解。</p>
<h2 id="62-2-内存保留块"><a href="#62-2-内存保留块" class="headerlink" title="62.2 内存保留块"></a>62.2 内存保留块</h2><p>内存保留块（Memory Reserved Block）是用于客户端程序的保护和保留物理内存区域的列表。这些保留区域不应被用于一般的内存分配，而是用于保护重要数据结构，以防止客户端程序覆盖这些数据。内存保留块的目的是确保特定的内存区域在客户端程序运行时不被修改或使用。由于在示例设备树中没有设置内存保留块，所以相应的区域都为0，如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022259.jpeg" alt="img"> </p>
<p><strong>保留区域列表：</strong> 内存保留块是一个由一组 64 位大端整数对构成的列表。每对整数对应一个保留内存区域，其中包含物理地址和区域的大小（以字节为单位）。这些保留区域应该彼此不重叠。</p>
<p><strong>保留区域的用途：</strong>客户端程序不应访问内存保留块中的保留区域，除非引导程序提供的其他信息明确指示可以访问。引导程序可以使用特定的方式来指示客户端程序可以访问保留内存的部分内容。引导程序可能会在文档、可选的扩展或特定于平台的文档中说明保留内存的特定用途。</p>
<p><strong>格式：</strong>内存保留块中的每个保留区域由一个64位大端整数对表示。每对由以下 C 结构表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct fdt_reserve_entry &#123; </span><br><span class="line">	uint64_t address; </span><br><span class="line">	uint64_t size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的第一个整数表示保留区域的物理地址，第二个整数表示保留区域的大小（以字节为单位）。每个整数都以 64 位的形式表示，即使在32位架构上也是如此。在32位CPU上，整数的高 32 位将被忽略。</p>
<p>内存保留块为设备树提供了保护和保留物理内存区域的功能。它确保了特定的内存区域在客户端程序运行时不被修改或使用。这样可以确保引导程序和其他关键组件在需要的情况下能够访问保留内存的特定部分，并保护关键数据结构免受意外修改。</p>
<h2 id="62-3-结构快"><a href="#62-3-结构快" class="headerlink" title="62.3 结构快"></a>62.3 结构快</h2><p>结构块是设备树中描述设备树本身结构和内容的部分。它由一系列带有数据的令牌序列组成，这些令牌按照线性树结构进行组织。</p>
<p><strong>（1）令牌类型</strong></p>
<p> 结构块中的令牌分为五种类型，每种类型用于不同的目的。</p>
<p>a. FDT_BEGIN_NODE (0x00000001): FDT_BEGIN_NODE 标记表示一个节点的开始。它后面跟着节点的单元名称作为额外数据。节点名称以以空字符结尾的字符串形式存储，并且可以包括单元地址。节点名称后可能需要填充零字节以对齐，然后是下一个标记，可以是除了 FDT_END 之外的任何标记。</p>
<p>b. FDT_END_NODE (0x00000002): FDT_END_NODE 标记表示一个节点的结束。该标记没有额外的数据，紧随其后的是下一个标记，可以是除了 FDT_PROP 之外的任何标记。</p>
<p>c. FDT_PROP (0x00000003): FDT_PROP 标记表示设备树中属性的开始。它后面跟着描述属性的额外数据，该数据首先由属性的长度和名称组成，表示为以下 C 结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">	uint32_t len; </span><br><span class="line">	uint32_t nameoff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>长度表示属性值的字节长度，名称偏移量指向字符串块中存储属性名称的位置。在这个结构之后，属性的值作为字节字符串给出。属性值后可能需要填充零字节以对齐，然后是下一个令牌，可以是除了 FDT_END 之外的任何标记。</p>
<p>d. FDT_NOP (0x00000004): FDT_NOP 令牌可以被解析设备树的程序忽略。该令牌没有额外的数据，紧随其后的是下一个令牌，可以是任何有效的令牌。使用 FDT_NOP 令牌可以覆盖树中的属性或节点定义，从而将其从树中删除，而无需移动设备树 blob 中的其他部分。</p>
<p>e. FDT_END (0x00000009): FDT_END 标记表示结构块的结束。应该只有一个 FDT_END 标记，并且应该是结构块中的最后一个标记。该标记没有额外的数据，紧随其后的字节应该位于结构块的开头偏移处，该偏移等于设备树 blob 标头中的 size_dt_struct 字段的值。</p>
<p><strong>（2）树状结构：</strong></p>
<p>设备树的结构以线性树的形式表示。每个节点由 FDT_BEGIN_NODE 标记开始，由 FDT_END_NODE 标记结束。节点的属性和子节点在 FDT_END_NODE 之前表示，因此子节点的 FDT_BEGIN_NODE 和 FDT_END_NODE 令牌嵌套在父节点的令牌中。</p>
<p><strong>（3）结构块的结束</strong></p>
<p>结构块以单个 FDT_END 标记结束。该标记没有额外的数据，它位于结构块的末尾，并且是结构块中的最后一个标记。FDT_END 标记之后的字节应位于结构块的开头偏移处，该偏移等于设备树 blob 标头中的 size_dt_struct 字段的值。</p>
<p>最后对结构块开头的部分内容进行讲解，具体内容如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022678.jpeg" alt="img"> </p>
<table>
<thead>
<tr>
<th>十六进制数值</th>
<th>代表含义</th>
</tr>
</thead>
<tbody><tr>
<td>00000001</td>
<td>根节点的开始</td>
</tr>
<tr>
<td>00000000</td>
<td>根节点没有节点名，所以这里名字为0</td>
</tr>
<tr>
<td>00000003</td>
<td>设备树中属性的开始</td>
</tr>
<tr>
<td>00000017</td>
<td>代表该属性的大小，换算成十进制为23，也就是”This is my devicetree!”这一字符串的长度</td>
</tr>
<tr>
<td>00000000</td>
<td>代表该属性在字符串块的偏移量，这里为0，表示无偏移</td>
</tr>
<tr>
<td>54686973-65210000</td>
<td>model的具体值</td>
</tr>
</tbody></table>
<p>通过使用结构块，设备树可以以一种层次化的方式组织和描述系统中的设备和资源。每个节点可以包含属性和子节点，从而实现更加灵活和可扩展的设备树表示。</p>
<h2 id="62-4-字符串块"><a href="#62-4-字符串块" class="headerlink" title="62.4 字符串块"></a>62.4 字符串块</h2><p>字符串块用于存储设备树中使用的所有属性名称。它由一系列以空字符结尾的字符串组成，这些字符串在字符串块中简单地连接在一起，具体示例如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022711.jpeg" alt="img"> </p>
<p><strong>（1）字符串连接：</strong></p>
<p> 字符串块中的字符串以空字符（\0）作为终止符来连接。这意味着每个字符串都以空字符结尾，并且下一个字符串紧跟在上一个字符串的末尾。这种连接方式使得字符串块中的所有字符串形成一个连续的字符序列。</p>
<p><strong>（2）偏移量引用：</strong></p>
<p>在结构块中，属性的名称是通过偏移量来引用字符串块中的相应字符串的。偏移量是一个无符号整数值，它表示字符串在字符串块中的位置。通过使用偏移量引用，设备树可以节省空间，并且在属性名称发生变化时也更加灵活，因为只需要更新偏移量，而不需要修改结构块中的属性引用。</p>
<p><strong>（3）对齐约束：</strong></p>
<p>字符串块没有对齐约束，这意味着它可以出现在设备树 blob 的任何偏移处。这使得字符串块的位置在设备树 blob 中是灵活的，并且可以根据需要进行调整，而不会对设备树的解析和处理造成影响。</p>
<p>字符串块是设备树中用于存储属性名称的部分。它由字符串连接而成，并通过偏移量在结构块中进行引用。字符串块的灵活位置使得设备树的表示更加紧凑和可扩展。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rk3568-%E9%A9%B1%E5%8A%A8/" rel="tag">rk3568 驱动</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-1-61-实例分析-pinctrl"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/1-61-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-pinctrl/"
    >1-61-实例分析: pinctrl</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/1-61-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-pinctrl/" class="article-date">
  <time datetime="2023-09-05T00:01:31.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第61章-实例分析：pinctrl"><a href="#第61章-实例分析：pinctrl" class="headerlink" title="第61章 实例分析：pinctrl"></a>第61章 实例分析：pinctrl</h1><h2 id="61-1-pinmux-介绍"><a href="#61-1-pinmux-介绍" class="headerlink" title="61.1 pinmux 介绍"></a>61.1 pinmux 介绍</h2><p>Pinmux（引脚复用）是指在系统中配置和管理引脚功能的过程。在许多现代集成电路中，单个引脚可以具有多个功能，例如作为 GPIO、UART、SPI 或 I2C 等。通过使用引脚复用功能，可以在这些不同的功能之间切换。</p>
<p>引脚复用通过硬件和软件的方式实现。硬件层面，芯片设计会为每个引脚提供多个功能的选择。这些功能通常由芯片厂商在芯片规格文档中定义。通过编程设置寄存器或开关，可以选择某个功能来连接引脚。这种硬件层面的配置通常是由引脚控制器（Pin Controller）或引脚复用控制器（Pin Mux Controller）负责管理。</p>
<p>软件层面，操作系统或设备驱动程序需要了解和配置引脚的功能。它们使用设备树（Device Tree）或设备树绑定（Device Tree Bindings）来描述和配置引脚的功能。在设备树中，可以指定引脚的复用功能，将其连接到特定的硬件接口或功能。操作系统或设备驱动程序在启动过程中解析设备树，并根据配置对引脚进行初始化和设置。</p>
<p>那我们要怎样知晓每一个管脚都可以复用成什么功能呢，一般在核心板原理图都会标注出每个管脚的复用功能，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022792.jpeg" alt="img"> </p>
<p>从上图可以看到UART4_RX_M1对应的引脚可以复用为以下6个功能LCDC_D16、VOP_BT1120_D7、GMAC1_RXD0_M0、UART4_RX_M1、PWM8_M0、GPIO3_B1_d，对应的BGA引脚标号为AG1,那这里的AG1是如何定位的呢。</p>
<p>在 BGA（Ball Grid Array，球栅阵列）封装中，引脚标号是用于唯一标识每个引脚的标识符。这些标号通常由芯片制造商定义，并在芯片的规格文档或数据手册中提供。</p>
<p>BGA 芯片的引脚标号通常由字母和数字的组合构成。它们用于在芯片的封装底部的焊盘上进行标记。每个引脚标号都与芯片内部的功能或信号相对应，以便正确连接到印刷电路板（PCB）上的目标位置。RK3568的引脚标号图如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022868.jpeg" alt="img"> </p>
<p>可以看到纵向为A-AH的28个字母类型标号，横向为1-28的28个字母类型标号，瑞芯微也在对应的3568数据手册中加入了根据BGA位置制作的复用功能图，部分内容如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022855.jpeg" alt="img"> </p>
<p>其中黑色框代表被保留的引脚，其他有颜色的框一般为电源和地，白色的框代表有具体复用功能的引脚。</p>
<p>脚复用提高了芯片的灵活性和可重用性，通过允许同一个引脚在不同的功能之间切换，可以减少硬件设计的复杂性和成本。此外，引脚复用还使得在使用相同芯片的不同应用中可以更加灵活地配置和定制引脚功能。</p>
<p>会在下一个小节中讲解如何使用pinctrl在设备树中配置引脚的复用。</p>
<h2 id="61-2-使用pinctrl设置复用关系"><a href="#61-2-使用pinctrl设置复用关系" class="headerlink" title="61.2 使用pinctrl设置复用关系"></a>61.2 使用pinctrl设置复用关系</h2><p>pinctrl（引脚控制）用于描述和配置硬件设备上的引脚功能和连接方式。它是设备树的一部分，用于在启动过程中传递引脚配置信息给操作系统和设备驱动程序，以便正确地初始化和控制引脚。</p>
<p>在设备树中，pinctrl（引脚控制）使用了客户端和服务端的概念来描述引脚控制的关系和配置。</p>
<h3 id="61-2-1-客户端-Client"><a href="#61-2-1-客户端-Client" class="headerlink" title="61.2.1 客户端(Client)"></a>61.2.1 客户端(Client)</h3><p>接下来将使用三个例子对客户端要用到的属性进行讲解。</p>
<p>例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node &#123;</span><br><span class="line">    pinctrl-names = &quot;default&quot;;</span><br><span class="line">    pinctrl-0 = &lt;&amp;pinctrl_hog_1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在例1中，pinctrl-names 属性定义了一个状态名称：default。</p>
<p>pinctrl-0 属性指定了第一个状态 default 对应的引脚配置。</p>
<p>&lt;&amp;pinctrl_hog_1&gt; 是一个引脚描述符，它引用了一个名为 pinctrl_hog_1 的引脚控制器节点。这表示在 default 状态下，设备的引脚配置将使用 pinctrl_hog_1 节点中定义的配置。</p>
<p>例2：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node &#123;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>, <span class="string">&quot;wake up&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_hog_1&gt;;</span><br><span class="line">    pinctrl<span class="number">-1</span> = &lt;&amp;pinctrl_hog_2&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在例2中，pinctrl-names 属性定义了两个状态名称：default 和 wake up。</p>
<p>pinctrl-0 属性指定了第一个状态 default 对应的引脚配置，引用了 pinctrl_hog_1 节点。</p>
<p>pinctrl-1 属性指定了第二个状态 wake up 对应的引脚配置，引用了 pinctrl_hog_2 节点。</p>
<p>这意味着设备可以处于两个不同的状态之一，每个状态分别使用不同的引脚配置。</p>
<p>例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node &#123;</span><br><span class="line">    pinctrl-names = &quot;default&quot;;</span><br><span class="line">    pinctrl-0 = &lt;&amp;pinctrl_hog_1 &amp;pinctrl_hog_2&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，pinctrl-names 属性仍然定义了一个状态名称：default。</p>
<p>pinctrl-0 属性指定了第一个状态 default 对应的引脚配置，但与之前的例子不同的是，它引用了两个引脚描述符：pinctrl_hog_1 和 pinctrl_hog_2。</p>
<p>这表示在 default 状态下，设备的引脚配置将使用 pinctrl_hog_1 和 pinctrl_hog_2 两个节点中定义的配置。这种方式可以将多个引脚控制器的配置组合在一起，以满足特定状态下的引脚需求。</p>
<p>至此关于客户端的内容就讲解完成了，低于客户端的内容，不同厂家的编写格式是相同的，而服务端每个厂家就有区别了，在下一个小节将以rk3568的pinctrl服务端为例进行讲解。</p>
<h3 id="61-2-2-服务端-Server"><a href="#61-2-2-服务端-Server" class="headerlink" title="61.2.2 服务端(Server)"></a>61.2.2 服务端(Server)</h3><p>服务端是设备树中定义引脚配置的部分。它包含引脚组和引脚描述符，为客户端提供引脚配置选择。服务端在设备树中定义了 pinctrl 节点，其中包含引脚组和引脚描述符的定义。</p>
<p>这里以瑞芯微的RK3568为例进行pinctrl服务端的讲解，瑞芯微原厂BSP工程师为了方便用户通过pinctrl设置管脚的复用关系，将包含所有复用关系的配置写在了内核目录下的“arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568-pinctrl.dtsi”设备树中，具体内容如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022825.jpeg" alt="img"> </p>
<p>在pinctrl节点中就是每个节点的复用功能，然后我们以uart4的引脚复用为例进行讲解，uart4的pinctrl服务端内容如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022736.jpeg" alt="img"> </p>
<p>其中&lt;3 RK_PB1 4 &amp;pcfg_pull_up&gt;和&lt;3 RK_PB2 4 &amp;pcfg_pull_up&gt;分别表示将GPIO3的PB1引脚设置为功能4，将GPIO3的PB2也设置为功能4，且电器属性都会设置为上拉。通过查找原理图可以得到两个引脚在BGA封装位置分别为AG1和AF2，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022803.jpeg" alt="img"> </p>
<p>然后在rk3568的数据手册中找到引脚复用表对应的位置，具体内容如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022099.jpeg" alt="img"><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022123.jpeg" alt="img"> </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022214.jpeg" alt="img"> </p>
<p>可以看到功能4对应串口4的发送端和接收端，pinctrl服务端的配置和数据手册中的引脚复用功能是一一对应，那如果要将RK_PB1和RK_PB2设置为GPIO功能要如何设置呢，从上图可以看到GPIO对应功能0，所以可以通过以下pinctrl内容将设置RK_PB1和RK_PB2设置为GPIO功能（事实上如果不对该管脚进行功能复用该引脚默认就会设置为GPIO功能）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="number">3</span> RK_PB1 <span class="number">0</span> &amp;pcfg_pull_up&gt;,                                                                                                                                                                                           </span><br><span class="line">&lt;<span class="number">3</span> RK_PB2 <span class="number">0</span> &amp;pcfg_pull_up&gt;;</span><br></pre></td></tr></table></figure>

<p>最后来看客户端对uart4服务端的引用，具体内容在内核源码目录“arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568-evb1-ddr4-v10-linux.dts”：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022165.jpeg" alt="img"> </p>
<p>通过在客户端中引用服务端的引脚描述符，设备树可以将客户端和服务端的引脚配置关联起来。这样，在设备树被解析和处理时，操作系统和设备驱动程序可以根据客户端的需求，查找并应用适当的引脚配置。</p>
<h2 id="61-3-pinctrl实例编写"><a href="#61-3-pinctrl实例编写" class="headerlink" title="61.3 pinctrl实例编写"></a>61.3 pinctrl实例编写</h2><p>本小节将通过上面学到的pinctrl相关知识，将led的控制引脚复用为GPIO模式。</p>
<p>首先来对rk3568的设备树结构进行以下介绍，根据sdk源码目录下的“device&#x2F;rockchip&#x2F;rk356x&#x2F;BoardConfig-rk3568-evb1-ddr4-v10.mk”默认配置文件可以了解到编译的设备树为rk3568-evb1-ddr4-v10-linux.dts,整理好的设备树之间包含关系列表如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022266.png" alt="image-20230906164406935"></p>
<p>Led在rk3568-evb.dtsi设备树中已经被正常配置了，如下图所示：<br><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022394.jpeg" alt="img"></p>
<p>这时候可能大家就有问题了，这里也并没有配置pinctrl呀，那为什么led最后能正常使用呢，这个原因在上节课中其实我们已经提到了，当一个引脚没有被复用为任何功能时，默认就是GPIO功能，所以这里没有pinctrl led功能也可以正常使用。</p>
<p>但这里我们仍旧使用pinctrl对led进行配置，从而熟练pinctrl，首先注释掉leds节点，注释完成如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022446.jpeg" alt="img"> </p>
<p>保存退出之后，然后进入到rk3568-evb1-ddr4-v10.dtsi设备树中，找到rk_485_ctl节点，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022525.jpeg" alt="img"> </p>
<p>这是根节点的最后一个节点，而且也是用来控制一个GPIO的，我们完全可以仿照该节点，在该节点下方编写led控制节点，仿写完成的设备树内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_led: led &#123;</span><br><span class="line">   compatible = <span class="string">&quot;topeet,led&quot;</span>;</span><br><span class="line">   gpios = &lt;&amp;gpio0 RK_PB7 GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">   pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">   pinctrl<span class="number">-0</span> = &lt;&amp;rk_led_gpio&gt;;</span><br><span class="line">   &#125;;  </span><br></pre></td></tr></table></figure>

<p>第1行：节点名称为 led，标签名为my_led。</p>
<p>第2行：compatible 属性指定了设备的兼容性标识，即设备与驱动程序之间的匹配规则。在这里，设备标识为 “topeet,led”，表示该 LED 设备与名为 “topeet,led” 的驱动程序兼容。</p>
<p>第3行：gpios 属性指定了与LED相关的GPIO（通用输入&#x2F;输出）引脚配置。</p>
<p>第4行：pinctrl-names 属性指定了与引脚控制相关的命名。default表示状态 0</p>
<p>第5行：pinctrl-0 属性指定了与 pinctrl-names 属性中命名的引脚控制相关联的实际引脚控制器配置。&lt;&amp;rk_led_gpio&gt; 表示引用了名为 rk_led_gpio 的引脚控制器配置。</p>
<p>添加完成如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022540.jpeg" alt="img"> </p>
<p>然后继续找到在同一设备树文件的485 pinctrl服务端节点，具体内容如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022591.jpeg" alt="img"> </p>
<p>然后在该节点下方仿写led控制引脚pinctrl服务端节点，仿写完成的节点内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rk_led&#123;</span><br><span class="line">		rk_led_gpio:rk-led-gpio &#123;</span><br><span class="line">			rockchip,pins = &lt;0 RK_PB7 RK_FUNC_GPIO &amp;pcfg_pull_none&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p>添加完成之后如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022594.jpeg" alt="img"> </p>
<p>至此，led的控制引脚就通过pinctrl被复用为了GPIO功能，保存退出之后，重新编译内核，没有报错就证明我们的实验完成了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rk3568-%E9%A9%B1%E5%8A%A8/" rel="tag">rk3568 驱动</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-1-60-实例分析-GPIO"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/1-60-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-GPIO/"
    >1-60-实例分析:GPIO</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/1-60-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-GPIO/" class="article-date">
  <time datetime="2023-09-05T00:01:29.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第60章-实例分析：GPIO"><a href="#第60章-实例分析：GPIO" class="headerlink" title="第60章 实例分析：GPIO"></a>第60章 实例分析：GPIO</h1><h2 id="60-1-GPIO相关属性"><a href="#60-1-GPIO相关属性" class="headerlink" title="60.1 GPIO相关属性"></a>60.1 GPIO相关属性</h2><h3 id="60-1-1-RK-ft5x06设备树节点"><a href="#60-1-1-RK-ft5x06设备树节点" class="headerlink" title="60.1.1 RK ft5x06设备树节点"></a>60.1.1 RK ft5x06设备树节点</h3><p>下面展示的是iTOP-RK3568开发板SDK源码中的ft5x06设备树，其中蓝色字体部分就是关于gpio相关的描述，包括了interrupts、 interrupt-controller、#interrupt-cells、interrupt-parent四种常见属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">gpio0: gpio@fdd60000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;rockchip,gpio-bank&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0</span> <span class="number">0xfdd60000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">33</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    clocks = &lt;&amp;pmucru PCLK_GPI00&gt;, &lt;&amp;pmucru DBCLK_GPI00&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    gpio-ranges = &lt;&amp;pinctrl <span class="number">0</span> <span class="number">0</span> <span class="number">32</span>&gt;;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06@<span class="number">38</span> &#123; </span><br><span class="line">    status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    compatible = <span class="string">&quot;edt,edt-ft5306&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">    touch-gpio = &lt;&amp;gpio0 RK_PB5 IRQ_TYPE_EDGE_RISING&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio0&gt;;</span><br><span class="line">    interrupts = &lt;RK_PB5 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">    reset-gpios = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    touchscreen-size-x = &lt;<span class="number">800</span>&gt;;</span><br><span class="line">    touchscreen-size-y = &lt;<span class="number">1280</span>&gt;;</span><br><span class="line">    touch_type = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中gpio0节点是在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568.dtsi”设备树的3549-3560行定义的，而ft5x06: ft5x06@38触摸芯片节点是在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;topeet_rk3568_lcds.dtsi”设备树的301-313行定义的。接下来将会对设备树常见的四个gpio属性进行介绍。</p>
<h3 id="60-1-2-gpio-controller"><a href="#60-1-2-gpio-controller" class="headerlink" title="60.1.2 gpio-controller"></a>60.1.2 gpio-controller</h3><p>gpio-controller属性用于标识一个设备节点作为GPIO控制器。GPIO控制器是负责管理和控制GPIO引脚的硬件模块或驱动程序。</p>
<p>gpio-controller属性通常作为设备节点的一个属性出现，位于设备节点的属性列表中。</p>
<p>当一个设备节点被标识为GPIO控制器时，它通常会定义一组GPIO引脚，并提供相关的GPIO控制和配置功能。其他设备节点可以使用该GPIO控制器来控制和管理其GPIO引脚。</p>
<p>通过使用gpio-controller属性，设备树可以明确标识出GPIO控制器设备节点，使系统可以正确识别和管理GPIO引脚的配置和控制。</p>
<h3 id="60-1-3-gpio-cells"><a href="#60-1-3-gpio-cells" class="headerlink" title="60.1.3 #gpio-cells"></a>60.1.3 #gpio-cells</h3><p>#gpio-cells属性用于指定GPIO引脚描述符的编码方式。GPIO引脚描述符是用于标识和配置GPIO引脚的一组值，例如引脚编号、引脚属性等。</p>
<p>#gpio-cells属性的属性值是一个整数，表示用于编码GPIO引脚描述符的单元数。通常，这个值为2。</p>
<p>在第一小节的示例中有1个gpio引脚描述属性,由于#gpio-cells属性被设置为了2，所以每个引脚描述属性中会有两个整数，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ft5x06: ft5x06@<span class="number">38</span> &#123; </span><br><span class="line">    .....</span><br><span class="line">    reset-gpios = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>RK_PB6、GPIO_ACTIVE_LOW都属于恒定义，会在下面的小节进行讲解。</p>
<p>通过使用#gpio-cells属性，设备树可以指定GPIO引脚描述符的编码方式，使系统能够正确识别和解析GPIO引脚的配置和控制。</p>
<h3 id="60-1-4-gpio-ranges"><a href="#60-1-4-gpio-ranges" class="headerlink" title="60.1.4 gpio-ranges"></a>60.1.4 gpio-ranges</h3><p>gpio-ranges属性是设备树中一个用于描述GPIO范围映射的属性。它通常用于描述具有大量GPIO引脚的GPIO控制器，以简化GPIO引脚的编码和访问。</p>
<p>在设备树中，GPIO控制器的每个引脚都有一个本地编号，用于在控制器内部进行引脚寻址。然而，这些本地编号并不一定与外部引脚的物理编号或其他系统中使用的编号一致。为了解决这个问题，可以使用gpio-ranges属性将本地编号映射到实际的引脚编号。</p>
<p>gpio-ranges属性是一个包含一系列整数值的列表，每个整数值对应于设备树中的一个GPIO控制器。列表中的每个整数值按照特定的顺序提供以下信息：</p>
<p>（1）外部引脚编号的起始值。	</p>
<p>（2）GPIO控制器内部本地编号的起始值。</p>
<p>（3）引脚范围的大小（引脚数量）。</p>
<p>在第一小节的示例中gpio-ranges属性的值为&lt;&amp;pinctrl 0 0 32&gt;，其中&lt;&amp;pinctrl&gt;表示引用了名为pinctrl的引脚控制器节点，0 0 32表示外部引脚从0开始，控制器本地编号从0开始，共映射了32个引脚。</p>
<p>这样，gpio-ranges属性将GPIO控制器的本地编号直接映射到外部引脚编号，使得GPIO引脚的编码和访问更加简洁和直观。</p>
<h3 id="60-1-5-gpio引脚描述属性"><a href="#60-1-5-gpio引脚描述属性" class="headerlink" title="60.1.5 gpio引脚描述属性"></a>60.1.5 gpio引脚描述属性</h3><p>第一小节的设备树中关于gpio引脚描述属性相关内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ft5x06: ft5x06@<span class="number">38</span> &#123; </span><br><span class="line">    .....</span><br><span class="line">    reset-gpios = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>gpio引脚描述属性个数由#gpio-cells所决定，因为gpio0节点中的#gpio-cells属性设置为了2，所以上面设备树gpio引脚描述属性个数也为2。</p>
<p>其中RK_PB6 定义在内核源码目录下的“include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h”头文件中，定义了RK引脚名和gpio编号的宏定义，如下图所示：<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022930.jpeg" alt="img"> </p>
<p>GPIO_ACTIVE_LOW定义在源码目录下的“include&#x2F;dt-bindings&#x2F;gpio&#x2F;gpio.h”中，表示设置为低电平，同理GPIO_ACTIVE_HIGH就表示将这个GPIO设置为高电平，但这里只是对设备的描述，具体的设置还是要跟驱动相匹配。</p>
<h3 id="60-1-6-其他属性"><a href="#60-1-6-其他属性" class="headerlink" title="60.1.6 其他属性"></a>60.1.6 其他属性</h3><p>本小节将根据下面的设备树示例讲解一下gpio的其他重要属性，设备树具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gpio-controller@00000000 &#123;</span><br><span class="line">    compatible = &quot;foo&quot;;</span><br><span class="line">    reg = &lt;0x00000000 0x1000&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    #gpio-cells = &lt;2&gt;;</span><br><span class="line">    ngpios = &lt;18&gt;;</span><br><span class="line">    gpio-reserved-ranges = &lt;0 4&gt;, &lt;12 2&gt;;</span><br><span class="line">    gpio-line-names = &quot;MMC-CD&quot;, &quot;MMC-WP&quot;,</span><br><span class="line">                      &quot;voD eth&quot;, &quot;RST eth&quot;, &quot;LED R&quot;,</span><br><span class="line">                      &quot;LED G&quot;, &quot;LED B&quot;, &quot;col A&quot;,</span><br><span class="line">                      &quot;col B&quot;, &quot;col C&quot;, &quot;col D&quot;,</span><br><span class="line">                      &quot;NMI button&quot;, &quot;Row A&quot;, &quot;Row B&quot;,</span><br><span class="line">                      &quot;Row C&quot;, &quot;Row D&quot;, &quot;poweroff&quot;,</span><br><span class="line">                      &quot;reset&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第6行的ngpios 属性指定了 GPIO 控制器所支持的 GPIO 引脚数量。它表示该设备上可用的 GPIO 引脚的总数。在这个例子中，ngpios&#96; 的值为 18，意味着该 GPIO 控制器支持 18 个 GPIO 引脚。</p>
<p>第7行的gpio-reserved-ranges属性定义了保留的GPIO范围。每个范围由两个整数值表示，用尖括号括起来。保留的GPIO范围意味着这些GPIO引脚不可用或已被其他设备或功能保留。在这个例子中，有两个保留范围：&lt;0 4&gt;和&lt;12 2&gt;。&lt;0 4&gt;表示从第0个引脚开始的连续4个引脚被保留，而&lt;12 2&gt;表示从第12个引脚开始的连续2个引脚被保留。<br>    第8行的gpio-line-names 属性定义了GPIO引脚的名称，以逗号分隔。每个名称对应一个 GPIO 引脚。这些名称用于标识和识别每个GPIO引脚的作用或连接的设备。在这个例子中，gpio-line-names属性列出了多个GPIO引脚的名称，如 “MMC-CD”、”MMC-WP”、”voD eth” 等等。通过这些名称，可以清楚地了解每个GPIO引脚的功能或用途。</p>
<h2 id="60-2-中断实例编写"><a href="#60-2-中断实例编写" class="headerlink" title="60.2 中断实例编写"></a>60.2 中断实例编写</h2><p>在上一个小节中对设备树中断要用到的属性进行了讲解，而在本小节将会编写一个在RK3568上LED灯的中断设备树。</p>
<p>首先确定LED的引脚编号，LED原理图如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022878.jpeg" alt="img"> </p>
<p>从上面的原理图可以得到LED灯的引脚网络标号为Working_LEDEN_H_GPIO0_B7，对应的引脚为GPIO0_B7。</p>
<p>然后来查看内核源码目录下的“drivers&#x2F;drivers&#x2F;leds&#x2F;leds-gpio.c”文件，这是led的驱动文件，然后找到compatible匹配值相关的部分，如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022895.jpeg" alt="img"> </p>
<p>可以看到compatible匹配值为gpio-leds。</p>
<p>最后在内核源码目录下的“include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h”头文件中，定义了RK引脚名和gpio编号的宏定义，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022857.jpeg" alt="img"> </p>
<p>在源码目录下的“include&#x2F;dt-bindings&#x2F;gpio&#x2F;gpio.h”文件中定义了引脚极性设置宏定义，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062022886.jpeg" alt="img"> </p>
<p>其中GPIO_ACTIVE_HIGH表示将该引脚设置为高电平，GPIO_ACTIVE_LOW表示将该引脚设置为低电平。</p>
<p>至此，我们关于编写LED设备树的前置内容就查找完成了，接下来进行设备树的编写。</p>
<p>  编写完成的设备树如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/pinctrl/rockchip.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dt-bindings/gpio/gpio.h&quot;</span></span></span><br><span class="line">/&#123;</span><br><span class="line">	model = <span class="string">&quot;This is my devicetree!&quot;</span>;</span><br><span class="line"></span><br><span class="line">	led led@<span class="number">1</span> &#123;</span><br><span class="line">		compatible = <span class="string">&quot;gpio-leds&quot;</span>;</span><br><span class="line">		gpios = &lt;&amp;gpio0 RK_PB7 GPIO_ACTIVE_HIGH&gt;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第1行: 设备树文件的头部，指定了使用的设备树语法版本。</p>
<p>第3行：用于定义 Rockchip 平台的引脚控制器相关的绑定。</p>
<p>第4行：用于定义中断控制器相关的绑定。</p>
<p>第5行：表示设备树的根节点开始。</p>
<p>第6行：指定了设备树的模型名称，描述为 “This is my devicetree!”。</p>
<p>第9行：指定了设备节点的兼容性字符串，表示该设备与 “gpio-leds” 兼容。</p>
<p>第10行：指定了该 LED 设备所使用的 GPIO 引脚。&amp;gpio0 是引脚控制器的引用，RK_PB7 是引脚的编号或标识，GPIO_ACTIVE_HIGH 表示该 GPIO 引脚的活动电平是高电平。</p>
<p>至此，关于led的设备树就讲解完成了。</p>
<h2 id="60-3-其他SOC设备树对比"><a href="#60-3-其他SOC设备树对比" class="headerlink" title="60.3 其他SOC设备树对比"></a>60.3 其他SOC设备树对比</h2><p>而无论使用的是瑞芯微SOC还是恩智浦、三星的SOC，在设备树关于gpio相关的描述都是类似的，关于在恩智浦和三星源码中的ft5x06设备树如下所示：</p>
<p>恩智浦：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">gpio1: gpio@<span class="number">0209</span>c000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;fsl,inx6ul-gpio&quot;</span>, <span class="string">&quot;fsl,imx35-gpio&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0209c000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">66</span> IRQ_TYPE_LEVEL_HIGH&gt;, &lt;GIC_SPI <span class="number">67</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    edt-ft5x06@<span class="number">38</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;edt,edt-ft5306&quot;</span>, <span class="string">&quot;edt,edt-ft5x06&quot;</span>, <span class="string">&quot;edt,edt-ft5406&quot;</span>;</span><br><span class="line">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        pinctrl<span class="number">-0</span> = &lt;&amp;ts_int_pin &amp;ts_reset_pin&gt;;</span><br><span class="line">        reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">        interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">        interrupts = &lt;<span class="number">9</span> <span class="number">0</span>&gt;;</span><br><span class="line">        reset-gpios = &lt;&amp;gpio5 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">        irq-gpios = &lt;&amp;gpio1 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>三星：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">gpio_c: gpioc &#123;</span><br><span class="line">    compatible = <span class="string">&quot;gpio-controller&quot;</span>;</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ft5x06: ft5x06038 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;edt,edt-ft5406&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(RGB_1024x600) || defined(RGB_800x480)</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;tsc2007_irq&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio_c&gt;;</span><br><span class="line">    interrupts = &lt;<span class="number">26</span> IRQ_TYPE_EDGE_FALLING&gt;;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(LvDs_800×1280) || defined(LvDS_1024x768)</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;gt911_irq&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio_b&gt;;</span><br><span class="line">    interrupts = &lt;<span class="number">29</span> IRQ_TYPE_EDGE_FALLING&gt;;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> reset-gpios = &lt;&amp;gpio_e <span class="number">30</span> <span class="number">0</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对比之后会发现，不同厂商对于gpio的配置都是类似的，只是里面的参数有些许区别，如果大家在之后遇到了其他平台，只需要稍加区分即可</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rk3568-%E9%A9%B1%E5%8A%A8/" rel="tag">rk3568 驱动</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-1-59-实例分析-CPU"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/05/1-59-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-CPU/"
    >1-59-实例分析:CPU</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/1-59-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-CPU/" class="article-date">
  <time datetime="2023-09-05T00:01:28.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第59章-实例分析：CPU"><a href="#第59章-实例分析：CPU" class="headerlink" title="第59章 实例分析：CPU"></a>第59章 实例分析：CPU</h1><h2 id="59-1-cpus节点"><a href="#59-1-cpus节点" class="headerlink" title="59.1 cpus节点"></a>59.1 cpus节点</h2><p>设备树的 cpus 节点是用于描述系统中的处理器的一个重要节点。它是处理器拓扑结构的顶层节点，包含了所有处理器相关的信息。下面将详细介绍设备树的 cpus 节点的各个方面。</p>
<p><strong>节点结构：</strong></p>
<p>cpus 节点是一个容器节点，其下包含了系统中每个处理器的子节点。每个子节点的名称通常为 cpu@X，其中 X 是处理器的索引号。每个子节点都包含了与处理器相关的属性，例如时钟频率、缓存大小等。</p>
<p><strong>处理器属性：</strong></p>
<p>cpu@X 子节点中的属性可以包括以下信息：</p>
<p>（1）device_type：指示设备类型为处理器（”cpu”）。</p>
<p>（2）reg：指定处理器的地址范围，通常是物理地址或寄存器地址。</p>
<p>（3）compatible：指定处理器的兼容性信息，用于匹配相应的设备驱动程序。</p>
<p>（4）clock-frequency：指定处理器的时钟频率。</p>
<p>（5）cache-size：指定处理器的缓存大小。</p>
<p><strong>处理器拓扑关系：</strong></p>
<p>除了处理器的基本属性，cpus 节点还可以包含其他用于描述处理器拓扑关系的节点，以提供更详细的处理器拓扑信息。这些节点可以帮助操作系统和软件了解处理器之间的连接关系、组织结构和特性。</p>
<p>cpu-map 节点：描述处理器的映射关系，通常在多核处理器系统中使用。</p>
<p>socket 节点：描述多处理器系统中的物理插槽或芯片组。</p>
<p>cluster 节点：描述处理器集群，即将多个处理器组织在一起形成的逻辑组。</p>
<p>core 节点：描述处理器核心，即一个物理处理器内的独立执行单元。</p>
<p>thread 节点：描述处理器线程，即一个物理处理器核心内的线程。</p>
<p>这些节点的嵌套关系可以在 cpus 节点下形成一个层次结构，反映了处理器的拓扑结构。上述这些节点会在后面的小节进行介绍。一个单核CPU设备树和一个四核CPU设备树示例如下所示：</p>
<p>单核CPU示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    cpu0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a7&quot;</span>;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        <span class="comment">// 其他属性...</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多核CPU示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;0&gt;;</span><br><span class="line"></span><br><span class="line">    cpu0: cpu@0 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a9&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu1: cpu@1 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a9&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu2: cpu@2 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a9&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpu3: cpu@3 &#123;</span><br><span class="line">        device_type = &quot;cpu&quot;;</span><br><span class="line">        compatible = &quot;arm,cortex-a9&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cpus 节点是一个容器节点，包含了 cpu0 子节点。该节点使用了 #address-cells 和 #size-cells 属性来指定地址和大小的单元数量。</p>
<p>cpu0 子节点代表第一个处理器，具有以下属性：</p>
<p>compatible 属性指定了处理器的兼容性信息</p>
<p>device_type 属性指示设备类型为处理器。</p>
<p>你可以在此基础上继续添加其他属性来描述处理器的特性，如时钟频率、缓存大小等。</p>
<h2 id="59-2-cpu-map、socket、cluster节点"><a href="#59-2-cpu-map、socket、cluster节点" class="headerlink" title="59.2 cpu-map、socket、cluster节点"></a>59.2 cpu-map、socket、cluster节点</h2><p>cpu-map 节点是设备树中用于描述大小核架构处理器的映射关系的节点之一。它的父节点必须是 cpus 节点，而子节点可以是一个或多个 cluster 和 socket 节点。通过 cpu-map 节点，可以定义不同核心和集群之间的连接和组织结构。</p>
<p>socket 节点用于描述处理器插槽（socket）之间的映射关系。每个 socket 子节点表示一个处理器插槽，可以使用 cpu-map-mask 属性来指定该插槽使用的核心。通过为每个 socket 子节点指定适当的 cpu-map-mask，可以定义不同插槽中使用的核心。这样，操作系统和软件可以了解到不同插槽之间的核心分配情况。</p>
<p>cluster 节点用于描述核心（cluster）之间的映射关系。每个 cluster 子节点表示一个核心集群，可以使用 cpu-map-mask 属性来指定该集群使用的核心。通过为每个 cluster 子节点指定适当的 cpu-map-mask，可以定义每个集群中使用的核心。这样，操作系统和软件可以了解到不同集群之间的核心分配情况。</p>
<p>通过在 cpu-map 节点中定义 socket 和 cluster 子节点，并为它们指定适当的 cpu-map-mask，可以提供处理器的拓扑结构信息。这对于操作系统和软件来说非常有用，因为它们可以根据这些信息进行任务调度和资源分配的优化，以充分利用大小核架构处理器的性能和能效特性。</p>
<p>一个大小核架构的具体示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">    cpu-<span class="built_in">map</span> &#123;</span><br><span class="line">        cluster0 &#123;</span><br><span class="line">            core0 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_l0&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">            core1 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_l1&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">            core2 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_l2&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">            core3 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_l3&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        cluster1 &#123;</span><br><span class="line">            core0 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_b0&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">            core1 &#123;</span><br><span class="line">                cpu = &lt;&amp;cpu_b1&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">	cpu_l0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_l1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_l2: cpu@<span class="number">2</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_l3: cpu@<span class="number">3</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_b0: cpu@<span class="number">100</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a72&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpu_b1: cpu@<span class="number">101</span> &#123;</span><br><span class="line">		device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">		compatible = <span class="string">&quot;arm,cortex-a72&quot;</span>, <span class="string">&quot;arm,armv8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个设备树描述了一个具有多个 CPU 核心的系统，包括四个 Cortex-A53 核心和两个 Cortex-A72 核心。下面是对设备树中各个部分的简要介绍：</p>
<p>#address-cells &#x3D; &lt;2&gt;; 和 #size-cells &#x3D; &lt;0&gt;;：这些属性指定了设备树中地址和大小的编码方式。</p>
<p>cpu-map：这个节点定义了 CPU 的映射关系。它包含了两个簇（clusters）：cluster0 和 cluster1。cluster0 包含了四个核心：core0、core1、core2 和 core3，分别对应 cpu_l0、cpu_l1、cpu_l2 和 cpu_l3。cluster1 包含了两个核心：core0 和 core1，分别对应 cpu_b0 和 cpu_b1。</p>
<p>cpu_l0、cpu_l1、cpu_l2 和 cpu_l3：这些节点描述了 Cortex-A53 核心。它们具有相同的设备类型 cpu 和兼容性属性 “arm,cortex-a53”, “arm,armv8”。</p>
<p>cpu_b0 和 cpu_b1：这些节点描述了 Cortex-A72 核心。它们具有相同的设备类型 cpu 和兼容性属性 “arm,cortex-a72”, “arm,armv8”。</p>
<h2 id="59-3-core、thread节点"><a href="#59-3-core、thread节点" class="headerlink" title="59.3 core、thread节点"></a>59.3 core、thread节点</h2><p>“core” 和 “thread” 节点通常用于描述处理器核心和线程的配置。下面是对这两个节点的详细介绍：</p>
<p>Core 节点用于描述处理器的核心。一个处理器通常由多个核心组成，每个核心可以独立执行指令和任务。</p>
<p>Thread 节点用于描述处理器的线程。线程是在处理器核心上执行的基本执行单元，每个核心可以支持多个线程。</p>
<p>通过使用 Core 和 Thread 节点，设备树可以准确描述处理器的核心和线程的配置，例如可以使用设备树来描述一个具有16个核心的CPU，一个物理插槽，每个集群中有两个核心，每个核心有两个线程的设备树示例，具体设备树如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    cpu-<span class="built_in">map</span> &#123;</span><br><span class="line">        socket0 &#123;</span><br><span class="line">            cluster0 &#123;</span><br><span class="line">                core0 &#123;</span><br><span class="line">                    thread0 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU0&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    thread1 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU1&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">                core1 &#123;</span><br><span class="line">                    thread0 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU2&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    thread1 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU3&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            cluster1 &#123;</span><br><span class="line">                core0 &#123;</span><br><span class="line">                    thread0 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU4&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    thread1 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU5&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">                core1 &#123;</span><br><span class="line">                    thread0 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU6&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    thread1 &#123;</span><br><span class="line">                        cpu = &lt;&amp;CPU7&gt;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        socket1 &#123;</span><br><span class="line">			cluster0 &#123;</span><br><span class="line">				core0 &#123;</span><br><span class="line">					thread0 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU8&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">					thread1 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU9&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;;</span><br><span class="line">				core1 &#123;</span><br><span class="line">					thread0 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU10&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">					thread1 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU11&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">			cluster1 &#123;</span><br><span class="line">				core0 &#123;</span><br><span class="line">					thread0 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU12&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">					thread1 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU13&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;;</span><br><span class="line">				core1 &#123;</span><br><span class="line">					thread0 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU14&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">					thread1 &#123;</span><br><span class="line">						cpu = &lt;&amp;CPU15&gt;;</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rk3568-%E9%A9%B1%E5%8A%A8/" rel="tag">rk3568 驱动</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/8/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="热爱学习的未来酱"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>