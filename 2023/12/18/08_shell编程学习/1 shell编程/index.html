<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="永远年轻，永远热泪盈眶" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>shell编程 第一次学习 |  热爱学习的未来酱</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="热爱学习的未来酱" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-08_shell编程学习/1 shell编程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  shell编程 第一次学习
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/12/18/08_shell%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1%20shell%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2023-12-18T12:41:19.000Z" itemprop="datePublished">2023-12-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/shell%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/">shell编程学习</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">11.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">46 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>​	先说一下前提条件，其实shell编程我好早之前就知道了，其实吧，这个就跟法师最后让我录制的课程是差不多的，只是一个叫做Ubuntu基础，一个叫做shell编程，这两个其实是一个东西，而我对于ubuntu中的一些命令其实并不熟悉，我也并不能独立写出来一个脚本，所以我并不反感法师让我去录课，我的基础其实并不牢固，要学习的东西真的太多了，而我这一星期的重点就是戒掉小说，学生shell。</p>
<p>==弱小和无知并不是生存的障碍，傲慢才是==</p>
<h1 id="1什么是shell和bash"><a class="markdownIt-Anchor" href="#1什么是shell和bash"></a> 1.什么是shell和bash</h1>
<p>​	近代以来，计算机操作系统都采用了某种形式的用户界面，借此指定需要操作系统执行的命令，但是很多操作系统当中命令是内建的，是同计算机交互的唯一方式，而shell无非也就是一个程序而已，这个程序的作用就是为用户执行其他程序，但他要做的并不只于此，一个只允许你输入命令的shell确实没有太大的意思，但如果你可以使用这些命令编程呢，是不是很酷。</p>
<p>​	Shell（壳层）是计算机科学中的一个概念。在操作系统中，Shell 是用户与操作系统内核之间的接口。它提供了一个命令行界面（CLI）或图形用户界面（GUI），使用户能够与操作系统进行交互、运行命令和访问系统资源。</p>
<p>​	bash也是一种shell，即命令解释器，bash的目的是让用户同计算机操作系统进行交互，从而完成想做的任务，当然这些任务可能是重复性的、要么非常的复杂，shell编程允许你对此任务进行自动化，以实现易用性、可靠性以及可重现性。</p>
<h1 id="2标准输出"><a class="markdownIt-Anchor" href="#2标准输出"></a> 2.标准输出</h1>
<h2 id="21-输出到终端"><a class="markdownIt-Anchor" href="#21-输出到终端"></a> 2.1 输出到终端</h2>
<p>​	使用内建命令echo，将命令行中的参数打印到屏幕上</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello shell</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182109865.png" alt="image-20231218210955820" /></p>
<p>​	echo是最简单的bash命令之一，该命令可以将参数输出到屏幕上，需要注意的是shell会接续echo的命令行参数，即在输出之前，shell自动完成赋值、替换、等一系列操作，除此之外参数之间的空白字符会忽略，无论多少个空白字符，都会是一个字符，具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello    shell !  !    !</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182112259.png" alt="image-20231218211254225" /></p>
<p>​	但有些时候又需要空白字符，那要如何做呢？</p>
<h2 id="22-保留空白字符"><a class="markdownIt-Anchor" href="#22-保留空白字符"></a> 2.2 保留空白字符</h2>
<p>​	其实保留空白字符的方法十分简单，只需要在字符前后加上双引号或者单引号即可，具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello    shell !  !    !&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182119526.png" alt="image-20231218211953490" /></p>
<p>​	通过单引号和双引号可以指定为字符串，而shell不会对字符串进行干涉，双引号和单引号也是有区别的,单引号明确告诉不要干涉，而双引号仍旧会执行一些替换操作，包括变量扩展、算数运算、波浪号扩展等</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182135535.png" alt="image-20231218213521502" /></p>
<h2 id="23-在输出中加入更多的格式控制"><a class="markdownIt-Anchor" href="#23-在输出中加入更多的格式控制"></a> 2.3 在输出中加入更多的格式控制</h2>
<p>​	就跟C语言里面的相同，仍旧可以使用printf命令打印这些，具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf &quot;%s = %d\n&quot; lines $LINES</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182138655.png" alt="image-20231218213848622" /></p>
<p>​	==我知道你想说，这个东西有什么用吗，没错我也是这样想的，但是你怎么知道你以后不用它呢，当你真的用的时候你还能想的起来吗==</p>
<h2 id="24-消除换行符"><a class="markdownIt-Anchor" href="#24-消除换行符"></a> 2.4 消除换行符</h2>
<p>​	认真观察的同学可能发现了，上面的echo命令自带换行，而printf命令默认不带换行，换行需要一个\n来完成，那echo如何不换行呢，其实可以加一个参数-n，具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -n lines</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182146056.png" alt="image-20231218214603028" /></p>
<p>除此之外还可以通过添加-e参数和\c转义序列来实现，具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e &#x27;lines\c&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182147836.png" alt="image-20231218214717809" /></p>
<h2 id="25-保存命令输出"><a class="markdownIt-Anchor" href="#25-保存命令输出"></a> 2.5 保存命令输出</h2>
<p>可以通过&gt;符号来告诉shell将输出重定向到文件中，具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello shell &gt; 01_helloshell</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182149376.png" alt="image-20231218214925317" /></p>
<p>​	上面用到了cat命令进行文件夹内容的查看，当然cat并不仅仅是用来查看文件夹内容的，cat的英文原型是concatenation（拼接），该命令会将出现在命令行上的文件的输出拼接在一起。后面会有章节对cat进行学习，这里先了解这么多。</p>
<h2 id="26-追加输出"><a class="markdownIt-Anchor" href="#26-追加输出"></a> 2.6 追加输出</h2>
<p>​	上面使用单括号进行了输出重定向，使用两个单括号进行追加输出。具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo hello shell &gt; 02_helloshell</span><br><span class="line">echo hello shell too &gt;&gt; 02_helloshell</span><br><span class="line">cat 02_helloshell</span><br></pre></td></tr></table></figure>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231218215813823.png" alt="image-20231218215813823" /></p>
<h2 id="27-获取文件的开始和结尾"><a class="markdownIt-Anchor" href="#27-获取文件的开始和结尾"></a> 2.7 获取文件的开始和结尾</h2>
<p>​	使用head和tail命令输出指定文件的开始和结尾前10行或者后10行的内容，也可以加入-number参数指定默认行数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head -1 02_helloshell</span><br><span class="line">tail -1 02_helloshell</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182201446.png" alt="image-20231218220159397" /></p>
<p>​	tail除了-number这一参数外，还可以有这样的格式 -n number，这样可以指定相对于文件末尾的行偏移。因此tail -n 10 file 会显示文件的最后10行，而如果以加号开头则表示文件起始的偏移数，例如tail -n +1 file会显示整个文件，tail -n +2 file会跳过第一行，以此类推。</p>
<h2 id="28-丢弃输出"><a class="markdownIt-Anchor" href="#28-丢弃输出"></a> 2.8 丢弃输出</h2>
<p>​	这个我还是很熟悉的，我前些日子搞了一下这个，通过将输出丢弃，从而起到了美化终端的作用。其实也挺简单的，就是输出重定向到/dev/null中。具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello shell too &gt; /dev/null</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182220976.png" alt="image-20231218222037949" /></p>
<h2 id="29-将输出作为输入管道"><a class="markdownIt-Anchor" href="#29-将输出作为输入管道"></a> 2.9 将输出作为输入(管道)</h2>
<p>管道符 | ，可以将上一个命令的输出作为输入传给下一个命令，具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 02_helloshell | grep too</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182224603.png" alt="image-20231218222447569" /></p>
<p>tee可以保留输出前的副本，上面的管道可以省略步骤，但是呢，如果想要查看中间步骤的结果要怎么办呢，那就是tee命令了，tee可以将管道分成两个一模一样的流，一个用来写入文件，一个用来继续向下传递，具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 02_helloshell | tee 03_tee | grep too</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312182230184.png" alt="image-20231218223034147" /></p>
<h2 id="210-以输出为参数连接两个程序"><a class="markdownIt-Anchor" href="#210-以输出为参数连接两个程序"></a> 2.10 以输出为参数连接两个程序</h2>
<p>​	<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312190736817.png" alt="image-20231219073617761" />	如上图所示，可以通过find命令查找上面的三个文件，那如何将这些输入引入rm 从而删除呢，rm只能以命令行参数的形式获取文件名，所以像下面这种方式是不对的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name &#x27;0*&#x27; | rm </span><br></pre></td></tr></table></figure>
<p>​	那应该如何操作呢，其实也不难，只需使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mtext>即可，</mtext></mrow><annotation encoding="application/x-tex">()即可，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mclose">)</span><span class="mord cjk_fallback">即</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">，</span></span></span></span>()会被替换成所包含的命令输出，具体示例如下所示</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $(find -name &#x27;0*&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312190742576.png" alt="image-20231219074243540" /></p>
<p>可以看到输出就变成了命令行参数，所以可以通过下面的命令来删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm $(find -name &#x27;0*&#x27;)</span><br></pre></td></tr></table></figure>
<h1 id="3-标准输入"><a class="markdownIt-Anchor" href="#3-标准输入"></a> 3 标准输入</h1>
<h2 id="31获取文件输入"><a class="markdownIt-Anchor" href="#31获取文件输入"></a> 3.1获取文件输入</h2>
<p>​	这个其实比较简单，标准输出的符号是&gt;，那相对的标准输入的符号肯定就是&lt;了，但是我目前并不理解这个&lt;的实际用法是什么，以后如果学习到了再来进行弥补。</p>
<h2 id="32-获得脚本输入"><a class="markdownIt-Anchor" href="#32-获得脚本输入"></a> 3.2 获得脚本输入</h2>
<p>​	使用&lt;&lt;两个箭头来从命令行，而非文件重定向输入文本，如果放在shell脚本中，可以同时包含数据和代码，一个具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grep $1 &lt;&lt;EOF</span><br><span class="line">111 1</span><br><span class="line">222 2</span><br><span class="line">333 3</span><br><span class="line">444 4</span><br><span class="line">555 5</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312192029903.png" alt="image-20231219202905867" /></p>
<p>​		上面这个shell脚本有两个地方要注意的，第一个是$1。这个表示脚本输入的第一个参数，而后面的&lt;&lt;表示我们想要创建一个临时的输入源，==EOF是上面最重要的一个点，我之前一直以为他是开始和结束的标志，而实际上并不是，在&lt;&lt;后面可以是任意的字符串，只要最后的结束也是这个字符串即可==。</p>
<p>​	仍旧需要注意的是，在&lt;&lt;内部的这些内容，都是可以被解释的，例如如果内部输入了一个$1，那就会被转换为输入的第一个字符，那要如何避免这个情况呢，其实也很简单，那就是给EOF加上‘’单引号，表示不用执行扩展。</p>
<h2 id="33-获取用户输入"><a class="markdownIt-Anchor" href="#33-获取用户输入"></a> 3.3 获取用户输入</h2>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312192038960.png" alt="image-20231219203837889" /></p>
<p>​	可以通过read命令进行用户输入的获取，就比如上面的RPE变量，通过输入之后再读取出来。</p>
<h1 id="4-执行命令"><a class="markdownIt-Anchor" href="#4-执行命令"></a> 4 执行命令</h1>
<h2 id="41-运行程序"><a class="markdownIt-Anchor" href="#41-运行程序"></a> 4.1 运行程序</h2>
<p>​	bash的基本操作就是载入并运行程序，其他都是一些准备工作，除了shell的变量之外还有循环控制语句、判断以及各种控制输入和输出的方法，但是上面的这些描述仅仅只是锦上添花而已，所以这时候就应该想一些内容了，程序到底是从哪里开始运行的呢。</p>
<p>​	bash使用名为￥PATH的shell变量来定位这些可执行文件，￥PATH变量包含了一个目录列表，各个目录之间以冒号：进行分割，bash在这些目录中查找命令行上指定的可执行文件，目录的顺序很重要，会根据PATH变量中定义的顺序依次查找，选择所找到的第一个同名的可执行文件。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312210733311.png" alt="image-20231221073336242" /></p>
<p>​	赋予可执行权限的命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x name</span><br></pre></td></tr></table></figure>
<h2 id="42-执行多个命令"><a class="markdownIt-Anchor" href="#42-执行多个命令"></a> 4.2 执行多个命令</h2>
<p>​	方法一：不停的输入，Linux系统足够先进，在运行上一个命令的同时允许你继续输入，因此可以将命令依次输入进去即可。</p>
<p>​	方法二：将多个命令写入脚本中，运行这个脚本即可</p>
<p>​	方法三：依次执行这些命令，只需要使用分号将这些命令分隔开然后输入即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long ; medium ; short</span><br></pre></td></tr></table></figure>
<p>​	这样无论前面的程序是否运行成功，都会继续执行后面的命令，如果想要确保前面的命令运行成功，可以用下面这种写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long &amp;&amp; medium &amp;&amp; short</span><br></pre></td></tr></table></figure>
<h2 id="43-同时执行多个命令"><a class="markdownIt-Anchor" href="#43-同时执行多个命令"></a> 4.3 同时执行多个命令</h2>
<p>​	可以在命令行的末尾加上一个&amp;符号，在后台运行起来，这样一来，就能够快速的同时执行三个命令了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long &amp;</span><br><span class="line">medium &amp;</span><br><span class="line">short </span><br></pre></td></tr></table></figure>
<p>或者也可以将他们放在一个单行，具体如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long &amp; medium &amp; short </span><br></pre></td></tr></table></figure>
<p>这里提一下bg命令,一个示例如下所示：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312210751415.png" alt="image-20231221075105359" /></p>
<p>​	这个脚本的作用很简单就是睡眠10秒钟，在睡眠的过程中使用ctrl+z暂停，需要注意的是这里是暂停，而不是中断或者停止，暂停是可以回复的，可以使用两个命令进行恢复命令，也就是fg和bg，这两个命令从名字就可以看出fg是放到前台，而bg是放到后台，但每个命令都能继续运行相应的脚本。</p>
<h2 id="44-了解命令是否成功运行"><a class="markdownIt-Anchor" href="#44-了解命令是否成功运行"></a> 4.4 了解命令是否成功运行</h2>
<p>​	shell变量中$?中保存着命令的退出状态，其取值范围为0-255，在编写shell脚本的时候，正确的做法是，如果一切正常，退出时候就会返回0，如果运行的过程中出错了，就会返回非0值，一个具体示例如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312210757591.png" alt="image-20231221075735514" /></p>
<p>​	可以看到睡眠十秒的程序被打断了，然后它的返回值为148，为非零值就表示没有正常退出，但要注意的是，退出状态的机会只有一次。</p>
<h2 id="45-无人值守下运行耗时作业"><a class="markdownIt-Anchor" href="#45-无人值守下运行耗时作业"></a> 4.5 无人值守下运行耗时作业</h2>
<p>​	这个很重要呀，就比如，我在我的电脑上运行服务器编译，当我的本地终端关掉之后，服务器的命令我想让他仍旧可以继续运行，放到后台当然也是一个很好的办法，但是终端关掉之后这个仍旧是退出了，所以本小节的nohup命令很是重要，nohup命令的效果只是设置子进程忽略hangup信号，但其仍旧可以被kail杀死，这当然是两回事。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./06_bg &amp;</span><br></pre></td></tr></table></figure>
<p>​	这样运行06进行睡眠，然后关掉终端，这个程序仍旧是在运行的。</p>
<h1 id="5-shell变量"><a class="markdownIt-Anchor" href="#5-shell变量"></a> 5 shell变量</h1>
<p>​	无论是什么编程语言，变量都是必不可少的一个，shell编程中也不例外，一般情况下，shell中的变量采用全大写的方式，变量不需要进行声明，直接使用即可，由于命令的区分困难，所以赋值语句前后都不能有空格，当然在文件名字中也不能出现=等于号。引用变量的时候要使用$美元符号，而赋值的时候不需要加上引用符。</p>
<h2 id="51-注释"><a class="markdownIt-Anchor" href="#51-注释"></a> 5.1 注释</h2>
<p>​	在shell中使用#作为注释，在#后面的一行不会被解释。</p>
<h2 id="52-提高脚本可读性"><a class="markdownIt-Anchor" href="#52-提高脚本可读性"></a> 5.2 提高脚本可读性</h2>
<ol>
<li>​	以四个空格为一个等级，不要使用tab指标符号。</li>
<li>尽可能的不要省略变量名称，利于后期的维护</li>
<li>每行的内容描述不完时可以使用\进行断行</li>
</ol>
<h2 id="53-变量的导出"><a class="markdownIt-Anchor" href="#53-变量的导出"></a> 5.3 变量的导出</h2>
<p>​	如果在一个脚本中定义了一个变量，其他脚本中是不能共享该变量的，如果想要共享这个变量需要使用export进行变量的导出。</p>
<h2 id="54查看所有的变量"><a class="markdownIt-Anchor" href="#54查看所有的变量"></a> 5.4查看所有的变量</h2>
<p>​	可以使用set或者env对变量进行查看，set可以查看定义的所有变量和值，而env是查看所有导出的变量。</p>
<h2 id="55在shell脚本中使用参数"><a class="markdownIt-Anchor" href="#55在shell脚本中使用参数"></a> 5.5在shell脚本中使用参数</h2>
<p>​	 使用$1 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mtext>来代替脚本中所使用的参数，当然要是有很多个，超过了十个以上的参数，那么需要用双括号引起来</mtext></mrow><annotation encoding="application/x-tex">2 来代替脚本中所使用的参数，当然要是有很多个，超过了十个以上的参数，那么需要用双括号引起来</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">替</span><span class="mord cjk_fallback">脚</span><span class="mord cjk_fallback">本</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">当</span><span class="mord cjk_fallback">然</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">很</span><span class="mord cjk_fallback">多</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">超</span><span class="mord cjk_fallback">过</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">十</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">那</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">双</span><span class="mord cjk_fallback">括</span><span class="mord cjk_fallback">号</span><span class="mord cjk_fallback">引</span><span class="mord cjk_fallback">起</span><span class="mord cjk_fallback">来</span></span></span></span>{10}</p>
<h2 id="56-获取参数的数量"><a class="markdownIt-Anchor" href="#56-获取参数的数量"></a> 5.6 获取参数的数量</h2>
<p>​	使用$#来获取脚本输入的数量，在限定输入参数的一些脚本中有用。</p>
<h1 id="6-shell逻辑和运算"><a class="markdownIt-Anchor" href="#6-shell逻辑和运算"></a> 6 shell逻辑和运算</h1>
<h2 id="61-算数运算"><a class="markdownIt-Anchor" href="#61-算数运算"></a> 6.1 算数运算</h2>
<p>​	使用$(())或者let进行算数运算，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COUNT=$((COUNT + 5 + MAX * 2))</span><br><span class="line">let COUNT+=&#x27;5+MAX*2&#x27;</span><br></pre></td></tr></table></figure>
<p>​	需要注意等于号两边不能有任何的空格，举一个反面例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COUNT = $((COUNT + 5 + MAX * 2))</span><br></pre></td></tr></table></figure>
<p>​	那么shell会解析成COUNT这个命令第一个参数是等于号，后面是运算。</p>
<h2 id="62-分支条件"><a class="markdownIt-Anchor" href="#62-分支条件"></a> 6.2 分支条件</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if [$# -lt 3 ]</span><br><span class="line">then</span><br><span class="line">	printf &quot;xxx&quot;</span><br><span class="line">elif [$# &gt; 3 ]</span><br><span class="line">then </span><br><span class="line">	printf &quot;xxx&quot;</span><br><span class="line">else</span><br><span class="line">    printf &quot;xxx&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>上面使用的是换行符号，其实也可以使用分号来替代上面的换行符。</p>
<h2 id="63-测试文件特性"><a class="markdownIt-Anchor" href="#63-测试文件特性"></a> 6.3 测试文件特性</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-b # 块设备文件</span><br><span class="line">-c # 字符设备文件</span><br><span class="line">-d # 目录文件</span><br><span class="line">-e # 文件是否存在</span><br><span class="line">-f # 普通文件</span><br><span class="line">-h # 链接符号文件</span><br><span class="line">-r # 可读文件</span><br><span class="line">-s # 文件大小不为空</span><br><span class="line">-w # 可写文件</span><br><span class="line">-x # 可执行文件</span><br></pre></td></tr></table></figure>
<p>也可以使用-a或者-o参数在判断内进行逻辑判断的组合，-a表示逻辑与，-o表示逻辑或</p>
<h2 id="64-多路分支"><a class="markdownIt-Anchor" href="#64-多路分支"></a> 6.4 多路分支</h2>
<p>​	如果有多个比较，如果只是简单的使用if elif else 则会显得非常啰嗦和重复，而更好的解决办法是case，一个case的示例如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case $FN in</span><br><span class="line">	1）xxx;;</span><br><span class="line">	2) xxx;;</span><br><span class="line">	3) xxx;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<p>​	case语句会扩展case和in之间的单词，然后依次匹配多种模式</p>
<h1 id="7-中级shell工具"><a class="markdownIt-Anchor" href="#7-中级shell工具"></a> 7 中级shell工具</h1>
<h2 id="71-在文件中查找字符串"><a class="markdownIt-Anchor" href="#71-在文件中查找字符串"></a> 7.1 在文件中查找字符串</h2>
<p>​	使用grep命令在文件中查找相关的字符串，一个具体示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep printf *.c</span><br></pre></td></tr></table></figure>
<p>​	这段shell代码的作用就是在本地的C程序中查找printf语句。</p>
<p>​	如果一个文件中出现了很多次的printtf，那会将这个文件打印很多遍，要如何只打印一遍呢，这个只需要-l参数即可，具体如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -l printf *.c</span><br></pre></td></tr></table></figure>
<p>​	如果只是想知道在某个文件中是否有这个字符，只需要使用-q参数即可，该参数的作用是将输入结果丢弃到/dev/null，然后通过$?查看即可。</p>
<p>不区分大小写的话要使用-i参数，具体示例如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i printf *.c</span><br></pre></td></tr></table></figure>
<p>​	那如何在压缩文件中搜索呢，其实也只能搜索是不是有这个文件，但不能得到相应的信息，就比如下面这样</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312222132396.png" alt="image-20231222213204345" /></p>
<p>​	我还以为能有好东西了，原来只是简单的搜索。</p>
<h2 id="72-保留部分行"><a class="markdownIt-Anchor" href="#72-保留部分行"></a> 7.2 保留部分行</h2>
<p>​	使用awk命令从命令行上指定的文件中读取数据，例如默认情况下ls -l的打印如下所示：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312222137695.png" alt="image-20231222213709584" />	可以通过下面这个命令只打印第一行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l | awk &#x27;&#123;print $1&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312222137811.png" alt="image-20231222213756694" /></p>
<p>​	而现在得到的结果也并不好，因为并没有相应的文件名，上面的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mtext>是第一行，那文件名是第几行呢，是最后一行，我们并不知道最后一行是多少，不要着急，有内建命令，在</mtext><mi>a</mi><mi>w</mi><mi>k</mi><mtext>中</mtext></mrow><annotation encoding="application/x-tex">1是第一行，那文件名是第几行呢，是最后一行，我们并不知道最后一行是多少，不要着急，有内建命令，在awk中</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">第</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">那</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">名</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">第</span><span class="mord cjk_fallback">几</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">呢</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">知</span><span class="mord cjk_fallback">道</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">多</span><span class="mord cjk_fallback">少</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">着</span><span class="mord cjk_fallback">急</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">建</span><span class="mord cjk_fallback">命</span><span class="mord cjk_fallback">令</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">在</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">中</span></span></span></span>NF表示最后一行的元素。所以这个命令可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l | awk &#x27;&#123;print $1,$NF&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312222142312.png" alt="image-20231222214203181" /></p>
<h2 id="73-压缩文件"><a class="markdownIt-Anchor" href="#73-压缩文件"></a> 7.3 压缩文件</h2>
<p>tar这个命令我用过很多次了，但好像我一直都不解其意，tar的英文全程是tape archive翻译成中文也就是磁带归档。</p>
<h2 id="74-find"><a class="markdownIt-Anchor" href="#74-find"></a> 7.4 find</h2>
<p>好像find并不是我想象中的那么简单，一个具体的示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name *gz -print -exec mv &#x27;&#123;&#125;&#x27; /home/topeet/ \;</span><br></pre></td></tr></table></figure>
<p>​	上面这句脚本前面很用以理解，那就是查找以gz结尾的文件，后面是print是必须要有的，打印正确，而-exec是找到文件之后要执行的命令，这里是mv，而后面的‘{}’就表示前面查找到的内容，再后面是移动到的位置，最后是\；这个不能缺少</p>
<p>​	可如果是软链接或者硬链接呢，上面的find查找到的只是文件名，并没有找到文件的根本位置，其实也很见到那，只需要加入一个-L参数即可，具体示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -L . -name *gz -print -exec mv &#x27;&#123;&#125;&#x27; /home/topeet/ \;</span><br></pre></td></tr></table></figure>
<p>​	那如何不区分大小写进行查找呢，其实也简单只需要将上面的-name 换位-iname即可，具体示例如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -L . -iname *gz -print -exec mv &#x27;&#123;&#125;&#x27; /home/topeet/ \;</span><br></pre></td></tr></table></figure>
<h2 id="75-函数"><a class="markdownIt-Anchor" href="#75-函数"></a> 7.5 函数</h2>
<p>​	三种不同的函数编写方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function usage ()</span><br><span class="line">&#123;</span><br><span class="line">	printf xxx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function usage &#123;</span><br><span class="line">	printf xxx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usage ()</span><br><span class="line">&#123;</span><br><span class="line">	printf xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	可以注意到保留字function或者（）必须出现，如果使用了function，那么（）就是可选的，一般情况下都使用第一种情况</p>
<h2 id="76-别名"><a class="markdownIt-Anchor" href="#76-别名"></a> 7.6 别名</h2>
<p>​	可以通过alias对一些常用命令进行重命名，默认情况下其实已经有一些别名了，如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312230714153.png" alt="image-20231223071432992" /></p>
<p>​	一个具体的示例如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias h=’ls -’</span><br></pre></td></tr></table></figure>
<h2 id="77-计算时间"><a class="markdownIt-Anchor" href="#77-计算时间"></a> 7.7 计算时间</h2>
<p>​	不建议使用time，建议使用bash内建的SECONDS变量，可以记录时间，具体如下所示：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312230726458.png" alt="image-20231223072615391" /></p>
<h1 id="8-简单的图形界面"><a class="markdownIt-Anchor" href="#8-简单的图形界面"></a> 8 简单的图形界面</h1>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/bin/bash</span> </span><br><span class="line">titlestr=&quot;选择一个选项&quot;  # 标题字符串</span><br><span class="line">backtitle=&quot;iTOP-RK3568构建脚本，http://www.topeet.com&quot;  # 返回标题，网站链接</span><br><span class="line">menustr=&quot;Compile image | uboot| kernel| recovery| buildroot | debian | yocto | all&quot;  # 菜单字符串</span><br><span class="line">TTY_X=$(($(stty size | awk &#x27;&#123;print $2&#125;&#x27;)-6))                    # 确定终端宽度</span><br><span class="line">TTY_Y=$(($(stty size | awk &#x27;&#123;print $1&#125;&#x27;)-6))                    # 确定终端高度</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选项数组，包含选项和对应的函数名</span></span><br><span class="line">choose+=(&quot;uboot&quot; &quot;build_uboot&quot;)</span><br><span class="line">choose+=(&quot;kernel&quot; &quot;build_kernel&quot;)</span><br><span class="line">choose+=(&quot;recovery&quot; &quot;build_recovery&quot;)</span><br><span class="line">choose+=(&quot;buildroot&quot; &quot;build_rootfs buildroot&quot;)</span><br><span class="line">choose+=(&quot;debian&quot; &quot;build_rootfs debian&quot;)</span><br><span class="line">choose+=(&quot;yocto&quot; &quot;build_rootfs yocto&quot;)</span><br><span class="line">choose+=(&quot;save&quot; &quot;build_save&quot;)</span><br><span class="line">choose+=(&quot;all&quot; &quot;build_all&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用whiptail创建菜单，保存用户选择的选项到变量OPTIONS中</span></span><br><span class="line">OPTIONS=$(whiptail --title &quot;$&#123;titlestr&#125;&quot; --backtitle &quot;$&#123;backtitle&#125;&quot; --notags \</span><br><span class="line">                            --menu &quot;$&#123;menustr&#125;&quot; &quot;$&#123;TTY_Y&#125;&quot; &quot;$&#123;TTY_X&#125;&quot; $((TTY_Y - 8))  \</span><br><span class="line">                            --cancel-button Exit --ok-button Select &quot;$&#123;choose[@]&#125;&quot; \</span><br><span class="line">                            3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3)</span><br><span class="line">echo $OPTIONS</span><br></pre></td></tr></table></figure>
<p>​	图像示例如下所示：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312250734246.png" alt="image-20231225073426133" />	然后进行简单的修改将脚本修改为两页。具体脚本内容如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/bin/bash</span> </span><br><span class="line">titlestr=&quot;选择一个选项&quot;  # 标题字符串</span><br><span class="line">backtitle=&quot;iTOP-RK3568构建脚本，http://www.topeet.com&quot;  # 返回标题，网站链接</span><br><span class="line">menustr=&quot;Compile image | uboot| kernel| recovery| buildroot | debian | yocto | all&quot;  # 菜单字符串</span><br><span class="line">TTY_X=$(($(stty size | awk &#x27;&#123;print $2&#125;&#x27;)-6))                    # 确定终端宽度</span><br><span class="line">TTY_Y=$(($(stty size | awk &#x27;&#123;print $1&#125;&#x27;)-6))                    # 确定终端高度</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一页选项数组，包含选项和对应的函数名</span></span><br><span class="line">choose_page1+=(&quot;uboot&quot; &quot;build_uboot&quot;)</span><br><span class="line">choose_page1+=(&quot;kernel&quot; &quot;build_kernel&quot;)</span><br><span class="line">choose_page1+=(&quot;recovery&quot; &quot;build_recovery&quot;)</span><br><span class="line">choose_page1+=(&quot;save&quot; &quot;build_save&quot;)</span><br><span class="line">choose_page1+=(&quot;all&quot; &quot;build_all&quot;)</span><br><span class="line">choose_page1+=(&quot;rootfs&quot; &quot;build_rootfs&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第二页选项数组，包含选项和对应的函数名</span></span><br><span class="line">choose_page2+=(&quot;buildroot&quot; &quot;build_rootfs buildroot&quot;)</span><br><span class="line">choose_page2+=(&quot;debian&quot; &quot;build_rootfs debian&quot;)</span><br><span class="line">choose_page2+=(&quot;yocto&quot; &quot;build_rootfs yocto&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用whiptail创建第一页菜单，保存用户选择的选项到变量OPTIONS中</span></span><br><span class="line">OPTIONS=$(whiptail --title &quot;$&#123;titlestr&#125;&quot; --backtitle &quot;$&#123;backtitle&#125;&quot; --notags \</span><br><span class="line">                    --menu &quot;$&#123;menustr&#125;&quot; &quot;$&#123;TTY_Y&#125;&quot; &quot;$&#123;TTY_X&#125;&quot; $((TTY_Y - 8))  \</span><br><span class="line">                    --cancel-button Exit --ok-button Select &quot;$&#123;choose_page1[@]&#125;&quot; \</span><br><span class="line">                    3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据用户选择的选项，判断是否需要显示第二页菜单</span></span><br><span class="line">if [[ $OPTIONS == &quot;rootfs&quot; ]]; then</span><br><span class="line">    # 使用whiptail创建第二页菜单，保存用户选择的选项到变量OPTIONS中</span><br><span class="line">    OPTIONS=$(whiptail --title &quot;$&#123;titlestr&#125;&quot; --backtitle &quot;$&#123;backtitle&#125;&quot; --notags \</span><br><span class="line">                        --menu &quot;$&#123;menustr&#125;&quot; &quot;$&#123;TTY_Y&#125;&quot; &quot;$&#123;TTY_X&#125;&quot; $((TTY_Y - 8))  \</span><br><span class="line">                        --cancel-button Exit --ok-button Select &quot;$&#123;choose_page2[@]&#125;&quot; \</span><br><span class="line">                        3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3)</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo $OPTIONS</span><br></pre></td></tr></table></figure>
<p>这是第一页的内容：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312250743408.png" alt="image-20231225074324294" />	这是第二页的内容：<br />
<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202312250744974.png" alt="image-20231225074424898" />	还有许多要改的内容，就比如上面的标题，然后那个提示文字等等，这些都需要改，慢慢来吧，最后对该命令的介绍进行总结：当我们需要在终端界面中创建交互式的对话框和菜单时，Whiptail是一个非常有用的命令行工具。它提供了一种简单的方式来创建和显示对话框、消息框、输入框、菜单等，并且可以捕获用户的选择和输入。下面我将详细介绍Whiptail命令及其使用方法。</p>
<p>Whiptail命令的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whiptail [选项] [标题] [高度] [宽度] [默认值]</span><br></pre></td></tr></table></figure>
<p>选项可以用来配置对话框的外观和行为，标题是对话框的标题栏文本，高度和宽度指定对话框的尺寸，而默认值是可选的，用于设置输入框的默认值。</p>
<p>下面是Whiptail命令中常用的选项：</p>
<ul>
<li><code>--title &lt;文本&gt;</code>：设置对话框的标题。</li>
<li><code>--backtitle &lt;文本&gt;</code>：设置对话框的返回标题，通常用来显示相关的信息或链接。</li>
<li><code>--yesno &lt;文本&gt; &lt;高度&gt; &lt;宽度&gt;</code>：显示一个简单的是/否对话框，用户可以选择是或否。</li>
<li><code>--msgbox &lt;文本&gt; &lt;高度&gt; &lt;宽度&gt;</code>：显示一个简单的消息框，只用于显示信息，没有用户选择。</li>
<li><code>--inputbox &lt;文本&gt; &lt;高度&gt; &lt;宽度&gt; [默认值]</code>：显示一个输入框，用户可以输入文本。</li>
<li><code>--passwordbox &lt;文本&gt; &lt;高度&gt; &lt;宽度&gt;</code>：显示一个密码输入框，用户输入的内容会被隐藏。</li>
<li><code>--menu &lt;文本&gt; &lt;高度&gt; &lt;宽度&gt; &lt;菜单项1&gt; &lt;菜单项2&gt; ...</code>：显示一个菜单，用户可以从选项中选择一个。</li>
<li><code>--checklist &lt;文本&gt; &lt;高度&gt; &lt;宽度&gt; &lt;菜单项1&gt; &lt;菜单项2&gt; ...</code>：显示一个复选框菜单，用户可以选择多个选项。</li>
<li><code>--radiolist &lt;文本&gt; &lt;高度&gt; &lt;宽度&gt; &lt;菜单项1&gt; &lt;菜单项2&gt; ...</code>：显示一个单选框菜单，用户可以从选项中选择一个。</li>
<li><code>--textbox &lt;文件&gt; &lt;高度&gt; &lt;宽度&gt;</code>：显示一个只读文本框，用于显示文件中的内容。</li>
</ul>
<p>除了上述选项之外，Whiptail还提供了其他一些选项和功能，例如<code>--yes-button</code>、<code>--no-button</code>、<code>--defaultno</code>、<code>--nocancel</code>等，用于自定义对话框的按钮和默认行为。</p>
<p>使用Whiptail命令创建对话框时，用户的选择和输入可以通过标准输出返回，可以使用命令替换或重定向来捕获这些值。例如，可以将用户选择的选项保存到变量中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS=$(whiptail --menu &quot;请选择一个选项&quot; 10 40 3 \</span><br><span class="line">           &quot;1&quot; &quot;选项1&quot; \</span><br><span class="line">           &quot;2&quot; &quot;选项2&quot; \</span><br><span class="line">           &quot;3&quot; &quot;选项3&quot; \</span><br><span class="line">           3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3)</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，用户选择的选项将保存在变量<code>OPTIONS</code>中。使用<code>3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3</code>的重定向语法可以将标准输出和标准错误输出互换，这样可以将用户的选择输出到标准输出。</p>
<p>Whiptail还提供了一些辅助功能，例如获取终端的尺寸可以使用<code>stty size</code>命令，并结合算术运算来动态计算对话框的尺寸。这对于使对话框在不同终端上具有良好的可移植性非常有用。</p>
<p>总结一下，Whiptail是一个功能强大的命令行工具，用于创建交互式的对话框和菜单。它提供了当我们需要在终端界面中创建交互式的对话框和菜单时，Whiptail是一个非常有用的命令行工具。它提供了一种简单的方式来创建和显示对话框、消息框、输入框、菜单等，并且可以捕获用户的选择和输入。下面我将详细介绍Whiptail命令及其使用方法。</p>
<h1 id="9-实战"><a class="markdownIt-Anchor" href="#9-实战"></a> 9 实战</h1>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> tabstop=4 <span class="string">&quot;设置tab按键为四个字符</span></span><br><span class="line"><span class="string">set shiftwidth=4 &quot;</span>设置缩进为四个字符</span><br></pre></td></tr></table></figure>
<h2 id="91-在path-中查找程序"><a class="markdownIt-Anchor" href="#91-在path-中查找程序"></a> 9.1 在PATH 中查找程序</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">in_path 函数用于检查给定命令是否在指定路径中可执行</span></span><br><span class="line">in_path()</span><br><span class="line">&#123;</span><br><span class="line">    cmd=$1 ourpath=$2 result=1</span><br><span class="line">    oldIFS=$IFS IFS=&quot;:&quot;</span><br><span class="line">    for directory in $ourpath</span><br><span class="line">    do</span><br><span class="line">        if [ -x $directory/$cmd ] ; then</span><br><span class="line">            result=0</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">    IFS=$oldIFS</span><br><span class="line">    return $result</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">checkForCmdInPath 函数用于检查指定命令是否在环境变量 PATH 中可执行</span></span><br><span class="line">checkForCmdInPath()</span><br><span class="line">&#123;</span><br><span class="line">    var=$1</span><br><span class="line">    if [ &quot;$var&quot; != &quot;&quot; ] ; then</span><br><span class="line">        if [ &quot;$&#123;var:0:1&#125;&quot; = &quot;/&quot; ] ; then</span><br><span class="line">            if [ ! -x $var ] ; then</span><br><span class="line">                return 1</span><br><span class="line">            fi</span><br><span class="line">        elif ! in_path $var &quot;$PATH&quot; ; then</span><br><span class="line">            return 2</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查参数数量是否正确</span></span><br><span class="line">if [ $# -ne 1 ] ; then</span><br><span class="line">    echo &quot;使用方法: $0 命令&quot; &gt;&amp;2</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用 checkForCmdInPath 函数检查命令是否在 PATH 中</span></span><br><span class="line">checkForCmdInPath &quot;$1&quot;</span><br><span class="line">case $? in</span><br><span class="line">    0 ) echo &quot;$1 在 PATH 中找到&quot; ;;</span><br><span class="line">    1 ) echo &quot;$1 未找到或不可执行&quot; ;;</span><br><span class="line">    2 ) echo &quot;$1 未在 PATH 中找到&quot; ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
<p>​	<strong>知识点1：$用法</strong></p>
<ol>
<li><code>$1</code>：表示脚本中的第一个参数。在这个脚本中，<code>$1</code> 用于获取传递给脚本的命令参数。</li>
<li><code>$2</code>：表示脚本中的第二个参数。在 <code>in_path</code> 函数中，<code>$2</code> 用于获取传递给该函数的第二个参数，即路径。</li>
<li><code>$IFS</code>：表示内部字段分隔符（Internal Field Separator）。在脚本中，<code>$IFS</code> 用于保存原始的字段分隔符，并在后续代码中修改为 <code>:</code>，以便在路径中进行分隔。</li>
<li><code>$&#123;var:0:1&#125;</code>：表示对变量 <code>var</code> 进行字符串截取。<code>$&#123;var:0:1&#125;</code> 表示从字符串的第一个字符开始，截取长度为 1 的子字符串。在脚本中，<code>$&#123;var:0:1&#125;</code> 用于检查给定的命令是否是以 <code>/</code> 开头。</li>
<li><code>&quot;$var&quot;</code>：表示对变量进行引用。在脚本中，<code>&quot;$var&quot;</code> 用于将变量 <code>var</code> 的值作为字符串进行引用，以便在条件语句中进行判断。</li>
<li><code>$?</code>：表示上一个命令的退出状态。在脚本中，<code>$?</code> 用于获取 <code>checkForCmdInPath</code> 函数的返回值，即命令是否在 PATH 中可执行的状态。</li>
<li><code>$#</code> ：表示传递给脚本的参数数量。</li>
</ol>
<p>​	<strong>知识点2：if语法</strong></p>
<p>​		在Shell脚本中，<code>if</code>语句是用于执行条件判断的控制结构。它的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># 执行条件为真时的代码块</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># 执行条件为假时的代码块</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p><code>if</code>语句的工作原理如下：</p>
<ol>
<li>首先，<code>if</code>关键字标识条件语句的开始。</li>
<li>紧接着是一个条件表达式，用于判断条件的真假。条件表达式通常使用方括号 <code>[ ]</code> 来包裹，且表达式与方括号之间需要有空格。</li>
<li>如果条件表达式的结果为真（非零），则执行<code>then</code>关键字后面的代码块。代码块可以是单行命令或多行代码块，可以包含任何Shell支持的命令。</li>
<li>如果条件表达式的结果为假（零），则跳过<code>then</code>代码块，执行<code>else</code>关键字后面的代码块（可选）。如果没有<code>else</code>部分，整个<code>if</code>语句结束。</li>
<li>最后，通过<code>fi</code>关键字结束整个<code>if</code>语句块。</li>
</ol>
<p>在条件表达式中，可以使用各种条件判断运算符和Shell的内置命令来进行条件判断。常用的条件判断运算符包括：</p>
<ul>
<li><code>-eq</code>：等于</li>
<li><code>-ne</code>：不等于</li>
<li><code>-gt</code>：大于</li>
<li><code>-lt</code>：小于</li>
<li><code>-ge</code>：大于等于</li>
<li><code>-le</code>：小于等于</li>
<li><code>-z</code>：判断字符串是否为空</li>
<li><code>-n</code>：判断字符串是否非空</li>
<li><code>-f</code>：判断文件是否存在且为普通文件</li>
<li><code>-d</code>：判断路径是否存在且为目录</li>
<li><code>-x</code>：判断文件或路径是否可执行</li>
</ul>
<p><strong>知识点3：case语句</strong></p>
<p>在Shell脚本中，<code>case</code>语句是一种用于多重条件判断的控制结构。它的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> expression <span class="keyword">in</span></span><br><span class="line">    pattern1)</span><br><span class="line">        <span class="comment"># 匹配 pattern1 执行的代码块</span></span><br><span class="line">        ;;</span><br><span class="line">    pattern2)</span><br><span class="line">        <span class="comment"># 匹配 pattern2 执行的代码块</span></span><br><span class="line">        ;;</span><br><span class="line">    pattern3)</span><br><span class="line">        <span class="comment"># 匹配 pattern3 执行的代码块</span></span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="comment"># 默认情况（即未匹配任何模式）执行的代码块</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p><code>case</code>语句的工作原理如下：</p>
<ol>
<li>首先，<code>case</code>关键字标识多重条件语句的开始。</li>
<li><code>expression</code>是要进行匹配的表达式或变量。通常，<code>expression</code>是一个变量，你希望根据其值进行多重条件判断。</li>
<li>接下来，使用<code>in</code>关键字表示要开始进行模式匹配。</li>
<li>然后，每个模式使用圆括号<code>()</code>包括起来，并在每个模式后面加上<code>)</code>。</li>
<li>对于每个模式，如果<code>expression</code>的值与模式相匹配，则执行与该模式对应的代码块。代码块可以是单行命令或多行代码块，可以包含任何Shell支持的命令。</li>
<li>每个代码块的结尾需要使用两个分号<code>;;</code>表示结束。</li>
<li>如果<code>expression</code>的值未匹配任何模式，则执行<code>*)</code>后面的代码块（即默认情况）。这部分代码块是可选的。</li>
<li>最后，通过<code>esac</code>关键字结束整个<code>case</code>语句块。</li>
</ol>
<p>以下是一个具体的示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">fruit=<span class="string">&quot;apple&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$fruit</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">&quot;apple&quot;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;这是一个苹果&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="string">&quot;orange&quot;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;这是一个橘子&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="string">&quot;banana&quot;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;这是一个香蕉&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;未知的水果&quot;</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们使用变量<code>fruit</code>作为匹配表达式。根据<code>$fruit</code>的值，<code>case</code>语句会依次进行模式匹配。如果<code>$fruit</code>的值匹配到某个模式（例如，“apple”），则执行与该模式对应的代码块（输出&quot;这是一个苹果&quot;）。如果<code>$fruit</code>的值未匹配到任何模式，则执行默认情况下的代码块（输出&quot;未知的水果&quot;）。</p>
<h2 id="92-验证输入仅限字母和数字"><a class="markdownIt-Anchor" href="#92-验证输入仅限字母和数字"></a> 9.2 验证输入：仅限字母和数字</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数，用于验证字符串是否仅由字母和数字组成</span></span><br><span class="line"><span class="function"><span class="title">volidAlphaNum</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"># 通过sed命令将输入的字符串中的非字母和数字字符替换为空字符串</span></span><br><span class="line">    validchars=<span class="string">&quot;<span class="subst">$(echo $1 | sed &#x27;s/[^[:alnum:]]//g&#x27;)</span>&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 比较替换后的字符串与原始输入的字符串是否相等</span></span><br><span class="line">    <span class="comment"># 如果相等，说明输入的字符串仅由字母和数字组成，返回0</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$validchars</span>&quot;</span> = <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> 0</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment"># 如果不相等，说明输入的字符串包含非字母和数字字符，返回1</span></span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出提示并读取用户输入</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;请输入输入内容:&quot;</span></span><br><span class="line"><span class="built_in">read</span> input</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用验证函数检查输入的内容是否仅由字母和数字组成</span></span><br><span class="line"><span class="keyword">if</span> ! volidAlphaNum <span class="string">&quot;<span class="variable">$input</span>&quot;</span> ; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># 如果验证函数返回非0，说明输入的内容包含非字母和数字字符</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;错误：输入内容必须仅包含字母和数字&quot;</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># 如果验证函数返回0，说明输入的内容仅由字母和数字组成</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;输入内容有效&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本正常结束，退出状态码为0</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>
<p><strong>知识点</strong>1 <strong>read</strong></p>
<p>在Shell脚本中，<code>read</code> 是一个用于读取用户输入的命令。它允许脚本暂停执行，等待用户从标准输入（通常是键盘）输入一行文本，并将输入的内容保存到一个或多个变量中。</p>
<p><code>read</code> 命令的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> [options] [variable ...]</span><br></pre></td></tr></table></figure>
<p>其中，<code>options</code> 是一些可选的参数，用于控制 <code>read</code> 命令的行为。<code>variable</code> 是一个或多个变量名，用于保存用户输入的值。</p>
<p>以下是一些常用的 <code>read</code> 命令选项：</p>
<ul>
<li><code>-p prompt</code>：显示一个提示符，提示用户输入。<code>prompt</code> 是要显示的提示信息，可以是字符串或变量。示例：<code>read -p &quot;Enter your name: &quot; name</code></li>
<li><code>-s</code>：静默模式，用户输入内容时不回显在终端上，适用于输入密码等敏感信息。示例：<code>read -s password</code></li>
<li><code>-n num</code>：读取指定数量的字符后立即返回，而不需要等待用户按下回车键。<code>num</code> 是要读取的字符数。示例：<code>read -n 1 key</code> 读取一个字符。</li>
<li><code>-t timeout</code>：设置等待用户输入的超时时间（秒），如果超过指定时间没有输入，则 <code>read</code> 命令返回一个非零的退出状态码。示例：<code>read -t 5 input</code> 设置等待时间为5秒。</li>
</ul>
<p><strong>知识点2 sed</strong></p>
<p>​	在Shell脚本中，<code>sed</code>（Stream Editor）是一种流式文本编辑器，用于处理和转换文本流。它可以读取输入流中的文本，根据指定的编辑命令对文本进行修改，并将结果输出到标准输出流。</p>
<p><code>sed</code> 命令的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [options] <span class="string">&#x27;command&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>其中，<code>options</code> 是一些可选的参数，用于控制 <code>sed</code> 命令的行为。<code>'command'</code> 是一个或多个编辑命令，用于指定要对文本进行的操作。<code>file</code> 是要处理的输入文件。</p>
<p>以下是一些常用的 <code>sed</code> 命令选项：</p>
<ul>
<li><code>-n</code>：禁止默认输出，只输出经过编辑处理后的结果。如果没有使用 <code>-n</code>，则 <code>sed</code> 会默认将每一行的结果输出到标准输出。</li>
<li><code>-e script</code>：指定要执行的编辑命令。可以在一个 <code>sed</code> 命令中指定多个编辑命令，使用 <code>-e</code> 分隔它们。</li>
<li><code>-i</code>：原地编辑，直接修改输入文件，而不是将结果输出到标准输出。使用 <code>-i</code> 选项时可以指定备份文件的扩展名，备份文件会保留原始文件的副本。</li>
<li><code>-r</code>（或 <code>-E</code>）：启用扩展的正则表达式语法，可以使用更强大的正则表达式功能。</li>
</ul>
<p><code>sed</code> 命令的编辑命令由一个或多个操作组成，每个操作由一个地址和一个命令组成。地址指定了要应用命令的行范围，命令指定了要对行执行的操作。</p>
<p>以下是一些常用的 <code>sed</code> 命令操作：</p>
<ul>
<li><code>s/regexp/replacement/</code>：替换操作，将与正则表达式 <code>regexp</code> 匹配的文本替换为 <code>replacement</code>。例如：<code>sed 's/apple/orange/' file</code> 将文件中的 “apple” 替换为 “orange”。</li>
<li><code>p</code>：打印操作，输出指定范围内的行。例如：<code>sed -n '1,10p' file</code> 打印文件中的前10行。</li>
<li><code>d</code>：删除操作，删除指定范围内的行。例如：<code>sed '5,10d' file</code> 删除文件中的第5到第10行。</li>
<li><code>i\text</code>：插入操作，向指定行之前插入文本。例如：<code>sed '3i\This is a new line.' file</code> 在文件的第3行之前插入一行文本。</li>
<li><code>a\text</code>：追加操作，向指定行之后追加文本。例如：<code>sed '3a\This is a new line.' file</code> 在文件的第3行之后追加一行文本。</li>
</ul>
<p><code>sed 's/[^[:alnum:]]//g'</code>：这是 <code>sed</code> 命令的一部分，用于对输入的文本进行替换操作。</p>
<ol>
<li><code>s/[^[:alnum:]]//g</code> 是一个替换命令，用于将输入中的非字母数字字符替换为空字符串。</li>
<li><code>[^[:alnum:]]</code> 是一个正则表达式，表示匹配任何非字母数字字符。</li>
<li><code>//</code> 是替换命令的分隔符，用于指定要替换的文本为空字符串。</li>
<li><code>g</code> 是替换命令的标志，表示要替换所有匹配项，而不是只替换第一个匹配项。</li>
</ol>
<h2 id="93-规范日期格式"><a class="markdownIt-Anchor" href="#93-规范日期格式"></a> 9.3 规范日期格式</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">mounthNumToName</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">        1 ) month=<span class="string">&quot;Jan&quot;</span>;; 2 ) month=<span class="string">&quot;Feb&quot;</span> ;;</span><br><span class="line">        3 ) month=<span class="string">&quot;Mar&quot;</span>;; 4 ) month=<span class="string">&quot;Apr&quot;</span>;;</span><br><span class="line">        5 ) month=<span class="string">&quot;May&quot;</span>;; 6 ) month=<span class="string">&quot;Jun&quot;</span>;;</span><br><span class="line">        7 ) month=<span class="string">&quot;Jul&quot;</span>;; 8 ) month=<span class="string">&quot;Aug&quot;</span>;;</span><br><span class="line">        9 ) month=<span class="string">&quot;Sep&quot;</span>;; 10 ) month=<span class="string">&quot;Oct&quot;</span>;;</span><br><span class="line">        11 ) month=<span class="string">&quot;Nov&quot;</span>;; 12 ) month=<span class="string">&quot;Dec&quot;</span>;;</span><br><span class="line">        * ) <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$0</span>: 未知的月份数值 <span class="variable">$1</span>&quot;</span> &gt;&amp;2</span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查参数数量是否正确</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -ne 3 ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;用法: <span class="variable">$0</span> 月份 日  年份&quot;</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查年份是否为4位数字</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$3</span> -le 99 ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$0</span>: 预期为4位数字的年份&quot;</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查月份是否为纯数字</span></span><br><span class="line"><span class="keyword">if</span> [ -z $(<span class="built_in">echo</span> <span class="variable">$1</span>|sed <span class="string">&#x27;s/[[:digit:]]//g&#x27;</span>) ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># 如果是纯数字，则调用函数将月份转换为对应的名称</span></span><br><span class="line">    mounthNumToName <span class="variable">$1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># 如果不是纯数字，则将首字母大写，后续字母小写</span></span><br><span class="line">    month=<span class="string">&quot;<span class="subst">$(echo $1| cut -c1|tr &#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27;)</span>&quot;</span></span><br><span class="line">    month=<span class="string">&quot;$month<span class="subst">$(echo $1|cut -c2-3 | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;)</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$month</span> <span class="variable">$2</span> <span class="variable">$3</span></span><br></pre></td></tr></table></figure>
<h2 id="94-美化多位数字"><a class="markdownIt-Anchor" href="#94-美化多位数字"></a> 9.4 美化多位数字</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nicenumber--给定一个数字，以逗号分隔的形式显示它。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  需要DD（小数点分隔符）和TD（千位分隔符）被实例化。如果指定了第二个参数，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  则将输出回显到标准输出。</span></span><br><span class="line"></span><br><span class="line">nicenumber()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">注意，我们假设“.”是此脚本输入值中的小数分隔符。</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">输出值中的小数分隔符是“.”，除非用户使用-d标志指定。</span></span><br><span class="line"></span><br><span class="line">  integer=$(echo $1 | cut -d. -f1)        # 小数点左边</span><br><span class="line">  decimal=$(echo $1 | cut -d. -f2)        # 小数点右边</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">检查我们的数字是否除了整数部分之外还有其他部分。</span></span><br><span class="line">  if [ &quot;$decimal&quot; != &quot;$1&quot; ]; then</span><br><span class="line">    # 存在小数部分，因此将其包含在内。</span><br><span class="line">    result=&quot;$&#123;DD:= &#x27;.&#x27;&#125;$decimal&quot;</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  thousands=$integer</span><br><span class="line"></span><br><span class="line">  while [ $thousands -gt 999 ]; do</span><br><span class="line">    remainder=$(($thousands % 1000))    # 三个最低有效位</span><br><span class="line">    </span><br><span class="line">    # 我们需要“remainder”是三位数。我们需要添加零吗？</span><br><span class="line">    while [ $&#123;#remainder&#125; -lt 3 ] ; do  # 强制前导零</span><br><span class="line">      remainder=&quot;0$remainder&quot;</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    result=&quot;$&#123;TD:=&quot;,&quot;&#125;$&#123;remainder&#125;$&#123;result&#125;&quot;    # 从右向左构建</span><br><span class="line">    thousands=$(($thousands / 1000))    # 如果有余数，则向左移动</span><br><span class="line">  done</span><br><span class="line"></span><br><span class="line">  nicenum=&quot;$&#123;thousands&#125;$&#123;result&#125;&quot;</span><br><span class="line">  if [ ! -z $2 ] ; then</span><br><span class="line">    echo $nicenum</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DD=&quot;.&quot;  # 小数点分隔符，用于分隔整数和小数部分</span><br><span class="line">TD=&quot;,&quot;  # 千位分隔符，用于每三位数分隔</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始主脚本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=================</span></span><br><span class="line"></span><br><span class="line">while getopts &quot;d:t:&quot; opt; do</span><br><span class="line">  case $opt in</span><br><span class="line">    d ) DD=&quot;$OPTARG&quot;    ;;</span><br><span class="line">    t ) TD=&quot;$OPTARG&quot;    ;;</span><br><span class="line">  esac</span><br><span class="line">done</span><br><span class="line">shift $(($OPTIND - 1))</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入验证</span></span><br><span class="line">if [ $# -eq 0 ] ; then</span><br><span class="line">  echo &quot;Usage: $(basename $0) [-d c] [-t c] numeric_value&quot;</span><br><span class="line">  echo &quot;  -d 指定小数点分隔符（默认为&#x27;.&#x27;）&quot;</span><br><span class="line">  echo &quot;  -t 指定千位分隔符（默认为&#x27;,&#x27;）&quot;</span><br><span class="line">  exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">nicenumber $1 1         # 第二个参数强制nicenumber将输出回显。</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
<p><strong>重点1：</strong><br />
<code>getopts</code> 是一个用于处理命令行选项的 Bash 内置命令。它可以帮助你解析和处理脚本或命令的命令行参数。<code>getopts</code> 在循环中使用，每次循环处理一个选项，并将其与相应的参数关联起来。</p>
<p><code>getopts</code> 命令的语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getopts</span> optstring variable [args]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>optstring</code>：定义了脚本支持的选项列表，每个选项由一个字母表示。如果选项后面带有冒号（<code>:</code>），则表示该选项需要附加参数。</li>
<li><code>variable</code>：用于存储当前解析的选项的变量名。</li>
<li><code>args</code>：可选参数，用于指定要解析的命令行参数列表。如果省略，则默认使用脚本的命令行参数。</li>
</ul>
<p>在使用 <code>getopts</code> 时，你需要在脚本中使用一个 <code>while</code> 循环来处理每个选项。在循环中，<code>getopts</code> 会将当前解析的选项存储在 <code>variable</code> 变量中，并将附加的参数存储在特殊变量 <code>OPTARG</code> 中。</p>
<p>以下是一个简单的示例，展示了如何使用 <code>getopts</code> 处理命令行选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="string">&quot;a:b:&quot;</span> opt; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$opt</span> <span class="keyword">in</span></span><br><span class="line">    a)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;选项 -a，参数为 <span class="variable">$OPTARG</span>&quot;</span></span><br><span class="line">      ;;</span><br><span class="line">    b)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;选项 -b，参数为 <span class="variable">$OPTARG</span>&quot;</span></span><br><span class="line">      ;;</span><br><span class="line">    \?)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;无效的选项： -<span class="variable">$OPTARG</span>&quot;</span></span><br><span class="line">      ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行脚本并传递选项和参数</span></span><br><span class="line"><span class="comment"># ./script.sh -a value1 -b value2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 选项 -a，参数为 value1</span></span><br><span class="line"><span class="comment"># 选项 -b，参数为 value2</span></span><br></pre></td></tr></table></figure>
<p>在这个示例中，脚本使用 <code>getopts</code> 解析了两个选项 <code>-a</code> 和 <code>-b</code>，并将它们的参数打印出来。如果脚本遇到无效的选项，则会打印出错误信息。</p>
<p>总之，<code>getopts</code> 命令是一个用于处理命令行选项的工具，可以帮助你编写更灵活和可配置的脚本。</p>
<p><strong>重点2：</strong></p>
<ul>
<li><code>-z string</code>：判断给定的字符串是否为空。如果字符串为空，则条件为真。</li>
<li><code>-n string</code>：判断给定的字符串是否非空。如果字符串非空，则条件为真。</li>
<li><code>string1 = string2</code>：判断两个字符串是否相等。如果相等，则条件为真。</li>
<li><code>string1 != string2</code>：判断两个字符串是否不相等。如果不相等，则条件为真。</li>
<li><code>file1 -eq file2</code>：判断两个文件是否具有相同的设备号和 inode 号。如果相同，则条件为真。</li>
<li><code>file1 -nt file2</code>：判断文件 1 是否比文件 2 更新（修改时间更晚）。如果是，则条件为真。</li>
<li><code>file1 -ot file2</code>：判断文件 1 是否比文件 2 更旧（修改时间更早）。如果是，则条件为真。</li>
<li><code>num1 -eq num2</code>：判断两个数字是否相等。如果相等，则条件为真。</li>
<li><code>num1 -ne num2</code>：判断两个数字是否不相等。如果不相等，则条件为真。</li>
<li><code>num1 -lt num2</code>：判断 num1 是否小于 num2。如果是，则条件为真。</li>
<li><code>num1 -le num2</code>：判断 num1 是否小于等于 num2。如果是，则条件为真。</li>
<li><code>num1 -gt num2</code>：判断 num1 是否大于 num2。如果是，则条件为真。</li>
<li><code>num1 -ge num2</code>：判断 num1 是否大于等于 num2。如果是，则条件为真。</li>
</ul>
<h2 id="95-验证整数输入"><a class="markdownIt-Anchor" href="#95-验证整数输入"></a> 9.5 验证整数输入</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">validint--验证整数输入，允许负数。</span></span><br><span class="line"></span><br><span class="line">validint()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">验证第一个字段，并将其与提供的最小值 <span class="variable">$2</span> 和/或最大值 <span class="variable">$3</span> 进行比较：</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">如果值不在范围内或不仅由数字组成，则失败。</span></span><br><span class="line"></span><br><span class="line">  number=&quot;$1&quot;;      min=&quot;$2&quot;;      max=&quot;$3&quot;</span><br><span class="line"></span><br><span class="line">  if [ -z $number ] ; then</span><br><span class="line">    echo &quot;您未输入任何内容。请输入一个数字。&quot; &gt;&amp;2 ; return 1</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">第一个字符是否为 <span class="string">&#x27;-&#x27;</span> 符号？</span></span><br><span class="line">  if [ &quot;$&#123;number%$&#123;number#?&#125;&#125;&quot; = &quot;-&quot; ] ; then</span><br><span class="line">    testvalue=&quot;$&#123;number#?&#125;&quot; # 提取除第一个字符外的所有字符进行测试。</span><br><span class="line">  else</span><br><span class="line">    testvalue=&quot;$number&quot;</span><br><span class="line">  fi</span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">创建一个没有数字的版本，用于测试。</span></span><br><span class="line">  nodigits=&quot;$(echo $testvalue | sed &#x27;s/[[:digit:]]//g&#x27;)&quot;</span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">检查是否存在非数字字符。</span></span><br><span class="line">  if [ ! -z $nodigits ] ; then</span><br><span class="line">    echo &quot;无效的数字格式！只允许数字，不允许逗号、空格等。&quot; &gt;&amp;2</span><br><span class="line">    return 1</span><br><span class="line">  fi</span><br><span class="line">  </span><br><span class="line">  if [ ! -z $min ] ; then</span><br><span class="line">    # 输入值是否小于最小值？</span><br><span class="line">    if [ &quot;$number&quot; -lt &quot;$min&quot; ] ; then</span><br><span class="line">      echo &quot;$number 太小了：最小可接受值为 $min&quot; &gt;&amp;2</span><br><span class="line">      return 1</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">  if [ ! -z $max ] ; then</span><br><span class="line">    # 输入值是否大于最大值？</span><br><span class="line">    if [ &quot;$number&quot; -gt &quot;$max&quot; ] ; then</span><br><span class="line">      echo &quot;您的值太大了：最大可接受值为 $max&quot; &gt;&amp;2</span><br><span class="line">      return 1</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">  return 0</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入验证</span></span><br><span class="line">if validint &quot;$1&quot; &quot;$2&quot; &quot;$3&quot; ; then</span><br><span class="line">  echo &quot;输入是一个在您约束条件内的有效整数&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h2 id="96-验证浮点数输入"><a class="markdownIt-Anchor" href="#96-验证浮点数输入"></a> 9.6 验证浮点数输入</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">validfloat--检测一个数字是否是有效的浮点数。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  注意，此脚本无法接受科学计数法（1.304e5）表示的浮点数。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为了测试输入值是否是有效的浮点数，我们需要将该值拆分为两部分：整数部分和小数部分。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们可以测试第一部分，看它是否是有效的整数，然后再测试第二部分是否是有效的 &gt;=0 整数。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因此，-30.5 被认为是有效的，但 -30.-8 不是。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要在此脚本中包含另一个 shell 脚本作为一部分，可以使用 <span class="string">&quot;.&quot;</span> 来源符号。非常简单。</span></span><br><span class="line"></span><br><span class="line">. validint   # Bourne shell 的方式，引入 validint 函数</span><br><span class="line"></span><br><span class="line">validfloat()</span><br><span class="line">&#123;</span><br><span class="line">  fvalue=&quot;$1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">检查输入的数字是否有小数点。</span></span><br><span class="line">  if [ ! -z $(echo $fvalue | sed &#x27;s/[^.]//g&#x27;) ] ; then</span><br><span class="line"></span><br><span class="line">    # 提取小数点前的部分（比如 &#x27;3.14&#x27; 中的 &#x27;3&#x27;）。</span><br><span class="line">    decimalPart=&quot;$(echo $fvalue | cut -d. -f1)&quot;</span><br><span class="line"></span><br><span class="line">    # 提取小数点后的数字部分（比如 &#x27;3.14&#x27; 中的 &#x27;14&#x27;）。</span><br><span class="line">    fractionalPart=&quot;$&#123;fvalue#*\.&#125;&quot;</span><br><span class="line"></span><br><span class="line">    # 首先测试小数部分，即小数点左边的部分。</span><br><span class="line"></span><br><span class="line">    if [ ! -z $decimalPart ] ; then</span><br><span class="line">      # &quot;!&quot; 反转了测试逻辑，所以下面的条件表示 &quot;如果不是有效的整数&quot;</span><br><span class="line">      if ! validint &quot;$decimalPart&quot; &quot;&quot; &quot;&quot; ; then</span><br><span class="line">        return 1</span><br><span class="line">      fi </span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 现在测试小数部分（小数点右边的值）。</span><br><span class="line">    # 首先，小数点后面不能有负号，比如 33.-11，所以我们要检查小数部分是否包含负号。</span><br><span class="line">    if [ &quot;$&#123;fractionalPart%$&#123;fractionalPart#?&#125;&#125;&quot; = &quot;-&quot; ] ; then</span><br><span class="line">      echo &quot;无效的浮点数：小数点后面不允许有负号&quot; &gt;&amp;2  # &gt;&amp;2 将输出发送到 stderr。</span><br><span class="line">      return 1</span><br><span class="line">    fi </span><br><span class="line">    if [ &quot;$fractionalPart&quot; != &quot;&quot; ] ; then </span><br><span class="line">      # 如果小数部分不是有效的整数...</span><br><span class="line">      if ! validint &quot;$fractionalPart&quot; &quot;0&quot; &quot;&quot; ; then</span><br><span class="line">        return 1</span><br><span class="line">      fi</span><br><span class="line">    fi</span><br><span class="line">  else </span><br><span class="line">    # 如果整个值只是 &quot;-&quot;，也是不允许的。</span><br><span class="line">    if [ &quot;$fvalue&quot; = &quot;-&quot; ] ; then</span><br><span class="line">      echo &quot;无效的浮点格式。&quot; &gt;&amp;2 ; return 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 最后，检查剩余的数字是否是有效的整数。</span><br><span class="line">    if ! validint &quot;$fvalue&quot; &quot;&quot; &quot;&quot; ; then</span><br><span class="line">      return 1</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if validfloat $1 ; then</span><br><span class="line">  echo &quot;$1 是一个有效的浮点数&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2023/12/18/08_shell%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1%20shell%E7%BC%96%E7%A8%8B/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/12/23/07_%E5%B0%8F%E6%8A%80%E5%B7%A7/4%20VScode%E5%AD%A6%E4%B9%A0/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            VScode学习
          
        </div>
      </a>
    
    
      <a href="/2023/12/10/07_%E5%B0%8F%E6%8A%80%E5%B7%A7/3%20tabby%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">tabby的使用</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2024
        <i class="ri-heart-fill heart_icon"></i> chai
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="热爱学习的未来酱"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E7%94%9F%E6%B4%BB">生活</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E7%91%9E%E8%8A%AF%E5%BE%AE">瑞芯微</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/Linux%E5%AD%A6%E4%B9%A0">Linux学习</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E8%AF%BB%E4%B9%A6">读书</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0">驱动学习</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/C%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E5%AD%A6%E4%B9%A0">C语言高级学习</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7">小技巧</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/shell%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0">shell编程学习</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/PCB%E5%AD%A6%E4%B9%A0">PCB学习</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0">音视频学习</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=0&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>