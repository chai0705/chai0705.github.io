<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="永远年轻，永远热泪盈眶" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>rk3568 驱动开发第三篇 并发与竞争 |  热爱学习的未来酱</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="热爱学习的未来酱" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-rk3568-驱动开发第三篇-并发与竞争"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  rk3568 驱动开发第三篇 并发与竞争
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%89%E7%AF%87-%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/" class="article-date">
  <time datetime="2023-09-04T12:55:28.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">19k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">78 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第19章-并发与竞争实验"><a href="#第19章-并发与竞争实验" class="headerlink" title="第19章 并发与竞争实验"></a>第19章 并发与竞争实验</h1><p>在前面章节的学习中，相信大家已经对用户空间与内核空间数据传递进行了实验，假如要传递的数据被存放在了全局变量，该数据就可以作为共享资源被多个任务共同读写，从而造成数据的错误传输，多个程序同时访问一个共享资源产生的问题就叫做竞争。竞争产生的根本原因就是Linux系统的并发访问。</p>
<p>在本章节中首先会对并发与并行的概念进行讲解，随后对竞争产生的原因进行总结，最后以一个实际的竞争实验加深大家的理解。下面就让我们开始本章节的学习吧。</p>
<h2 id="19-1-并发与竞争"><a href="#19-1-并发与竞争" class="headerlink" title="19.1 并发与竞争"></a>19.1 并发与竞争</h2><h3 id="19-1-1并发"><a href="#19-1-1并发" class="headerlink" title="19.1.1并发"></a>19.1.1并发</h3><p>早期计算机大多只有一个CPU核心，一个CPU在同一时间只能执行一个任务，当系统中有多个任务等待执行时，CPU只能执行完一个再执行下一个。而计算机的很多指令会涉及I&#x2F;O操作，执行速度远远低于CPU内高速存储器的存取速度，这就导致CPU经常处于空闲状态，只能等待I&#x2F;O操作完成后才能继续执行后面的指令。为了提高CPU利用率，减少等待时间，提出了CPU并发工作理论。</p>
<p>所谓并发，就是通过算法将CPU资源合理地分配给多个任务，当一个任务执行 I&#x2F;O 操作时，CPU可以转而执行其它的任务，等到 I&#x2F;O 操作完成以后，或者新的任务遇到 I&#x2F;O 操作时，CPU再回到原来的任务继续执行。</p>
<p>下图（图19-1）展示了两个任务并发执行的过程（为了容易理解，这里以两个任务并发执行为例，当然一个CPU核心并不仅仅只能两个任务并发）：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps109.jpg" alt="img"> </p>
<p>图 19-1</p>
<p>虽然CPU在同一时刻只能执行一个任务，但是通过将CPU的使用权在恰当的时机分配给不同的任务，使得多个任务看起来是一起执行的（CPU的执行速度极快，多任务切换的时间也极短）。</p>
<p>至此关于并发的概念就讲解完成了。</p>
<h3 id="19-1-2并行"><a href="#19-1-2并行" class="headerlink" title="19.1.2并行"></a>19.1.2并行</h3><p>并发是针对单核CPU提出的，而并行则是针对多核CPU提出的。和单核CPU不同，多核CPU真正实现了“同时执行多个任务”。多核CPU的每个核心都可以独立地执行一个任务，而且多个核心之间不会相互干扰。在不同核心上执行的多个任务，是真正地同时运行，这种状态就叫做并行。双核CPU的工作状态如下图（图19-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps110.jpg" alt="img"> </p>
<p>图 19-2</p>
<p>双核CPU执行两个任务时，每个核心各自执行一个任务，和单核CPU在两个任务之间不断切换相比，它的执行效率更高。</p>
<p>至此对于并行的概念就讲解完成了。</p>
<h3 id="19-1-3并发-并行"><a href="#19-1-3并发-并行" class="headerlink" title="19.1.3并发+并行"></a>19.1.3并发+并行</h3><p>在并行的工作状态中，两个CPU分别执行两个任务，是一种理想状态。但是在实际场景中，处于运行状态的任务是非常多的，以实际办公电脑为例，windows系统在开机之后会运行几十个任务，而CPU往往只有4核、8核等，远远低于任务的数量，这个时候就会同时存在并发和并行两种情况，即所有核心在并行工作的同时，每个核心还要并发工作。</p>
<p>例如一个双核 CPU 要执行四个任务，它的工作状态如下图（图19-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps111.jpg" alt="img"> </p>
<p>图 19-3</p>
<p>为了容易理解，这里是以两个任务并发执行为例，当然一个CPU核心并不仅仅只能两个任务并发，并发任务的数量和操作系统的分配方式、以及每个任务的工作状态有关系。</p>
<p>至此，对于并发+并行的概念讲解就结束了。</p>
<p>并发可以看作是并行的理想状态，为了便于讲解和避免产生歧义，之后的章节无论是并发还是并行，都会统称为并发。</p>
<h3 id="19-1-4-竞争"><a href="#19-1-4-竞争" class="headerlink" title="19.1.4 竞争"></a>19.1.4 竞争</h3><p>并发可能会造成多个程序同时访问一个共享资源，这时候由并发同时访问一个共享资源产生的问题就叫做竞争。</p>
<p>竞争产生的原因如下所示：</p>
<p>（1）多线程的并发访问。由于Linux 是多任务操作系统，所以多线程访问是竞争产生的基本原因。</p>
<p>（2）中断程序的并发访问。中断任务产生后，CPU会立刻停止当前工作，从而去执行中断中的任务，如果中断任务对共享资源进行了修改，就会产生竞争。</p>
<p>（3）抢占式并发访问。linux2.6及更高版本引入了抢占式内核，高优先级的任务可以打断低优先级的任务。在线程访问共享资源的时候，另一个线程打断了现在正在访问共享资源的线程同时也对共享资源进行操作，从而造成了竞争。</p>
<p>（4）多处理器(SMP）并发访问。多核处理器之间存在核间并发访问。</p>
<h3 id="19-1-5-共享资源的保护"><a href="#19-1-5-共享资源的保护" class="headerlink" title="19.1.5 共享资源的保护"></a>19.1.5 共享资源的保护</h3><p>竞争是由并发访问同一个共享资源产生的。为了防止“竞争”的产生就要对共享资源进行保护，这里提到的共享资源又是什么呢？</p>
<p>以实际生活中的共享资源为例，可以是公共电话，也可以是共享单车、共享充电宝等公共物品，以上都属于共享资源的范畴，以公共电话为例，每个人都可以对它进行使用，但在同一时间内只能由一个人进行使用，如果两个人都要对电话进行使用，则产生了竞争。而在实际的驱动的代码中，共享资源可以是全局变量，也可以是驱动中的设备结构体等，需要根据具体的驱动程序来进行分析。在下一小节的实验中，会以全局变量为例，进行并发与竞争实验。</p>
<h2 id="19-2-实验程序的编写"><a href="#19-2-实验程序的编写" class="headerlink" title="19.2 实验程序的编写"></a>19.2 实验程序的编写</h2><h3 id="19-2-1-驱动程序编写"><a href="#19-2-1-驱动程序编写" class="headerlink" title="19.2.1 驱动程序编写"></a>19.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\14\module。</p>
<p>本实验将编写并发与竞争的驱动代码，首先完善字符设备驱动框架，然后通过copy_from_user(…)函数接收用户空间传递到内核空间的数据并进行判断，如果接收到的字符串数据为“topeet”会在睡眠4秒钟后打印接收到的数据，如果接收到的字符串数据为“itop”会在睡眠2秒钟后打印接收到的数据。</p>
<p>编写完成的example.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;\nthis is open_test \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//printk(&quot;\nthis is release_test \n&quot;);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对于重要逻辑部分已经加粗，后续章节的实验都是对上述并发与竞争实验的改进，以不同的方式来避免竞争的产生。</p>
<h3 id="19-2-2-编写测试-APP"><a href="#19-2-2-编写测试-APP" class="headerlink" title="19.2.2 编写测试 APP"></a>19.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\14\app。</p>
<p>本测试app较为简单，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="19-3-运行测试"><a href="#19-3-运行测试" class="headerlink" title="19.3 运行测试"></a>19.3 运行测试</h2><h3 id="19-3-1-编译驱动程序"><a href="#19-3-1-编译驱动程序" class="headerlink" title="19.3.1 编译驱动程序"></a>19.3.1 编译驱动程序</h3><p>在上一小节中的example.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += example.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放example.c和Makefile文件目录下，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps112.jpg" alt="img"> </p>
<p>图 19-4</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图19-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps113.jpg" alt="img"> </p>
<p>图 19-5</p>
<p>编译完生成example.ko目标文件，如下图（图19-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps114.jpg" alt="img"> </p>
<p>图 19-6</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h3 id="19-3-2-编译应用程序"><a href="#19-3-2-编译应用程序" class="headerlink" title="19.3.2 编译应用程序"></a>19.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图19-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps115.jpg" alt="img"> </p>
<p>图 19-7</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图19-8）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps116.jpg" alt="img"> </p>
<p>图 19-8</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="19-3-3-运行测试"><a href="#19-3-3-运行测试" class="headerlink" title="19.3.3 运行测试"></a>19.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图19-9）所示：</p>
<p>insmod example.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps117.jpg" alt="img"> </p>
<p>图 19-9</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图19-10）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps118.jpg" alt="img"> </p>
<p>图 19-10</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图19-11）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps119.jpg" alt="img"> </p>
<p>图 19-11</p>
<p>可以看到传递的buf值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图19-12）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet &amp;</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test itop &amp;</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps120.jpg" alt="img"> </p>
<p>图 19-12</p>
<p>在不存在竞争的情况下，传递的两个字符串数据应该是topeet和itop，而在上图中的打印信息为两个itop，原因是第二个app应用程序运行之后对共享资源进行了修改，两个app应用程序就产生了竞争关系，会在之后的章节中使用不同的方法对上述驱动程序进行改进，从而避免竞争的产生。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图19-13）所示：</p>
<p>rmmod  example.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps121.jpg" alt="img"> </p>
<p>图 19-13</p>
<p>至此，并发与竞争的实验就完成了。</p>
<h1 id="第20章-原子操作实验"><a href="#第20章-原子操作实验" class="headerlink" title="第20章 原子操作实验"></a>第20章 原子操作实验</h1><p>在上一章节的实验中，对并发与竞争进行了实验，两个app应用程序之间对共享资源的竞争访问引起了数据传输错误，而在Linux内核中，提供了四种处理并发与竞争的常见方法，分别是原子操作、自旋锁、信号量、互斥体，在之后的几个章节中会依次对上述四种方法进行讲解。</p>
<p>本章首先对四种常见方法中的原子操作进行讲解。</p>
<h2 id="20-1-原子操作"><a href="#20-1-原子操作" class="headerlink" title="20.1 原子操作"></a>20.1 原子操作</h2><p>“原子”是化学世界中不可再分的最小微粒，一切物质都由原子组成。在Linux内核中的原子操作可以理解为“不可被拆分的操作”，就是不能被更高等级中断抢夺优先的操作。在C语言中可以使用以下代码对一个整形变量赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> v;<span class="comment">//定义一个int类型的变量v</span></span><br><span class="line">v = <span class="number">1</span>;<span class="comment">//将int类型的变量v赋值为1</span></span><br></pre></td></tr></table></figure>

<p>而上述代码仍然不是“不可拆分的操作”，C语言程序仍然需要翻译成汇编指令，在汇编指令的执行过程中仍可能会有竞争的产生。而原子操作会将整形变量的操作当成一个整体，不可再进行分割。而原子操作又可以进一步细分为“整型原子操作”和“位原子操作”，这里首先对****整型原子操作****进行讲解。</p>
<p>在Linux内核中使用 atomic_t和atomic64_t结构体分别来完成32位系统和64位系统的整形数据原子操作，两个结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;types.h”文件中，具体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     <span class="type">int</span> counter;</span><br><span class="line"> &#125; <span class="type">atomic_t</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     <span class="type">long</span> counter;</span><br><span class="line">&#125; <span class="type">atomic64_t</span>;</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>例如可以使用以下代码定义一个64位系统的原子整形变量：</p>
<p>atomic64_t v;</p>
<p>在成功定义原子变量之后，必然要对原子变量进行读取、加减等动作，原子操作的部分常用API函数如下所示，定义在“内核源码&#x2F;include&#x2F;linux&#x2F;atomic.h”文件中，所以在接下来的实验中需要加入该头文件的引用。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ATOMIC_INIT(int i)</td>
<td>定义原子变量的时候对其初始化，赋值为i</td>
</tr>
<tr>
<td>int atomic_read(atomic_t *v)</td>
<td>读取v的值，并且返回。</td>
</tr>
<tr>
<td>void atomic_set(atomic_t *v, int i)</td>
<td>向原子变量v写入i值。</td>
</tr>
<tr>
<td>void atomic_add(int i, atomic_t *v)</td>
<td>原子变量v加上i值。</td>
</tr>
<tr>
<td>void atomic_sub(int i, atomic_t *v)</td>
<td>原子变量v减去i值。</td>
</tr>
<tr>
<td>void atomic_inc(atomic_t *v)</td>
<td>原子变量v加1</td>
</tr>
<tr>
<td>void atomic_dec(atomic_t *v)</td>
<td>原子变量v减1</td>
</tr>
<tr>
<td>int atomic_dec_return(atomic_t *v)</td>
<td>原子变量v减1，并返回v的值。</td>
</tr>
<tr>
<td>int atomic_inc_return(atomic_t *v)</td>
<td>原子变量v加 1，并返回v的值。</td>
</tr>
<tr>
<td>int atomic_sub_and_test(int i, atomic_t *v)</td>
<td>原子变量v减 i，如果结果为0就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_dec_and_test(atomic_t *v)</td>
<td>原子变量v减 1，如果结果为0就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_inc_and_test(atomic_t *v)</td>
<td>原子变量v加 1，如果结果为0就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_add_negative(int i, atomic_t *v)</td>
<td>原子变量v加 i，如果结果为负就返回真，否则返回假</td>
</tr>
</tbody></table>
<p>图表20- 1</p>
<p>至此，对于整型原子操作的相关API函数就讲解完成了，会在下一小节中使用上述原子整形操作API进行相应的实验。</p>
<p>下面对原子位操作进行讲解，和原子整形变量不同，原子位操作没有 atomic_t 的数据结构，原子位操作是直接对内存进行操作，原子位操作相关API函数如下（图表20-2）所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void set_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位置 1。</td>
</tr>
<tr>
<td>void clear_bit(int nr,void *p)</td>
<td>将 p 地址的第 nr 位清零。</td>
</tr>
<tr>
<td>void change_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位进行翻转。</td>
</tr>
<tr>
<td>int test_bit(int nr, void *p)</td>
<td>获取 p 地址的第 nr 位的值。</td>
</tr>
<tr>
<td>int test_and_set_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位置 1，并且返回 nr 位原来的值。</td>
</tr>
<tr>
<td>int test_and_clear_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位清零，并且返回 nr 位原来的值。</td>
</tr>
<tr>
<td>int test_and_change_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位翻转，并且返回 nr 位原来的值。</td>
</tr>
</tbody></table>
<p>图表20- 2</p>
<p>对于原子位操作的知识就不再深入讲解和实验，感兴趣的同学可以到相关网站上进行自主学习。</p>
<p>在下一小节中，将会使用原子整形操作对19章的并发与竞争实验进行改进。</p>
<h2 id="20-2-实验程序的编写"><a href="#20-2-实验程序的编写" class="headerlink" title="20.2 实验程序的编写"></a>20.2 实验程序的编写</h2><h3 id="20-2-1-驱动程序编写"><a href="#20-2-1-驱动程序编写" class="headerlink" title="20.2.1 驱动程序编写"></a>20.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\15\module。</p>
<p>为了解决第19章实验中并发与竞争的问题，本章节实验将加入原子整形操作相关实验代码，在open()函数和release()函数中加入原子整形变量v的赋值代码，并且在open()函数中加入原子整形变量v的判断代码，从而实现同一时间内只允许一个应用打开该设备节点，以此来防止共享资源竞争的产生。</p>
<p>编写完成的atomic.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">atomic64_t</span> v = ATOMIC_INIT(<span class="number">1</span>);<span class="comment">//初始化原子类型变量v,并设置为1</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(atomic64_read(&amp;v) != <span class="number">1</span>)&#123;<span class="comment">//读取原子类型变量v的值并判断是否等于1</span></span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line">	atomic64_set(&amp;v,<span class="number">0</span>);<span class="comment">//将原子类型变量v的值设置为0</span></span><br><span class="line">	<span class="comment">//printk(&quot;\nthis is open_test \n&quot;);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//printk(&quot;\nthis is release_test \n&quot;);</span></span><br><span class="line">	atomic64_set(&amp;v,<span class="number">1</span>);<span class="comment">//将原子类型变量v的值赋1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">	dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="20-2-2-编写测试-APP"><a href="#20-2-2-编写测试-APP" class="headerlink" title="20.2.2 编写测试 APP"></a>20.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\15\app。</p>
<p>本测试app代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-3-运行测试"><a href="#20-3-运行测试" class="headerlink" title="20.3 运行测试"></a>20.3 运行测试</h2><h3 id="20-3-1-编译驱动程序"><a href="#20-3-1-编译驱动程序" class="headerlink" title="20.3.1 编译驱动程序"></a>20.3.1 编译驱动程序</h3><p>在上一小节中的atomic.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += atomic.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放atomic.c和Makefile文件目录下，如下图（图20-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps122.jpg" alt="img"> </p>
<p>图 20-4</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图20-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps123.jpg" alt="img"> </p>
<p>图 20-5</p>
<p>编译完生成atomic.ko目标文件，如下图（图20-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps124.jpg" alt="img"> </p>
<p>图 20-6</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h3 id="20-3-2-编译应用程序"><a href="#20-3-2-编译应用程序" class="headerlink" title="20.3.2 编译应用程序"></a>20.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图20-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps125.jpg" alt="img"> </p>
<p>图 20-7</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图20-8）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps126.jpg" alt="img"> </p>
<p>图 20-8</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="20-3-3-运行测试"><a href="#20-3-3-运行测试" class="headerlink" title="20.3.3 运行测试"></a>20.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图20-9）所示：</p>
<p>insmod atomic.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps127.jpg" alt="img"> </p>
<p>图 20-9</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图20-10）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps128.jpg" alt="img"> </p>
<p>图 20-10</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图20-11）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps129.jpg" alt="img"> </p>
<p>图 20-11</p>
<p>可以看到传递的buf值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图20-12）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet &amp;</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test itop </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps130.jpg" alt="img"> </p>
<p>图 20-12</p>
<p>​	可以看到应用程序在打开第二次&#x2F;dev&#x2F;device_test 文件的时候，出现了“file open failed”打印，证明文件打开失败，只有在第一个应用关闭相应的文件之后，下一个应用才能打开，通过限制同一时间内设备访问数量，来对共享资源进行保护。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图20-13）所示：</p>
<p>rmmod flag.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps131.jpg" alt="img"> </p>
<p>图 20-13</p>
<p>至此，原子操作实验就完成了。</p>
<h1 id="第21章-自旋锁实验"><a href="#第21章-自旋锁实验" class="headerlink" title="第21章 自旋锁实验"></a>第21章 自旋锁实验</h1><p>在上一节中对原子操作进行了讲解，并使用原子整形操作对并发与竞争实验进行了改进，但是原子操作只能对整形变量或者位进行保护，而对于结构体或者其他类型的共享资源，原子操作就力不从心了，这时候就轮到自旋锁的出场了，下面就让我们一起来进行自旋锁的学习吧。</p>
<h2 id="21-1-自旋锁"><a href="#21-1-自旋锁" class="headerlink" title="21.1 自旋锁"></a>21.1 自旋锁</h2><p>自旋锁是为了保护共享资源提出的一种锁机制。自旋锁（spin lock）是一种非阻塞锁，也就是说，如果某线程需要获取锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取锁。</p>
<p>在有些场景中，同步资源(用来保持一致性的两个或多个资源)的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果计算机有多个CPU核心，能够让两个或以上的线程同时并行执行，这样我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，直到持有锁的线程释放锁，后面请求锁的线程才可以获取锁。</p>
<p>为了让后面那个请求锁的线程“稍等一下”，我们需让它进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么该线程便不必阻塞，并且直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。我们再举个形象生动的例子，以现实生活中银行ATM机办理业务为例，ATM机防护舱在同一时间内只允许一个人进入，当有人进入ATM机防护舱之后，两秒钟之后自动上锁，其他也想要存取款的人员，只能在外部等待，办理完相应的存取款业务之后，舱内人员需要手动打开防护锁，其他人才能进入其中，办理业务。而自旋锁在驱动中的使用和上述ATM机办理业务流程相同，当一个任务要访问某个共享资源之前需要先获取相应的自旋锁，自旋锁只能被一个任务持有，在该任务持有自旋锁的过程中，其他任务只能原地等待该自旋锁的释放，在等待过程中的任务同样会持续占用CPU，消耗CPU资源，所以临界区的代码不能太多。</p>
<p>如果自旋锁被错误使用可能会导致死锁的产生，对于自旋锁死锁会在下一章节进行详细说明，并进行相应的实验。</p>
<p>内核中以spinlock_t结构体来表示自旋锁，定义在“内核源码&#x2F;include&#x2F;linux&#x2F;spinlock_types.h”文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            u8 __padding[LOCK_PADSIZE];</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     &#125;;</span><br><span class="line">&#125; <span class="type">spinlock_t</span>;</span><br></pre></td></tr></table></figure>

<p>自旋锁相关API函数定义在“内核源码&#x2F;include&#x2F;linux&#x2F;spinlock.h”文件中，所以在本章节的实验中要加入该头文件（spinlock.h头文件包含spinlock_types.h等，所以只需加入spinlock.h头文件即可），部分API函数如下（表 21-1）所示，</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_SPINLOCK(spinlock_t lock)</td>
<td>定义并初始化自旋锁。</td>
</tr>
<tr>
<td>int spin_lock_init(spinlock_t *lock)</td>
<td>初始化自旋锁。</td>
</tr>
<tr>
<td>void spin_lock(spinlock_t *lock)</td>
<td>获取指定的自旋锁，也叫做加锁。</td>
</tr>
<tr>
<td>void spin_unlock(spinlock_t *lock)</td>
<td>释放指定的自旋锁。</td>
</tr>
<tr>
<td>int spin_trylock(spinlock_t *lock)</td>
<td>尝试获取指定的自旋锁，如果没有获取到就返回 0</td>
</tr>
<tr>
<td>int spin_is_locked(spinlock_t *lock)</td>
<td>检查指定的自旋锁是否被获取，如果没有被获取就返回非0，否则返回 0。</td>
</tr>
</tbody></table>
<p>表 21-1</p>
<p>除了上述API之外还有其他与终端相关的自旋锁API函数，会在接下来的自旋锁死锁章节进行讲解。</p>
<p>自旋锁的使用步骤：</p>
<p>1 在访问临界资源的时候先申请自旋锁</p>
<p>2 获取到自旋锁之后就进入临界区，获取不到自旋锁就“原地等待”。</p>
<p>3 退出临界区的时候要释放自旋锁。</p>
<p>在下一小节中将使用上述自旋锁API进行相应的实验，利用自旋锁相关知识来对第19章节的并发与竞争实验进行优化。</p>
<h2 id="21-2-实验程序的编写"><a href="#21-2-实验程序的编写" class="headerlink" title="21.2 实验程序的编写"></a>21.2 实验程序的编写</h2><h3 id="21-2-1-驱动程序编写"><a href="#21-2-1-驱动程序编写" class="headerlink" title="21.2.1 驱动程序编写"></a>21.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\16\module。</p>
<p>与上一章节使用原子整形操作避免并发与竞争逻辑相同，在驱动入口函数初始化自旋锁，然后在open函数中使用自旋锁实现对设备的互斥访问，最后在 release 函数中解锁，表示设备被释放了，可以被其他的应用程序使用。上述操作都将共享资源由自旋锁进行保护，从而实现同一时间内只允许一个应用打开该设备节点，以此来防止共享资源竞争的产生。</p>
<p>编写完成的spinlock.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">spinlock_t</span> spinlock_test;<span class="comment">//定义spinlock_t类型的自旋锁变量spinlock_test</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> flag = <span class="number">1</span>;<span class="comment">//定义flag标准为，flag等于1表示设备没有被打开，等于0则证明设备已经被打开了</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//printk(&quot;\nthis is open_test \n&quot;);</span></span><br><span class="line">	spin_lock(&amp;spinlock_test);<span class="comment">//自旋锁加锁</span></span><br><span class="line">	<span class="keyword">if</span>(flag != <span class="number">1</span>)&#123;<span class="comment">//判断标志位flag的值是否等于1</span></span><br><span class="line">spin_unlock(&amp;spinlock_test);<span class="comment">//自旋锁解锁</span></span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line">	 &#125;</span><br><span class="line">	flag = <span class="number">0</span>;<span class="comment">//将标志位的值设置为0</span></span><br><span class="line">	spin_unlock(&amp;spinlock_test);<span class="comment">//自旋锁解锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;\nthis is release_test \n&quot;</span>);</span><br><span class="line">	spin_lock(&amp;spinlock_test);<span class="comment">//自旋锁加锁</span></span><br><span class="line">	flag = <span class="number">1</span>;</span><br><span class="line">	spin_unlock(&amp;spinlock_test);<span class="comment">//自旋锁解锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	spin_lock_init(&amp;spinlock_test);</span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">	dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="21-2-2-编写测试-APP"><a href="#21-2-2-编写测试-APP" class="headerlink" title="21.2.2 编写测试 APP"></a>21.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\16\app。</p>
<p>本测试app代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="21-3-运行测试"><a href="#21-3-运行测试" class="headerlink" title="21.3 运行测试"></a>21.3 运行测试</h2><h3 id="21-3-1-编译驱动程序"><a href="#21-3-1-编译驱动程序" class="headerlink" title="21.3.1 编译驱动程序"></a>21.3.1 编译驱动程序</h3><p>在上一小节中的spinlock.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += spinlock.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放spinlock.c和Makefile文件目录下，如下图（图21-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps132.jpg" alt="img"> </p>
<p>图 21-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图21-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps133.jpg" alt="img"> </p>
<p>图 21-3</p>
<p>编译完生成spinlock.ko目标文件，如下图（图21-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps134.jpg" alt="img"> </p>
<p>图 21-4</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h3 id="21-3-2-编译应用程序"><a href="#21-3-2-编译应用程序" class="headerlink" title="21.3.2 编译应用程序"></a>21.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图21-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps135.jpg" alt="img"> </p>
<p>图 21-5</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图21-6）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps136.jpg" alt="img"> </p>
<p>图 21-6</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="21-3-3-运行测试"><a href="#21-3-3-运行测试" class="headerlink" title="21.3.3 运行测试"></a>21.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图21-7）所示：</p>
<p>insmod spinlock.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps137.jpg" alt="img"> </p>
<p>图21-7</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（21-8）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps138.jpg" alt="img"> </p>
<p>图 21-8</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图21-9）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps139.jpg" alt="img"> </p>
<p>图 21-9</p>
<p>可以看到传递的buf值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图21-10）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet &amp;</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test itop </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps140.jpg" alt="img"> </p>
<p>图 21-10</p>
<p>​	可以看到应用程序在打开第二次&#x2F;dev&#x2F;device_test 文件的时候，出现了“file open failed”打印，证明文件打开失败，只有在第一个应用关闭相应的文件之后，下一个应用才能打开。本次实验的自旋锁只是对标志位flag进行保护，flag用来表示设备的状态，确保同一时间内，该设备只能被一个应用程序打开。进而对共享资源进行保护。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图21-11）所示：</p>
<p>rmmod spinlock.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps141.jpg" alt="img"> </p>
<p>图 21-11</p>
<p>至此，自旋锁实验就完成了。</p>
<h1 id="第22章-自旋锁死锁实验"><a href="#第22章-自旋锁死锁实验" class="headerlink" title="第22章 自旋锁死锁实验"></a>第22章 自旋锁死锁实验</h1><p>在上一小节中，学习了内核中自旋锁的使用，而自旋锁若是使用不当就会产生死锁，在本章将会对自旋锁的特殊情况-死锁进行讲解。</p>
<h2 id="22-1-自旋锁死锁"><a href="#22-1-自旋锁死锁" class="headerlink" title="22.1 自旋锁死锁"></a>22.1 自旋锁死锁</h2><p>死锁是指两个或多个事物在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。当多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进，这种情况就是死锁。</p>
<p>自旋锁死锁发生存在两种情况：</p>
<p>（1）第一种情况是拥有自旋锁的进程A在内核态阻塞了，内核调度B进程，碰巧B进程也要获得自旋锁，此时B只能自旋转。而此时抢占已经关闭(在单核条件下)不会调度A进程了，B永远自旋，产生死锁，如下图（图 22-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps142.jpg" alt="img"> </p>
<p>图 22-1</p>
<p>相应的解决办法是，在自旋锁的使用过程中要尽可能短的时间内拥有自旋锁，而且不能在临界区中调用导致线程休眠的函数。</p>
<p>第二种情况是进程A拥有自旋锁，中断到来，CPU执行中断函数，中断处理函数，中断处理函数需要获得自旋锁，访问共享资源，此时无法获得锁，只能自旋，从而产生死锁，如下图（图22-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps143.jpg" alt="img"> </p>
<p>图 22-2</p>
<p>对于中断引发的死锁，最好的解决方法就是在获取锁之前关闭本地中断，Linux内核在“&#x2F;include&#x2F;linux&#x2F;spinlock.h”文件中提供了相应的API 函数，如下（图22-3）所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void spin_lock_irq(spinlock_t *lock)</td>
<td>禁止本地中断，并获取自旋锁。</td>
</tr>
<tr>
<td>void spin_unlock_irq(spinlock_t *lock)</td>
<td>激活本地中断，并释放自旋锁。</td>
</tr>
<tr>
<td>void spin_lock_irqsave(spinlock_t *lock, unsigned long flags)</td>
<td>恢复中断状态，关闭中断并获取自旋锁。</td>
</tr>
<tr>
<td>void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)</td>
<td>将中断状态恢复到以前的状态，打开中断并释放自旋锁</td>
</tr>
<tr>
<td>void spin_lock_bh(spinlock_t *lock)</td>
<td>关闭下半部，获取自旋锁</td>
</tr>
<tr>
<td>void spin_unlock_bh(spinlock_t *lock)</td>
<td>打开下半部，获取自旋锁</td>
</tr>
</tbody></table>
<p>表 22-3</p>
<p>由于Linux内核运行是非常复杂的，很难确定某个时刻的中断状态，因此建议使用 spin_lock_irqsave&#x2F;spin_unlock_irqrestore，因为这一组函数会保存中断状态，在释放锁的时候会恢复中断状态。</p>
<p>在下一小节中将进行自旋锁死锁实验，本次实验所采取的是第一种情况，即拥有自旋锁的进程A在内核态阻塞了，内核调度B进程，碰巧B进程也要获得自旋锁，依次产生死锁。</p>
<h2 id="22-2-实验程序的编写"><a href="#22-2-实验程序的编写" class="headerlink" title="22.2 实验程序的编写"></a>22.2 实验程序的编写</h2><h3 id="22-2-1-驱动程序编写"><a href="#22-2-1-驱动程序编写" class="headerlink" title="22.2.1 驱动程序编写"></a>22.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\17\module。</p>
<p>本章节实验以19章并发与竞争实验为基础，在open()函数中加入了自旋锁加锁，在close()函数中加入了自旋锁解锁，由于在write()函数中存在sleep()睡眠函数，所以会造成内核阻塞，睡眠期间如果使用另一个进程获取该自旋锁，就会造成死锁。</p>
<p>编写完成的dielock.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">spinlock_t</span> spinlock_test;<span class="comment">//定义spinlock_t类型的自旋锁变量spinlock_test</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//printk(&quot;\nthis is open_test \n&quot;);</span></span><br><span class="line">	spin_lock(&amp;spinlock_test);<span class="comment">//自旋锁加锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;\nthis is release_test \n&quot;</span>);</span><br><span class="line">	spin_unlock(&amp;spinlock_test);<span class="comment">//自旋锁解锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	spin_lock_init(&amp;spinlock_test);</span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">	dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="22-2-2-编写测试-APP"><a href="#22-2-2-编写测试-APP" class="headerlink" title="22.2.2 编写测试 APP"></a>22.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\17\app。</p>
<p>本测试app代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于本次测试的CPU为多核心CPU，其他核心仍旧可以调度其他进程，所以需要多次使用taskset函数指定CPU进行进程的运行，以此来产生死锁，在与app.c同级目录下创建名为app.sh的脚本文件，脚本内容如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">taskset -c 0 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 1 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 2 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 3 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 0 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 1 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 2 ./app /dev/device_test topeet &amp;</span><br><span class="line">taskset -c 3 ./app /dev/device_test topeet &amp;</span><br></pre></td></tr></table></figure>

<p>保存退出之后，需要使用以下命令赋予脚本可执行权限，如下图（图22-4）所示：</p>
<p>chmod 777 app.sh</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps144.jpg" alt="img"> </p>
<p>图 22-4</p>
<p>至此测试程序app.c和运行脚本app.sh就编写完成了。</p>
<h2 id="22-3-运行测试"><a href="#22-3-运行测试" class="headerlink" title="22.3 运行测试"></a>22.3 运行测试</h2><h3 id="22-3-1-编译驱动程序"><a href="#22-3-1-编译驱动程序" class="headerlink" title="22.3.1 编译驱动程序"></a>22.3.1 编译驱动程序</h3><p>在上一小节中的dielock.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += dielock.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放dielock.c和Makefile文件目录下，如下图（图22-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps145.jpg" alt="img"> </p>
<p>图 22-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图22-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps146.jpg" alt="img"> </p>
<p>图 22-6</p>
<p>编译完生成dielock.ko目标文件，如下图（图22-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps147.jpg" alt="img"> </p>
<p>图 22-7</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h3 id="22-3-2-编译应用程序"><a href="#22-3-2-编译应用程序" class="headerlink" title="22.3.2 编译应用程序"></a>22.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图22-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps148.jpg" alt="img"> </p>
<p>图 22-8</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图22-9）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps149.jpg" alt="img"> </p>
<p>图 22-9</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="22-3-3-运行测试"><a href="#22-3-3-运行测试" class="headerlink" title="22.3.3 运行测试"></a>22.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图22-10）所示：</p>
<p>insmod dielock.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps150.jpg" alt="img"> </p>
<p>图 22-10</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图22-11）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps151.jpg" alt="img"> </p>
<p>图 22-11</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行app.sh脚本，该脚本会指定CPU在加锁之后进入内核休眠状态，如下图（图22-12）所示：</p>
<p>.&#x2F;app.sh</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps152.jpg" alt="img"> </p>
<p>图 22-12</p>
<p>​	在指令输入之后，串口终端无法输入，引发了死锁，进而造成了系统崩溃，所以在编写驱动的过程中，要尽可能的避免死锁的出现。</p>
<p>至此，自旋锁死锁驱动实验就完成了。</p>
<h1 id="第23章-信号量实验"><a href="#第23章-信号量实验" class="headerlink" title="第23章 信号量实验"></a>第23章 信号量实验</h1><p>在上面两个章节对自旋锁和自旋锁死锁进行了学习，自旋锁会让请求的任务原地“自旋”，在等待的过程中会循环检测自旋锁的状态，进而占用系统资源，而本章节要讲解的信号量也是解决竞争的一种常用方法，与自旋锁不同的是，信号量会使等待的线程进入休眠状态，适用于那些占用资源比较久的场合。下面对信号量相关知识的进行讲解。</p>
<h2 id="23-1-信号量"><a href="#23-1-信号量" class="headerlink" title="23.1 信号量"></a>23.1 信号量</h2><p>信号量是操作系统中最典型的用于同步和互斥的手段，本质上是一个全局变量，信号量的值表示控制访问资源的线程数，可以根据实际情况来自行设置，如果在初始化的时候将信号量量值设置为大于1，那么这个信号量就是计数型信号量，允许多个线程同时访问共享资源。如果将信号量量值设置为1，那么这个信号量就是二值信号量，同一时间内只允许一个线程访问共享资源，注意！信号量的值不能小于0。当信号量的值为0时，想访问共享资源的线程必须等待，直到信号量大于0时，等待的线程才可以访问。当访问共享资源时，信号量执行“减一”操作，访问完成后再执行“加一”操作。</p>
<p>相比于自旋锁，信号量具有休眠特性，因此适用长时间占用资源的场合，但由于信号量会引起休眠，所以不能用在中断函数中，最后如果共享资源的持有时间比较短，使用信号量的话会造成频繁的休眠，反而带来更多资源的消耗，使用自旋锁反而效果更好。再同时使用信号量和自旋锁的时候，要先获取信号量，再使用自旋锁，因为信号量会导致睡眠。</p>
<p>以现实生活中的银行办理业务为例，银行的业务办理窗口就是共享资源，业务办理窗口的数量就是信号量量值，进入银行之后，客户需要领取相应的排序码，然后在休息区进行等待，可以看作线程的睡眠阶段，当前面的客户办理完业务之后，相应的窗口会空闲出来，可以看作信号量的释放，之后银行会通过广播，提醒下一位客户到指定的窗口进行业务的办理，可以看作线程的唤醒并获取到信号量，访问共享资源的过程。</p>
<p>Linux 内核使用semaphore结构体来表示信号量，该结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;semaphore.h”文件内（所以在下一章节的信号量实验中需要加入该头文件），结构体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="type">raw_spinlock_t</span>      lock;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 与信号量相关的 API 函数同样定义在semaphore.h文件内，部分常用API函数如下（表23-1）所示： </p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_SEAMPHORE(name)</td>
<td>定义信号量，并且设置信号量的值为 1。</td>
</tr>
<tr>
<td>void sema_init(struct semaphore *sem, int val)</td>
<td>初始化信号量 sem，设置信号量值为 val。</td>
</tr>
<tr>
<td>void down(struct semaphore *sem)</td>
<td>获取信号量，不能被中断打断，如ctrl+c</td>
</tr>
<tr>
<td>int down_interruptible(struct semaphore *sem)</td>
<td>获取信号量，可以被中断打断，如ctrl+c</td>
</tr>
<tr>
<td>void up(struct semaphore *sem)</td>
<td>释放信号量</td>
</tr>
<tr>
<td>int down_trylock(struct semaphore *sem);</td>
<td>尝试获取信号量，如果能获取到信号量就获取，并且返回 0。如果不能就返回非 0</td>
</tr>
</tbody></table>
<p>表 23-1</p>
<p>至此，关于信号量相关的知识就讲解完成了，上述API函数会在下一小节的实验中用到。</p>
<h2 id="23-2-实验程序的编写"><a href="#23-2-实验程序的编写" class="headerlink" title="23.2 实验程序的编写"></a>23.2 实验程序的编写</h2><h3 id="23-2-1-驱动程序编写"><a href="#23-2-1-驱动程序编写" class="headerlink" title="23.2.1 驱动程序编写"></a>23.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\18\module。</p>
<p>与之前章节设置标志位，在同一时间内只允许一个任务对共享资源进行访问的方式所不同，本小节将采用信号量的方式避免竞争的产生。本实验设置的信号量量值为1，所以需要在open()函数中加入信号量获取函数，在release()函数中加入信号量释放函数即可。</p>
<p>编写完成的semaphore.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">semaphore_test</span>;</span><span class="comment">//定义一个semaphore类型的结构体变量semaphore_test</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;\nthis is open_test \n&quot;</span>);</span><br><span class="line">down(&amp;semaphore_test);<span class="comment">//信号量数量减1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">up(&amp;semaphore_test);<span class="comment">//信号量数量加1</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is release_test \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	sema_init(&amp;semaphore_test,<span class="number">1</span>);<span class="comment">//初始化信号量结构体semaphore_test，并设置信号量的数量为1</span></span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">	dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="23-2-2-编写测试-APP"><a href="#23-2-2-编写测试-APP" class="headerlink" title="23.2.2 编写测试 APP"></a>23.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\18\app。</p>
<p>本测试app代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="23-3-运行测试"><a href="#23-3-运行测试" class="headerlink" title="23.3 运行测试"></a>23.3 运行测试</h2><h3 id="23-3-1-编译驱动程序"><a href="#23-3-1-编译驱动程序" class="headerlink" title="23.3.1 编译驱动程序"></a>23.3.1 编译驱动程序</h3><p>在上一小节中的semaphore.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += semaphore.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放semaphore.c和Makefile文件目录下，如下图（图23-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps153.jpg" alt="img"> </p>
<p>图 23-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图23-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps154.jpg" alt="img"> </p>
<p>图 23-3</p>
<p>编译完生成semaphore.ko目标文件，如下图（图23-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps155.jpg" alt="img"> </p>
<p>图 23-4</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的安装。</p>
<h3 id="23-3-2-编译应用程序"><a href="#23-3-2-编译应用程序" class="headerlink" title="23.3.2 编译应用程序"></a>23.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图 23-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps156.jpg" alt="img"> </p>
<p>图 23-5</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图23-6）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps157.jpg" alt="img"> </p>
<p>图23-6</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="23-3-3-运行测试"><a href="#23-3-3-运行测试" class="headerlink" title="23.3.3 运行测试"></a>23.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 23-7）所示：</p>
<p>insmod semaphore.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps158.jpg" alt="img"> </p>
<p>图 23-7</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图23-8）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps159.jpg" alt="img"> </p>
<p>图 23-8</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图23-9）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps160.jpg" alt="img"> </p>
<p>图 23-9</p>
<p>可以看到传递的buf值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图23-10）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet &amp;</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test itop </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps161.jpg" alt="img"> </p>
<p>图 23-10</p>
<p>​	上述打印信息正常，证明数据被正确传递了，没有发生共享资源的竞争，第一个任务运行之后，由于设置的信号量量值为1，所以第二个任务会进入休眠状态，第一个任务执行完毕之后，会唤醒第二个任务去执行，所以避免了并发与竞争。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图 23-11）所示：</p>
<p>rmmod semaphore.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps162.jpg" alt="img"> </p>
<p>图 23-11</p>
<p>至此，信号量实验就完成了。</p>
<h1 id="第24章-互斥锁实验"><a href="#第24章-互斥锁实验" class="headerlink" title="第24章 互斥锁实验"></a>第24章 互斥锁实验</h1><p>在上一章节中对信号量进行了学习，而本章节要学习的互斥锁可以说是“量值”为 1 的信号量，最终实现的效果相同，既然有了信号量，那为什么还要有互斥锁呢，带着疑问，让我们来进行本章节的学习吧！</p>
<h2 id="24-1-互斥锁"><a href="#24-1-互斥锁" class="headerlink" title="24.1 互斥锁"></a>24.1 互斥锁</h2><p>在上一章节中，将信号量量值设置为1，最终实现的就是互斥效果，与本章节要学习的互斥锁功能相同，虽然两者功能相同但是具体的实现方式是不同的，但是使用互斥锁效率更高、更简洁，所以如果使用到的信号量“量值”为 1，一般将其修改为使用互斥锁实现。</p>
<p>当有多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制。线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。互斥锁为资源引入一个状态：锁定或者非锁定。某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性，能够保证多个线程访问共享数据不会出现资源竞争及数据错误。</p>
<p>为了方便大家理解，这里举个例子来说明。比如公司部门里，我在使用着打印机打印东西的同时（还没有打印完），别人刚好也在此刻使用打印机打印东西，如果不做任何处理的话，打印出来的东西肯定是错乱的。那么怎么解决这种情况呢？只要我在打印着的时候别人是不允许打印的，只有等我打印结束后别人才允许打印。这个过程有点类似于，把打印机放在一个房间里，给这个房间安把锁，这个锁默认是打开的。当 A 需要打印时，他先过来检查这把锁有没有锁着，没有的话就进去，同时上锁在房间里打印。而在这时，刚好 B 也需要打印，B 同样先检查锁，发现锁是锁住的，他就在门外等着。而当 A 打印结束后，他会开锁出来，这时候 B 才进去上锁打印。看了这个例子，相信大家已经理解了互斥锁。</p>
<p>互斥锁会导致休眠，所以在中断里面不能用互斥锁。同一时刻只能有一个线程持有互斥锁，并且只有持有者才可以解锁，并且不允许递归上锁和解锁。</p>
<p>内核中以mutex结构体来表示互斥体，定义在“内核源码&#x2F;include&#x2F;linux&#x2F;mutex.h”文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_long_t</span>       owner;</span><br><span class="line">    <span class="type">spinlock_t</span>      wait_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MUTEX_SPIN_ON_OWNER</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">optimistic_spin_queue</span> <span class="title">osq</span>;</span> <span class="comment">/* Spinner MCS lock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">    <span class="type">void</span>            *magic;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>  <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一些和互斥体相关的API函数也定义在mutex.h文件中，常用API函数如下（表24-1）所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_MUTEX(name)</td>
<td>定义并初始化一个 mutex 变量。</td>
</tr>
<tr>
<td>void mutex_init(mutex *lock)</td>
<td>初始化 mutex。</td>
</tr>
<tr>
<td>void mutex_lock(struct mutex *lock)</td>
<td>获取 mutex，也就是给 mutex 上锁。如果获取不到就进休眠。</td>
</tr>
<tr>
<td>void mutex_unlock(struct mutex *lock)</td>
<td>释放 mutex，也就给 mutex 解锁。</td>
</tr>
<tr>
<td>int mutex_is_locked(struct mutex *lock)</td>
<td>判断 mutex 是否被获取，如果是的话就返回1，否则返回 0。</td>
</tr>
</tbody></table>
<p>表 24-1</p>
<p>至此，关于互斥体相关的知识就讲解完成了，在下一小节的实验中会对上述API函数进行运用。</p>
<h2 id="24-2-实验程序的编写"><a href="#24-2-实验程序的编写" class="headerlink" title="24.2 实验程序的编写"></a>24.2 实验程序的编写</h2><h3 id="24-2-1-驱动程序编写"><a href="#24-2-1-驱动程序编写" class="headerlink" title="24.2.1 驱动程序编写"></a>24.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\19\module。</p>
<p>本小节实验将使用互斥体对19章的并发与竞争实验进行改进，由于互斥体在同一时间内只允许一个任务对共享资源进行，所以除了在atomic_init()函数内加入初始化互斥锁函数之外，只需要在open()函数中加入互斥锁加锁函数，在release()函数中加入互斥锁解锁函数即可。</p>
<p>编写完成的mutex.c代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex_test</span>;</span><span class="comment">//定义mutex类型的互斥锁结构体变量mutex_test</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">open_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;\nthis is open_test \n&quot;</span>);</span><br><span class="line">	mutex_lock(&amp;mutex_test);<span class="comment">//互斥锁加锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> kbuf[<span class="number">10</span>] = <span class="string">&quot;topeet&quot;</span>;<span class="comment">//定义char类型字符串变量kbuf</span></span><br><span class="line">	printk(<span class="string">&quot;\nthis is read_test \n&quot;</span>);</span><br><span class="line">	ret = copy_to_user(ubuf,kbuf,<span class="built_in">strlen</span>(kbuf));<span class="comment">//使用copy_to_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_to_user is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_to_user is ok \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kbuf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义char类型字符串全局变量kbuf</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_test</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *ubuf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = copy_from_user(kbuf,ubuf,len);<span class="comment">//使用copy_from_user接收用户空间传递的数据</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;copy_from_user is error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;<span class="comment">//如果传递的kbuf是topeet就睡眠四秒钟</span></span><br><span class="line">		ssleep(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(kbuf,<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//如果传递的kbuf是itop就睡眠两秒钟</span></span><br><span class="line">		ssleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;copy_from_user buf is %s \n&quot;</span>,kbuf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">release_test</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex_unlock(&amp;mutex_test);<span class="comment">//互斥锁解锁</span></span><br><span class="line">printk(<span class="string">&quot;\nthis is release_test \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> &#123;</span></span><br><span class="line">       <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line">       <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev_test</span> <span class="title">dev1</span>;</span><span class="comment">//创建chrdev_test类型的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops_test</span> =</span> &#123;</span><br><span class="line">      .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">      .open = open_test,<span class="comment">//将open字段指向open_test(...)函数</span></span><br><span class="line">      .read = read_test,<span class="comment">//将read字段指向read_test(...)函数</span></span><br><span class="line">      .write = write_test,<span class="comment">//将write字段指向write_test(...)函数</span></span><br><span class="line">      .release = release_test,<span class="comment">//将release字段指向release_test(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	mutex_init(&amp;mutex_test);<span class="comment">//对互斥体进行初始化</span></span><br><span class="line">	<span class="keyword">if</span>(alloc_chrdev_region(&amp;dev1.dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>) &lt; <span class="number">0</span> )&#123;<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">		printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">	dev1.major = MAJOR(dev1.dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">	dev1.minor = MINOR(dev1.dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">	printk(<span class="string">&quot;major is %d,minor is %d\n&quot;</span>,dev1.major,dev1.minor);</span><br><span class="line">	cdev_init(&amp;dev1.cdev_test,&amp;fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到fops_test结构体</span></span><br><span class="line">	dev1.cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	cdev_add(&amp;dev1.cdev_test,dev1.dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">	dev1.class_test = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">	device_create(dev1.class_test,<span class="number">0</span>,dev1.dev_num,<span class="number">0</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(dev1.class_test,dev1.dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">	class_destroy(dev1.class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">	cdev_del(&amp;dev1.cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">	unregister_chrdev_region(dev1.dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(<span class="type">atomic_init</span>);</span><br><span class="line">module_exit(<span class="type">atomic_exit</span>)</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="24-2-2-编写测试-APP"><a href="#24-2-2-编写测试-APP" class="headerlink" title="24.2.2 编写测试 APP"></a>24.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\19\app。</p>
<p>本测试app代码和上一章节相同，需要输入两个参数，第一个参数为对应的设备节点，第二个参数为“topeet”或者“itop”，分别代表向设备写入的数据，编写完成的应用程序app.c内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区str1</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open failed \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为topeet，条件成立，调用write函数，写入topeet*/</span>    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;topeet&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;topeet&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为itop，条件成立，调用write函数，写入itop*/</span>  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;itop&quot;</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		write(fd,<span class="string">&quot;itop&quot;</span>,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24-3-运行测试"><a href="#24-3-运行测试" class="headerlink" title="24.3 运行测试"></a>24.3 运行测试</h2><h3 id="24-3-1-编译驱动程序"><a href="#24-3-1-编译驱动程序" class="headerlink" title="24.3.1 编译驱动程序"></a>24.3.1 编译驱动程序</h3><p>在上一小节中的mutex.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += mutex.c    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放mutex.c和Makefile文件目录下，如下图（图24-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps163.jpg" alt="img"> </p>
<p>图 24-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图24-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps164.jpg" alt="img"> </p>
<p>图24-3</p>
<p>编译完生成mutex.ko目标文件，如下图（图 24-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps165.jpg" alt="img"> </p>
<p>图 24-4</p>
<p>至此驱动模块就编译成功了，下面进行应用程序的编译。</p>
<h3 id="24-3-2-编译应用程序"><a href="#24-3-2-编译应用程序" class="headerlink" title="24.3.2 编译应用程序"></a>24.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图 24-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps166.jpg" alt="img"> </p>
<p>图 24-5</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图 24-6）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps167.jpg" alt="img"> </p>
<p>图 24-6</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="24-3-3-运行测试"><a href="#24-3-3-运行测试" class="headerlink" title="24.3.3 运行测试"></a>24.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图24-7）所示：</p>
<p>insmod mutex.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps168.jpg" alt="img"> </p>
<p>图 24-7</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图24-8）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps169.jpg" alt="img"> </p>
<p>图 24-8</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令运行测试app，运行结果如下图（图24-9）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps170.jpg" alt="img"> </p>
<p>图 24-9</p>
<p>可以看到传递的buf值为topeet，然后输入以下命令在后台运行两个app，来进行竞争测试，运行结果如下图（图24-10）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test topeet &amp;</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test itop </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps171.jpg" alt="img"> </p>
<p>图 24-10</p>
<p>​	与23章实验测试现象相同，两个app被同时运行，最终打印信息正常，证明数据被正确传递了，没有发生共享资源的竞争，证明互斥量就起到了作用。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图24-11）所示：</p>
<p>rmmod mutex.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps172.jpg" alt="img"> </p>
<p>图 24-11</p>
<p>至此，互斥体实验就完成了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%89%E7%AF%87-%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/" rel="tag">并发与竞争</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E5%9B%9B%E7%AF%87-%E9%AB%98%E7%BA%A7%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E8%BF%9B%E9%98%B6/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            rk3568 驱动开发第四篇 高级字符设备进阶
          
        </div>
      </a>
    
    
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%8C%E7%AF%87-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%9F%BA%E7%A1%80/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">rk3568 驱动开发第二篇 字符设备基础</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="热爱学习的未来酱"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>