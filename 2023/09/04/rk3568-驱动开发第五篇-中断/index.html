<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="永远年轻，永远热泪盈眶" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>rk3568 驱动开发第五篇 中断 |  热爱学习的未来酱</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="热爱学习的未来酱" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-rk3568-驱动开发第五篇-中断"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  rk3568 驱动开发第五篇 中断
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%94%E7%AF%87-%E4%B8%AD%E6%96%AD/" class="article-date">
  <time datetime="2023-09-04T12:55:48.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">26.9k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">98 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第39章-中断实验"><a href="#第39章-中断实验" class="headerlink" title="第39章 中断实验"></a>第39章 中断实验</h1><p>在前面的课程中，我们深入学习了高级字符设备的进阶知识，包括IO模型、定时器原理、llseek设备定位和通过ioctl传递参数等。通过这些课程，我们对高级字符设备有了深入的理解，并掌握了一些实用的技术和编程方法。从今天开始，我们就进入中断课程的学习了。中断是操作系统中至关重要的机制，它能够显著提高系统的响应性能和并发处理能力。</p>
<h2 id="39-1什么是中断？"><a href="#39-1什么是中断？" class="headerlink" title="39.1什么是中断？"></a>39.1什么是中断？</h2><h3 id="39-1-1-中断的概念"><a href="#39-1-1-中断的概念" class="headerlink" title="39.1.1 中断的概念"></a>39.1.1 中断的概念</h3><p>中断是指在CPU正常运行期间，由外部或内部事件引起的一种机制。当中断发生时，CPU会停止当前正在执行的程序，并转而执行触发该中断的中断处理程序。处理完中断处理程序后，CPU会返回到中断发生的地方，继续执行被中断的程序。中断机制允许CPU在实时响应外部或内部事件的同时，保持对其他任务的处理能力。</p>
<p>可以想象这样一幅画面，你正在烹饪一顿美味的晚餐，准备了各种食材，点燃了炉灶，开始了幸福的烹饪过程，突然，你的手机响起，有人打来了一个紧急电话，打破了你正常的烹饪流程，这时候你需要立刻停止手中的工作，迅速接起电话，与对方进行交流，在接完电话之后，再回到厨房继续之前的烹饪流程。这就是一个在实际生活中的中断案例，中断的概念流程图如下（39-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps33.jpg" alt="img"> </p>
<p>图 39-1</p>
<h3 id="39-1-2-中断的重要性"><a href="#39-1-2-中断的重要性" class="headerlink" title="39.1.2 中断的重要性"></a>39.1.2 中断的重要性</h3><p>在上面的场景中，作为唯一具有处理能力的主体，我们一次只能专注于一个任务，可以等待水烧开、看电视等等。然而，当我们专心致志地完成一项任务时，常常会有紧迫或不紧迫的其他事情突然出现，需要我们关注和处理。有些情况甚至要求我们立即停下手头的工作来应对。只有在处理完这些中断事件之后，我们才能回到先前的任务。</p>
<p>中断机制赋予了我们处理意外情况的能力，而且如果我们能充分利用这个机制，就能够同时完成多个任务。回到烧水的例子，无论我们是否在厨房，煤气灶都会将水烧开。我们只需要在水烧开后及时关掉煤气。为了避免在厨房等待的时间，而水烧开时产生的声音就是中断信号，提醒我们炉子上的水已经烧开。这样，我们就可以在等待的时间里做其他事情，比如看电视。当水壶烧开发出声音之后，它会打断当前的任务，提醒水已经烧开，这时只需要前往厨房关掉煤气即可。</p>
<p>中断机制使我们能够有条不紊地同时处理多个任务，从而提高了并发处理能力。类似地，计算机系统中也使用中断机制来应对各种外部事件。例如，在键盘输入时，会发送一个中断信号给CPU，以便及时响应用户的操作。这样，CPU就不必一直轮询键盘的状态，而可以专注于其他任务。中断机制还可以用于处理硬盘读写完成、网络数据包接收等事件，提高了系统的资源利用率和并发处理能力。</p>
<h3 id="39-1-3-中断的上下半部"><a href="#39-1-3-中断的上下半部" class="headerlink" title="39.1.3 中断的上下半部"></a>39.1.3 中断的上下半部</h3><p>中断的执行需要快速响应，但并不是所有中断都能迅速完成。此外，Linux中的中断不支持嵌套，意味着在正式处理中断之前会屏蔽其他中断，直到中断处理完成后再重新允许接收中断，如果中断处理时间过长，将会引发问题。</p>
<p>这里仍旧以烹饪的过程中接电话进行举例：当你正在烹饪一顿美味的晚餐时，所有的食材都准备好了，炉灶上的火焰跳跃着，你正享受着烹饪的乐趣。突然，你的手机响起，发出紧急电话的铃声，打破了你正常的烹饪流程，接电话的时间很短并不会对烹饪产生很大的影响，而接电话的时候可能就有问题了，水烧开之后可能会煮干、错过了最好的添加调味料的时间等等。</p>
<p>而为了让系统可以更好地处理中断事件，提高实时性和响应能力，将中断服务程序划分为上下文两部分：</p>
<p>中断上文是中断服务程序的第一部分，它主要处理一些紧急且需要快速响应的任务。中断上文的特点是执行时间较短，旨在尽快完成对中断的处理。这些任务可能包括保存寄存器状态、更新计数器等，以便在中断处理完成后能够正确地返回到中断前的执行位置。</p>
<p>中断下文是中断服务程序的第二部分，它主要处理一些相对耗时的任务。由于中断上文需要尽快完成，因此中断下文负责处理那些不能立即完成的、需要更多时间的任务。这些任务可能包括复杂的计算、访问外部设备或进行长时间的数据处理等。</p>
<h2 id="39-2中断子系统框架"><a href="#39-2中断子系统框架" class="headerlink" title="39.2中断子系统框架"></a>39.2中断子系统框架</h2><p>一个完整的中断子系统框架可以分为四个层次，由上到下分别为用户层、通用层、硬件相关层和硬件层，每个层相关的介绍如下（图39-2）所示：</p>
<p>****用户层：****用户层是中断的使用者，主要包括各类设备驱动。这些驱动程序通过中断相关的接口进行中断的申请和注册。当外设触发中断时，用户层驱动程序会进行相应的回调处理，执行特定的操作。</p>
<p>****通用层：****通用层也可称为框架层，它是硬件无关的层次。通用层的代码在所有硬件平台上都是通用的，不依赖于具体的硬件架构或中断控制器。通用层提供了统一的接口和功能，用于管理和处理中断，使得驱动程序能够在不同的硬件平台上复用。</p>
<p>****硬件相关层：****硬件相关层包含两部分代码。一部分是与特定处理器架构相关的代码，比如ARM64处理器的中断处理相关代码。这些代码负责处理特定架构的中断机制，包括中断向量表、中断处理程序等。另一部分是中断控制器的驱动代码，用于与中断控制器进行通信和配置。这些代码与具体的中断控制器硬件相关。</p>
<p>****硬件层：****硬件层位于最底层，与具体的硬件连接相关。它包括外设与SoC（系统片上芯片）的物理连接部分。中断信号从外设传递到中断控制器，由中断控制器统一管理和路由到处理器。硬件层的设计和实现决定了中断信号的传递方式和硬件的中断处理能力。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps34.jpg" alt="img"> </p>
<p>图 39-2</p>
<p>本小节的重点会聚集在硬件层各部分的详细讲解以及用户层编写驱动程序所用到的接口函数。</p>
<h3 id="39-2-1-中断控制器GIC"><a href="#39-2-1-中断控制器GIC" class="headerlink" title="39.2.1 中断控制器GIC"></a>39.2.1 中断控制器GIC</h3><p>中断控制器GIC（Generic Interrupt Controller）是中断子系统框架硬件层中的一个关键组件，用于管理和控制中断。它接收来自各种中断源的中断请求，并根据预先配置的中断优先级、屏蔽和路由规则，将中断请求分发给适当的处理器核心或中断服务例程。</p>
<p>GIC是由ARM公司提出设计规范，当前有四个版本，GIC V1-v4。设计规范中最常用的，有3个版本V2.0、V3.1、V4.1，GICv3版本设计主要运行在Armv8-A, Armv9-A等架构上。ARM公司并给出一个实际的控制器设计参考，比如GIC-400(支持GIC v2架构)、gic500(支持GIC v3架构)、GIC-600(支持GIC v3和GIC v4架构)。最终芯片厂商可以自己实现GIC或者直接购买ARM提供的设计。</p>
<p>每个GIC版本及相应特性如下表（表 39-3）所示：</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>关键特性</th>
<th>常用核心</th>
</tr>
</thead>
<tbody><tr>
<td>GICv1</td>
<td>-支持最多八个处理器核心（PE）- 支持最多1020个中断ID</td>
<td>ARM Cortex-A5 MPCoreARM Cortex-A9 MPCoreARM Cortex-R7 MPCore</td>
</tr>
<tr>
<td>GICv2</td>
<td>- GICv1的所有关键特性-支持虚拟化</td>
<td>ARM Cortex-A7 MPCoreARM Cortex-A15 MPCoreARM Cortex-A53 MPCoreARM Cortex-A57 MPCore</td>
</tr>
<tr>
<td>GICv3</td>
<td>- GICv2的所有关键特性-支持超过8个处理器核心-支持基于消息的中断-支持超过1020个中断ID- CPU接口寄存器的系统寄存器访问-增强的安全模型，分离安全和非安全的Group 1中断</td>
<td>ARM Cortex-A53MPCoreARM Cortex-A57MPCoreARM Cortex-A72 MPCore</td>
</tr>
<tr>
<td>GICv4</td>
<td>- GICv3的所有关键特性-虚拟中断的直接注入</td>
<td>ARM Cortex-A53 MPCoreARMCortex-A57MPCoreARM Cortex-A72 MPCore</td>
</tr>
</tbody></table>
<p>表 39-3</p>
<p>在RK3568上使用的GIC版本为GICv3，相应的中断控制器模型如下（图 39-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps35.jpg" alt="img"> </p>
<p>图 39-4</p>
<p>GIC中断控制器可以分为Distributor接口、Redistributor接口和CPU接口，下面是每个部分的说明：</p>
<p><em><strong>*Distributor*</strong></em><em><strong>*中断仲裁器：*</strong></em></p>
<p>包含影响所有处理器核心中断的全局设置。包含以下编程接口：</p>
<p>●启用和禁用SPI。</p>
<p>●设置每个SPI的优先级级别。</p>
<p>●每个SPI的路由信息。</p>
<p>●将每个SPI设置为电平触发或边沿触发。</p>
<p>●生成基于消息的SPI。</p>
<p>●控制SPI的活动和挂起状态。</p>
<p>●用于确定在每个安全状态中使用的程序员模型的控制（亲和性路由或遗留模型）。</p>
<p>****Redistributor重新分配器****：</p>
<p>对于每个连接的处理器核心（PE），都有一个重新分配器（Redistributor）。重新分配器提供以下编程接口：</p>
<p>●启用和禁用SGI（软件生成的中断）和PPI（处理器专用中断）。</p>
<p>●设置SGI和PPI的优先级级别。</p>
<p>●将每个PPI设置为电平触发或边沿触发。</p>
<p>●将每个SGI和PPI分配给一个中断组。</p>
<p>●控制SGI和PPI的状态。</p>
<p>●对支持关联LPI（低功耗中断）的中断属性和挂起状态的内存中的数据结构进行基址控制。</p>
<p>●支持与连接的处理器核心的电源管理。</p>
<p><em><strong>*CPU接口*</strong></em><em><strong>*：*</strong></em></p>
<p>每个重新分配器都连接到一个CPU接口。CPU接口提供以下编程接口：</p>
<p>●通用控制和配置，用于启用中断处理。</p>
<p>●确认中断。</p>
<p>●执行中断的优先级降低和停用。</p>
<p>●为处理器核心设置中断优先级屏蔽。</p>
<p>●定义处理器核心的抢占策略。</p>
<p>●确定处理器核心最高优先级的挂起中断。</p>
<h3 id="39-2-2-中断类型"><a href="#39-2-2-中断类型" class="headerlink" title="39.2.2 中断类型"></a>39.2.2 中断类型</h3><p>GIC-V3支持四种类型的中断，分别是SGI、PPI、SPI和LPI，每个中断类型的介绍如下：</p>
<p>SGI（Software Generated Interrupt，软件生成中断）：SGI 是通过向 GIC 中的 SGI 寄存器写入来生成的中断。它通常用于处理器之间的通信，允许一个 PE 发送中断给一个或多个指定的 PE，中断号ID0 - ID15用于SGI。</p>
<p>PPI（Private Peripheral Interrupt，私有外设中断）：针对特定 PE 的外设中断。不与其他 PE 共享，中断号ID16 - ID31用于PPI。</p>
<p>SPI（Shared Peripheral Interrupt，共享外设中断）：全局外设中断，可以路由到指定的处理器核心（PE）或一组 PE，它允许多个 PE 接收同一个中断。中断号ID32 - ID1019用于SPI，</p>
<p>LPI（Locality-specific Peripheral Interrupt，特定局部外设中断）：LPI 是 GICv3 中引入的一种中断类型，与其他类型的中断有几个不同之处。LPI 总是基于消息的中断，其配置存储在内存表中，而不是寄存器中。</p>
<table>
<thead>
<tr>
<th>INTID范围</th>
<th>中断类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>0 - 15</td>
<td>SGI（软件生成中断）</td>
<td>每个核心分别存储</td>
</tr>
<tr>
<td>16 - 31</td>
<td>PPI（私有外设中断）</td>
<td>每个核心分别存储</td>
</tr>
<tr>
<td>32 - 1019</td>
<td>SPI（共享外设中断）</td>
<td></td>
</tr>
<tr>
<td>1020 - 1023</td>
<td>特殊中断号</td>
<td>用于表示特殊情况</td>
</tr>
<tr>
<td>1024 - 8191</td>
<td>保留</td>
<td></td>
</tr>
<tr>
<td>8192及更大</td>
<td>LPI（特定局部外设中断）</td>
<td>上限由实现定义</td>
</tr>
</tbody></table>
<p>表 39-5</p>
<p>中断处理的状态机如下图（图 39-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps36.jpg" alt="img"> </p>
<p>图 39-6</p>
<p>Inactive（非活动状态）：中断源当前未被触发。</p>
<p>Pending（等待状态）：中断源已被触发，但尚未被处理器核心确认。</p>
<p>Active（活动状态）：中断源已被触发，并且已被处理器核心确认。</p>
<p>Active and Pending（活动且等待状态）：已确认一个中断实例，同时另一个中断实例正在等待处理。</p>
<p>每个外设中断可以是以下两种类型之一：<br><em><strong>*边沿触发（Edge-triggered）*</strong></em><em><strong>*：*</strong></em><br>    这是一种在检测到中断信号上升沿时触发的中断，然后无论信号状态如何，都保持触发状态，直到满足本规范定义的条件来清除中断。</p>
<p><em><strong>*电平触发（Level-sensitive）*</strong></em><em><strong>*：*</strong></em><br>    这是一种在中断信号电平处于活动状态时触发的中断，并且在电平不处于活动状态时取消触发。</p>
<h3 id="39-2-3-中断号"><a href="#39-2-3-中断号" class="headerlink" title="39.2.3 中断号"></a>39.2.3 中断号</h3><p>在linux 内核中，我们使用IRQ number和HW interrupt ID两个ID来标识一个来自外设的中断：</p>
<p>****IRQ number****：CPU需要为每一个外设中断编号，我们称之IRQ Number。这个IRQ number是一个虚拟的interrupt ID，和硬件无关，仅仅是被CPU用来标识一个外设中断。</p>
<p>****HW interrupt ID：****对于GIC中断控制器而言，它收集了多个外设的interrupt request line并向上传递，因此，GIC中断控制器需要对外设中断进行编码。GIC中断控制器用HW interrupt ID来标识外设的中断。如果只有一个GIC中断控制器，那IRQ number和HW interrupt ID是可以一一对应的，如下图（图 39-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps37.jpg" alt="img"> </p>
<p>图 39-7</p>
<p>但如果是在GIC中断控制器级联的情况下，仅仅用HW interrupt ID就不能唯一标识一个外设中断，还需要知道该HW interrupt ID所属的GIC中断控制器（HW interrupt ID在不同的Interrupt controller上是会重复编码的）。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps38.jpg" alt="img"> </p>
<p>图 39-8</p>
<p>这样，CPU和中断控制器在标识中断上就有了一些不同的概念，但是，对于驱动工程师而言，我们和CPU视角是一样的，我们只希望得到一个IRQ number，而不关系具体是那个GIC中断控制器上的那个HW interrupt ID。这样一个好处是在中断相关的硬件发生变化的时候，驱动软件不需要修改。因此，linux kernel中的中断子系统需要提供一个将HW interrupt ID映射到IRQ number上来的机制，也就是irq domain。</p>
<h3 id="39-2-4-中断申请函数"><a href="#39-2-4-中断申请函数" class="headerlink" title="39.2.4 中断申请函数"></a>39.2.4 中断申请函数</h3><h4 id="（1）-request-irq"><a href="#（1）-request-irq" class="headerlink" title="（1）****request_irq"></a><strong>（<strong><strong>1</strong></strong>）****request_irq</strong></h4><p>request_irq 函数是在 Linux 内核中用于注册中断处理程序的函数。它用于请求一个中断号（IRQ number）并将一个中断处理程序与该中断关联起来。下面是对 request_irq 函数的详细介绍：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>  int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev);</p>
<p>****头文件****：</p>
<p>  #include &lt;linux&#x2F;interrupt.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>request_irq 函数的主要功能是请求一个中断号，并将一个中断处理程序与该中断号关联起来。当中断事件发生时，与该中断号关联的中断处理程序会被调用执行。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>irq：要请求的中断号（IRQ number）。</p>
<p>handler：指向中断处理程序的函数指针。</p>
<p>flags：标志位，用于指定中断处理程序的行为和属性，如中断触发方式、中断共享等。</p>
<p>name：中断的名称，用于标识该中断。</p>
<p>dev：指向设备或数据结构的指针，可以在中断处理程序中使用。</p>
<p>返回值：</p>
<p>成功：0 或正数，表示中断请求成功。</p>
<p>失败：负数，表示中断请求失败，返回的负数值表示错误代码。</p>
<p>irq参数用来指定要请求的中断号，中断号需要通过gpio_to_irq 函数映射 GPIO 引脚来获得（gpio_to_irq 函数接下来会进行介绍）。</p>
<p>irq_handler_t handler参数是一个函数指针，指向了中断处理程序的函数。中断处理程序是在中断事件发生时调用的函数，用于处理中断事件（关于中断处理程序会在下个小节进行详细的讲解）。</p>
<p>unsigned long flags：中断处理程序的标志位</p>
<p>这个参数用于指定中断处理程序的行为和属性，如中断触发方式、中断共享等。可以使用不同的标志位进行位运算来组合多个属性。常用的标志位包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IRQF_TRIGGER_NONE：无触发方式，表示中断不会被触发。</span><br><span class="line">IRQF_TRIGGER_RISING：上升沿触发方式，表示中断在信号上升沿时触发。</span><br><span class="line">IRQF_TRIGGER_FALLING：下降沿触发方式，表示中断在信号下降沿时触发。</span><br><span class="line">IRQF_TRIGGER_HIGH：高电平触发方式，表示中断在信号为高电平时触发。</span><br><span class="line">IRQF_TRIGGER_LOW：低电平触发方式，表示中断在信号为低电平时触发。</span><br><span class="line">IRQF_SHARED：中断共享方式，表示中断可以被多个设备共享使用。</span><br></pre></td></tr></table></figure>



<h4 id="（2）-gpio-to-irq"><a href="#（2）-gpio-to-irq" class="headerlink" title="（2）****gpio_to_irq"></a><strong>（2）****gpio_to_irq</strong></h4><p>gpio_to_irq 函数用于将 GPIO 引脚的编号（GPIO pin number）转换为对应的中断请求号（interrupt request number）。</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>unsigned int gpio_to_irq(unsigned int gpio);</p>
<p>****头文件****：</p>
<p>#include &lt;linux&#x2F;gpio.h&gt;</p>
<p><em><strong>*函数功能：*</strong></em><br>    gpio_to_irq 是一个用于将 GPIO 引脚映射到对应中断号的函数。它的作用是根据给定的 GPIO 引脚号，获取与之关联的中断号。</p>
<p><em><strong>*参数说明：*</strong></em></p>
<p>gpio：要映射的 GPIO 引脚号。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>成功：返回值为该 GPIO 引脚所对应的中断号。</p>
<p>失败：返回值为负数，表示映射失败或无效的 GPIO 引脚号。</p>
<h4 id="（3）free-irq"><a href="#（3）free-irq" class="headerlink" title="（3）free_irq"></a>（3）<strong>free_irq</strong></h4><p>free_irq 函数用于释放之前通过 request_irq 函数注册的中断处理程序。它的作用是取消对中断的注册并释放相关的系统资源。下面是关于该函数的详细解释：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>void free_irq(unsigned int irq, void *dev_id);</p>
<p><em><strong>*头文件：*</strong></em></p>
<p>#include &lt;linux&#x2F;interrupt.h&gt;</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>free_irq 函数用于释放之前通过 request_irq 函数注册的中断处理程序。它会取消对中断的注册并释放相关的系统资源，包括中断号、中断处理程序和设备标识等。</p>
<p><em><strong>*参数说明：*</strong></em></p>
<p>irq：要释放的中断号。</p>
<p>dev_id：设备标识，用于区分不同的中断请求。它通常是在 request_irq 函数中传递的设备特定数据指针。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>free_irq 函数没有返回值。</p>
<h3 id="39-2-5-中断服务函数"><a href="#39-2-5-中断服务函数" class="headerlink" title="39.2.5 中断服务函数"></a>39.2.5 中断服务函数</h3><p>中断处理程序是在中断事件发生时自动调用的函数。它负责处理与中断相关的操作，例如读取数据、清除中断标志、更新状态等。</p>
<p>irqreturn_t handler(int irq, void *dev_id) 是一个典型的中断服务函数的函数原型。下面对该函数原型及其参数进行详细解释：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>irqreturn_t handler(int irq, void *dev_id);</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>handler 函数是一个中断服务函数，用于处理特定中断事件。它在中断事件发生时被操作系统或硬件调用，执行必要的操作来响应和处理中断请求。</p>
<p><em><strong>*参数说明：*</strong></em></p>
<p>irq：表示中断号或中断源的标识符。它指示引发中断的硬件设备或中断控制器。</p>
<p>dev_id：是一个 void 类型的指针，用于传递设备特定的数据或标识符。它通常用于在中断处理程序中区分不同的设备或资源。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>irqreturn_t 是一个特定类型的枚举值，用于表示中断服务函数的返回状态。它可以有以下几种取值：</p>
<p>IRQ_NONE：表示中断服务函数未处理该中断，中断控制器可以继续处理其他中断请求。</p>
<p>IRQ_HANDLED：表示中断服务函数已成功处理该中断，中断控制器无需进一步处理。</p>
<p>IRQ_WAKE_THREAD：表示中断服务函数已处理该中断，并且请求唤醒一个内核线程来继续执行进一步的处理。这在一些需要长时间处理的中断情况下使用。</p>
<p>在处理程序中，通常需要注意以下几个方面：</p>
<p>（1）处理程序应该尽可能地快速执行，以避免中断丢失或过多占用 CPU 时间。</p>
<p>（2）如果中断源是共享的，处理程序需要处理多个设备共享同一个中断的情况。</p>
<p>（3）处理程序可能需要与其他部分的代码进行同步，例如访问共享数据结构或使用同步机制来保护临界区域。</p>
<p>（4）处理程序可能需要与其他线程或进程进行通信，例如唤醒等待的线程或发送信号给其他进程。</p>
<h2 id="39-3实验程序编写"><a href="#39-3实验程序编写" class="headerlink" title="39.3实验程序编写"></a>39.3实验程序编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\30_interrupt\03_中断驱动例程。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中会打印申请的GPIO号和This is irq_handler。</p>
<p>iTOP-RK3568有 5 组 GPIO bank：GPIO0<del>GPIO4，每组又以 A0</del>A7, B0<del>B7, C0</del>C7, D0~D7 作为编号区分,常用以下公式计算引脚：</p>
<ul>
<li>GPIO pin脚计算公式：pin <strong>&#x3D;</strong> bank ***** 32 <strong>+</strong> number   &#x2F;&#x2F;bank为组号，number为小组编号</li>
<li>GPIO 小组编号计算公式：number <strong>&#x3D;</strong> group ***** 8 <strong>+</strong> X</li>
</ul>
<p>LCD触摸屏对应的中断引脚标号为TP_INT_L_GPIO3_A5，对应的计算过程如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bank = <span class="number">3</span>;       <span class="comment">//GPIO3_A5=&gt; 3, bank ∈ [0,4]</span></span><br><span class="line">group = <span class="number">0</span>;      <span class="comment">//GPIO3_A5 =&gt; 0, group ∈ &#123;(A=0), (B=1), (C=2), (D=3)&#125;</span></span><br><span class="line">X = <span class="number">5</span>;         <span class="comment">//GPIO3_A5 =&gt; 5, X ∈ [0,7]</span></span><br><span class="line">number = group * <span class="number">8</span> + X = <span class="number">0</span> * <span class="number">8</span> + <span class="number">5</span> =<span class="number">5</span></span><br><span class="line">pin = bank*<span class="number">32</span> + number= <span class="number">3</span> * <span class="number">32</span> + <span class="number">5</span> = <span class="number">101</span>;</span><br></pre></td></tr></table></figure>

<p> 得到中断引脚的引脚标号后，下面开始编写对应的驱动程序，编写完成的interrupt.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN 101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_irq_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt occurred on GPIO %d\n&quot;</span>, GPIO_PIN);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;This is irq_handler\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">interrupt_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> irq_num;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Initializing GPIO Interrupt Driver\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将GPIO引脚映射到中断号</span></span><br><span class="line">    irq_num = gpio_to_irq(GPIO_PIN);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;GPIO %d mapped to IRQ %d\n&quot;</span>, GPIO_PIN, irq_num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求中断</span></span><br><span class="line">    <span class="keyword">if</span> (request_irq(irq_num, gpio_irq_handler, IRQF_TRIGGER_RISING, <span class="string">&quot;irq_test&quot;</span>, <span class="literal">NULL</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to request IRQ %d\n&quot;</span>, irq_num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求中断失败，释放GPIO引脚</span></span><br><span class="line">        gpio_free(GPIO_PIN);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">interrupt_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;                                                                                                                                                                                                                                     </span><br><span class="line">    <span class="type">int</span> irq_num = gpio_to_irq(GPIO_PIN);</span><br><span class="line">    <span class="comment">// 释放中断</span></span><br><span class="line">    free_irq(irq_num, <span class="literal">NULL</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;GPIO Interrupt Driver exited successfully\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(interrupt_init);</span><br><span class="line">module_exit(interrupt_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="39-4-运行测试"><a href="#39-4-运行测试" class="headerlink" title="39.4 运行测试"></a>39.4 运行测试</h2><h3 id="39-4-1-编译驱动程序"><a href="#39-4-1-编译驱动程序" class="headerlink" title="39.4.1 编译驱动程序"></a>39.4.1 编译驱动程序</h3><p>在上一小节中的timer_mod.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m +=interrupt.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图(图 39-9)所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps39.jpg" alt="img"> </p>
<p>图 39-9</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 39-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps40.jpg" alt="img"> </p>
<p>图 39-10</p>
<p>编译完生成 interrupt.ko目标文件，如下图（图 39-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps41.jpg" alt="img"> </p>
<p>图 39-11</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="39-4-2-运行测试"><a href="#39-4-2-运行测试" class="headerlink" title="39.4.2 运行测试"></a>39.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 39-12）所示：</p>
<p>insmod interrupt.ko </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps42.jpg" alt="img"> </p>
<p>图 39-12</p>
<p>可以看到驱动加载之后，打印了“Initializing GPIO Interrupt Driver”表示程序加载成功了，在后面又打印了gpio映射后的中断请求号为113，然后触摸LCD屏，触发中断服务程序，打印如下图（图 39-13）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps43.jpg" alt="img"> </p>
<p>图 39-13</p>
<p>成功打印了GPIO的引脚编号以及“This is irq_handler”，证明编写的驱动程序没有问题，最后使用以下命令卸载相应的驱动，如下图（图 39-14）所示：</p>
<p>rmmod  interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps44.jpg" alt="img"> </p>
<p>图 39-14</p>
<h1 id="第40章-中断申请流程"><a href="#第40章-中断申请流程" class="headerlink" title="第40章 中断申请流程"></a>第40章 中断申请流程</h1><p>在上一章中，我们简单的认识了一下中断以及中断子系统框架，最后编写了中断申请和中断服务函数的实验，大家会发现虽然前面讲解的只是点很多，但实际用起来只需要两三个函数就可以了，但中断的具体申请流程是怎样的呢，大家就不是很清楚了，在本章节将带领大家研究中断的申请流程。</p>
<h2 id="40-1-request-irq函数"><a href="#40-1-request-irq函数" class="headerlink" title="40.1 request_irq函数"></a>40.1 request_irq函数</h2><p>中断申请使用的是request_irq 函数，它用于请求一个中断号（IRQ number）并将一个中断处理程序与该中断关联起来，它定义在内核源码的“&#x2F;include&#x2F;linux&#x2F;interrupt.h”目录下，具体定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">request_irq(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span><br><span class="line">	    <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的内容可以得到request_irq()函数实际上是调用了request_threaded_irq()函数来完成中断申请的过程。request_threaded_irq()函数提供了线程化的中断处理方式，可以在中断上下文中执行中断处理函数。</p>
<h2 id="40-2-request-threaded-irq函数"><a href="#40-2-request-threaded-irq函数" class="headerlink" title="40.2 request_threaded_irq函数"></a>40.2 request_threaded_irq函数</h2><p>request_threaded_irq 函数是 Linux 内核提供的一个功能强大的函数，用于请求分配一个中断，并将中断处理程序与该中断关联起来。该函数的主要作用是在系统中注册中断处理函数，以响应对应中断的发生。以下是 request_threaded_irq 函数的功能和作用的详细介绍：</p>
<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em>****中断请求****：request_threaded_irq 函数用于请求一个中断。它会向内核注册对应中断号的中断处理函数，并为该中断分配必要的资源。中断号是标识特定硬件中断的唯一标识符。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em>****中断处理函数关联：****通过 handler 参数，将中断处理函数与中断号关联起来。中断处理函数是一个预定义的函数，用于处理中断事件。当中断发生时，内核将调用该函数来处理中断事件。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em>****线程化中断处理****：request_threaded_irq 函数还支持使用线程化中断处理函数。通过指定 thread_fn 参数，可以在一个内核线程上下文中异步执行较长时间的中断处理或延迟敏感的工作。这有助于避免在中断上下文中阻塞时间过长。</p>
<p><em><strong>*（*</strong></em><em><strong>*4*</strong></em><em><strong>*）*</strong></em>****中断属性设置：****通过 irqflags 参数，可以设置中断处理的各种属性和标志。例如，可以指定中断触发方式（上升沿、下降沿、边沿触发等）、中断类型（边沿触发中断、电平触发中断等）以及其他特定的中断行为。</p>
<p><em><strong>*（*</strong></em><em><strong>*5*</strong></em><em><strong>*）*</strong></em>****设备标识关联：****通过 dev_id 参数，可以将中断处理与特定设备关联起来。这样可以在中断处理函数中访问与设备相关的数据。设备标识符可以是指向设备结构体或其他与设备相关的数据的指针。</p>
<p><em><strong>*（*</strong></em><em><strong>*6*</strong></em><em><strong>*）*</strong></em>****错误处理：****request_threaded_irq 函数会返回一个整数值，用于指示中断请求的结果。如果中断请求成功，返回值为 0；如果中断请求失败，则返回一个负数错误代码，表示失败的原因。</p>
<p>request_threaded_irq 函数定义在内核源码目录下的“&#x2F;kernel&#x2F;irq&#x2F;manage.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span>  <span class="comment">// 中断动作结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span>  <span class="comment">// 中断描述符指针</span></span><br><span class="line">	<span class="type">int</span> retval;  <span class="comment">// 返回值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查中断号是否为未连接状态</span></span><br><span class="line">	<span class="keyword">if</span> (irq == IRQ_NOTCONNECTED)</span><br><span class="line">		<span class="keyword">return</span> -ENOTCONN;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查中断标志的有效性</span></span><br><span class="line">	<span class="keyword">if</span> (((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id) ||</span><br><span class="line">	    (!(irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)) ||</span><br><span class="line">	    ((irqflags &amp; IRQF_NO_SUSPEND) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据中断号获取中断描述符</span></span><br><span class="line">	desc = irq_to_desc(irq);</span><br><span class="line">	<span class="keyword">if</span> (!desc)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查中断设置是否可以进行中断请求，以及是否为每个CPU分配唯一设备ID</span></span><br><span class="line">	<span class="keyword">if</span> (!irq_settings_can_request(desc) ||</span><br><span class="line">	    WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果未指定中断处理函数，则使用默认的主处理函数</span></span><br><span class="line">	<span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!thread_fn)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		handler = irq_default_primary_handler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配并初始化中断动作数据结构</span></span><br><span class="line">	action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!action)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	action-&gt;handler = handler;  <span class="comment">// 中断处理函数</span></span><br><span class="line">	action-&gt;thread_fn = thread_fn;  <span class="comment">// 线程处理函数</span></span><br><span class="line">	action-&gt;flags = irqflags;  <span class="comment">// 中断标志</span></span><br><span class="line">	action-&gt;name = devname;  <span class="comment">// 设备名称</span></span><br><span class="line">	action-&gt;dev_id = dev_id;  <span class="comment">// 设备ID</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取中断的电源管理引用计数</span></span><br><span class="line">	retval = irq_chip_pm_get(&amp;desc-&gt;irq_data);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		kfree(action);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置中断并将中断动作与中断描述符关联</span></span><br><span class="line">	retval = __setup_irq(irq, desc, action);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理中断设置失败的情况</span></span><br><span class="line">	<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">		irq_chip_pm_put(&amp;desc-&gt;irq_data);</span><br><span class="line">		kfree(action-&gt;secondary);</span><br><span class="line">		kfree(action);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SHIRQ_FIXME</span></span><br><span class="line">	<span class="keyword">if</span> (!retval &amp;&amp; (irqflags &amp; IRQF_SHARED)) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">		disable_irq(irq);</span><br><span class="line">		local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">		handler(irq, dev_id);</span><br><span class="line"></span><br><span class="line">		local_irq_restore(flags);</span><br><span class="line">		enable_irq(irq);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> retval;  <span class="comment">// 返回设置中断的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em><em><strong>*声明变量和初始化：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span>  <span class="comment">// 中断动作结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span>  <span class="comment">// 中断描述符指针</span></span><br><span class="line"><span class="type">int</span> retval;  <span class="comment">// 返回值</span></span><br></pre></td></tr></table></figure>

<p>第5行：用于存储中断动作结构体的指针（会在下面的小节进行详细的讲解）。</p>
<p>第6行：用于存储中断描述符的指针（会在下面的小节进行详细的讲解）。</p>
<p>第7行：用于存储函数的返回值。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em><em><strong>*参数检查：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查中断号是否为未连接状态</span></span><br><span class="line"><span class="keyword">if</span> (irq == IRQ_NOTCONNECTED)</span><br><span class="line">	<span class="keyword">return</span> -ENOTCONN;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查中断标志的有效性</span></span><br><span class="line"><span class="keyword">if</span> (((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id) ||</span><br><span class="line">    (!(irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)) ||</span><br><span class="line">    ((irqflags &amp; IRQF_NO_SUSPEND) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)))</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br></pre></td></tr></table></figure>

<p>第10行：检查中断号是否为未连接状态（IRQ_NOTCONNECTED）。</p>
<p>第14-17行：检查中断标志的有效性，包括共享标志与设备ID的关联性，条件挂起标志的有效性，以及无挂起标志与条件挂起标志的关联性。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em><em><strong>*获取中断描述符：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据中断号获取中断描述符</span></span><br><span class="line">desc = irq_to_desc(irq);</span><br><span class="line"><span class="keyword">if</span> (!desc)</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br></pre></td></tr></table></figure>

<p>第20行：根据中断号调用irq_to_desc函数获取对应的中断描述符。</p>
<p>第21行：如果获取中断描述符失败，则返回-EINVAL表示无效的参数。</p>
<p><em><strong>*（*</strong></em><em><strong>*4*</strong></em><em><strong>*）*</strong></em><em><strong>*检查中断设置：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查中断设置是否可以进行中断请求，以及是否为每个CPU分配唯一设备ID</span></span><br><span class="line"><span class="keyword">if</span> (!irq_settings_can_request(desc) ||</span><br><span class="line">    WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br></pre></td></tr></table></figure>

<p>第25-26行：检查中断设置是否可以进行中断请求，以及是否为每个CPU分配唯一设备ID。如果中断设置不满足要求，则返回-EINVAL表示无效的参数。</p>
<p><em><strong>*（*</strong></em><em><strong>*5*</strong></em><em><strong>*）*</strong></em><em><strong>*处理中断处理函数和线程处理函数：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果未指定中断处理函数，则使用默认的主处理函数</span></span><br><span class="line"><span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!thread_fn)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	handler = irq_default_primary_handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果未指定中断处理函数，则将默认的主处理函数（irq_default_primary_handler）赋值给handler。</p>
<p><em><strong>*（*</strong></em><em><strong>*6*</strong></em><em><strong>*）*</strong></em><em><strong>*分配并初始化中断动作数据结构：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配并初始化中断动作数据结构</span></span><br><span class="line">action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!action)</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">action-&gt;handler = handler;  <span class="comment">// 中断处理函数</span></span><br><span class="line">action-&gt;thread_fn = thread_fn;  <span class="comment">// 线程处理函数</span></span><br><span class="line">action-&gt;flags = irqflags;  <span class="comment">// 中断标志</span></span><br><span class="line">action-&gt;name = devname;  <span class="comment">// 设备名称</span></span><br><span class="line">action-&gt;dev_id = dev_id;  <span class="comment">// 设备ID</span></span><br></pre></td></tr></table></figure>

<p>第37行：调用kzalloc函数分配内存空间，大小为sizeof(struct irqaction)。	</p>
<p>第38行：如果分配内存失败，则返回-ENOMEM表示内存不足。</p>
<p>第41行-第45行：将中断处理函数、线程处理函数、中断标志、设备名称和设备ID赋值给相应的字段。</p>
<p><em><strong>*（*</strong></em><em><strong>*7*</strong></em><em><strong>*）*</strong></em><em><strong>*获取中断的电源管理引用计数：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取中断的电源管理引用计数</span></span><br><span class="line">retval = irq_chip_pm_get(&amp;desc-&gt;irq_data);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	kfree(action);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第48行：调用irq_chip_pm_get函数获取中断的电源管理引用计数。</p>
<p>第49行：如果获取失败，则释放先前分配的内存空间，并返回获取失败的结果。</p>
<p><em><strong>*（*</strong></em><em><strong>*8*</strong></em><em><strong>*）*</strong></em><em><strong>*设置中断并关联中断动作：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置中断并将中断动作与中断描述符关联</span></span><br><span class="line">retval = __setup_irq(irq, desc, action);</span><br></pre></td></tr></table></figure>

<p>第55行：调用__setup_irq函数设置中断并将中断动作与中断描述符关联。</p>
<p><em><strong>*（*</strong></em><em><strong>*9*</strong></em><em><strong>*）*</strong></em><em><strong>*处理设置中断失败的情况：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理中断设置失败的情况</span></span><br><span class="line"><span class="keyword">if</span> (retval) &#123;</span><br><span class="line">	irq_chip_pm_put(&amp;desc-&gt;irq_data);</span><br><span class="line">	kfree(action-&gt;secondary);</span><br><span class="line">	kfree(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第59行：调用irq_chip_pm_put函数释放中断的电源管理引用计数。</p>
<p>第60行：释放次要中断动作的内存空间。</p>
<p>第61行：释放中断动作的内存空间。</p>
<p><em><strong>*（*</strong></em><em><strong>*10*</strong></em><em><strong>*）*</strong></em><em><strong>*可选的共享中断处理：*</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SHIRQ_FIXME</span></span><br><span class="line">	<span class="keyword">if</span> (!retval &amp;&amp; (irqflags &amp; IRQF_SHARED)) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">		disable_irq(irq);</span><br><span class="line">		local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">		handler(irq, dev_id);</span><br><span class="line"></span><br><span class="line">		local_irq_restore(flags);</span><br><span class="line">		enable_irq(irq);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>第65行：如果设置中断成功且中断标志中包含共享标志（IRQF_SHARED），则执行以下操作：</p>
<p>第68行：禁用中断。</p>
<p>第69行：保存当前中断状态并禁用本地中断。</p>
<p>第70行：调用主处理函数处理中断。</p>
<p>第73行：恢复中断状态。</p>
<p>第74行）：重新使能中断。</p>
<h2 id="40-3-irq-desc结构体"><a href="#40-3-irq-desc结构体" class="headerlink" title="40.3 irq_desc结构体"></a>40.3 irq_desc结构体</h2><p>irq_desc 结构体是 Linux 内核中用于描述中断的数据结构之一。每个硬件中断都有一个对应的 irq_desc 实例，它用于记录与该中断相关的各种信息和状态。该结构体的主要功能是管理中断处理函数、中断行为以及与中断处理相关的其他数据。</p>
<p>以下是 irq_desc 结构体的主要作用和功能：</p>
<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em>****中断处理函数管理****：irq_desc 结构体中的 handle_irq 字段保存中断处理函数的指针。当硬件触发中断时，内核会调用该函数来处理中断事件。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em>****中断行为管理：****irq_desc 结构体中的 action 字段是一个指向中断行为列表的指针。中断行为是一组回调函数，用于注册、注销和处理与中断相关的事件。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em>****中断统计信息：****irq_desc 结构体中的 kstat_irqs 字段是一个指向中断统计信息的指针。该信息用于记录中断事件的发生次数和处理情况，可以帮助分析中断的性能和行为。</p>
<p><em><strong>*（*</strong></em><em><strong>*4*</strong></em><em><strong>*）*</strong></em>****中断数据管理：****irq_desc 结构体中的 irq_data 字段保存了与中断相关的数据，如中断号、中断类型等。这些数据用于识别和管理中断。</p>
<p><em><strong>*（*</strong></em><em><strong>*5*</strong></em><em><strong>*）*</strong></em>****通用中断数据管理：****irq_desc 结构体中的 irq_common_data 字段保存了与中断处理相关的通用数据，如中断控制器、中断屏蔽等。这些数据用于处理和控制中断的行为。</p>
<p><em><strong>*（*</strong></em><em><strong>*6*</strong></em><em><strong>*）*</strong></em>****中断状态管理：****irq_desc 结构体中的其他字段用于管理中断的状态，如嵌套中断禁用计数、唤醒使能计数等。这些状态信息帮助内核跟踪和管理中断的状态变化。</p>
<p>通过使用 irq_desc 结构体，内核可以有效地管理和处理系统中的硬件中断。它提供了一个统一的接口，用于注册和处理中断处理函数、管理中断行为，并提供了必要的信息和数据结构来监视和控制中断的行为和状态。</p>
<p> irq_desc 结构体定义在内核源码目录的“include&#x2F;linux&#x2F;irqdesc.h”文件，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_common_data</span>	<span class="title">irq_common_data</span>;</span>    <span class="comment">/* 通用中断数据 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span>		<span class="title">irq_data</span>;</span>  <span class="comment">/* 中断数据 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> __percpu	*kstat_irqs;  <span class="comment">/* 中断统计信息 */</span></span><br><span class="line">	<span class="type">irq_flow_handler_t</span>	handle_irq;    <span class="comment">/* 中断处理函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IRQ_PREFLOW_FASTEOI</span></span><br><span class="line">	<span class="type">irq_preflow_handler_t</span>	preflow_handler;   <span class="comment">/* 预处理中断处理函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">action</span>;</span>   * IRQ action <span class="built_in">list</span> */</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		status_use_accessors;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		core_internal_state__do_not_mess_with_it; <span class="comment">/* 内核内部状态标志位，请勿修改 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		depth;     <span class="comment">/* 嵌套中断禁用计数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		wake_depth;   <span class="comment">/* 嵌套唤醒使能计数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		tot_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq_count;     <span class="comment">/* 用于检测损坏的IRQ计数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		last_unhandled;  <span class="comment">/* 未处理计数的老化计时器 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irqs_unhandled; <span class="comment">/* 未处理的中断计数 */</span></span><br><span class="line">	<span class="type">atomic_t</span>		threads_handled;   <span class="comment">/* 处理中断的线程计数 */</span></span><br><span class="line">	<span class="type">int</span>			threads_handled_last;</span><br><span class="line">	<span class="type">raw_spinlock_t</span>		lock;        <span class="comment">/* 自旋锁 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>		*<span class="title">percpu_enabled</span>;</span>      <span class="comment">/* 指向每个CPU的使能掩码 */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>	*<span class="title">percpu_affinity</span>;</span>     <span class="comment">/* 指向每个CPU亲和性掩码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>	*<span class="title">affinity_hint</span>;</span>   <span class="comment">/* CPU亲和性提示 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_affinity_notify</span> *<span class="title">affinity_notify</span>;</span>  <span class="comment">/* CPU亲和性变化通知 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PENDING_IRQ</span></span><br><span class="line">	<span class="type">cpumask_var_t</span>		pending_mask;          <span class="comment">/* 等待处理的中断掩码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		threads_oneshot;</span><br><span class="line">	<span class="type">atomic_t</span>		threads_active;    <span class="comment">/* 活动中的线程计数 */</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span>       wait_for_threads;   <span class="comment">/* 等待线程的等待队列头 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		nr_actions;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		no_suspend_depth;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		cond_suspend_depth;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		force_resume_depth;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>	*<span class="title">dir</span>;</span>       <span class="comment">/* proc文件系统目录项 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_IRQ_DEBUGFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>		*<span class="title">debugfs_file</span>;</span>    <span class="comment">/* 调试文件系统文件 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*dev_name;           <span class="comment">/* 设备名称 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSE_IRQ</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		<span class="title">kobj</span>;</span>  <span class="comment">/* 内核对象 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">request_mutex</span>;</span>   <span class="comment">/* 请求互斥锁 */</span></span><br><span class="line">	<span class="type">int</span>			parent_irq;     <span class="comment">/* 父中断号 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span>        <span class="comment">/* 模块拥有者 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*name;          <span class="comment">/* 中断名称 */</span></span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<p>在irq_desc 结构体中最重要的就是 action 字段，会在下个小节对action 字段进行详细的讲解。</p>
<h2 id="40-4-irqaction-结构体"><a href="#40-4-irqaction-结构体" class="headerlink" title="40.4 irqaction 结构体"></a>40.4 irqaction 结构体</h2><p>irqaction 结构体是 Linux 内核中用于描述中断行为的数据结构之一。它用于定义中断处理过程中的回调函数和相关属性。irqaction 结构体的主要功能是管理与特定中断相关的行为和处理函数。</p>
<p>以下是 irqaction 结构体的主要作用和功能：</p>
<p><em><strong>*（*</strong></em><em><strong>*1*</strong></em><em><strong>*）*</strong></em>****中断处理函数管理****：irqaction 结构体中的 handler 字段保存中断处理函数的指针。该函数在中断发生时被调用，用于处理中断事件。</p>
<p><em><strong>*（*</strong></em><em><strong>*2*</strong></em><em><strong>*）*</strong></em>****中断处理标志管理：****irqaction 结构体中的 flags 字段用于指定中断处理的各种属性和标志。这些标志控制中断处理的行为，例如触发方式、中断类型等。</p>
<p><em><strong>*（*</strong></em><em><strong>*3*</strong></em><em><strong>*）*</strong></em>****设备标识符管理****：irqaction 结构体中的 dev_id 字段用于保存与中断处理相关的设备标识符。它可以是指向设备结构体或其他与设备相关的数据的指针，用于将中断处理与特定设备关联起来。</p>
<p><em><strong>*（*</strong></em><em><strong>*4*</strong></em><em><strong>*）*</strong></em>****中断行为链表管理****：irqaction 结构体中的 next 字段是一个指向下一个 irqaction 结构体的指针，用于构建中断行为的链表。这样可以将多个中断处理函数链接在一起，以便在中断发生时按顺序调用它们。</p>
<p>通过使用 irqaction 结构体，内核可以灵活地定义和管理与特定中断相关的行为和处理函数。它提供了一个统一的接口，用于注册和注销中断处理函数，并提供了必要的属性和数据结构来控制中断处理的行为和顺序。</p>
<p>irqaction 体定义在内核源码的“include&#x2F;linux&#x2F;interrupt.h”文件中如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> &#123;</span></span><br><span class="line">	<span class="type">irq_handler_t</span>		handler;          <span class="comment">// 中断处理函数</span></span><br><span class="line">	<span class="type">void</span>			*dev_id;          <span class="comment">// 设备ID</span></span><br><span class="line">	<span class="type">void</span> __percpu		*percpu_dev_id;   <span class="comment">// 每个CPU的设备ID</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">next</span>;</span>            <span class="comment">// 下一个中断动作结构体</span></span><br><span class="line">	<span class="type">irq_handler_t</span>		thread_fn;        <span class="comment">// 线程处理函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">thread</span>;</span>          <span class="comment">// 线程结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">secondary</span>;</span>       <span class="comment">// 次要中断动作结构体</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq;              <span class="comment">// 中断号</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		flags;            <span class="comment">// 中断标志</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		thread_flags;     <span class="comment">// 线程标志</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		thread_mask;      <span class="comment">// 线程掩码</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*name;            <span class="comment">// 设备名称</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>	*<span class="title">dir</span>;</span>             <span class="comment">// proc文件系统目录项指针</span></span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<h1 id="第41章-中断下文tasklet实验"><a href="#第41章-中断下文tasklet实验" class="headerlink" title="第41章 中断下文tasklet实验"></a>第41章 中断下文tasklet实验</h1><p>在上一个章节中，我们申请GPIO中断，使用的是request_irq,但是request_irq绑定的中断服务程序指的是中断上文。在之前的中断视频中讲解了：中断分为俩个部分——中断上文和中断下文。本章节我们来学习中断下文的一种实现方式——tasklet。</p>
<h2 id="41-1-什么是tasklet"><a href="#41-1-什么是tasklet" class="headerlink" title="41.1 什么是tasklet"></a>41.1 什么是tasklet</h2><p>在Linux内核中，tasklet是一种特殊的软中断机制，被广泛用于处理中断下文相关的任务。它是一种常见且有效的方法，在多核处理系统上可以避免并发问题。Tasklet绑定的函数在同一时间只能在一个CPU上运行，因此不会出现并发冲突。然而，需要注意的是，tasklet绑定的函数中不能调用可能导致休眠的函数，否则可能引起内核异常。</p>
<p>在Linux内核中，tasklet结构体的定义位于include&#x2F;linux&#x2F;interrupt.h头文件中。其原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> state;</span><br><span class="line">    <span class="type">atomic_t</span> count;</span><br><span class="line">    <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet_t</span>;</span></span><br></pre></td></tr></table></figure>

<p>tasklet_struct结构体包含以下成员：</p>
<p>l next:指向下一个tasklet的指针，用于形成链表结构，以便内核中可以同时管理多个tasklet。</p>
<p>l state:表示tasklet的当前状态。</p>
<p>l count:用于引用计数，用于确保tasklet在多个地方调度或取消调度时的正确处理。</p>
<p>l func:指向tasklet绑定的函数的指针，该函数将在tasklet执行时被调用。</p>
<p>l data:传递给tasklet绑定函数的参数</p>
<p>此外，为了方便，还定义了tasklet_t类型作为struct tasklet_struct的别名。这样我们可以使用tasklet_t来声明tasklet变量，而不是直接使用struct tasklet_struct。</p>
<h2 id="41-2-tasklet相关接口函数"><a href="#41-2-tasklet相关接口函数" class="headerlink" title="41.2 tasklet相关接口函数"></a>41.2 tasklet相关接口函数</h2><h3 id="41-2-1-静态初始化函数"><a href="#41-2-1-静态初始化函数" class="headerlink" title="41.2.1 静态初始化函数"></a>41.2.1 静态初始化函数</h3><p>在Linux内核中，有一个用于静态初始化tasklet的宏函数：DECLARE_TASKLET。这个宏函数可以帮助我们更方便地进行tasklet的静态初始化。</p>
<p>宏函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，name是tasklet的名称，func是tasklet的处理函数，data是传递给处理函数的参数。</p>
<p>初始化状态为使能状态。</p>
<p>如果tasklet初始化函数为非使能状态，使用以下宏定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，name是tasklet的名称，func是tasklet的处理函数，data是传递给处理函数的参数。</p>
<p>初始化状态为非使能状态。</p>
<p>下面是一个示例，展示了如何使用DECLARE_TASKLET宏函数进行tasklet的静态初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，my_tasklet是tasklet的名称，my_tasklet_handler是tasklet的处理函数，0是传递给处理函数的参数。但是需要注意的是，使用DECLARE_TASKLET静态初始化的tasklet无法在运行时动态销毁，因此在不需要tasklet时，应该避免使用此方法。如果需要在运行时销毁tasklet，应使用tasklet_init和tasklet_kill函数进行动态初始化和销毁，接下来我们来学习动态初始化函数。</p>
<h3 id="41-2-2-动态初始化函数"><a href="#41-2-2-动态初始化函数" class="headerlink" title="41.2.2 动态初始化函数"></a>41.2.2 动态初始化函数</h3><p> 在Linux内核中，可以使用tasklet_init函数对tasklet进行动态初始化。该函数原型为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，t是指向tasklet结构体的指针，func是tasklet的处理函数，data是传递给处理函数的参数</p>
<p>以下是一个示例，tasklet_init函数进行动态初始化如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在示例中，我们首先定义了my_tasklet_handler作为tasklet的处理函数。然后，声明了一个名为my_tasklet的tasklet结构体。接下来，通过调用tasklet_init函数，进行动态初始化。</p>
<p>通过使用tasklet_init函数，我们可以在运行时动态创建和初始化tasklet。这样，我们可以根据需要灵活地管理和控制tasklet的生命周期。在不再需要tasklet时，可以使用tasklet_kill函数进行销毁，以释放相关资源。</p>
<h3 id="41-2-3-关闭函数"><a href="#41-2-3-关闭函数" class="headerlink" title="41.2.3 关闭函数"></a>41.2.3 关闭函数</h3><p>在Linux内核中，可以使用tasklet_disabled函数来关闭一个已经初始化的tasklet。该函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，t是指向tasklet结构体的指针。</p>
<p>以下是一个示例，使用tasklet_disable函数来关闭tasklet。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先定义了my_tasklet_handler作为tasklet的处理函数。然后，声明了一个名为my_tasklet的tasklet结构体，并使用tasklet_init函数对其进行初始化。最后，通过调用tasklet_disable函数，我们关闭了my_tasklet。</p>
<p>关闭tasklet后，即使调用tasklet_schedule函数触发tasklet，tasklet的处理函数也不会再被执行。这可以用于临时暂停或停止tasklet的执行，直到再次启用（通过调用tasklet_enable函数）。</p>
<p>需要注意的是，关闭tasklet并不会销毁tasklet结构体，因此可以随时通过调用tasklet_enable函数重新启用tasklet，或者调用tasklet_kill函数来销毁tasklet。</p>
<h3 id="41-2-4-使能函数"><a href="#41-2-4-使能函数" class="headerlink" title="41.2.4 使能函数"></a>41.2.4 使能函数</h3><p>在Linux内核中，可以使用tasklet_enable函数来使能（启用）一个已经初始化的tasklet。该函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，t是指向tasklet结构体的指针。</p>
<p>以下是一个示例，展示如何使用tasklet_enable函数来使能tasklet：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先定义了my_tasklet_handler作为tasklet的处理函数。然后，声明了一个名为my_tasklet的tasklet结构体，并使用tasklet_init函数对其进行初始化。最后，通过调用tasklet_enable函数，我们使能（启用）了my_tasklet。</p>
<p>使能tasklet后，如果调用tasklet_schedule函数触发tasklet，则tasklet的处理函数将会被执行。这样，tasklet将开始按计划执行其处理逻辑。</p>
<p>需要注意的是，使能tasklet并不会自动触发tasklet的执行，而是通过调用tasklet_schedule函数来触发。同时，可以使用tasklet_disable函数来临时暂停或停止tasklet的执行。如果需要永久停止tasklet的执行并释放相关资源，则应调用tasklet_kill函数来销毁tasklet。</p>
<h3 id="41-2-5-调度函数"><a href="#41-2-5-调度函数" class="headerlink" title="41.2.5 调度函数"></a>41.2.5 调度函数</h3><p>在Linux内核中，可以使用tasklet_schedule函数来调度（触发）一个已经初始化的tasklet执行。该函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	其中，t是指向tasklet结构体的指针。</p>
<p>以下是一个示例，展示如何使用tasklet_schedule函数来调度tasklet执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先定义了my_tasklet_handler作为tasklet的处理函数。然后，声明了一个名为my_tasklet的tasklet结构体，并使用tasklet_init函数对其进行初始化。最后，通过调用tasklet_schedule函数，我们调度（触发）了my_tasklet的执行。</p>
<p>需要注意的是，调度tasklet只是将tasklet标记为需要执行，并不会立即执行tasklet的处理函数。实际的执行时间取决于内核的调度和处理机制。</p>
<h3 id="41-2-6-销毁函数"><a href="#41-2-6-销毁函数" class="headerlink" title="41.2.6 销毁函数"></a>41.2.6 销毁函数</h3><p>​	在Linux内核中，可以使用tasklet_kill函数来销毁一个已经初始化的tasklet，释放相关资源。该函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，t是指向tasklet结构体的指针。</p>
<p>以下是一个示例，展示如何使用tasklet_kill函数来销毁tasklet：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先定义了my_tasklet_handler作为tasklet的处理函数。然后，声明了一个名为my_tasklet的tasklet结构体，并使用tasklet_init函数对其进行初始化。最后，通过调用tasklet_kill函数，我们销毁了my_tasklet。</p>
<p>调用tasklet_kill函数会释放tasklet所占用的资源，并将tasklet标记为无效。因此，销毁后的tasklet不能再被使用。</p>
<p>需要注意的是，在销毁tasklet之前，应该确保该tasklet已经被停止（通过调用tasklet_disable函数）。否则，销毁一个正在执行的tasklet可能导致内核崩溃或其他错误。</p>
<p>一旦销毁了tasklet，如果需要再次使用tasklet，需要重新进行初始化（通过调用tasklet_init函数）。在下一小节中我们将使用上述tasklet函数相关接口函数进行相应的实验。</p>
<h2 id="41-3-实验程序的编写"><a href="#41-3-实验程序的编写" class="headerlink" title="41.3 实验程序的编写"></a>41.3 实验程序的编写</h2><h3 id="41-3-1-驱动程序编写"><a href="#41-3-1-驱动程序编写" class="headerlink" title="41.3.1 驱动程序编写"></a>41.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\32_tasklet\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中调度中断下文tasklet处理函数，打印“This id test_interrupt”和“<em><strong>*data is*</strong></em> ****1****”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO转换为中断号，并使用request_irq函数请求中断，然后对tasklet进行初始化。在中断处理函数中，我们调度tasklet执行，使得当中断触发时，tasklet会被调度执行。在模块退出函数中，我们释放中断资源，并使能tasklet销毁tasklet。</p>
<p>编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="41-4-运行测试"><a href="#41-4-运行测试" class="headerlink" title="41.4 运行测试"></a>41.4 运行测试</h2><h3 id="41-4-1-编译驱动程序"><a href="#41-4-1-编译驱动程序" class="headerlink" title="41.4.1 编译驱动程序"></a>41.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图41-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps45.jpg" alt="img"></p>
<p>图 41-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图41-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps46.jpg" alt="img"></p>
<p>图 41-2</p>
<p>编译完生成interrupt.ko目标文件，如下图（图41-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps47.jpg" alt="img"></p>
<p>图 41-3</p>
<p>至此驱动模块就编译成功了。</p>
<h3 id="41-4-2-运行测试"><a href="#41-4-2-运行测试" class="headerlink" title="41.4.2 运行测试"></a>41.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 41-4）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps48.jpg" alt="img"> </p>
<p>图 41-4</p>
<p>看到驱动加载之后，可以看到申请的中断号（113）被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，触发中断服务程序，打印如下图（41-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps49.jpg" alt="img"></p>
<p>图 41-5</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”和tasklet处理函数中添加的打印“data is 1”，说明成功执行了中断下文tasklet处理函数。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图图 41-6）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps50.jpg" alt="img"></p>
<p>图 41-6</p>
<p>之前的理论章节我们强调说tasklet函数中不能调用休眠的函数，在此我们在上述驱动实验的基础上实验一下，驱动文件中添加休眠函数，如下（图 41-7）所示：</p>
<p>​	<img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps51.png" alt="img"></p>
<p>图 41-7</p>
<p>同理，进行编译驱动模块，卸载掉之前的驱动模块后，加载新编译的驱动模块，如下图（图 41-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps52.jpg" alt="img"></p>
<p>图 41-8</p>
<p>然后用手触摸连接的LVDS 7寸屏幕，打印如下图（41-9）所示，内核会崩溃。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps53.jpg" alt="img"></p>
<p>图 41-9</p>
<p>至此，中断下文tasklet实验就完成了。</p>
<h1 id="第42章-软中断实验"><a href="#第42章-软中断实验" class="headerlink" title="第42章 软中断实验"></a>第42章 软中断实验</h1><p>在上个章节我们学习了中断下文的一种实验方式——tasklet，本章节我们来学习中断下文的另一种实现方式——软中断。软中断的资料有限，对应的中断号不多，一般用在网络设备驱动，块设备驱动当中。这时本章节要学习的软中断就闪耀登场了。</p>
<h2 id="42-1-什么是软中断"><a href="#42-1-什么是软中断" class="headerlink" title="42.1 什么是软中断"></a>42.1 什么是软中断</h2><p>打开Linux源码linux_sdk&#x2F;kernel&#x2F;include&#x2F;linux&#x2F;interrupt.h文件，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上代码定义了一个枚举类型，用于标识软中断的不同类型或优先级。每个枚举常量对应一个特定的软中断类型。</p>
<p>以下是每个枚举常量的含义：</p>
<p>HI_SOFTIRQ：高优先级软中断</p>
<p>TIMER_SOFTIRQ：定时器软中断</p>
<p>NET_TX_SOFTIRQ：网络传输发送软中断</p>
<p>NET_RX_SOFTIRQ：网络传输接收软中断</p>
<p>BLOCK_SOFTIRQ：块设备软中断</p>
<p>IRQ_POLL_SOFTIRQ：中断轮询软中断</p>
<p>TASKLET_SOFTIRQ：任务软中断</p>
<p>SCHED_SOFTIRQ：调度软中断</p>
<p>HRTIMER_SOFTIRQ, &#x2F;* Unused, but kept as tools rely on the numbering. Sigh! *&#x2F;</p>
<p>RCU_SOFTIRQ,   &#x2F;* Preferable RCU should always be the last softirq *&#x2F;</p>
<p>NR_SOFTIRQS：表示软中断的总数，用于指示软中断类型的数据</p>
<p>中断号的优先级越小，代表优先级越高。在驱动代码中，我们可以使用Linux驱动代码中上述的软中断，当然我们也可以自己添加软中断。我们添加一个自定义的软中断，如下所示，TEST_SOFTIRQ为自定义添加的软中断。</p>
<p>enum</p>
<p>{</p>
<p>​	HI_SOFTIRQ&#x3D;0,</p>
<p>​	TIMER_SOFTIRQ,</p>
<p>​	NET_TX_SOFTIRQ,</p>
<p>​	NET_RX_SOFTIRQ,</p>
<p>​	BLOCK_SOFTIRQ,</p>
<p>​	IRQ_POLL_SOFTIRQ,</p>
<p>​	TASKLET_SOFTIRQ,</p>
<p>​	SCHED_SOFTIRQ,</p>
<p>​	HRTIMER_SOFTIRQ, &#x2F;* Unused, but kept as tools rely on the</p>
<p>​			  numbering. Sigh! *&#x2F;</p>
<p>​	RCU_SOFTIRQ,   &#x2F;* Preferable RCU should always be the last softirq *&#x2F;</p>
<p>​	TEST_SOFTIRQ, &#x2F;&#x2F;添加的自定义软中断</p>
<p>​	NR_SOFTIRQS</p>
<p>};</p>
<p>这里要注意：尽管我们添加一个自定义的软中断非常简单，但是Linux内核的开发者并不希望我们这样去做，如果我们要用软中断，建议使用tasklet。虽然Linux内核开发者不建议自定义软中断，但是我们抱着学习的态度，了解学习下软中断还是很有必要的。上述修改之后，重新编译内核源码，接下来我们来学习下软中断的使用方法。</p>
<h2 id="42-2-软中断接口函数"><a href="#42-2-软中断接口函数" class="headerlink" title="42.2 软中断接口函数"></a>42.2 软中断接口函数</h2><p>软中断的接口函数非常简单，介绍如下所示：</p>
<p>1 注册软中断，使用open_softirq函数，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数的参数如下所示：</p>
<p>nr: 软中断的编号或优先级。它是一个整数，表示要注册的软中断的标识符。</p>
<p>action: 指向一个函数的指针，这个函数将作为软中断的处理程序。该函数接受一个struct softirq_action类型的参数。</p>
<p>2 触发软中断，使用 raise_softirq函数，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数的参数如下所示：</p>
<p>nr: 软中断的编号或优先级。它是一个整数，表示要注册的软中断的标识符。</p>
<p>3 在禁用硬件中断的情况下，触发软中断使用raise_softirq_irqoff函数，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数的参数如下所示：</p>
<p>nr: 软中断的编号或优先级。它是一个整数，表示要注册的软中断的标识符。</p>
<p>在下一小节中将使用上述软中断API进行相应的实验。</p>
<h2 id="42-3-实验程序的编写"><a href="#42-3-实验程序的编写" class="headerlink" title="42.3 实验程序的编写"></a>42.3 实验程序的编写</h2><h3 id="42-3-1-驱动程序编写"><a href="#42-3-1-驱动程序编写" class="headerlink" title="42.3.1 驱动程序编写"></a>42.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\33_softirq\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中触发软中断，打印“This id test_interrupt”和“****This is testsoft_func****”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO转换为中断号，并使用request_irq函数请求中断，然后注册软中断函数。在中断处理函数中，我们触发软中断，使得当中断触发时，软中断处理函数会被调度执行。</p>
<p>接下来我们编写驱动代码，使用软中断来实现中断的下半部分。编写完成的interrupt.c代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="42-4-运行测试"><a href="#42-4-运行测试" class="headerlink" title="42.4 运行测试"></a>42.4 运行测试</h2><h3 id="42-4-1-编译驱动程序"><a href="#42-4-1-编译驱动程序" class="headerlink" title="42.4.1 编译驱动程序"></a>42.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图42-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps54.jpg" alt="img"></p>
<p>图 42-1</p>
<p>然后使用命令“make”进行驱动的编译，编译如下图（图42-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps55.jpg" alt="img"></p>
<p>图 42-2</p>
<p>上图中提示open_softirq和raise_softirq没有被定义，但是为什么还会提示这样的错误呢？</p>
<p>这是因为Linux内核开发者不希望驱动工程师擅自在枚举类型中添加软中断。我们将这俩个函数导出到符号表，修改linux_sdk&#x2F;kernel&#x2F;kernel&#x2F;softirq.c，修改内容如下（图42-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps56.jpg" alt="img"></p>
<p>图42-3</p>
<p>修改完成后，重新编译内核源码，编译源码通过后，再次编译驱动模块，如下图（图 42-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps57.jpg" alt="img"></p>
<p>图 42-4</p>
<p>编译完生成interrupt.ko目标文件，如下图（图42-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps58.jpg" alt="img"></p>
<p>图 42-5</p>
<h3 id="42-4-2-运行测试"><a href="#42-4-2-运行测试" class="headerlink" title="42.4.2 运行测试"></a>42.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图42-6）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps59.jpg" alt="img"></p>
<p>图42-6</p>
<p>驱动加载成功之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，触发中断服务程序，打印如下图（42-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps60.jpg" alt="img"></p>
<p>图 42-7</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”和软中断处理函数中添加的打印“This is testsoft_func”</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图42-8）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps61.jpg" alt="img"></p>
<p>图 42-8</p>
<p>至此，软中断实验就完成了。</p>
<h1 id="第43章-特殊的软中断tasklet分析实验"><a href="#第43章-特殊的软中断tasklet分析实验" class="headerlink" title="第43章 特殊的软中断tasklet分析实验"></a>第43章 特殊的软中断tasklet分析实验</h1><p>Tasklet是Linux内核中的一种软中断机制，它可以被看作是一种轻量级的延迟处理机制。它是通过软中断控制结构来实现的，因此也被称为软中断。本章节我们来从代码层面分析一下为什么tasklet是一个特殊的软中断呢？</p>
<p>软中断处理函数的定义内核源码kernel&#x2F;kernel&#x2F;softirq.c文件中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面开始对上述代码详细解释：</p>
<p>l for_each_possible_cpu(cpu)：遍历每个可能的CPU。在多核系统中，此循环用于初始化每个CPU的tasklet_vec和tasklet_hi_vec。</p>
<p>l per_cpu(tasklet_vec, cpu).tail &#x3D; &amp;per_cpu(tasklet_vec, cpu).head;：将每个CPU的tasklet_vec的tail指针设置为对应的head指针的初始位置。这样做是为了确保tasklet_vec的初始状态是空的。</p>
<p>l per_cpu(tasklet_hi_vec, cpu).tail &#x3D; &amp;per_cpu(tasklet_hi_vec, cpu).head;：将每个CPU的tasklet_hi_vec的tail指针设置为对应的head指针的初始位置。这样做是为了确保tasklet_hi_vec的初始状态是空的。</p>
<p>l open_softirq(TASKLET_SOFTIRQ, tasklet_action);：注册TASKLET_SOFTIRQ软中断，并指定对应的处理函数为tasklet_action。这样，在TASKLET_SOFTIRQ被触发时，将会调用tasklet_action函数来处理相应的任务。</p>
<p>l open_softirq(HI_SOFTIRQ, tasklet_hi_action);：注册HI_SOFTIRQ软中断，并指定对应的处理函数为tasklet_hi_action。这样，在HI_SOFTIRQ被触发时，将会调用tasklet_hi_action函数来处理相应的任务。</p>
<p>在执行__init softirq_init函数时，会触发TASKLET_SOFTIRQ，然后会调用tasklet_action函数，tasklet_action函数如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述函数中调用了tasklet_action_common函数，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>tasklet_action_common函数，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>在上面的代码中，tasklet_action_common()函数对任务链表中的每个tasklet进行处理。它首先禁用本地中断，获取任务链表头指针，清空任务链表，并重新设置尾指针。然后它循环遍历任务链表，对每个tasklet进行处理。如果tasklet的锁获取成功，并且计数器为0，它将执行tasklet的处理函数，并清除状态标志位。如果锁获取失败或计数不为0，它将tasklet添加到任务链表的尾部，并触发指定的软中断。最后，它启用本地中断，完成任务处理过程。</p>
<p>那么tasklet在什么时候加到链表里面的呢？tasklet是通__tasklet_schedule_common()函数加入到链表中的。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过上述代码，__tasklet_schedule_common()函数将tasklet成功添加到链表的末尾。当软中断被触发时，系统会遍历链表并处理每个tasklet。因此，在添加到链表后，tasklet将在适当的时机被系统调度和执行。</p>
<p>经过上述分析，所以说tasklet是一个特殊的软中断。</p>
<p>内核开发者不希望我们去添加软中断的软中断号，更希望我们使用tasklet。那么tasklet相比自己添加软中断有哪些优点和缺点呢？</p>
<p>使用Tasklet相比自己添加软中断有一些优点和缺点。以下是它们的比较：</p>
<p>优点：</p>
<p>\1. 简化的接口和编程模型：Tasklet提供了一个简单的接口和编程模型，使得在内核中处理延迟工作变得更加容易。相比自己添加软中断，Tasklet提供了更高级的抽象。</p>
<p>\2. 低延迟：Tasklet在软中断上下文中执行，避免了内核线程的上下文切换开销，因此具有较低的延迟。这对于需要快速响应的延迟敏感任务非常重要。</p>
<p>\3. 自适应调度：Tasklet具有自适应调度的特性，当多个Tasklet处于等待状态时，内核会合并它们以减少不必要的上下文切换。这种调度机制可以提高系统的效率。</p>
<p>缺点：</p>
<p>\1. 无法处理长时间运行的任务：Tasklet适用于短时间运行的延迟工作，如果需要处理长时间运行的任务，可能会阻塞其他任务的执行。对于较长的操作，可能需要使用工作队列或内核线程来处理。</p>
<p>\2. 缺乏灵活性：Tasklet的执行受限于软中断的上下文，不适用于所有类型的延迟工作。某些情况下，可能需要更灵活的调度和执行机制，这时自定义软中断可能更加适合。</p>
<p>\3. 资源限制：Tasklet的数量是有限的，系统中可用的Tasklet数量取决于架构和内核配置。如果需要大量的延迟工作处理，可能会受到Tasklet数量的限制。</p>
<p>综上所述，Tasklet提供了一种简单且低延迟的延迟工作处理机制，适用于短时间运行的任务和对响应时间敏感的场景。然而，对于长时间运行的任务和需要更灵活调度的情况，自定义软中断可能更合适。在选择使用Tasklet还是自定义软中断时，需要根据具体的需求和系统特性进行权衡和决策。</p>
<h1 id="第44章-共享工作队列实验"><a href="#第44章-共享工作队列实验" class="headerlink" title="第44章 共享工作队列实验"></a>第44章 共享工作队列实验</h1><p>在上个章节我们学习了中断下文的一种实验方式——软中断，本章节我们来学习中断下文的另一种实现方式——工作队列。工作队列是操作系统中管理和调度异步任务执行的一种机制，接下来开始学习工作队列吧。	</p>
<h2 id="44-1-什么是工作队列"><a href="#44-1-什么是工作队列" class="headerlink" title="44.1 什么是工作队列"></a>44.1 什么是工作队列</h2><p>工作队列是实现中断下半部分的机制之一，是一种用于管理任务的数据结构或机制。它通常用于多线程，多进程或分布式系统中，用于协调和分配****待处理的任务*<em><strong>给</strong></em>*可用的工作线程或工作进程****。</p>
<p>工作队列的基本原理是将需要执行的任务按顺序排列在队列中，并提供一组工作线程或者工作进程来处理队列中的任务。当有新的任务到达时，它们会被添加到队列的末尾，工作线程或工作进程从队列的头部获取任务，并执行相应的处理操作。</p>
<p>工作队列和之前学习的tasklet有什么不同呢？tasklet也是实现中断下半部分的机制之一。他们最主要的区别是tasklet不能休眠，而工作队列是可以休眠的，所以tasklet可以用来处理比较耗时间的事情，而工作队列可以处理更耗时间的事情。</p>
<p>工作队列将工作推后以后，会交给内核线程去执行。Linux在启动过程中会创建一个工作者内核线程，这个线程创建以后处于sleep状态。当有工作需要处理的时候，会唤醒这个线程去处理工作。</p>
<p>在内核中，工作队列包括共享工作队列和自定义工作队列这俩种类型。这两种类型的工作队列具有不同的特点和用途。</p>
<p>1  共享队列是由****内核管理****的全局工作队列，用于处理内核中一些系统级任务。共享工作队列是内核中一个默认工作队列，可以由多个内核组件和驱动程序共享使用。</p>
<p>2 自定义工作队列是由****内核或驱动程序创建的****特定工作队列，用于处理特定的任务。自定义工作队列通常与特定的内核模块或驱动程序相关联，用于执行该模块或驱动程序相关的任务。</p>
<p> 本章节我们先来学习共享工作队列相关的知识。 </p>
<p>在Linux 内核中，使用 work_struct 结构体表示一个工作项，这些工作组织成工作队列，工作队列使用 workqueue_struct 结构体表示，如下图所示，流水线相当于工作队列，流水线上一个个等待处理的物料相当于一个个工作。机器相当于内核线程或进程。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps62.jpg" alt="img"> </p>
<p>图 44-1</p>
<p>work_struct 结构体表示一个工作项，定义在include&#x2F;linux&#x2F;workqueue.h中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		</p>
<h2 id="44-2-工作队列相关接口函数"><a href="#44-2-工作队列相关接口函数" class="headerlink" title="44.2 工作队列相关接口函数"></a>44.2 工作队列相关接口函数</h2><h3 id="44-2-1-初始化函数"><a href="#44-2-1-初始化函数" class="headerlink" title="44.2.1 初始化函数"></a>44.2.1 初始化函数</h3><p>在实际的驱动开发中，我们只需要定义工作项(work_struct)即可，关于工作队列和工作者线程我们基本不用去管。简单创建工作很简单，直接定义一个 work_struct 结构体变量即可，然后使用 INIT_WORK 宏来初始化工作，INIT_WORK 宏定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>INIT_WORK 宏接受两个参数：_work 和 _func，分别表示要初始化的工作项和工作项的处理函数。</p>
<p>也可以使用 DECLARE_WORK 宏一次性完成工作的创建和初始化，宏定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数n 表示定义的工作(work_struct)，f 表示工作对应的处理函数。</p>
<h3 id="44-2-2-调度-取消调度工作队列函数"><a href="#44-2-2-调度-取消调度工作队列函数" class="headerlink" title="44.2.2 调度&#x2F;取消调度工作队列函数"></a>44.2.2 调度&#x2F;取消调度工作队列函数</h3><p>和 tasklet 一样，工作也是需要调度才能运行的，工作的调度函数为 schedule_work，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数是指向工作项的指针。这个函数作用是将工作项提交到工作队列中，并请求调度器在合适的时机执行工作项。该函数会返回一个布尔值，表示工作项是否成功被提交到工作队列。</p>
<p>如果想要取消该工作项的调度，使用以下函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数是指向工作项的指针。这个函数的作用是取消该工作项的调度。如果工作项已经在工作队列中，它将被从队列中移除。如果工作项已经在工作队列中，它将被从队列中移除，并等待工作项执行完成。函数返回一个布尔值，表示工作项是否成功取消。</p>
<h2 id="44-3-实验程序的编写"><a href="#44-3-实验程序的编写" class="headerlink" title="44.3 实验程序的编写"></a>44.3 实验程序的编写</h2><h3 id="44-3-1-驱动程序编写"><a href="#44-3-1-驱动程序编写" class="headerlink" title="44.3.1 驱动程序编写"></a>44.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\34_workqueue\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中提交工作项到共享工作队列中，打印“This id test_interrupt”和“****This is test_work****”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO转换为中断号，并使用request_irq函数请求中断，然后初始化工作项。当中断被触发时，中断处理函数被调用，并将工作项提交到共享工作队列中，最终由工作项处理函数异步执行。编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="44-4-运行测试"><a href="#44-4-运行测试" class="headerlink" title="44.4 运行测试"></a>44.4 运行测试</h2><h3 id="44-4-1-编译驱动程序"><a href="#44-4-1-编译驱动程序" class="headerlink" title="44.4.1 编译驱动程序"></a>44.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图44-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps63.jpg" alt="img"></p>
<p>图 44-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图44-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps64.jpg" alt="img"> </p>
<p>图 44-3</p>
<p>编译完生成interrupt.ko目标文件，如下图（图44-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps65.jpg" alt="img"> </p>
<p>图 44-4</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="44-4-2-运行测试"><a href="#44-4-2-运行测试" class="headerlink" title="44.4.2 运行测试"></a>44.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图44-5）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps66.jpg" alt="img"></p>
<p>图44-5</p>
<p>加载驱动之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（44-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps67.jpg" alt="img"></p>
<p>图 44-6</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”被多次打印，说明触发了好几次中断上文，那么中断上文会多次调度中断下文，所以也会打印工作项处理函数中添加的打印“This is test_work”。但是为什么只会打印俩次“This is test_work”呢？这是因为在中断上文调度工作项处理函数之后，内核没有来得及去执行工作项处理函数，没有执行相当于无效操作，有效的执行则打印了俩次“This is test_work”。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图44-7）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps68.jpg" alt="img"></p>
<p>图 44-7</p>
<p>至此，共享工作队列实验就完成了。	</p>
<h1 id="第45章-自定义工作队列实验"><a href="#第45章-自定义工作队列实验" class="headerlink" title="第45章 自定义工作队列实验"></a>第45章 自定义工作队列实验</h1><p>在上一章节中对工作队列以及共享工作队列知识进行了学习，并使用共享队列进行了实验。共享队列是由****内核管理*<em><strong>的全局工作队列，自定义工作队列是由</strong></em>*内核或驱动程序创建的****特定工作队列，用于处理特定的任务。下面就让我们一起来进行自定义工作队列的学习吧。</p>
<h2 id="45-1-工作队列相关结构体"><a href="#45-1-工作队列相关结构体" class="headerlink" title="45.1 工作队列相关结构体"></a>45.1 工作队列相关结构体</h2><p>在Linux内核中，结构体struct work_struct描述的是要延迟执行的工作项，定义在include&#x2F;linux&#x2F;workqueue.h当中，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>  这些工作组织成工作队列，内核使用struct workqueue_struct结构体描述一个工作队列，定义在include&#x2F;linux&#x2F;workqueue.h 当中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="45-2-工作队列相关接口函数"><a href="#45-2-工作队列相关接口函数" class="headerlink" title="45.2 工作队列相关接口函数"></a>45.2 工作队列相关接口函数</h2><p>在Linux内核中，create_workqueue函数用于创建一个工作队列，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数name是创建的工作队列的名字。使用这个函数可以给每个CPU都创建一个CPU相关的工作队列。创建成功返回一个struct workqueue_struct类型指针，创建失败返回NULL。</p>
<p>如果只给一个CPU创建一个CPU相关的工作队列，使用以下函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数name是创建的工作队列的名字。使用这个函数只会给一个CPU创建一个CPU相关的工作队列。创建成功之后返回一个struct workqueue_struct 类型指针，创建失败返回NULL。 </p>
<p>当工作队列创建好之后，需要将要延迟执行的工作项放在工作队列上，调度工作队列，使用queue_work_on函数，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>  该函数有三个参数，第一个参数是一个整数cpu，第二个参数是一个指向struct workqueue_struct的指针wq，第三个参数是一个指向struct work_struct的指针work。</p>
<p>该函数的返回类型是布尔值，表示是否成功调度工作队列。 queue_work_on函数还有其他变种，比如queue_work函数，这里略过，其实思路是一致的，用于将定义好的工作项立即添加到工作队列中，并在工作队列可用时立即执行。</p>
<p>​	如果要取消一个已经调度的工作，使用函数bool cancel_work_sync，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>  函数的作用是取消一个已经调度的工作，如果被取消的工作已经正在执行，则会等待他执行完成再返回。</p>
<p>在Linux 内核中，使用flush_workqueue函数将刷新该工作队列中所有已提交但未执行的工作项。函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p> 该函数参数是一个指向struct workqueue_struct类型的指针wq。函数的作用是刷新工作队列，告诉内核尽快处理工作队列上的工作。</p>
<p>如果要删除自定义的工作队列，使用destroy_workqueue函数，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>  该函数参数是一个指向struct workqueue_struct类型的指针wq。</p>
<p>在下一小节中将使用上述工作队列API函数进行相应的实验。</p>
<h2 id="45-3-实验程序的编写"><a href="#45-3-实验程序的编写" class="headerlink" title="45.3 实验程序的编写"></a>45.3 实验程序的编写</h2><h3 id="45-3-1-驱动程序编写"><a href="#45-3-1-驱动程序编写" class="headerlink" title="45.3.1 驱动程序编写"></a>45.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\35_workqueue_share\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中提交工作项到工作队列中，打印“This id test_interrupt”和“****This is test_work****”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO转换为中断号，并使用request_irq函数请求中断，然后创建自定义工作队列，初始化工作项。当中断被触发时，中断处理函数被调用，并将工作项提交到自定义工作队列中，最终由工作项处理函数异步执行。编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="45-4-运行测试"><a href="#45-4-运行测试" class="headerlink" title="45.4 运行测试"></a>45.4 运行测试</h2><h3 id="45-4-1-编译驱动程序"><a href="#45-4-1-编译驱动程序" class="headerlink" title="45.4.1 编译驱动程序"></a>45.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图45-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps69.jpg" alt="img"> </p>
<p>图 45-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图45-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps70.jpg" alt="img"></p>
<p>图 45-2</p>
<p>编译完生成interrupt.ko目标文件，如下图（图45-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps71.jpg" alt="img"></p>
<p>图 45-3</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="45-4-2-运行测试"><a href="#45-4-2-运行测试" class="headerlink" title="45.4.2 运行测试"></a>45.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图45-4）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps72.jpg" alt="img"> </p>
<p>图45-4</p>
<p>加载驱动之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（45-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps73.jpg" alt="img"> </p>
<p>图 45-5</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”被打印了俩次，说明触发了2次中断上文，那么中断上文会调度2次中断下文，所以也会打印2次工作项处理函数中添加的打印“This is test_work”。</p>
<p>在按屏幕之后，立即输入ps -aux|grep test_workqueue命令可以查看自己创建的工作队列，如下（图 45-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps74.jpg" alt="img"></p>
<p>图 45-6</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图45-7）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps75.jpg" alt="img"></p>
<p>图 45-7</p>
<p>至此，自定义工作队列实验就完成了。</p>
<h1 id="第46章-延迟工作实验"><a href="#第46章-延迟工作实验" class="headerlink" title="第46章 延迟工作实验"></a>第46章 延迟工作实验</h1><p>在之前的章节中，我们学习了共享工作队列和自定义工作队列，为了更形象地理解学习，将流水线比作工作队列，流水线上一个个等待处理的物料比作一个个工作。机器比作内核线程或进程。本章节我们即将学习的延迟工作，可以类比为将物料延迟一定时间，再放到生产线上加工。延迟工作不仅可以在自定义工作队列中实现 也可以在共享工作队列上实现。现在，我们对延迟工作有了一个感性的认识，接下来详细的学习下延迟工作吧。</p>
<h2 id="46-1-什么是延迟工作"><a href="#46-1-什么是延迟工作" class="headerlink" title="46.1 什么是延迟工作"></a>46.1 什么是延迟工作</h2><p>延迟工作是一种将工作的执行延迟到稍后时间点进行处理的技术。通常情况下，当某个任务需要花费较长时间，不需要立即执行或需要按时执行时，延迟工作就会派上用场。</p>
<p>延迟工作的基本思想是将任务放入一个队列中，然后由后台的工作进程会任务调度程序来处理队列中的任务。任务可以在指定的延迟时间后执行，也可以根据优先级，任务类型或者其他条件进行排序和处理。</p>
<p>延迟工作在许多应用场景中都非常有用，尤其是在需要处理大量任务，提供系统性能和可靠性的情况下。以下是一些常用的应用场景：</p>
<p>1 延迟工作常用于处理那些需要花费较长时间的任务，比如发送电子邮件，处理图像等。通过将这些任务放入队列中并延迟执行，可以避免阻塞应用程序的主线程，提高系统的响应速度。</p>
<p>2 延迟工作可以用来执行定时任务，比如定时备份数据库，通过将任务设置为在未来的某个时间点执行，提高系统的可靠性和效率。</p>
<p>为了方便大家理解，我们再举个形象点的例子，比如说开发板上的按键，现在我们想通过驱动程序读取按键的状态，那么只需要读取这个按键所连接的GPIO的状态就可以了。</p>
<p>理想型的按键电压变化过程如图（图 46-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps76.png" alt="img"> </p>
<p>图 46-1</p>
<p>在上图中，按键没有按下的时候按键值为 1，当按键在 t1 时刻按键被按下以后按键值就变为 0，这是最理想的状态。但是实际的按键是机械结构，加上刚按下去的一瞬间人手可能也有抖动，实际的按键电压变化过程如下图（图 46-2）所示：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\ksohtml17816\wps77.png" alt="img"> </p>
<p>图 46-2</p>
<p>在上图中，t1 时刻按键被按下，但是由于抖动的原因，直到 t2 时刻才稳定下来，t1 到t2 这段时间就是抖动。一般这段时间就是十几 ms 左右，从上图中可以看出在抖动期间会有多次触发，如果不消除这段抖动的话软件就会误判，本来按键就按下了一次，结果软件读取IO 值发现电平多次跳变以为按下了多次。所以我们需要跳过这段抖动时间再去读取按键的 IO值，也就是至少要在 t2 时刻以后再去读 IO 值。在之前的驱动视频中，我们使用了定时器来实现消抖。按键采用中断驱动方式，当按键按下以后触发按键中断，在按键中断中开启一个定时器，定时周期为 10ms，当定时时间到了以后就会触发定时器中断，最后在定时器中断处理函数中读取按键的值，如果按键值还是按下状态那就表示这是一次有效的按键。定时器按键消抖如下图（图 46-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps78.png" alt="img"> </p>
<p>图 46-3</p>
<p>在上图中t1<del>t3 这一段时间就是按键抖动，是需要消除的。设置按键为下降沿触发，因此会在 t1、t2 和 t3 这三个时刻会触发按键中断，每次进入中断处理函数都会重新开器定时器中断，所以会在 t1、t2 和 t3 这三个时刻开器定时器中断。但是 t1</del>t2 和 t2~t3 这两个时间段是小于我们设置的定时器中断周期(也就是消抖时间，比如 10ms)，所以虽然 t1 开启了定时器，但是定时器定时时间还没到呢 t2 时刻就重置了定时器，最终只有 t3 时刻开启的定时器能完整的完成整个定时周期并触发中断，我们就可以在中断处理函数里面做按键处理了，这就是定时器实现按键防抖的原理，Linux 里面的按键驱动用的就是这个原理！</p>
<p>除了使用定时器方式进行消抖，也可以使用本章节讲述的延迟工作。在中断下文中将工作延迟3秒之后，再去读GPIO电平状态。</p>
<p>在Linux内核中，使用struct delayed_work来描述延迟工作，定义在include&#x2F;linux&#x2F;workqueue.h当中，原型定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>struct delayed_work结构体包含了两个成员：</p>
<p>1  work：这是一个struct work_struct类型的成员，用于表示延迟工作的基本工作结构。struct work_struct是表示工作的常见数据结构，用于定义要执行的工作内容。</p>
<p>2  timer：这是一个struct timer_list类型的成员，用于管理延迟工作的定时器。struct timer_list是Linux内核中的定时器结构，用于设置延迟时间和触发工作执行的时机。</p>
<p>  使用struct delayed_work结构体，可以将需要执行的工作封装成一个延迟工作，并使用定时器来控制工作的延迟执行。通过设置定时器的延迟时间，可以指定工作在一定时间后执行。</p>
<p>接下来我们学习下延迟工作相关的接口函数吧。</p>
<h2 id="46-2-延迟工作相关接口函数"><a href="#46-2-延迟工作相关接口函数" class="headerlink" title="46.2 延迟工作相关接口函数"></a>46.2 延迟工作相关接口函数</h2><h3 id="46-2-1-初始化延迟工作函数"><a href="#46-2-1-初始化延迟工作函数" class="headerlink" title="46.2.1 初始化延迟工作函数"></a>46.2.1 初始化延迟工作函数</h3><p>静态定义并初始化延迟工作使用宏DECLARE_DELAYED_WORK，函数原型如下所示：	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用宏定义后，可以将上述代码简化为#define DECLARE_DELAYED_WORK(n,f)，n代表延迟工作的变量名，f是延迟工作的处理函数。</p>
<p>动态定义并初始化延迟工作使用宏INIT_DELAYED_WORK，函数原型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用宏定义后，可以将上述代码简化为#define INIT_DELAYED_WORK(_work, _func)， n代表延迟工作的变量名，f是延迟工作的处理函数。</p>
<h3 id="46-2-2-调度-取消调度-延迟工作函数"><a href="#46-2-2-调度-取消调度-延迟工作函数" class="headerlink" title="46.2.2 调度&#x2F;取消调度 延迟工作函数"></a>46.2.2 调度&#x2F;取消调度 延迟工作函数</h3><p>如果是在共享工作队列上调度延迟工作，使用以下函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数是一个内联函数，用于在给定的延迟时间后调度延迟工作执行。</p>
<p>函数参数dwork:是指向延迟工作的指针，即要被调度的延迟工作。</p>
<p>delay:表示延迟的时间长度，以内核时钟节拍数jiffies为单位。</p>
<p>如果是在自定义工作队列上调度延迟工作，使用以下函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数是一个内联函数，用于将延迟工作加入工作队列后在指定的延迟时间后执行。</p>
<p>函数参数wq是指向工作队列结构的指针，即要将延迟工作加入的目标工作队列。</p>
<p>dwork:指向延迟工作的指针，也就是要被加入工作队列的延迟工作。</p>
<p>delay: 表示延迟的时间长度，以内核时钟节拍数jiffies为单位。</p>
<p>如果要取消调度函数，使用以下函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数是一个外部声明的函数，用于取消延迟工作并等待其完成。dwork参数是指向延迟工作的指针，也就是要被取消的延迟工作。函数如果返回true，说明成功取消延迟工作并等待其完成。函数如果返回false，说明无法取消延迟工作或等待其完成。</p>
<p>在下一小节中将在自定义工作队列实验的基础上修改驱动，进行延迟工作实验。</p>
<h2 id="46-3-实验程序的编写"><a href="#46-3-实验程序的编写" class="headerlink" title="46.3 实验程序的编写"></a>46.3 实验程序的编写</h2><h3 id="46-3-1-驱动程序编写"><a href="#46-3-1-驱动程序编写" class="headerlink" title="46.3.1 驱动程序编写"></a>46.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\36_workqueue_delay\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中提交延迟工作项到工作队列中，打印“This id test_interrupt”，并延迟打印“****This is test_work****”。</p>
<p>在驱动程序中的模块初始化函数中，我们将GPIO转换为中断号，并使用request_irq函数请求中断，然后创建自定义工作队列，初始化延迟工作项。当中断被触发时，中断处理函数被调用，并将延迟工作项提交到自定义工作队列中，最终由工作项处理函数异步执行。编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="46-4-运行测试"><a href="#46-4-运行测试" class="headerlink" title="46.4 运行测试"></a>46.4 运行测试</h2><h3 id="46-4-1-编译驱动程序"><a href="#46-4-1-编译驱动程序" class="headerlink" title="46.4.1 编译驱动程序"></a>46.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图46-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps79.jpg" alt="img"></p>
<p>图 46-4</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图46-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps80.jpg" alt="img"></p>
<p>图46-5</p>
<p>编译完生成interrupt.ko目标文件，如下图（图46-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps81.jpg" alt="img"></p>
<p>图 46-6</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="46-4-2-运行测试"><a href="#46-4-2-运行测试" class="headerlink" title="46.4.2 运行测试"></a>46.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图46-7）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps82.jpg" alt="img"></p>
<p>图46-7</p>
<p>加载驱动之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（46-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps83.jpg" alt="img"></p>
<p>图46-8</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”被打印了多次，说明触发了多次中断上文，在4秒之后，打印工作项处理函数中的“This is test_work”。4秒之后打印“This is test_work”是因为调度延迟工作函数写了延迟3秒，再加上工作项处理函数中延迟了一秒，所以一共是4秒。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图46-9）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps84.jpg" alt="img"></p>
<p>图 46-9</p>
<p>至此，延迟工作实验就完成了。</p>
<h1 id="第47章-工作队列传参实验"><a href="#第47章-工作队列传参实验" class="headerlink" title="第47章 工作队列传参实验"></a>第47章 工作队列传参实验</h1><p>在41章节中，我们使用tasklet来实现中断下文，并使用tasklet给中断下文传参，如果我们使用工作队列来实现中断的下半部分，那么如何用工作队列给中断下文传参呢？本章节我们来一探究竟！</p>
<h2 id="47-1-工作队列传参"><a href="#47-1-工作队列传参" class="headerlink" title="47.1 工作队列传参"></a>47.1 工作队列传参</h2><p>在Linux内核的工作队列中，可以通过使用工作项的方式向工作队列传递参数。工作项是一个抽象的结构，可以用于封装需要执行的工作及其相关的参数。</p>
<p>首先我们定义工作项结构，如下所示，在结构体struct work_data中定义了需要传递给工作项处理函数的参数a和b，然后定义一个类型为struct work_data 的变量test_workqueue_work。</p>
<p>struct work_data {</p>
<p> struct work_struct test_work;</p>
<p> int a;</p>
<p> int b;</p>
<p>};  </p>
<p>struct work_data test_workqueue_work;</p>
<p>接下来在模块初始化函数interrupt_irq_init 中创建了一个工作队列test_workqueue 和一个工作项 test_workqueue_work。</p>
<p>test_workqueue &#x3D; create_workqueue(“test_workqueue”); &#x2F;&#x2F; 创建工作队列</p>
<p>INIT_WORK(&amp;test_workqueue_work.test_work, test_work); &#x2F;&#x2F; 初始化工作项</p>
<p>然后在模块初始化函数中，为工作项的参数 a 和 b 赋值。</p>
<p>test_workqueue_work.a &#x3D; 1;</p>
<p>test_workqueue_work.b &#x3D; 2;</p>
<p>当中断触发时，在中断处理函数 test_interrupt 中，通过调用 queue_work 函数将工作项 test_workqueue_work.test_work 提交到工作队列 test_workqueue 中。</p>
<p>queue_work(test_workqueue, &amp;test_workqueue_work.test_work);</p>
<p>然后工作项处理函数 test_work 定义了一个指针 pdata，将工作项转换为 struct work_data 结构，并通过该结构访问参数 a 和 b。如下所示：</p>
<p>void test_work(struct work_struct *work)</p>
<p>{</p>
<p> struct work_data *pdata;</p>
<p> pdata &#x3D; container_of(work, struct work_data, test_work);</p>
<p> printk(“a is %d\n”, pdata-&gt;a);</p>
<p> printk(“b is %d\n”, pdata-&gt;b);</p>
<p>}</p>
<p>这样，当工作队列被调度执行时，工作项处理函数test_work将能够访问到传递给工作项的参数a和b,并在内核日志中打印他们的值。</p>
<p>注意，工作项处理函数中的 container_of 宏用于从工作项结构的指针获取整个 struct work_data 结构的指针。这样可以通过指针偏移来访问工作项结构中的其他字段，例如参数 a 和 b。</p>
<p>详细的驱动代码编写见下一小节。</p>
<h2 id="47-2实验程序的编写"><a href="#47-2实验程序的编写" class="headerlink" title="47.2实验程序的编写"></a>47.2实验程序的编写</h2><h3 id="47-2-1-驱动程序编写"><a href="#47-2-1-驱动程序编写" class="headerlink" title="47.2.1 驱动程序编写"></a>47.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\37_workqueue_data\module。</p>
<p>编写完成的interrupt.c代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="47-3-运行测试"><a href="#47-3-运行测试" class="headerlink" title="47.3 运行测试"></a>47.3 运行测试</h2><h3 id="47-3-1-编译驱动程序"><a href="#47-3-1-编译驱动程序" class="headerlink" title="47.3.1 编译驱动程序"></a>47.3.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>.对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图47-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps85.jpg" alt="img"></p>
<p>图 47-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图47-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps86.jpg" alt="img"></p>
<p>图 47-2</p>
<p>编译完生成interrupt.ko目标文件，如下图（图47-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps87.jpg" alt="img"></p>
<p>图 47-3</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="47-3-2-运行测试"><a href="#47-3-2-运行测试" class="headerlink" title="47.3.2 运行测试"></a>47.3.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图47-4）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps88.jpg" alt="img"> </p>
<p>图47-4</p>
<p>驱动加载之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（47-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps89.jpg" alt="img"> </p>
<p>图 47-5</p>
<p>在上图中，可以看到打印中断处理函数中添加的打印“This is test_interrupt”和传递给工作项的参数a和b的值。</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图47-6）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps90.jpg" alt="img"> </p>
<p>图 47-6</p>
<p>至此，工作队列传参实验就完成了。</p>
<h1 id="第48章-并发管理工作队列实验"><a href="#第48章-并发管理工作队列实验" class="headerlink" title="第48章 并发管理工作队列实验"></a>第48章 并发管理工作队列实验</h1><p>在现代的软件开发中，我们常常面临着需要同时处理多个任务的挑战。这些任务可能是并行的、独立的，或者需要以某种顺序进行处理。为了高效地管理这些并发任务，我们需要一种有效的机制来协调它们的执行。这就是并发管理工作队列发挥作用的地方。本章节我们来学习并发管理工作队列。</p>
<h2 id="48-1工作队列的实现"><a href="#48-1工作队列的实现" class="headerlink" title="48.1工作队列的实现"></a>48.1工作队列的实现</h2><p>在44章节和45章节，我们学习了共享工作队列和自定义工作队列，在使用工作队列时，我们首先定义一个work结构体，然后将work添加到workqueue(工作队列)中，最后worker thread 执行workqueue。当工作队列中有新work产生时，工作线程（worker thread）会执行工作队列中每个work。当执行完结束的时候，worker thread会睡眠，等到新的中断产生，work再继续添加到工作队列，然后工作线程执行每个工作，周而复始。</p>
<p>在单核线程的系统中，通常会为每个 CPU（核心）初始化一个工作线程并关联一个工作队列。这种默认设置确保每个CPU都有一个专门的线程来处理与其绑定的工作队列上的工作项。如下图（48-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps91.jpg" alt="img"> </p>
<p>图 48-1</p>
<p>在多核线程系统中，工作队列的设计与单核线程系统有所不同。在多核线程系统中，通常会存在多个工作队列，每个工作队列与一个工作线程（Worker Thread）绑定。这样可以充分利用多个核心的并行处理能力。如下图（48-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps92.jpg" alt="img"></p>
<p>图 48-2</p>
<p>当有新的工作项产生时，系统需要决定将其分配给哪个工作队列。一种常见的策略是使用负载均衡算法，根据工作队列的负载情况来平衡分配工作项，以避免某个工作队列过载而导致性能下降。每个工作队列独立管理自己的工作项。当有新的工作项添加到工作队列时，工作线程会从其关联的工作队列中获取待执行的工作项，并执行相应的处理函数。在多核线程系统中，多个工作线程可以同时执行各自绑定的工作队列中的工作项。这样可以实现并行处理，提高系统的整体性能和响应速度。</p>
<p>了解了工作队列是如何实现的，接下来我们看看传统的工作队列有什么弊端呢？</p>
<h2 id="48-2-workqueue队列弊端"><a href="#48-2-workqueue队列弊端" class="headerlink" title="48.2 workqueue队列弊端"></a>48.2 workqueue队列弊端</h2><p>假如说有三个work放到了同一个工作队列上，接下来CPU会启动工作线程去执行这三个work，如下图（48-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps93.jpg" alt="img"> </p>
<p>图 48-3</p>
<p>在上图中，工作项w0、w1、w2被排队到同一个CPU上的绑定工作队列上。w0工作项执行的时候，先工作 5毫秒，然后睡觉10毫秒，然后再工作CPU 5毫秒，然后完成。工作项w1和w2都是工作5ms，然后睡眠10 ms，然后完成。传统工作队列的弊端如下所示：</p>
<p>1 在工作项w0 工作甚至是睡眠时，工作项w1 w2是排队等待的，在繁忙的系统中，工作队列可能会积累大量的待处理工作项，导致任务调度的延迟，这可能会影响系统的响应性能，并增加工作项的处理时间。</p>
<p>2 在工作队列中，不同的工作项可能具有不同的处理时间和资源需求。如果工作项的处理时间差异很大，一些工作线程可能会一直忙于处理长时间的工作项，而其他工作线程则处于空闲状态，导致资源利用不均衡。</p>
<p>3 在多线程环境下，多个工作线程同时访问和修改工作队列可能会导致竞争条件的发生。为了确保数据的一致性和正确性，需要采用适当的同步机制，如锁或原子操作，来保护共享数据，但这可能会引入额外的同步开销。</p>
<p>4 工作队列通常按照先进先出（FIFO）的方式处理工作项，缺乏对工作项优先级的细粒度控制。在某些场景下，可能需要根据工作项的重要性或紧急程度进行优先级调度，而工作队列本身无法提供这种级别的优先级控制。</p>
<p>5 当工作线程从工作队列中获取工作项并执行时，可能需要频繁地进行上下文切换，将处理器的执行上下文从一个线程切换到另一个线程。这种上下文切换开销可能会影响系统的性能和效率。</p>
<h2 id="48-2-什么是并发管理工作队列"><a href="#48-2-什么是并发管理工作队列" class="headerlink" title="48.2 什么是并发管理工作队列"></a>48.2 什么是并发管理工作队列</h2><p>通过上一小节的学习，我们认识到传统的工作队列无论是单核系统还是多核系统上都是有缺陷的。比如无法充分利用多核处理器的计算能力以及对于不同优先级的工作项无法提供公平的调度。为了解决这些问题，Con Kolivas提出了CMWQ调度算法。</p>
<p>CMWQ 全称是concurrency Managed Workqueue，意为并发管理工作队列。并发管理工作队列是一种并发编程模式，用于有效地管理和调度待执行的任务或工作项。它通常用于多线程或多进程环境中，以实现并发执行和提高系统的性能。CMWQ 工作实现如下图（48-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps94.jpg" alt="img"> </p>
<p>图 48-4</p>
<p>当我们需要在一个系统中同时处理多个任务或工作时，使用并发管理工作队列是一种有效的方式。</p>
<p>想象一下，你是一个餐厅的服务员，有很多顾客同时来到餐厅用餐。为了提高效率，你需要将顾客的点菜请求放到一个队列中，这就是工作队列。然后，你和其他服务员可以从队列中获取顾客的点菜请求，每个服务员独立地为顾客提供服务。通过这种方式，你们可以并发地处理多个顾客的点菜请求，而不需要等待上一个顾客点完菜再去处理下一个顾客的请求。每个服务员可以独立地从队列中获取任务，并根据需要执行相应的服务。这种独立获取任务的过程就是从工作队列中取出任务并执行的过程。</p>
<p>通过并发管理工作队列，你们能够更高效地处理顾客的点菜请求，提高服务的速度和质量。同时，这种方式也能够更好地利用你们的工作能力，因为每个服务员都可以独立处理任务，而不会相互干扰或等待。</p>
<p>总的来说，通过并发管理工作队列，我们可以同时处理多个任务或工作，提高系统的并发性和性能。每个任务独立地从队列中获取并执行，这种解耦使得整个系统更加高效、灵活，并且能够更好地应对多任务的需求。</p>
<h2 id="48-3-并发管理工作队列接口函数"><a href="#48-3-并发管理工作队列接口函数" class="headerlink" title="48.3 并发管理工作队列接口函数"></a>48.3 并发管理工作队列接口函数</h2><p>​	alloc_workqueue是Linux内核中的一个函数，用于创建和分配一个工作队列。工作队列是一种用于管理和调度工作项的机制，可用于实现并发处理和异步任务处理。alloc_workqueue函数的原型如下：</p>
<p>struct workqueue_struct *alloc_workqueue(const char *fmt, unsigned int flags, int max_active);</p>
<p>参数说明：</p>
<p>****fmt：****指定工作队列的名称格式。</p>
<p>****flags****：指定工作队列的标志，可以控制工作队列的行为和属性，如WQ_UNBOUND表示无绑定的工作队列，WQ_HIGHPRI表示高优先级的工作队列等。</p>
<p>****max_active****：指定工作队列中同时活跃的最大工作项数量。</p>
<p>函数返回一个指向工作队列结构体（struct workqueue_struct）的指针，或者返回NULL表示创建失败。</p>
<p>在下一小节中将使用上述API进行相应的实验。</p>
<h2 id="48-4-实验程序的编写"><a href="#48-4-实验程序的编写" class="headerlink" title="48.4 实验程序的编写"></a>48.4 实验程序的编写</h2><h3 id="45-4-1-驱动程序编写"><a href="#45-4-1-驱动程序编写" class="headerlink" title="45.4.1 驱动程序编写"></a>45.4.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\38_CMWQ\module。</p>
<p>本实验在35自定义工作队列实验的基础上进行修改，使用alloc_workqueue函数创建和分配一个工作队列。编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="48-5-运行测试"><a href="#48-5-运行测试" class="headerlink" title="48.5 运行测试"></a>48.5 运行测试</h2><h3 id="48-5-1-编译驱动程序"><a href="#48-5-1-编译驱动程序" class="headerlink" title="48.5.1 编译驱动程序"></a>48.5.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图48-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps95.jpg" alt="img"> </p>
<p>图 48-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图48-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps96.jpg" alt="img"></p>
<p>图 48-6</p>
<p>编译完生成interrupt.ko目标文件，如下图（图48-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps97.jpg" alt="img"> </p>
<p>图 48-7</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="48-5-2-运行测试"><a href="#48-5-2-运行测试" class="headerlink" title="48.5.2 运行测试"></a>48.5.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图48-8）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps98.jpg" alt="img"></p>
<p>图48-8</p>
<p>驱动加载之后，可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（48-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps99.jpg" alt="img"></p>
<p>图 48-9</p>
<p>我们按一下屏幕，立即输入“ps -aux | grep test_workqueue”,可以看到工作线程，如下图（48-10）所示，u代表无绑定的工作队列。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps100.jpg" alt="img"></p>
<p>图 48-10</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图48-11）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps101.jpg" alt="img"></p>
<p>图 48-11</p>
<p>至此，并发管理工作队列实验就完成了。	</p>
<h1 id="第49章-中断线程化实验"><a href="#第49章-中断线程化实验" class="headerlink" title="第49章 中断线程化实验"></a>第49章 中断线程化实验</h1><p>中断线程化是实时Linux项目开发的一个新特性，目的是降低中断处理对系统实时延迟的影响。本章节我们来一项新技术——中断线程化。</p>
<h2 id="49-1什么是中断线程化"><a href="#49-1什么是中断线程化" class="headerlink" title="49.1什么是中断线程化"></a>49.1什么是中断线程化</h2><p>中断线程化是一种优化技术，用于提高多线程程序的性能。</p>
<p>想象一下，你正在做一项任务，但是总是被别人的打扰所中断，每次都要停下手头的工作去处理别人的事情。这样频繁的中断会让你的工作效率变低，因为你需要反复切换任务，无法专心做好自己的工作。</p>
<p>在多线程程序中，也存在类似的问题。有时硬件或其他事件会发出中断信号，打断正在执行的线程，需要切换到中断处理程序去处理这些事件。这种频繁的中断切换会导致额外的开销和延迟，影响程序的性能。</p>
<p>为了解决这个问题，中断线程化提出了一种优化方案。它将中断处理程序从主线程中独立出来，创建一个专门的线程来处理这些中断事件。这样，主线程就不再受到中断的干扰，可以专注于自己的工作，不再频繁地被打断。</p>
<p>中断线程化的核心思想是将中断处理和主线程的工作分开，让它们可以并行执行。中断线程负责处理中断事件，而主线程负责执行主要的工作任务。这样一来，不仅可以减少切换的开销，还可以提高整个程序的响应速度和性能。</p>
<p>需要注意的是，中断线程化还需要处理线程之间的同步和数据共享问题。因为中断线程和主线程可能会同时访问和修改共享的数据，所以需要合理地进行同步操作，确保数据的一致性和正确性。</p>
<p>总而言之，中断线程化是一种优化技术，通过将中断处理和主线程的工作分开，提高多线程程序的性能。让主线程不再频繁被中断，可以专注于自己的工作，从而提高程序的效率和响应速度。</p>
<p>中断线程化的处理仍然可以看作是将原来的中断上半部分和中断下半部分。上半部分还是用来处理紧急的事情，下半部分也是出路比较耗时的操作，但是下半部分会交给一个专门的内核线程来处理。这个内核线程只用于这个中断。当发生中断的时候，会唤醒这个内核线程，然后由这个内核线程来执行中断下半部分的函数。</p>
<h2 id="49-2-中断线程化接口函数"><a href="#49-2-中断线程化接口函数" class="headerlink" title="49.2 中断线程化接口函数"></a>49.2 中断线程化接口函数</h2><p>request_threaded_irq 是 Linux 内核中用于请求并注册一个线程化的中断处理函数的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p><em><strong>*参数说明*</strong></em></p>
<p>****irq****：中断号，表示要请求的中断线路。</p>
<p>****handler****：是在发生中断时首先要执行的处理程序，非常类似于顶半部，该函数最后会返回IRQ_WAKE_THREAD来唤醒中断，一般handler设为NULL，用系统提供的默认处理。</p>
<p>****thread_fn****：线程化的中断处理函数，非常类似于底半部。如果此处设置为NULL 则表示没有使用中断线程化。</p>
<p>****irqflags****：中断标志，用于指定中断的属性和行为。</p>
<p>****devname****：中断的名称，用于标识中断请求的设备。</p>
<p>****dev_id****：设备标识符，用于传递给中断处理函数的参数。</p>
<p><em><strong>*函数返回值*</strong></em></p>
<p>  函数返回一个整数值，表示中断请求的结果。如果中断请求成功，返回值为0，否则返回一个负数错误代码。</p>
<p>在下一小节中将使用上述API进行相应的实验，利用中断线程化相关知识来对共享工作队列实验进行优化。</p>
<h2 id="49-3-实验程序的编写"><a href="#49-3-实验程序的编写" class="headerlink" title="49.3 实验程序的编写"></a>49.3 实验程序的编写</h2><h3 id="49-3-1-驱动程序编写"><a href="#49-3-1-驱动程序编写" class="headerlink" title="49.3.1 驱动程序编写"></a>49.3.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\39_request_threaded_irq\module。</p>
<p>本实验将实现注册显示屏触摸中断，每按当触摸LCD显示屏就会触发中断服务函数，在中断服务函数中提交工作项到工作队列中，打印“This id test_interrupt”，并打印“****This is test_work****”。</p>
<p>我们要实现一个简单的中断处理的例子，用于展示中断的顶半部和底半部处理的概念，并通过线程化的工作队列实现了底半部的延时处理。编写完成的interrupt.c代码如下所示，添加的代码已加粗表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="49-4-运行测试"><a href="#49-4-运行测试" class="headerlink" title="49.4 运行测试"></a>49.4 运行测试</h2><h3 id="49-4-1-编译驱动程序"><a href="#49-4-1-编译驱动程序" class="headerlink" title="49.4.1 编译驱动程序"></a>49.4.1 编译驱动程序</h3><p>在上一小节中的interrupt.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放interrupt.c和Makefile文件目录下，如下图（图49-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps102.jpg" alt="img"></p>
<p>图 49-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图49-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps103.jpg" alt="img"></p>
<p>图 49-2</p>
<p>编译完生成interrupt.ko目标文件，如下图（图49-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps104.jpg" alt="img"></p>
<p>图 49-3</p>
<p>至此驱动模块就编译成功了，接下来进行测试。</p>
<h3 id="49-4-2-运行测试"><a href="#49-4-2-运行测试" class="headerlink" title="49.4.2 运行测试"></a>49.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图49-4）所示：</p>
<p>insmod interrupt.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps105.jpg" alt="img"></p>
<p>图49-4</p>
<p>可以看到申请的中断号被打印了出来，然后用手触摸连接的LVDS 7寸屏幕，打印如下图（49-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps106.jpg" alt="img"></p>
<p>图 49-5</p>
<p>我们按一下屏幕，立即输入“ps -aux | grep test_workqueue”,可以看到工作线程，如下图（49-6）所示，u代表无绑定的工作队列。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps107.jpg" alt="img"></p>
<p>图 49-6</p>
<p>最后可以使用以下命令进行驱动的卸载，如下图（图49-7）所示：</p>
<p>rmmod interrupt</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps108.jpg" alt="img"></p>
<p>图 49-7</p>
<p>至此，中断线程化实验就完成了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%94%E7%AF%87-%E4%B8%AD%E6%96%AD/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD/" rel="tag">中断</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E5%85%AD%E7%AF%87-%E5%B9%B3%E5%8F%B0%E6%80%BB%E7%BA%BF/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            rk3568 驱动开发第六篇 平台总线
          
        </div>
      </a>
    
    
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E5%9B%9B%E7%AF%87-%E9%AB%98%E7%BA%A7%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E8%BF%9B%E9%98%B6/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">rk3568 驱动开发第四篇 高级字符设备进阶</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="热爱学习的未来酱"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>