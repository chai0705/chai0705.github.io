<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="永远年轻，永远热泪盈眶" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>rk3568 驱动开发第二篇 字符设备基础 |  热爱学习的未来酱</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="热爱学习的未来酱" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-rk3568-驱动开发第二篇-字符设备基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  rk3568 驱动开发第二篇 字符设备基础
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%8C%E7%AF%87-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2023-09-04T12:55:19.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">29.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">120 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第7章-menuconfig图形化配置实验"><a href="#第7章-menuconfig图形化配置实验" class="headerlink" title="第7章 menuconfig图形化配置实验"></a>第7章 menuconfig图形化配置实验</h1><p>Linux内核可以通过输入“make menuconfig”来打开图形化配置界面，menuconfig是一套图形化的配置工具，本章节来学习使用menuconfig配置内核。</p>
<h2 id="7-1图形化界面的操作"><a href="#7-1图形化界面的操作" class="headerlink" title="7.1图形化界面的操作"></a>7.1图形化界面的操作</h2><p>menuconfig图形化的配置工具需要 ncurses 库支持。ncurses库提供了一系列的API函数供调用者生成基于文本的图形界面，因此在使用menuconfig图形化配置界面之前需要先在 Ubuntu 中安装ncurses库，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line"></span><br><span class="line">sudo apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure>

<p>图形化配置界面主要有以下四种，在这四种方式中，最推荐的是 make menuconfig，它不依赖于 QT 或 GTK+，且非常直观。</p>
<p>make config （基于文本的最为传统的配置界面，不推荐使用）</p>
<p>make menuconfig （基于文本菜单的配置界面）</p>
<p>make xconfig （要求 QT 被安装）</p>
<p>make gconfig （要求 GTK+ 被安装）</p>
<p>如何打开menuconfig图形化配置界面呢？</p>
<p>以RK3568为例，在内核源码目录下输入以下命令，打开图形化配置界面。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm64</span><br><span class="line"></span><br><span class="line">make rockchip_linux_defconfig</span><br><span class="line"></span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps33.jpg" alt="img"> </p>
<p>图 7-1</p>
<p>打开后界面如下所（图7-2）示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps34.jpg" alt="img"> </p>
<p>图 7-2</p>
<p>打开menuconfig图形化配置界面以后，可以使用以下方式进行操作，如下表（表7-3）所示：</p>
<table>
<thead>
<tr>
<th>上下键</th>
<th>选择不同的行，即移动到不同的（每一行的）选项上</th>
</tr>
</thead>
<tbody><tr>
<td>空格键</td>
<td>用于在选择该选项，取消选择该选项之间来回切换</td>
</tr>
<tr>
<td>选择该（行所在的）选项</td>
<td>则对应的该选项前面就变成了 [ * ]，表示被选中了。把驱动编译编译成模块，用 M 来表示。把驱动编译到内核里面，用*来表示。</td>
</tr>
<tr>
<td>取消该选项</td>
<td>则对应的该选项变成了只有一个中括号，里面是空的，即：[ ]</td>
</tr>
<tr>
<td>左右键</td>
<td>用于在 Select&#x2F;Exit&#x2F;Help 之前切换</td>
</tr>
<tr>
<td>回车键</td>
<td>左右键切换到了某个键上，此时回车键，就执行相应的动作</td>
</tr>
<tr>
<td>Select</td>
<td>此时一般都是所在（的行的）选项，后面有三个短横线加上一个右箭头，即 —&gt;，表示此项下面还有子选项，即进入子菜单</td>
</tr>
<tr>
<td>Exit</td>
<td>直接退出当前的配置。所以，当你更改了一些配置，但是又没有去保存，此时一般都会询问你是否要保存当前（已修改后的最新的）配置，然后再退出。</td>
</tr>
<tr>
<td>Help</td>
<td>针对你当前所在某个（行的）选项，查看其帮助信息。一般来说，其帮助信息，都包含针对该选项的很详细的解释。换句话说：如果你对某个选项的功能，不是很清楚，那么就应该认真仔细的去看看其 Help，往往都会找到详细解释，以便你更加了解此配置的含义。另外一般也会写出，此选项所对应的宏。该宏，就是写出到配置文件中的那个宏，对于写 makefile 的人来说，往往也是利用此相关的宏，在 makefile 中，实现对应的不同的控制。</td>
</tr>
<tr>
<td>快捷键快速跳转到对应的选项</td>
<td>menuconfig 中的每一行的选项，都有一个用特殊颜色标记出来的字母，很明显，此字母，就是该行的快捷字母。注意：此类快捷字母，一般都是大写的，且是大小写区分的</td>
</tr>
<tr>
<td>&#x2F; 键</td>
<td>输入“&#x2F;”即可弹出搜索界面，然后输入我们想要搜索的内容即可。</td>
</tr>
</tbody></table>
<p>表 7-3</p>
<h2 id="7-2-Kconfig-语法简介"><a href="#7-2-Kconfig-语法简介" class="headerlink" title="7.2 Kconfig 语法简介"></a>7.2 Kconfig 语法简介</h2><p>上一小节我们打开的图形化配置界面是如何生成的呢？图形化配置界面中的每一个界面都会对应一个Kconfig文件。所以图形化配置界面的每一级菜单是由Kconfig文件来决定的。</p>
<p>图形化配置界面有很多菜单。所以就会有很多Kconfig文件，这也就是为什么我们会在内核源码的每个子目录下，都会看到Kconfig文件的原因，那掌握Kconfig文件相关的知识是不是就非常重要呢。</p>
<p>所以这一小节我们来看下如何编写Kconfig文件来生成图形化配置界面，也就是Kconfig文件的语法是什么。</p>
<p>\1. Mainmenu</p>
<p>mainmenu顾名思义就是主菜单，也就是我们输入完“make menuconfig”以后默认打开的界面，mainmenu用来设置主菜单的标题，如下所示：</p>
<p>mainmenu “Linux&#x2F;$(ARCH) $(KERNELVERSION) Kernel Configuration”</p>
<p>此行代码是设置菜单的名字为“Linux&#x2F;$(ARCH) $(KERNELVERSION) Kernel Configuration”。如下图（图7-4）所示，ARCH变量是通过“export ARCH&#x3D;arm64”设置的，内核版本KERNELVERSION为4.19.232。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps35.jpg" alt="img"> </p>
<p>图 7-4</p>
<p>2.source</p>
<p>source用于读取另一个Kconfig文件，比如“source “init&#x2F;Kconfig””就是读取init目录下的Kconfig文件。</p>
<p>3.menu&#x2F;endmenu</p>
<p>menu&#x2F;endmenu条目用于生成菜单，如下（图7-5）所示，生成了Watchdog Timer Support的菜单。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">menu <span class="string">&quot;Watchdog Timer Support&quot;</span></span><br><span class="line"> </span><br><span class="line">config HW_WATCHDOG</span><br><span class="line">	bool</span><br><span class="line"> </span><br><span class="line">config WDT</span><br><span class="line">	bool <span class="string">&quot;Enable driver model for watchdog timer drivers&quot;</span></span><br><span class="line">	depends on DM</span><br><span class="line">	help</span><br><span class="line">	  Enable driver model for watchdog timer. At the moment the API.</span><br><span class="line">......</span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure>

<p>图 7-5</p>
<p>menu之后的字符串是菜单名，“menu”是菜单开始的标志，“endmenu”是菜单结束的标志，这俩个是成对出现的。“menu”和“endmenu”之间有很多config条目。在kernel目录下输入make menuconfig，如下图（图7-6）所示，可以看到上述代码描述的”Watchdog Timer Support”菜单。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps36.jpg" alt="img"> </p>
<p>图 7-6</p>
<p>进入“ Watchdog Timer Support  —&gt; ”可以看到很多config定义的条目，如下（图7-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps37.jpg" alt="img"> </p>
<p>图 7-7</p>
<p>4.if&#x2F;endif</p>
<p>if&#x2F;endif 语句是一个条件判断，定义了一个 if 结构，Kconfig中代码如下（图7-8）所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">menu &quot;Hardware Drivers Config&quot;</span><br><span class="line">    menuconfig BSP_USING_CAN</span><br><span class="line">        bool &quot;Enable CAN&quot;</span><br><span class="line">        default n</span><br><span class="line">        select RT_USING_CAN</span><br><span class="line">        if BSP_USING_CAN</span><br><span class="line">            config BSP_USING_CAN1</span><br><span class="line">                bool &quot;Enable CAN1&quot;</span><br><span class="line">                default n</span><br><span class="line">        endif</span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure>

<p>图 7-8</p>
<p>当没有选中 “Enable CAN” 选项时，下面通过 if 判断的 Enable CAN1 选项并不会显示出来。当上一级菜单选中 “Enable CAN” 时，Enable CAN1 选项才会显示。</p>
<p>\5. choice&#x2F;endchooice</p>
<p>choice条目将多个类似的配置选项组合到一起，供用户选择，用户选择是从“choice”开始，从“endchoice”结束，“choice”和“endchoice”之间有很多的config条目，这些config条目是提供用户选择的，如下（图7-9）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">choice</span><br><span class="line">        bool <span class="string">&quot;Parade TrueTouch Gen5 MultiTouch Protocol&quot;</span></span><br><span class="line">        depends on TOUCHSCREEN_CYPRESS_CYTTSP5</span><br><span class="line">        default TOUCHSCREEN_CYPRESS_CYTTSP5_MT_B</span><br><span class="line">        help</span><br><span class="line">          This option controls which MultiTouch protocol will be used to</span><br><span class="line">          report the touch events.</span><br><span class="line">config TOUCHSCREEN_CYPRESS_CYTTSP5_MT_A</span><br><span class="line">        bool <span class="string">&quot;Protocol A&quot;</span></span><br><span class="line">        help</span><br><span class="line">          Select to enable MultiTouch touch reporting using protocol A</span><br><span class="line">          on Parade TrueTouch(tm) Standard Product Generation4 touchscreen</span><br><span class="line">          controller.</span><br><span class="line"> </span><br><span class="line">config TOUCHSCREEN_CYPRESS_CYTTSP5_MT_B</span><br><span class="line">        bool <span class="string">&quot;Protocol B&quot;</span></span><br><span class="line">        help</span><br><span class="line">          Select to enable MultiTouch touch reporting using protocol B</span><br><span class="line">          on Parade TrueTouch(tm) Standard Product Generation4 touchscreen</span><br><span class="line">          controller.</span><br><span class="line"> </span><br><span class="line">endchoice</span><br></pre></td></tr></table></figure>

<p>图 7-9</p>
<p>我们在内核目录下输入make menuconfig可以看到，如下（图7-10）所示，“Parade TrueTouch Gen5 MultiTouch Protocol”是choice选项名称，“Protocol B”是Kconfig里面默认选择的。“–&gt;”代表此菜单能进入，需要键盘操作进入。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps38.jpg" alt="img"> </p>
<p>图7-10</p>
<p>进入“Parade TrueTouch Gen5 MultiTouch Protocol”后，可以看到多选项提供给用户进行选择，如下（图7-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps39.jpg" alt="img"> </p>
<p>图7-11</p>
<p>6.comment</p>
<p>comment 语句出现在界面的第一行，用于定义一些提示信息。</p>
<p>comment “Compiler: $(CC_VERSION_TEXT)”</p>
<p>以上代码的配置界面如下（图7-12）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps40.jpg" alt="img"> </p>
<p>图7-12</p>
<p>7.config</p>
<p>使用关键字config来定义一个新的选项，如下（图7-13）所示</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config helloworld</span><br><span class="line">bool “hello world support”</span><br><span class="line">default y</span><br><span class="line">help</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>图7-13</p>
<p>如上所示，使用config关键字定义了一个“helloworld”选项，每个选项都必须指定类型，类型包括bool，tristate,string,hex,int。最常见的是bool,tristate,string这三个。</p>
<p>bool类型取值只有“y”和“n”</p>
<p>tristate类型的变量取值有3种：“y”,“n”,“m”</p>
<p>string类型取值为字符串</p>
<p>hex类型取值为十六进制的数据</p>
<p>int类型取值为十进制的数据</p>
<p>help表示帮助信息，当我们在图形化界面按下h按键，弹出来的就是help的内容。</p>
<p>8.depends on</p>
<p>Kconfig中depends on关键字用来指定依赖关系，当依赖的选项被选中时，当前的配置选项的信息才会在菜单中显示出来，才能操作该选项的内容。举例来说，如下所示，选项A依赖选项B，只有当选项B被选中时，选项A才可以被选中。</p>
<p>config A</p>
<p>depends on B</p>
<p>9.select</p>
<p>Kconfig中select关键字用来表示反向依赖关系，当指定当前选项被选中时，此时select后面的选项也会被自动选中。举个例子来说，如下所示，在选项A被选中的情况下，选项B自动被选中。</p>
<p>config A</p>
<p>select on B</p>
<p>\10. menuconfig</p>
<p>menuconfig可以认为是config 中的升级版。menuconfig也是一个正常的配置项，通过自己的配置值来决定另外一组配置项是否作为子菜单的形式显示出来并供用户配置。代码如下（图7-14）所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">menuconfig NETDEVICES</span><br><span class="line">	default y if UML</span><br><span class="line">	depends on NET</span><br><span class="line">	bool &quot;Network device support&quot;</span><br><span class="line">	---help---</span><br><span class="line">if NETDEVICES</span><br><span class="line">config MII</span><br><span class="line">	tristate</span><br><span class="line"></span><br><span class="line">config NET_CORE</span><br><span class="line">	default y</span><br><span class="line">	bool &quot;Network core driver support&quot;</span><br><span class="line">	---help---</span><br><span class="line">	  You can say N here if you do not intend to use any of the</span><br><span class="line">	  networking core drivers (i.e. VLAN, bridging, bonding, etc.)</span><br></pre></td></tr></table></figure>

<p>图7-14</p>
<p>以上代码中通过menuconfig配置了一个bool类型的配置项，在图形化配置界面中显示（图7-15）如下：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps41.jpg" alt="img"> </p>
<p>图7-15</p>
<p>当我们选中”Network device support”配置项时，其子菜单被显示出来，如下图（图7-16）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps42.jpg" alt="img"> </p>
<p>图7-16</p>
<h2 id="7-3-config配置文件介绍"><a href="#7-3-config配置文件介绍" class="headerlink" title="7.3 .config配置文件介绍"></a>7.3 .config配置文件介绍</h2><p>我们在图形化配置界面配置好了以后，会得到一个.config配置文件。在编译内核的时候会根据这个.config文件来编译内核。这样是不是就实现了通过图像化界面的配置来配置内核呀。用通俗的话来说，Kconfig就是饭店的菜单，.config就是客人点完的菜。然后厨师会根据客人点的菜，也就是.config来做菜，对应的操作就是编译内核。</p>
<p>那.config是如何产生的呢？对应上面的例子就是要有服务员给我们点菜呀。</p>
<p>当我们使用make menuconfig的时候，会通过mconf程序去解析Kconfig文件，然后生成对应的配置文件.config。所以这个mconf就是服务员。</p>
<p>mconf程序源码在内核源码scripts&#x2F;kconfig目录下，如下图所示，这里不对Kconfig文件的解析流程进行分析，感兴趣的同学可以自行分析下mconf的源码。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps43.jpg" alt="img"> </p>
<p>图7-18</p>
<p>有了.config配置文件以后，内核就可以根据这个配置文件来编译内核，比如控制某些驱动编译进内核，或者控制某些驱动不编译内核。那他是怎么实现的呢？</p>
<p>.config会通过syncconfig目标将.config作为输入然后输出需要文件，这里我们重点更关注auto.conf和autoconf.h。如下图（图7-19）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps44.jpg" alt="img"> </p>
<p>图7-19</p>
<p>在auto.conf文件中，存放的是配置信息。如下图（图7-20）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps45.jpg" alt="img"> </p>
<p>图7-20</p>
<p>在内核源码的顶层Makefile中会包含auto.conf文件，以此引用其中的变量来控制Makefile的动作，如哪些驱动编译，哪些驱动不编译。如：</p>
<p>auto.conf文件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include include/config/auto.conf</span><br><span class="line">CONFIG _A=y</span><br></pre></td></tr></table></figure>

<p>顶层Makefile中包含auto.conf文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifeq ($(dot-config),1)</span><br><span class="line">include include/config/auto.conf</span><br><span class="line">Endif</span><br></pre></td></tr></table></figure>



<p>内核源码下drivers&#x2F;A&#x2F;Makefile引用这个变量</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONFIG _A) +=A.o</span><br></pre></td></tr></table></figure>



<p>注：obj-y就是编译进内核，obj-m就是编译成ko文件。</p>
<p>在autoconf.h中，是C语言代码。用来配合编译时的条件选择。如下图（图7-21）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps46.jpg" alt="img"> </p>
<p>图7-21</p>
<h2 id="7-4-defconfig配置文件"><a href="#7-4-defconfig配置文件" class="headerlink" title="7.4 defconfig配置文件"></a>7.4 defconfig配置文件</h2><p>defconfig文件和.config文件都是linux内核的配置文件，defconfig文件在内核源码的arch&#x2F;$(ARCH)&#x2F;configs目录下，是Linux系统默认的配置文件。比如说瑞芯微平台Linux源码默认的配置文件为：kernel&#x2F;arch&#x2F;arm64&#x2F;configs&#x2F;rockchip_linux_defconfig。</p>
<p>.config文件位于Linux内核源码的顶层目录下，编译Linux内核时会使用.config文件里面的配置来编译内核镜像。</p>
<p>如果.config文件存在，make menuconfig界面的默认配置也就是当前.config文件的配置，如果修改了图形化配置界面的设置并保存，那么.config文件会被更新。</p>
<p>如果.config文件不存在，使用命令“make XXX_defconfig”命令会根据arch&#x2F;$(ARCH)&#x2F;configs目录下的XXX_defconfig自动生成.config。make menuconfig界面的默认配置则为defconfig文件中的默认配置，比如说瑞芯微平台Linux内核源码目录下输入“make rockchip_linux_defconfig”会自动生成.config文件。那么此时rockchip_linux_defconfig的配置项和.config的配置项是相同的。</p>
<h2 id="7-5-自定义菜单实验"><a href="#7-5-自定义菜单实验" class="headerlink" title="7.5 自定义菜单实验"></a>7.5 自定义菜单实验</h2><p>有了上面的理论基础后，我们就可以自己在图形化配置界面中来自定义一个菜单，要定义一个菜单，根据我们前面的分析，是不是就要从Kconfig文件入手呀。因为图形化配置界面是根据Kconfig文件来生成的！</p>
<p>1 在kernel目录下创建一个topeet的文件夹，如下（图7-22）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps47.jpg" alt="img"> </p>
<p>图7-22</p>
<p>2 打开kernel下的Kconfig文件，在里面加入以下代码：</p>
<p>source “topeet&#x2F;Kconfig”</p>
<p>添加完成后如下（图7-23）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps48.jpg" alt="img"> </p>
<p>图7-23</p>
<p>3 然后进入到topeet文件夹，在此文件夹下创建一个Kconfig文件，创建完成如下（图7-24）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps49.jpg" alt="img"> </p>
<p>图7-24</p>
<p>4 打开创建好的Kconfig文件，写入以下（图7-25）内容：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">menu <span class="string">&quot;test menu&quot;</span></span><br><span class="line">config TEST_CONFIG</span><br><span class="line">bool <span class="string">&quot;test&quot;</span></span><br><span class="line">default y</span><br><span class="line">help</span><br><span class="line">just test</span><br><span class="line">comment <span class="string">&quot;just test&quot;</span></span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure>

<p>图7-25</p>
<p>在上面的代码中，我们在主菜单中添加了一个名为 test menu 的子菜单，然后在这个子菜单里面我们添加了一个名为 TEST_CONFIG 的配置项，这个配置项变量类型为 bool，默认配置为 Y，帮助信息为 just test，注释为 just test。添加完成如下图（图7-26）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps50.jpg" alt="img"> </p>
<p>图7-26</p>
<p>5 添加完成以后，打开图形化配置界面，如下图（图7-27）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps51.jpg" alt="img"> </p>
<p>图7-27</p>
<p>6子菜单中的配置项，默认为 y，注释信息为 just test。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps52.jpg" alt="img"> </p>
<p>图7-28</p>
<p>7 在此界面输入？，显示帮助信息为 just test，如下（图7-29）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps53.jpg" alt="img"> </p>
<p>图7-29</p>
<p>8 保存退出后，打开内核源码目录下的.config 文件，如下图（图7-30）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps54.jpg" alt="img"> </p>
<p>图7-30</p>
<p>9 可以在这个.config 文件中找到添加的 TEST_CONFIG（注意，我们需要在 make menuconfig 中保存才可以看到，否则是看不到我们添加的这个选项的），这样在编译内核的时候就可以根据这个配置信息来执行对应的操作了，就是我们下一章节要给大家讲的把驱动编译进内核，如下图所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps55.jpg" alt="img"> </p>
<p>图7-31</p>
<h1 id="第8章-驱动模块编译进内核实验"><a href="#第8章-驱动模块编译进内核实验" class="headerlink" title="第8章 驱动模块编译进内核实验"></a>第8章 驱动模块编译进内核实验</h1><p>通过上一章的学习，我们学会了使用menuconfig图形化配置工具，以及了解了menuconfig相关的文件：Kconfig .config XXXdefconfig。本章节学习将helloworld驱动编译进内核。</p>
<p>输入“cd drivers&#x2F;char”进入到 drivers&#x2F;char 目录下，然后输入“mkdir hello”建立hello文件夹，并输入“cd hello”进入hello文件夹，如下（图8-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps56.jpg" alt="img"> </p>
<p>图8-1</p>
<p>然后将第三章编写的hello.c文件拷贝到hello文件夹内。如下（图8-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps57.jpg" alt="img"> </p>
<p>图8-2</p>
<p>输入“touch Kconfig”命令创建Kconfig文件，Kconfig文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config HELLO</span><br><span class="line">tristate &quot;hello world&quot;</span><br><span class="line">help</span><br><span class="line">hello hello</span><br></pre></td></tr></table></figure>

<p>然后“touch Makefile”命令创建Makefile文件,Makefile文件内容如下所示：</p>
<p>obj-$(CONFIG_HELLO)+&#x3D;helloworld.o</p>
<p>接下来修改上一级目录的Kconfig文件和Makefile文件，也就是driver&#x2F;char目录。Makefile添加如下图(图8-3)所示内容。</p>
<p>obj-y +&#x3D; hello&#x2F;</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps58.jpg" alt="img"> </p>
<p>图8-3</p>
<p>Kconfig添加如下图（图8-4）所示内容：</p>
<p>source “drivers&#x2F;char&#x2F;hello&#x2F;Kconfig”</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps59.jpg" alt="img"> </p>
<p>图8-4</p>
<p>最后打开menuconfig图形化配置工具，在配置界面选择helloworld驱动。把驱动编译进Linux内核，用 * 来表示，所以配置选项改为*。如果想要将驱动编译为模块，则用M来表示，配置选项改为M。这里我们选择成 * </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers ─&gt;</span><br><span class="line">    Character devices ---&gt;</span><br><span class="line">        &lt;*&gt; hello world或者&lt;M&gt; hello world</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps60.jpg" alt="img"> </p>
<p>图8-5</p>
<p>然后将光标移动到save，保存配置，如下图（图8-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps61.jpg" alt="img"> </p>
<p>图8-6</p>
<p>保存到.config文件，如下（图8-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps62.jpg" alt="img"> </p>
<p>图-7</p>
<p>退出配置界面，然后输入以下命令便可以编译源码了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make savedefconfig</span><br><span class="line">cp defconfig arch/arm64/configs/rockchip_linux_defconfig </span><br><span class="line">cd ../</span><br><span class="line">./build.sh kernel</span><br></pre></td></tr></table></figure>

<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps63.jpg" alt="img"> </p>
<p>图8-8</p>
<p>编译成功之后，进入到drivers&#x2F;char&#x2F;hello目录下，可以看到会生成对应的.o文件。就说明已经成功将驱动编译进内核。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps64.jpg" alt="img"> </p>
<p>图8-9</p>
<p>将编译好的内核镜像烧写到开发板上后，在开发板系统启动的时候也可以成功看到加载helloworld驱动，如下图（图8-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps65.jpg" alt="img"> </p>
<p>图8-10</p>
<p>如果在图形化配置界面中选择的M，也就是编译成驱动模块，则生成helloworld.ko文件如下图（图8-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps66.jpg" alt="img"> </p>
<p>图8-11</p>
<h1 id="第9章-申请字符设备号实验"><a href="#第9章-申请字符设备号实验" class="headerlink" title="第9章 申请字符设备号实验"></a>第9章 申请字符设备号实验</h1><p>经过前面章节的学习，相信大家已经对驱动模块的基本框架、驱动模块传参等知识有了自己的认识，本章节开始就要进入字符设备的世界了。 字符设备是指在I&#x2F;O传输过程中以字符为单位进行传输的设备，可以使用与普通文件相同的文件操作命令（打开、关闭、读、写等）对字符设备进行操作，是Linux驱动中最基本的一类设备驱动，例如最常见的LED、按键、IIC、SPI，LCD等都属于字符设备的范畴。要想对字符设备进行操作，需要通过设备号来对相应的设备进行查找，在本章节将对设备号相关知识进行讲解。 </p>
<h2 id="9-1-申请驱动设备号"><a href="#9-1-申请驱动设备号" class="headerlink" title="9.1 申请驱动设备号"></a>9.1 申请驱动设备号</h2><h3 id="9-1-1-设备号申请"><a href="#9-1-1-设备号申请" class="headerlink" title="9.1.1 设备号申请"></a>9.1.1 设备号申请</h3><p>在Linux系统中每一个设备都有相应的设备号，通过该设备号查找对应的设备，从而进行之后的文件操作。设备号有主设备号与次设备号之分，主设备号用来表示一个特定的驱动，次设备号用来管理下面的设备。</p>
<p>在Linux驱动中可以使用以下两种方法进行设备号的申请：</p>
<p>1.通过register_chrdev_region(dev_t from, unsigned count, const char *name)函数进行静态申请设备号。</p>
<p>2.通过alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,const char *name)函数进行动态申请设备号。</p>
<p>两个函数在“内核源码&#x2F;include&#x2F;linux&#x2F;fs.h”文件中引用(在编写驱动程序的时候要加入该文件的引用)，如下（图9-1）所示： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *, <span class="type">unsigned</span>, <span class="type">unsigned</span>, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">register_chrdev_region</span><span class="params">(<span class="type">dev_t</span>, <span class="type">unsigned</span>, <span class="type">const</span> <span class="type">char</span> *)</span>;   </span><br></pre></td></tr></table></figure>

<p>图9-1</p>
<p>静态申请设备号：</p>
<p><strong>函数原型</strong>：</p>
<p>register_chrdev_region(dev_t from, unsigned count, const char *name)</p>
<p><strong>函数作用：</strong></p>
<p>静态申请设备号，对指定好的设备号进行申请。</p>
<p><strong>参数含义：</strong></p>
<p> from: 自定义的dev_t类型设备号</p>
<p> count: 申请设备的数量</p>
<p> name: 申请的设备名称</p>
<p><strong>函数返回值：</strong>申请成功返回0，申请失败返回负数</p>
<p>动态申请设备号：</p>
<p><strong>函数原型：</strong></p>
<p>alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,const char *name)</p>
<p><strong>函数作用</strong></p>
<p>动态申请设备号，内核会自动分配一个未使用的设备号，相较于静态申请设备号，动态申请会避免注册设备号相同引发冲突的问题。</p>
<p><strong>参数含义</strong></p>
<p>dev *: 会将申请完成的设备号保存在dev变量中</p>
<p>baseminor: 次设备号可申请的最小值</p>
<p>count: 申请设备的数量</p>
<p>name: 申请的设备名称</p>
<p>****函数返回值：****申请成功返回0，申请失败返回负数</p>
<p>对于申请设备号所用到的函数就讲解完成了，会在之后的测试小节对两个函数进行实际运用。</p>
<h3 id="9-1-2-设备号类型"><a href="#9-1-2-设备号类型" class="headerlink" title="9.1.2 设备号类型"></a>9.1.2 设备号类型</h3><p>申请的设备号类型为dev_t ，在“内核源码&#x2F;include&#x2F;linux&#x2F;types.h” 文件中定义如下（图9-2）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> u32 <span class="type">__kernel_dev_t</span>;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">__kernel_dev_t</span>      <span class="type">dev_t</span>;</span><br></pre></td></tr></table></figure>

<p>图 9-2</p>
<p>dev_t为u32类型，而u32 定义在文件 “内核源码&#x2F;include&#x2F;uapi&#x2F;asm-generic&#x2F;int-ll64.h”文件中，定义如下（图9-3）： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> __u32;</span><br></pre></td></tr></table></figure>

<p>图 9-3</p>
<p>__u32为unsigned int类型，所以dev_t是一个无符号的32位整形类型。其中高12位表示主设备号，低20位表示次设备号。在“内核源码&#x2F;include&#x2F;linux&#x2F;kdev_t.h”中提供了设备号相关的宏定义，如下（图9-4）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MINORBITS   20   <span class="comment">/*次设备号位数*/</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINORMASK   ((1U &lt;&lt; MINORBITS) - 1)  <span class="comment">/*次设备号掩码*/</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAJOR(dev)  ((unsigned int) ((dev) &gt;&gt; MINORBITS))<span class="comment">/*dev右移20位得到主设备号*/</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINOR(dev)  ((unsigned int) ((dev) &amp; MINORMASK))  <span class="comment">/*与次设备掩码与，得到次设备号*/</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MKDEV(ma,mi)    (((ma) &lt;&lt; MINORBITS) | (mi))<span class="comment">/*MKDEV宏将主设备号（ma）左移20位，然后与次设备号（mi）相与，得到设备号*/</span></span></span><br></pre></td></tr></table></figure>

<p>图 9-4</p>
<p>在稍后的实验中不论是静态申请设备号还是动态申请设备号都会用到上述宏，例如在静态申请设备号时需要将指定的主设备号和从设备号通过MKDEV(ma,mi)宏进行设备号的转换，在动态申请设备号时可以用MAJOR(dev) 和MINOR(dev)宏将动态申请的设备号转化为主设备号和从设备号。</p>
<p>至此，关于设备号相关的知识就结束了，在下一小节中将对申请设备号实验代码进行编写。</p>
<h2 id="9-2-实验程序的编写"><a href="#9-2-实验程序的编写" class="headerlink" title="9.2 实验程序的编写"></a>9.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\04。</p>
<p>本章节实验将编写Linux下申请字符设备号实例代码，如果在进行驱动模块加载时传入了major主设备号，则通过静态的方式进行设备号的申请，如果不传入任何参数进行驱动模块加载，则通过动态的方式进行设备号申请。</p>
<p>编写完成的dev_t.c代码如下（图9-5）所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>                                                                                                                                </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major;<span class="comment">//定义静态加载方式时的主设备号参数major</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> minor;<span class="comment">//定义静态加载方式时的次设备号参数minor</span></span><br><span class="line">module_param(major,<span class="type">int</span>,S_IRUGO);<span class="comment">//通过驱动模块传参的方式传递主设备号参数major</span></span><br><span class="line">module_param(minor,<span class="type">int</span>,S_IRUGO);<span class="comment">//通过驱动模块传参的方式传递次设备号参数minor</span></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型(32位大小)的变量dev_num</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">dev_t_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;<span class="comment">//定义int类型的变量ret，用来判断函数返回值</span></span><br><span class="line">    <span class="comment">/*以主设备号进行条件判断，即如果通过驱动传入了major参数则条件成立，进入以下分支*/</span></span><br><span class="line">    <span class="keyword">if</span>(major)&#123;</span><br><span class="line">        dev_num = MKDEV(major,minor);<span class="comment">//通过MKDEV函数将驱动传参的主设备号和次设备号转换成dev_t类型的设备号</span></span><br><span class="line">        printk(<span class="string">&quot;major is %d\n&quot;</span>,major);</span><br><span class="line">        printk(<span class="string">&quot;minor is %d\n&quot;</span>,minor);</span><br><span class="line">        ret = register_chrdev_region(dev_num,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>);<span class="comment">//通过静态方式进行设备号册</span></span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            printk(<span class="string">&quot;register_chrdev_region is error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        printk(<span class="string">&quot;register_chrdev_region is ok\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*如果没有通过驱动传入major参数，则条件成立，进入以下分支*/</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ret = alloc_chrdev_region(&amp;dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_num&quot;</span>);<span class="comment">//通过动态方式进行设备号注册</span></span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);</span><br><span class="line">        &#125;                                                                                                                                              </span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line">        major=MAJOR(dev_num);<span class="comment">//通过MAJOR()函数进行主设备号获取</span></span><br><span class="line">        minor=MINOR(dev_num);<span class="comment">//通过MINOR()函数进行次设备号获取</span></span><br><span class="line">        printk(<span class="string">&quot;major is %d\n&quot;</span>,major);</span><br><span class="line">        printk(<span class="string">&quot;minor is %d\n&quot;</span>,minor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">dev_t_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    unregister_chrdev_region(dev_num,<span class="number">1</span>);<span class="comment">//释放字符驱动设备号 </span></span><br><span class="line">    printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(dev_t_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(dev_t_exit);<span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);  <span class="comment">//作者信息  </span></span><br></pre></td></tr></table></figure>

<p>图 9-5</p>
<p>以上代码通过对传入参数的判断，从而进行设备号申请方式的选择，会在下一小节进行相应的驱动加载测试。</p>
<h2 id="9-3-运行测试"><a href="#9-3-运行测试" class="headerlink" title="9.3 运行测试"></a>9.3 运行测试</h2><h3 id="9-3-1-编译驱动程序"><a href="#9-3-1-编译驱动程序" class="headerlink" title="9.3.1 编译驱动程序"></a>9.3.1 编译驱动程序</h3><p>在上一小节中的dev_t.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图9-6）所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m += dev_c.o    #此处要和你的驱动源文件同名</span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    #make操作</span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    #make clean操作</span><br></pre></td></tr></table></figure>

<p>图 9-6</p>
<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放dev_t.c和Makefile文件目录下，如下图（图9-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps67.jpg" alt="img"> </p>
<p>图 9-7</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图9-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps68.jpg" alt="img"> </p>
<p>图 9-8</p>
<p>编译完生成dev_t.ko目标文件，如下图（图9-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps69.jpg" alt="img"> </p>
<p>图 9-9</p>
<p>至此我们的驱动模块就编译成功了，下面对驱动进行加载测试。</p>
<h3 id="9-3-2-运行测试"><a href="#9-3-2-运行测试" class="headerlink" title="9.3.2 运行测试"></a>9.3.2 运行测试</h3><p>开发板上电启动之后，使用以下命令加载dev_t.ko驱动，加载完成之后的打印信息如下图图（9-10）所示：</p>
<p>insmod dev_t.ko major&#x3D;200 minor&#x3D;0</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps70.jpg" alt="img"> </p>
<p>图 9-10</p>
<p>可以看到传入的主设备号和次设备号都被打印了出来，“register_chrdev_region is ok”也被成功打印了证明设备注册成功了，然后使用以下命令进行注册设备号的查看，如下图（图9-11）所示：</p>
<p> cat &#x2F;proc&#x2F;devices</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps71.jpg" alt="img"> </p>
<p>图 9-11</p>
<p>可以看到主设备号200的设备名为chrdev_name，和驱动程序中设置的相同，证明我们的设备号注册成功了，然后使用以下命令进行驱动的卸载，如下图（图9-12）所示：</p>
<p>rmmod dev_t.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps72.jpg" alt="img"> </p>
<p>图 9-12</p>
<p>下面进行动态申请设备号实验，使用以下命令进行驱动模块的加载，如下图（图9-13）所示：</p>
<p> insmod dev_t.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps73.jpg" alt="img"> </p>
<p>图 9-13</p>
<p>可以看到动态申请设备号成功了，主设备号为236，次设备号为0，然后使用以下命令进行注册设备号的查看，如下图（图9-14）所示：</p>
<p> cat &#x2F;proc&#x2F;devices</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps74.jpg" alt="img"> </p>
<p>图 9-14</p>
<p>可以看到主设备号236的设备名为chrdev_name，和驱动程序中设置的相同，证明我们的设备号注册成功了，最后可以输入以下命令对驱动进行卸载，卸载完成如下图（图9-15）所示：</p>
<p>rmmod dev_t.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps75.jpg" alt="img"> </p>
<p>图 9-15</p>
<h1 id="第10章-注册字符设备实验"><a href="#第10章-注册字符设备实验" class="headerlink" title="第10章 注册字符设备实验"></a>第10章 注册字符设备实验</h1><p>在上一小节中已经对设备号的相关知识进行了讲解，并成功申请到了设备号，那在Linux系统中，设备号是怎样与字符设备进行关联的呢？字符设备又是怎样注册的呢？带着疑问，让我们开始本章节的学习吧。</p>
<h2 id="10-1-注册字符设备"><a href="#10-1-注册字符设备" class="headerlink" title="10.1 注册字符设备"></a>10.1 注册字符设备</h2><p>注册字符设备可以分为两个步骤：</p>
<p>1.字符设备初始化</p>
<p>2.字符设备的添加</p>
<p>在本小节将对上述两个步骤所用到的函数和结构体进行讲解。</p>
<h3 id="10-1-1-字符设备初始化"><a href="#10-1-1-字符设备初始化" class="headerlink" title="10.1.1 字符设备初始化"></a>10.1.1 字符设备初始化</h3><p>字符设备初始化所用到的函数为cdev_init(…),在对该函数讲解之前，首先对cdev结构体进行介绍。</p>
<p>Linux 内核中将字符设备抽象成一个具体的数据结构 (struct cdev), 我们可以理解为字符设备对象，cdev 记录了字符设备号、内核对象、文件操作file_operations结构体（设备的打开、读写、关闭等操作接口）等信息，struct cdev 结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;cdev.h”文件中（在编写驱动程序的时候要加入该文件的引用），如下（图10-1）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>                  <span class="comment">//内嵌的内核对象.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>                 <span class="comment">//该字符设备所在的内核模块的对象指针.</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span>    <span class="comment">//该结构描述了字符设备所能实现的方法，是极为关键的一个结构体.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>                <span class="comment">//用来将已经向内核注册的所有字符设备形成链表.</span></span><br><span class="line">	<span class="type">dev_t</span> dev;                            <span class="comment">//字符设备的设备号，由主设备号和次设备号构成.</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> count;                   <span class="comment">//隶属于同一主设备号的次设备号的个数.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>图 10-1</p>
<p>关于该结构体参数的注释在上图已经添加，设备初始化所用到的函数为cdev_init(),该函数同样在“内核源码&#x2F;include&#x2F;linux&#x2F;cdev.h”文件中所引用如下（图10-2）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="type">const</span> <span class="keyword">struct</span> file_operations *)</span>;</span><br></pre></td></tr></table></figure>

<p> 图10-2</p>
<p>该函数的详细内容在“内核源码&#x2F;include&#x2F;fs&#x2F;char_dev.c”文件中定义，如下（图10-3）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cdev, <span class="number">0</span>, <span class="keyword">sizeof</span> *cdev);<span class="comment">//将整个结构体清零；</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);<span class="comment">//初始化list成员使其指向自身；</span></span><br><span class="line">    kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);<span class="comment">//初始化kobj成员；</span></span><br><span class="line">    cdev-&gt;ops = fops;<span class="comment">//初始化ops成员，建立cdev 和 file_operations之间的连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图 10-3</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>初始化传入的cdev 类型的结构体，并与自定义的file_operations * 类型的结构体进行链接。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p> cdev: 要传入的cdev类型结构体，为要初始化的字符设备。</p>
<p> fops：要传入的file_operations * 类型结构体，关于file_operations结构体的相关的知识会在下一章节进行讲解。</p>
<p>****函数返回值：****无返回值。</p>
<h3 id="10-1-2-字符设备的注册"><a href="#10-1-2-字符设备的注册" class="headerlink" title="10.1.2 字符设备的注册"></a>10.1.2 字符设备的注册</h3><p><em><strong>*字符设备的注册：*</strong></em>	</p>
<p>字符设备添加所用到的函数为cdev_add()，该函数在“内核源码&#x2F;include&#x2F;linux&#x2F;cdev.h”文件中所引用，如下（图10-4）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="type">dev_t</span>, <span class="type">unsigned</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>图 10-4</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int cdev_add(struct cdev *p, dev_t dev, unsigned count)   </p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>该函数向内核注册一个struct cdev结构体</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>(1)第一个参数为要添加的struct cdev 类型的结构体</p>
<p>(2)第二个参数为申请的字符设备号</p>
<p>(3)第三个参数为和该设备关联的设备编号的数量。</p>
<p>这两个参数直接赋值给struct cdev 的dev成员和count成员。</p>
<p>****函数返回值：****添加成功返回0，添加失败返回负数。</p>
<p><em><strong>*字符设备的注销：*</strong></em></p>
<p>字符设备删除所用到的函数为cdev_del()，该函数同样在“内核源码&#x2F;include&#x2F;linux&#x2F;cdev.h”文件中所引用，如下（图10-5）所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cdev_del(struct cdev *);</span><br></pre></td></tr></table></figure>

<p>图 10-5</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>void cdev_del(struct cdev *p)  </p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>该函数会向内核删除一个struct cdev 类型结构体</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>该函数只有一个参数，为要删除的struct cdev 类型的结构体</p>
<p>****函数返回值：****无返回值</p>
<p>至此，关于注册字符设备实验所用到的函数就讲解完成了，在下一小节中将编写注册字符设备代码。</p>
<h2 id="10-2-实验程序的编写"><a href="#10-2-实验程序的编写" class="headerlink" title="10.2 实验程序的编写"></a>10.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\05。</p>
<p>本实验采用动态申请设备号的方式进行设备号的申请，然后对设备进行注册，并将申请到的主设备号和次设备号以及设备注册情况打印到终端上。</p>
<p>编写完成的cdev.c代码如下（图10-6）所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型（32位大小）的变量dev_num,用来存放设备号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义cdev结构体类型的变量cdev_test</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_ops</span>&#123;</span></span><br><span class="line">	.owner=THIS_MODULE<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">&#125;;<span class="comment">//定义file_operations结构体类型的变量cdev_test_ops</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">module_cdev_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;<span class="comment">//定义int类型变量ret，进行函数返回值判断</span></span><br><span class="line">    <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>);<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_register_region is ok\n&quot;</span>);</span><br><span class="line">    major = MAJOR(dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">    minor = MINOR(dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">    printk(<span class="string">&quot;major is %d\n&quot;</span>,major);</span><br><span class="line">    printk(<span class="string">&quot;minor is %d\n&quot;</span>,minor);                                         </span><br><span class="line">cdev_init(&amp;cdev_test,&amp;cdev_test_ops);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到cdev_test_ops结构体</span></span><br><span class="line">cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块 </span></span><br><span class="line">    ret = cdev_add(&amp;cdev_test,dev_num,<span class="number">1</span>);<span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        printk(<span class="string">&quot;cdev_add is error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;cdev_add is ok\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">module_cdev_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cdev_del(&amp;cdev_test);<span class="comment">//使用cdev_del()函数进行字符设备的删除</span></span><br><span class="line">    unregister_chrdev_region(dev_num,<span class="number">1</span>);<span class="comment">//释放字符驱动设备号 </span></span><br><span class="line">    printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(module_cdev_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(module_cdev_exit);<span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);  <span class="comment">//作者信息  </span></span><br></pre></td></tr></table></figure>

<p>图 10-6</p>
<p>相较于上一章节实验，本章节的代码去掉了静态申请设备号部分代码，并在申请设备号完成之后注册了相应的字符设备，并在驱动出口函数中添加了相应的字符设备删除代码（相关代码已加粗）。</p>
<p>需要注意的是，字符设备的注册要放在申请字符设备号之后，字符设备的删除要放在释放字符驱动设备号之前。</p>
<h2 id="10-3-运行测试"><a href="#10-3-运行测试" class="headerlink" title="10.3 运行测试"></a>10.3 运行测试</h2><h3 id="10-3-1-编译驱动程序"><a href="#10-3-1-编译驱动程序" class="headerlink" title="10.3.1 编译驱动程序"></a>10.3.1 编译驱动程序</h3><p>在上一小节中的cdev.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图10-7）所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m += cdev.o    #此处要和你的驱动源文件同名</span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    #make操作</span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    #make clean操作</span><br></pre></td></tr></table></figure>

<p>图 10-7</p>
<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放parameter.c和Makefile文件目录下，如下图（图10-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps76.jpg" alt="img"> </p>
<p>图 10-8</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图10-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps77.jpg" alt="img"> </p>
<p>图 10-9</p>
<p>编译完会生成 cdev.ko目标文件，如下图（图10-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps78.jpg" alt="img"> </p>
<p>图 10-10</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h3 id="10-3-2-运行测试"><a href="#10-3-2-运行测试" class="headerlink" title="10.3.2 运行测试"></a>10.3.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图10-11）所示：</p>
<p>insmod cdev.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps79.jpg" alt="img"> </p>
<p>图 10-11</p>
<p>可以看到动态申请设备号成功了，主设备号为236，次设备号为0，然后使用以下命令进行注册设备号的查看，如下图（图10-12）所示：</p>
<p> cat &#x2F;proc&#x2F;devices</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps80.jpg" alt="img"> </p>
<p>图 10-12</p>
<p>可以看到主设备号236的设备名为chrdev_name，和驱动程序中设置的设备名称相同，证明字符设备注册成功了，最后可以使用以下命令对驱动进行卸载，卸载完成如下图（10-13）所示：</p>
<p>rmmod cdev.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps81.jpg" alt="img"> </p>
<p>图 10-13</p>
<h1 id="第11章-创建设备节点实验"><a href="#第11章-创建设备节点实验" class="headerlink" title="第11章 创建设备节点实验"></a>第11章 创建设备节点实验</h1><p>在上两个章节的学习中，我们已经成功的申请了设备号并且注册了相应的字符设备。系统通过设备号对设备进行查找，而字符设备注册到内核之后，并不能直接进行设备文件操作命令（打开、关闭、读、写等），需要相应的设备文件作为桥梁以此来进行设备的访问，在本章节将对如何创建设备节点进行学习。 </p>
<h2 id="11-1-创建设备节点"><a href="#11-1-创建设备节点" class="headerlink" title="11.1 创建设备节点"></a>11.1 创建设备节点</h2><p>在Linux操作系统中一切皆文件，设备访问也是通过文件的方式来进行的，对于用来进行设备访问的文件称之为设备节点，设备节点被创建在&#x2F;dev目录下，将内核中注册的设备与用户层进行链接，这样应用程序才能对设备进行访问。</p>
<p>根据设备节点的创建方式不同，分为了手动创建设备节点和自动创建设备节点，下面对两种设备节点创建方式进行介绍。</p>
<h3 id="11-1-1-手动创建设备节点"><a href="#11-1-1-手动创建设备节点" class="headerlink" title="11.1.1 手动创建设备节点"></a>11.1.1 手动创建设备节点</h3><p>使用mknod命令手动创建设备节点，mknod 命令格式为：</p>
<p>mknod NAME TYPE MAJOR MINOR</p>
<p>参数含义：</p>
<p>NAME: 要创建的节点名称</p>
<p>TYPE: b表示块设备，c表示字符设备，p表示管道</p>
<p>MAJOR：要链接设备的主设备号</p>
<p>MINOR: 要链接设备的从设备号</p>
<p>例如使用以下命令创建一个名为device_test的字符设备节点，链接设备的主设备号和从设备号分别为236和0：</p>
<p>mknod &#x2F;dev&#x2F;device_test c 236 0 </p>
<h3 id="11-1-2-自动创建设备节点"><a href="#11-1-2-自动创建设备节点" class="headerlink" title="11.1.2 自动创建设备节点"></a>11.1.2 自动创建设备节点</h3><p>设备文件的自动创建是利用udev(mdev)机制来实现，多数情况下采用自动创建设备节点的方式。udev(mdev)可以检测系统中硬件设备状态，可以根据系统中硬件设备状态来创建或者删除设备文件。在驱动中首先使用class_create(…)函数对class进行创建，这个类存放于&#x2F;sys&#x2F;class&#x2F; 目录下，之后使用device_create(…)函数创建相应的设备，在进行模块加载时，用户空间中的udev会自动响应device_create()函数，寻找对应的类从而创建设备节点。</p>
<p>下面对于自动创建节点中所用到的函数进行解释说明：</p>
<p><em><strong>*class_create(…)函数*</strong></em></p>
<p>该函数在“内核源码&#x2F;include&#x2F;linux&#x2F;device.h”文件中所引用（由于上一小节中引用的cdev.h文件已包含device.h，所以不需要再重复引用），如下（图11-1）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> class_create(owner, name)       \</span></span><br><span class="line"><span class="meta">(&#123;                      \</span></span><br><span class="line"><span class="meta">   static struct lock_class_key __key; \</span></span><br><span class="line"><span class="meta">    __class_create(owner, name, &amp;__key);    \                                                                           </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>图 11-1</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>用于动态创建设备的逻辑类，并完成部分字段的初始化，然后将其添加进Linux内核系统。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>owner：struct module结构体类型的指针，指向函数即将创建的这个struct class的模块。一般赋值为THIS_MODULE。</p>
<p>name：char类型的指针，代表即将创建的struct class变量的名字。</p>
<p>返回值：struct class * 类型的结构体。 </p>
<p><em><strong>*class_destroy(…)函数*</strong></em></p>
<p>该函数在“内核源码&#x2F;include&#x2F;linux&#x2F;device.h”文件中所引用，如下（图11-2）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">class_destroy</span><span class="params">(<span class="keyword">struct</span> class *cls)</span>;  </span><br></pre></td></tr></table></figure>

<p>图 11-2</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>用于删除设备的逻辑类，即从Linux内核系统中删除设备的逻辑类。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>owner：struct module结构体类型的指针，指向函数即将创建的这个struct class的模块。一般赋值为THIS_MODULE。</p>
<p>name：char类型的指针，代表即将创建的struct class变量的名字。</p>
<p>返回值：无</p>
<p><em><strong>*device_create(…)函数*</strong></em></p>
<p>该函数在“内核源码&#x2F;include&#x2F;linux&#x2F;device.h”文件中所引用，如下（图11-3）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device *<span class="title function_">device_create</span><span class="params">(<span class="keyword">struct</span> class *cls, <span class="keyword">struct</span> device *parent,                                                  </span></span><br><span class="line"><span class="params">               <span class="type">dev_t</span> devt, <span class="type">void</span> *drvdata,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>图 11-3</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>用来在class类中下创建一个设备属性文件，udev会自动识别从而进行设备节点的创建。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>cls：指定所要创建的设备所从属的类。</p>
<p>parent:指定该设备的父设备，如果没有就指定为NULL。</p>
<p>devt:指定创建设备的设备号。</p>
<p>drvdata:被添加到该设备回调的数据，没有则指定为NULL。</p>
<p>fmt：添加到系统的设备节点名称。</p>
<p>****返回值：****struct device * 类型结构体</p>
<p><em><strong>*device_destroy(…)函数*</strong></em></p>
<p>在“内核源码&#x2F;include&#x2F;linux&#x2F;device.h”文件中所引用，如下（图11-4）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">device_destroy</span><span class="params">(<span class="keyword">struct</span> class *cls, <span class="type">dev_t</span> devt)</span>; </span><br></pre></td></tr></table></figure>

<p>图 11-4</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>用来删除class类中的设备属性文件，udev会自动识别从而进行设备节点的删除。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>cls：指定所要创建的设备所从属的类。</p>
<p>devt:指定创建设备的设备号。</p>
<p>返回值：无</p>
<p>至此，关于自动创建节点相关的函数就介绍完成了，会在下一小节中对于设备节点的自动创建进行相应实验程序的编写。</p>
<h2 id="11-2-实验程序的编写"><a href="#11-2-实验程序的编写" class="headerlink" title="11.2 实验程序的编写"></a>11.2 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\06。</p>
<p>本章实验将编写Linux下的自动创建设备节点实验代码，首先采用自动申请设备号的方式进行设备号的申请，并对获取的主设备号与次设备号进行打印，之后对字符设备进行注册(file_operations结构体只填充owner 字段即可，会在下个章节对file_operations结构体进行讲解)，最后自动对设备节点进行创建。</p>
<p>编写完成的chrdev_node.c代码如下（图11-5）所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_fops_test</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">&#125;;<span class="comment">//定义file_operations结构体类型的变量cdev_test_ops</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chrdev_fops_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;<span class="comment">//定义int类型的变量ret，用来对函数返回值进行判断</span></span><br><span class="line">    <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>);<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">    <span class="keyword">if</span> (ret  &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">    major = MAJOR(dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">    minor = MINOR(dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">    printk(<span class="string">&quot;major is %d\n minor is %d \n&quot;</span>,major,minor);</span><br><span class="line">    cdev_init(&amp;cdev_test,&amp;cdev_fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到cdev_test_ops结构&gt;体</span></span><br><span class="line">    cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    ret = cdev_add(&amp;cdev_test,dev_num,<span class="number">1</span>); <span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">         printk(<span class="string">&quot;cdev_add is error \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;cdev_add is ok \n&quot;</span>);</span><br><span class="line">    class_test  = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">    device_create(class_test,<span class="literal">NULL</span>,dev_num,<span class="literal">NULL</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chrdev_fops_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cdev_del(&amp;cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">    unregister_chrdev_region(dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">    device_destroy(class_test,dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">    class_destroy(class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">    printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(chrdev_fops_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(chrdev_fops_exit);<span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);<span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>图 11-5</p>
<p>相较于上一章节实验，本章节代码在入口函数中添加了自动创建设备节点相关代码，在驱动出口函数中添加了相应的删除设备节点相关代码(相关代码已加粗)。</p>
<p>需要注意的是，在进行设备节点添加时，类的创建要放在设备创建之前；在进行设备节点删除时，类的删除要放在设备删除之后。</p>
<h2 id="11-3-运行测试"><a href="#11-3-运行测试" class="headerlink" title="11.3 运行测试"></a>11.3 运行测试</h2><h3 id="11-3-1-编译驱动程序"><a href="#11-3-1-编译驱动程序" class="headerlink" title="11.3.1 编译驱动程序"></a>11.3.1 编译驱动程序</h3><p>在上一小节中的chrdev_node.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图11-6）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += chrdev_node.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>图 11-6</p>
<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放chrdev_node.c和Makefile文件目录下，如下图（图11-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps82.jpg" alt="img"> </p>
<p>图 11-7</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图11-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps83.jpg" alt="img"> </p>
<p>图 11-8</p>
<p>编译完生成 chrdev_node.ko目标文件，如下图（图11-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps84.jpg" alt="img"> </p>
<p>图 11-9</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h3 id="11-3-2-运行测试"><a href="#11-3-2-运行测试" class="headerlink" title="11.3.2 运行测试"></a>11.3.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图11-10）所示：</p>
<p>insmod cdev.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps85.jpg" alt="img"> </p>
<p>图 11-10</p>
<p>可以看到动态申请设备号成功了，主设备号为236，次设备号为0，然后使用以下命令进行注册设备号的查看，如下图（图11-11）所示：</p>
<p> cat &#x2F;proc&#x2F;devices</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps86.jpg" alt="img"> </p>
<p>图 11-11</p>
<p>可以看到主设备号236的设备名为chrdev_name，和驱动程序中设置的相同，证明我们的设备号注册成功了，然后使用以下命令对class目录进行查看，如下图（图11-12）所示：</p>
<p>ls &#x2F;sys&#x2F;class&#x2F;</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps87.jpg" alt="img"> </p>
<p>图 11-12</p>
<p>可以看到在驱动程序中创建的class_test 类已经被成功创建了，然后使用以下命令对class_test 目录进行查看，如下图（图11-12）所示：</p>
<p>ls &#x2F;sys&#x2F;class&#x2F;class_test&#x2F;</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps88.jpg" alt="img"> </p>
<p>图 11-12</p>
<p>可以看到在驱动程序中创建的名为device_test的设备属性文件夹也被创建了，然后使用命令“ls &#x2F;dev&#x2F;device_test”对&#x2F;dev目录进行查看，相应的设备节点也已经被自动创建了，如下图（图11-13）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps89.jpg" alt="img"> </p>
<p>图 11-13</p>
<p>最后可以使用以下命令进行驱动的卸载，卸载完成如下图（图11-14）所示：</p>
<p>rmmod chrdev_node.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps90.jpg" alt="img"> </p>
<p>图 11-14</p>
<h1 id="第12章-字符设备驱动框架实验"><a href="#第12章-字符设备驱动框架实验" class="headerlink" title="第12章 字符设备驱动框架实验"></a>第12章 字符设备驱动框架实验</h1><p>下面对前面三个章节进行总结，首先驱动向Linux内核进行设备号申请，之后的字符设备注册时，会对申请的设备号进行使用。而Linux 内核会将字符设备抽象成一个具体的struct cdev结构体，该结构体记录了字符设备的字符设备号、内核对象等信息，cdev_init(…)函数对结构体进行初始化之后，cdev_add(…)函数将设备号和cdev结构体进行链接，这时设备号才真正指向了内核中注册的设备。设备注册成功之后，此时还不能对字符设备进行文件操作，所以需要设备节节点来充当内核和用户层通信的桥梁，至此，前面三个章节就总结完成了，以上步骤并没有涉及到操作设备文件，本章节将对字符设备框架进行最终的完善。 </p>
<h2 id="12-1-文件操作集简介"><a href="#12-1-文件操作集简介" class="headerlink" title="12.1 文件操作集简介"></a>12.1 文件操作集简介</h2><p> 在进行注册字符设备实验章节中，使用cdev_init(…)函数对struct cdev结构体类型变量和struct file_operations结构体类型变量相链接，struct file_operations结构体就是把系统调用和驱动程序关联起来的关键数据结构。该结构体的每一个成员都对应着一个系统调用，读取file_operation中相应的函数指针，接着把控制权转交给函数，从而完成了Linux设备驱动程序的工作。</p>
<p>file_operations结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;fs.h”文件中，下面对部分常用函数进行说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br></pre></td></tr></table></figure>

<p>owner是第一个 file_operations 成员，它并不是一个操作, 而一个指向拥有该结构的模块的指针，避免正在操作时被卸载，一般为初始化为THIS_MODULES (在 &lt;linux&#x2F;module.h&gt; 中定义的宏)</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br></pre></td></tr></table></figure>

<p>read函数指针用来从设备中同步读取数据，读取成功返回读取的字节数。与应用程序中的 read函数对应。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br></pre></td></tr></table></figure>

<p>write函数指针用来发送数据给设备. 写入成功返回写入的字节数。与应用程序中的write函数对应。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br></pre></td></tr></table></figure>

<p>unlocked_ioctl函数指针提供对于设备的控制功能，与应用程序中的ioctl函数对应。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br></pre></td></tr></table></figure>

<p>open函数指针用于打开设备,与应用程序中的open函数对应。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br></pre></td></tr></table></figure>

<p>release函数指针在file结构体释放时被调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br></pre></td></tr></table></figure>

<p>至此对于file_operations文件操作集的部分常用函数就介绍完了，填充了部分常用函数的 file_operations结构体如下（图12-1）所示：</p>
<p>图 12-1</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_fops_test</span> =</span> &#123;</span><br><span class="line">   .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">   .open = chrdev_open,<span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">   .read = chrdev_read,<span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">   .write = chrdev_write,<span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">   .release = chrdev_release,<span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;<span class="comment">//定义file_operations结构体类型的变量cdev_test_ops</span></span><br></pre></td></tr></table></figure>



<p>会在下个小节进行字符设备驱动框架实验代码的编写，在上一章节实验的基础上加入file_operations结构体，并通过应用程序对字符设备驱动进行文件操作测试。</p>
<h2 id="12-2-实验程序的编写"><a href="#12-2-实验程序的编写" class="headerlink" title="12.2 实验程序的编写"></a>12.2 实验程序的编写</h2><h3 id="12-2-1-驱动程序编写"><a href="#12-2-1-驱动程序编写" class="headerlink" title="12.2.1 驱动程序编写"></a>12.2.1 驱动程序编写</h3><p>本实验驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\07\module。</p>
<p>本章实验将编写字符设备驱动框架实验，会在上一章节实验基础上对file_operation结构体相关内容进行补充。</p>
<p>首先采用自动申请设备号的方式进行设备号的申请，然后对获取的主设备号与次设备号进行打印，之后对字符设备进行注册，并填充相应的file_openration结构体和相关函数，最后自动对设备节点进行创建，编写完成的chrdev_fops.c代码如下（图12-2）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>                                                                                                    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chrdev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is chrdev_open \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">chrdev_read</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is chrdev_read \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">chrdev_write</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> __user *buf,<span class="type">size_t</span> size,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is chrdev_write \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chrdev_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_num;<span class="comment">//定义dev_t类型变量dev_num来表示设备号</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span><span class="comment">//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_fops_test</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = chrdev_open,<span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = chrdev_read,<span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = chrdev_write,<span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = chrdev_release,<span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;<span class="comment">//定义file_operations结构体类型的变量cdev_test_ops</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">class_test</span>;</span><span class="comment">//定于struct class *类型结构体变量class_test，表示要创建的类</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chrdev_fops_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;<span class="comment">//定义int类型的变量ret，用来对函数返回值进行判断</span></span><br><span class="line">    <span class="type">int</span> major,minor;<span class="comment">//定义int类型的主设备号major和次设备号minor</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_num,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;chrdev_name&quot;</span>);<span class="comment">//自动获取设备号，设备名chrdev_name</span></span><br><span class="line">    <span class="keyword">if</span> (ret  &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok \n&quot;</span>);</span><br><span class="line">    major = MAJOR(dev_num);<span class="comment">//使用MAJOR()函数获取主设备号</span></span><br><span class="line">    minor = MINOR(dev_num);<span class="comment">//使用MINOR()函数获取次设备号</span></span><br><span class="line">    printk(<span class="string">&quot;major is %d\n minor is %d \n&quot;</span>,major,minor);</span><br><span class="line">    cdev_init(&amp;cdev_test,&amp;cdev_fops_test);<span class="comment">//使用cdev_init()函数初始化cdev_test结构体，并链接到cdev_test_ops结构体</span></span><br><span class="line">    cdev_test.owner = THIS_MODULE;<span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    ret = cdev_add(&amp;cdev_test,dev_num,<span class="number">1</span>); <span class="comment">//使用cdev_add()函数进行字符设备的添加</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">         printk(<span class="string">&quot;cdev_add is error \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;cdev_add is ok \n&quot;</span>);                                                                                </span><br><span class="line">    class_test  = class_create(THIS_MODULE,<span class="string">&quot;class_test&quot;</span>);<span class="comment">//使用class_create进行类的创建，类名称为class_test</span></span><br><span class="line">    device_create(class_test,<span class="literal">NULL</span>,dev_num,<span class="literal">NULL</span>,<span class="string">&quot;device_test&quot;</span>);<span class="comment">//使用device_create进行设备的创建，设备名称为device_test</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chrdev_fops_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    device_destroy(class_test,dev_num);<span class="comment">//删除创建的设备</span></span><br><span class="line">class_destroy(class_test);<span class="comment">//删除创建的类</span></span><br><span class="line">    cdev_del(&amp;cdev_test);<span class="comment">//删除添加的字符设备cdev_test</span></span><br><span class="line">    unregister_chrdev_region(dev_num,<span class="number">1</span>);<span class="comment">//释放字符设备所申请的设备号</span></span><br><span class="line">    printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(chrdev_fops_init);<span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(chrdev_fops_exit);<span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">//同意GPL开源协议</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);<span class="comment">//作者信息</span></span><br></pre></td></tr></table></figure>

<p>图 12-2</p>
<h3 id="12-2-2-编写测试-APP"><a href="#12-2-2-编写测试-APP" class="headerlink" title="12.2.2 编写测试 APP"></a>12.2.2 编写测试 APP</h3><p>本实验应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\07\app。</p>
<p>由于在驱动程序中，只是对一系列文件操作函数添加了标志打印（之后的章节会加入数据的读写），所以本小节的应用程序只是起简单的测试作用。编写完成的应用程序app.c内容如下（图12-3）所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>];<span class="comment">//定义读取缓冲区buf</span></span><br><span class="line">    fd=open(argv[<span class="number">1</span>],O_RDWR,<span class="number">0666</span>);<span class="comment">//调用open函数，打开输入的第一个参数文件，权限为可读可写</span></span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;open is ok\n&quot;</span>);</span><br><span class="line">	<span class="comment">/*如果第二个参数为read，条件成立，调用read函数，对文件进行读取*/</span>                                                                                                                                  </span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;read&quot;</span>))&#123;</span><br><span class="line">        read(fd,buf,<span class="number">32</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">/*如果第二个参数为write，条件成立，调用write函数，对文件进行写入*/</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;write&quot;</span>))&#123;</span><br><span class="line">        write(fd,<span class="string">&quot;hello\n&quot;</span>,<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">close(fd);<span class="comment">//调用close函数，对取消文件描述符到文件的映射</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>图 12-3</p>
<p>上述应用程序逻辑较为简单，第一个参数为要进行读写操作的设备节点，第二个参数为read时，对设备节点进行读操作，第二个参数为write时，对设备节点进行写操作。</p>
<h2 id="12-3-运行测试"><a href="#12-3-运行测试" class="headerlink" title="12.3 运行测试"></a>12.3 运行测试</h2><h3 id="12-3-1-编译驱动程序"><a href="#12-3-1-编译驱动程序" class="headerlink" title="12.3.1 编译驱动程序"></a>12.3.1 编译驱动程序</h3><p>在上一小节中的chrdev_fops.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图12-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += chrdev_fops.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>图 12-4</p>
<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放chrdev_fops.c和Makefile文件目录下，如下图（图12-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps91.jpg" alt="img"> </p>
<p>图 12-5</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图12-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps92.jpg" alt="img"> </p>
<p>图 12-6</p>
<p>编译完生成chrdev_fops.ko目标文件，如下图（图12-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps93.jpg" alt="img"> </p>
<p>图 12-7</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h3 id="12-3-2-编译应用程序"><a href="#12-3-2-编译应用程序" class="headerlink" title="12.3.2 编译应用程序"></a>12.3.2 编译应用程序</h3><p>来到应用程序app.c文件的存放路径如下图（图12-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps94.jpg" alt="img"> </p>
<p>图 12-8</p>
<p>然后使用以下命令对app.c进行交叉编译，编译完成如下图（图12-9）所示：</p>
<p>aarch64-linux-gnu-gcc -o app app.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps95.jpg" alt="img"> </p>
<p>图 12-9</p>
<p>生成的app文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="12-3-3-运行测试"><a href="#12-3-3-运行测试" class="headerlink" title="12.3.3 运行测试"></a>12.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图12-10）所示：</p>
<p>insmod chrdev_fops.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps96.jpg" alt="img"> </p>
<p>图 12-10</p>
<p>可以看到申请的主设备号和次设备号就被打印了出来，然后使用以下代码对自动生成的设备节点device_test进行查看，如下图（图12-11）所示：</p>
<p> ls &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps97.jpg" alt="img"> </p>
<p>图 12-11</p>
<p>可以看到device_test节点已经被自动创建了，然后使用以下命令对open()函数进行测试，如下图（图12-11）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps98.jpg" alt="img"> </p>
<p>图 12-12</p>
<p>可以看到“This is chrdev_open”和“open is ok”信息被打印了，证明应用程序运行成功，且调用了驱动程序中的open(…)函数，而“Segmentation fault”相关打印是因为没有对第二个参数进行传入，这里忽略即可，随后使用以下命令对设备进行读测试，如下图（图12-13）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test read</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps99.jpg" alt="img"> </p>
<p>图 12-13</p>
<p>可以看到“This is chrdev_read”信息被打印了出来，证明驱动程序中的read(…)函数被调用了,然后使用以下命令对设备进行写测试，如下图（图12-14）所示：</p>
<p>.&#x2F;app &#x2F;dev&#x2F;device_test write</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps100.jpg" alt="img"> </p>
<p>图 12-14</p>
<p>可以看到“This is chrdev_write”信息被打印了出来，证明驱动程序中的write(…)函数被调用了。最后可以使用以下命令进行驱动的卸载，如下图（图12-15）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps101.jpg" alt="img"> </p>
<p>图 12-15</p>
<p>至此，字符设备驱动框架实验就完成了。</p>
<h1 id="第13章-杂项设备驱动实验"><a href="#第13章-杂项设备驱动实验" class="headerlink" title="第13章 杂项设备驱动实验"></a>第13章 杂项设备驱动实验</h1><p>经过前面章节的学习，我们已经对字符设备驱动框架有了一定的理解，而本章要讲解的杂项设备属于特殊的一种字符型设备，是对字符设备的一种封装，为最简单的字符设备。为什么从字符设备中单独提取出了杂项设备呢？杂项设备又要如何进行使用呢？带着疑问，让我们进行杂项设备的学习吧！</p>
<h2 id="13-1-杂项设备驱动简介"><a href="#13-1-杂项设备驱动简介" class="headerlink" title="13.1 杂项设备驱动简介"></a>13.1 杂项设备驱动简介</h2><p>在Linux中，把无法归类的五花八门的设备定义成杂项设备。相较于字符设备，杂项设备有以下两个优点:</p>
<p>(1)节省主设备号:杂项设备的主设备号固定为10，而字符设备不管是动态分配还是静态分配设备号，都会消耗一个主设备号，进而造成了主设备号浪费。当系统中注册了多个misc设备驱动时，只需使用子设备号进行区分即可。</p>
<p>(2)使用简单：当使用普通的字符设备驱动时，如果开发人员需要导出操作接口给用户空间，就需要注册对应的字符驱动，并创建字符设备class从而自动在&#x2F;dev下生成设备节点，而misc驱动只需要将基本信息通过结构体传递给相应处理函数即可。</p>
<p>在驱动中使用miscdevice结构体描述misc设备，该结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;miscdevice.h”文件中（在下面的实验代码中需要加入该头文件的引用），具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span>  &#123;</span></span><br><span class="line">	<span class="type">int</span> minor; <span class="comment">/* 子设备号 需要用户填写*/</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;<span class="comment">/* 设备名 需要用户填写*/</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span><span class="comment">/* 设备操作集 需要用户填写*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">this_device</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *nodename;</span><br><span class="line">	<span class="type">umode_t</span> mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义一个misc 设备，一般只需要填充minor、name、fops 这三个成员变量。</p>
<p>minor指次设备号，可以从“内核源码&#x2F;include&#x2F;linux&#x2F;miscdevice.h”文件中预定义的次设备号挑选，也可以自行定义子设备号（没有被其他设备使用即可），通常情况下将该参数设置为MISC_DYNAMIC_MINOR，表示自动分配子设备号。</p>
<p>name表示misc设备的名字。misc设备驱动注册成功之后，会在dev目录下生成名为name的设备节点。</p>
<p>fops 指向了file_operations的结构体，表示字符设备的操作集合。</p>
<h2 id="13-2-杂项设备的注册和卸载"><a href="#13-2-杂项设备的注册和卸载" class="headerlink" title="13.2 杂项设备的注册和卸载"></a>13.2 杂项设备的注册和卸载</h2><p>不同于字符设备的注册和卸载的繁琐，杂项设备的注册可以直接使用函数misc_register函数来完成，杂项设备的卸载可以直接使用misc_deregister函数来完成。上述两个函数均定义在“内核源码&#x2F;include&#x2F;linux&#x2F;miscdevice.h”文件当中。</p>
<p>杂项设备的注册：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int misc_register(struct miscdevice *misc)</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>基于misc_class构造一个设备，将miscdevice结构挂载到misc_list列表上，并初始化与linux设备模型相关的结构。进而起到杂项设备注册的作用。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p> misc: 杂项设备的结构体指针</p>
<p>****函数返回值：****申请成功返回0，申请失败返回负数</p>
<p>杂项设备的卸载：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int misc_deregister(struct miscdevice *misc)</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>从mist_list中删除miscdevice，进而起到杂项设备卸载的作用。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p> misc: 杂项设备的结构体指针</p>
<p>****函数返回值：****卸载成功返回0，申请失败返回负数</p>
<p>至此，注册和卸载杂项设备的API函数就讲解完成了，会在接下来的驱动章节中对上述函数进行具体使用。</p>
<h2 id="13-3-杂项设备驱动框架"><a href="#13-3-杂项设备驱动框架" class="headerlink" title="13.3 杂项设备驱动框架"></a>13.3 杂项设备驱动框架</h2><p>MISC驱动一般使用以下结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">xxx_fops</span>&#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">	.read = xxx_read,</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">xxx_dev</span>&#123;</span></span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">    .name = <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">    .fops = &amp;xxx_fops</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;xxx_init\r\n&quot;</span>);</span><br><span class="line">    ret = misc_register(&amp;xxx_dev);<span class="comment">//注册杂项设备</span></span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         printk( <span class="string">&quot;misc_register failed\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> 	printk( <span class="string">&quot;misc_register ok\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_exit</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;xxx_exit\r\n&quot;</span>);</span><br><span class="line">    misc_deregister(&amp;xxx_dev);  <span class="comment">//卸载杂项设备</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(xxx_init);    <span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(xxx_exit);   </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);   </span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="13-4-实验程序的编写"><a href="#13-4-实验程序的编写" class="headerlink" title="13.4 实验程序的编写"></a>13.4 实验程序的编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\08。</p>
<p>本小节将编写最简单的misc驱动，在驱动入口函数中通过misc_register(…)函数注册杂项设备驱动，在驱动出口函数中通过misc_deregister(…)函数注销杂项设备驱动。编写完成的miscdevice.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>              <span class="comment">//初始化头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>            <span class="comment">//最基本的文件，支持动态添加和卸载模块。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span>        <span class="comment">//注册杂项设备头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span>                <span class="comment">//注册设备节点的文件结构体</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">misc_fops</span> =</span> &#123; <span class="comment">//文件操作集</span></span><br><span class="line">    .owner = THIS_MODULE <span class="comment">////将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">misc_dev</span> =</span> &#123;       <span class="comment">//杂项设备结构体</span></span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR,     <span class="comment">//动态申请的次设备号</span></span><br><span class="line">    .name = <span class="string">&quot;test&quot;</span>,                  <span class="comment">//杂项设备名字是hello_misc</span></span><br><span class="line">    .fops = &amp;misc_fops,              <span class="comment">//文件操作集</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">misc_init</span><span class="params">(<span class="type">void</span>)</span>           </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = misc_register(&amp;misc_dev); <span class="comment">//在初始化函数中注册杂项设备</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;misc registe is error \n&quot;</span>); <span class="comment">//打印注册杂项设备失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;misc registe is succeed \n&quot;</span>);<span class="comment">//打印注册杂项设备成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">misc_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">    misc_deregister(&amp;misc_dev);     <span class="comment">//在卸载函数中注销杂项设备</span></span><br><span class="line">    printk(<span class="string">&quot; misc goodbye! \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(misc_init);</span><br><span class="line">module_exit(misc_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="13-5-运行测试"><a href="#13-5-运行测试" class="headerlink" title="13.5 运行测试"></a>13.5 运行测试</h2><h3 id="13-5-1-编译驱动程序"><a href="#13-5-1-编译驱动程序" class="headerlink" title="13.5.1 编译驱动程序"></a>13.5.1 编译驱动程序</h3><p>在上一小节中的miscdevice.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += miscdevice.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>Makefile保存退出之后，来到存放miscdevice.c和Makefile文件目录下，如下图（图13-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps102.jpg" alt="img"> </p>
<p>图 13-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 13-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps103.jpg" alt="img"> </p>
<p>图 13-2</p>
<p>编译完生成 miscdevice.ko目标文件，如下图（图 13-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps104.jpg" alt="img"> </p>
<p>图 13-2</p>
<p>至此我们的驱动模块就编译成功了，下面进行驱动的运行测试。</p>
<h3 id="13-5-2-运行测试"><a href="#13-5-2-运行测试" class="headerlink" title="13.5.2 运行测试"></a>13.5.2 运行测试</h3><p>将编译生成的驱动模块miscdevice.ko拷贝到开发板上，输入以下命令加载驱动模块。</p>
<p>insmod miscdevice.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps105.jpg" alt="img"> </p>
<p>图 13-3</p>
<p>可以看到驱动加载之后，打印“misc registe is succeed”,说明misc驱动注册成功。输入以下命令查看加载的驱动模块，驱动加载成功如下（图13-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps106.jpg" alt="img"> </p>
<p>图 13-4</p>
<p>然后来到&#x2F;sys&#x2F;class&#x2F;misc目录下，可以看到名为“test”的文件夹已经被创建了，在&#x2F;sys&#x2F;class&#x2F;misc目录下有misc类的所有设备，每个注册的杂项设备对应一个文件夹目录，如下图（图13-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps107.jpg" alt="img"> </p>
<p>图 13-5</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps108.jpg" alt="img"> </p>
<p>图 13-7</p>
<p>驱动加载成功之后会生成&#x2F;dev&#x2F;test设备驱动文件，输入以下命令查看杂项设备的主次设备号。</p>
<p>ls &#x2F;dev&#x2F;test -al</p>
<p>结果如下图（图 13-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps109.jpg" alt="img"> </p>
<p>图 13-8</p>
<p>从上图可以看出，&#x2F;dev&#x2F;test这个杂项设备的主设备号为10，次设备号为53，最后可以使用以下命令对驱动进行卸载，卸载完成如下图（图 13-9）所示：</p>
<p>rmmod miscdevice.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps110.jpg" alt="img"> </p>
<p>图 13-9</p>
<h1 id="第14章-内核空间与用户空间数据交互实验"><a href="#第14章-内核空间与用户空间数据交互实验" class="headerlink" title="第14章 内核空间与用户空间数据交互实验"></a>第14章 内核空间与用户空间数据交互实验</h1><p>在“第12章 字符设备驱动框架实验”中，已经对file_operations结构体的进行了填充，该结构体的每一个成员都对应着一个系统调用，例如read、write等，在对应的实验中，只是对调用函数进行了标志打印，并没有真正实现设备的读写功能，而在本章节将对内核空间与用户空间的数据交换功能进行实现。</p>
<h2 id="14-1-内核空间与用户空间"><a href="#14-1-内核空间与用户空间" class="headerlink" title="14.1 内核空间与用户空间"></a>14.1 内核空间与用户空间</h2><p>Linux系统将可访问的内存空间分为了两个部分，一部分是内核空间，一部分是用户空间。操作系统和驱动程序运行在内核空间（内核态），应用程序运行在用户空间（用户态）。</p>
<p>那么为什么要区分用户空间和内核空间呢？</p>
<p>（1）内核空间中的代码控制了硬件资源，用户空间中的代码只能通过内核暴露的系统调用接口来使用系统中的硬件资源，这样的设计可以保证操作系统自身的安全性和稳定性。</p>
<p>（2）从另一方面来说，内核空间的代码更偏向于系统管理，而用户空间中的代码更偏重业务逻辑实现，俩者的分工不同。</p>
<p>硬件资源管理都是在内核空间完成的，应用程序无法直接对硬件进行操作，只能通过调用相应的内核接口来完成相应的操作。比如应用程序要对磁盘上的一个文件进行读取，应用程序可以向内核发起一个“系统调用”申请——我要读取磁盘上的文件。这个过程其实是通过一个特殊的指令让进程从用户态进入到了内核态。在内核空间中，CPU可以执行任何命令，包括从磁盘上读取数据，具体过程是先把数据读取到内核空间中，然后再把数据拷贝到用户空间并从内核态切换到用户态。此时应用程序已经从系统调用中返回并拿到了想要的数据，可以继续往下执行了。</p>
<p>进程只有从用户空间切换到内核空间才可以使用系统的硬件资源，切换的方式有三种：系统调用，软中断，硬中断，如下图（图 14-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps111.jpg" alt="img"> </p>
<p>图 14-1</p>
<h2 id="14-2-用户空间和内核空间数据交换"><a href="#14-2-用户空间和内核空间数据交换" class="headerlink" title="14.2 用户空间和内核空间数据交换"></a>14.2 用户空间和内核空间数据交换</h2><p>内核空间和用户空间的内存是不能互相访问的。但是很多应用程序都需要和内核进行数据的交换，例如应用程序使用read函数从驱动中读取数据，使用write函数向驱动中写数据，上述功能就需要使用copy_from_user和copy_to_user俩个函数来完成。copy_from_user函数是将用户空间的数据拷贝到内核空间。copy_to_user函数是将内核空间的数据拷贝到用户空间。</p>
<p>这俩个函数定义在了kernel&#x2F;include&#x2F;linux&#x2F;uaccess.h文件下，如下所示：</p>
<p>copy_to_user</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>unsigned long copy_to_user_inatomic(void __user *to, const void *from, unsigned long n);</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>把内核空间的数据复制到用户空间。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>*to是用户空间的指针</p>
<p>*from是内核空间的指针</p>
<p>n是从内核空间向用户空间拷贝的字节数</p>
<p>copy_from_user</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>unsigned long copy_from_user(void *to, const void __user *from, unsigned long n)</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>把用户空间的数据复制到内核空间。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>*to是内核空间的指针</p>
<p>*from是用户空间的指针</p>
<p>n是从用户空间向内核空间拷贝的字节数</p>
<h2 id="14-3-实验程序编写"><a href="#14-3-实验程序编写" class="headerlink" title="14.3 实验程序编写"></a>14.3 实验程序编写</h2><h3 id="14-3-1-驱动程序编写"><a href="#14-3-1-驱动程序编写" class="headerlink" title="14.3.1 驱动程序编写"></a>14.3.1 驱动程序编写</h3><p>本驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\09\module。</p>
<p>在该实验中将实现内核空间和用户空间进行数据交换的功能。以12章编写的字符设备驱动框架实验为基础编写驱动程序，程序使用copy_to_user函数和copy_from_user函数来实现内核空间和用户空间互传数据的功能，编写完成的file.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;  <span class="comment">//主设备号</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> minor = <span class="number">0</span>;  <span class="comment">//次设备号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>       <span class="comment">//类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>    <span class="comment">//设备</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*本章实验重点******/</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//定义写入缓存区kbuf</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);<span class="comment">//打印copy_from_user函数执行失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_write\r\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;kbuf is %s\r\n&quot;</span>, kbuf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*本章实验重点******/</span></span><br><span class="line"><span class="type">char</span> kbuf[<span class="number">32</span>] = <span class="string">&quot;This is cdev_test_read!&quot;</span>;<span class="comment">//定义内核空间数据</span></span><br><span class="line"><span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, kbuf, <span class="built_in">strlen</span>(kbuf)) != <span class="number">0</span>)     &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>); <span class="comment">//打印copy_to_user函数执行失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数，定义file_operations结构体类型的变量cdev_test_fops*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read,  <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"><span class="comment">/*1 创建设备号*/</span></span><br><span class="line"><span class="comment">//动态分配设备号</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>);     <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);<span class="comment">//打印动态分配设备号失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    major = MAJOR(dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    minor = MINOR(dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">    cdev_add(&amp;cdev_test, dev_num, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">    device = device_create(class, <span class="literal">NULL</span>, dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;cdev_test);               <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(class, dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);   <span class="comment">//注册入口函数</span></span><br><span class="line">module_exit(chr_fops_exit);  <span class="comment">//注册出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码在cdev_test_read函数中使用copy_to_user函数将内核数据拷贝到用户空间，在cdev_test_write函数中使用copy_from_user函数将用户空间数据拷贝到内核空间。</p>
<h3 id="14-3-2-编写测试-APP"><a href="#14-3-2-编写测试-APP" class="headerlink" title="14.3.2 编写测试 APP"></a>14.3.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\09\app。</p>
<p>编写测试APP其实是在编写Linux应用，编译完成的应用程序app.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  <span class="comment">//主函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;   <span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//定义读取缓存区buf1</span></span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>; <span class="comment">//定义写入缓存区buf2</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开字符设备驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    read(fd, buf1, <span class="keyword">sizeof</span>(buf1));<span class="comment">//从/dev/test文件读取数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf1 is %s \r\n&quot;</span>, buf1); <span class="comment">//打印读取的数据</span></span><br><span class="line"></span><br><span class="line">    write(fd,buf2,<span class="keyword">sizeof</span>(buf2));<span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="14-4-运行测试"><a href="#14-4-运行测试" class="headerlink" title="14.4 运行测试"></a>14.4 运行测试</h2><h3 id="14-4-1-编译驱动程序"><a href="#14-4-1-编译驱动程序" class="headerlink" title="14.4.1 编译驱动程序"></a>14.4.1 编译驱动程序</h3><p>在上一小节中的file.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下   所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m +=file.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放file.c和Makefile文件目录下，如下图（图14-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps112.jpg" alt="img"> </p>
<p>图 14-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图14-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps113.jpg" alt="img"> </p>
<p>图14-3</p>
<p>编译完生成 file.ko目标文件，如下图（图 14-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps114.jpg" alt="img"> </p>
<p>图 14-4</p>
<p>至此我们的驱动模块就编译成功了，下面进行应用程序编译.</p>
<h3 id="14-4-2-编译应用程序"><a href="#14-4-2-编译应用程序" class="headerlink" title="14.4.2 编译应用程序"></a>14.4.2 编译应用程序</h3><p>因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图 14-5）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps115.jpg" alt="img"> </p>
<p>图 14-5</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="14-4-3-运行测试"><a href="#14-4-3-运行测试" class="headerlink" title="14.4.3 运行测试"></a>14.4.3 运行测试</h3><p>驱动模块file.ko和测试程序app都已经准备好了，接下来就是运行测试。首先输入以下命令加载驱动程序，如下图（图14–6）所示：</p>
<p>insmod file.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps116.jpg" alt="img"> </p>
<p>图 14-6</p>
<p>输入以下命令运行应用程序，如下图（图 14-7）所示</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps117.jpg" alt="img"> </p>
<p>图 14-7</p>
<p>由上图可知，打印“This is cdev_test_open”信息说明成功打开了字符设备驱动。</p>
<p>打印“ This is cdev_test_read”和“buf1 is This is cdev_test_read!”说明应用程序成功读取到内核的数据。</p>
<p>打印“This is cdev_test_write”和“kbuf is nihao”说明应用程序向内核写数据成功。</p>
<p>最后打印“This is cdev_test_release”说明卸载字符设备。</p>
<h1 id="第15章-文件私有数据实验"><a href="#第15章-文件私有数据实验" class="headerlink" title="第15章 文件私有数据实验"></a>第15章 文件私有数据实验</h1><p>在之前章节编写的驱动程序中，将生成字符设备的一些硬件属性（设备号、类、设备名称等）全都写成了变量的形式，虽然这样编写驱动代码不会产生报错，但是会显得有点不专业。通常在驱动开发中会为设备定义相关的设备结构体，将硬件属性的描述信息全部放在该结构体中，在本章节中将对设备结构体的功能实现和文件私有数据进行学习。</p>
<h2 id="15-1-文件私有数据简介"><a href="#15-1-文件私有数据简介" class="headerlink" title="15.1 文件私有数据简介"></a>15.1 文件私有数据简介</h2><p>Linux中并没有明确规定要使用文件私有数据，但是在linux驱动源码中，广泛使用了文件私有数据，这是Linux驱动遵循的“潜规则”，实际上也体现了Linux面向对象的思想。struct file 结构体中专门为用户留了一个域用于定义私有数据。结构体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">fu_llist</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">fu_rcuhead</span>;</span></span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span>	<span class="comment">/* cached value */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protects f_ep_links, f_flags.</span></span><br><span class="line"><span class="comment">	 * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rw_hint</span>		<span class="title">f_write_hint</span>;</span></span><br><span class="line">	<span class="type">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> 		f_flags;</span><br><span class="line">	<span class="type">fmode_t</span>			f_mode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">	<span class="type">loff_t</span>			f_pos;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="type">void</span>			*private_data;<span class="comment">//私有数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_ep_links</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_tfile_llink</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span></span><br><span class="line">	<span class="type">errseq_t</span>		f_wb_err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件私有数据的概念在Linux驱动中有着非常广泛的应用，文件私有数据就是将私有数据private_data指向设备结构体。通过它可以将私有数据一路从open函数带到read, write函数层层传入。一般是在open 的时候赋值，read、write时使用。open函数中私有数据的使用如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">	file-&gt;private_data=&amp;dev1;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，定义了一个设备结构体dev1，然后在open函数中，将私有数据private_data指向了设备结构体dev1。</p>
<p>我们可以在read write函数中通过private_data访问设备结构体，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">const</span> <span class="type">char</span> _user *buf, <span class="type">size_t</span> size,<span class="type">loff_t</span> *<span class="type">off_t</span>)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-2-实验程序编写"><a href="#15-2-实验程序编写" class="headerlink" title="15.2 实验程序编写"></a>15.2 实验程序编写</h2><h3 id="15-2-1-驱动程序编写"><a href="#15-2-1-驱动程序编写" class="headerlink" title="15.2.1 驱动程序编写"></a>15.2.1 驱动程序编写</h3><p>本驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\10\module。</p>
<p>本章实验将编写Linux下的使用文件私有数据实例代码，在open函数中对私有数据结构体赋值，在write函数中使用。编写完成的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">dev_t</span> dev_num;              <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;                  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;                   <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span>          <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>             <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>          <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];                <span class="comment">//缓存区buf</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  <span class="comment">//定义一个device_test结构体变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;  <span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data; <span class="comment">//在write函数中读取private_data</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_write\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;kbuf is %s\r\n&quot;</span>, test_dev-&gt;kbuf); <span class="comment">//打印kbuf的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;    </span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,         <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open,         <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read,          <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write,         <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release,<span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">  dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">    cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建设备*/</span></span><br><span class="line">    dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="15-2-2-编写测试-APP"><a href="#15-2-2-编写测试-APP" class="headerlink" title="15.2.2 编写测试 APP"></a>15.2.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\10\app。</p>
<p>编写测试APP其实是在编写Linux应用，在应用程序中向设备文件写入数据，编写完成的应用程序app.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> <span class="comment">//主函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>;  <span class="comment">//定义写入缓存区buf1</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR); <span class="comment">//打开/dev/test设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd,buf1,<span class="keyword">sizeof</span>(buf1)); <span class="comment">//向/dev/test设备写入数据</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-3-运行测试"><a href="#15-3-运行测试" class="headerlink" title="15.3 运行测试"></a>15.3 运行测试</h2><h3 id="15-3-1-编译驱动程序"><a href="#15-3-1-编译驱动程序" class="headerlink" title="15.3.1 编译驱动程序"></a>15.3.1 编译驱动程序</h3><p>在上一小节中的file.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图5-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += file.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放file.c和Makefile文件目录下，如下图（图15-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps118.jpg" alt="img"> </p>
<p>图15-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图15-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps119.jpg" alt="img"> </p>
<p>图 15-2</p>
<p>编译完生成 file.ko目标文件，如下图（图15-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps120.jpg" alt="img"> </p>
<p>图 15-3</p>
<p>至此我们的驱动模块就编译成功了，下面进行应用程序编译，</p>
<h3 id="15-3-2-编译应用程序"><a href="#15-3-2-编译应用程序" class="headerlink" title="15.3.2 编译应用程序"></a>15.3.2 编译应用程序</h3><p>因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图15-4）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps121.jpg" alt="img"> </p>
<p>图15-4</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="15-3-3-运行测试"><a href="#15-3-3-运行测试" class="headerlink" title="15.3.3 运行测试"></a>15.3.3 运行测试</h3><p>驱动模块file.ko和测试程序app都已经准备好了，接下来就是运行测试。</p>
<p>输入以下命令加载驱动程序</p>
<p>insmod file.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps122.jpg" alt="img"> </p>
<p>图 15-5</p>
<p>驱动加载成功之后会生成&#x2F;dev&#x2F;test设备驱动文件，输入以下命令查看杂项设备的主次设备号。</p>
<p>ls &#x2F;dev&#x2F;test -al</p>
<p>结果如下图（图15-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps123.jpg" alt="img"> </p>
<p>图 15-6</p>
<p>运行应用程序，如下（图 15-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps124.jpg" alt="img"> </p>
<p>图 15-7</p>
<p>在此实验中，将硬件属性的信息全部放在一个结构体private_data，依然可以实现字符设备的操作。</p>
<h1 id="第16章-一个驱动兼容不同设备实验"><a href="#第16章-一个驱动兼容不同设备实验" class="headerlink" title="第16章 一个驱动兼容不同设备实验"></a>第16章 一个驱动兼容不同设备实验</h1><p>在Linux中，使用主设备号来表示对应某一类驱动，使用次设备号来表示这类驱动下的各个设备。假如现在驱动要支持的主设备号相同，但是次设备号不同的设备。驱动程序要怎样编写呢，上一章节学习的私有数据private_date在此时就派上了用场，具体是怎样使用的呢，多个设备是如何在一个驱动中兼容的呢，带着疑问，让我们开始本章节的学习吧。</p>
<h2 id="16-1-container-of函数简介"><a href="#16-1-container-of函数简介" class="headerlink" title="16.1 container_of函数简介"></a>16.1 container_of函数简介</h2><p>container_of在Linux内核中是一个常用的宏，用于从包含在某个结构中的指针获得结构本身的指针，通俗地讲就是通过结构体变量中某个成员的首地址进而获得整个结构体变量的首地址。那么可以使用这个函数获取不同设备的地址，来对不同的设备进行操作，从而一个驱动可以兼容不同的设备。</p>
<p>container_of</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>container_of(ptr,type,member)</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>通过结构体变量中某个成员的首地址获取到整个结构体变量的首地址。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>ptr是结构体变量中某个成员的地址。</p>
<p>type是结构体的类型 </p>
<p>member是该结构体变量的具体名字</p>
<p>container_of宏的作用是通过结构体内某个成员变量的地址和该变量名，以及结构体类型。找到该结构体变量的地址。</p>
<h2 id="16-2-实验程序编写"><a href="#16-2-实验程序编写" class="headerlink" title="16.2 实验程序编写"></a>16.2 实验程序编写</h2><h3 id="16-2-1-驱动程序编写"><a href="#16-2-1-驱动程序编写" class="headerlink" title="16.2.1 驱动程序编写"></a>16.2.1 驱动程序编写</h3><p>本驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\11\module。</p>
<p>本章实验将使用container_of函数编写一个驱动兼容不同设备的实例代码，编写完成的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> dev_num;             <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major;                  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor;                  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span>        <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>           <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>        <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];              <span class="comment">//定义缓冲区kbuf</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span>   <span class="comment">//定义一个device_test结构体变量dev1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev2</span>;</span>  <span class="comment">//定义一个device_test结构体变量dev2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    dev1.minor = <span class="number">0</span>;    <span class="comment">//设置dev1的次设备号为0</span></span><br><span class="line">    dev2.minor = <span class="number">1</span>;   <span class="comment">//设置dev2的次设备号为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//inode-&gt;i_rdev 为该 inode 的设备号，使用container_of函数找到结构体变量dev1 dev2的地址</span></span><br><span class="line"><span class="comment">//然后设置私有数据</span></span><br><span class="line">    file-&gt;private_data = container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> device_test, cdev_test);</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span> =</span> (<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="comment">//如果次设备号是0，则为dev1</span></span><br><span class="line">    <span class="keyword">if</span> (test_dev-&gt;minor == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(<span class="string">&quot; test_dev-&gt;kbuf is %s\r\n&quot;</span>, test_dev-&gt;kbuf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果次设备号是1，则为dev2</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(test_dev-&gt;minor == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(<span class="string">&quot; test_dev-&gt;kbuf is %s\r\n&quot;</span>, test_dev-&gt;kbuf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span> =</span> (<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>(test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数,定义file_operations结构体类型的变量cdev_test_fops*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号,,这里注册2个设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对设备1进行操作</span></span><br><span class="line">    <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">    cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">    dev1.class = class_create(THIS_MODULE, <span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5 创建设备*/</span></span><br><span class="line">    dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev2.major = MAJOR(dev1.dev_num + <span class="number">1</span>); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev2.minor = MINOR(dev1.dev_num + <span class="number">1</span>); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev2.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev2.minor); <span class="comment">//打印次设备号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对设备2进行操作</span></span><br><span class="line">  <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev2.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev2.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">    cdev_add(&amp;dev2.cdev_test, dev1.dev_num + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">    dev2.class = class_create(THIS_MODULE, <span class="string">&quot;test2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">    dev2.device = device_create(dev2.class, <span class="literal">NULL</span>, dev1.dev_num + <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&quot;test2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>);    <span class="comment">//注销设备号</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num + <span class="number">1</span>, <span class="number">1</span>);  <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                  <span class="comment">//删除cdev</span></span><br><span class="line">    cdev_del(&amp;dev2.cdev_test);                  <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);     <span class="comment">//删除设备</span></span><br><span class="line">    device_destroy(dev2.class, dev1.dev_num + <span class="number">1</span>);  <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">    class_destroy(dev2.class);                 <span class="comment">//删除类</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="16-2-2-编写测试-APP"><a href="#16-2-2-编写测试-APP" class="headerlink" title="16.2.2 编写测试 APP"></a>16.2.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\11\app。</p>
<p>编写应用程序，打开生成的俩个设备，并向俩个设备中写入数据，编写完成的应用程序app.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd1;  <span class="comment">//定义设备1的文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd2;  <span class="comment">//定义设备2的文件描述符</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = <span class="string">&quot;nihao /dev/test1&quot;</span>;   <span class="comment">//定义写入缓存区buf1</span></span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = <span class="string">&quot;nihao /dev/test2&quot;</span>;   <span class="comment">//定义写入缓存区buf2</span></span><br><span class="line">    fd1 = open(<span class="string">&quot;/dev/test1&quot;</span>, O_RDWR);  <span class="comment">//打开设备1：test1</span></span><br><span class="line">    <span class="keyword">if</span> (fd1 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd1;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd1,buf1,<span class="keyword">sizeof</span>(buf1));  <span class="comment">//向设备1写入数据</span></span><br><span class="line">    close(fd1); <span class="comment">//取消文件描述符到文件的映射</span></span><br><span class="line"></span><br><span class="line">    fd2= open(<span class="string">&quot;/dev/test2&quot;</span>, O_RDWR); <span class="comment">//打开设备2：test2</span></span><br><span class="line">    <span class="keyword">if</span> (fd2 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd2;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd2,buf2,<span class="keyword">sizeof</span>(buf2));  <span class="comment">//向设备2写入数据</span></span><br><span class="line">    close(fd2);   <span class="comment">//取消文件描述符到文件的映射</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="16-3-运行测试"><a href="#16-3-运行测试" class="headerlink" title="16.3 运行测试"></a>16.3 运行测试</h2><h3 id="16-3-1-编译驱动程序"><a href="#16-3-1-编译驱动程序" class="headerlink" title="16.3.1 编译驱动程序"></a>16.3.1 编译驱动程序</h3><p>在上一小节中的file.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图5-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += file.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放file.c和Makefile文件目录下，如下图（图16-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps125.jpg" alt="img"> </p>
<p>图 16-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图16-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps126.jpg" alt="img"> </p>
<p>图 16-2</p>
<p>编译完生成 file.ko目标文件，如下图（图16-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps127.jpg" alt="img"> </p>
<p>图 16-3</p>
<p>至此我们的驱动模块就编译成功了，下面进行应用程序编译</p>
<h3 id="16-3-2-编译应用程序"><a href="#16-3-2-编译应用程序" class="headerlink" title="16.3.2 编译应用程序"></a>16.3.2 编译应用程序</h3><p>因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图 16-4）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps128.jpg" alt="img"> </p>
<p>图 16-5</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="16-3-2-运行测试"><a href="#16-3-2-运行测试" class="headerlink" title="16.3.2 运行测试"></a>16.3.2 运行测试</h3><p>驱动模块file.ko和测试程序app都已经准备好了，接下来就是运行测试。</p>
<p>输入以下命令加载驱动模块，如下图（图 16-6）所示：</p>
<p>insmod file.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps129.jpg" alt="img"> </p>
<p>图 16-7</p>
<p>驱动加载成功之后会生成&#x2F;dev&#x2F;test1和&#x2F;dev&#x2F;test2设备驱动文件，输入以下命令查看设备，可以看到一个驱动创建并管理了多个驱动设备，如下图（图 16-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps130.jpg" alt="img"> </p>
<p>图 16-9</p>
<p>运行应用程序，如下（图 16-10）所示:</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps131.jpg" alt="img"> </p>
<p>图 16-11</p>
<p>如上图所示，可以看到用户顺利向俩个设备写入数据，且每个设备拥有私有数据。</p>
<h1 id="第17章-Linux错误处理实验"><a href="#第17章-Linux错误处理实验" class="headerlink" title="第17章 Linux错误处理实验"></a>第17章 Linux错误处理实验</h1><p>在前面章节进行的字符设备驱动实验中，即使是最简单的注册字符设备，也存在注册失败的可能性，因此在之前编写的驱动代码中采用检查函数返回值的方式，确认函数是否成功执行，而在本章节中将采用goto语句对Linux错误处理进行更进一步的处理。</p>
<h2 id="17-1-goto语句简介"><a href="#17-1-goto语句简介" class="headerlink" title="17.1 goto语句简介"></a>17.1 goto语句简介</h2><p>在编写驱动程序时，驱动程序应该提供函数执行失败后处理的能力。如果驱动程序中函数执行失败了，必须取消掉所有失败前的注册，否则内核会处于一个不稳定的状态，因为它包含了不存在代码的内部指针。在处理Linux错误时，最好使用goto语句，goto语句的使用示例如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>   init <span class="title function_">my_init_function</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line">err = register_this(ptr1, <span class="string">&quot;skull&quot;</span>); </span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">	<span class="keyword">goto</span> fail_this;</span><br><span class="line"></span><br><span class="line">err = register_that(ptr2, <span class="string">&quot;skull&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">	<span class="keyword">goto</span> fail_that;</span><br><span class="line"></span><br><span class="line">err = register_those(ptr3, <span class="string">&quot;skull&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">	<span class="keyword">goto</span> fail_those;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line"> </span><br><span class="line">fail_those:</span><br><span class="line">	unregister_that(ptr2, <span class="string">&quot;skull&quot;</span>); </span><br><span class="line">fail_that:</span><br><span class="line">	unregister_this(ptr1, <span class="string">&quot;skull&quot;</span>);</span><br><span class="line">fail_this:</span><br><span class="line">	<span class="keyword">return</span> err;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中试图注册3个虚构设备，goto语句在失败情况下使用，对之前已经成功注册的设施进行注销。使用goto语句处理的时候，应该遵循“先进后出”的原则，如下图（图 17-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps132.jpg" alt="img"> </p>
<p>图 17-2</p>
<p>如果在驱动代码中初始化和卸载函数比较复杂，goto方法可能变得难于管理，为了使代码重复性最小以及流程化，Linux提供了更简便的方法，我们接着来学习下一小节。</p>
<h2 id="17-2-IS-ERR-简介"><a href="#17-2-IS-ERR-简介" class="headerlink" title="17.2 IS_ERR()简介"></a>17.2 IS_ERR()简介</h2><p>对于任何一个指针来说，必然存在三种情况，一种是合法指针，一种是NULL(也就是空指针)，一种是错误指针(也就是无效指针)。在Linux内核中，所谓的错误指针已经指向了内核空间的最后一页，例如，对于一个64位系统来说，内核空间最后地址为0xffffffffffffffff，那么最后一页的地址是0xfffffffffffff000~0xffffffffffffffff，这段地址是被保留的，如果指针落在这段地址之内，说明是错误的无效指针。</p>
<p>在Linux内核源码中实现了指针错误的处理机制，相关的函数接口主要有IS_ERR()、PTR_ERR()、ERR_PTR()等，其函数的源码在include&#x2F;linux&#x2F;err.h文件中，如下所示：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\ksohtml55808\wps133.jpg" alt="img"> </p>
<p>如上图所示，在Linux源码中IS_ERR()函数其实就是判断指针是否出错，如果指针指向了内核空间的最后一页，就说明指针是一个无效指针，如果指针并不是落在内核空间的最后一页，就说明这指针是有效的。无效的指针能表示成一种负数的错误码，如果想知道这个指针是哪个错误码，使用PTR_ERR函数转化。0xfffffffffffff000~0xffffffffffffffff这段地址和Linux错误码是一一对应的，内核错误码保存在errno-base.h文件中。如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_GENERIC_ERRNO_BASE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_GENERIC_ERRNO_BASE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EPERM		 1	<span class="comment">/* Operation not permitted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOENT		 2	<span class="comment">/* No such file or directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ESRCH		 3	<span class="comment">/* No such process */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EINTR		 4	<span class="comment">/* Interrupted system call */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EIO		 5	<span class="comment">/* I/O error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENXIO		 6	<span class="comment">/* No such device or address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	E2BIG		 7	<span class="comment">/* Argument list too long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOEXEC		 8	<span class="comment">/* Exec format error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EBADF		 9	<span class="comment">/* Bad file number */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ECHILD		10	<span class="comment">/* No child processes */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EAGAIN		11	<span class="comment">/* Try again */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOMEM		12	<span class="comment">/* Out of memory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EACCES		13	<span class="comment">/* Permission denied */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EFAULT		14	<span class="comment">/* Bad address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOTBLK		15	<span class="comment">/* Block device required */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EBUSY		16	<span class="comment">/* Device or resource busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EEXIST		17	<span class="comment">/* File exists */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EXDEV		18	<span class="comment">/* Cross-device link */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENODEV		19	<span class="comment">/* No such device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOTDIR		20	<span class="comment">/* Not a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EISDIR		21	<span class="comment">/* Is a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EINVAL		22	<span class="comment">/* Invalid argument */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENFILE		23	<span class="comment">/* File table overflow */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EMFILE		24	<span class="comment">/* Too many open files */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOTTY		25	<span class="comment">/* Not a typewriter */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ETXTBSY		26	<span class="comment">/* Text file busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EFBIG		27	<span class="comment">/* File too large */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOSPC		28	<span class="comment">/* No space left on device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ESPIPE		29	<span class="comment">/* Illegal seek */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EROFS		30	<span class="comment">/* Read-only file system */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EMLINK		31	<span class="comment">/* Too many links */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EPIPE		32	<span class="comment">/* Broken pipe */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EDOM		33	<span class="comment">/* Math argument out of domain of func */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ERANGE		34	<span class="comment">/* Math result not representable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>那么如何判断函数返回的指针是有效地址还是错误码呢？对于IS_ERR()的使用，实例代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">myclass = class_create(THIS_MODULE, <span class="string">&quot;myclass&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(myclass)) &#123;</span><br><span class="line">　　ret = PTR_ERR(myclass);</span><br><span class="line">   <span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">mydevice = device_create(myclass, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;simple-device&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(mydevice)) &#123;</span><br><span class="line">　　class_destroy(myclass);</span><br><span class="line">　　ret = PTR_ERR(mydevice);</span><br><span class="line">　　<span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，调用了class_create()和device_create()函数，必须使用IS_ERR()函数判断返回的指针是否是有效的，如果是无效的，需要调用PTR_ERR()函数将无效指针转换为错误码，并进行错误码的返回。</p>
<h2 id="17-3-实验程序编写"><a href="#17-3-实验程序编写" class="headerlink" title="17.3 实验程序编写"></a>17.3 实验程序编写</h2><h3 id="17-3-1-驱动程序编写"><a href="#17-3-1-驱动程序编写" class="headerlink" title="17.3.1 驱动程序编写"></a>17.3.1 驱动程序编写</h3><p>本驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\12\module。</p>
<p>本实验在15章的驱动程序基础上进行编写，进行Linux错误处理实验。当创建设备号，初始化cdev，注册字符设备，创建类，创建设备的这些函数执行失败时，应该怎么处理呢，编写好的驱动程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];  <span class="comment">//定义缓存区kbuf</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>   <span class="comment">//定义一个device_test结构体变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">    file-&gt;private_data=&amp;dev1;  <span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_write\r\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;kbuf is %s\r\n&quot;</span>, test_dev-&gt;kbuf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;   </span><br><span class="line"><span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">       ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="17-3-2-编写测试-APP"><a href="#17-3-2-编写测试-APP" class="headerlink" title="17.3.2 编写测试 APP"></a>17.3.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\12\app。</p>
<p>编写应用程序app.c，完成的应用程序app.c代码如下所示，应用程序只是起简单的测试作用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> <span class="comment">//主函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>;  <span class="comment">//定义写入缓存区buf1</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR); <span class="comment">//打开/dev/test设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd,buf1,<span class="keyword">sizeof</span>(buf1)); <span class="comment">//向/dev/test设备写入数据</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="17-4-运行测试"><a href="#17-4-运行测试" class="headerlink" title="17.4 运行测试"></a>17.4 运行测试</h2><h3 id="17-4-1-编译驱动程序"><a href="#17-4-1-编译驱动程序" class="headerlink" title="17.4.1 编译驱动程序"></a>17.4.1 编译驱动程序</h3><p>在上一小节中的file.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图5-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += chrdev_fops.o                     <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel   <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules     <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放file.c和Makefile文件目录下，如下图（图17-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps134.jpg" alt="img"> </p>
<p>图 17-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图17-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps135.jpg" alt="img"> </p>
<p>图 17-3</p>
<p>编译完生成 file.ko目标文件，如下图（图17-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps136.jpg" alt="img"> </p>
<p>图 17-4</p>
<p>至此我们的驱动模块就编译成功了。</p>
<h3 id="17-4-2-编译应用程序"><a href="#17-4-2-编译应用程序" class="headerlink" title="17.4.2 编译应用程序"></a>17.4.2 编译应用程序</h3><p>下面进行应用程序编译，因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图17-5）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps137.jpg" alt="img"> </p>
<p>图 17-5</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="17-4-3运行测试"><a href="#17-4-3运行测试" class="headerlink" title="17.4.3运行测试"></a>17.4.3运行测试</h3><p>驱动模块file.ko和测试程序app都已经准备好了，接下来就是运行测试。</p>
<p>输入以下命令，加载驱动程序，如下图（图17-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps138.jpg" alt="img"> </p>
<p>图 17-6</p>
<p>运行应用程序如下（图17-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps139.jpg" alt="img"> </p>
<p>图 17-7</p>
<p>卸载驱动程序，如下图（图17-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps140.jpg" alt="img"> </p>
<p>图 17-8</p>
<h1 id="第18章-点亮LED灯实验"><a href="#第18章-点亮LED灯实验" class="headerlink" title="第18章 点亮LED灯实验"></a>第18章 点亮LED灯实验</h1><p>经过前面章节的学习，我们已经对字符设备相关的知识进行了学习和实验，但实际上并没有涉及到对硬件的操作，而在本小节中将通过字符设备驱动及相关的应用程序对LED灯进行控制，通过对硬件的实际操作，从而对之前学习到的知识进行整合与回顾。</p>
<h2 id="18-1-查看原理图"><a href="#18-1-查看原理图" class="headerlink" title="18.1 查看原理图"></a>18.1 查看原理图</h2><p>首先打开底板原理图，如下图（图18-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps141.jpg" alt="img"> </p>
<p>图 18-1</p>
<p>由上图可以看出，LED灯是由GPIO0_B7控制的。当GPIO0_B7为高电平时，三极管Q16导通，LED9点亮。当GPIO0_B7为低电平时，三极管Q16截止，LED9不亮。</p>
<h2 id="18-2-查询寄存器地址"><a href="#18-2-查询寄存器地址" class="headerlink" title="18.2 查询寄存器地址"></a>18.2 查询寄存器地址</h2><p>在上一小节，我们查询到了控制LED灯的GPIO为GPIO0_B7。在接下来的实验中需要对GPIO进行配置，一般情况下需要对GPIO的复用寄存器，方向寄存器，数据寄存器进行配置。接下来我们打开RK3568的参考手册part1查找这几个寄存器的地址。</p>
<p>查找复用寄存器</p>
<p>打开参考手册part1的第三章，GPIOB的复用寄存器的偏移地址如下（图18-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps142.jpg" alt="img"> </p>
<p>图 18-2</p>
<p>搜索gpio0b7，如下图（图 18-3）所示，gpio0b7_sel在PMU_GRF_GPIO0B_IOMUX_H上，所以偏移地址为0x000C。gpio0b7可以通过控制[14:12]位来选择复用为哪个功能，我们要控制led灯，所以功能要复用为gpio。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps143.jpg" alt="img"> </p>
<p>图 18-3</p>
<p>复用寄存器的基地址如下图(图 18-4)所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps144.jpg" alt="img"> </p>
<p>图 18-4</p>
<p>所以复用寄存器地址&#x3D;基地址+偏移地址&#x3D;0xFDC2000C 。使用io命令查看此寄存器的地址：</p>
<p>io -r -4 0xFDC2000C</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps145.jpg" alt="img"> </p>
<p>图 18-5</p>
<p>如上图(图 18-5)所示，寄存器值为00000001，[14:12]位为000，如下图（图 18-6）所示，所以默认设置的为gpio功能。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps146.jpg" alt="img"> </p>
<p>图 18-6</p>
<p>查找方向寄存器</p>
<p>打开参考手册part1的第16章节，数据寄存器的偏移地址如下图（图 18-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps147.jpg" alt="img"> </p>
<p>图 18-7</p>
<p>GPIO有四组GPIO，分别是GPIOA，GPIOB，GPIOC，GPIOD。每组又以 A0<del>A7, B0</del>B7, C0<del>C7, D0</del>D7 作为编号区分。GPIO0B7在GPIO_SWPORT_DDR_L上所以，方向寄存器的偏移地址为0x0008。接着查看GPIO_SWPORT_DDR_L寄存器的具体描述，如下图（图18-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps148.jpg" alt="img"> </p>
<p>图 18-8</p>
<p>如上图（图 18-8）所示，[31:16]位属性是WO，也就是只可写入。这[31:16]位是写标志位，是低16位的写使能。如果低16位中某一位要设置输入输入输出，则对应高位写标志也应该设置为1。 [15：0] 是数据方向控制寄存器低位，如果要设置某个GPIO为输出，则对应位置1，如果要设置某个GPIO为输入，则对应位置0。那么GPIO0 B7 ，我们要设置第15位为输入还是输出，那么对应的[31:16]位写使能也要置1。</p>
<p>打开参考手册part1的1.1小节Address Mapping。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps149.jpg" alt="img"> </p>
<p>图 18-9</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps150.jpg" alt="img"> </p>
<p>图 18-10</p>
<p>如上图（图18-10）所示，GPIO0的基地址为0xFDD60000。方向寄存器的地址&#x3D;基地址+偏移地址&#x3D;0xFDD60000+0x0008&#x3D;0xFDD60008</p>
<p>然后使用IO命令查看该寄存器的值，如下（图18-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps151.jpg" alt="img"> </p>
<p>图 18-11</p>
<p>如下图（图 18-11）所示，第15位默认为1，设置GPIO0_B7为输出。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps152.jpg" alt="img"> </p>
<p>查找数据寄存器</p>
<p>打开参考手册part1的1.1小节Address Mapping。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps153.jpg" alt="img"> </p>
<p>图 18-12</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps154.jpg" alt="img"> </p>
<p>图 18-13</p>
<p>如上图（图18-13）所示，GPIO0的基地址为0xFDD60000。</p>
<p>数据寄存器的偏移地址如下（图18-14）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps155.jpg" alt="img"> </p>
<p>图 18-14</p>
<p>所以数据寄存器的地址为基地址+偏移地址&#x3D;0xFDD60000。使用IO命令查看地址的值，如下（图18-15）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps156.jpg" alt="img"> </p>
<p>图 18-15</p>
<p>我们来看一下这个数据寄存器的描述，如下图（图18-16）所示，</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps157.jpg" alt="img"> </p>
<p>图18-16</p>
<p>分析上图的方法和在分析方向寄存器的方法同理，由上图可知，如果要控制第15位为高电平（置1），需要设置31位为1，那么点亮灯，需要向数据寄存器写入0x8000c040，如下图（图18-17）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps158.jpg" alt="img"> </p>
<p>图 18-17</p>
<p>如果要灭灯，需要设置第15位为0 ，第31位为1，那么向数据寄存器中写入0x80004040，如下图（图 18-18）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps159.jpg" alt="img"> </p>
<p>图 18-18</p>
<p>总结</p>
<p>l 复用关系寄存器的基地址为0xFDC20000 ，偏移地址为000C ，所以要操作的地址为基地址+偏移地址&#x3D;0xFDC2000C </p>
<p>l GPIO的基地址为0xFDD60000，偏移地址为0x0008，所以方向寄存器要操作的地址为基地址+偏移地址&#x3D;0xFDD60008</p>
<p>l GPIO的基地址为0xFDD60000，偏移地址为0x0000，所以数据寄存器要操作的地址为基地址+偏移地址&#x3D;0xFDD60000</p>
<p>l 默认的数据寄存器的值：0x8000c040亮灯，0x80004040灭灯</p>
<h2 id="18-3-实验程序编写"><a href="#18-3-实验程序编写" class="headerlink" title="18.3 实验程序编写"></a>18.3 实验程序编写</h2><h3 id="18-3-1-驱动程序编写"><a href="#18-3-1-驱动程序编写" class="headerlink" title="18.3.1 驱动程序编写"></a>18.3.1 驱动程序编写</h3><p>本驱动程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\13\module。</p>
<p>本次实验在15章的驱动程序基础上进行编写，通过在应用层传入0&#x2F;1数据到内核，如果传入数据是1，则设置GPIO的数据寄存器值为0x8000c040，如果应用层传入0，则设置GPIO的数据寄存器值为0x80004040，这样就可以达到控制led的效果， 编写好的驱动程序file.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_DR 0xFDD60000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *vir_gpio_dr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(test_dev-&gt;kbuf[<span class="number">0</span>]==<span class="number">1</span>)&#123;   <span class="comment">//如果应用层传入的数据是1，则打开灯</span></span><br><span class="line">            *(test_dev-&gt;vir_gpio_dr) = <span class="number">0x8000c040</span>;   <span class="comment">//设置数据寄存器的地址</span></span><br><span class="line">            printk(<span class="string">&quot;test_dev-&gt;kbuf [0]  is %d\n&quot;</span>,test_dev-&gt;kbuf[<span class="number">0</span>]);  <span class="comment">//打印传入的数据</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(test_dev-&gt;kbuf[<span class="number">0</span>]==<span class="number">0</span>)&#123;  <span class="comment">//如果应用层传入的数据是0，则关闭灯</span></span><br><span class="line">        *(test_dev-&gt;vir_gpio_dr) = <span class="number">0x80004040</span>; <span class="comment">//设置数据寄存器的地址</span></span><br><span class="line">        printk(<span class="string">&quot;test_dev-&gt;kbuf [0]  is %d\n&quot;</span>,test_dev-&gt;kbuf[<span class="number">0</span>]); <span class="comment">//打印传入的数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*本实验重点*****/</span></span><br><span class="line">    dev1.vir_gpio_dr=ioremap(GPIO_DR,<span class="number">4</span>);  <span class="comment">//将物理地址转化为虚拟地址</span></span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.vir_gpio_dr))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.vir_gpio_dr);  <span class="comment">//PTR_ERR()来返回错误代码</span></span><br><span class="line">        <span class="keyword">goto</span> err_ioremap;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_ioremap:</span><br><span class="line">        iounmap(dev1.vir_gpio_dr);</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);    <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="18-3-2-编写测试-APP"><a href="#18-3-2-编写测试-APP" class="headerlink" title="18.3.2 编写测试 APP"></a>18.3.2 编写测试 APP</h3><p>本应用程序对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\13\app。</p>
<p>编写测试app,led驱动加载成功之后会生成&#x2F;dev&#x2F;test节点，应用程序APP通过操作&#x2F;dev&#x2F;test文件来完成对LED设备的控制。向&#x2F;dev&#x2F;test文件写入0表示关闭LED灯，写入1表示打开LED灯。编写完成的应用程序app.c代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开led驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// atoi()将字符串转为整型，这里将第一个参数转化为整型后，存放在 buf[0]中</span></span><br><span class="line">buf[<span class="number">0</span>] =atoi(argv[<span class="number">1</span>]);  </span><br><span class="line">write(fd,buf,<span class="keyword">sizeof</span>(buf));  <span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-4-运行测试"><a href="#18-4-运行测试" class="headerlink" title="18.4 运行测试"></a>18.4 运行测试</h2><h3 id="18-4-1编译驱动程序"><a href="#18-4-1编译驱动程序" class="headerlink" title="18.4.1编译驱动程序"></a>18.4.1编译驱动程序</h3><p>在上一小节中的file.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下（图5-4）所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += file.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放file.c和Makefile文件目录下，如下图（图18-19）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps160.jpg" alt="img"> </p>
<p>图 18-19</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 18-20）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps161.jpg" alt="img"> </p>
<p>图 18-20</p>
<p>编译完生成 file.ko目标文件，如下图（图 18-21）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps162.jpg" alt="img"> </p>
<p>图 18-21</p>
<h3 id="18-4-2-编译应用程序"><a href="#18-4-2-编译应用程序" class="headerlink" title="18.4.2 编译应用程序"></a>18.4.2 编译应用程序</h3><p>至此我们的驱动模块就编译成功了，下面进行应用程序编译，因为测试APP是要在开发板上运行的，所以需要aarch64-linux-gnu-gcc来编译，输入以下命令，编译完成以后会生成一个app的可执行程序，如下图（图 18-21）所示：</p>
<p>aarch64-linux-gnu-gcc app.c -o app</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps163.jpg" alt="img"> </p>
<p>图 18-21</p>
<p>下面进行驱动程序的测试。</p>
<h3 id="18-4-3-运行测试"><a href="#18-4-3-运行测试" class="headerlink" title="18.4.3 运行测试"></a>18.4.3 运行测试</h3><p>驱动模块file.ko和测试程序app都已经准备好了，接下来就是运行测试。</p>
<p>输入以下命令加载驱动程序，如下（图 18-22）所示：</p>
<p>insmod file.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps164.jpg" alt="img"> </p>
<p>图 18-22</p>
<p>然后运行测试程序，输入“.&#x2F;app 1”，LED灯点亮，如下图（图 18-24）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps165.jpg" alt="img"> </p>
<p>图 18-23</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps166.jpg" alt="img"> </p>
<p>图 18-24</p>
<p>输入“.&#x2F;app 0”,LED灯熄灭，如下图（图 18-26）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps167.jpg" alt="img"> </p>
<p>图 18-25</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps168.jpg" alt="img"> </p>
<p>图 18-26</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%8C%E7%AF%87-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%9F%BA%E7%A1%80/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%9F%BA%E7%A1%80/" rel="tag">字符设备基础</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%89%E7%AF%87-%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            rk3568 驱动开发第三篇 并发与竞争
          
        </div>
      </a>
    
    
      <a href="/2023/09/04/2023-0904-%E8%AF%BB%E4%B9%A6/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">2023 0904 读书</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="热爱学习的未来酱"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>