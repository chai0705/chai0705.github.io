<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="永远年轻，永远热泪盈眶" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>rk3568 驱动开发第四篇 高级字符设备进阶 |  热爱学习的未来酱</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="热爱学习的未来酱" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-rk3568-驱动开发第四篇-高级字符设备进阶"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  rk3568 驱动开发第四篇 高级字符设备进阶
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E5%9B%9B%E7%AF%87-%E9%AB%98%E7%BA%A7%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E8%BF%9B%E9%98%B6/" class="article-date">
  <time datetime="2023-09-04T12:55:36.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">32.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">136 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第25章-IO模型引入实验"><a href="#第25章-IO模型引入实验" class="headerlink" title="第25章 IO模型引入实验"></a>第25章 IO模型引入实验</h1><p>我们经常提到 IO、NIO 这些名词。那么，到底什么是 IO 呢？什么又是 NIO 呢？另外，我们平时又会听到两组很相似的概念：阻塞&#x2F;非阻塞、同步&#x2F;异步。那么，阻塞和非阻塞有什么区别呢？同步和异步的差别又在哪里呢？</p>
<p>为了更好的理解IO模型，在本章节将对IO的概念、IO的执行过程及IO模型的分类进行详细分析，下面就让我们一起进入IO的世界吧！</p>
<h2 id="25-1-IO的概念"><a href="#25-1-IO的概念" class="headerlink" title="25.1 IO的概念"></a>25.1 IO的概念</h2><p>IO是英文Input和Output的首字母，代表了输入和输出，当然这样的描述有一点点抽象，更直观的意思是计算机的输入与输出。在冯.诺依曼结构中，将计算机分成了5个部分，分别是运算器，控制器，存储器，输入设备，输出设备。如下图（图 25-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps173.jpg" alt="img"> </p>
<p>图 25-1</p>
<p>上图中的输入设备指的是鼠标和键盘等向计算机输入数据和信息的设备，输出设备指的是电脑显示器等用于计算机信息输出的设备，下面对计算机输入输出过程进行实际举例，当敲击键盘（输入设备）任意按键后，按键的数据会传递给计算机，计算机CPU会对数据进行运算，运算完成之后会将数据输出到显示器（输出设备）上，整个过程如下图（图 25-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps174.jpg" alt="img"> </p>
<p>图 25-2</p>
<p>上述事例中，鼠标、显示器只是输入输出的直观表现形式，而在计算机架构层面上，IO是涉及计算机核心与其他设备间数据迁移的过程。以磁盘IO为例，内存读取磁盘数据和将内存数据写入磁盘，就是一对输入输出的过程。</p>
<p>至此，对于IO的概念就讲解完成了，在下一小节中将对IO执行过程进行分析。</p>
<h2 id="25-2-IO执行过程"><a href="#25-2-IO执行过程" class="headerlink" title="25.2 IO执行过程"></a>25.2 IO执行过程</h2><p>操作系统（Linux）负责对计算机的资源进行管理和对进程进行调度，应用程序运行在操作系统上，处于用户空间。应用程序不能直接对硬件进行操作，只能通过操作系统提供的API来操作硬件。需要将进程切换到内核空间，才能进行IO操作，并且应用程序不能直接操作内核空间的数据，需要把内核空间的数据拷贝到用户空间。</p>
<p>应用程序运行在用户空间，它不存在实质的IO过程，真正的IO是在操作系统执行的。那么应用程序操作IO就会有两个动作：IO调用和IO执行。IO调用是应用程序向操作系统内核发起调用，IO执行是操作系统内核完成的IO操作。</p>
<p>一个完整的IO过程需要包含以下三个步骤，如下图（图25-3）所示：</p>
<p>（1） 用户空间的应用程序向内核发起IO调用请求(系统调用)</p>
<p>（2） 内核操作系统准备数据，把IO设备的数据加载到内核缓冲区</p>
<p>（3） 操作系统拷贝数据，把内核缓冲区的数据拷贝到用户进程缓冲区</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps175.jpg" alt="img"> </p>
<p>图 25-2</p>
<h2 id="25-3-IO模型的分类"><a href="#25-3-IO模型的分类" class="headerlink" title="25.3 IO模型的分类"></a>25.3 IO模型的分类</h2><p>假设有这样一个场景，从磁盘中循环读取100M的数据并处理，磁盘读取100M需要花费20秒的时间，CPU同样也需要20秒的时间处理完这些数据。如果采用传统的模式编写代码：读数据-&gt;等待数据读取完毕-&gt;数据处理，可以发现，数据的读取花费了一半的时间，而这就导致该任务的效率极其低下，那么能不能在等待数据的同时对数据进行处理呢？当然可以！这时候就轮到IO编程模型来出场了。</p>
<p>IO模型根据实现的功能可以划分为为阻塞IO、非阻塞IO、信号驱动IO， IO多路复用和异步IO。根据等待IO的执行结果进行划分，前四个IO模型又被称为同步IO，如下图（图 25-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps176.jpg" alt="img"> </p>
<p>图 25-4</p>
<p>所谓同步，即发出一个功能调用后，只有得到结果该调用才会返回。异步的概念和同步相对。当一个异步过程调用发出后，调用者并不能立刻得到结果，实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>
<p>以现实生活去餐馆吃饭为例，根据菜单进行点餐之后，这时会存在两个选择，第一个选择是在餐馆等待饭菜制作完毕，这就是同步IO的具体表现。第二个选择是，离开餐馆去做其他的事情，工作人员会在饭菜制作完成之后提醒你回餐馆取餐，这就是异步IO的具体表现。</p>
<p>下面让我们来认识一下这五种IO模型。</p>
<p><em><strong>*1 阻塞IO*</strong></em></p>
<p>以****阻塞读****为例：进程进行IO操作时(如read操作)，首先会发起一个系统调用，从而转到内核空间进行处理，内核空间的数据没有准备就绪时，进程会被阻塞，不会继续向下执行，直到内核空间的数据准备完成后，数据才会从内核空间拷贝到用户空间，最后返回用户进程，由用户空间进行数据的处理，如下图（图 25-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps177.jpg" alt="img"> </p>
<p>图 25-6</p>
<p>以现实生活中的钓鱼为例，在做好相应准备抛下鱼钩之后，需要耐心等待鱼儿的上钩，等待的过程中必须聚精会神的关注鱼竿的状态，鱼儿上钩之后立刻扬竿，这就是阻塞IO在实际生活中的事例。</p>
<p>通过上述例子可以总结出阻塞IO的优势与不足，首先可以及时的获取结果，并立刻对获取到的结果进行处理，然而在获取结果之前，无法去处理其他任务，需要时刻对结果进行监听。</p>
<p>阻塞IO比较有代表性的是C语言中的scanf()函数。编写好的io.c文件，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>,i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，scanf函数用于从键盘上接收数据，如果键盘不进行数据的输入，该任务会持续阻塞，只有键盘输入数据之后，才会有相应的输入值打印到系统终端上。输入以下命令进行可执行文件的编译，如下（图 25-7）所示</p>
<p>gcc io.c -o io</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps178.jpg" alt="img"> </p>
<p>图 25-8</p>
<p>编译完成之后，输入“.&#x2F;io”运行可执行文件，如下所示，键盘没有输入数据时，该任务会持续阻塞，当在键盘上输入“123”之后，输入的值才会被打印出来，如下（图 25-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps179.jpg" alt="img"> </p>
<p>图 25-9</p>
<p><em><strong>*2 非阻塞IO*</strong></em></p>
<p>和阻塞IO模型不同，非阻塞IO进行IO操作时，如果内核数据没有准备好，内核会立即向进程返回err，不会进行阻塞；如果内核空间数据准备就绪，内核会立即把数据返回给用户空间的进程，如下图（图 25-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps180.jpg" alt="img"> </p>
<p>图 25-10</p>
<p>仍旧以现实生活中钓鱼为例，在做好相应准备抛下鱼钩之后，这次并没有持续不断的关注鱼竿的状态，而是去做其他的事情（不阻塞等待结果），每隔几分钟对鱼竿的状态进行检查，如果没有鱼儿上钩，就继续去做其他事情，如果上钩了就把鱼钓上来,这就是非阻塞IO在实际生活中的事例。</p>
<p>从上述案例中可以看出非阻塞IO的优点是效率高，同样的时间可以做更多的事。但是缺点也很明显，需要不断对结果进行轮询查看，从而导致结果获取不及时（结果可能在两次轮询之间就已经准备完毕，但是只能在发起轮询的时候才能知道），如果要增加非阻塞IO的实时性，就要加快轮询的频率，但这样无疑也会增加CPU的负担。</p>
<p><em><strong>*3 IO多路复用*</strong></em></p>
<p>通常情况下使用select()、poll()、epoll()函数实现IO多路复用。这里以select函数为例进行讲解，使用时可以对select传入多个描述符，并设置超时时间。当执行select的时候，系统会发起一个系统调用，内核会遍历检查传入的描述符是否有事件发生（如可读、可写事件）。如有，立即返回，否则进入睡眠状态，使进程进入阻塞状态，直到任何一个描述符事件产生后（或者等待超时）立刻返回。此时用户空间需要对全部描述符进行遍历，以确认具体是哪个发生了事件，这样就能使用一个进程对多个IO进行管理，如下图（图 25-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps181.jpg" alt="img"> </p>
<p>图 25-11</p>
<p>继续以现实生活中的钓鱼为例，和之前案例只有一个鱼竿不同，这次会在十个不同的地方做好相应准备抛下鱼钩，并把十个鱼竿连在了一个铃铛上，这样只要铃铛响了就表示有鱼上钩，只需挨个检查到底是哪个鱼竿有鱼上钩即可。</p>
<p>这样的优点是一个进程&#x2F;线程可以同时监听和处理多路IO，效率成倍提高。但是IO多路复用并不是能医治百病的良药，虽然IO多路复用可以监听多个IO，但是实际上对结果的处理也只能依次进行，比较适合IO密集但是每一路IO数据量不多且到达时间分散的场合（如网络聊天）。</p>
<p>另外select监听的描述符有上限（一般描述符最大不超过1024），而且需要遍历究竟是哪一个IO产生了数据。因此IO较多时，效率不高（这个问题被epoll解决，感兴趣的读者可以自行了解）。</p>
<p><em><strong>*4 信号驱动*</strong></em></p>
<p>信号驱动IO顾名思义与信号相关。系统在一些事件发生之后，会对进程发出特定的信号，而信号与处理函数相绑定，当信号产生时就会调用绑定的处理函数。例如在Linux系统任务执行的过程中可以按下ctrl+C来对任务进行终止，系统实际上是对该进程发送一个SIGINT信号，该信号的默认处理函数就是退出当前程序。</p>
<p>具体到IO模型上，可以对SIGIO信号注册相应的信号处理函数，并打开对应描述符的信号驱动。每当有IO数据产生时，系统就会发送一个SIGIO信号，进而调用相应的信号处理函数，从而在这个处理函数中对数据进行读取，如下图（图 25-12）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps182.jpg" alt="img"> </p>
<p>图 25-12</p>
<p>仍旧以现实生活中的钓鱼为例，在做好相应准备抛下鱼钩之后，这次同样没有持续不断的关注鱼竿的状态，而是去做其他的事情（不阻塞等待结果），与之前不同的是，在鱼竿处绑定了一个提醒铃铛，当鱼咬钩之后，铃铛就会响(有SIGIO信号)，进而得知到鱼儿上钩的消息之，这样就可以及时把鱼钓上来了(调用处理函数)。</p>
<p><em><strong>*5 异步IO*</strong></em></p>
<p>aio_read函数常常用于异步IO，当进程使用aio_read读取数据时，如果数据尚未准备就绪就立即返回，不会阻塞。若数据准备就绪就会把数据从内核空间拷贝到用户空间的缓冲区中，然后执行定义好的回调函数对接收到的数据进行处理。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps183.jpg" alt="img"> </p>
<p>图 25-13</p>
<p>最后，还是以钓鱼为例。小马同学喜欢吃新鲜的鱼，但是不想自己钓，所以他请了一个助手来帮他钓鱼，他自己去忙其他的事情（进程不阻塞，立即返回）。如果有鱼上钩助手会帮忙钓上来（将数据拷贝到指定的缓冲区），并立即通知小马同学回来把鱼取走（处理数据）。</p>
<h1 id="第26章-阻塞IO实验"><a href="#第26章-阻塞IO实验" class="headerlink" title="第26章  阻塞IO实验"></a>第26章  阻塞IO实验</h1><p>在上一章节，对IO的相关概念和五种IO模型分类进行了学习，在接下来的章节中将分别对四种同步IO进行详细的讲解和实验，本章节要讲解的IO模型是阻塞IO，阻塞IO在Linux内核中是非常常用的IO模型，所依赖的机制是等待队列。下面让我们来开始阻塞IO的学习吧。</p>
<h2 id="26-1-什么是等待队列"><a href="#26-1-什么是等待队列" class="headerlink" title="26.1 什么是等待队列"></a>26.1 什么是等待队列</h2><p>在Linux驱动程序中，阻塞进程可以使用等待队列来实现。等待队列是内核实现阻塞和唤醒的内核机制，以双循环链表为基础结构，由链表头和链表项两部分组成，分别表示等待队列头和等待队列元素，如下图（图26-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps184.jpg" alt="img"> </p>
<p>图26-1</p>
<p>等待队列头使用结构体wait_queue_head_t 来表示，等待队列头是一个等待队列的头部，这个结构体定义在文件include&#x2F;linux&#x2F;wait.h里面，结构体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">wait_queue_head</span>&#123;</span></span><br><span class="line"><span class="type">spinlock_t</span> lock;    <span class="comment">//自旋锁</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span> //链表头</span></span><br><span class="line"><span class="class">&#125;；</span></span><br><span class="line"><span class="class"><span class="title">typefef</span> <span class="keyword">struct</span> _<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br></pre></td></tr></table></figure>

<p>等待队列项使用结构体wait_queue_t来表示，等待队列项是等待队列元素，该结构体同样定义在文件include&#x2F;linux&#x2F;wait.h里面，结构体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">wait_queue</span>&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">void</span> *private;</span><br><span class="line"><span class="type">wait_queue_func_t</span> func;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">wait_queue</span> <span class="title">wait_queue_t</span>;</span></span><br></pre></td></tr></table></figure>

<h2 id="26-2-等待队列API函数"><a href="#26-2-等待队列API函数" class="headerlink" title="26.2 等待队列API函数"></a>26.2 等待队列API函数</h2><p><em><strong>*1 定义并初始化等待队列头*</strong></em></p>
<p>等待队列要想被使用，第一步就是对等待队列头进行初始化，有俩种办法如下所示：</p>
<p>方法一：使用 DECLARE_WAIT_QUEUE_HEAD宏静态创建等待队列头，宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WAIT_QUEUE_HEAD(name) \</span></span><br><span class="line"><span class="meta">wait_queue_head_t name = __WAIT_QUEUE_HEAD_INITIALIZER(name)</span></span><br></pre></td></tr></table></figure>

<p>参数name表示要定义的队列头名字。通常以全局变量的方式定义,如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_WAIT_QUEUE_HEAD(head);</span><br></pre></td></tr></table></figure>

<p>方法二：使用init_waitqueue_head宏动态初始化等待队列头，宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> init_waitqueue_head(q)				\</span></span><br><span class="line"><span class="meta">	do &#123;						\</span></span><br><span class="line"><span class="meta">		static struct lock_class_key __key;	\</span></span><br><span class="line"><span class="meta">							\</span></span><br><span class="line"><span class="meta">		__init_waitqueue_head((q), #q, &amp;__key);	\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>参数q表示需要初始化的队列头指针。使用宏定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wait_queue_head_t</span> head;       <span class="comment">//等待队列头</span></span><br><span class="line">init_waitqueue_head(&amp;head);    <span class="comment">//初始化等待队列头指针</span></span><br></pre></td></tr></table></figure>



<p>然后再来学习如何创建等待队列元素，也就是等待队列项。</p>
<p><em><strong>*2 创建等待队列项*</strong></em></p>
<p>一般使用宏 DECLARE_WAITQUEUE(name,tsk)给当前正在运行的进程创建并初始化一个等待队列项，宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WAITQUEUE(name, tsk)						\</span></span><br><span class="line"><span class="meta">struct wait_queue_entry name = __WAITQUEUE_INITIALIZER(name, tsk)</span></span><br></pre></td></tr></table></figure>

<p>第一个参数name是等待队列项的名字，第二个参数tsk表示此等待队列项属于哪个任务（进程），一般设置为current。在Linux内核中current相当于一个全局变量，表示当前进程。创建等待队列项如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_WAITQUEUE(wait,current);  <span class="comment">//给当前正在运行的进程创建一个名为wait的等待队列项。</span></span><br><span class="line">add_wait_queue(wq,&amp;wait); <span class="comment">//将wait这个等待队列项加到wq这个等待队列当中</span></span><br></pre></td></tr></table></figure>

<p><em><strong>*3添加&#x2F;删除队列*</strong></em></p>
<p>当设备没有准备就绪（如没有可读数据）而需要进程阻塞的时候，就需要将进程对应的等待队列项添加到前面创建的等待队列中，只有添加到等待队列中以后进程才能进入休眠态。当设备可以访问时（如有可读数据），再将进程对应的****等待队列项****从等待队列中移除即可。</p>
<p>等待队列项添加队列函数如下所示：</p>
<p><em><strong>*函数原型:*</strong></em></p>
<p>  void add_wait_queue(wait_queue_head_t *q,wait_queue_t *wait)</p>
<p><em><strong>*函数功能:*</strong></em></p>
<p> (通过等待队列头)向等待队列中添加队列项</p>
<p><em><strong>*参数含义:*</strong></em></p>
<p> wq_head表示等待队列项要加入等待队列的等待队列头</p>
<p>wq_entry表示要加入的等待队列项</p>
<p><em><strong>*函数返回值*</strong></em>  </p>
<p>无</p>
<p>等待队列项移除队列函数如下所示：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>void remove_wait_queue(wait_queue_head_t *q,wait_queue_t *wait)</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>要删除的等待队列项所处的等待队列头</p>
<p><em><strong>*函数含义：*</strong></em></p>
<p>第一个参数q表示等待队列项要加入等待队列的等待队列头</p>
<p>第二个参数wait表示要加入的等待队列项</p>
<p><em><strong>*函数返回值：*</strong></em></p>
<p>无</p>
<p><em><strong>*4等待事件*</strong></em></p>
<p>除了主动唤醒以外，也可以设置等待队列等待某个事件，当这个事件满足以后就自动唤醒等待队列中的进程，使用如下所示的宏，是不可中断的阻塞等待。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __wait_event(wq_head, condition)					\</span></span><br><span class="line"><span class="meta">(void)___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 0, 0,	\</span></span><br><span class="line"><span class="meta">schedule())</span></span><br></pre></td></tr></table></figure>

<p><em><strong>*宏定义功能：*</strong></em></p>
<p>不可中断的阻塞等待，让调用进程进入不可中断的睡眠状态，在等待队列里面睡眠直到condition变成真，被内核唤醒。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>第一个参数wq: wait_queue_head_t 类型变量</p>
<p>第二个参数condition : 等待条件，为假时才可以进入休眠。如果condition为真，则不会休眠</p>
<p>除此之外，wait_event_interruptible的宏是可中断的阻塞等待。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __wait_event_interruptible(wq_head, condition)				\</span></span><br><span class="line"><span class="meta">___wait_event(wq_head, condition, TASK_INTERRUPTIBLE, 0, 0,		\</span></span><br><span class="line"><span class="meta">schedule())</span></span><br></pre></td></tr></table></figure>



<p><em><strong>*宏含义功能：*</strong></em></p>
<p>可中断的阻塞等待，让调用进程进入可中断的睡眠状态，直到condition变成真被内核唤醒或信号打断唤醒。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>第一个参数wq :wait_queue_head_t 类型变量</p>
<p>第二个参数condition :等待条件。为假时才可以进入休眠。如果condition为真，则不会休眠。</p>
<p>wait_event_timeout() 宏也与 wait_event()类似.不过如果所给的睡眠时间为负数则立即返回.如果在睡眠期间被唤醒,且condition 为真则返回剩余的睡眠时间,否则继续睡眠直到到达或超过给定的睡眠时间,然后返回 0。</p>
<p>wait_event_interruptible_timeout() 宏与 wait_event_timeout()类似,不过如果在睡眠期间被信号打断则返回 ERESTARTSYS 错误码。</p>
<p>wait_event_interruptible_exclusive() 宏同样和 wait_event_interruptible()一样,不过该睡眠的进程是一个互斥进程</p>
<p>注意：调用的时要确认 condition 值是真还是假，如果调用 condition 为真，则不会休眠。</p>
<p><em><strong>*5等待队列唤醒*</strong></em></p>
<p>当设备可以使用的时候就要唤醒进入休眠态的进程，唤醒可以使用如下俩个函数</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>wake_up(wait_queue_head_t *q)</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>唤醒所有休眠进程</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>q表示要唤醒的等待队列的等待队列头</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>wake_up_interruptible(wait_queue_head_t *q)</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>唤醒可中断的休眠进程</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>q表示要唤醒的等待队列的等待队列头</p>
<h2 id="26-3-等待队列使用方法"><a href="#26-3-等待队列使用方法" class="headerlink" title="26.3 等待队列使用方法"></a>26.3 等待队列使用方法</h2><p>步骤一：初始化等待队列头，并将条件置成假(condition&#x3D;0)。</p>
<p>步骤二：在需要阻塞的地方调用wait_event()，使进程进入休眠状态。</p>
<p>步骤三：当条件满足时，需要解除休眠，先将条件(condition&#x3D;1),然后调用wake_up函数唤醒等待队列中的休眠进程。</p>
<h2 id="26-4-实验程序编写"><a href="#26-4-实验程序编写" class="headerlink" title="26.4 实验程序编写"></a>26.4 实验程序编写</h2><h3 id="26-4-1-驱动程序编写"><a href="#26-4-1-驱动程序编写" class="headerlink" title="26.4.1 驱动程序编写"></a>26.4.1 驱动程序编写</h3><p>本实验对应的驱动网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\20\module。</p>
<p>接着编写等待队列的实验代码，在此代码中，按照上一小节等待队列使用方法的三个步骤进行编写，在read函数中调用wait_event_interruptible函数阻塞，使进程进入休眠状态。在write函数中唤醒等待队列中的休眠进程。编写好的驱动程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span>  flag;  <span class="comment">//标志位</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  </span><br><span class="line"></span><br><span class="line">DECLARE_WAIT_QUEUE_HEAD(read_wq); <span class="comment">//定义并初始化等待队列头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test_dev-&gt;flag=<span class="number">1</span>;<span class="comment">//将条件置1</span></span><br><span class="line">    wake_up_interruptible(&amp;read_wq); <span class="comment">//并使用wake_up_interruptible唤醒等待队列中的休眠进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    wait_event_interruptible(read_wq,test_dev-&gt;flag); <span class="comment">//可中断的阻塞等待，使进程进入休眠态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="26-4-2-编写测试-APP"><a href="#26-4-2-编写测试-APP" class="headerlink" title="26.4.2 编写测试 APP"></a>26.4.2 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\20\app。</p>
<p>接下来编写应用程序read.c，此程序实现了从设备读取数据的功能。编写好的应用程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开led驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read before \n&quot;</span>);</span><br><span class="line">    read(fd,buf1,<span class="keyword">sizeof</span>(buf1));  <span class="comment">//从/dev/test文件读取数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf is %s  \n&quot;</span>,buf1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read after \n&quot;</span>);</span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理 ，编写应用程序write.c，实现向设备写入数据的功能，编写好的应用程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开led驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write before \n&quot;</span>);</span><br><span class="line">    write(fd,buf2,<span class="keyword">sizeof</span>(buf2));  <span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;write after\n&quot;</span>);</span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-5运行测试"><a href="#26-5运行测试" class="headerlink" title="26.5运行测试"></a>26.5运行测试</h2><h3 id="26-5-1编译驱动程序"><a href="#26-5-1编译驱动程序" class="headerlink" title="26.5.1编译驱动程序"></a>26.5.1编译驱动程序</h3><p>在上一小节中的wq.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += wq.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放wq.c和Makefile文件目录下，如下图（图 26-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps185.jpg" alt="img"> </p>
<p>图 26-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 26-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps186.jpg" alt="img"> </p>
<p>图 26-3</p>
<p>编译完生成 wq.ko目标文件，如下图（图 26-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps187.jpg" alt="img"> </p>
<p>图 26-4</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="26-5-2-编译应用程序"><a href="#26-5-2-编译应用程序" class="headerlink" title="26.5.2 编译应用程序"></a>26.5.2 编译应用程序</h3><p>来到存放应用程序read.c和write.c的文件夹下，使用以下命令对read.c和write.c进行交叉编译，编译完成如下图（图 26-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o read read.c -static</p>
<p>aarch64-linux-gnu-gcc -o write write.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps188.jpg" alt="img"> </p>
<p>图 26-4</p>
<p>生成的read write文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="26-5-3-运行测试"><a href="#26-5-3-运行测试" class="headerlink" title="26.5.3 运行测试"></a>26.5.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 26-5）所示：</p>
<p>insmod wq.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps189.jpg" alt="img"></p>
<p>图 26-5</p>
<p>输入以下命令运行read可执行文件，如下图（图 26-6）所示，read应用程序进程阻塞</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps190.jpg" alt="img"></p>
<p>图 26-6</p>
<p>然后输入以下命令运行write可执行文件，如下图（图 26-7）所示，使用write函数向设备写入数据，唤醒等待队列中的休眠进程。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps191.jpg" alt="img"></p>
<p>图 26-7</p>
<p>在使用可执行程序write向缓冲区写入数据时，read可执行程序读取到了缓冲区的数据并打印。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps192.jpg" alt="img"></p>
<p>图 26-8</p>
<h1 id="第27章-非阻塞IO实验"><a href="#第27章-非阻塞IO实验" class="headerlink" title="第27章 非阻塞IO实验"></a>第27章 非阻塞IO实验</h1><p>上个章节中我们学习了阻塞IO，阻塞IO是通过等待队列来实现的，那么如何让驱动实现非阻塞呢？带着疑问，让我们开始本章节非阻塞IO的学习吧！</p>
<h2 id="27-1-非阻塞IO简介"><a href="#27-1-非阻塞IO简介" class="headerlink" title="27.1 非阻塞IO简介"></a>27.1 非阻塞IO简介</h2><p>应用程序可以使用如下所示示例代码来实现阻塞访问：</p>
<p>int fd;</p>
<p>int data &#x3D; 0;</p>
<p>fd &#x3D; open(“&#x2F;dev&#x2F;xxx_dev”, <em><strong>*O_RDWR*</strong></em>);  &#x2F;* 阻塞方式打开 *&#x2F;</p>
<p>ret &#x3D; read(fd, &amp;data, sizeof(data));   &#x2F;* 读取数据 *&#x2F;</p>
<p>可以看出对于设备驱动文件的默认读取方式就是阻塞式的，所以之前实验例程测试 APP 都是采用阻塞 IO。</p>
<p>如果应用程序要采用非阻塞的方式来访问驱动设备文件，可以使用如下所示代码：</p>
<p>int fd;</p>
<p>int data &#x3D; 0;</p>
<p>fd &#x3D; open(“&#x2F;dev&#x2F;xxx_dev”, <em><strong>*O_RDWR | O_NONBLOCK*</strong></em>); &#x2F;* 非阻塞方式打开 *&#x2F;</p>
<p>ret &#x3D; read(fd, &amp;data, sizeof(data)); &#x2F;* 读取数据 *&#x2F;</p>
<p>使用 open 函数打开“&#x2F;dev&#x2F;xxx_dev”设备文件的时候添加了参数“O_NONBLOCK”，表示以非阻塞方式打开设备，这样从设备中读取数据的时候是非阻塞方式了。</p>
<h2 id="27-2-实验程序编写"><a href="#27-2-实验程序编写" class="headerlink" title="27.2 实验程序编写"></a>27.2 实验程序编写</h2><h3 id="27-2-1-编写测试-APP"><a href="#27-2-1-编写测试-APP" class="headerlink" title="27.2.1 编写测试 APP"></a>27.2.1 编写测试 APP</h3><p>非阻塞IO实验需要应用程序和驱动配合，所以需要编写驱动代码和应用测试代码。</p>
<p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\21\app。</p>
<p>首先来编写应用测试代码read.c，在此代码中使用非阻塞的方式打开设备，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;  <span class="comment">//定义int类型的文件描述符</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//定义读取缓冲区buf</span></span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//定义读取缓冲区buf</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR| O_NONBLOCK);  <span class="comment">//打开/dev/test设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read before \n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         read(fd,buf1,<span class="keyword">sizeof</span>(buf1));  <span class="comment">//从/dev/test文件读取数据</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;buf is %s \n&quot;</span>,buf1);  <span class="comment">//打印读取的数据</span></span><br><span class="line">         sleep(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read after\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着编写应用程序write.c，用来向设备文件写入数据，编写好的应用程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR|O_NONBLOCK);  <span class="comment">//打开/dev/test设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write before \n&quot;</span>);</span><br><span class="line">    write(fd,buf2,<span class="keyword">sizeof</span>(buf2));  <span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;write after\n&quot;</span>);</span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="27-2-1-驱动程序编写"><a href="#27-2-1-驱动程序编写" class="headerlink" title="27.2.1 驱动程序编写"></a>27.2.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\21\module。</p>
<p> 编写好的驱动程序wq.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span>  flag;  <span class="comment">//标志位</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  </span><br><span class="line"></span><br><span class="line">DECLARE_WAIT_QUEUE_HEAD(read_wq); <span class="comment">//定义并初始化等待队列头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test_dev-&gt;flag=<span class="number">1</span>;    <span class="comment">//将条件置1，并使用wake_up_interruptible唤醒等待队列中的休眠进程</span></span><br><span class="line">    wake_up_interruptible(&amp;read_wq); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span>(file-&gt;f_flags &amp; O_NONBLOCK )&#123;</span><br><span class="line">        <span class="keyword">if</span> (test_dev-&gt;flag !=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    &#125;</span><br><span class="line">    wait_event_interruptible(read_wq,test_dev-&gt;flag); <span class="comment">//可中断的阻塞等待，使进程进入休眠态</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="27-3-运行测试"><a href="#27-3-运行测试" class="headerlink" title="27.3 运行测试"></a>27.3 运行测试</h2><h3 id="27-3-1-编译驱动程序"><a href="#27-3-1-编译驱动程序" class="headerlink" title="27.3.1 编译驱动程序"></a>27.3.1 编译驱动程序</h3><p>在上一小节中的wq.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += wq.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放wq.c和Makefile文件目录下，如下图（图 27-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps193.jpg" alt="img"> </p>
<p>图 27-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图27-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps194.jpg" alt="img"> </p>
<p>图 27-2</p>
<p>编译完生成 wq.ko目标文件，如下图（图 27-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps195.jpg" alt="img"> </p>
<p>图 27-3</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="27-3-2-编译应用程序"><a href="#27-3-2-编译应用程序" class="headerlink" title="27.3.2 编译应用程序"></a>27.3.2 编译应用程序</h3><p>来到存放应用程序read.c和write.c的文件夹下，使用以下命令对read.c和write.c进行交叉编译，编译完成如下图（图 27-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o read read.c -static</p>
<p>aarch64-linux-gnu-gcc -o write write.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps196.jpg" alt="img"> </p>
<p>图 27-4</p>
<p>生成的read write文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="27-3-3-测试"><a href="#27-3-3-测试" class="headerlink" title="27.3.3 测试"></a>27.3.3 测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 27-5）所示：</p>
<p>insmod wq.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps197.jpg" alt="img"></p>
<p>图 27-5</p>
<p>输入以下命令运行read可执行文件，如下图（图 27-6）所示，应用程序进程非阻塞，读取不到数据便返回，然后一直轮询查看是否有数据。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps198.jpg" alt="img"></p>
<p>图 27-6</p>
<p>然后输入以下命令运行write可执行文件向设备文件写入数据，如下图（图 27-7）所示:</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps199.jpg" alt="img"></p>
<p>图 27-7</p>
<p>在使用可执行程序write向缓冲区写入数据时，read可执行程序读取到了缓冲区的数据并打印。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps200.jpg" alt="img"></p>
<p>图 27-8</p>
<h1 id="第28章-IO多路复用实验"><a href="#第28章-IO多路复用实验" class="headerlink" title="第28章 IO多路复用实验"></a>第28章 IO多路复用实验</h1><p>在上俩个章节中，我们对阻塞IO和非阻塞IO进行了学习，本章节将学习第三种IO模型-多路复用IO。</p>
<h2 id="28-1-IO多路复用简介"><a href="#28-1-IO多路复用简介" class="headerlink" title="28.1 IO多路复用简介"></a>28.1 IO多路复用简介</h2><p>IO多路复用是一种同步的IO模型。IO多路复用可以实现一个进程监视多个文件描述符。一旦某个文件描述符准备就绪，就通知应用程序进行相应的读写操作。没有文件描述符就绪时就会阻塞应用程序，从而释放出CPU资源。</p>
<p>在第25章中，我们以钓鱼为例，对IO多路复用有了一个简单的认识。下面对钓鱼例子进行回顾：小李同时放置了十个鱼竿，并把十个鱼竿连在了一个铃铛上。这样小李就不必在岸边等待。当铃铛响了就表示有鱼上钩，再回来挨个检查到底是哪个鱼竿有鱼上钩即可。接着进一步体会IO多路复用。</p>
<p>在应用层Linux提供了三种实现IO多路复用的模型，分别是select、poll 和 epoll。在本驱动手册中主要偏重于对驱动的讲解，所以应用层中select、poll 和 epoll函数的使用在这里不做重点讲解。</p>
<p>首先来学习下select、poll 和 epoll函数有什么区别呢？poll函数和seslect函数都可以监听多个文件描述符，通过轮询来获取已经准备好的文件描述符。但是epoll函数将主动轮询变成了被动通知，当事件发生时被动接收通知。为了方便理解，举个形象的例子。假如poll和select是公司的前台，某天一位客户来公司找硬件工程师-小李，请求前台帮忙找人。于是poll和select前台带着这位客户挨个屋子寻找小李，直到找到小李为止。假如epoll是公司的前台，他提前统计了公司每个员工的工位。当客户来找小李的时候，不必像poll select一样，可以直接带着客户到硬件部门去找小李。从上面的俩个例子，明显对比epoll的效率更高。假如公司园区很大，那么poll select需要花费很长时间寻找小李，而epoll已经提前知道小李坐在哪个工位了，直接带客户去找小李即可。</p>
<p>select,poll,epoll有什么区别呢？在单个线程中，select函数最大可以监视1024个文件描述符，而poll函数和select函数并没有什么区别，只是poll函数没有最大文件描述符的限制。在本章节的实验中，以poll为例进行实验。在Linux应用程序中poll函数如下所示：</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>int poll(struct pollfd *fds,</p>
<p>nfds_t nfds,</p>
<p>int timeout);</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>监视并等待多个文件描述符的属性变化</p>
<p><em><strong>*函数参数：*</strong></em></p>
<p><em><strong>*第一个参数fds*</strong></em>: 要监视的文件描述符集合以及要监视的事件，为一个数组，数组元素都是结构体pollfd类型，pollfd结构体如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"><span class="type">int</span> fd;       <span class="comment">//被监视的文件描述符</span></span><br><span class="line"><span class="type">short</span> events;  <span class="comment">//等待的事件</span></span><br><span class="line"><span class="type">short</span> revents;  <span class="comment">//实际发生的事件</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>在pollfd结构体中，第一个成员fd是被监视的文件描述符。第二个成员events是要监视的事件，可监视的事件类型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POLLIN   有数据可以读取</span><br><span class="line">POLLPRI  有紧急的数据需要读取</span><br><span class="line">POLLOUT  可以写数据</span><br><span class="line">POLLERR   指定的文件描述符发生错误</span><br><span class="line">POLLHUP   指定的文件描述符挂起</span><br><span class="line">POLLNVAL  无效的请求</span><br><span class="line">POLLRDNORM  等同于POLLIN</span><br></pre></td></tr></table></figure>

<p>第三个成员是返回事件，由Linux内核设置具体的返回事件。</p>
<p><em><strong>*第二个参数nfds*</strong></em>: poll函数要监视的文件描述符数量</p>
<p><em><strong>*第三个参数timeout*</strong></em>:指定等待的时间，单位是ms。无论I&#x2F;O是否准备好，时间到POLL就会返回。如果timepoll大于0 等待指定的时间，如果timeout等于0，立即返回。如果timeout等于-1，事件发生以后才返回。</p>
<p><em><strong>*函数返回值：*</strong></em></p>
<p>失败返回-1，成功返回revents不为0的文件描述符个数。</p>
<p>当应用程序使用select或者poll函数对驱动程序进行非阻塞访问时，驱动程序中file_operations操作集的poll函数会执行。所以需要完善驱动中的poll函数。驱动中的poll函数原型如下所示：</p>
<p>unsigned int (*poll)(struct file *filp,struct poll_table_struct *wait);</p>
<p><em><strong>*函数参数：*</strong></em></p>
<p>filp:要打开的文件描述符</p>
<p>wait: 结构体poll_table_struct类型指针，此参数是由应用程序中传递的。一般此参数要传递给poll_wait函数。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>向应用程序返回资源状态，可以返回的资源状态如下：</p>
<p>POLLIN  有数据可以读取</p>
<p>POLLPRI  有紧急的数据需要读取</p>
<p>POLLOUT  可以写数据</p>
<p>POLLERR  指定的文件描述符发生错误</p>
<p>POLLHUP  指定的文件描述符挂起</p>
<p>POLLNVAL  无效的请求</p>
<p>POLLRDNORM 等同于POLLIN，普通数据可读。</p>
<p><em><strong>*函数功能：*</strong></em></p>
<p>这个函数要进行下面两项工作。首先，对可能引起设备文件状态变化的等待队列调用poll_wait(),将对应的等待队列头添加到poll_table.然后返回表示是否能对设备进行无阻塞读写访问的掩码。</p>
<p>驱动程序的poll函数中调用poll_wait函数，注意！poll_wait函数是不会引起阻塞的。poll_wait函数原型如下所示：</p>
<p>void poll_wait(struct file *filp,wait_queue_head_t *queue,poll_table *wait);</p>
<p>参数queue是要添加到poll_table中的等待队列头，参数wait是poll_table，也就是file_operations中poll函数的wait参数。</p>
<h2 id="28-2-实验程序编写"><a href="#28-2-实验程序编写" class="headerlink" title="28.2 实验程序编写"></a>28.2 实验程序编写</h2><h3 id="28-2-1-编写测试-APP"><a href="#28-2-1-编写测试-APP" class="headerlink" title="28.2.1 编写测试 APP"></a>28.2.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\22\app。</p>
<p>在应用层Linux提供了三种API函数，分别是select poll和epoll。本次实验使用poll函数进行实验，如果对select 和epoll函数感兴趣，可以查找一些系统编程课程学习。</p>
<p>编写好的应用程序read.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;  <span class="comment">//要监视的文件描述符</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>  <span class="title">fds</span>[1];</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开/dev/test设备，阻塞式访问</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//构造结构体</span></span><br><span class="line">    fds[<span class="number">0</span>] .fd =fd;</span><br><span class="line">    fds[<span class="number">0</span>].events = POLLIN; <span class="comment">//监视数据是否可以读取</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read before \n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = poll(fds,<span class="number">1</span>,<span class="number">3000</span>);  <span class="comment">//轮询文件是否可操作，超时3000ms</span></span><br><span class="line">    <span class="keyword">if</span>(!ret)&#123;  <span class="comment">//超时</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;time out !!\n,&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(fds[<span class="number">0</span>].revents == POLLIN) <span class="comment">//如果返回事件是有数据可读取</span></span><br><span class="line">    &#123;</span><br><span class="line">        read(fd,buf1,<span class="keyword">sizeof</span>(buf1));  <span class="comment">//从/dev/test文件读取数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf is %s \n,&quot;</span>,buf1); <span class="comment">//打印读取的数据</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read after\n&quot;</span>);</span><br><span class="line">close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码第16行，在打开设备节点时不使用非阻塞方式，要使用阻塞方式，所以改为O_RDWR。</p>
<p>在上述代码的第28行，使用poll函数监视并等待多个文件描述符的属性变化。poll函数第一个参数是被监视的文件描述符，是pollfd结构体类型的数组，所以在14行定义了pollfd结构体类型的数组fds。poll函数第2个参数是要监视的文件描述符数量，这里监视的文件描述符为1个。poll函数第3个参数是指定等待的时间 3000ms。</p>
<p>然后编写应用程序write.c，实现向设备文件写入数据的功能，编写好的write.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">32</span>] = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR);  <span class="comment">//打开/dev/test设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write before \n&quot;</span>);</span><br><span class="line">    write(fd,buf2,<span class="keyword">sizeof</span>(buf2));  <span class="comment">//向/dev/test文件写入数据</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;write after\n&quot;</span>);</span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="28-2-2-驱动程序编写"><a href="#28-2-2-驱动程序编写" class="headerlink" title="28.2.2 驱动程序编写"></a>28.2.2 驱动程序编写</h3><p>本实验对应的驱动程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\22\module。</p>
<p>IO多路复用实验需要应用程序和驱动程序进行配合，接下来编写驱动程序。编写好的驱动程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span>  flag;  <span class="comment">//标志位</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  </span><br><span class="line">DECLARE_WAIT_QUEUE_HEAD(read_wq); <span class="comment">//定义并初始化等待队列头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test_dev-&gt;flag=<span class="number">1</span>;</span><br><span class="line">    wake_up_interruptible(&amp;read_wq);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span>(file-&gt;f_flags &amp; O_NONBLOCK )&#123;</span><br><span class="line">        <span class="keyword">if</span> (test_dev-&gt;flag !=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    &#125;</span><br><span class="line">    wait_event_interruptible(read_wq,test_dev-&gt;flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span>  <span class="type">__poll_t</span>  <span class="title function_">cdev_test_poll</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> poll_table_struct *p)</span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;  <span class="comment">//设置私有数据</span></span><br><span class="line">     <span class="type">__poll_t</span> mask=<span class="number">0</span>;    </span><br><span class="line">     poll_wait(file,&amp;read_wq,p);     <span class="comment">//应用阻塞</span></span><br><span class="line">     <span class="keyword">if</span> (test_dev-&gt;flag == <span class="number">1</span>)    </span><br><span class="line">     &#123;</span><br><span class="line">         mask |= POLLIN; </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> mask; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">    .poll = cdev_test_poll,  <span class="comment">//将poll字段指向chrdev_poll(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>首先在第9行代码添加&lt;linux&#x2F;poll.h&gt;头文件。然后在第94行将poll字段指向chrdev_poll(…)函数，最后在73行到84行编写这个函数。</p>
<h2 id="28-3-运行测试"><a href="#28-3-运行测试" class="headerlink" title="28.3 运行测试"></a>28.3 运行测试</h2><h3 id="28-3-1-编译驱动程序"><a href="#28-3-1-编译驱动程序" class="headerlink" title="28.3.1 编译驱动程序"></a>28.3.1 编译驱动程序</h3><p>在上一小节中的poll.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += poll.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放poll.c和Makefile文件目录下，如下图（图 28-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps201.jpg" alt="img"> </p>
<p>图 28-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 28-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps202.jpg" alt="img"> </p>
<p>图 28-2</p>
<p>编译完生成poll.ko目标文件，如下图（图 28-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps203.jpg" alt="img"></p>
<p>图 28-3</p>
<p>至此驱动模块就编译成功了，下面进行应用程序read.c和write.c的编译。</p>
<h3 id="28-3-2-编译应用程序"><a href="#28-3-2-编译应用程序" class="headerlink" title="28.3.2 编译应用程序"></a>28.3.2 编译应用程序</h3><p>来到存放应用程序read.c和write.c的文件夹下，使用以下命令对read.c和write.c进行交叉编译，编译完成如下图（图 28-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o read read.c -static</p>
<p>aarch64-linux-gnu-gcc -o write write.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps204.jpg" alt="img"> </p>
<p>图 28-4</p>
<p>生成的read write文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="28-3-3-测试"><a href="#28-3-3-测试" class="headerlink" title="28.3.3 测试"></a>28.3.3 测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 28-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps205.jpg" alt="img"></p>
<p>图 28-5</p>
<p>在加载驱动程序之后，会生成如下图（图 28-6）所示的设备节点，在应用程序中也是操作这个设备节点。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps206.jpg" alt="img"></p>
<p>图 28-6</p>
<p>首先运行read可执行程序，如下（图 28-7）所示，在三秒钟以后打印“time out”。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps207.jpg" alt="img"></p>
<p>图 28-7</p>
<p>然后运行write可执行程序写入数据，如下（图 28-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps208.jpg" alt="img"></p>
<p>图 28-8</p>
<p>接着可以看到read读取到了数据，如下（图 28-9）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps209.jpg" alt="img"></p>
<p>图 28-9</p>
<h1 id="第29章-信号驱动IO实验"><a href="#第29章-信号驱动IO实验" class="headerlink" title="第29章 信号驱动IO实验"></a>第29章 信号驱动IO实验</h1><p>本章节要讲解的信号驱动IO是最后一个IO模型，在第25章中我们已经对信号驱动IO有了基本的认识，本章节将对信号驱动IO进行深入的学习，最后通过相应的实验，来加深对信号驱动IO的理解。</p>
<h2 id="29-1-信号驱动IO简介"><a href="#29-1-信号驱动IO简介" class="headerlink" title="29.1 信号驱动IO简介"></a>29.1 信号驱动IO简介</h2><p>信号驱动IO不需要应用程序查询设备的状态，一旦设备准备就绪，会触发SIGIO信号，进而调用注册的处理函数。仍旧以钓鱼为例。小马同学喜欢吃新鲜的鱼，但是不想自己钓，所以他请了一个助手来帮他钓鱼，他自己去忙其他的事情（进程不阻塞，立即返回）。如果有鱼上钩助手会帮忙钓上来（将数据拷贝到指定的缓冲区），并立即通知小马同学回来把鱼取走（处理数据）。</p>
<p>如果要实现信号驱动IO，需要应用程序和驱动程序配合，应用程序使用信号驱动IO的步骤有三步：</p>
<p>步骤1 ：注册信号处理函数 应用程序使用signal函数来注册SIGIO信号的信号处理函数。</p>
<p>步骤2： 设置能够接收这个信号的进程</p>
<p>步骤3： 开启信号驱动IO 通常使用fcntl函数的F_SETFL命令打开FASYNC标志。</p>
<p>fcntl函数如下所示：</p>
<p>****函数原型****： </p>
<p>int fcntl(int fd,int cmd, …)</p>
<p>****函数功能****： </p>
<p>fcntl函数可以用来操作文件描述符</p>
<p><em><strong>*函数参数*</strong></em>:</p>
<p>fd: 被操作的文件描述符</p>
<p>cmd: 操作文件描述符的命令，cmd参数决定了要如何操作文件描述符fd</p>
<p>…: 根据cmd的参数来决定是不是需要使用第三个参数</p>
<p>操作文件描述符的命令如下表（表 29-1）所示：</p>
<table>
<thead>
<tr>
<th>命令名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>F_DUPFD</td>
<td>复制文件描述符</td>
</tr>
<tr>
<td>F_GETFD</td>
<td>获取文件描述符标志</td>
</tr>
<tr>
<td>F_SETFD</td>
<td>设置文件描述符标志</td>
</tr>
<tr>
<td>F_GETFL</td>
<td>获取文件状态标志</td>
</tr>
<tr>
<td>F_SETFL</td>
<td>设置文件状态标志</td>
</tr>
<tr>
<td>F_GETLK</td>
<td>获取文件锁</td>
</tr>
<tr>
<td>F_SETLK</td>
<td>设置文件锁</td>
</tr>
<tr>
<td>F_SETLKW</td>
<td>类似F_SETLK，但等待返回</td>
</tr>
<tr>
<td>F_GETOWN</td>
<td>获取当前接收SIGIO和SIGURG信号的进程ID和进程组ID</td>
</tr>
<tr>
<td>F_SETOWN</td>
<td>设置当前接收SIGIO和SIGURG信号的进程ID和进程组ID</td>
</tr>
</tbody></table>
<p>表 29-2</p>
<p>接下来学习驱动程序实现fasync方法</p>
<p>步骤1 </p>
<p>当应用程序开启信号驱动IO时，会触发驱动中的fasync函数。所以首先在file_operations结构体中实现fasync函数，函数原型如下：</p>
<p>int (*fasync) (int fd,struct file *filp,int on)</p>
<p>步骤2</p>
<p>在驱动中的fasync函数调用fasync_helper函数来操作fasync_struct结构体，fasync_helper函数原型如下：</p>
<p>int fasync_helper(int fd,struct file *filp,int on,struct fasync_struct **fapp)</p>
<p>步骤3：</p>
<p>当设备准备好的时候，驱动程序需要调用kill_fasync函数通知应用程序，此时应用程序的SIGIO信号处理函数就会被执行。kill_fasync负责发送指定的信号，函数原型如下：</p>
<p>void kill_fasync(struct fasync_struct **fp,int sig,int band)</p>
<p><em><strong>*函数参数：*</strong></em></p>
<p>fp: 要操作的fasync_struct</p>
<p>sig: 发送的信号</p>
<p>band: 可读的时候设置成POLLIN ，可写的时候设置成POLLOUT</p>
<h2 id="29-2-实验程序编写"><a href="#29-2-实验程序编写" class="headerlink" title="29.2 实验程序编写"></a>29.2 实验程序编写</h2><h3 id="29-2-1-编写测试-APP"><a href="#29-2-1-编写测试-APP" class="headerlink" title="29.2.1 编写测试 APP"></a>29.2.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\23\app。</p>
<p>编写应用程序write.c，在此代码中，调用write函数向&#x2F;dev&#x2F;test设备写入数据“nihao”。编写好的程序如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    char buf1[32] = &#123;0&#125;;   </span><br><span class="line">    char buf2[32] = &quot;nihao&quot;;</span><br><span class="line">    fd = open(&quot;/dev/test&quot;,O_RDWR);  //打开/dev/test设备</span><br><span class="line">    if (fd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;open error \n&quot;);</span><br><span class="line">        return fd;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;write before \n&quot;);</span><br><span class="line">    write(fd,buf2,sizeof(buf2));  //向/dev/test文件写入数据</span><br><span class="line">    printf(&quot;write after\n&quot;);</span><br><span class="line">    close(fd);     //关闭文件</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后来编写应用程序read.c，在此代码中要使用信号驱动IO读取数据。编写好的应用程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">char</span> buf1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//SIGIO信号的信号处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> signum)</span></span><br><span class="line">&#123;</span><br><span class="line">    read(fd,buf1,<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;buf is %s\n&quot;</span>,buf1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">       fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDWR);  <span class="comment">//打开led驱动</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signal(SIGIO,func);  <span class="comment">//步骤一：使用signal函数注册SIGIO信号的信号处理函数</span></span><br><span class="line">     <span class="comment">//步骤二：设置能接收这个信号的进程</span></span><br><span class="line">     <span class="comment">//fcntl函数用来操作文件描述符，</span></span><br><span class="line">     <span class="comment">//F_SETOWN 设置当前接收的SIGIO的进程ID</span></span><br><span class="line">     fcntl(fd,F_SETOWN,getpid()); </span><br><span class="line"></span><br><span class="line">    flags = fcntl(fd,F_GETFD); <span class="comment">//获取文件描述符标志</span></span><br><span class="line">    <span class="comment">//步骤三  开启信号驱动IO 使用fcntl函数的F_SETFL命令打开FASYNC标志</span></span><br><span class="line">    fcntl(fd,F_SETFL,flags| FASYNC);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);    </span><br><span class="line">    close(fd);     <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="29-2-2-驱动程序编写"><a href="#29-2-2-驱动程序编写" class="headerlink" title="29.2.2 驱动程序编写"></a>29.2.2 驱动程序编写</h3><p>本实验对应的驱动程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\23\module。</p>
<p>接下来编写驱动程序，在29.1小节中介绍了驱动程序中实现fasync方法的三个步骤，按照这个思路，依次实现这三步，编写好的驱动程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span>  flag;  <span class="comment">//标志位</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">device_test</span> <span class="title">dev1</span>;</span>  </span><br><span class="line"></span><br><span class="line">DECLARE_WAIT_QUEUE_HEAD(read_wq); <span class="comment">//定义并初始化等待队列头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开设备函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(test_dev-&gt;kbuf, buf, size) != <span class="number">0</span>) <span class="comment">// copy_from_user:用户空间向内核空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test_dev-&gt;flag=<span class="number">1</span>;</span><br><span class="line">    wake_up_interruptible(&amp;read_wq);</span><br><span class="line">    kill_fasync(&amp;test_dev-&gt;fasync,SIGIO,POLLIN);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span>(file-&gt;f_flags &amp; O_NONBLOCK )&#123;</span><br><span class="line">        <span class="keyword">if</span> (test_dev-&gt;flag !=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    &#125;</span><br><span class="line">    wait_event_interruptible(read_wq,test_dev-&gt;flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, test_dev-&gt;kbuf, <span class="built_in">strlen</span>( test_dev-&gt;kbuf)) != <span class="number">0</span>) <span class="comment">// copy_to_user:内核空间向用户空间传数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_to_user error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span>  <span class="type">__poll_t</span>  <span class="title function_">cdev_test_poll</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> poll_table_struct *p)</span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;  <span class="comment">//设置私有数据</span></span><br><span class="line">     <span class="type">__poll_t</span> mask=<span class="number">0</span>;    </span><br><span class="line">     poll_wait(file,&amp;read_wq,p);     <span class="comment">//应用阻塞</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (test_dev-&gt;flag == <span class="number">1</span>)    </span><br><span class="line">     &#123;</span><br><span class="line">         mask |= POLLIN;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> mask;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_fasync</span> <span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span>=</span>(<span class="keyword">struct</span> device_test *)file-&gt;private_data;  <span class="comment">//设置私有数据</span></span><br><span class="line">    <span class="keyword">return</span>  fasync_helper(fd,file,on,&amp;test_dev-&gt;fasync);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">    .poll = cdev_test_poll,  <span class="comment">//将poll字段指向chrdev_poll(...)函数</span></span><br><span class="line">    .fasync = cdev_test_fasync,   <span class="comment">//将fasync字段指向cdev_test_fasync(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chr_fops_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">   dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chr_fops_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(chr_fops_init);</span><br><span class="line">module_exit(chr_fops_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="29-3-运行测试"><a href="#29-3-运行测试" class="headerlink" title="29.3 运行测试"></a>29.3 运行测试</h2><h3 id="29-3-1-编译程序"><a href="#29-3-1-编译程序" class="headerlink" title="29.3.1 编译程序"></a>29.3.1 编译程序</h3><p>在上一小节中的fasync.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m +=fasync.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放fasync.c.c和Makefile文件目录下，如下图（图 29-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps210.jpg" alt="img"> </p>
<p>图 29-2</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图29-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps211.jpg" alt="img"> </p>
<p>图 29-3</p>
<p>编译完生成fasync.ko目标文件，如下图（图 29-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps212.jpg" alt="img"> </p>
<p>图 29-4</p>
<p>至此驱动模块就编译成功了，下面进行交叉编译应用程序。</p>
<h3 id="29-3-2-编译应用程序"><a href="#29-3-2-编译应用程序" class="headerlink" title="29.3.2 编译应用程序"></a>29.3.2 编译应用程序</h3><p>来到存放应用程序read.c和write.c的文件夹下，使用以下命令对read.c和write.c进行交叉编译，编译完成如下图（图 29-5）所示：</p>
<p>aarch64-linux-gnu-gcc -o read read.c -static</p>
<p>aarch64-linux-gnu-gcc -o write write.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps213.jpg" alt="img"> </p>
<p>图 29-5</p>
<p>生成的read write文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="29-3-3-测试"><a href="#29-3-3-测试" class="headerlink" title="29.3.3 测试"></a>29.3.3 测试</h3><p>输入以下命令加载驱动程序。</p>
<p>insmod fasync.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps214.jpg" alt="img"></p>
<p>图 29-6</p>
<p>输入以下命令运行read应用程序，如下图（图 29-7）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps215.jpg" alt="img"></p>
<p>图 29-7</p>
<p>然后输入以下命令运行write应用程序，如下图（图 29-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps216.jpg" alt="img"></p>
<p>图 29-8</p>
<p>如下图（图29-9）所示，read程序窗口打印读取的数据。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps217.jpg" alt="img"></p>
<p>图 29-9</p>
<h1 id="第30章-定时器实验"><a href="#第30章-定时器实验" class="headerlink" title="第30章 定时器实验"></a>第30章 定时器实验</h1><p>在Linux内核中很多函数是基于定时器进行驱动的，所以时间管理在内核中占有非常重要的地位。本小节将对Linux中的时间管理相关知识进行学习.</p>
<h2 id="30-1-Linux定期器"><a href="#30-1-Linux定期器" class="headerlink" title="30.1 Linux定期器"></a>30.1 Linux定期器</h2><p>硬件为内核提供了一个系统定时器来计算流逝的时间（即基于未来时间点的计时方式，以当前时刻为计时开始的起点，以未来的某一时刻为计时的终点），内核只有在系统定时器的帮助下才能计算和管理时间，但是内核定时器的精度并不高，所以不能作为高精度定时器使用。并且内核定时器的运行没有周期性，到达计时终点后会自动关闭。如果要实现周期性定时，就要在定时处理函数中重新开启定时器。</p>
<p>Linux内核中使用timer_list 结构体表示内核定时器，该结构体定义在“内核源码&#x2F;include&#x2F;linux&#x2F;timer.h”文件中，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct timer_list &#123;</span><br><span class="line">    struct hlist_node   entry;</span><br><span class="line">    unsigned long       expires;/* 定时器超时时间，单位是节拍数 */</span><br><span class="line">    void            (*function)(struct timer_list *);/* 定时处理函数 */</span><br><span class="line">    u32         flags;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_LOCKDEP</span><br><span class="line">    struct lockdep_map  lockdep_map;</span><br><span class="line">#endif</span><br><span class="line">    ANDROID_KABI_RESERVE(1);</span><br><span class="line">    ANDROID_KABI_RESERVE(2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用以下宏对timer_list结构体进行定义，_name为定义的结构体名称，_function为定时处理函数，该宏同样定义在文件 “内核源码&#x2F;include&#x2F;linux&#x2F;timer.h”文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_TIMER(_name, _function)              \</span></span><br><span class="line"><span class="meta">struct timer_list _name =               \</span></span><br><span class="line"><span class="meta">    __TIMER_INITIALIZER(_function, 0)     </span></span><br></pre></td></tr></table></figure>

<p>例如可以使用以下代码对定时器和相应的定时处理函数进行定义 </p>
<p>DEFINE_TIMER(timer_test,function_test);&#x2F;&#x2F;定义一个定时器</p>
<p>定时器定义完成之后还需要通过一系列的 API 函数来初始化此定时器，部分函数说明如下(表30-1)所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void add_timer(struct timer_list *timer)</td>
<td>向 Linux 内核注册定时器，使用 add_timer 函数向内核注册定时器以后，定时器就会开始运行</td>
</tr>
<tr>
<td>int del_timer(struct timer_list * timer)</td>
<td>删除一个定时器</td>
</tr>
<tr>
<td>int mod_timer(struct timer_list *timer,unsigned long expires)</td>
<td>修改定时值，如果定时器还没有激活的话，mod_timer 函数会激活定时器</td>
</tr>
</tbody></table>
<p>表 	30-1</p>
<p>在使用add_timer()函数向 Linux 内核注册定时器之前，还需要设置定时时间，定时时间由timer_list结构体中的expires参数所确定，单位为节拍数，可以通过图形化界面设置系统节拍的频率，具体路径如下图(图 30-2)所示：</p>
<p>-&gt; Kernel Features</p>
<p>-&gt; Timer frequency (<choice> [&#x3D;y])</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps218.jpg" alt="img"> </p>
<p>图 30-2</p>
<p>​	从上图可以看出可选的系统节拍率为 100Hz、250Hz、300Hz和 1000Hz，默认情况下选择 300Hz。</p>
<p>通过全局变量jiffies来记录自系统启动以来产生节拍的总数。启动时，内核将该变量初始化为0，此后，每次时钟中断处理程序都会增加该变量的值，一秒内jiffes增加的值为设置的系统节拍数，该变量定义在”内核源码&#x2F;include&#x2F;linux&#x2F;jiffies.h”文件中（timer.h文件中已经包含，不需要重复引用），具体定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern u64 __cacheline_aligned_in_smp jiffies_64;</span><br><span class="line">extern unsigned long volatile __cacheline_aligned_in_smp __jiffy_arch_data jiffies;</span><br></pre></td></tr></table></figure>

<p>​	其中jiffies_64用于64位系统，而jiffies用于 32 位系统。为了方便开发，Linux 内核还提供了几个jiffies和ms、us、ns之间的转换函数，如下(表 30-2)所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>int jiffies_to_msecs(const unsigned long j)</td>
<td>将 jiffies 类型的参数 j 分别转换为对应的毫秒</td>
</tr>
<tr>
<td>int jiffies_to_usecs(const unsigned long j)</td>
<td>将 jiffies 类型的参数 j 分别转换为对应的微秒</td>
</tr>
<tr>
<td>u64 jiffies_to_nsecs(const unsigned long j)</td>
<td>将 jiffies 类型的参数 j 分别转换为对应的纳秒</td>
</tr>
<tr>
<td>long msecs_to_jiffies(const unsigned int m)</td>
<td>将毫秒转换为 jiffies 类型</td>
</tr>
<tr>
<td>long usecs_to_jiffies(const unsigned int u)</td>
<td>将微秒转换为 jiffies 类型</td>
</tr>
<tr>
<td>unsigned long nsecs_to_jiffies(u64 n)</td>
<td>将纳秒转换为 jiffies 类型</td>
</tr>
</tbody></table>
<p>表 30-3</p>
<p>​	例如可以使用以下命令进行3秒钟的定时：</p>
<p>timer_test.expires &#x3D; jiffies_64 +msecs_to_jiffies(3000) </p>
<p>至此关于Linux定时器相关的知识就讲解完成了，在下个小节中将进行相应的实验。</p>
<h2 id="30-2-实验程序编写"><a href="#30-2-实验程序编写" class="headerlink" title="30.2 实验程序编写"></a>30.2 实验程序编写</h2><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\24\module。</p>
<p>本实验将实现五秒钟的计时，五秒钟之后将打印“this is function test”相关字符，为了实现循环打印还需要在定时处理函数中使用mod_timer函数重新设置定时时间。</p>
<p> 编写好的驱动程序timer_mod.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">function_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span>;<span class="comment">//定义function_test定时功能函数</span></span><br><span class="line">DEFINE_TIMER(timer_test,function_test);<span class="comment">//定义一个定时器</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">function_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;this is function test \n&quot;</span>);</span><br><span class="line">	mod_timer(&amp;timer_test,jiffies_64 + msecs_to_jiffies(<span class="number">5000</span>));<span class="comment">//使用mod_timer函数将定时时间设置为五秒后</span></span><br><span class="line">&#125;	</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_mod_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">	timer_test.expires = jiffies_64 + msecs_to_jiffies(<span class="number">5000</span>);<span class="comment">//将定时时间设置为五秒后</span></span><br><span class="line">	add_timer(&amp;timer_test);<span class="comment">//添加一个定时器</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_mod_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">	del_timer(&amp;timer_test);<span class="comment">//删除一个定时器</span></span><br><span class="line">	printk(<span class="string">&quot;module exit \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_mod_init);</span><br><span class="line">module_exit(timer_mod_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="30-3-运行测试"><a href="#30-3-运行测试" class="headerlink" title="30.3 运行测试"></a>30.3 运行测试</h2><h3 id="30-3-1-编译驱动程序"><a href="#30-3-1-编译驱动程序" class="headerlink" title="30.3.1 编译驱动程序"></a>30.3.1 编译驱动程序</h3><p>在上一小节中的timer_mod.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m += timer_mod.o    #此处要和你的驱动源文件同名</span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    #make操作</span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    #make clean操作</span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放timer_mod.c和Makefile文件目录下，如下图()所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps219.jpg" alt="img"> </p>
<p>图 30-4</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图30-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps220.jpg" alt="img"> </p>
<p>图30-5</p>
<p>编译完生成 timer_mod.ko目标文件，如下图（图 30-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps221.jpg" alt="img"> </p>
<p>图 30-6</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="30-3-2-运行测试"><a href="#30-3-2-运行测试" class="headerlink" title="30.3.2 运行测试"></a>30.3.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 30-7）所示：</p>
<p>insmod timer_mod.ko </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps222.jpg" alt="img"> </p>
<p>图 30-7</p>
<p>可以看到驱动加载之后，每隔五秒钟会打印“this is function test”相关打印，证明编写的驱动程序没有问题，最后使用以下命令卸载相应的驱动，如下图（图30-8）所示：</p>
<p>rmmod timer_mod.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps223.jpg" alt="img"> </p>
<p>图 30-8</p>
<h1 id="第31章-秒字符设备驱动实验"><a href="#第31章-秒字符设备驱动实验" class="headerlink" title="第31章 秒字符设备驱动实验"></a>第31章 秒字符设备驱动实验</h1><p>本章节将实现秒字符设备驱动，以此对之前学习到的知识进行巩固。本章节实验要实现的任务如下：</p>
<p>\1. 实现字符设备驱动框架，自动生成设备节点。</p>
<p>\2. 根据上一小节学到的知识，实现秒计时。</p>
<p>\3. 通过原子变量来记录递增的秒数，避免竞争的发生。</p>
<p>\4. 通过用户空间和内核空间的数据交换，将记录的秒数传递到应用空间，并通过应用程序打印出来。</p>
<h2 id="31-1-实验程序编写"><a href="#31-1-实验程序编写" class="headerlink" title="31.1 实验程序编写"></a>31.1 实验程序编写</h2><h3 id="31-1-1-编写测试-APP"><a href="#31-1-1-编写测试-APP" class="headerlink" title="31.1.1 编写测试 APP"></a>31.1.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\25\app。</p>
<p>首先来编写应用测试代码timer.c，在此代码中每隔一秒钟打印从用户空间传递来的秒数，具体代码内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符fd</span></span><br><span class="line">	<span class="type">int</span> count;<span class="comment">//定义int类型记录秒数的变量count</span></span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR);<span class="comment">//使用open()函数以可读可写的方式打开设备文件</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		read(fd,&amp;count,<span class="keyword">sizeof</span>(count));<span class="comment">//使用read函数读取内核传递来的秒数</span></span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;num is %d\n&quot;</span>,count);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="31-1-2-驱动程序编写"><a href="#31-1-2-驱动程序编写" class="headerlink" title="31.1.2 驱动程序编写"></a>31.1.2 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\25\module。</p>
<p> 编写好的驱动程序timer_dev.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">	<span class="type">int</span> sec; <span class="comment">//秒</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">atomic64_t</span> v = ATOMIC_INIT(<span class="number">0</span>);<span class="comment">//定义原子类型变量v，并定义为0</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">function_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span>;<span class="comment">//定义function_test定时功能函数</span></span><br><span class="line">DEFINE_TIMER(timer_test,function_test);<span class="comment">//定义一个定时器</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">function_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span></span><br><span class="line">&#123;</span><br><span class="line">	atomic64_inc(&amp;v);<span class="comment">//原子变量v自增</span></span><br><span class="line">	dev1.sec = <span class="type">atomic_read</span>(&amp;v);<span class="comment">//将读取到的原子变量v,赋值给sec</span></span><br><span class="line">	<span class="comment">//printk(&quot;the sec is %d\n&quot;,dev1.sec);</span></span><br><span class="line">	mod_timer(&amp;timer_test,jiffies_64 + msecs_to_jiffies(<span class="number">1000</span>));<span class="comment">//使用mod_timer函数将定时时间设置为一秒后</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">	add_timer(&amp;timer_test);	<span class="comment">//添加一个定时器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(copy_to_user(buf,&amp;dev1.sec,<span class="keyword">sizeof</span>(dev1.sec)))&#123;<span class="comment">//使用copy_to_user函数将sec传递到应用层</span></span><br><span class="line">		printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	del_timer(&amp;timer_test);<span class="comment">//删除一个定时器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_dev_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  	dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_dev_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_dev_init);</span><br><span class="line">module_exit(timer_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="31-2-运行测试"><a href="#31-2-运行测试" class="headerlink" title="31.2 运行测试"></a>31.2 运行测试</h2><h3 id="31-2-1-编译驱动程序"><a href="#31-2-1-编译驱动程序" class="headerlink" title="31.2.1 编译驱动程序"></a>31.2.1 编译驱动程序</h3><p>在上一小节中的timer_dev.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += timer_dev.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放timer_dev.c和Makefile文件目录下，如下图（图31-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps224.jpg" alt="img"> </p>
<p>图31-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 31-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps225.jpg" alt="img"> </p>
<p>图 31-2</p>
<p>编译完生成 timer_dev.ko目标文件，如下图（图 31-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps226.jpg" alt="img"> </p>
<p>图 31-3</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="31-2-2-编译应用程序"><a href="#31-2-2-编译应用程序" class="headerlink" title="31.2.2 编译应用程序"></a>31.2.2 编译应用程序</h3><p>然后来到存放应用程序timer.c的文件夹下，使用以下命令对timer.c进行交叉编译，编译完成如下图（图 31-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o timer timer.c</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps227.jpg" alt="img"> </p>
<p>图 31-4</p>
<p>生成的timer文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="31-2-3-运行测试"><a href="#31-2-3-运行测试" class="headerlink" title="31.2.3 运行测试"></a>31.2.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 31-5）所示：</p>
<p>insmod timer_dev.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps228.jpg" alt="img"> </p>
<p>图 31-5</p>
<p>然后输入以下命令进行可执行程序的运行，如下图（图 31-6）所示：</p>
<p>.&#x2F;timer</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps229.jpg" alt="img"> </p>
<p>图 31-6</p>
<p>可以看到每隔一秒钟就会打印由内核空间传递来的秒数，我们要实现的任务就完成了，最后使用以下命令卸载对应的驱动，如下图（图 31-7）所示：</p>
<p>rmmod timer_dev</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps230.jpg" alt="img"> </p>
<p>图 31-7</p>
<p>第32章 Linux内核打印实验 </p>
<p>本手册的实验都是在buildroot系统上完成的，由于buildroot系统已经设置了相应的打印等级，所以驱动的相关打印都能正常显示在串口终端上，如果将实验系统换成了ubuntu，然后加载同样的驱动，会发现打印信息不见了，这一现象的基本原因就是内核打印等级不同，那打印等级是如何修改的呢，查看打印等级的方式又有哪些呢，就让我们进入本章节的学习吧！</p>
<h2 id="32-1-方法一：dmseg-命令"><a href="#32-1-方法一：dmseg-命令" class="headerlink" title="32.1 方法一：dmseg 命令"></a>32.1 方法一：dmseg 命令</h2><p>在终端使用dmseg命令可以获取内核打印信息，该命令的具体使用方法如下所示：</p>
<p>dmesg命令</p>
<p>****英文全称：****display message（显示信息）</p>
<p><em><strong>*作用*</strong></em>****：****kernel 会将打印信息存储在 ring <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=buffer&spm=1001.2101.3001.7020">buffer</a> 中。可以利用 dmesg命令来查看内核打印信息。。</p>
<p><em><strong>*常用参数:*</strong></em></p>
<p>-C，–clear清除内核环形缓冲区</p>
<p>-c，—-read-clear读取并清除所有消息</p>
<p>-T，–显示时间戳</p>
<p>****提示：****dmesg命令也可以与grep命令组合使用。如查找待用usb关键字的打印信息，就可以使用如下命令:dmseg | grep usb</p>
<p>首先在串口终端使用“dmseg”命令，可以看见相应的内核打印信息已经加载了出来，如下图（图 32-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps231.jpg" alt="img"> </p>
<p>图 32-1</p>
<p>然后使用以下组合命令查找nfs相关的打印信息，如下图（图 32-2）所示：</p>
<p>dmesg | grep nfs</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps232.jpg" alt="img"> </p>
<p>图 32-2</p>
<p>至此关于dmesg命令就讲解演示完成了。</p>
<h2 id="32-2-方法二：查看kmsg文件"><a href="#32-2-方法二：查看kmsg文件" class="headerlink" title="32.2 方法二：查看kmsg文件"></a>32.2 方法二：查看kmsg文件</h2><p>内核所有的打印信息都会输出到循环缓冲区 ‘log_buf’，为了能够方便的在用户空间读取 内核打印信息，Linux内核驱动将该循环缓冲区映射到了&#x2F;proc目录下的文件节点kmsg。通过 cat或者其他应用程序读取Log Buffer的时候可以不断的等待新的log，所以访问&#x2F;proc&#x2F;kmsg 的方式适合长时间的读取log，一旦有新的log就可以被打印出来。</p>
<p>首先使用以下命令读取kmsg文件，在没有新的内核打印信息时会阻塞，如下图（图 32-3）所示：</p>
<p>cat &#x2F;proc&#x2F;kmsg</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps233.jpg" alt="img"> </p>
<p>图 32-3</p>
<p>然后在该设备的其他终端加载任意有打印信息的驱动文件（这里使用的是ssh），如下图（图 32-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps234.jpg" alt="img"> </p>
<p>图 32-4</p>
<p>在串口终端中可以看到对应驱动的打印信息就被打印了出来，如下图（图 32-5）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps235.jpg" alt="img"> </p>
<p>图 32-5</p>
<h2 id="32-3-方法三：调整内核打印等级"><a href="#32-3-方法三：调整内核打印等级" class="headerlink" title="32.3 方法三：调整内核打印等级"></a>32.3 方法三：调整内核打印等级</h2><p>内核的日志打印由相应的打印等级来控制，可以通过调整内核打印等级来控制打印日志的输出。使用以下命令查看当前默认打印等级，如下图（图 32-6）所示:</p>
<p>cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;printk</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps236.jpg" alt="img"> </p>
<p>图 32-6</p>
<p>可以看到内核打印等级由四个数字所决定，“7 4 1 7” 分别对应console_loglevel、default_message_loglevel、minimum_c onsole_loglevel、default_console_loglevel，具体类型说明如下表（表 32-7）所示：</p>
<table>
<thead>
<tr>
<th>终端打印类型</th>
<th>对应类型说明</th>
</tr>
</thead>
<tbody><tr>
<td>console_loglevel</td>
<td>只有当printk打印消息的log优先级高于console_loglevel时，才能输出到终端上</td>
</tr>
<tr>
<td>default_message_loglevel</td>
<td>printk打印消息时默认的log等级</td>
</tr>
<tr>
<td>minimum_console_loglevel</td>
<td>console_loglevel可以被设置的最小值</td>
</tr>
<tr>
<td>default_console_loglevel</td>
<td>console_loglevel的缺省值</td>
</tr>
</tbody></table>
<p>表 32-7</p>
<p>上面的“7 4 1 7”意味着只有优先级高于KERN_DEBUG(7)的打印消息才能输出到终端，在“内核源码&#x2F;include&#x2F;linux&#x2F;kern_levels.h”文件中对于文件打印等级进行了如下打印等级定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_EMERG  KERN_SOH <span class="string">&quot;0&quot;</span>    <span class="comment">/* system is unusable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ALERT  KERN_SOH <span class="string">&quot;1&quot;</span>    <span class="comment">/* action must be taken immediately */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_CRIT   KERN_SOH <span class="string">&quot;2&quot;</span>    <span class="comment">/* critical conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ERR    KERN_SOH <span class="string">&quot;3&quot;</span>    <span class="comment">/* error conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_WARNING    KERN_SOH <span class="string">&quot;4&quot;</span>    <span class="comment">/* warning conditions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_NOTICE KERN_SOH <span class="string">&quot;5&quot;</span>    <span class="comment">/* normal but significant condition */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_INFO   KERN_SOH <span class="string">&quot;6&quot;</span>    <span class="comment">/* informational */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_DEBUG  KERN_SOH <span class="string">&quot;7&quot;</span>    <span class="comment">/* debug-level messages */</span></span></span><br></pre></td></tr></table></figure>

<p>printk在打印信息前，可以加入相应的打印等级宏定义，具体格式如下所示：</p>
<p>printk(打印等级 “打印信息”)</p>
<p>接下来将使用以下驱动例程进行实际的打印等级测试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot; 0000 KERN_EMERG\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot; 1111 KERN_ALERT\n&quot;</span>);</span><br><span class="line">    printk(KERN_CRIT <span class="string">&quot; 2222 KERN_CRIT\n&quot;</span>);</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot; 3333 KERN_ERR\n&quot;</span>);</span><br><span class="line">    printk(KERN_WARNING <span class="string">&quot; 4444 KERN_WARNING\n&quot;</span>);</span><br><span class="line">    printk(KERN_NOTICE <span class="string">&quot; 5555 KERN_NOTICE\n&quot;</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot; 6666 KERN_INFO\n&quot;</span>);</span><br><span class="line">    printk(KERN_DEBUG <span class="string">&quot; 7777 KERN_DEBUG\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot; 8888 no_fix\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);</span><br><span class="line">module_exit(helloworld_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>加载该驱动之后，第5-11行0-6等级的打印信息就被打印了出来，第13行由于没有设置打印等级，所以会被赋予默认打印等级4，高于console_loglevel打印等级，所以也会被打印出来，最后只有第12行打印等级为7的信息，和console_loglevel打印等级相同，所以不会被打印出来，如下图（图 32-8）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps237.jpg" alt="img"> </p>
<p>图 32-8</p>
<p>然后使用以下命令将console_loglevel打印等级设置为4，如下图（图 32-9）所示：</p>
<p>echo 4 4 1 7 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;printk</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps238.jpg" alt="img"> </p>
<p>图 32-9</p>
<p>卸载驱动之后，再一次加载驱动，发现只有打印等级高于4的相关信息被打印了出来，如下图（图32-10）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps239.jpg" alt="img"> </p>
<p>图32-10</p>
<p>至此关于内核打印等级的实验就结束了。</p>
<h1 id="第33章llseek定位设备驱动实验"><a href="#第33章llseek定位设备驱动实验" class="headerlink" title="第33章llseek定位设备驱动实验"></a>第33章llseek定位设备驱动实验</h1><p>相信经过了前面章节的学习，大家已经对内核空间与用户空间的数据交互很是熟悉，但在之前的例子中都是对字符串的全部内容进行读写，假如现在有这样一个场景，将两个字符串依次进行写入，并对写入完成的字符串进行读取，如果仍采用之前的方式，第二次的写入值会覆盖第一次写入值，那要如何来实现上述功能呢？这就要轮到llseek出场了。</p>
<h2 id="33-1-定位设备llseek"><a href="#33-1-定位设备llseek" class="headerlink" title="33.1 定位设备llseek"></a>33.1 定位设备llseek</h2><h3 id="33-1-1-lseek函数的使用"><a href="#33-1-1-lseek函数的使用" class="headerlink" title="33.1.1 lseek函数的使用"></a>33.1.1 lseek函数的使用</h3><p>在应用程序中使用lseek函数进行读写位置的调整，该函数的具体使用说明如下所示：</p>
<p>lseek函数</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>​    off_t lseek(int fd, off_t offset, int whence);</p>
<p>****头文件****：</p>
<p>​    #include &lt;sys&#x2F;types.h&gt;</p>
<p>​    #include &lt;unistd.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>移动文件的读写位置。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>fd:	文件描述符；</p>
<p>off_t offset:	偏移量，单位是字节的数量，可以正负，如果是负值表示向前移动；如果是正值，表示向后移动。</p>
<p>whence：当前位置的基点，可以使用以下三组值。</p>
<p>​				SEEK_SET：相对于文件开头</p>
<p>​				SEEK_CUR:相对于当前的文件读写指针位置</p>
<p>​				SEEK_END:相对于文件末尾</p>
<p>****函数返回值：****成功返回当前位移大小，失败返回-1</p>
<p>函数使用示例：</p>
<p>把文件位置指针设置为5：	</p>
<p>lseek(fd,5,SEEK_SET);</p>
<p>把文件位置设置成文件末尾： </p>
<p>  lseek(fd,0,SEEK_END);</p>
<p>确定当前的文件位置：		</p>
<p>​	 lseek(fd,0,SEEK_CUR);</p>
<h3 id="33-1-2-驱动程序的完善"><a href="#33-1-2-驱动程序的完善" class="headerlink" title="33.1.2 驱动程序的完善"></a>33.1.2 驱动程序的完善</h3><p>上一小节中讲解的lseek函数如果要对设备文件生效，还需要完善相应的驱动程序。lseek函数会调用file_operation结构体中的llseek接口，所以需要对驱动中的llseek函数进行填充，并且完善read和write函数中偏移相关的部分。</p>
<p>下面对相关API接口函数进行填充：</p>
<p><em><strong>*llseek函数完善：*</strong></em></p>
<p>llseek填充完成的函数如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">loff_t</span> <span class="title function_">cdev_test_llseek</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">loff_t</span> offset, <span class="type">int</span> whence)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">loff_t</span> new_offset;<span class="comment">//定义loff_t类型的新的偏移值</span></span><br><span class="line">	<span class="keyword">switch</span>(whence)<span class="comment">//对lseek函数传递的whence参数进行判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> SEEK_SET:</span><br><span class="line">			<span class="keyword">if</span>(offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(offset &gt; BUFSIZE)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;	</span><br><span class="line">			&#125;</span><br><span class="line">			new_offset = offset;<span class="comment">//如果whence参数为SEEK_SET，则新偏移值为offset</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SEEK_CUR:</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &gt; BUFSIZE)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            new_offset = file-&gt;f_pos + offset;<span class="comment">//如果whence参数为SEEK_CUR，则新偏移值为file-&gt;f_pos + offset，file-&gt;f_pos为当前的偏移值</span></span><br><span class="line">			<span class="keyword">break</span>;			</span><br><span class="line">		<span class="keyword">case</span> SEEK_END:</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            new_offset = BUFSIZE + offset;<span class="comment">//如果whence参数为SEEK_END，则新偏移值为BUFSIZE + offset，BUFSIZE为最大偏移量</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	file-&gt;f_pos = new_offset;<span class="comment">//更新file-&gt;f_pos偏移值</span></span><br><span class="line">	<span class="keyword">return</span> new_offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第4行使用switch语句对传递的whence参数进行判断，whence在这里可以有三个取值，分别为SEEK_SET、SEEK_CUR和SEEK_END。</p>
<p>在6-16、17-28、29-38行代码中，分别对三个参数所代表的功能进行实现，其中需要注意的是file-&gt;f_pos指的是当前文件的偏移值。</p>
<p>在第40行和41行分别对f_pos偏移值进行更新，对新的偏移值进行返回。</p>
<p><em><strong>*read接口函数完善：*</strong></em></p>
<p>填充完成的read接口函数如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">loff_t</span> p = *off;<span class="comment">//将读取数据的偏移量赋值给loff_t类型变量p</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">size_t</span> count = size;</span><br><span class="line">	<span class="keyword">if</span>(p &gt; BUFSIZE)&#123;<span class="comment">//如果当前偏移值比最大偏移量大则返回错误</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(count &gt; BUFSIZE - p)&#123;</span><br><span class="line">		count  = BUFSIZE - p;<span class="comment">//如果要读取的偏移值超出剩余的空间，则读取到最后位置</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(copy_to_user(buf,mem+p,count))&#123;<span class="comment">//将mem中的值写入buf，并传递到用户空间</span></span><br><span class="line">		printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">		printk(<span class="string">&quot;buf[%d] is %c\n&quot;</span>,i,mem[i]);<span class="comment">//将mem中的值打印出来</span></span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;mem is %s,p is %llu,count is %d\n&quot;</span>,mem+p,p,count);</span><br><span class="line">	*off = *off + count;<span class="comment">//更新偏移值</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相较于之前的read接口函数，在第7行和第10行分别加入了对偏移值p和读取数量进行判定，在第13行通过偏移值p进行内核空间和用户空间数据的传递，最后在第21行对偏移值进行更新。</p>
<p><em><strong>*write接口函数完善：*</strong></em></p>
<p>write接口函数的完善和read接口函数相似，填充完成的write接口函数如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">loff_t</span> p = *off;<span class="comment">//将写入数据的偏移量赋值给loff_t类型变量p</span></span><br><span class="line">    <span class="type">size_t</span> count = size;</span><br><span class="line">    <span class="keyword">if</span>(p &gt; BUFSIZE)&#123;<span class="comment">//如果当前偏移值比最大偏移量大则返回错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &gt; BUFSIZE - p)&#123;</span><br><span class="line">        count  = BUFSIZE - p;<span class="comment">//如果要写入的偏移值超出剩余的空间，则写入到最后位置</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(copy_from_user(mem+p,buf,count))&#123;<span class="comment">//将buf中的值，从用户空间传递到内核空间</span></span><br><span class="line"> 		printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	printk(<span class="string">&quot;mem is %s,p is %llu\n&quot;</span>,mem+p,p);<span class="comment">//打印写入的值</span></span><br><span class="line">	*off = *off + count;<span class="comment">//更新偏移值</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相较于之前的write接口函数，在第7行和第10行分别加入了对偏移值p和读取数量进行判定，在第13行通过偏移值p进行内核空间和用户空间数据的传递，最后在第18行对偏移值进行更新。</p>
<p>至此，关于定位设备相关的API接口函数就都填充完成了，将在下一小节进行定位设备驱动实验代码的编写。</p>
<h2 id="33-2-实验程序编写"><a href="#33-2-实验程序编写" class="headerlink" title="33.2 实验程序编写"></a>33.2 实验程序编写</h2><h3 id="33-2-1-编写测试-APP"><a href="#33-2-1-编写测试-APP" class="headerlink" title="33.2.1 编写测试 APP"></a>33.2.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\26\app。</p>
<p>首先来编写应用测试代码llseek.c，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型文件描述符</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> off;<span class="comment">//定义读写偏移位置</span></span><br><span class="line">	<span class="type">char</span> readbuf[<span class="number">13</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区readbuf</span></span><br><span class="line">	<span class="type">char</span> readbuf1[<span class="number">19</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义读取缓冲区readbuf1</span></span><br><span class="line"></span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR,<span class="number">666</span>);<span class="comment">//打开/dev/test设备</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	write(fd,<span class="string">&quot;hello world&quot;</span>,<span class="number">13</span>);<span class="comment">//向fd写入数据hello world</span></span><br><span class="line">	off = lseek(fd,<span class="number">0</span>,SEEK_CUR);<span class="comment">//读取当前位置的偏移量</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">    off = lseek(fd,<span class="number">0</span>,SEEK_SET);<span class="comment">//将偏移量设置为0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">	read(fd,readbuf,<span class="keyword">sizeof</span>(readbuf));<span class="comment">//将写入的数据读取到readbuf缓冲区</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;read is %s\n&quot;</span>,readbuf);</span><br><span class="line"></span><br><span class="line">    off = lseek(fd,<span class="number">0</span>,SEEK_CUR);<span class="comment">//读取当前位置的偏移量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">	off = lseek(fd,<span class="number">-1</span>,SEEK_CUR);<span class="comment">//将当前位置的偏移量向前挪动一位</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">    write(fd,<span class="string">&quot;Linux&quot;</span>,<span class="number">6</span>);<span class="comment">//向fd写入数据Linux</span></span><br><span class="line">    off = lseek(fd,<span class="number">0</span>,SEEK_CUR);<span class="comment">//读取当前位置的偏移量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">    off = lseek(fd,<span class="number">0</span>,SEEK_SET);<span class="comment">//将偏移量设置为0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line"></span><br><span class="line">    read(fd,readbuf1,<span class="keyword">sizeof</span>(readbuf1));<span class="comment">//将写入的数据读取到readbuf1缓冲区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read is %s\n&quot;</span>,readbuf1);</span><br><span class="line"></span><br><span class="line">    off = lseek(fd,<span class="number">0</span>,SEEK_CUR);<span class="comment">//读取当前位置的偏移量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;off is %d\n&quot;</span>,off);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="33-2-2-驱动程序编写"><a href="#33-2-2-驱动程序编写" class="headerlink" title="33.2.2 驱动程序编写"></a>33.2.2 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\26\module。</p>
<p> 编写好的驱动程序llseek.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024<span class="comment">//设置最大偏移量为1024</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> mem[BUFSIZE] = &#123;<span class="number">0</span>&#125;;<span class="comment">//设置数据存储数组mem</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*从设备读取数据*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">loff_t</span> p = *off;<span class="comment">//将读取数据的偏移量赋值给loff_t类型变量p</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">size_t</span> count = size;</span><br><span class="line">	<span class="keyword">if</span>(p &gt; BUFSIZE)&#123;<span class="comment">//如果当前偏移值比最大偏移量大则返回错误</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(count &gt; BUFSIZE - p)&#123;</span><br><span class="line">		count  = BUFSIZE - p;<span class="comment">//如果要读取的偏移值超出剩余的空间，则读取到最后位置</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(copy_to_user(buf,mem+p,count))&#123;<span class="comment">//将mem中的值写入buf，并传递到用户空间</span></span><br><span class="line">		printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">		printk(<span class="string">&quot;buf[%d] is %c\n&quot;</span>,i,mem[i]);<span class="comment">//将mem中的值打印出来</span></span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;mem is %s,p is %llu,count is %d\n&quot;</span>,mem+p,p,count);</span><br><span class="line">	*off = *off + count;<span class="comment">//更新偏移值</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*向设备写入数据函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">loff_t</span> p = *off;<span class="comment">//将写入数据的偏移量赋值给loff_t类型变量p</span></span><br><span class="line">    <span class="type">size_t</span> count = size;</span><br><span class="line">    <span class="keyword">if</span>(p &gt; BUFSIZE)&#123;<span class="comment">//如果当前偏移值比最大偏移量大则返回错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &gt; BUFSIZE - p)&#123;</span><br><span class="line">        count  = BUFSIZE - p;<span class="comment">//如果要写入的偏移值超出剩余的空间，则写入到最后位置</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(copy_from_user(mem+p,buf,count))&#123;<span class="comment">//将buf中的值，从用户空间传递到内核空间</span></span><br><span class="line"> 		printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	printk(<span class="string">&quot;mem is %s,p is %llu\n&quot;</span>,mem+p,p);<span class="comment">//打印写入的值</span></span><br><span class="line">	*off = *off + count;<span class="comment">//更新偏移值</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">loff_t</span> <span class="title function_">cdev_test_llseek</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">loff_t</span> offset, <span class="type">int</span> whence)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">loff_t</span> new_offset;<span class="comment">//定义loff_t类型的新的偏移值</span></span><br><span class="line">	<span class="keyword">switch</span>(whence)<span class="comment">//对lseek函数传递的whence参数进行判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> SEEK_SET:</span><br><span class="line">			<span class="keyword">if</span>(offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(offset &gt; BUFSIZE)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;	</span><br><span class="line">			&#125;</span><br><span class="line">			new_offset = offset;<span class="comment">//如果whence参数为SEEK_SET，则新偏移值为offset</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SEEK_CUR:</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &gt; BUFSIZE)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            new_offset = file-&gt;f_pos + offset;<span class="comment">//如果whence参数为SEEK_CUR，则新偏移值为file-&gt;f_pos + offset，file-&gt;f_pos为当前的偏移值</span></span><br><span class="line">			<span class="keyword">break</span>;			</span><br><span class="line">		<span class="keyword">case</span> SEEK_END:</span><br><span class="line">            <span class="keyword">if</span>(file-&gt;f_pos + offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            new_offset = BUFSIZE + offset;<span class="comment">//如果whence参数为SEEK_END，则新偏移值为BUFSIZE + offset，BUFSIZE为最大偏移量</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	file-&gt;f_pos = new_offset;<span class="comment">//更新file-&gt;f_pos偏移值</span></span><br><span class="line">	<span class="keyword">return</span> new_offset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">    .open = cdev_test_open, <span class="comment">//将open字段指向chrdev_open(...)函数</span></span><br><span class="line">    .read = cdev_test_read, <span class="comment">//将open字段指向chrdev_read(...)函数</span></span><br><span class="line">    .write = cdev_test_write, <span class="comment">//将open字段指向chrdev_write(...)函数</span></span><br><span class="line">    .release = cdev_test_release, <span class="comment">//将open字段指向chrdev_release(...)函数</span></span><br><span class="line">	.llseek = cdev_test_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_dev_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  	dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_dev_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_dev_init);</span><br><span class="line">module_exit(timer_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="33-3-运行测试"><a href="#33-3-运行测试" class="headerlink" title="33.3 运行测试"></a>33.3 运行测试</h2><h3 id="33-3-1-编译驱动程序"><a href="#33-3-1-编译驱动程序" class="headerlink" title="33.3.1 编译驱动程序"></a>33.3.1 编译驱动程序</h3><p>在上一小节中的llseek.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += llseek.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放llseek.c和Makefile文件目录下，如下图（图 33-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps240.jpg" alt="img"> </p>
<p>图 33-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 33-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps241.jpg" alt="img"> </p>
<p>图 33-2</p>
<p>编译完生成 llseek.ko目标文件，如下图（图 33-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps242.jpg" alt="img"> </p>
<p>图 33-3</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="33-3-2-编译应用程序"><a href="#33-3-2-编译应用程序" class="headerlink" title="33.3.2 编译应用程序"></a>33.3.2 编译应用程序</h3><p>来到存放应用程序llseek.c的文件夹下，使用以下命令对llseek.c进行交叉编译，编译完成如下图（图 33-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o read read.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps243.jpg" alt="img"> </p>
<p>图 33-4</p>
<p>生成的llseek文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="33-3-3-运行测试"><a href="#33-3-3-运行测试" class="headerlink" title="33.3.3 运行测试"></a>33.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 33-5）所示：</p>
<p>insmod llseek.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps244.jpg" alt="img"> </p>
<p>图 33-5</p>
<p>然后使用以下命令运行可执行文件llseek，运行结果如下图（图 33-6）所示：</p>
<p>.&#x2F;llseek</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps245.jpg" alt="img"> </p>
<p>图 33-6</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps246.jpg" alt="img"> </p>
<p>图 33-7</p>
<p>然后使用以下命令卸载对应的驱动，如下图（图 33-8）所示：</p>
<p>rmmod timer_dev</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps247.jpg" alt="img"> </p>
<p>图 33-8</p>
<h1 id="第34章-IOCTL驱动传参实验"><a href="#第34章-IOCTL驱动传参实验" class="headerlink" title="第34章 IOCTL驱动传参实验"></a>第34章 IOCTL驱动传参实验</h1><p>用户如果要对外设进行操作，对应的设备驱动不仅要具备读写的能力，还需要对硬件进行控制。以点亮LED灯驱动实验为例，应用程序通过向内核空间写入1和0从而控制LED灯的亮灭，但是读写操作主要是数据流对数据进行操作，而一些复杂的控制通常需要非数据操作，这时本章节要学习的ioctl函数就闪耀登场了。</p>
<h2 id="34-1-ioctl基础"><a href="#34-1-ioctl基础" class="headerlink" title="34.1 ioctl基础"></a>34.1 ioctl基础</h2><p>ioctl是设备驱动程序中用来控制设备的接口函数，一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87&spm=1001.2101.3001.7020">字符设备</a>驱动通常需要实现设备的打开、关闭、读取、写入等功能，而在一些需要细分的情况下，就需要扩展新的功能，通常以增设ioctl()命令的方式来实现。</p>
<p>下面将从应用层和驱动函数两个方面来对ioctl函数进行学习。</p>
<p><em><strong>*应用层：*</strong></em></p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>​    int ioctl(int fd, unsigned int cmd, unsigned long args);</p>
<p>****头文件****：</p>
<p>​    #include &lt;sys&#x2F;ioctl.h&gt;</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>用于向设备发送控制和配置命令。</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>fd ：是用户程序打开设备时返回的文件描述符 </p>
<p>cmd ：是用户程序对设备的控制命令，</p>
<p>args：应用程序向驱动程序下发的参数，如果传递的参数为指针类型，则可以接收驱动向用户空间传递的数据（在下面的实验中会进行使用）</p>
<p>上述三个参数中，最重要的是第二个cmd参数，为unsigned int 类型，为了高效的使用cmd参数传递更多的控制信息，一个unsigned int cmd被拆分为了4段，每一段都有各自的意义，unsigned int cmd位域拆分如下：</p>
<p>cmd[31:30]—数据（args）的传输方向（读写）</p>
<p>​	cmd[29:16]—数据（args）的大小</p>
<p>​	cmd[15:8]—&gt;命令的类型，可以理解成命令的密钥，一般为ASCII码（0-255的一个字符，有部分字符已经被占用，每个字符的序号段可能部分被占用）</p>
<p>​	cmd[7:0] —&gt;命令的序号，是一个8bits的数字（序号，0-255之间）</p>
<p>cmd参数由ioctl合成宏定义得到，四个合成宏定义如下所示：</p>
<p>定义一个命令，但是不需要参数：</p>
<p>#define _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)</p>
<p>定义一个命令，应用程序从驱动程序读参数：</p>
<p>#define _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))</p>
<p>定义一个命令，应用程序向驱动程序写参数：</p>
<p>#define _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</p>
<p>定义一个命令，参数是双向传递的：</p>
<p>#define _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</p>
<p>宏定义参数说明如下所示：</p>
<p>type：命令的类型，一般为一个ASCII码值，一个驱动程序一般使用一个type</p>
<p>​	nr：该命令下序号。一个驱动有多个命令，一般他们的type，序号不同</p>
<p>​	size：args的类型</p>
<p>例如可以使用以下代码定义不需要参数、向驱动程序写参数、向驱动程序读参数三个宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST0 _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST1 _IOW(<span class="string">&#x27;L&#x27;</span>,1,int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST2 _IOR(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br></pre></td></tr></table></figure>

<p>至此，关于应用程序的ioctl相关知识就讲解完成了。</p>
<p><em><strong>*驱动函数：*</strong></em></p>
<p>应用程序中ioctl函数会调用file_operation结构体中的unlocked_ioctl接口，接口定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long (*unlocked_ioctl) (struct file *file , unsigned int cmd, unsigned long arg);</span><br></pre></td></tr></table></figure>

<p>参数说明如下所示：</p>
<p>file：文件描述符。</p>
<p>​	cmd：与应用程序的cmd参数对应，在驱动程序中对传递来的cmd参数进行判断从而做出不同的动作。</p>
<p>​	arg：与应用程序的arg参数对应，从而实现内核空间和用户空间参数的传递。</p>
<p>至此，关于驱动函数中的ioctl相关知识就讲解完成了。在下一小节中将进行ioctl驱动传参实验。</p>
<h2 id="34-2-实验程序编写"><a href="#34-2-实验程序编写" class="headerlink" title="34.2 实验程序编写"></a>34.2 实验程序编写</h2><h3 id="34-2-1-编写测试-APP"><a href="#34-2-1-编写测试-APP" class="headerlink" title="34.2.1 编写测试 APP"></a>34.2.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\27\app。</p>
<p>首先来编写应用测试代码ioctl.c，在此代码中使用非阻塞的方式打开设备，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST0 _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST1 _IOW(<span class="string">&#x27;L&#x27;</span>,1,int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST2 _IOR(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型的文件描述符fd</span></span><br><span class="line">	<span class="type">int</span> val;<span class="comment">//定义int类型的传递参数val</span></span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR);<span class="comment">//打开test设备节点</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open fail\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;write&quot;</span>))&#123;</span><br><span class="line">		ioctl(fd,CMD_TEST1,<span class="number">1</span>);<span class="comment">//如果第二个参数为write，向内核空间写入1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;read&quot;</span>))&#123;</span><br><span class="line">		ioctl(fd,CMD_TEST2,&amp;val);<span class="comment">//如果第二个参数为read，则读取内核空间传递向用户空间传递的值</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;val is %d\n&quot;</span>,val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="34-2-2-驱动程序编写"><a href="#34-2-2-驱动程序编写" class="headerlink" title="34.2.2 驱动程序编写"></a>34.2.2 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\27\module。</p>
<p> 编写好的驱动程序ioctl.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST0 _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST1 _IOW(<span class="string">&#x27;L&#x27;</span>,1,int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST2 _IOR(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">cdev_test_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> val;<span class="comment">//定义int类型向应用空间传递的变量val</span></span><br><span class="line">	<span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> CMD_TEST0:</span><br><span class="line">            printk(<span class="string">&quot;this is CMD_TEST0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;		</span><br><span class="line">        <span class="keyword">case</span> CMD_TEST1:</span><br><span class="line">            printk(<span class="string">&quot;this is CMD_TEST1\n&quot;</span>);</span><br><span class="line">			printk(<span class="string">&quot;arg is %ld\n&quot;</span>,arg);<span class="comment">//打印应用空间传递来的arg参数</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CMD_TEST2:</span><br><span class="line">			val = <span class="number">1</span>;<span class="comment">//将要传递的变量val赋值为1</span></span><br><span class="line">            printk(<span class="string">&quot;this is CMD_TEST2\n&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span>(copy_to_user((<span class="type">int</span> *)arg,&amp;val,<span class="keyword">sizeof</span>(val)) != <span class="number">0</span>)&#123;<span class="comment">//通过copy_to_user向用户空间传递数据</span></span><br><span class="line">				printk(<span class="string">&quot;copy_to_user error \n&quot;</span>);	</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">break</span>;			</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	.unlocked_ioctl = cdev_test_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_dev_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line">  dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  	dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_dev_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_dev_init);</span><br><span class="line">module_exit(timer_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="34-3-运行测试"><a href="#34-3-运行测试" class="headerlink" title="34.3 运行测试"></a>34.3 运行测试</h2><h3 id="34-3-1-编译驱动程序"><a href="#34-3-1-编译驱动程序" class="headerlink" title="34.3.1 编译驱动程序"></a>34.3.1 编译驱动程序</h3><p>在上一小节中的ioctl.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm64#设置平台架构</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀</span><br><span class="line">obj-m += ioctl.o    #此处要和你的驱动源文件同名</span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    #这里是你的内核目录                                                                                                                            </span><br><span class="line">PWD ?= $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules    #make操作</span><br><span class="line">clean:</span><br><span class="line">    make -C $(KDIR) M=$(PWD) clean    #make clean操作</span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放ioctl.c和Makefile文件目录下，如下图（图 34-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps248.jpg" alt="img"> </p>
<p>图 34-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 34-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps249.jpg" alt="img"> </p>
<p>图 34-2</p>
<p>编译完生成 ioctl.ko目标文件，如下图（图 34-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps250.jpg" alt="img"> </p>
<p>图 34-4</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="34-3-2-编译应用程序"><a href="#34-3-2-编译应用程序" class="headerlink" title="34.3.2 编译应用程序"></a>34.3.2 编译应用程序</h3><p>来到存放应用程序ioctl.c的文件夹下，使用以下命令对ioctl.c进行交叉编译，编译完成如下图（图 34-5）所示：</p>
<p>aarch64-linux-gnu-gcc -o ioctl ioctl.c -static</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps251.jpg" alt="img"> </p>
<p>图 34-5</p>
<p>生成的ioctl文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="34-3-3-运行测试"><a href="#34-3-3-运行测试" class="headerlink" title="34.3.3 运行测试"></a>34.3.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 34-6）所示：</p>
<p>insmod ioctl.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps252.jpg" alt="img"> </p>
<p>图 34-6</p>
<p>然后使用以下命令通过ioctl向内核空间传递arg参数，传递成功如下图（图 34-7）所示：</p>
<p>.&#x2F;ioctl write</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps253.jpg" alt="img"> </p>
<p>图 34-7</p>
<p>然后使用以下命令通过ioctl读取内核空间向用户空间传递的val值，读取成功如下图（图 34-8）所示：</p>
<p>.&#x2F;ioctl read</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps254.jpg" alt="img"> </p>
<p>图 34-8</p>
<p>至此关于iocto驱动传参实验就测试完成了，可以使用以下命令卸载对应的驱动，如下图（图 34-9）所示： </p>
<p>rmmod ioctl.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps255.jpg" alt="img"> </p>
<p>图 34-9</p>
<h1 id="第35章-IOCTL地址传参实验"><a href="#第35章-IOCTL地址传参实验" class="headerlink" title="第35章 IOCTL地址传参实验"></a>第35章 IOCTL地址传参实验</h1><p>在上一章节中对ioctl基础知识进行了学习，并通过ioctl进行了驱动传参实验，在本章节将以传递结构体为例，进行地址传参实验，从而加深大家对ioctl的认识。</p>
<h2 id="35-1-实验程序编写"><a href="#35-1-实验程序编写" class="headerlink" title="35.1 实验程序编写"></a>35.1 实验程序编写</h2><h3 id="35-1-1-编写测试-APP"><a href="#35-1-1-编写测试-APP" class="headerlink" title="35.1.1 编写测试 APP"></a>35.1.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\28\app。</p>
<p>首先编写应用程序ioctl.c，用来向设备文件写入数据，编写好的应用程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST0 _IOW(<span class="string">&#x27;L&#x27;</span>,0,int)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span>&#123;</span><span class="comment">//定义要传递的结构体</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;<span class="comment">//定义int类型文件描述符</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">test</span>;</span><span class="comment">//定义args类型的结构体变量test</span></span><br><span class="line">	test.a = <span class="number">1</span>;</span><br><span class="line">	test.b = <span class="number">2</span>;</span><br><span class="line">	test.c = <span class="number">3</span>;</span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR,<span class="number">0777</span>);<span class="comment">//打开/dev/test设备</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ioctl(fd,CMD_TEST0,&amp;test);<span class="comment">//使用ioctl函数传递结构体变量test地址</span></span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="35-1-1-驱动程序编写"><a href="#35-1-1-驱动程序编写" class="headerlink" title="35.1.1 驱动程序编写"></a>35.1.1 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\28\module。</p>
<p> 编写好的驱动程序ioctl.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_TEST0 _IOW(<span class="string">&#x27;L&#x27;</span>,0,int)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">     <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">cdev_test_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">test</span>;</span>  </span><br><span class="line">	<span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> CMD_TEST0:</span><br><span class="line">			<span class="keyword">if</span>(copy_from_user(&amp;test,(<span class="type">int</span> *)arg,<span class="keyword">sizeof</span>(test)) != <span class="number">0</span>)&#123;<span class="comment">//将用户空间传递来的arg赋值给test</span></span><br><span class="line">				printk(<span class="string">&quot;copy_from_user error\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			printk(<span class="string">&quot;a = %d\n&quot;</span>,test.a);<span class="comment">//对传递的值进行打印验证</span></span><br><span class="line">  			printk(<span class="string">&quot;b = %d\n&quot;</span>,test.b);</span><br><span class="line">  	  		printk(<span class="string">&quot;c = %d\n&quot;</span>,test.c);</span><br><span class="line">            <span class="keyword">break</span>;			</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	.unlocked_ioctl = cdev_test_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_dev_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line"> dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/*5  创建设备*/</span></span><br><span class="line"> 	dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_dev_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_dev_init);</span><br><span class="line">module_exit(timer_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="35-2-运行测试"><a href="#35-2-运行测试" class="headerlink" title="35.2 运行测试"></a>35.2 运行测试</h2><h3 id="35-2-1-编译驱动程序"><a href="#35-2-1-编译驱动程序" class="headerlink" title="35.2.1 编译驱动程序"></a>35.2.1 编译驱动程序</h3><p>在上一小节中的ioctl.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += ioctl.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放ioctl.c和Makefile文件目录下，如下图（图 35-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps256.jpg" alt="img"> </p>
<p>图 35-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 35-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps257.jpg" alt="img"> </p>
<p>图 35-2</p>
<p>编译完生成 wq.ko目标文件，如下图（图 35-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps258.jpg" alt="img"> </p>
<p>图 35-3</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="35-2-2-编译应用程序"><a href="#35-2-2-编译应用程序" class="headerlink" title="35.2.2 编译应用程序"></a>35.2.2 编译应用程序</h3><p>来到存放应用程序ioctl.c的文件夹下，使用以下命令对ioctl.c进行交叉编译，编译完成如下图（图 35-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o ioctl ioctl.c</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps259.jpg" alt="img"> </p>
<p>图 35-4</p>
<p>生成的ioctl文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="35-2-3-运行测试"><a href="#35-2-3-运行测试" class="headerlink" title="35.2.3 运行测试"></a>35.2.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 35-5）所示：</p>
<p>insmod ioctl.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps260.jpg" alt="img"> </p>
<p>图 35-5</p>
<p>然后使用以下命令运行可执行程序，运行成功如下图（图 35-6）所示：</p>
<p> .&#x2F;ioctl</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps261.jpg" alt="img"> </p>
<p>图 35-6</p>
<p>可以看到结构体类型变量test已经成功传递到了内核空间，a、b、c的值都被正确打印了出来，我们的ioctl地址传参实验就完成了。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps262.jpg" alt="img"> </p>
<p>图 35-7</p>
<h1 id="第36章-封装驱动API接口实验"><a href="#第36章-封装驱动API接口实验" class="headerlink" title="第36章 封装驱动API接口实验"></a>第36章 封装驱动API接口实验</h1><p>相信经过前面两个章节的学习已经能够熟练的使用ioctl函数了，在本章节会进行两个实验，每个实验的要完成的任务如下所示：</p>
<p>实验一：通过ioctl对定时器进行控制，分别实现打开定时器、关闭定时器和设置定时时间的功能。</p>
<p>实验二：对实验一的应用程序进行封装，从而让应用编程人员更好的对设备进行编程。</p>
<h2 id="36-1-ioctl控制定时器实验"><a href="#36-1-ioctl控制定时器实验" class="headerlink" title="36.1 ioctl控制定时器实验"></a>36.1 ioctl控制定时器实验</h2><p>首先进行ioctl控制定时器实验，通过该实验可以综合ioctl函数和定时器相关知识，从而进一步加深对ioctl的理解。</p>
<h3 id="36-1-1-编写测试-APP"><a href="#36-1-1-编写测试-APP" class="headerlink" title="36.1.1 编写测试 APP"></a>36.1.1 编写测试 APP</h3><p>本实验对应的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\29\app1。</p>
<p>首先来编写应用测试代码ioctl.c，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_OPEN _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_CLOSE _IO(<span class="string">&#x27;L&#x27;</span>,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_SET _IOW(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR,<span class="number">0777</span>);<span class="comment">//打开test节点</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    ioctl(fd,TIME_SET,<span class="number">1000</span>);</span><br><span class="line">	ioctl(fd,TIME_OPEN);</span><br><span class="line">	sleep(<span class="number">3</span>);</span><br><span class="line">    ioctl(fd,TIME_SET,<span class="number">3000</span>);</span><br><span class="line">	sleep(<span class="number">7</span>);</span><br><span class="line">	ioctl(fd,TIME_CLOSE);</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第8-10行通过合成宏定义了三个ioctl命令，分别代表定时器打开、定时器关闭、定时时间设置。</p>
<p>第18行和第21行将定时时间分别设置为1秒和3秒。</p>
<p>第19行打开定时器。</p>
<p>第23行关闭定时器。</p>
<h3 id="36-1-2-驱动程序编写"><a href="#36-1-2-驱动程序编写" class="headerlink" title="36.1.2 驱动程序编写"></a>36.1.2 驱动程序编写</h3><p>本实验对应的网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\29\module。</p>
<p> 编写好的驱动程序ioctl_timer.c如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_OPEN _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_CLOSE _IO(<span class="string">&#x27;L&#x27;</span>,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_SET _IOW(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_test</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">dev_t</span> dev_num;  <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">int</span> major ;  <span class="comment">//主设备号</span></span><br><span class="line">    <span class="type">int</span> minor ;  <span class="comment">//次设备号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span> <span class="comment">// cdev</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>   <span class="comment">//类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">//设备</span></span><br><span class="line">	<span class="type">int</span> counter; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> <span class="title">dev1</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">fnction_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span>;<span class="comment">//定义function_test定时功能函数</span></span><br><span class="line">DEFINE_TIMER(timer_test,fnction_test);<span class="comment">//定义一个定时器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fnction_test</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;this is fnction_test\n&quot;</span>);</span><br><span class="line">    mod_timer(&amp;timer_test,jiffies_64 + msecs_to_jiffies(dev1.counter));<span class="comment">//使用mod_timer函数重新设置定时时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    file-&gt;private_data=&amp;dev1;<span class="comment">//设置私有数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">cdev_test_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_test</span> *<span class="title">test_dev</span> =</span> (<span class="keyword">struct</span> device_test *)file-&gt;private_data;<span class="comment">//设置私有数据</span></span><br><span class="line">	<span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> TIMER_OPEN:</span><br><span class="line">			add_timer(&amp;timer_test);<span class="comment">//添加一个定时器</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TIMER_CLOSE:</span><br><span class="line">			del_timer(&amp;timer_test);<span class="comment">//删除一个定时器</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TIMER_SET:</span><br><span class="line">			test_dev-&gt;counter = arg;</span><br><span class="line">			timer_test.expires = jiffies_64 + msecs_to_jiffies(test_dev-&gt;counter);<span class="comment">//设置定时时间</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设备操作函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE, <span class="comment">//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块</span></span><br><span class="line">	.open = cdev_test_open,</span><br><span class="line">	.release = cdev_test_release,</span><br><span class="line">	.unlocked_ioctl = cdev_test_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_dev_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注册字符设备驱动*/</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*1 创建设备号*/</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev1.dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>); <span class="comment">//动态分配设备号</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">goto</span> err_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev1.major = MAJOR(dev1.dev_num); <span class="comment">//获取主设备号</span></span><br><span class="line">    dev1.minor = MINOR(dev1.dev_num); <span class="comment">//获取次设备号</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;major is %d \r\n&quot;</span>, dev1.major); <span class="comment">//打印主设备号</span></span><br><span class="line">    printk(<span class="string">&quot;minor is %d \r\n&quot;</span>, dev1.minor); <span class="comment">//打印次设备号</span></span><br><span class="line">     <span class="comment">/*2 初始化cdev*/</span></span><br><span class="line">    dev1.cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;dev1.cdev_test, &amp;cdev_test_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3 添加一个cdev,完成字符设备注册到内核*/</span></span><br><span class="line">   ret =  cdev_add(&amp;dev1.cdev_test, dev1.dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span>  err_chr_add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*4 创建类*/</span></span><br><span class="line"> dev1. <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(IS_ERR(dev1.class))</span><br><span class="line">&#123;</span><br><span class="line">        ret=PTR_ERR(dev1.class);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*5  创建设备*/</span></span><br><span class="line">  	dev1.device = device_create(dev1.class, <span class="literal">NULL</span>, dev1.dev_num, <span class="literal">NULL</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(dev1.device))</span><br><span class="line">    &#123;</span><br><span class="line">        ret=PTR_ERR(dev1.device);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">        class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line"></span><br><span class="line">err_class_create:</span><br><span class="line">       cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line"></span><br><span class="line">err_chr_add:</span><br><span class="line">        unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line"></span><br><span class="line">err_chrdev:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_dev_exit</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注销字符设备*/</span></span><br><span class="line">    unregister_chrdev_region(dev1.dev_num, <span class="number">1</span>); <span class="comment">//注销设备号</span></span><br><span class="line">    cdev_del(&amp;dev1.cdev_test);                 <span class="comment">//删除cdev</span></span><br><span class="line">    device_destroy(dev1.class, dev1.dev_num);       <span class="comment">//删除设备</span></span><br><span class="line">    class_destroy(dev1.class);                 <span class="comment">//删除类</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(timer_dev_init);</span><br><span class="line">module_exit(timer_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="36-2-运行测试"><a href="#36-2-运行测试" class="headerlink" title="36.2 运行测试"></a>36.2 运行测试</h2><h3 id="36-2-1-编译驱动程序"><a href="#36-2-1-编译驱动程序" class="headerlink" title="36.2.1 编译驱动程序"></a>36.2.1 编译驱动程序</h3><p>在上一小节中的ioctl_timer.c代码同一目录下创建 Makefile 文件，Makefile 文件内容如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ARCH=arm64<span class="comment">#设置平台架构</span></span><br><span class="line"><span class="keyword">export</span> CROSS_COMPILE=aarch64-linux-gnu-<span class="comment">#交叉编译器前缀</span></span><br><span class="line">obj-m += ioctl_timer.o    <span class="comment">#此处要和你的驱动源文件同名</span></span><br><span class="line">KDIR :=/home/topeet/Linux/linux_sdk/kernel    <span class="comment">#这里是你的内核目录                                                                                                                            </span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules    <span class="comment">#make操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean    <span class="comment">#make clean操作</span></span><br></pre></td></tr></table></figure>

<p>对于Makefile的内容注释已在上图添加，保存退出之后，来到存放ioctl_timer.c和Makefile文件目录下，如下图（图 36-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps263.jpg" alt="img"> </p>
<p>图 36-1</p>
<p>然后使用命令“make”进行驱动的编译，编译完成如下图（图 36-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps264.jpg" alt="img"> </p>
<p>图 36-2</p>
<p>编译完生成 ioctl_timer.ko目标文件，如下图（图 36-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps265.jpg" alt="img"> </p>
<p>图 36-3</p>
<p>至此驱动模块就编译成功了，下面交叉编译应用程序。</p>
<h3 id="36-2-2-编译应用程序"><a href="#36-2-2-编译应用程序" class="headerlink" title="36.2.2 编译应用程序"></a>36.2.2 编译应用程序</h3><p>来到存放应用程序ioctl.c的文件夹下，使用以下命令对ioctl.c进行交叉编译，编译完成如下图（图 36-4）所示：</p>
<p>aarch64-linux-gnu-gcc -o ioctl ioctl.c</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps266.jpg" alt="img"> </p>
<p>图 36-4</p>
<p>生成的ioctl文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="36-2-3-运行测试"><a href="#36-2-3-运行测试" class="headerlink" title="36.2.3 运行测试"></a>36.2.3 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 36-5）所示：</p>
<p>insmod ioctl_timer.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps267.jpg" alt="img"> </p>
<p>图 36-5</p>
<p>输入以下命令运行可执行文件,运行成功如下图（图 36-6）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps268.jpg" alt="img"> </p>
<p>图 36-6</p>
<p>可以看到前面三个打印信息间隔为1秒钟，后面三个打印信息间隔为3秒钟，至此，实验一就结束了，然后使用以下命令卸载驱动模块，如下图（图 36-7）所示：</p>
<p>rmmod ioctl_timer.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps269.jpg" alt="img"> </p>
<p>图 36-7</p>
<h2 id="36-3-封装驱动API接口"><a href="#36-3-封装驱动API接口" class="headerlink" title="36.3 封装驱动API接口"></a>36.3 封装驱动API接口</h2><p>至此，随着ioctl练习的结束，字符设备驱动框架相关的知识也就完结了，相信细心的小伙伴在上一小节应用程序的编写中会发现问题，应用程序是从驱动的角度进行编写的，具体内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_OPEN _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_CLOSE _IO(<span class="string">&#x27;L&#x27;</span>,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_SET _IOW(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	fd = open(<span class="string">&quot;/dev/test&quot;</span>,O_RDWR,<span class="number">0777</span>);<span class="comment">//打开test节点</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open error \n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    ioctl(fd,TIME_SET,<span class="number">1000</span>);</span><br><span class="line">	ioctl(fd,TIME_OPEN);</span><br><span class="line">	sleep(<span class="number">3</span>);</span><br><span class="line">    ioctl(fd,TIME_SET,<span class="number">3000</span>);</span><br><span class="line">	sleep(<span class="number">7</span>);</span><br><span class="line">	ioctl(fd,TIME_CLOSE);</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为驱动工程师的我们当然可以理解每一行代码所要完成的功能，而一般情况下，应用都是由专业的应用工程师来进行编写的，上述代码编写方式很不利于应用工程师的理解和程序的移植，所以对于应用程序API的封装是一件必然的事情。</p>
<p>封装好的应用程序网盘路径为：iTOP-RK3568开发板【底板V1.7版本】\03_【iTOP-RK3568开发板】指南教程\02_Linux驱动配套资料\04_Linux驱动例程\29\app2。</p>
<p>首先来编写整体库文件timerlib.h，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TIMELIB_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TIMELIB_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_OPEN _IO(<span class="string">&#x27;L&#x27;</span>,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_CLOSE _IO(<span class="string">&#x27;L&#x27;</span>,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_SET _IOW(<span class="string">&#x27;L&#x27;</span>,2,int)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_open</span><span class="params">()</span>;<span class="comment">//定义设备打开函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_open</span><span class="params">(<span class="type">int</span> fd)</span>;<span class="comment">//定义定时器打开函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_close</span><span class="params">(<span class="type">int</span> fd)</span>;<span class="comment">//定义定时器关闭函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_set</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> arg)</span>;<span class="comment">//定义设置计时时间函数</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在9-11行使用合成宏定义了三个ioctl命令，分别代表定时器打开、定时器关闭、定时时间设置。</p>
<p>在第12-15行定义了四个功能函数，所代表的功能分别为设备打开、定时器打开、定时器关闭、定时时间设置。</p>
<p>接下来将创建每个功能函数的c文件，最后编译为单独的库，首先编写dev_open.c文件，编写好的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;timerlib.h&quot;</span><br><span class="line">int dev_open()</span><br><span class="line">&#123;</span><br><span class="line">    int fd；</span><br><span class="line">    fd = open(&quot;/dev/test&quot;,O_RDWR,0777);</span><br><span class="line">    if(fd &lt; 0)&#123;</span><br><span class="line">        printf(&quot;file open error \n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写定时器打开函数timeropen.c文件，编写好的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;timerlib.h&quot;</span><br><span class="line">int timer_open(int fd)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	ret = ioctl(fd,TIMER_OPEN);</span><br><span class="line">	if(ret &lt; 0)&#123;</span><br><span class="line">		printf(&quot;ioctl open error \n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写定时器打开函数timerclose.c文件，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timerlib.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_close</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ret = ioctl(fd,TIMER_CLOSE);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ioctl  close error \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写定时器打开函数timerset.c文件，编写好的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;timerlib.h&quot;</span><br><span class="line">int timer_set(int fd,int arg)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	ret = ioctl(fd,TIMER_SET,arg);</span><br><span class="line">	if(ret &lt; 0)&#123;</span><br><span class="line">		printf(&quot;ioctl error \n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后编写测试要用到的应用程序ioctl.c文件，编写好的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timerlib.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	fd = dev_open();</span><br><span class="line">    timer_set(fd,<span class="number">1000</span>);</span><br><span class="line">	timer_open(fd);</span><br><span class="line">	sleep(<span class="number">3</span>);</span><br><span class="line">	timer_set(fd,<span class="number">3000</span>);</span><br><span class="line">	sleep(<span class="number">7</span>);</span><br><span class="line">	timer_close(fd);</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，要用到的文件就都编写完成了，会在下一小节进行库的制作，以及应用程序的编译。</p>
<h2 id="36-4-运行测试"><a href="#36-4-运行测试" class="headerlink" title="36.4 运行测试"></a>36.4 运行测试</h2><h3 id="36-4-1-编译应用程序"><a href="#36-4-1-编译应用程序" class="headerlink" title="36.4.1 编译应用程序"></a>36.4.1 编译应用程序</h3><p>首先使用以下命令将存放功能函数的c文件编译成.o文件，编译完成如下图（图 36-7）所示：</p>
<p>aarch64-linux-gnu-gcc -c dev_open.c</p>
<p>aarch64-linux-gnu-gcc -c timer*.c</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps270.jpg" alt="img"> </p>
<p>图 36-7</p>
<p>然后使用以下命令将相应的.o文件编译成.a静态库（这里要注意库的名称都以lib开头），编译完成如下图（图 36-8）所示：</p>
<p>aarch64-linux-gnu-ar rcs libtime.a timer*.o</p>
<p>aarch64-linux-gnu-ar rcs libopen.a dev_open.o</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps271.jpg" alt="img"> </p>
<p>图 36-8</p>
<p>最后使用以下命令对ioctl.c进行交叉编译，编译完成如下图（图 36-9）所示：</p>
<p>aarch64-linux-gnu-gcc -o ioctl ioctl.c -L.&#x2F; -ltime -lopen</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps272.jpg" alt="img"> </p>
<p>图 36-9</p>
<p>生成的ioctl文件就是之后放在开发板上运行的可执行文件，至此应用程序的编译就完成了。</p>
<h3 id="36-4-2-运行测试"><a href="#36-4-2-运行测试" class="headerlink" title="36.4.2 运行测试"></a>36.4.2 运行测试</h3><p>开发板启动之后，使用以下命令进行驱动模块的加载，如下图（图 36-10）所示：</p>
<p>insmod ioctl_timer.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps273.jpg" alt="img"> </p>
<p>图 36-10</p>
<p>输入以下命令运行可执行文件,运行成功如下图（图 36-11）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps274.jpg" alt="img"> </p>
<p>图 36-11</p>
<p>可以看到前面三个打印信息间隔为1秒钟，后面三个打印信息间隔为3秒钟，至此，实验一就结束了，然后使用以下命令卸载驱动模块，如下图（图 36-12）所示：</p>
<p>rmmod ioctl_timer.ko</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps275.jpg" alt="img"> </p>
<p>图 36-12</p>
<h1 id="第37章-优化驱动稳定性和效率实验"><a href="#第37章-优化驱动稳定性和效率实验" class="headerlink" title="第37章 优化驱动稳定性和效率实验"></a>第37章 优化驱动稳定性和效率实验</h1><p>在Linux中应用程序运行在用户空间，应用程序错误之后，并不会影响其他程序的运行，而驱动工作在内核层，是内核代码的一部分，当驱动出现问题之后，可能会导致整个系统的崩溃。所以在驱动中，需要对各种判断、预处理等进行排查等，在本小节将对如何优化驱动稳定性和提高驱动效率进行学习。</p>
<h2 id="37-1-方法一：检测ioctl命令"><a href="#37-1-方法一：检测ioctl命令" class="headerlink" title="37.1 方法一：检测ioctl命令"></a>37.1 方法一：检测ioctl命令</h2><p>ioctl的cmd命令是由合成宏合成得到的，也有相应的分解宏得到各个参数，四个分解宏如下所示：</p>
<p>分解cmd命令，得到命令的类型：</p>
<p>_IOC_TYPE(cmd)</p>
<p>分解cmd命令，得到数据（args）的传输方向：</p>
<p>_IOC_DIR(cmd)</p>
<p>分解cmd命令，得到命令的序号：</p>
<p>_IOC_NR(cmd)</p>
<p>分解cmd命令，得到数据（args）的大小：</p>
<p>_IOC_SIZE(cmd)</p>
<p>可以在驱动中通过上述分解宏对传入的ioctl命令类型等参数进行判断，从而得到判断传入的参数是否正确，以此优化驱动的稳定性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(_IOC_TYPE(cmd) != <span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">   printk(<span class="string">&quot;cmd type error \n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如可以通过上述代码对传入参数的类型进行判断，如果传入的参数类型不为“L”,就返回错误，其他参数的检测方法相同。</p>
<h2 id="37-2-方法二：检测传递地址是否合理"><a href="#37-2-方法二：检测传递地址是否合理" class="headerlink" title="37.2 方法二：检测传递地址是否合理"></a>37.2 方法二：检测传递地址是否合理</h2><p>access_ok()函数</p>
<p><em><strong>*函数原型：*</strong></em></p>
<p>​    access_ok(addr,size);</p>
<p><em><strong>*函数作用：*</strong></em></p>
<p>检查用户空间内存块是否可用</p>
<p><em><strong>*参数含义：*</strong></em></p>
<p>addr  :  用户空间的指针变量，其指向一个要检查的内存块开始处。</p>
<p>size   :  要检查内存块的大小。</p>
<p><em><strong>*返回值：*</strong></em></p>
<p>成功返回1，失败返回0</p>
<p>以第35章的ioctl地址传参实验为例，对传入的args地址进行判断，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">test</span>;</span></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">	<span class="keyword">case</span> CMD_TEST0:</span><br><span class="line">		len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> args);</span><br><span class="line">		<span class="keyword">if</span>(!access_ok(arg,len))&#123;</span><br><span class="line">			 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(copy_from_user(&amp;test,(<span class="type">int</span> *)arg,<span class="keyword">sizeof</span>(test)) != <span class="number">0</span>)&#123;</span><br><span class="line">			 printk(<span class="string">&quot;copy_from_user error\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>在第6行对传入的args参数地址进行判断，如果不合法则返回-1，从而保证了驱动运行的稳定性。</p>
<h2 id="37-3-方法三：分支预测优化"><a href="#37-3-方法三：分支预测优化" class="headerlink" title="37.3 方法三：分支预测优化"></a>37.3 方法三：分支预测优化</h2><p>现在的CPU都有ICache和流水线机制。即运行当前指令时，ICache会预读取后面的指令，从而提升效率。但是如果条件分支的结果是跳转到了其他指令，那预取下一条指令就浪费时间了。而本章节要用到的likely和unlikely宏，会让编译器总是将大概率执行的代码放在靠前的位置，从而提高驱动的效率。</p>
<p>likely和unlikely宏定义在“内核源码&#x2F;include&#x2F;linux&#x2F;compiler.h”文件中，具体定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define likely(x) __builtin_expect(!!(x), 1)</span><br><span class="line">#define unlikely(x) __builtin_expect(!!(x), 0)</span><br></pre></td></tr></table></figure>

<p>__builtin_expect的作用是告知编译器预期表达式exp等于c的可能性更大，编译器可以根据该因素更好的对代码进行优化，所以likely与unlikely的作用就是表达性x为真的可能性更大（likely）和更小（unlikely）。</p>
<p>这里以上一小节添加传递地址检测内容后的代码为例，对copy_from_user函数添加分支预测优化函数，添加完成如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">test</span>;</span></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">	<span class="keyword">case</span> CMD_TEST0:</span><br><span class="line">		len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> args);</span><br><span class="line">		<span class="keyword">if</span>(!access_ok(arg,len))&#123;</span><br><span class="line">			 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(unlikely(copy_from_user(&amp;test,(<span class="type">int</span> *)arg,<span class="keyword">sizeof</span>(test)) != <span class="number">0</span>))&#123;</span><br><span class="line">			 printk(<span class="string">&quot;copy_from_user error\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>传递地址检测成功之后才会使用执行copy_from_user函数，在传递地址正确的前提下copy_from_user函数运行失败为小概率事件，所以这里使用unlikely函数进行驱动效率的优化。</p>
<p>至此，关于分支预测优化相关的知识就讲解完成了。</p>
<h1 id="第38章-驱动调试方法实验"><a href="#第38章-驱动调试方法实验" class="headerlink" title="第38章 驱动调试方法实验"></a>第38章 驱动调试方法实验</h1><p>在之前编写的驱动程序中，通常都使用printk函数打印相应的提示信息从而对驱动进行调试，那有没有其他的方式来调试驱动呢，答案是肯定的，在本章节中将对不同驱动调试方法进行学习。</p>
<h2 id="38-1-方法1：dump-stack函数"><a href="#38-1-方法1：dump-stack函数" class="headerlink" title="38.1 方法1：dump_stack函数"></a>38.1 方法1：dump_stack函数</h2><p>作用:打印内核调用堆栈，并打印函数的调用关系。</p>
<p>这里以最简单的helloworld驱动为例进行dump_stack函数演示，实验代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>        </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">	dump_stack();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);    </span><br><span class="line">module_exit(helloworld_exit);   </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    </span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>和原helloworld驱动程序相比，在第6行添加了dump_stack()，驱动加载之后打印信息如下（图 38-1）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps276.jpg" alt="img"> </p>
<p>图 38-1</p>
<p>可以看到helloworld_init函数的调用关系就都打印了出来。</p>
<p>至此关于dump_stack函数的测试就完成了。</p>
<h2 id="38-2-方法2：WARN-ON-condition-函数"><a href="#38-2-方法2：WARN-ON-condition-函数" class="headerlink" title="38.2 方法2：WARN_ON(condition)函数"></a>38.2 方法2：WARN_ON(condition)函数</h2><p>WARN_ON (condition)函数作用:在括号中的条件成立时，内核会抛出栈回溯，打印函数的调用关系。通常用于内核抛出一个警告，暗示某种不太合理的事情发生了。</p>
<p>WARN_ON实际上也是调用dump_stack，只是多了参数condition判断条件是否成立，例如WARN_ON (1)则条件判断成功，函数会成功执行。</p>
<p>这里仍然以最简单的helloworld驱动为例进行WARN_ON函数演示，实验代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>        </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">	WARN_ON(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);    </span><br><span class="line">module_exit(helloworld_exit);   </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    </span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);c</span><br></pre></td></tr></table></figure>

<p>和原helloworld驱动程序相比，在第6行添加了WARN_ON(1)，驱动加载之后打印信息如下（图 38-2）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps277.jpg" alt="img"> </p>
<p>图 38-2</p>
<p>可以看到helloworld_init函数的调用关系以及寄存器值就都打印了出来。</p>
<p>至此关于WARN_ON函数的测试就完成了。</p>
<h2 id="38-3-方法3：BUG-ON-condition-函数"><a href="#38-3-方法3：BUG-ON-condition-函数" class="headerlink" title="38.3 方法3：BUG_ON (condition)函数"></a>38.3 方法3：BUG_ON (condition)函数</h2><p>内核中有许多地方调用类似BUG_ON()的语句，它非常像一个内核运行时的断言，意味着本来不该执行到BUG_ON()这条语句，一旦BUG_ON()执行内核就会立刻抛出oops，导致栈的回溯和错误信息的打印。大部分体系结构把BUG()和BUG_ON()定义成某种非法操作，这样自然会产生需要的oops。参数condition判断条件是否成立，例如BUG_ON (1)则条件判断成功，函数会成功执行。</p>
<p>这里仍然以最简单的helloworld驱动为例进行BUGON函数演示，实验代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>        </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">	BUGON(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);    </span><br><span class="line">module_exit(helloworld_exit);   </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    </span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>和原helloworld驱动程序相比，在第6行添加了BUGON(1)，驱动加载之后打印信息如下（图 38-3）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps278.jpg" alt="img"> </p>
<p>图 38-3</p>
<p>可以看到helloworld_init函数的调用关系以及寄存器值就都打印了出来。</p>
<p>至此关于BUGON(1)函数的测试就完成了。</p>
<h2 id="38-4-方法4：panic-fmt…-函数"><a href="#38-4-方法4：panic-fmt…-函数" class="headerlink" title="38.4 方法4：panic (fmt…)函数"></a>38.4 方法4：panic (fmt…)函数</h2><p>panic (fmt…)函数:输出打印会造成系统死机并将函数的调用关系以及寄存器值就都打印了出来。</p>
<p>这里仍然以最简单的helloworld驱动为例进行panic 函数的演示，实验代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">helloworld_init</span><span class="params">(<span class="type">void</span>)</span>        </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_init\r\n&quot;</span>);</span><br><span class="line">	panic(<span class="string">&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">helloworld_exit</span><span class="params">(<span class="type">void</span>)</span>    </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;helloworld_exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);    </span><br><span class="line">module_exit(helloworld_exit);   </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);    </span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>和原helloworld驱动程序相比，在第6行添加了panic(“!!!!!!!!!!!!!!!!!!!!!!!!!!!!”)，驱动加载之后打印信息如下（图 38-4）所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/wps279.jpg" alt="img"> </p>
<p>图 38-4</p>
<p>可以看到helloworld_init函数的调用关系以及寄存器值就都打印了出来，信息打印完成之后会发现系统已经崩溃了，终端已经无法再进行输入。</p>
<p>至此关于panic函数的测试就完成了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E5%9B%9B%E7%AF%87-%E9%AB%98%E7%BA%A7%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E8%BF%9B%E9%98%B6/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%AB%98%E7%BA%A7%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E8%BF%9B%E9%98%B6/" rel="tag">高级字符设备进阶</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%94%E7%AF%87-%E4%B8%AD%E6%96%AD/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            rk3568 驱动开发第五篇 中断
          
        </div>
      </a>
    
    
      <a href="/2023/09/04/rk3568-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%89%E7%AF%87-%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">rk3568 驱动开发第三篇 并发与竞争</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="热爱学习的未来酱"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>