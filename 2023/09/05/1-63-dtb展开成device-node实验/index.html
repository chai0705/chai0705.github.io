<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="永远年轻，永远热泪盈眶" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>1-62-dtb文件格式讲解 |  热爱学习的未来酱</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="热爱学习的未来酱" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-1-63-dtb展开成device-node实验"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  1-62-dtb文件格式讲解
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/05/1-63-dtb%E5%B1%95%E5%BC%80%E6%88%90device-node%E5%AE%9E%E9%AA%8C/" class="article-date">
  <time datetime="2023-09-05T00:01:33.000Z" itemprop="datePublished">2023-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/rk3568-%E9%A9%B1%E5%8A%A8/">rk3568 驱动</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">5.7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">22 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第63章-dtb展开成device-node实验"><a href="#第63章-dtb展开成device-node实验" class="headerlink" title="第63章 dtb展开成device_node实验"></a>第63章 dtb展开成device_node实验</h1><p>在上个小节中我们讲解了设备树deb的文件格式，那deb文件是怎样传递给内核的呢，那就进入到本小节的学习吧。</p>
<h2 id="63-1-dtb展开流程"><a href="#63-1-dtb展开流程" class="headerlink" title="63.1 dtb展开流程"></a>63.1 dtb展开流程</h2><p>dtb展开流程图如下所示：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\ksohtml13380\wps224.jpg" alt="img"> </p>
<p>接下来将会根据上图对deb的展开流程进行详细的讲解：</p>
<p><strong>（1）设备树源文件编写：</strong>根据之前的章节中讲解的设备树的基本语法和相关知识编写符合规范的设备树。</p>
<p><strong>（2）设备树编译：</strong>设备树源文件经过设备树编译器（dtc）进行编译，生成设备树二进制文件（.dtb）。设备树编译器会检查源文件的语法和语义，并将其转换为二进制格式，以便内核能够解析和使用。</p>
<p><strong>（3）boot.img</strong>镜像生成：boot.img是一个包含内核镜像、设备树二进制文件和其他一些资源文件的镜像文件（目前只是适用于瑞芯微的soc上，其他厂商的soc需要具体问题具体分析）。在生成boot.img时，通常会将内核镜像、设备树二进制文件和其他一些资源文件打包在一起。这个过程可以使用特定的工具或脚本完成。</p>
<p>（<strong>4）U-Boot加载：</strong>U-Boot（Universal Bootloader）是一种常用的开源引导加载程序，用于引导嵌入式系统。在系统启动过程中，U-Boot会将boot.img中的内核和设备树的二进制文件加载到系统内存的特定地址。</p>
<p><strong>（5）内核初始化：</strong>U-Boot将内核和设备树的二进制文件加载到系统内存的特定地址后，控制权会转交给内核。在内核初始化的过程中，会解析设备树二进制文件，将其展开为内核可以识别的数据结构，以便内核能够正确地初始化和管理硬件资源。</p>
<p><strong>（6）设备树展开：</strong>设备树展开是指将设备树二进制文件解析成内核中的设备节点（device_node）的过程。内核会读取设备树二进制文件的内容，并根据设备树的描述信息，构建设备树数据结构，例如设备节点、中断控制器、寄存器、时钟等。这些设备树数据结构将在内核运行时用于管理和配置硬件资源。</p>
<p>而本章节要讲解的重点就在上面的第6步“设备树的展开”，最终设备树二进制文件会被解析成device_node，device_node结构体定义在内核源码的“&#x2F;include&#x2F;linux&#x2F;of.h”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;                <span class="comment">// 设备节点的名称</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *type;                <span class="comment">// 设备节点的类型</span></span><br><span class="line">	phandle phandle;                  <span class="comment">// 设备节点的句柄</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *full_name;           <span class="comment">// 设备节点的完整名称</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> <span class="title">fwnode</span>;</span>     <span class="comment">// 设备节点的固件节点句柄</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">properties</span>;</span>     <span class="comment">// 设备节点的属性列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">deadprops</span>;</span>      <span class="comment">// 已删除的属性列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">parent</span>;</span>      <span class="comment">// 父设备节点指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span>       <span class="comment">// 子设备节点指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">sibling</span>;</span>     <span class="comment">// 兄弟设备节点指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_KOBJ)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>             <span class="comment">// 内核对象（用于 sysfs）</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> _flags;            <span class="comment">// 设备节点的标志位</span></span><br><span class="line">	<span class="type">void</span> *data;                      <span class="comment">// 与设备节点相关的数据指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SPARC)</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *path_component_name; <span class="comment">// 设备节点的路径组件名称</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> unique_id;          <span class="comment">// 设备节点的唯一标识</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">of_irq_controller</span> *<span class="title">irq_trans</span>;</span> <span class="comment">// 设备节点的中断控制器</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后对该结构体的重要参数进行讲解：</p>
<p>（1）name：name 字段表示设备节点的名称。设备节点的名称是在设备树中唯一标识该节点的字符串。它通常用于在设备树中引用设备节点。</p>
<p>（2）type：type 字段表示设备节点的类型。设备节点的类型提供了关于设备节点功能和所属设备类别的信息。它可以用于识别设备节点的用途和特性。</p>
<p>（3）properties：properties 字段是指向设备节点属性列表的指针。设备节点的属性包含了与设备节点相关联的配置和参数信息。属性以键值对的形式存在，可以提供设备的特定属性、寄存器地址、中断信息等。property字段同样定义在内核源码的“&#x2F;include&#x2F;linux&#x2F;of.h”文件中，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct property &#123;</span><br><span class="line">	char *name;                    // 属性的名称</span><br><span class="line">	int length;                    // 属性值的长度（字节数）</span><br><span class="line">	void *value;                   // 属性值的指针</span><br><span class="line">	struct property *next;         // 下一个属性节点指针</span><br><span class="line">#if defined(CONFIG_OF_DYNAMIC) || defined(CONFIG_SPARC)</span><br><span class="line">	unsigned long _flags;          // 属性的标志位</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_OF_PROMTREE)</span><br><span class="line">	unsigned int unique_id;        // 属性的唯一标识</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_OF_KOBJ)</span><br><span class="line">	struct bin_attribute attr;     // 内核对象二进制属性</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（4）parent：parent 字段指向父设备节点。设备树中的设备节点按照层次结构组织，父设备节点是当前设备节点的直接上级。通过 parent 字段，可以在设备树中遍历设备节点的父子关系。</p>
<p>（5）child：child 字段指向子设备节点。在设备树中，一个设备节点可以拥有多个子设备节点。通过 child 字段，可以遍历设备节点的所有子设备节点。</p>
<p>（6）sibling：sibling 字段指向兄弟设备节点。在设备树中，同一级别的兄弟设备节点共享相同的父设备节点。通过 sibling 字段，可以在同级设备节点之间进行遍历。</p>
<p>至此，关于device_node的结构体讲解就完成了，虽然我们现在知道了，dtb文件最终会展开成device_node这一可以让内核识别的格式，那更具体的实现流程是怎样的呢，让我们进入下一小节的学习吧。</p>
<h2 id="63-2-dtb解析过程源码分析"><a href="#63-2-dtb解析过程源码分析" class="headerlink" title="63.2 dtb解析过程源码分析"></a>63.2 dtb解析过程源码分析</h2><p>首先来到源码目录下的“&#x2F;init&#x2F;main.c”文件，找到其中的start_kernel 函数，start_kernel 函数是 Linux 内核启动的入口点，它是Linux内核的核心函数之一，负责完成内核的初始化和启动过程，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __init <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *command_line;</span><br><span class="line">    <span class="type">char</span> *after_dashes;</span><br><span class="line"></span><br><span class="line">    set_task_stack_end_magic(&amp;init_task);    <span class="comment">// 设置任务栈的魔数</span></span><br><span class="line">    smp_setup_processor_id();    <span class="comment">// 设置处理器ID</span></span><br><span class="line">    debug_objects_early_init();    <span class="comment">// 初始化调试对象</span></span><br><span class="line">    cgroup_init_early();    <span class="comment">// 初始化cgroup（控制组）</span></span><br><span class="line"></span><br><span class="line">    local_irq_disable();    <span class="comment">// 禁用本地中断</span></span><br><span class="line">    early_boot_irqs_disabled = <span class="literal">true</span>;     <span class="comment">// 标记早期引导期间中断已禁用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 中断仍然被禁用。进行必要的设置，然后启用它们。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    boot_cpu_init();    <span class="comment">// 初始化引导CPU</span></span><br><span class="line">    page_address_init();    <span class="comment">// 设置页地址</span></span><br><span class="line">    pr_notice(<span class="string">&quot;%s&quot;</span>, linux_banner);    <span class="comment">// 打印Linux内核版本信息</span></span><br><span class="line">    setup_arch(&amp;command_line);    <span class="comment">// 架构相关的初始化</span></span><br><span class="line">    mm_init_cpumask(&amp;init_mm);    <span class="comment">// 初始化内存管理的cpumask（CPU掩码）</span></span><br><span class="line">    setup_command_line(command_line);    <span class="comment">// 设置命令行参数</span></span><br><span class="line">    setup_nr_cpu_ids();    <span class="comment">// 设置CPU个数</span></span><br><span class="line">    setup_per_cpu_areas();    <span class="comment">// 设置每个CPU的区域</span></span><br><span class="line">    smp_prepare_boot_cpu();    <span class="comment">// 准备启动CPU（架构特定的启动CPU钩子）</span></span><br><span class="line">    boot_cpu_hotplug_init();    <span class="comment">// 初始化热插拔的引导CPU</span></span><br><span class="line"></span><br><span class="line">    build_all_zonelists(<span class="literal">NULL</span>);    <span class="comment">// 构建所有内存区域列表</span></span><br><span class="line">    page_alloc_init();    <span class="comment">// 初始化页面分配器</span></span><br><span class="line">	........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中跟设备树相关的函数为第20行的 setup_arch**(&amp;<strong>command_line</strong>);**该函数定义在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;setup.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">setup_arch</span><span class="params">(<span class="type">char</span> **cmdline_p)</span></span><br><span class="line">&#123;</span><br><span class="line">	init_mm.start_code = (<span class="type">unsigned</span> <span class="type">long</span>) _text;</span><br><span class="line">	init_mm.end_code   = (<span class="type">unsigned</span> <span class="type">long</span>) _etext;</span><br><span class="line">	init_mm.end_data   = (<span class="type">unsigned</span> <span class="type">long</span>) _edata;</span><br><span class="line">	init_mm.brk	   = (<span class="type">unsigned</span> <span class="type">long</span>) _end;</span><br><span class="line"></span><br><span class="line">	*cmdline_p = boot_command_line;</span><br><span class="line"></span><br><span class="line">	early_fixmap_init();    <span class="comment">// 初始化 early fixmap</span></span><br><span class="line">	early_ioremap_init();    <span class="comment">// 初始化 early ioremap</span></span><br><span class="line"></span><br><span class="line">	setup_machine_fdt(__fdt_pointer);    <span class="comment">// 设置机器的 FDT（平台设备树）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化静态密钥，早期可能会被 cpufeature 代码和早期参数启用</span></span><br><span class="line">	jump_label_init();</span><br><span class="line">	parse_early_param();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在启动可能的早期控制台后，解除屏蔽异步中断和 FIQ（一旦我们可以报告发生的系统错误）</span></span><br><span class="line">	local_daif_restore(DAIF_PROCCTX_NOIRQ);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在这个阶段，TTBR0仅用于身份映射。将其指向零页面，以避免做出猜测性的新条目获取。</span></span><br><span class="line">	cpu_uninstall_idmap();</span><br><span class="line"></span><br><span class="line">	xen_early_init();    <span class="comment">// Xen 平台的早期初始化</span></span><br><span class="line">	efi_init();    <span class="comment">// EFI 平台的初始化</span></span><br><span class="line">	arm64_memblock_init();    <span class="comment">// ARM64 内存块的初始化</span></span><br><span class="line"></span><br><span class="line">	paging_init();    <span class="comment">// 分页初始化</span></span><br><span class="line"></span><br><span class="line">	acpi_table_upgrade();    <span class="comment">// ACPI 表的升级</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析 ACPI 表以进行可能的引导时配置</span></span><br><span class="line">	acpi_boot_table_init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (acpi_disabled)</span><br><span class="line">		unflatten_device_tree();    <span class="comment">// 展开设备树</span></span><br><span class="line"></span><br><span class="line">	bootmem_init();    <span class="comment">// 引导内存的初始化</span></span><br><span class="line">	............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在setup_arch函数中与设备树相关的函数分别为第13行的setup_machine_fdt(__fdt_pointer)和第37行的unflatten_device_tree()，接下来将对上述两个函数进行详细的介绍。</p>
<h3 id="63-2-1-setup-machine-fdt-fdt-pointer"><a href="#63-2-1-setup-machine-fdt-fdt-pointer" class="headerlink" title="63.2.1 setup_machine_fdt(__fdt_pointer)"></a>63.2.1 setup_machine_fdt(__fdt_pointer)</h3><p>setup_machine_fdt(__fdt_pointer)中的__fdt_pointer是dtb二进制文件加载到内存的地址，该地址由bootloader启动kernel时透过x0寄存器传递过来的，具体的汇编代码在内核源码目录下的“&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;head.S”文件中，具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">preserve_boot_args:</span><br><span class="line">	mov	x21, x0				// x21=FDT</span><br><span class="line"></span><br><span class="line">__primary_switched:</span><br><span class="line">	str_l	x21, __fdt_pointer, x5		// Save FDT pointer</span><br></pre></td></tr></table></figure>

<p>第2行: 将寄存器 x0 的值复制到寄存器 x21。x0 寄存器中保存了一个指针，该指针指向设备树（Device Tree）。</p>
<p>第4行: 将寄存器 x21 的值存储到内存地址 __fdt_pointer 中。</p>
<p>然后来看setup_machine_fdt函数，该函数定义在内核源码的“&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;setup.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化设置机器的设备树</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">setup_machine_fdt</span><span class="params">(<span class="type">phys_addr_t</span> dt_phys)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 将设备树物理地址映射到内核虚拟地址空间</span></span><br><span class="line">    <span class="type">void</span> *dt_virt = fixmap_remap_fdt(dt_phys, &amp;size, PAGE_KERNEL);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果映射成功</span></span><br><span class="line">    <span class="keyword">if</span> (dt_virt) &#123;</span><br><span class="line">        <span class="comment">// 保留设备树占用的内存区域</span></span><br><span class="line">        memblock_reserve(dt_phys, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设备树映射失败或者设备树解析失败</span></span><br><span class="line">    <span class="keyword">if</span> (!dt_virt || !early_init_dt_scan(dt_virt)) &#123;</span><br><span class="line">        <span class="comment">// 输出错误信息</span></span><br><span class="line">		pr_crit(<span class="string">&quot;\n&quot;</span></span><br><span class="line">			<span class="string">&quot;Error: invalid device tree blob at physical address %pa (virtual address 0x%p)\n&quot;</span></span><br><span class="line">			<span class="string">&quot;The dtb must be 8-byte aligned and must not exceed 2 MB in size\n&quot;</span></span><br><span class="line">			<span class="string">&quot;\nPlease check your bootloader.&quot;</span>,</span><br><span class="line">			&amp;dt_phys, dt_virt);</span><br><span class="line">        <span class="comment">// 无限循环，等待系统崩溃</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            cpu_relax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 早期修复完成，将设备树映射为只读模式</span></span><br><span class="line">    fixmap_remap_fdt(dt_phys, &amp;size, PAGE_KERNEL_RO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取设备树的机器名</span></span><br><span class="line">    name = of_flat_dt_get_machine_name();</span><br><span class="line">    <span class="comment">// 如果设备树没有机器名，则返回</span></span><br><span class="line">    <span class="keyword">if</span> (!name)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	    pr_info(<span class="string">&quot;Machine model: %s\n&quot;</span>, name); <span class="comment">// 输出机器型号信息</span></span><br><span class="line">    dump_stack_set_arch_desc(<span class="string">&quot;%s (DT)&quot;</span>, name); <span class="comment">// 设置栈转储的架构描述为机器型号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数用于在内核启动过程中设置机器的设备树。在此函数中，将执行以下步骤： </p>
<p>1.使用 fixmap_remap_fdt() 将设备树映射到内核虚拟地址空间中的 fixmap 区域。 </p>
<p>2.如果映射成功，则使用 memblock_reserve() 保留设备树占用的物理内存区域。 </p>
<p>3.检查设备树的有效性和完整性，通过调用early_init_dt_scan()进行早期扫描。 如果设备树无效或扫描失败，则会输出错误信息并进入死循环。 </p>
<p>4.早期修复已完成，现在将设备树映射为只读，通过调用 fixmap_remap_fdt() 实现。</p>
<p>5.获取设备树中的机器模型名称，通过调用 of_flat_dt_get_machine_name()。</p>
<p>6.如果机器模型名称存在，则输出机器模型的信息，并通过 dump_stack_set_arch_desc() 设置堆栈描述信息。</p>
<p>其中上面的第3步调用的early_init_dt_scan() 需要详细的讲解一下，该函数定义在内核源码的“drivers&#x2F;of&#x2F;fdt.c”目录下，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __init <span class="title function_">early_init_dt_scan</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证设备树的兼容性和完整性</span></span><br><span class="line">    status = early_init_dt_verify(params);</span><br><span class="line">    <span class="keyword">if</span> (!status)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描设备树节点</span></span><br><span class="line">    early_init_dt_scan_nodes();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，调用 early_init_dt_verify() 函数对设备树进行兼容性和完整性验证。该函数可能会检查设备树中的一致性标记、版本信息以及必需的节点和属性是否存在。如果验证失败，函数会返回 false。该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __init <span class="title function_">early_init_dt_verify</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 验证传入的参数是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!params)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查设备树头部的有效性</span></span><br><span class="line">    <span class="comment">// 如果设备树头部无效，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (fdt_check_header(params))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置指向设备树的指针为传入的参数</span></span><br><span class="line">    initial_boot_params = params;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算设备树的 CRC32 校验值</span></span><br><span class="line">    <span class="comment">// 并将结果保存在全局变量 of_fdt_crc32 中</span></span><br><span class="line">    of_fdt_crc32 = crc32_be(~<span class="number">0</span>, initial_boot_params, fdt_totalsize(initial_boot_params));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 true，表示设备树验证和初始化成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第4行：该进行参数的有效性检查，如果 params 为空，则直接返回 false，表示参数无效。</p>
<p>第9行：检查设备树头部的有效性。fdt_check_header 是一个用于检查设备树头部的函数，如果设备树头部无效，则返回 false，表示设备树不合法。</p>
<p>第13行：如果设备树头部有效，程序继续执行，将传入的 params 赋值给全局变量 initial_boot_params，用来保存设备树的指针。</p>
<p>第17行，使用 crc32_be 函数计算设备树的 CRC32 校验值，其中 crc32_be 是一个用于计算 CRC32 校验值的函数，~0 表示初始值为全1的位模式。计算完成后，将结果保存在全局变量 of_fdt_crc32 中。</p>
<p>然后继续回到early_init_dt_scan() 函数中，如果设备树验证成功（即 status 为真），则调用 early_init_dt_scan_nodes() 函数。这个函数的作用是扫描设备树的节点并进行相应的处理，该函数的具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void __init early_init_dt_scan_nodes(void)</span><br><span class="line">&#123;</span><br><span class="line">	/* 从 /chosen 节点中检索各种信息 */</span><br><span class="line">	of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);</span><br><span class="line"></span><br><span class="line">	/* 初始化 &#123;size,address&#125;-cells 信息 */</span><br><span class="line">	of_scan_flat_dt(early_init_dt_scan_root, NULL);</span><br><span class="line"></span><br><span class="line">	/* 设置内存信息，调用 early_init_dt_add_memory_arch 函数 */</span><br><span class="line">	of_scan_flat_dt(early_init_dt_scan_memory, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数early_init_dt_scan_nodes被声明为__init，这表示它是在内核初始化阶段被调用，并且在初始化完成后不再需要。该函数的目的是在早期阶段扫描设备树节点，并执行一些初始化操作。</p>
<p>函数中主要调用了of_scan_flat_dt函数，该函数用于扫描平面设备树（flat device tree）。平面设备树是一种将设备树以紧凑形式表示的数据结构，它不使用树状结构，而是使用线性结构，以节省内存空间。</p>
<p>具体来看，early_init_dt_scan_nodes函数的执行步骤如下：</p>
<p>（1）of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line)：从设备树的&#x2F;chosen节点中检索各种信息。&#x2F;chosen节点通常包含了一些系统的全局配置参数，比如命令行参数。early_init_dt_scan_chosen是一个回调函数，用于处理&#x2F;chosen节点的信息。boot_command_line是一个参数，表示内核启动时的命令行参数。</p>
<p>（2）of_scan_flat_dt(early_init_dt_scan_root, NULL)：初始化{size,address}-cells信息。{size,address}-cells描述了设备节点中地址和大小的编码方式。early_init_dt_scan_root是一个回调函数，用于处理设备树的根节点。</p>
<p>（3）of_scan_flat_dt(early_init_dt_scan_memory, NULL)：设置内存信息，并调用early_init_dt_add_memory_arch函数。这个步骤主要用于在设备树中获取内存的相关信息，并将其传递给内核的内存管理模块。early_init_dt_scan_memory是一个回调函数，用于处理内存信息。</p>
<p>至此，关于setup_machine_fdt(__fdt_pointer)代码的分析就完成了。</p>
<h3 id="63-2-2-unflatten-device-tree"><a href="#63-2-2-unflatten-device-tree" class="headerlink" title="63.2.2 unflatten_device_tree"></a>63.2.2 unflatten_device_tree</h3><p>该函数用于解析设备树，将紧凑的设备树数据结构转换为树状结构的设备树，该函数定义在内核源码目录下的“&#x2F;drivers&#x2F;of&#x2F;fdt.c”文件中，具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">unflatten_device_tree</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 解析设备树 */</span></span><br><span class="line">    __unflatten_device_tree(initial_boot_params, <span class="literal">NULL</span>, &amp;of_root,</span><br><span class="line">                            early_init_dt_alloc_memory_arch, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取指向 &quot;/chosen&quot; 和 &quot;/aliases&quot; 节点的指针，以供全局使用 */</span></span><br><span class="line">    of_alias_scan(early_init_dt_alloc_memory_arch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 运行设备树的单元测试 */</span></span><br><span class="line">    unittest_unflatten_overlay_base();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数主要用于解析设备树，并将解析后的设备树存储在全局变量of_root中。</p>
<p>函数首先调用__unflatten_device_tree函数来执行设备树的解析操作。解析后的设备树将使用of_root指针进行存储。</p>
<p>接下来，函数调用of_alias_scan函数。这个函数用于扫描设备树中的&#x2F;chosen和&#x2F;aliases节点，并为它们分配内存。这样，其他部分的代码可以通过全局变量访问这些节点。</p>
<p>最后，函数调用unittest_unflatten_overlay_base函数，用于运行设备树的单元测试。</p>
<p>然后对__unflatten_device_tree这一设备树的解析函数进行详细的介绍，该函数的具体内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__unflatten_device_tree(<span class="type">const</span> <span class="type">void</span> *blob,</span><br><span class="line">		      <span class="keyword">struct</span> device_node *dad,</span><br><span class="line">			      <span class="keyword">struct</span> device_node **mynodes,</span><br><span class="line">			      <span class="type">void</span> *(*dt_alloc)(u64 size, u64 align),</span><br><span class="line">			      <span class="type">bool</span> detached)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	<span class="type">void</span> *mem;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot; -&gt; unflatten_device_tree()\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!blob) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;No device tree pointer\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;Unflattening device tree:\n&quot;</span>);</span><br><span class="line">	pr_debug(<span class="string">&quot;magic: %08x\n&quot;</span>, fdt_magic(blob));</span><br><span class="line">	pr_debug(<span class="string">&quot;size: %08x\n&quot;</span>, fdt_totalsize(blob));</span><br><span class="line">	pr_debug(<span class="string">&quot;version: %08x\n&quot;</span>, fdt_version(blob));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fdt_check_header(blob)) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;Invalid device tree blob header\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 第一遍扫描，计算大小 */</span></span><br><span class="line">	size = unflatten_dt_nodes(blob, <span class="literal">NULL</span>, dad, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (size &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	size = ALIGN(size, <span class="number">4</span>);</span><br><span class="line">	pr_debug(<span class="string">&quot;  大小为 %d，正在分配内存...\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 为展开的设备树分配内存 */</span></span><br><span class="line">	mem = dt_alloc(size + <span class="number">4</span>, <span class="keyword">alignof</span>(<span class="keyword">struct</span> device_node));</span><br><span class="line">	<span class="keyword">if</span> (!mem)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(mem, <span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line">	*(__be32 *)(mem + size) = cpu_to_be32(<span class="number">0xdeadbeef</span>);</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;  正在展开 %p...\n&quot;</span>, mem);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 第二遍扫描，实际展开设备树 */</span></span><br><span class="line">	unflatten_dt_nodes(blob, mem, dad, mynodes);</span><br><span class="line">	<span class="keyword">if</span> (be32_to_cpup(mem + size) != <span class="number">0xdeadbeef</span>)</span><br><span class="line">		pr_warning(<span class="string">&quot;End of tree marker overwritten: %08x\n&quot;</span>,</span><br><span class="line">			   be32_to_cpup(mem + size));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (detached &amp;&amp; mynodes) &#123;</span><br><span class="line">		of_node_set_flag(*mynodes, OF_DETACHED);</span><br><span class="line">		pr_debug(<span class="string">&quot;unflattened tree is detached\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot; &lt;- unflatten_device_tree()\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的重点在两次设备树的扫描上，第一遍扫描的目的是计算展开设备树所需的内存大小。</p>
<p>第29行：unflatten_dt_nodes函数的作用是递归地遍历设备树数据块，并计算展开设备树所需的内存大小。它接受四个参数：blob（设备树数据块指针）、start（当前节点的起始地址，初始为NULL）、dad（父节点指针）和mynodes（用于存储节点指针数组的指针，初始为NULL）。</p>
<p>第一遍扫描完成后，unflatten_dt_nodes函数会返回展开设备树所需的内存大小，然后在对大小进行对齐操作，并为展开的设备树分配内存。</p>
<p>第二遍扫描的目的是实际展开设备树，并填充设备节点的名称、类型和属性等信息。</p>
<p>第49行：再次调用了unflatten_dt_nodes函数进行第二遍扫描。通过这样的过程，第二遍扫描会将设备树数据块中的节点展开为真正的设备节点，并填充节点的名称、类型和属性等信息。这样就完成了设备树的展开过程。</p>
<p>最后我们来对unflatten_dt_nodes函数内容进行一下深究，unflatten_dt_nodes函数具体定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">unflatten_dt_nodes</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *blob,</span></span><br><span class="line"><span class="params">			      <span class="type">void</span> *mem,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> device_node *dad,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> device_node **nodepp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">root</span>;</span>  <span class="comment">// 根节点</span></span><br><span class="line">	<span class="type">int</span> offset = <span class="number">0</span>, depth = <span class="number">0</span>, initial_depth = <span class="number">0</span>;  <span class="comment">// 偏移量、深度和初始深度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_MAX_DEPTH	64  <span class="comment">// 最大深度</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nps</span>[<span class="title">FDT_MAX_DEPTH</span>];</span>  <span class="comment">// 设备节点数组</span></span><br><span class="line">	<span class="type">void</span> *base = mem;  <span class="comment">// 基地址，用于计算偏移量</span></span><br><span class="line">	<span class="type">bool</span> dryrun = !base;  <span class="comment">// 是否只是模拟运行，不实际处理</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nodepp)</span><br><span class="line">		*nodepp = <span class="literal">NULL</span>;  <span class="comment">// 如果指针不为空，将其置为空指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果 @dad 有效，则表示正在展开设备子树。</span></span><br><span class="line"><span class="comment">	 * 在第一层深度可能有多个节点。</span></span><br><span class="line"><span class="comment">	 * 将 @depth 设置为 1，以使 fdt_next_node() 正常工作。</span></span><br><span class="line"><span class="comment">	 * 当发现负的 @depth 时，该函数会立即退出。</span></span><br><span class="line"><span class="comment">	 * 否则，除第一个节点外的设备节点将无法成功展开。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dad)</span><br><span class="line">		depth = initial_depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	root = dad;  <span class="comment">// 根节点为 @dad</span></span><br><span class="line">	nps[depth] = dad;  <span class="comment">// 将根节点放入设备节点数组</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (offset = <span class="number">0</span>;</span><br><span class="line">	     offset &gt;= <span class="number">0</span> &amp;&amp; depth &gt;= initial_depth;</span><br><span class="line">	     offset = fdt_next_node(blob, offset, &amp;depth)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(depth &gt;= FDT_MAX_DEPTH))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果未启用 CONFIG_OF_KOBJ 并且节点不可用，则跳过该节点</span></span><br><span class="line">		<span class="keyword">if</span> (!IS_ENABLED(CONFIG_OF_KOBJ) &amp;&amp;</span><br><span class="line">		    !of_fdt_device_is_available(blob, offset))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 填充节点信息，并将子节点添加到设备节点数组</span></span><br><span class="line">		<span class="keyword">if</span> (!populate_node(blob, offset, &amp;mem, nps[depth],</span><br><span class="line">				   &amp;nps[depth+<span class="number">1</span>], dryrun))</span><br><span class="line">			<span class="keyword">return</span> mem - base;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!dryrun &amp;&amp; nodepp &amp;&amp; !*nodepp)</span><br><span class="line">			*nodepp = nps[depth+<span class="number">1</span>];  <span class="comment">// 将子节点指针赋值给 @nodepp</span></span><br><span class="line">		<span class="keyword">if</span> (!dryrun &amp;&amp; !root)</span><br><span class="line">			root = nps[depth+<span class="number">1</span>];  <span class="comment">// 如果根节点为空，则将子节点设置为根节点</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset &lt; <span class="number">0</span> &amp;&amp; offset != -FDT_ERR_NOTFOUND) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;Error %d processing FDT\n&quot;</span>, offset);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 反转子节点列表。一些驱动程序假设节点顺序与 .dts 文件中的节点顺序一致</span></span><br><span class="line">	<span class="keyword">if</span> (!dryrun)</span><br><span class="line">		reverse_nodes(root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mem - base;  <span class="comment">// 返回处理的字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unflatten_dt_nodes 函数的作用我们在上面已经讲解过了，这里重点介绍第31行的 fdt_next_node()函数和第41行的populate_node函数。</p>
<p>fdt_next_node() 函数用来遍历设备树的节点。从偏移量为 0 开始，只要偏移量大于等于 0 且深度大于等于初始深度，就执行循环。循环中的每次迭代都会处理一个设备树节点。</p>
<p>在每次迭代中，首先检查深度是否超过了最大深度 FDT_MAX_DEPTH，如果超过了，则跳过该节点。</p>
<p>如果未启用 CONFIG_OF_KOBJ 并且节点不可用（通过 of_fdt_device_is_available() 函数判断），则跳过该节点。</p>
<p>随后调用 populate_node() 函数填充节点信息，并将子节点添加到设备节点数组 nps 中。 populate_node() 函数定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">static bool populate_node(const void *blob,</span><br><span class="line">			  int offset,</span><br><span class="line">			  void **mem,</span><br><span class="line">			  struct device_node *dad,</span><br><span class="line">			  struct device_node **pnp,</span><br><span class="line">			  bool dryrun)</span><br><span class="line">&#123;</span><br><span class="line">	struct device_node *np;  // 设备节点指针</span><br><span class="line">	const char *pathp;  // 节点路径字符串指针</span><br><span class="line">	unsigned int l, allocl;  // 路径字符串长度和分配的内存大小</span><br><span class="line"></span><br><span class="line">	pathp = fdt_get_name(blob, offset, &amp;l);  // 获取节点路径和长度</span><br><span class="line">	if (!pathp) &#123;</span><br><span class="line">		*pnp = NULL;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	allocl = ++l;  // 分配内存大小为路径长度加一，用于存储节点路径字符串</span><br><span class="line"></span><br><span class="line">	np = unflatten_dt_alloc(mem, sizeof(struct device_node) + allocl,</span><br><span class="line">				__alignof__(struct device_node));  // 分配设备节点内存</span><br><span class="line">	if (!dryrun) &#123;</span><br><span class="line">		char *fn;</span><br><span class="line">		of_node_init(np);  // 初始化设备节点</span><br><span class="line">		np-&gt;full_name = fn = ((char *)np) + sizeof(*np);  // 设置设备节点的完整路径名</span><br><span class="line"></span><br><span class="line">		memcpy(fn, pathp, l);  // 将节点路径字符串复制到设备节点的完整路径名中</span><br><span class="line"></span><br><span class="line">		if (dad != NULL) &#123;</span><br><span class="line">			np-&gt;parent = dad;  // 设置设备节点的父节点</span><br><span class="line">			np-&gt;sibling = dad-&gt;child;  // 设置设备节点的兄弟节点</span><br><span class="line">			dad-&gt;child = np;  // 将设备节点添加为父节点的子节点</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	populate_properties(blob, offset, mem, np, pathp, dryrun);  // 填充设备节点的属性信息</span><br><span class="line">	if (!dryrun) &#123;</span><br><span class="line">		np-&gt;name = of_get_property(np, &quot;name&quot;, NULL);  // 获取设备节点的名称属性</span><br><span class="line">		np-&gt;type = of_get_property(np, &quot;device_type&quot;, NULL);  // 获取设备节点的设备类型属性</span><br><span class="line"></span><br><span class="line">		if (!np-&gt;name)</span><br><span class="line">			np-&gt;name = &quot;&lt;NULL&gt;&quot;;  // 如果设备节点没有名称属性，则设置为&quot;&lt;NULL&gt;&quot;</span><br><span class="line">		if (!np-&gt;type)</span><br><span class="line">			np-&gt;type = &quot;&lt;NULL&gt;&quot;;  // 如果设备节点没有设备类型属性，则设置为&quot;&lt;NULL&gt;&quot;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*pnp = np;  // 将设备节点指针赋值给*pnp</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在populate_node 函数中首先会调用第18行的 unflatten_dt_alloc 函数分配设备节点内存。分配的内存大小为 sizeof(struct device_node) + allocl 字节，并使用 <strong>alignof</strong>(struct device_node) 对齐。然后调用 populate_properties 函数填充设备节点的属性信息。该函数会解析设备节点的属性，并根据需要分配内存来存储属性值。</p>
<p>至此，关于dtb二进制文件的解析过程就讲解完成了，完整的源码分析流程图如下所示：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202309062024648.jpeg" alt="img"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2023/09/05/1-63-dtb%E5%B1%95%E5%BC%80%E6%88%90device-node%E5%AE%9E%E9%AA%8C/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rk3568-%E9%A9%B1%E5%8A%A8/" rel="tag">rk3568 驱动</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/09/05/1-64-device-node%E8%BD%AC%E6%8D%A2%E6%88%90platform-device%E5%AE%9E%E9%AA%8C/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            1-62-dtb文件格式讲解
          
        </div>
      </a>
    
    
      <a href="/2023/09/05/1-62-dtb%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%AE%B2%E8%A7%A3/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">1-62-dtb文件格式讲解</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="热爱学习的未来酱"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>