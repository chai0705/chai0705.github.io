<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="永远年轻，永远热泪盈眶" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>0-0-15 显示硬件发展与视频开发知识点扫盲 |  热爱学习的未来酱</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="热爱学习的未来酱" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-0-0-15 显示硬件发展与视频开发知识点扫盲"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  0-0-15 显示硬件发展与视频开发知识点扫盲
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/19/0-0-15%20%E6%98%BE%E7%A4%BA%E7%A1%AC%E4%BB%B6%E5%8F%91%E5%B1%95%E4%B8%8E%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%89%AB%E7%9B%B2/" class="article-date">
  <time datetime="2023-11-19T13:16:56.000Z" itemprop="datePublished">2023-11-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%91%9E%E8%8A%AF%E5%BE%AE/">瑞芯微</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">57.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">211 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p> 电脑上炫酷的展示，生动的形象，离不开硬件的支持，硬件是音视频编程文化的一部分。开发者有必要对相关硬件大概了解。本专题涉及视频硬件相关话题，音频相关以后讲述。</p>
<p>​    视频编程的本质是图形图像编程，本专题以时间为主线，以公司硬件发展为点位，以图像图像开发接口为切面，宏观进行介绍，希望对视频编程开发者进行有益的启示。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192138685.png" alt="img"></p>
<p>​    本系列文章依发展顺序，从早期起源开始，再到2D时代，3D时代，移动时代，智能时代，最后到显示标准与专业视频处理单元，大体分为6部分。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192138724.png" alt="img"></p>
<p>​    早期概述回顾286之前的电脑，以及一些图形图像工作站。那个年代图形图像编程起源于欧美发达国家。毫不夸张的说，欧美打开了计算机世界的大门，后面简单描述了VGA早期图形编程。</p>
<p>​    2D时代回顾了当年硬件产品、2D编程接口。GDI、GDI+、D2D、AGG、Cairo、Cocoa Drawing等。2D时代的到来，迈出了图形图像编程的第一步，拉开了多媒体编程的序幕。</p>
<p>​    3D时代是计算机图形学大发展的年代，3D引擎的出现，为图形学的发展注入了活力。可以说，3D时代的降临，音视频技术的春天到来了。</p>
<p>​    移动时代是图形图像技术在嵌入式设备上拓展的年代，多媒体引擎也发生了一些变化。多媒体功能是手机最重要的功能之一，未来音视频技术在手机上将会有大的发展。</p>
<p>​    人工智能的发展，智能时代到来了，音视频方面是人工智能应用最广泛的分支。音视频技术是人工智能最重要的方向，未来，人工智能技术是音视频技术最核心的技术之一。</p>
<p>​    技术的发展没有穷尽，硬件技术的进步，显示标准和工业化硬件的出现。给技术的发发展指明了方向。</p>
<h1 id="1、早期概述"><a href="#1、早期概述" class="headerlink" title="1、早期概述"></a>1、早期概述</h1><p>​    早期图形图像处理主要靠一些工作站来完成。286之前的电脑仅进行基本的双色文本显示。显示主要靠显示器和主板显示原器件做支持。下图是1973年的Alto和1980年的Perq图形工作站，其中Alto是地球上第一台图形工作站。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192138787.png" alt="img"></p>
<p>​    286之前，国内谈不上电脑的视频编程。专业的音视频处理主要靠图形图像工作站完成，设备全靠进口，图形图像软件的开发是国外专业芯片公司、计算机设备公司开发，当年的视频编程没有走向民间。后来，在消费级领域，一些图形加速卡出现，为图形图像编程做了前期的准备。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192138694.png" alt="img"></p>
<p>​    286之前的图形图像工作站编程，历史已经久远，本专题不做阐述。</p>
<p>​    技术的发展推动了显示标准的改变，从MDA—CGA—EGA—VGA。显示标准对硬件厂商做了规格的约束，指引着显示技术的方向，影响着图形图像技术的发展，对视频研发产生影响，推动末端技术应用。</p>
<p>​    历史的烽烟过去，年代已经久远，广袤的互联网上，很难找到工作站编程的资料。</p>
<h1 id="2、VGA编程"><a href="#2、VGA编程" class="headerlink" title="2、VGA编程"></a>2、VGA编程</h1><p>​    VGA的出现，显卡作为独立功能部件，从主板上剥离。这个改变，图形图像编程的曙光出现了，当年的图形图像编程还必须依靠厂家提供的视频驱动。视频驱动的完备程度，很大程度决定了硬件厂商的生存。</p>
<p>​    下面的代码，老一代程序员应该对此并不陌生。也就是这样的代码，拉开了图形编程的序幕，迈出了视频编程的第一步。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//调用VGA驱动程序</span><br><span class="line">int  gdriver=DETECT， gmode;</span><br><span class="line">initgraph ( &amp;gdriver， &amp;gmode， “c:\\tc\\bgi”);</span><br><span class="line">setbkcolor ( BLACK);                 //设定背景颜色为黑色</span><br><span class="line">setcolor ( WHITE);                   //设定画线的颜色为白色</span><br><span class="line">setlinestyle (0， 4444， 4);          //设置当前线型 实线  线图样  线宽四个像素</span><br><span class="line">line ( x1， y1， x2，y2);            //画线  x1 y1起点  x2y2终点</span><br><span class="line">lineto( x， y);                      //当前位置到xy坐标画直线</span><br></pre></td></tr></table></figure>

<p>​    计算机发展过程中，显示部件在设计上发生着变化，下图是从70年代到今天显卡发展过程图。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192138742.png" alt="img"></p>
<p>​    自从计算的出现，相比其它领域，计算机领域发展更快，对社会影响更远，厂商竞争更为激烈。下面从公司、产品、技术的角度探讨。</p>
<ol start="2">
<li>2d时代</li>
</ol>
<h1 id="3、2D时代"><a href="#3、2D时代" class="headerlink" title="3、2D时代"></a>3、2D时代</h1><p>​    几十年工艺改进，解决了基本制造问题，计算机开始向应用过渡。显示问题是首当其冲的问题，多年的思辨与实践，2D技术横空出世，完善发展，为计算机的应用推广做出了卓越的贡献。双色显示的星星之火，在2D时代终于熊熊燃烧，计算机走向民间的时代到来了。</p>
<p>​    下面从公司产品的角度，回顾2D时代的图形图像编程。</p>
<h2 id="3-1、公司"><a href="#3-1、公司" class="headerlink" title="3.1、公司"></a>3.1、公司</h2><h3 id="3-1-1、Amiga"><a href="#3-1-1、Amiga" class="headerlink" title="3.1.1、Amiga"></a>3.1.1、Amiga</h3><p>​    Amiga是80年代图形性能最强大的电脑之一，拥有专门处理图形的芯片。杰.迈纳是当年显卡芯片设计的灵魂人物。下图Amiga500拆机，红圈内的denise芯片就是专门用来负责处理图形的，denise是真正意义上的2d加速卡。</p>
<p>​    这家公司在音视频多媒体领域超越当年的IBM与Apple，遗憾的是，最好的技术也被市场所淘汰。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139556.png" alt="img"></p>
<h3 id="3-1-2、IBM"><a href="#3-1-2、IBM" class="headerlink" title="3.1.2、IBM"></a>3.1.2、IBM</h3><p>​    1981年， IBM推出个人电脑，提供了两种显卡，一种是“单色显卡”(简称 MDA)， 一种是 “彩色绘图卡” (简称 CGA)。</p>
<p>​    1982年，IBM又推出了MGA（Monochrome Graphic Adapter）， 又称Hercules Card (大力士卡)， 除了显示图形外，还保留了原来MDA的功能，IBM是世界第一块显卡制造商。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139564.png" alt="img"></p>
<h3 id="3-1-3、S3"><a href="#3-1-3、S3" class="headerlink" title="3.1.3、S3"></a>3.1.3、S3</h3><p>​    S3在1989年开始造显卡，2D画质领域无人能及，盛极一时的Trident也无奈败下阵来。S3最经典的产品当属Trio64V+，有着高速的2D性能和强大的VCD软解实力，支持1024×768的分辨率，在低分辨率下支持最高32Bit真彩色。</p>
<p>​    那是一个VCD满天飞的年代，显卡的VCD解压能力是视频底层技术的一个突破。S3几经被转卖，先被威盛收编，后被HTC揽入囊中。今天，HTC步履蹒跚，生死一线。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139538.png" alt="img"></p>
<h3 id="3-1-4、Trident"><a href="#3-1-4、Trident" class="headerlink" title="3.1.4、Trident"></a>3.1.4、Trident</h3><p>​    Trident，这家公司当年在2D显卡领域红极一时，在当年的产品专柜里，多次看到其身影，后期由于技术方向原因，在3D显卡年代被淘汰。最终在2003年被XGI收购。而XGI最终在后来被ATI纳入麾下。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139600.png" alt="img"></p>
<h3 id="3-1-5、Matrox（迈创）"><a href="#3-1-5、Matrox（迈创）" class="headerlink" title="3.1.5、Matrox（迈创）"></a>3.1.5、Matrox（迈创）</h3><p>​    曾经独显领域的主要玩家，2D显卡时代声名显赫，3D时代落寞，最终转向小众视频市场。如今说起显卡GPU，很多人脑海里只会浮现NVIDIA、AMD两个名字，在上个世纪末，Matrox(迈创)的名字如雷贯耳。它的资格比NVIDIA、AMD要老得多。迈创来自加拿大(ATI也是)，Matrox成立于1976年，比ATI早9年，比NVIDIA早17年。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139577.png" alt="img"></p>
<h2 id="3-2、图形技术"><a href="#3-2、图形技术" class="headerlink" title="3.2、图形技术"></a>3.2、图形技术</h2><p>​    1976年~1995年是沉闷寂寥的2D时代，显示技术发展缓慢，，图形图像编程近乎停滞。市场期待着集成电路的发展、微电子技术的爆发。</p>
<p>​    1995年之后，硬件技术的春天到来了，3D显卡涌现，性能和技术有很大提升，鸟语花香，百家争鸣。厂商不断推陈出新才能生存，跟不上节奏的企业，逃不了被收购的命运。缅怀过去，继往开来，2D技术多年的发展为3D技术做了20年的铺垫。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139542.png" alt="img"></p>
<p>​    结合过去历史，回顾当年2D编程的技术。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139738.png" alt="img"></p>
<h3 id="3-2-1、GDI编程"><a href="#3-2-1、GDI编程" class="headerlink" title="3.2.1、GDI编程"></a>3.2.1、GDI编程</h3><p>​    当时图形图像编程多使用GDI技术。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139839.png" alt="img"></p>
<p>​    代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CDC *pDC = GetDC();</span><br><span class="line">pDC-&gt;SelectObject(&amp;…);</span><br><span class="line">ReleaseDC(pDC);</span><br></pre></td></tr></table></figure>

<p>​    GDI编程的出现，代表了消费级图像编程的兴起。</p>
<h3 id="3-2-2、GDI-编程"><a href="#3-2-2、GDI-编程" class="headerlink" title="3.2.2、GDI+编程"></a>3.2.2、GDI+编程</h3><p>​    GDI+是GDI的增强版，想当年，Windows平台的上的图形图像技术，走在各个平台的前端。</p>
<p>​    GDI编程为OpenGL和DirectX做了铺垫。</p>
<p>​    代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">HINSTANCE hInst = AfxGetResourceHandle();</span><br><span class="line">HRSRC hRsrc = ::FindResource (hInst，MAKEINTRESOURCE(nID)，sTR); // type</span><br><span class="line"></span><br><span class="line">if (!hRsrc)</span><br><span class="line">return FALSE;</span><br><span class="line"></span><br><span class="line">// load resource into memory</span><br><span class="line"></span><br><span class="line">DWORD len = SizeofResource(hInst， hRsrc);</span><br><span class="line">BYTE* lpRsrc = (BYTE*)LoadResource(hInst， hRsrc);</span><br><span class="line">if (!lpRsrc)</span><br><span class="line">return FALSE;</span><br><span class="line"></span><br><span class="line">// Allocate global memory on which to create stream</span><br><span class="line">HGLOBAL m_hMem = GlobalAlloc(GMEM_FIXED， len);</span><br><span class="line">BYTE* pmem = (BYTE*)GlobalLock(m_hMem);</span><br><span class="line">memcpy(pmem，lpRsrc，len);</span><br><span class="line">IStream* pstm;</span><br><span class="line">CreateStreamOnHGlobal(m_hMem，FALSE，&amp;pstm);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// load from stream</span><br><span class="line">pImg=Gdiplus::Image::FromStream(pstm);</span><br><span class="line"></span><br><span class="line">// free/release stuff</span><br><span class="line">GlobalUnlock(m_hMem);</span><br><span class="line">pstm-&gt;Release();</span><br><span class="line">FreeResource(lpRsrc);</span><br></pre></td></tr></table></figure>

<p>​    无论GDI还是GDI+技术，都代表着图形图像编程的年代到来了。</p>
<h3 id="3-2-3、Direct-2D"><a href="#3-2-3、Direct-2D" class="headerlink" title="3.2.3、Direct 2D"></a>3.2.3、Direct 2D</h3><p>​    Direct2D的出现代表着引擎技术的到来，体现了市场对图形图像、音视频技术的强烈需求，在引擎的背后，封装了图形图像技术的专业性与复杂性。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139869.png" alt="img"></p>
<p>​    代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt; </span><br><span class="line">#include &lt;d2d1.h&gt; </span><br><span class="line">#include &lt;d2d1helper.h&gt; </span><br><span class="line">#include &lt;dwrite.h&gt; </span><br><span class="line">#pragma comment(lib,&quot;dwrite.lib&quot;) </span><br><span class="line">#pragma comment(libd&quot;d2d1.lib&quot;) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static HINSTANCE g_hinst; </span><br><span class="line">static HWND g_hwnd;</span><br><span class="line">static bool g_flag_app_exit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static ID2D1Factory * g_factory; </span><br><span class="line">static ID2D1HwndRenderTarget * g_render_target; </span><br><span class="line"></span><br><span class="line">g_render_target-&gt;Resize(D2D1::SizeU(LOWORD(lparam)，HIWORD(lparam))); </span><br><span class="line">D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED， &amp;g_factory); </span><br><span class="line"></span><br><span class="line">RECT rc; </span><br><span class="line">GetClientRect(g_hwnd， &amp;rc); </span><br><span class="line"></span><br><span class="line">g_factory-&gt;CreateHwndRenderTarget(</span><br><span class="line">        D2D1::RenderTargetProperties()， </span><br><span class="line">        D2D1::HwndRenderTargetProperties(g_hwnd，</span><br><span class="line">D2D1::SizeU(rc。right - rc。left， rc。bottom - rc。top)    )， </span><br><span class="line">        &amp;g_render_target); </span><br><span class="line"></span><br><span class="line">g_render_target-&gt;BeginDraw(); </span><br><span class="line">g_render_target-&gt;Clear(D2D1::ColorF(0。63， 0。84， 0。00));  </span><br><span class="line">g_render_target-&gt;EndDraw(); </span><br><span class="line">g_render_target-&gt;Release(); </span><br><span class="line">g_factory-&gt;Release(); </span><br></pre></td></tr></table></figure>

<h3 id="3-2-4、AGG"><a href="#3-2-4、AGG" class="headerlink" title="3.2.4、AGG"></a>3.2.4、AGG</h3><p>​    AGG，全名：Anti-Grain Geometry，一个开源的、高效2D图形库。AGG的功能与GDI+的功能类似，提供了比GDI+更灵活的编程接口，产生的图形的质量非常高，跨平台的2D图形引擎，可在Windows、Wince、Linux等平台上运行。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139845.png" alt="img"></p>
<p>​    设计上，师出Boost库，使用了大量的C++语法规则，包括模板、仿函数等处理。为了能在更多平台上使用，并没有直接使用Boost和STL库，自己实现了部分STL功能。”</p>
<h3 id="3-2-5、Cairo"><a href="#3-2-5、Cairo" class="headerlink" title="3.2.5、Cairo"></a>3.2.5、Cairo</h3><p>​    cairo 是一个免费的矢量绘图软件库，可以绘制多种输出格式。cairo支持许多平台，包括 Linux、BSD、Windows等。Linux 绘图可以通过 X Window 系统、Quartz、图像缓冲格式或 OpenGL 上下文来实现。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139859.png" alt="img"></p>
<p>​    cairo 的主要设计目标是提供尽可能接近的输出。这种一致的输出使 cairo 非常适合 GUI 工具集编程和跨平台应用程序开发。使用同一个绘图库打印高分辨率的屏幕和绘制屏幕内容，这种功能具有显著的优点。</p>
<p>​    在支持的目标平台上，cairo 尝试智能化地使用底层硬件和软件支持。高质量矢量图形和高性能的结合使cairo成为优秀的绘图系统。</p>
<p>​    cairo 用C编写的，为大多数常用的语言提供了绑定。选用C语言有助于创建新的绑定，在进行C语言调用时提供高性能。和Python绑定，支持快速原型开发，降低了学习 cairo绘图API的门槛。</p>
<p>​    代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cairo.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc， <span class="type">char</span> *argv[])</span> </span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">cairo_surface_t</span> *surface; </span><br><span class="line">    <span class="type">cairo_t</span> *cr; </span><br><span class="line">    <span class="type">int</span> width = <span class="number">640</span>; </span><br><span class="line">    <span class="type">int</span> height = <span class="number">480</span>; </span><br><span class="line">    surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32， width， height); </span><br><span class="line">    cr = cairo_create (surface); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Drawing code goes here */</span> </span><br><span class="line">    cairo_set_line_width (cr， <span class="number">10</span>); </span><br><span class="line">    cairo_set_source_rgb (cr， <span class="number">0</span>， <span class="number">0</span>， <span class="number">0</span>); </span><br><span class="line">    cairo_rectangle (cr， width/<span class="number">4</span>， height/<span class="number">4</span>， width/<span class="number">2</span>， height/<span class="number">2</span>); </span><br><span class="line">    cairo_stroke (cr); </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Write output and clean up */</span> </span><br><span class="line">   cairo_surface_write_to_png (surface， <span class="string">&quot;rectangle。png&quot;</span>); </span><br><span class="line">   cairo_destroy (cr); </span><br><span class="line">   cairo_surface_destroy (surface); </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-6、Cocoa-Drawing"><a href="#3-2-6、Cocoa-Drawing" class="headerlink" title="3.2.6、Cocoa Drawing"></a>3.2.6、Cocoa Drawing</h3><p>​    Cocoa Drawing是苹果公司的2D图形图像开发类库，在XCode下运用，旨在推广苹果公司的技术。纵然苹果一直有着很强的图形图像处理能力，但仅局限于苹果公司本身的软件，苹果在早期一直没有很好的图形图像编程引擎。</p>
<p>​    近些年苹果的Metal技术，才可以算作苹果公司真正的技术创举。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139889.png" alt="img"></p>
<p>​    代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[NSGraphicsContext saveGraphicsState];</span><br><span class="line"></span><br><span class="line">// Create the path and add the shapes</span><br><span class="line">NSBezierPath* clipPath = [NSBezierPath bezierPath];</span><br><span class="line">[clipPath appendBezierPathWithRect:NSMakeRect(0.0，0.0，100.0，100.0)];</span><br><span class="line">[clipPath appendBezierPathWithOvalInRect:NSMakeRect(50.0，50.0，100.0，100.0)];</span><br><span class="line"></span><br><span class="line">// Add the path to the clip shape。</span><br><span class="line">[clipPath addClip];</span><br><span class="line"></span><br><span class="line">// Draw the image。</span><br><span class="line">[NSGraphicsContext restoreGraphicsState];</span><br></pre></td></tr></table></figure>

<h2 id="3-3、总结"><a href="#3-3、总结" class="headerlink" title="3.3、总结"></a>3.3、总结</h2><p>​    计算机功能的强大，代表本身的强大，本身的强大代表体系的复杂，模块的组合，视频技术也不例外，从宏观角度来看，图形图像编程框架如下图。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139912.png" alt="img"></p>
<p>​    软硬件技术是紧密结合的，硬件技术的进步推动了软件编程的繁荣，软件技术的应用促进了硬件的推广。早期的硬件公司驱动设计、专业级的编程接口研发，到后期消费级市场软件技术的繁荣。图形图像编程形成独立的软件阵地，呼唤着3D时代的到来。</p>
<h1 id="4、3D时代"><a href="#4、3D时代" class="headerlink" title="4、3D时代"></a>4、3D时代</h1><p>​    历史长河中，科技进步是人类文明的主要推动力。沧海桑田，天下多变，人类对科技的研究与探索从未停止，计算显示技术也不例外。</p>
<p>​    现实是3D的，显示硬件注定也是3D的。透过历史的云烟，得到岁月的启示，硬件对3D技术的支持是显卡厂商存活的根本。硬件对图形图像引擎的支持，是显示芯片公司做大做强的基础。引擎支持主要包括OpenGL和D3D引擎支持，在2000年前尤为明显。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139634.png" alt="img"></p>
<p>​    科技的风风雨雨，面临着技术的抉择和选型，无论辉煌黯淡，时光默然前行，那些远行的技术，做了科学的辩证。</p>
<h2 id="4-1、公司"><a href="#4-1、公司" class="headerlink" title="4.1、公司"></a>4.1、公司</h2><h3 id="4-1-1、3Dfx"><a href="#4-1-1、3Dfx" class="headerlink" title="4.1.1、3Dfx"></a>4.1.1、3Dfx</h3><p>​    1994年，3Dfx成立，在当时是一家小公司，定位明确，很快就推出了业界的第一块真正意义的3D图形加速卡：Voodoo。在当年，Voodoo在速度以及色彩方面的表现让喜欢游戏的用户为之疯狂，Voodoo几乎是玩家们唯一的选择，当年3Dfx的专用Glide引擎接口统治了整个3D世界。当年一个专业图形引擎，可拯救一系列产品，成就一家硬件厂商。</p>
<p>​    Glide引擎提供了专业的3D图形显示接口，Glide可以说是一套3D接口库，3Dfx凭借硬件与引擎的结合创造了发展历史上的奇迹。3Dfx的成功就是在3D硬件支持和相关引擎支持良好的表现。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139557.png" alt="img"></p>
<p>​    3Dfx从硬件上实现了Z缓存和双缓存，可进行光栅化之类的操作，实现了DirectX 6的特征集。CPU从繁重的像素填充任务中解脱出来。当然，当年的技术不成熟，顶点变换必须在CPU中完成，光栅化之后的像素操作也很有限。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139575.png" alt="img"></p>
<h3 id="4-1-2、ATI"><a href="#4-1-2、ATI" class="headerlink" title="4.1.2、ATI"></a>4.1.2、ATI</h3><p>​    说起显卡，我们不能不提ATI，由于对3D技术支持较好以及紧跟OpenGL和DirectX步伐。多年和英伟达齐名。后来由于显卡驱动问题，造就了A卡追击N卡的局面。ATI提供了良好的编程接口，成为推广的一个重要因素。</p>
<p>​    ATI的欻创始人何国源先生，广东新会人，在很多年间都是芯片界的顶级人物。AMD在2006年以54亿美元收购ATI，何国源从此退出显卡芯片行业。今天世界上很多电脑的显卡都有ATI的技术。下面是显卡领域的两个风云人物，何先生已金盆洗手，退出江湖，黄药师依然皮衣挂帅，征战一线。</p>
<p>​    市场风云变幻，毫无疑问，ATI是幸运的，当年潜图问鼎，雄霸天下。直至后来被高价收购，多年后的今天，A卡依然笑傲江湖。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139678.png" alt="img"></p>
<h3 id="4-1-3、NVIDIA"><a href="#4-1-3、NVIDIA" class="headerlink" title="4.1.3、NVIDIA"></a>4.1.3、NVIDIA</h3><p>​    提起显卡，必须提及另外一个厂家NViDia，英伟达的创始人黄仁勋先生，台湾台北人，江湖人称黄药师（老黄）。近20年以来，世界顶级芯片巨头。在图形处理芯片上，何国源和黄仁勋都做出了不可磨灭的贡献，图形处理芯片的前身，就是今天的GPU，GPU是英伟达推出的。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139618.png" alt="img"></p>
<p>​    NVIDIA 通过NV系列产品小试牛刀，通过GeForce 系列产品出征江湖，屡战屡胜，战功显赫，今天稳坐显示领域第一把交椅，无人出其左右。在人工智能数据分析方面，英伟达依然战功显赫。</p>
<p>​    想当年，显示领域是英伟达和ATI的天下，两者相互竞争，推动了显示技术的发展。成就了今天的显示规范。当年的竞争本质是显示指令、Shader编程、效率的竞争。</p>
<p>​    英伟达的NV3开始支持OpenGL，取得了巨大的成功。后期开始支持Direct3D。也就是前期对这些框架支持不足，导致经营举步维艰。</p>
<p>​    1999年8月，NVIDIA公司发布了一款代号为NV10的图形芯片Geforce 256。Geforce 256是图形芯片领域开天辟地的产品，因为它是第一款提出GPU概念的产品。</p>
<p>​    Geforce 256所采用的核心技术有“T&amp;L”硬件、立方环境材质贴图和顶点混合、纹理压缩和凹凸映射贴图、双重纹理四像素、256位渲染引擎等。“T&amp;L”硬件的出现，让显示芯片具备了以前只有高端工作站才有的顶点变换能力，同时期的OpenGL和DirectX 7都提供了硬件顶点变换的编程接口。1999年，GPU的概念就这样出现了。</p>
<p>​    GPU的推出，不仅仅是硬件体系的革命性变化，更是对显示标准的强大支持。今天3D引擎编程，核心主要也是面向GPU的编程。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139564.png" alt="img"></p>
<p>​    后期ATI被AMD收购，纵然没有英伟达耀眼，但整体发展还算顺利，形成了A卡和N卡竞争的格局。</p>
<p>​    2020年，英伟达收购ARM，市值超过3300亿美元，超过INTEL 1000亿美元，成为全球市值排名TOP10。在西方的土地上，一个黄种人，一个台湾人，战功显赫。</p>
<h3 id="4-1-4、3DLabs"><a href="#4-1-4、3DLabs" class="headerlink" title="4.1.4、3DLabs"></a>4.1.4、3DLabs</h3><p>​    3D技术飞速发展，专业显卡需求增大。专业公司应运而生。3DLabs就是这样的公司，开发高端绘图芯片，对OpenGL的完美支持，性能强大，当时的OpenGL普通显卡难以完全支持。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139756.png" alt="img"></p>
<p>​    当年在专业显卡市场，3DLabs的产品几乎是唯一选择。面对瞬息万变的世界，3DLabs还是落后了，对D3D技术重视不足和对OpenGL过度依赖，最终被黄药师的Quadro干掉。于2002年被创新科技收购，成为旗下子公司。</p>
<p>​    对D3D的支持程度不仅仅影响民间显卡，对专业显卡也有很大的影响。显卡的发展不仅仅要考虑OpenGL，更要考虑D3D。D3D是微软的，操作系统是微软的，Windows垄断操作系统的存在，对D3D是一个强大的支持。公司决定软件，软件决定硬件又一次得到体现。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139865.png" alt="img"></p>
<h3 id="4-1-5、Video-Logic"><a href="#4-1-5、Video-Logic" class="headerlink" title="4.1.5、Video Logic"></a>4.1.5、Video Logic</h3><p>​    Video Logic前期主打产品是PowerVR，当年PowerVR也涉足桌面显卡市场，比较有名的就是PCX2芯片，性能强大，支持D3D、OpenGL，然而驱动程序兼容性较差，游戏运行有问题，对CPU要求较高，影响了销售。即使如此，在很长时间内，市场占有率一直保持第二。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139862.png" alt="img"></p>
<p>​    对图形图像引擎的支持、驱动的友好程度决定了硬件的发展。后期由于优化不好，兼容性问题、软件冲突等，容易引起渲染错误或性能下降。离不开最终被转卖的命运。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139912.png" alt="img"></p>
<p>​    相比太多厂商，PowerVR是幸运的，桌面市场失败了，但PowerVR睿智的转向了移动图形市场，避免了桌面市场的残酷竞争，发挥了自己的技术优势，移动端成为未来的趋势，PowerVR成为移动显示领域的重要力量。</p>
<p>​    PC端计算机图形学发展的同时，移动端技术的兴起，移动端细分专业显示芯片的出现，进而发展成为独立的领域，计算机图形学向精细化发展。</p>
<h3 id="4-1-6、intel"><a href="#4-1-6、intel" class="headerlink" title="4.1.6、intel"></a>4.1.6、intel</h3><p>​    英特尔是美国一家以研制CPU为主的公司，是全球最大的个人计算机零件和CPU制造商，成立于1968年，具有52年产品创新和市场领导的历史。</p>
<p>​    1971年，英特尔推出了全球第一个微处理器。微处理器所带来的计算机和互联网革命，改变了整个世界。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139935.png" alt="img"></p>
<p>​    2016年4月，英特尔推出处理器至强7290F采用了多达72个处理器核心，成为英特尔核心数最多的处理器。2019年2月，英特尔推出至强铂金9282，它有112个线程，是线程最多的处理器。</p>
<p>​    2020年7月，福布斯2020全球品牌价值100强发布，英特尔排名第12位。9月3日，英特尔推出了新的极简主义 Logo。</p>
<p>​    谈到显卡，不能回避intel，由于特殊的地位，相比其它厂商，在显卡的道路上，走的相对平稳与踏实。i740就是Intel推出的第一款产品，极大的推动了AGP标准的发展。</p>
<p>​    intel专注于集成显卡领域，从i740之后，再也没有推出过独立显卡，i740成了Intel独立显卡的绝唱。纵然在显卡领域没有大的建树，但intel一直在坚守。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139916.png" alt="img"></p>
<h3 id="4-1-7、AMD"><a href="#4-1-7、AMD" class="headerlink" title="4.1.7、AMD"></a>4.1.7、AMD</h3><p>​    AMD显卡即ATI(被AMD收购)显卡，俗称A卡。搭载AMD公司的显示芯片。与NVIDIA齐名，同为世界两大显示芯片厂商之一。由于收购关系，在本专题中，不做过多讲述。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139966.png" alt="img"></p>
<p>​    AMD是目前业内唯一一个可以提供高性能CPU、高性能独立显卡、主板芯片组三大组件的半导体公司，为明确其优势，提出3A平台新标志，在笔记本领域有“AMD VISION”标志的就表示该电脑采用3A构建方案。</p>
<p>​    今天显卡市场，是A卡与N卡的天下，19年第四季度，AMD出货量环比大增22.6%，份额19%，NVIDIA减少1.9%，份额18%，Intel微增0.2%，份额63%。由于计算将Intel核显、APU算在内，NVIDIA并无优势。</p>
<p>​    在独显方面，AMD出货量占比27%，较上季度的24%和去年的26%均有增加，但NVIDIA仍旧以73%垄断剩余市场。今年，Intel Xe架构独显将面世，对独显格局有一定冲击。</p>
<p>​    AMD显卡与NVIDIA显卡相比，有更高的功耗与更高的性能。AMD显卡的子品牌有 ATI 和 Radeon，显卡型号众多。今天，AMD(ATI)显卡技术坚挺，依然耀眼。</p>
<h2 id="4-2、软件与硬件"><a href="#4-2、软件与硬件" class="headerlink" title="4.2、软件与硬件"></a>4.2、软件与硬件</h2><h3 id="4-2-1、接口与硬件"><a href="#4-2-1、接口与硬件" class="headerlink" title="4.2.1、接口与硬件"></a>4.2.1、接口与硬件</h3><p>​    专业图形图像领域，Z缓存和双缓存称为了3D图形技术的标配。在今天的流行图形图像API里，当年的Z缓冲和双缓冲，仅仅是今天图形图像引擎的一个参数或者一个函数而已，参数和函数的背后，是硬件的支持。</p>
<p>​    显卡插口有PCI和AGP两种。在数据处理上，逐渐支持高速和并行。具有着更大的传输速率，更复杂数据的处理能力。硬件技术的变革推动了软件技术的进步。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139076.png" alt="img"></p>
<p>​    任何技术的发展都不是一帆风顺的，显示技术也不例外。每一次技术的革新，都可能带来革命性的变化。那些曾经被淘汰、被边缘化的技术，为主流技术的发展做了助攻。在显卡技术发展过程中，硬件的升级，架构的改变，都代表着功能的提升。</p>
<p>​    下图从另外一个角度，展现显卡发展的过程。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139165.png" alt="img"></p>
<h3 id="4-2-2、3D引擎"><a href="#4-2-2、3D引擎" class="headerlink" title="4.2.2、3D引擎"></a>4.2.2、3D引擎</h3><p>​    遥想当年，视频编程主要靠专业引擎来体现，各家公司雄心勃勃，开宗立派，在数家公司的专业图形图像接口里，OpenGL和DirectX最终胜出。今天，消费级市场主要通过OpenGL和DirectX来体现。</p>
<p>​    可悲的是，早期在linux上很少有图形图像编程的处理。一直到今天，图形图像工作主要还是在Windows和Mac上进行。</p>
<p>​    时光的河流，流淌着一个真理，对3D的支持，以及对3D相关图形系统的支持，是硬件厂商存活的根本。这里的3D支持，就是3D引擎。</p>
<p>​    当年的图形图像编程，OpenGL刚刚起步，很多公司提供的应用引擎都是对OpenGL和D3D的封装。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139192.png" alt="img"></p>
<h4 id="4-2-2-1．OpenGL"><a href="#4-2-2-1．OpenGL" class="headerlink" title="4.2.2.1．OpenGL"></a>4.2.2.1．OpenGL</h4><p>​    OpenGL是渲染2D、3D数字图形的跨语言、跨平台的应用程序编程接口（API）。由近350个函数组成，绘制简单图形和复杂三维景象。OpenGL常用于CAD、虚拟现实、科学可视化和游戏开发等。OpenGL直接操纵图形硬件，高效进行图形图像编程，实现一般由显示设备厂商提供。OpenGL是对显卡编程的工业接口。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139175.png" alt="img"></p>
<p>​    OpenGL规范由1992年成立的OpenGL架构评审委员会（ARB）维护。ARB由业界顶级软硬件公司组成，下图是OpenGL的发展过程。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139161.png" alt="img"></p>
<p>​    OpenGL API定义了若干被客户端程序调用的函数，以及一些整型常量。这些实现方便了开发者调用。</p>
<p>​    OpenGL与语言平台无关。规范没有获得和管理OpenGL上下文相关的内容，将这些细节交给底层窗口系统。OpenGL专注图像渲染，不提供输入、音频及窗口相关的API。</p>
<p>​    OpenGL不断进化API。新版规范定期由Khronos Group发布，新版本通过扩展API来支持各种新功能。每个版本细节由Khronos Group成员一致决定，包括显卡厂商、操作系统设计人员以及类似Mozilla和谷歌的技术性公司。</p>
<p>​    除了核心API功能，GPU供应商通过扩展的形式提供额外功能。扩展引入新功能和新常量，增加或取消现有OpenGL功能。</p>
<p>​    每个扩展与一个标识符联系，标识符基于开发公司的名称。例如，英伟达（nVidia）的标识符是NV。如果多个供应商同意使用相同的API来实现相同功能，那么就用EXT标志符。这种情况更进一步，Khronos Group的架构评审委员（Architecture Review Board，ARB）正式批准该扩展，那么就被称为一个“标准扩展”，标识符使用ARB。第一个ARB扩展是GL_ARB_multitexture。</p>
<p>​    OpenGL每个新版本中引入的功能，特别是ARB和EXT类型的扩展，通常由数个被广泛实现的扩展功能组合而成。</p>
<p>​    代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;GLTools。h&gt;             // OpenGL toolkit</span><br><span class="line">#include &lt;GLShaderManager。h&gt;    // Shader Manager Class</span><br><span class="line"></span><br><span class="line">GLBatch	triangleBatch;</span><br><span class="line">GLShaderManager	shaderManager;</span><br><span class="line"></span><br><span class="line">void ChangeSize(int w， int h);</span><br><span class="line">void SetupRC();</span><br><span class="line">void RenderScene(void);</span><br><span class="line">gltSetWorkingDirectory(argv[0]);</span><br><span class="line">glutInit(&amp;argc， argv);</span><br><span class="line">glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH | GLUT_STENCIL);</span><br><span class="line">glutInitWindowSize(800， 600);</span><br><span class="line">glutCreateWindow(&quot;Triangle&quot;);</span><br><span class="line">glutReshapeFunc(ChangeSize);</span><br><span class="line">glutDisplayFunc(RenderScene);</span><br><span class="line"></span><br><span class="line">SetupRC();</span><br><span class="line">glutMainLoop();</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-2、DirectX"><a href="#4-2-2-2、DirectX" class="headerlink" title="4.2.2.2、DirectX"></a>4.2.2.2、DirectX</h4><p>​    微软在业界的大哥地位，影响力不言而喻。在发展史上，多次和IBM对博公堂，微软宣布，凡是IBM的电脑，不能安装Windows操作系统。软件厂商要挟硬件厂商，在微软发展历史上，留下了光辉的一页。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139171.png" alt="img"></p>
<p>​    音视频是电脑最核心的功能之一，作为系统供应商，微软推出了自己的DirectX产品，该产品在1995年前后十几年间，决定了很多硬件厂商的生死。</p>
<p>​    示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#pragma comment(lib，&quot;d3d9.lib&quot;)</span><br><span class="line">#pragma comment(lib，&quot;d3dx9.lib&quot;)</span><br><span class="line">#include &lt;d3dx9。h&gt;</span><br><span class="line">LPDIRECT3D9 g_pD3D = NULL;</span><br><span class="line">LPDIRECT3DDEVICE9 g_pD3DDevice = NULL;</span><br><span class="line">LPDIRECT3DVERTEXBUFFER9 g_pVertexBuffer = NULL; </span><br><span class="line"></span><br><span class="line">HRESULT InitialiseD3D(HWND hWnd)</span><br><span class="line">HRESULT InitialiseVertexBuffer()</span><br><span class="line">void SetupRotation()</span><br><span class="line">void SetupCamera()</span><br><span class="line">void SetupPerspective()</span><br><span class="line">void Render()</span><br><span class="line">void CleanUp()</span><br></pre></td></tr></table></figure>

<p>​    当我们平心静气面对这些技术和代码时，深刻的感受到，尤其在早期，当年的D3D技术对显卡厂家的影响是可怕的，对D3D技术的支持程度代表了显卡的受欢迎程度。当年的D3D技术应用最主要是游戏领域。</p>
<p>​    从D3D的发展，得到岁月的启示，垄断阻碍了技术的发展，相信在某一天，D3D也终究会退出技术的舞台。</p>
<h3 id="4-2-3、Shader编程"><a href="#4-2-3、Shader编程" class="headerlink" title="4.2.3、Shader编程"></a>4.2.3、Shader编程</h3><p>​    Shader在3D编程里面占据着重要的地位，是OpenGL、DirectX、Unity等引擎中最核心的概念。成了3D图形图像编程的核心标配。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139313.png" alt="img"></p>
<p>​    示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#version 130</span><br><span class="line">in vec4 vVertex;</span><br><span class="line">in vec3 vNormal;</span><br><span class="line"></span><br><span class="line">uniform vec4    ambientColor;</span><br><span class="line">uniform vec4    diffuseColor;	</span><br><span class="line">uniform vec4    specularColor;</span><br><span class="line">uniform vec3	   vLightPosition;</span><br><span class="line">uniform mat4	   mvpMatrix;</span><br><span class="line">uniform mat4	   mvMatrix;</span><br><span class="line">uniform mat3	   normalMatrix;</span><br><span class="line">smooth out vec4 vVaryingColor;</span><br><span class="line"></span><br><span class="line">void main(void) </span><br><span class="line">&#123; </span><br><span class="line">    vec3 vEyeNormal = normalMatrix * vNormal;</span><br><span class="line">    vec4 vPosition4 = mvMatrix * vVertex;</span><br><span class="line">    vec3 vPosition3 = vPosition4。xyz / vPosition4。w;</span><br><span class="line">    vec3 vLightDir = normalize(vLightPosition - vPosition3);</span><br><span class="line">    float diff = max(0。0， dot(vEyeNormal， vLightDir));</span><br><span class="line">    vVaryingColor = diff * diffuseColor;</span><br><span class="line">    vVaryingColor += ambientColor;</span><br><span class="line">    vec3 vReflection = normalize(reflect(-vLightDir， vEyeNormal));</span><br><span class="line">    float spec = max(0。0， dot(vEyeNormal， vReflection));</span><br><span class="line">if(diff != 0) </span><br><span class="line">&#123;</span><br><span class="line">        float fSpec = pow(spec， 128。0);</span><br><span class="line">        vVaryingColor。rgb += vec3(fSpec， fSpec， fSpec);</span><br><span class="line">	&#125;</span><br><span class="line">    gl_Position = mvpMatrix * vVertex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-1、Metal"><a href="#4-2-2-1、Metal" class="headerlink" title="4.2.2.1、Metal"></a>4.2.2.1、Metal</h4><p>​    Metal是苹果公司的图形编程库，近两年取得了巨大的发展。在Mac平台和IOS平台音视频开发上，Metal是一个很好的选择。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139423.png" alt="img"></p>
<p>​    Metal提供对GPU的直接访问，技术人员最大程度地发挥 iOS、macOS和Apple tvOS app中的图形硬件计算潜能。Metal构建于易用的低开销架构之上，提供预编译的GPU 着色器和精细的资源控制。</p>
<p>​    Metal支持多线程，支持 GPU 驱动命令创建。支持GPU阵列编程，充分利用 Mac Pro 和 Pro Display XDR 的专业级多媒体功能。</p>
<p>​    渲染示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;Renderer.h&quot;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    float red, green , blue, alpha;</span><br><span class="line">&#125;Color;</span><br><span class="line"></span><br><span class="line">@implementation Renderer</span><br><span class="line">&#123;</span><br><span class="line">    id&lt;MTLDevice&gt; _device;</span><br><span class="line">    id&lt;MTLCommandQueue&gt; _commandQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//画view的内容，这个代理方法会按帧率执行</span><br><span class="line">-(void)drawInMTKView:(MTKView *)view&#123;</span><br><span class="line">    //获取颜色</span><br><span class="line">    Color color = [self makeFancyColor];</span><br><span class="line">    //设置背景色</span><br><span class="line">    view.clearColor = MTLClearColorMake(color.red, color.green, color.blue, color.alpha);</span><br><span class="line">    </span><br><span class="line">    //创建一个命令缓冲区</span><br><span class="line">    id&lt;MTLCommandBuffer&gt; commandBuffer = [_commandQueue commandBuffer];</span><br><span class="line">    commandBuffer.label = @&quot;mycommand&quot;;</span><br><span class="line">    </span><br><span class="line">    //渲染过程，用于保存渲染过程的结果</span><br><span class="line">    MTLRenderPassDescriptor *renderPassDescriptor = view.currentRenderPassDescriptor;</span><br><span class="line">    </span><br><span class="line">    if (renderPassDescriptor != nil) &#123;</span><br><span class="line">        id&lt;MTLRenderCommandEncoder&gt; renderEncoder = [commandBuffer renderCommandEncoderWithDescriptor:renderPassDescriptor];</span><br><span class="line">        renderEncoder.label = @&quot;myrenderEncoder&quot;;</span><br><span class="line">        </span><br><span class="line">        //结束编码</span><br><span class="line">        [renderEncoder endEncoding];</span><br><span class="line">        </span><br><span class="line">        //注册一个可绘制图像</span><br><span class="line">        [commandBuffer presentDrawable:view.currentDrawable];</span><br><span class="line">    &#125;</span><br><span class="line">    //提交命令到GPU</span><br><span class="line">    [commandBuffer commit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//视口发生变化会被调用</span><br><span class="line">- (void)mtkView:(nonnull MTKView *)view drawableSizeWillChange:(CGSize)size &#123;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-2、Vulkan"><a href="#4-2-2-2、Vulkan" class="headerlink" title="4.2.2.2、Vulkan"></a>4.2.2.2、Vulkan</h4><p>​    Vulkan是一个跨平台的2D和3D绘图应用程序接口（API），科纳斯组织（Khronos Group）在2015年游戏开发者大会（GDC）上发布。</p>
<p>​    Khronos Group目前是世界多媒体、音视频、图形图像领域的核心协会，拥有世界顶级会员单元，拥有世界级的技术标准。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139417.png" alt="img"></p>
<p>​    科纳斯把Vulkan API称为“下一代OpenGL行动”（next generation OpenGL initiative）或“glNext”。就像OpenGL，Vulkan针对实时3D程序（如电子游戏）设计，Vulkan并计划提供高性能和低CPU管理负担（overhead），这也是Direct3D12和AMD的Mantle的目标。Vulkan兼容Mantle的一个分支，并使用了Mantle的一些组件。</p>
<p>​    Vulkan 是 AMD Mantle 的后续版本，继承了强大的低开销架构，使软件开发能够全面获取 Radeo GPU 与多核 CPU 的性能、效率和功能。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139433.png" alt="img"></p>
<p>​    Vulkan 支持深入硬件底层的控制，为各种系统带来更快的性能和更高的影像质量。Vulkan API 还提供超高的 OS 兼容性、渲染特性和硬件效率。</p>
<p>​    基于GCN架构的Radeon 显卡拥有强大的“异步计算”功能，使显卡并行处理3D几何图形与计算工作量。当游戏需要同时计算复杂照明与渲染人物时，这种功能就找到了用武之地。这些任务并不需要在Radeon显卡上串行运行，节约时间、提升整体帧速率。Vulkan在近期Windows和Linux系统上都有很好的应用。</p>
<p>​    目前，Vulkan得到广泛的的支持，在硬件上，无论是服务器、桌面、移动端，都进行了完好的支持。在系统层面上，Linux、Windows、Mac、Android、IOS都为Vulkan提供了完备的接口。</p>
<p>​    示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vulkan/vulkan.h&gt;</span><br><span class="line">#include &lt;stdexcept&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">class HelloTriangleApplication </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void run() </span><br><span class="line">&#123;</span><br><span class="line">        initVulkan();</span><br><span class="line">        mainLoop();</span><br><span class="line">        cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">void initVulkan() &#123;&#125;</span><br><span class="line">void mainLoop() &#123;&#125;</span><br><span class="line">void cleanup() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    HelloTriangleApplication app;</span><br><span class="line">try </span><br><span class="line">&#123;</span><br><span class="line">        app.run();</span><br><span class="line">&#125;</span><br><span class="line">catch (const std::runtime_error&amp; e) </span><br><span class="line">&#123;</span><br><span class="line">        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;</span><br><span class="line">        return EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3、启示"><a href="#4-3、启示" class="headerlink" title="4.3、启示"></a>4.3、启示</h2><p>​    计算机图形学的发展不是一蹴而就的，前期发展过程中，百花齐放，百家争鸣。各家接口不一，处于蓬勃不稳定发展期，系统厂商、硬件厂商、软件厂商、行业协会一起，共同推出软硬件规范，OpenGL就是一个成功的表现。</p>
<p>​    技术发展过程中，一些厂商没有明确的规范或没有明确的支持规范，进而失败了。没有硬件厂商支持的规范同样是可悲的，很快被淘汰了。软件运行在硬件之上，硬件在一定程度上决定着软件。软件反过来影响着硬件。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139426.png" alt="img"></p>
<p>​    3D时代绚丽多彩，现实生活姹紫嫣红，多年技术积淀，在3D时代五彩斑斓，应用辈出。显示技术的应用发挥到了极致，对计算技术的发展做出了卓越的贡献。</p>
<p>​    3D时代的到来，为显示技术的精细化发展吹响了号角。在计算机图形图像技术发展史上，承前启后，继往开来。</p>
<h1 id="5、移动时代"><a href="#5、移动时代" class="headerlink" title="5、移动时代"></a>5、移动时代</h1><p>​    移动时代可以追踪到很远，从古老的电台到1948年贝尔实验室的Bell boy，到1956年摩托罗拉的BP机。寻呼机的发展历史，主要是通讯技术的进步。和主题有一定偏差，不做阐述。翻开半个多世纪的画卷，历史没有想到的是，通讯技术在今天有如此傲娇的成绩。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146034.png" alt="img"></p>
<p>​    早期电脑至上，后来移动至上。不可怀疑的是，移动互联网高速发展的今天，手机成为应用系统最重要的终端。</p>
<p>​    移动端图形系统的研究，是移动应用终端开发的重中之重，也是手机底层技术的核心要素。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146054.png" alt="img"></p>
<p>​    本篇从手机发展史起笔，到移动显示芯片厂家、移动芯片技术与流行图形库讲述，希望给移动端音视频开发带来有益的启示。</p>
<h2 id="5-1、手机时代"><a href="#5-1、手机时代" class="headerlink" title="5.1、手机时代"></a>5.1、手机时代</h2><p>​    那年的“hello moto”，能否勾起你绵绵的情思。这颗圆圆的行星，”hello moto”之声奏响了银河系无线通讯的号角。那个年代手提电话(也叫移动电话)，还不叫手机，绰号大哥大，也叫板砖。当年的大哥大仅仅局限通话，短信功能也不具备。有了大哥大，不学数理化，大哥大成为了身份的象征。</p>
<p>​    硬件技术的进步，手机向小型化发展。两个企业的高光时刻带来了，当年的摩托罗拉和诺基亚堪称业界大哥，赚钱赚到罗马。从早期的单色屏逐渐发展到彩色屏。从1990年到2005年，那是诺基亚和摩托罗拉的时代。昨日年少英雄，指点江山，今天英雄白发，美人谢幕。互联网给我们多少唏嘘。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146040.png" alt="img"></p>
<p>​    工艺的提升不仅推动硬件设计的进步，更推动软件系统的发展，手机应该拥有更强大的功能。在这一大环境下，SmartPhone、Symbian、Linux手机操作系统不断涌现，为智能手机系统发展发起了前期的火力侦察。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146031.png" alt="img"></p>
<p>​    乔布斯担负着上帝赋予的伟大使命，2007年，Iphone诞生了。伴随着Iphone的诞生，Android的出现，智能时代到来了。完成了伟大使命的乔帮主，这位天选之子，4年之后，撒手人寰，魂归天堂。而他，留下了这颗行星上市值最高的公司。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146048.png" alt="img"></p>
<p>​    智能手机的兴起，促进移动端硬件提升，显示技术也有很大变化。移动时代硬件发展同样精彩,充满了竞争与杀戮，野蛮和邪恶，和PC端同样精彩。软件方面相对平滑平淡，没有大的开开合合。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146075.png" alt="img"></p>
<p>​    手机的发展史，也是一部无线技术的发展史。硬件技术与通讯规范密切相关，翻开移动通讯的日记，从1G到5G，感时光如梭，叹技术神速。通讯技术规范不属于本主题内容，不做阐述。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146307.png" alt="img"></p>
<p>​    移动时代芯片科技，看到了中国企业的影子，东方用资本开始了买买买的过程。对芯片技术的渴求，资本是最直接的倾诉。期望不远的未来，有一家拥有核心技术的东方芯片厂商。在技术的长河中，书写浓重的一笔。在芯片的交响乐中，奏出中国的声音。</p>
<p>​    波澜壮阔的手机应用，后台是芯片技术的驱动。下一节，我们从芯片的角度回顾。</p>
<h2 id="5-2、移动端主流显示芯片"><a href="#5-2、移动端主流显示芯片" class="headerlink" title="5.2、移动端主流显示芯片"></a>5.2、移动端主流显示芯片</h2><h3 id="5-2-1、ARM"><a href="#5-2-1、ARM" class="headerlink" title="5.2.1、ARM"></a>5.2.1、ARM</h3><p>​    ARM不仅进行嵌入式CPU架构授权，也进行GPU架构授权。在芯片架构设计上，ARM稳坐头把交椅。2006年，ARM 完成对挪威Falanx公司的收购，获得其移动GPU技术，完成对原有IP技术的扩展。也就是从那个年代开始，ARM闪亮登场。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146341.png" alt="img"></p>
<p>​    ARM是有先见之明的，15年后，GPU广泛用于智能手机、DTV和平板电脑等多种设备。15年时间，ARM Mali技术成为全球出货量第一的GPU，预计2020年总计出货量就超过15亿。在移动图形硬件发展史上，ARM mail是必谈的技术。</p>
<p>​    Mali GPU架构发展了3代，Utgard、Midgard和Bifrost。Utgard的代表是Mali-400 MP，三星的Exynos4412用的就是这款GPU，Mali-450至今的一些电视芯片还在使用（例如小米电视）。Midgard的型号是Mali-T系列，联发科Helio X20就用的是Mali-T880，而Bifrost的型号是Mali-G系列。</p>
<p>​    ARM的Mali可以说是ARM CPU的“黄金搭档”，架构上不是最先进，普及率非常高，低廉的授权费是芯片厂商比较喜欢的。ARM科技与方案的授权，保证了技术纯粹，降低了经营风险。</p>
<p>​    Mali是一款高端GPU，将图形IP视觉娱乐变为现实，市场占安卓智能手机30%以上，可与PowerVR SGX系列GPU对比。</p>
<p>​    应用基于ARM体系结构的移动设备上，得益于CPU占有率发展迅猛。ARM® Mali™ 系列 GPU 为所有嵌入式图形 IP 和视频 IP 提供完善的解决方案，使设备制造商和内容开发商能够为最广泛的消费类设备（手机、游戏机、智能本、HDTV）提供最高质量的尖端多媒体解决方案。GPU是近些年硬件最重要的应用之一，当年ARM收购Falanx简直是神来之笔，为ARM的做大做强埋下了伏笔。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146348.png" alt="img"></p>
<p>​    Mali 嵌入式图形 IP 设计用于提高能源效率和解决性能问题，包括世界上最小的 GPU、完整多核可扩展性（最高可达 1080p）、用于可视计算的 GPU 的通用计算 (GPGPU) 以及多用途应用程序。所有 Mali GPU 都受预先集成的 Mali 图形驱动程序软件支持。</p>
<p>​    灵活性是要考虑的一个重要因素，支持的业界标准开放式 API 包括OpenVG、OpenGL ES、OpenCL以及DirectX®。这些是ARM成功的基础。</p>
<p>​    ARM在芯片架构设计上，有多见的经验积累。高通在通讯领域里，有最好的技术产品。</p>
<h3 id="5-2-2、Qualcomm"><a href="#5-2-2、Qualcomm" class="headerlink" title="5.2.2、Qualcomm"></a>5.2.2、Qualcomm</h3><p>​    高通（Qualcomm）的英文是Quality Communications，翻译就是高质量通信。创始人雅各布斯是搞通信工程搞到卫星领域的男人，高通今天“连接万物”的使命从创立那天就奠定了。这是一家超强的公司，其技术延续性与强大性首屈一指。在这个年代的人，都用过高通的产品或者技术。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146324.png" alt="img"></p>
<p>​    1985年成立的公司，在1989开始推广CDMA。业界的注意力都在TDMA技术上（后来演变成GSM），高通靠着自己的实验和测试，让CDMA在1993年成为行业标准并和GSM分庭抗礼，这就是高通的水平。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146383.png" alt="img"></p>
<p>​    高通研发投入占比常年在收入的20%以上。前30年，高通累计投入了超过440亿美元的研发经费，获得了超过13万项全球专利。</p>
<p>​    2007年，那一年发生了两件改变世界的事情：乔布斯发布iPhone，高通推出了骁龙芯片Snapdragon S1。</p>
<p>​    13年间，高通在移动SoC领域打赢过两次重大战役，第一次让德州仪器、英伟达这些业界大厂退出了移动高端市场。第二次则是让联发科败走中高端。中途还插播过英特尔靠着Atom+补贴，打了几年酱油的历史。这些恐怖成绩的存在，是高通对硬件技术的不懈追求。</p>
<p>​    时间线调回2007年，从那时开始，高通每年的SoC，都会带着新的制程、新的CPU、GPU和调制解调器亮相。高通在调制解调器上的优势，犹如不可逾越的鸿沟，把其它大厂排挤在千里之外。高通把调制解调器分为两种，一种骁龙，一种其它。</p>
<p>​    2007年安卓和Windows Mobile的蛮荒时代，高通MSM7225&#x2F;7625这些上古的SoC连GPU都已经支持3G了，比国内称为3G元年的2009年还早了整整2年。作为移动技术的顶级元老，这个不让人意外。</p>
<p>​    移动GPU，特别是Adreno系列，在近10几年一直维持着远超摩尔定律的性能增速。这个故事出现得最密集的词，就是“暴涨”二字。在众多公司中，高通像一个工程师一样，坚守硬件设计的阵地。</p>
<p>​    2009年，MSM7227（隶属骁龙S1）搭载的Adreno 200，其浮点性能是2.1GFLOPS。而2012年初的Adreno 225上，浮点性能已经暴涨了10数倍，达到25 GFLOPS。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146377.png" alt="img"></p>
<p>​    手机GPU和电脑有一定的区别，手机GPU是整合到SoC内的，电脑可以有独立显卡。高通的adreno的技术部分源自高通从AMD收购的移动GPU部门。</p>
<p>​    高通的GPU市场占有率很高，adreno的表现也足够优秀，支持足够多的新特性，性能比较强，功耗表现也很理想。</p>
<p>​    如果说2015年之前，其他厂商的GPU还算和高通追得很紧的话，那在骁龙820&#x2F;821的Adreno 530开始，高通就进入了无人之境。或是从绝对性能，或是从能耗比上，拉开了和苹果、三星、海思、联发科的差距。现在唯一能在GPU性能上跟着高通的，就只剩苹果了。但同代产品上，高通总是能在能耗比上压苹果一头。</p>
<p>​    让人疯狂的是，除了能耗比其它公司占优之外，高通的Adreno几乎常年都是用着同代面积最小的GPU芯片面积。三星Exynos 9810上的GPU面积达到了25 mm2，Kirin 970上也有18 mm2，但高通硬生生只用了10 mm2出头的芯片面积，做到了更强的性能更低的能耗。</p>
<p>​    高通在嵌入式技术上的能力是有目共睹的，嵌入式硬件对移动端提供了核心的支持。在图形图像视频硬件技术上，高通道高一丈。、</p>
<p>​    在互联网众多科技公司中，高通算是厚积薄发。在企业发展上，稳健踏实，在芯片领域具有举足轻重的地位。在互联网、人工智能高速发展的今天，高通的硬实力展现出来。</p>
<p>​    苹果感谢高通，高通的存在，阻击了一线科技公司对苹果的围剿。在技术大潮中，高通不断为苹果输送技术的血液，成就了苹果的万亿帝国。</p>
<h3 id="5-2-3、Apple"><a href="#5-2-3、Apple" class="headerlink" title="5.2.3、Apple"></a>5.2.3、Apple</h3><p>​    2006年到2013年，AMD和NVIDIA在移动市场竞争中完全失策。丢掉全球移动GPU主要供应商的同时，苹果一步步取代他们并成为最强大、最主流的GPU处理器的生产者。AMD和NVIDIA重蹈Intel的覆辙，丢掉移动GPU市场。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146543.png" alt="img"></p>
<p>​    当年Intel未能预料iPhone的潜力，忽视了移动市场。让ARM从一家基础移动处理器生产商一跃成为智能手机和平板处理器的主要生产商，而移动GPU的发展也十分相似。历史不断的给苹果机会，并给与其把握机会的能力。</p>
<p>​    iOS符合用户知觉，视觉美观，图形环境(归功于GPU加速)，这是iPhone销量居高不下的因素。Google完全没有意识到iPhone成功的关键。</p>
<p>​    iPhone对GPU的重视，让iPhone适合游戏。从一开始，游戏是苹果应用商店里的主角，改变了大众对苹果“没有游戏”的印象。iPhone、iPod touch还有2010年的iPad，均作为独立的移动游戏设备颠覆了游戏市场。</p>
<p>​    苹果推出了新的API：Metal。很多优秀的开发者都利用了这套新的API开发新应用。Metal可以让游戏和其他需要图形性能的应用绕过OpenGL，利用苹果64位处理器的强大GPU。苹果在图形处理速度上有很大优势，在移动游戏方面尤其明显；而Metal则让优势进一步增加。</p>
<p>​    苹果把Imagination的人挖了之后自研了GPU，然后把这帮人解散了。这件事情告诉我们，苹果是靠不住的，不知道哪天又会卸磨杀驴。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146606.png" alt="img"></p>
<p>​    近些年苹果GPU走向自研道路。未来谁掌握了最强的手机图形性能，谁就可以在市场上获得更大主动权，苹果深谙此道。在进行技术拓展的同时，进一步巩固A系列芯片的性能优势。</p>
<p>​    A11尽管采用的是和骁龙835一样的10nm工艺，整体性能仍然强于骁龙835。GPU相比A10提升了30%，三核心设计，并对沉浸式 3D 游戏和 AR 增强现实进行了优化。这是苹果第一代自研GPU，苹果真正能把自己的GPU完善起来还需要1-2年时间。那时A系列GPU和CPU融合的会更加紧密，在性能和能耗上会有更大的突破。</p>
<p>​    发展的关键时刻，上帝偏爱苹果。面临技术抉择时，苹果往往押宝成功。看似孤傲独行，重大战役到来时，总有友军出现。这些因素的综合，使苹果稳坐科技公司第一宝座。</p>
<h3 id="5-2-4、Imagination-Technologies"><a href="#5-2-4、Imagination-Technologies" class="headerlink" title="5.2.4、Imagination Technologies"></a>5.2.4、Imagination Technologies</h3><p>​    Imagination Technologies前身是video logic公司。曾经的全球移动 GPU IP龙头，深耕GPU 内核研发和设计，曾是苹果御用图形技术提供商，总部位于英国。2018年被中资背景企业收购，未来发展不明。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146692.png" alt="img"></p>
<p>​    Imagination Technologies的核心产品是IMG A系列产品，被设计为可应用于各种场景的GPU，支持自动驾驶、AIoT、数字电视、机顶盒、移动设备等智能应用。</p>
<p>​    IMG A系列在多个市场中授权客户，这点和ARM相像。首批搭载该IP的SoC器件在2020年供货。Imagination Technologies宣布，紫光已获得最新一代神经网络加速器（NNA）PowerVR Series3NX半导体IP授权许可，是面向中高端移动设备市场的系统级芯片。</p>
<p>​    散热条件限制，大多数移动GPU很难提供持续一致的游戏体验，芯片发热其性能下降到不可接受的水平。IMG A系列则以一致的帧速提供持续可靠的性能以及更长游戏时间，避免了因芯片过热导致时钟降频甚至故障等过热情况，IMG A系列有一定的技术优势。</p>
<p>​    IMG A系列采用Imagination的HyperLane技术，独立的硬件控制通道被隔离在内存中，将不同的任务同时提交给GPU，实现GPU多任务处理。</p>
<p>​    通过AI Synergy，GPU在可以提供图形处理功能的同时，使用备用资源支持可编程AI以及固定功能，即高度优化的Imagination神经网络加速器。AI Synergy在最小的芯片面积中提供可编程的人工智能，统一的软件栈可实现灵活出色的性能。</p>
<p>​    PowerVR曾经是苹果“御用”的GPU，性能表现强大、架构先进，不仅在iOS领域，在安卓领域使用也很广泛。当年的一代神U联发科MT6577就使用了大幅度超频的SGX531，性能是低端机里的翘楚。</p>
<p>​    但是，因为较高的授权费用，PVR逐渐失去了安卓市场，客户纷纷转向更廉价的ARM Mali。虽然有联发科Helio X30等的支持，PVR仍然是强弩之末。再加上苹果的抛弃（苹果宣布自研GPU）和挖墙脚，等待Imagination的只有卖身的悲惨命运。</p>
<p>​    GPU技术的选择，是很多芯片公司做强做大的基础。尤其是智能时代的带来，GPU的应用汹涌澎湃，风卷云涌。</p>
<h3 id="5-2-5、Vivante"><a href="#5-2-5、Vivante" class="headerlink" title="5.2.5、Vivante"></a>5.2.5、Vivante</h3><p>​    Vivante(图芯)曾经是嵌入式图形处理器（GPU）的技术先行者。总部位于加州，为全球移动设备和家庭娱乐市场提供顶级应用，超级处理器解决方案。曾经拥有种类繁多的2D&#x2F;3D图形处理器。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146625.png" alt="img"></p>
<p>​    用硅印模，为业界标准应用程序接口提供强大支持。图芯芯片技术将桌面质量图象和性能带入汽车、手掌中的屏幕。优秀可升级的嵌入式解决方案是可升级的，建立在业界标准之上，且优化功耗、性能和大小。</p>
<p>​    图芯不断增长的产品系列，与全球多家公司成功合作。对移动视觉逼真和高清视觉逼真的核心技术，成为当年顶级移动端图形图像技术供应商。</p>
<p>​    2016年01月08日，图芯被中国芯原收购，产品开始沉默。对OpenGL ES、OpenVG、DirectX的成功支持，是图芯前期成功的核心要素。</p>
<h3 id="5-2-6、NVIDIA、AMD、Intel"><a href="#5-2-6、NVIDIA、AMD、Intel" class="headerlink" title="5.2.6、NVIDIA、AMD、Intel"></a>5.2.6、NVIDIA、AMD、Intel</h3><p>​    移动端图形技术的快速发展，加速了移动时代的到来。当年PC端显示技术的大佬们，变得孤单与寂寞，这能告诉我们什么呢？</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146638.png" alt="img"></p>
<p>​    手机gpu不能单卖，需要可用的基带，NVIDIA并没有基带。在不需要基带的移动gpu上，NVIDIA做的很好，例如switch gpu。</p>
<p>​    英伟达开发过手机芯片——Tegra系列，现在Tegra已经谢幕，当年使用Tegra芯片手机风行一时。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146708.png" alt="img"></p>
<p>​    英伟达在Tegra4及之前的GPU架构叫GeForce ULP，Tegra4号称“72核GPU”，但架构十分老旧，是DX9时代的分离渲染架构。Tegra因为基带芯片问题退出手机市场，后来推出了Tegra K1用上先进的Kepler架构，但是一切都太晚了。</p>
<p>​    NVIDIA现在和可预见的将来都没有手机产品，这是NVIDIA不能接受的。期望有一天，在移动端显示芯片上，上演王者归来。AMD不仅缺少移动GPU，还几乎没有市场份额。Intel在补贴硬件厂商让它们使用Intel产品(造成了每年400亿美元的损失)。</p>
<p>​    世界上影响力最大的两个GPU厂家，AMD和NVIDIA。两个微处理器的发明者Intel和德州仪器，几乎全都被苹果逐出了移动市场。现在市场中只有低端零件厂商、苹果高端、高销量的iOS设备竞争。这令人感叹，苹果跳出了时代的局限性，在桌面端和移动端成为最成功的企业，上帝太偏爱苹果了。</p>
<p>​    当年Nvidia买了Icera，i500之后，折腾SoC，没有下文。15年宣告放弃，现在想用只能外挂基带。黄药师仰天长啸，移动端报国无门。</p>
<p>​    外挂是可以的，DrivePX2上接GPU用PCIE 4x，然后GPU有自己显存，这个不是手机能接受的。如果用CCI，访问内存没有问题，但有其它局限性。Tegra X1后黄总就不用CCI互联了。</p>
<p>​    AMD、INTEL和英伟达道路相似，3D时代雄起，移动时代沉寂，智能时代奋起。每一家公司都有各自的领地。那些成功的跨界，成就了技术的艳遇。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146815.png" alt="img"></p>
<p>​    就工艺而言，相对于CPU，GPU技术难度低一些。这也是众多小厂开始向GPU迈进的原因。在移动时代，科技的发展创造机会，很多传统的CPU、GPU大厂由于固守轨道，错过了GPU发展的黄金时代。</p>
<h2 id="5-3、移动图形库"><a href="#5-3、移动图形库" class="headerlink" title="5.3、移动图形库"></a>5.3、移动图形库</h2><p>​    移动手机图形接口上，没有桌面端的万马奔腾、百舸争流，整体相对平稳与自然。无论Android还是IOS，都是Linux的内核。所以在移动图形库的选型与发展上，和桌面端图形库有一个很好的承接。OpenGL桌面端不可撼动的地位，移动端，OpenGL的简化版OpenGL ES应运而生。</p>
<h3 id="5-3-1、OpenGL-ES"><a href="#5-3-1、OpenGL-ES" class="headerlink" title="5.3.1、OpenGL ES"></a>5.3.1、OpenGL ES</h3><p>​    OpenGL ES 是 OpenGL三维图形 API 的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146838.png" alt="img"></p>
<p>​    OpenGL ES 是 OpenGL 裁剪定制而来，去除了复杂图元等非绝对必要的特性。OpenGL ES 2.0 参照 OpenGL 2.0 规范定义。</p>
<p>​    OpenGL ES 免授权并且跨平台，强大的2D和3D图形应用程序接口API，针对多种嵌入式系统专门设计，包括控制台、移动电话、手持设备、家电设备和汽车。由精心定义的桌面OpenGL子集组成，实现了软件与图形加速间灵活强大的底层交互接口。</p>
<h4 id="5-3-1-1、OpenGL-ES-版本与功能"><a href="#5-3-1-1、OpenGL-ES-版本与功能" class="headerlink" title="5.3.1.1、OpenGL ES 版本与功能"></a>5.3.1.1、OpenGL ES 版本与功能</h4><p>​    OpenGL ES包含浮点运算和顶点运算，及EGL便携设备的本地视窗系统规范。</p>
<p>​    OpenGL ES 1.X 面向功能固定的硬件所设计，并提供加速支持、图形质量及性能标准，也就是固定管线编程。OpenGL ES 2.X 提供包括遮盖器技术在内的全可编程3D图形算法。OpenGL ES 3.x则在可编程管线上进行了增强。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146870.png" alt="img"></p>
<p>​    OpenGL ES提高了不同消费电子设备的3D图形渲染速度，在嵌入式系统上实现了全面可编程的3D图形。</p>
<p>​    OpenGL ES工作组在六个月内更新OpenGL ES采纳者项目，提供兼容性测试，并提供相关源代码。目前 Corporation、Imagination、NVIDIA、高通、ZiiLABS等都表达了对OpenGL ES 3.0的大力支持。最新GPU就支持OpenGL ES 3.0。</p>
<h4 id="5-3-1-2、OpenGL-ES-3-0新功能"><a href="#5-3-1-2、OpenGL-ES-3-0新功能" class="headerlink" title="5.3.1.2、OpenGL ES 3.0新功能"></a>5.3.1.2、OpenGL ES 3.0新功能</h4><p>​    1、渲染管线多重增强，实现先进视觉效果的加速，包括遮挡查询(Occlusion Query)、变缓反馈(Transform Feedback)、实例渲染(Instanced Rendering)、更多渲染目标支持。</p>
<p>​    2、高质量ETC2&#x2F;EAC纹理压缩格式成为一项标准功能，不同平台上不再需要不同的纹理集。</p>
<p>​    3、新版GLSL ES 3.0着色语言，全面支持整数和32位浮点操作。</p>
<p>​    4、纹理功能增强，支持浮点纹理、3D纹理、深度纹理、顶点纹理、NPOT纹理、R&#x2F;RG单双通道纹理、不可变纹理、2D阵列纹理、无二次幂限制纹理、阴影对比、调配(swizzle)、LOD与mip level clamps、无缝立方体贴图、采样对象、纹理MSAA抗锯齿渲染器。</p>
<p>​    5、更多精确尺寸纹理和渲染缓冲格式，便携移动应用更简单。</p>
<h4 id="5-3-1-3、OpenGL-ES-示例代码"><a href="#5-3-1-3、OpenGL-ES-示例代码" class="headerlink" title="5.3.1.3、OpenGL ES 示例代码"></a>5.3.1.3、OpenGL ES 示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">       private final int CONTEXT_CLIENT_VERSION = 3;</span><br><span class="line">       private GLSurfaceView mGLSurfaceView;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">              super.onCreate(savedInstanceState);</span><br><span class="line">              mGLSurfaceView = new GLSurfaceView(this);</span><br><span class="line">              if (detectOpenGLES30()) &#123;</span><br><span class="line">              mGLSurfaceView.setEGLContextClientVersion(CONTEXT_CLIENT_VERSION);</span><br><span class="line">                     mGLSurfaceView.setRenderer(new RendererJNI(this));</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                     Log.e(&quot;opengles30&quot;, &quot;OpenGL ES 3.0 not supported on device.  Exiting...&quot;);</span><br><span class="line">                     finish();</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              setContentView(mGLSurfaceView);</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       protected void onResume() &#123;</span><br><span class="line">              super.onResume();</span><br><span class="line">              mGLSurfaceView.onResume();</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line">       @Override</span><br><span class="line">       protected void onPause() &#123;</span><br><span class="line">              super.onPause();</span><br><span class="line">              mGLSurfaceView.onPause();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       private boolean detectOpenGLES30() &#123;</span><br><span class="line">              ActivityManager am = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">              ConfigurationInfo info = am.getDeviceConfigurationInfo();        </span><br><span class="line">              return (info.reqGlEsVersion &gt;= 0x30000);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-2、其它"><a href="#5-3-2、其它" class="headerlink" title="5.3.2、其它"></a>5.3.2、其它</h3><p>​    Vulkan和Metal不仅是3D时代的图形框架，也是移动领域的核心图形图像框架。关于Metal和Vulkan的知识，参考前面主题。</p>
<h2 id="5-4、启示"><a href="#5-4、启示" class="headerlink" title="5.4、启示"></a>5.4、启示</h2><p>​    梳理这段历史时，我们发现，信息科技的核心是芯片，芯片技术被国外巨头垄断。偶尔有中资公司的影子，大多昙花一现。芯片技术是百年大计，很难实现弯道超车。</p>
<p>​    在计算科技白皮书里，大多是欧美科技的影子，东方公司比重较低。这注定了科技赶超是一个长期的过程。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146955.png" alt="img"></p>
<p>​    在软件规范制定上，面临同样的情况。未来几十年，在软件规范上，我们埋头苦干，奋勇向前。</p>
<p>​    通讯核心技术上，依然有很大不足。但在市场应用上，我们拔得头筹。在移动商务、移动支付、短视频应用上，捷报频传。</p>
<p>​    美摄科技坚持音视频核心技术研究，底层硬件技术研发。在技术接口，产业应用上乘风破浪，激流勇进。在祖国图形图像技术建设上，做出应有的贡献。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146972.png" alt="img"></p>
<p>​    缘聚缘散，时空变换。1978年之后，科技的春天再次到来了。从基础芯片，软件规范，到行业应用。我们流年笑掷，坚信未来可期。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146007.png" alt="img"></p>
<h1 id="6-人工智能时代"><a href="#6-人工智能时代" class="headerlink" title="6 人工智能时代"></a>6 人工智能时代</h1><h2 id="6-1、人工智能发展历史"><a href="#6-1、人工智能发展历史" class="headerlink" title="6.1、人工智能发展历史"></a>6.1、人工智能发展历史</h2><p>​    人工智能是科技永久的话题，计算机本身是一个工具，人工智能发展史上，计算机的出现，是人工智能发展的伟大节点。21世纪仅仅是人工智能的开端，人工智能的发展方兴未艾。</p>
<p>​    早期的人工智能偏重于理论，西方的神学大师、哲学先驱、数学巨匠一起，为人工智能奠定了文化基础，下面我们开始与大师的对话。</p>
<h3 id="6-1-1、大事记"><a href="#6-1-1、大事记" class="headerlink" title="6.1.1、大事记"></a>6.1.1、大事记</h3><p>​    200年前，巴贝奇，一个英国数学家，设计了第一台计算二次多项式的计算机器，叫做差分机，摇动手柄，计算出x*x+a式子的值。当时的东方，大清皇朝，即将面临血色的辉煌。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144726.png" alt="img"></p>
<p>​    1956年，几个科学家，聚会在美国汉诺思小镇宁静的达特茅斯学院，利用暑假的两个月进行封闭式的讨论研究，主题是“达特茅斯夏季人工智能研究计划”。首次提出“人工智能（Artificial Intelligence，简称AI）”这一概念，人工智能学科应运而生了。当年简单的两个单词，成为今天科技的主旋律。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144719.png" alt="img"></p>
<p>​    1959年，塞缪尔讲到，计算机可以比人更好地编程，进行国际象棋游戏时，创造了“机器学习”(Machine Learning)一词。上承接人工智能，下承接自然语言与机器视觉。编程邂逅人工智能，人工智能青梅竹马的年代开始了。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144994.png" alt="img"></p>
<p>​    1965年，Joseph Weizenbaum，开发ELIZA，一个交互式计算机程序，用英语与人交谈。Weizenbaum有一个目标，证明人工智能思维与人类思维之间的沟通是肤浅的。这是第一个通过图灵测试的软件程序，“对话就是模式匹配”，代表着自然语言技术的开端。60年后的今天，自然语言技术应用广泛。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144980.png" alt="img"></p>
<p>​    1978年，卡耐基梅隆大学，开发自动选配计算机配件的程序XCON，1980年投入工厂使用，包含2500条规则，后续几年处理了超过80000条订单，准确度超过95%，每年节省超过2500万美元。这是早期的专家系统，开始于生产应用。我们今天进行自动购物时，很少有人知道半个世纪以前，在大洋彼岸已被广泛应用。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144020.png" alt="img"></p>
<p>​    1979年，斯坦福大学，制造了无人驾驶车Stanford Cart，这是汽车的第一次，依靠视觉感应器，在没有人工干预的情况下，自主穿过散乱扔着椅子的房间，需要几个小时才能完成。当年的视觉感应器，就是今天的机器视觉，当年的无人工干预，就是今天的自动驾驶。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144044.png" alt="img"></p>
<p>​    1982年，英国科学家霍普菲尔德几乎同时与杰弗里·辛顿，发现了具有学习能力的神经网络算法，沉寂10年之后，神经网络有了新的进展。从此神经网络高速发展，90年代开始商业化，用于文字图像识别和语音识别。今天的神经网络工程师们，鲜有人知道这两位大师的名字。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144071.png" alt="img"></p>
<p>​    1986年，梅赛德斯 - 奔驰，Ernst Dickmanns的指导下建造并发布了一辆配备摄像头和传感器的无人驾驶厢式货车。能够在没有人类驾驶员的道路上行驶高达55英里&#x2F;小时。当年的神奇幻想，今天的美好现实。Ernst Dickmanns，成为了自动驾驶的鼻祖，当年的奔驰货车，也称了自动驾驶的先驱。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144102.png" alt="img"></p>
<p>​    1998年，Dave Hampton和Caleb Chung。发明了Furby，第一款玩具机器人。2000年前后，日本科技公司凭借着较好的工业基础，在早期智能时代占据着不可或缺的位置。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144234.png" alt="img"></p>
<p>​    1999年，索尼。推出AIBO，价值2000美元的机器人宠物狗，与环境，所有者和其它AIBO的互动来“学习”。功能包括能解和响应100多个语音命令并与人类所有者进行对话。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144268.png" alt="img"></p>
<p>​    2002年，Roomba，自动机器人真空吸尘器，避开障碍物进行清洁。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144255.png" alt="img"></p>
<p>​    2006年，杰弗里辛顿。出版《Learning Multiple Layers of Representation》，奠定神经网络的全新架构，今天人工智能的核心技术。短短10年间，数学冰山背后，春风化雨，夏露凝香。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144331.png" alt="img"></p>
<p>​    2007年，Fei Fei Li。出生于北京，美国国家工程院院士，Twitter独立董事。组建ImageNet，一个注释图像数据库，帮助物体识别。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144320.png" alt="img"></p>
<p>​    2009年，吴恩达，使用图形处理器（GPU而不是CPU）进行大规模无监督式机器学习。取得了惊人的成就，向世人展示了一个超强的神经网络，它在自主观看千万张图片之后，识别小猫的图像。这是历史上在没有人工干预下，自主强化学习的里程碑式事件。向世人展示了无监督学习的价值，自此AI识别，温柔了岁月，惊艳了时光。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144408.png" alt="img"></p>
<p>​    2011年，Watson，电视游戏中。回答IBM创建的计算机自然语言问题，击败了两个前Jeopardy冠军，肯詹宁斯和布拉德鲁特。自然语言处理逐步开始步入人类生活。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144475.png" alt="img"></p>
<p>​    2015-2017，AlphaGo，谷歌Go的计算机程序，击败了各种（人类）冠军。当时名噪一时，为人工智能做了最好的技术营销。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144464.png" alt="img"></p>
<p>​    2015年，谷歌。发力自动驾驶，Waymo今天是自动驾驶排行第一名。当年满头青丝的Ernst Dickmanns，今天已是白发苍苍。下图右为Ernst Dickmanns。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144489.png" alt="img"></p>
<p>​    2015 年，沈向洋，微软亚洲研究院视觉计算组开发的基于深度卷积神经网络（CNN）的计算机视觉系统，在 ImageNet1000 这项视觉识别挑战中第一个超越人类视觉能力的计算机系统。2019年，沈向洋离开微软，成为清华大学双聘教授。这位来自南京，人工智能国际巨人，把中国的人工智能技术推向一个新的高度。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144595.png" alt="img"></p>
<p>​    2016，微软。组建“微软人工智能与研究事业部”(MicrosoftAI and Research Group)。人工智能是微软的梦想，1991年，盖茨先生就做过人工智能的预言。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144600.png" alt="img"></p>
<p>​        人工智能在模拟、仿真、游戏方面也有着广泛的应用，国内2015年以前，仿真领域是人工智能最核心的领域，以后逐渐向其它领域过渡。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144674.png" alt="img"></p>
<h3 id="6-1-2、启示"><a href="#6-1-2、启示" class="headerlink" title="6.1.2、启示"></a>6.1.2、启示</h3><p>​    2020年前后，人工智能迎来了高速发展期，2019年，人工智能元年。大数据、数据挖掘、机器学习等理论百花齐放，人工智能的时代终于到来了。</p>
<p>​    凝视这段历史时，早期的人工智能偏重于模拟仿真，没有实时性。摄像与视频技术的进步，人工智能向实时性发展，实时性有着重要意义，开启了人工智能社会应用新篇章。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144706.png" alt="img"></p>
<p>​    人工智能代表着大数据量的到来，没有大的数据量无法进行有效的分析，数据处理是人工智能的核心要素，数据处理今天由并行计算来完成。</p>
<p>​    大的数据量不仅对算法有要求，对算力也是一个考验。人工智能需要巨大的算力，没有算力谈不上人工智能。目前在人工智能初级阶段，科技公司算力主要靠CPU、GPU。大的科技公司靠超算中心、VPG、APU、TPU、NPU等来解决。大数据的超强能力，为人工智能的算力提供强有力的支持。</p>
<p>​    人工智能目前阶段两个主要表现，第一个是自然语言处理，第二个是机器视觉。自然文字符号和音视频是人类信息两个重要的载体。</p>
<p>​    机器视觉，很多年前，国外有一些公司在做，仅限于一些专业领域。90年代进入国内后，中科院物理所引进国外专业相机，结合国内应用，开发出相关检测系统。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144737.png" alt="img"></p>
<p>​    新的硬件与显示标准对智能视觉处理有着很大推动，随着并行计算的发展。可以坚信的是，视觉智能是未来人工智能发展的重要方向。</p>
<h2 id="6-2、硬件发展"><a href="#6-2、硬件发展" class="headerlink" title="6.2、硬件发展"></a>6.2、硬件发展</h2><p>​    人工智能时代需要硬件的支持，不仅仅是外设，更是数据计算。在此需求下，不仅外设的繁荣，更是芯片技术的爆发。</p>
<p>​    芯片技术为智能处理提供了基础，在数据阶段处理，为CPU、GPU提供物理计算基础，在此基础上，有了并行计算架构。无论云平台、大数据、机器学习、区块链无一不是建立在并行计算的基础上。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147639.jpeg" alt="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3453621467,281658853&amp;fm=26&amp;gp=0.jpg"></p>
<p>​    60年代，中国挥剑斩芯片，丧失发展先机。今天，倾国之力，十万亿级投资，发展芯片，留给我们多少启示。</p>
<p>​    下面通过芯片、相机传感器硬件角度讲述，其它层面参考相关资料。智能时代的机器视觉视频来自于相机，考虑了相机因素。</p>
<h3 id="6-2-1、AI-AR-VR芯片"><a href="#6-2-1、AI-AR-VR芯片" class="headerlink" title="6.2.1、AI&#x2F;AR&#x2F;VR芯片"></a>6.2.1、AI&#x2F;AR&#x2F;VR芯片</h3><p>​    人工智能首先是硬件技术的进步，硬件技术的核心是芯片。芯片技术是集成电路的高度封装。芯片技术是半导体技术的体现，整个生产过程与产业链较长，需要多家公司合作才能完成。</p>
<p>​    顶级科技公司钟情于芯片研发，包括AI&#x2F;AR&#x2F;VR芯片研发。微软、特斯拉、英伟达、facebook、谷歌、NXP、华为等。人工智能时代的到来，芯片的多样性与功能性都有很大变化。技术的风起云涌，为芯片制造提供了契机。</p>
<p>​    人工智能时代，AI&#x2F;AR&#x2F;VR芯片快速发展，为人工智能提供澎湃动力支持。芯片技术是人工智能后续阶段的关键技术，没有芯片技术的进步，人工智能将会举步不前。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147689.png" alt="img"></p>
<h3 id="6-2-2、相机芯片"><a href="#6-2-2、相机芯片" class="headerlink" title="6.2.2、相机芯片"></a>6.2.2、相机芯片</h3><p>​    相机，记录着社会文明。相机，留存着社会点滴。相机，助力着生产生活。相机，是机器视觉第一步的表达。</p>
<p>​    整个视频处理流程，相机是前端，机器视觉部分处理在前端实现。学习机器视觉，有必要对相机简单了解。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147646.png" alt="img"></p>
<p>​        对于工业视频而言，相机是重中之重，相机技术有很多分类。本部分通过传统相机和工业相机进行讲述。</p>
<h4 id="6-2-2-1、传统相机"><a href="#6-2-2-1、传统相机" class="headerlink" title="6.2.2.1、传统相机"></a>6.2.2.1、传统相机</h4><p>​    相机技术发展多年，主要是图像传感器的发展，目前分为CCD和CMOS两种。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147725.png" alt="img"></p>
<h5 id="6-2-2-1-1、CCD"><a href="#6-2-2-1-1、CCD" class="headerlink" title="6.2.2.1.1、CCD"></a>6.2.2.1.1、CCD</h5><p>​    CCD芯片是将光信号转换成电信号的芯片，在数码相机、摄像机中，光信号转换成电信号，然后处理，编程数码照片文件。</p>
<p>​    CCD芯片，使用高感光度的半导体材料制成，把光线转变成电荷，通过模数转换器芯片转换成数字信号，数字信号经过压缩后由相机内部的存储设备保存，然后把数据传输给计算机，借助于计算机的处理手段，根据需要和想像来修改图像。</p>
<p>​    CCD芯片由感光单位组成，通常以百万像素为单位。CCD表面受到光线照射时，每个感光单位会将电荷反映在组件上，所有的感光单位所产生的信号加在一起，构成了一幅完整的画面。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147694.png" alt="img"></p>
<p>​    CCD图像传感器是按一定规律排列的mos（金属—氧化物—半导体）电容器组成的阵列，在p型或n型硅衬底上生长一层很薄（约120nm）的二氧化硅，再在二氧化硅薄层上依次序沉积金属或掺杂多晶硅电极（栅极），形成规则的mos电容器阵列，再加上两端的输入及输出二极管就构成了CCD芯片。</p>
<h5 id="6-2-2-1-2、CMOS"><a href="#6-2-2-1-2、CMOS" class="headerlink" title="6.2.2.1.2、CMOS"></a>6.2.2.1.2、CMOS</h5><p>​    CMOS相机采用CMOS图像传感器的设备。CMOS一般应用在普通数码设备中，CCD一般应用高档数码设备中，CCD比CMOS单位成像的效果要好。CCD镜头比CMOS分辨率要高。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147761.png" alt="img"></p>
<p>​    CCD和CMOS在制造上的主要区别是CCD是集成在半导体单晶材料上，而CMOS是集成在被称做金属氧化物的半导体材料上。CCD只有少数几个厂商索尼、松下等掌握这种技术。CCD制造工艺较复杂，采用CCD的摄像头价格昂贵。</p>
<p>​    相同像素下CCD的成像通透性、明锐度都很好，色彩还原、曝光可以保证基本准确。CMOS由于低廉的价格以及高度的整合性，因此在摄像头领域还是得到了广泛的应用。</p>
<p>​    CMOS的信号是以点为单位的电荷信号，而CCD是以行为单位的电流信号，前者更为敏感，速度也更快，更为省电。高级的CMOS并不比一般CCD差，CMOS工艺还不是十分成熟，普通的CMOS一般分辨率低而成像较差。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147893.png" alt="img"></p>
<p>​    CCD或CMOS，基本上都是利用矽感光二极体进行光与电的转换。光线越强、电力越强；反之，光线越弱、电力也越弱的道理，将光影像转换为电子数字信号。</p>
<p>​    CCD每曝光一次，在快门关闭后进行像素转移处理，将每一行中每一个像素（pixel）的电荷信号依序传入“缓冲器”中，由底端的线路引导输出至CCD旁的放大器进行放大，再串联ADC输出；相对地，CMOS的设计中每个像素旁就直接连着ADC（放大兼类比数字信号转换器），信号直接放大并转换成数字信号。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147035.png" alt="img"></p>
<p>​    CCD的充分保持信号传输时不失真，透过每一个像素集合至单一放大器上再做统一处理，保持资料的完整性；CMOS制程简单，没有专属通道，必须先放大再整合各个像素资料。</p>
<p>​    由于CMOS每个像素包含了放大器与A&#x2F;D转换电路，过多的额外设备压缩单一像素的感光区域的表面积，因此相同像素下，同样大小之感光器尺寸，CMOS的感光度会低于CCD。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147982.png" alt="img"></p>
<p>​    CMOS应用半导体工业常用的MOS制程，一次整合全部周边设施于单晶片中，节省加工晶片所需负担的成本和良率的损失；CCD采用电荷传递的方式输出资讯，必须另辟传输通道，如果通道中有一个像素故障（Fail），就会导致一整排的讯号壅塞，无法传递。</p>
<p>​    CMOS每个感光二极体旁都搭配一个ADC放大器，如果以百万像素计，需要百万个以上的ADC放大器，虽然是统一制造下的产品，每个放大器或多或少都有些微的差异存在，很难达到同步放大的效果，对比单一个放大器的CCD，CMOS最终计算出的噪点就比较多。</p>
<p>​    市场销售的数码摄像头中以CMOS感光器件的为主。在采用CMOS为感光元器件的产品中，采用影像光源自动增益补强技术，自动亮度、白平衡控制技术，色饱和度、对比度、边缘增强以及伽马矫正等先进的影像控制技术，完全可以达到与CCD摄像头相媲美的效果。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147015.png" alt="img"></p>
<p>​    尽管CCD在影像品质等方面均优于CMOS，不可否认的CMOS具有低成本、低耗电以及高整合度的特性。CMOS的低成本和稳定供货，所以广泛使用，制造技术不断地改良更新，使得CCD与CMOS两者的差异逐渐缩小。</p>
<h4 id="6-2-2-2、工业相机"><a href="#6-2-2-2、工业相机" class="headerlink" title="6.2.2.2、工业相机"></a>6.2.2.2、工业相机</h4><p>​    工业相机是机器视觉系统中的关键组件，本质功能就是将光信号转变成有序的电信号。选择合适的相机也是机器视觉系统设计中的重要环节，相机的选择不仅直接决定所采集到的图像分辨率、图像质量等，同时与整个视觉系统的运行模式直接相关。 </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147005.jpeg" alt="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1608566505281&amp;di=7b7d2283ab97792c4f33165fd0252355&amp;imgtype=0&amp;src=http%3A%2F%2Fa.img.youboy.com%2Fcoimg%2F2010%2F4%2F16%2Fg3_2764572.jpg"></p>
<p>​    工业相机俗称摄像机，相比于传统的民用相机（摄像机）而言，它具有高的图像稳定性、高传输能力和高抗干扰能力等，市面上工业相机大多是基于CCD（Charge Coupled Device）或CMOS（Complementary Metal Oxide Semiconductor）芯片的相机。</p>
<p>​    CCD是目前机器视觉常用的图像传感器。它集光电转换及电荷存贮、电荷转移、信号读取于一体，是典型的固体成像器件。突出特点是以电荷作为信号，不同于其它器件是以电流或者电压为信号。通过光电转换形成电荷包，而后在驱动脉冲的作用下转移、放大输出图像信号。典型的CCD相机由光学镜头、时序及同步信号发生器、垂直驱动器、模拟&#x2F;数字信号处理电路组成。CCD作为一种功能器件，与真空管相比，具有无灼伤、无滞后、低电压工作、低功耗等优点。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147051.png" alt="img"></p>
<p>​    CMOS图像传感器的开发最早出现在20世纪70 年代初，90 年代初期，超大规模集成电路 (VLSI)制造工艺技术的发展，CMOS图像传感器得到迅速发展。CMOS图像传感器将光敏元阵列、图像信号放大器、信号读取电路、模数转换电路、图像信号处理器及控制器集成在一块芯片上，还具有局部像素的编程随机访问的优点。CMOS图像传感器以其良好的集成性、低功耗、高速传输和宽动态范围等特点得到了广泛的应用。</p>
<p>​    工业视觉离不开相机的支持，在一些高端领域，必须用工业相机来处理。工业相机是民用相机的增强版，本质依然采用CCD或者CMOS技术。相对民用相机，用更高的软硬件配置，更大的功耗获得更好的质量。</p>
<h3 id="6-2-2-3、总结"><a href="#6-2-2-3、总结" class="headerlink" title="6.2.2.3、总结"></a>6.2.2.3、总结</h3><p>​    人工智能图像处理，工业上，对高清晰照片进行处理。其它领域，是消费级的处理。技术的进步，高清晰相机在消费级市场应用，高清照片的消费级技术处理将会显现。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147242.png" alt="img"></p>
<p>​    工业视频的处理靠高端硬件实现，消费级高清视频的处理，还需要新的技术框架支持。在未来几年将有新的机会出现。</p>
<h2 id="6-3、机器视觉"><a href="#6-3、机器视觉" class="headerlink" title="6.3、机器视觉"></a>6.3、机器视觉</h2><p>​    机器视觉是人工智能快速发展的一个分支，也是智能视觉重要的一部分。机器视觉就是用机器代替人眼来做测量和判断。</p>
<p>​    机器视觉系统通过机器视觉产品(即图像摄取装置，分CMOS和CCD两种)将被摄取目标转换成图像信号，传送给专用的图像处理系统，得到被摄目标的形态信息。根据像素分布和亮度、颜色等信息，转变成数字化信号;图像系统对这些信号进行各种运算来抽取目标的特征，进而根据判别的结果控制现场的设备动作。 </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147722.png" alt="img"></p>
<p>​    机器视觉是一项综合技术，包括图像处理、机械工程技术、控制、电光源照明、光学成像、传感器、模拟与数字视频技术、计算机软硬件技术(图像增强和分析算法、图像卡、 I&#x2F;O卡等)。</p>
<p>​    很多年前，机器视觉就在广泛应用。目前，在深度和广度方面拓展。未来10年，机器视觉对人类生活，将会有革命性的变化。</p>
<p>​    机器视觉是一门技术，机器视觉系统是技术的应用，下一主题，我们讲述机器视觉系统。</p>
<h2 id="6-4、机器视觉系统"><a href="#6-4、机器视觉系统" class="headerlink" title="6.4、机器视觉系统"></a>6.4、机器视觉系统</h2><p>​    一个典型的机器视觉应用系统包括图像捕捉、光源系统、图像数字化模块、数字图像处理模块、智能判断决策模块和机械控制执行模块。</p>
<p>​    机器视觉系统基本的特点就是提高生产的灵活性和自动化程度。在不适于人工作业的危险工作环境或者人工视觉难以满足要求的场合，用机器视觉来替代人工视觉。在大批量重复性工业生产中，用机器视觉检测方法提高生产的效率和自动化程度。 </p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147712.png" alt="img"></p>
<p>​    机器视觉系统提高生产的柔性和自动化程度。在一些不适合人工作业的危险工作环境或人工视觉难以满足要求的场合，常用机器视觉来替代人工视觉；同时在大批量工业生产过程中，用人工视觉检查产品质量效率低且精度不高，用机器视觉检测方法大大提高生产效率和自动化程度。机器视觉易于实现信息集成，是实现计算机集成制造的基础技术之一。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147680.jpeg" alt="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1608562528401&amp;di=e64ba214572a7b1d069c2c1c0522dc5c&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.mv186.com%2Fuploads%2Fimage%2F20150902%2F1441176652869171.png"></p>
<p>​    工业机器视觉系统包括：光源、镜头（定焦镜头、变倍镜头、远心镜头、显微镜头）、 相机（包括CCD相机和COMS相机）、图像处理单元（或图像捕获卡）、图像处理软件、监视器、通讯 &#x2F; 输入输出单元等。</p>
<p>​    机器视觉检测系统采用CCD照相机将被检测的目标转换成图像信号，传送给专用的图像处理系统，依据像素分布和亮度、颜色等信息，转变成数字化信号，图像处理系统对这些信号进行各种运算来抽取目标的特征，如面积、数量、位置、长度，再根据预设的允许度和其它条件输出结果，包括尺寸、角度、个数、合格&#x2F;不合格、有&#x2F;无等，实现自动识别功能。</p>
<p>​    目前，机器视觉系统主要应用在工业生产领域，互联网应用正在兴起，在居家生活应用上方兴未艾。</p>
<h2 id="6-5、计算机视觉"><a href="#6-5、计算机视觉" class="headerlink" title="6.5、计算机视觉"></a>6.5、计算机视觉</h2><p>​    计算机视觉是研究如何使机器“看”的科学，用摄影机和电脑代替人眼对目标进行识别、跟踪和测量等，并进一步做图形处理，使电脑处理更适合人眼观察或传送给仪器检测的图像。计算机视觉可以看作，如何使人工系统从图像或多维数据中“感知”的科学。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147700.png" alt="img"></p>
<p>​    计算机视觉是一门关于如何运用照相机和计算机来获取我们所需的，被拍摄对象的数据与信息的学问。形象地说，就是给计算机安装上眼睛（照相机）和大脑（算法），让计算机能够感知环境。</p>
<p>​    计算机视觉既是工程领域，也是科学领域中重要研究领域。计算机视觉是一门综合性的学科，吸引了众多研究者参加到对它的研究之中。包括计算机科学和工程、信号处理、物理学、应用数学和统计学，神经生理学和认知科学等。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147672.png" alt="img"></p>
<p>​    计算机视觉开始于60年代初，80年代取得很多重大进展。计算机视觉与人类视觉密切相关，对人类视觉有正确的认识对计算机视觉的研究非常有益。</p>
<p>​    计算机视觉用各种成像系统代替视觉器官作为输入敏感手段，由计算机来代替大脑完成处理和解释。计算机视觉的研究目标就是使计算机象人那样通过视觉观察和理解世界，具有自主适应环境的能力。</p>
<p>​    计算机视觉根据计算机系统的特点进行视觉信息处理。迄今为止人类视觉系统，是功能最强大和完善的视觉系统。对人类视觉处理机制的研究将给计算机视觉的研究提供启发和指导。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147682.jpeg" alt="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.zhimg.com%2Fv2-5f3ab881181f49338b21dfa143f8bffc_b.jpg&amp;refer=http%3A%2F%2Fpic1.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1615908110&amp;t=0cc3aa72b4535c39f9657f6823f990b2"></p>
<p>​    计算机信息处理的方法是研究人类视觉的机理，建立人类视觉计算理论。称为计算视觉（Computational Vision）。计算视觉是计算机视觉中的一个研究领域。</p>
<p>​    计算机视觉和机器视觉的定义有很多认知的区别，很多文献中有不同的论述，笔者认为，两者都是人工智能的分支，侧重点不一样。在今天学术领域，都没有严格的定义。</p>
<h2 id="6-6、智能时代软件发展"><a href="#6-6、智能时代软件发展" class="headerlink" title="6.6、智能时代软件发展"></a>6.6、智能时代软件发展</h2><p>​    天下事物发展一分为二，软硬件技术也不例外，第二次工业革命电磁理论，石破天惊，在后期推动了计算机技术的进步。为第四次科技革命的发展做好了硬件的铺垫。在硬件大力发展背后，智能时代软件的号角吹响了。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148933.png" alt="img"></p>
<p>​    人类在智能科技方面的探索没有终点，也很难找到起点。人工智能探索过程中，软件方面有着天翻地覆的变化，下面从编程语言、运算平台、机器学习库等方面分别进行阐述。</p>
<h3 id="6-6-1、人工智能编程语言"><a href="#6-6-1、人工智能编程语言" class="headerlink" title="6.6.1、人工智能编程语言"></a>6.6.1、人工智能编程语言</h3><p>​    人工智能编程语言是一类适应于人工智能和知识工程领域的、具有符号处理和逻辑推理能力的计算机程序设计语言。能够用它来编写程序求解非数值计算、知识处理、推理、规划、决策等具有智能的各种复杂问题。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148892.jpeg" alt="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1385822726,935678861&amp;fm=26&amp;gp=0.jpg"></p>
<p>​    事实上，已经有多种对应于各种不同知识表示方式的人工智能编程语言。按所对应的知识表示方式不同。可以区分为以下几类：</p>
<p>​    A、对应于产生式规则知识表示的语言。例如，由美国卡耐基·梅农大学的C·L·福基（C。L。Forgy）等人1977年开发的OPS(official production system)，当时用它来为DEC公司开发了一个解决VAX计算机系统配置问题的专家系统X1&#x2F;XCON。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148938.png" alt="img"></p>
<p>​    B、对应于逻辑公式知识表示的语言。一种已广为应用的逻辑语言就是PROLOG。1970年由法国马塞大学的 A。柯迈豪埃(Alain Colmerauer)所开发的。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148894.png" alt="img"></p>
<p>​    C、对应于框架或语义网知识表示的语言。这是“面向对象”的(object-oriented)语言。其中一个有代表性的语种就是Smalltalk。1980年首创，后来版本不断更新。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148927.png" alt="img"></p>
<p>​    D、对应于函数知识表示或函数式程序设计风格的语言的列表处理语言。函数式编程语言，理论上很完美，建立在坚实的数学基础之上，对于人工智能问题，在常规计算机上很难实现。20世纪50年代末，麻省理工学院的约翰·麦卡锡等人首先开发的列表处理语言LISP（LISt Processing）迄今仍然广泛用于编写人工智能应用程序，特别是用于开发专家系统。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148886.jpeg" alt="https://ss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/baike/w%3D268%3Bg%3D0/sign=cd791b07708b4710ce2ffacafbf5a4c0/1b4c510fd9f9d72a1781f33bd62a2834349bbb2b.jpg"></p>
<p>​    人工智能编程语言有共同特点，语言都面向要解决的问题、结合知识表示、完全脱离当代计算机的诺依曼结构特性而独立设计的；处于比面向过程的高级编程语言更高的抽象层次。</p>
<p>​    用这些语言编写的程序，在现代计算机环境中，无论是解释或编译执行，往往效率很低。尤其程序规模很大、复杂时，浪费大量系统资源，系统性能往往会下降到难以容忍的地步。 </p>
<h4 id="6-6-1-1、LISP"><a href="#6-6-1-1、LISP" class="headerlink" title="6.6.1.1、LISP"></a>6.6.1.1、LISP</h4><p>​    20世纪50年代后期，麻省理工学院的John McCarthy就开始了人工智能的研究，当时致力于设计一个用表处理的递归系统，在20世纪60年代初研制出了LISP语言。</p>
<p>​    LISP语言是一个用于处理符号表达式的、相当简单的函数式程序设计语言，以数学中的函数与函数作用的概念作为设计原理，奠定了函数式语言的基础。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148104.png" alt="img"></p>
<p>​    LISP语言是完全非von Neumann风格的，它没有使用ALGOL60等语言中所采用的可修改变量、赋值语句、转向语句等von Neumann结构语言中的有关概念。LISP程序与其数据结构采用了相同的结构形式与处理方式。</p>
<p>​    LISP方便地编写解释程序。LISP语言除了用s一表达式来统一处理数据与程序外，还引入了前缀运算符表示法、递归数据结构、递归控制结构以及新的条件表达式形式。</p>
<h4 id="6-6-1-2、Prolog"><a href="#6-6-1-2、Prolog" class="headerlink" title="6.6.1.2、Prolog"></a>6.6.1.2、Prolog</h4><p>​    Prolog(Programming in Logic)是一种逻辑编程语言，建立在逻辑学的理论基础之上，最初被运用于自然语言等研究领域。现已广泛应用在人工智能的研究中，可以用来建造专家系统、自然语言理解、智能知识库等。</p>
<p>​    对一些应用程序的编写很有帮助，能够比其它语言更快速开发程序，Prolog的编程方法更像是使用逻辑语言来描述程序。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148111.png" alt="img"></p>
<p>​    Prolog具有鲜明的逻辑编程语言特色，包括：没有特定的运行顺序，运行顺序是由计算机决定的，而不是程序员；程序中没有if、when、case、for这样的控制流程语句；Prolog程序和数据高度统一，其程序实际上是一个智能数据库；具有强大的递归功能。</p>
<p>​    1981年日本政府宣布第5代计算机系统(FGCS)项目以Prolog为基础语言以来，Prolog成为了人工智能研究领域的主导语言。</p>
<h4 id="6-6-1-3、OPS83"><a href="#6-6-1-3、OPS83" class="headerlink" title="6.6.1.3、OPS83"></a>6.6.1.3、OPS83</h4><p>​    OPS83是应用于专家系统的程序设计语言，支持OPS早期版本，也支持PASCAL或C这些常规程序设计语言所具有的过程设计能力。它不是对所有程序设计任务都适宜，OPS83较之OPS的早期版本，对许多问题处理的更目然、更有效。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148162.png" alt="img"></p>
<p>​    OPS是由美国宾夕法尼亚州卡内基一梅隆大学的C.L.Forgy等人开发。最早版本是在1975年开发的，之后几经修改形成了OPSl、OPS2(1978)、OPS4(1979)、OPS5(1981)多种版本，1986年出现了OPS83。 </p>
<p>​    OSP83采用产生式系统的知识表示模式和正向精确推理方式。它提供了两种交互环境：一是和用户的界面；二是和知识工程师的界面(调试环境)。OPS83包括三个主要部分：知识库、推理机和工作存贮器。</p>
<p>​    知识库又称规则库。每条规则均以0PS83语言来表示。OPS83的推理过程由若干“识别一动作”周期组成。每个周期包括三个动作或阶段：匹配、冲突解决(或选择)和执行。</p>
<p>​    匹配是数据和已有规则的匹配。匹配的结果形成了冲突集。是所有满足条件的规则的集合。然后，推理机从冲突集中选择规则执行。工作存贮器(Work Memory，WM)用来存贮推理机在推理过程中的初始状态、中间状态和目标等信息。</p>
<p>​    各个模块可作为独立的文件存放在存贮器中，单独编译，然后连接在一起运行。数据类型、语句、子程序等与一般程序设计语言类似，使用OPS83的知识工程师有一个类似于过程描述型语言的编程环境。</p>
<h4 id="6-6-1-4、Python"><a href="#6-6-1-4、Python" class="headerlink" title="6.6.1.4、Python"></a>6.6.1.4、Python</h4><p>​    1989年圣诞节期间，荷兰人吉多·范罗苏姆（Guido van Rossum），在阿姆斯特丹，为了打发圣诞节的无趣，决心开发一个新的脚本解释程序，作为ABC语言的继承。还受到了Modula-3的影响，结合了Unix shell和C的习惯。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148214.png" alt="img"></p>
<p>​    Guido本人看来，ABC语言优美强大，为非专业程序员设计。但是ABC语言并没有成功，究其原因，Guido认为是其非开放造成的。Guido在Python中避免这一错误。同时，他还想实现在ABC中闪现过但未曾实现的东西。</p>
<p>​    Python语法和动态类型，以及解释型语言的本质，使它成为多数平台上写脚本和快速开发应用的编程语言，随着版本的更新和语言新功能的添加，逐渐被用于独立的、大型项目的开发。</p>
<p>​    Python解释器易于扩展，可以使用C或C++（或者其它可以通过C调用的语言）扩展新的功能和数据类型。Python 也可用于可定制化软件中的扩展程序语言。丰富的标准库，提供了适用于各个主要系统平台的源码或机器码。</p>
<p>​    由于Python语言的简洁性、易读性以及可扩展性，在国内外用Python做科学计算的研究机构日益增多，很多知名大学已经采用Python来教授程序设计课程。例如卡耐基梅隆大学、麻省理工学院等。</p>
<p>​    众多开源的科学计算软件包都提供了Python的调用接口，例如著名的计算机视觉库OpenCV、三维可视化库VTK、医学图像处理库ITK。Python专用的科学计算扩展库十分流行，例如如下3个经典的科学计算扩展库：NumPy、SciPy和matplotlib，它们分别为Python提供了快速数组处理、数值运算以及绘图功能。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148197.png" alt="img"></p>
<p>​    Python语言及其众多的扩展库所构成的开发环境适合工程技术、科研人员处理实验数据、制作图表，甚至开发科学计算应用程序，并可用于机器学习领域。</p>
<p>​    让人惊奇的是，Python今天成为人工智能应用层上最主要的外部接口，尤其在图形图像领域，使用尤其广泛，例如TensorFlow和PyTorch等。这应该是Guido所不曾想到的。</p>
<h3 id="6-6-1-4、启示"><a href="#6-6-1-4、启示" class="headerlink" title="6.6.1.4、启示"></a>6.6.1.4、启示</h3><p>​    诚然，编程语言很多，描述这段历史时，应该认识到的是，不同的编程语言与当时的硬件环境、软件理论相照应。在今天，只需要一概而过，对于深度研发，有一定认知的必要。</p>
<p>​    人工智能是一场科技革命，不仅仅是理论的发展，更是实践的应用，随着硬件技术的进步，人工智能理念的变幻，软件方面也将有很大的发展。</p>
<p>​    编程语言发展上，人工智能有很大的发展，编程语言与硬件系统紧密结合，编程语言与框架模式协作并行，才会有更大的突破。在未来，人工智能方面编程语言的发展，有这样三个思索。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148251.png" alt="img"></p>
<p>​    A、研制与某种语言完全适应的新一代计算机。例如LlSP机、数据流机、PROLOG机、面向对象的体系结构等。但举步维艰、前景渺茫。以诺依曼机为核心的现代通用计算机已经广泛普及而且性能不断提高，积累了巨大的软件资源。任何与现代计算机不兼容的专用机，最多满足特殊需求，难以与现代通用计算机抗衡。在没有很大商业机会的前提下，这种办法是不可能实现的。</p>
<p>​    B、把不同风格的编程语言结合起来，发展复合语言或嵌入式语言，取长补短，使系统性能得以进一步提高。把面向对象语言的设计思路融汇到常用的面向过程的高级语言中。C++语言就是一个突出的例子。这种改变相对来说影响较小，毕竟不是脱胎换骨。</p>
<p>​    C、用面向问题的人工智能编程语言的特点，先选择某种语言编写出一个简洁明了而易于调试的程序原型。通过验证、调试，再仿照这个原型，改编为某种面向过程的高级语言程序，例如C或C++，达到提高最终应用系统开发质量和执行效率的目的。用PROLOG、 LISP、OPS等来开发专家系统原型，已有不少先例。在技术变幻的前提下，这种方式有一定的价值。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148324.jpeg" alt="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1263603027,3603698295&amp;fm=26&amp;gp=0.jpg"></p>
<p>​    计算机发展史上，基于冯·诺伊曼的硬件系统很难发生变化，计算机编程语言的发展从未停止。我们得到一个启示，思想最容易在软件方面实现，而计算机编程语言的发展也就不足为奇。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148373.png" alt="img"></p>
<p>​    关于计算机体系结构的发展，有一定价值的是，在未来，量子计算机的体系结构将会是一个重要的方向。随着量子技术的进步，对于商业而言，再次掀起市场的沧海桑田，腥风血雨。</p>
<h3 id="6-6-3、机器学习库"><a href="#6-6-3、机器学习库" class="headerlink" title="6.6.3、机器学习库"></a>6.6.3、机器学习库</h3><p>​    机器学习是人工智能的重要组成部分，机器学习是一个完善的生态环境，对于人工智能而言，算法库是重中之重。降低了智能视觉分析的门槛，加大了人工智能的应用。人工智能算法库有很多，本部分重点讨论应用广泛的两个神经网络库，TensorFlow和PyTorch。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148162.png" alt="img"></p>
<p>​    神经网络可以指向两种，一个是生物神经网络，一个是人工神经网络。</p>
<h4 id="6-6-3-1、生物神经网络"><a href="#6-6-3-1、生物神经网络" class="headerlink" title="6.6.3.1、生物神经网络"></a>6.6.3.1、生物神经网络</h4><p>​    生物神经网络：一般指生物的大脑神经元，细胞，触点等组成的网络，用于产生生物的意识，帮助生物进行思考和行动。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148129.jpeg" alt="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1907824141,1397086773&amp;fm=26&amp;gp=0.jpg"></p>
<h4 id="6-6-3-2、人工神经网络"><a href="#6-6-3-2、人工神经网络" class="headerlink" title="6.6.3.2、人工神经网络"></a>6.6.3.2、人工神经网络</h4><p>​    人工神经网络（Artificial Neural Networks，简写为ANNs）也简称为神经网络（NNs）或称作连接模型（Connection Model），它是一种模仿动物神经网络行为特征，进行分布式并行信息处理的算法数学模型。这种网络依靠系统的复杂程度，通过调整内部大量节点之间相互连接的关系，从而达到处理信息的目的。</p>
<p>​    人工神经网络：是一种应用类似于大脑神经突触联接的结构进行信息处理的数学模型。在工程与学术界也常直接简称为“神经网络”或类神经网络。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148142.png" alt="img"></p>
<p>​    人工神经网络（Artificial Neural Network，即ANN ），是20世纪80 年代以来人工智能领域兴起的研究热点。它从信息处理角度对人脑神经元网络进行抽象， 建立某种简单模型，按不同的连接方式组成不同的网络。在工程与学术界也常直接简称为神经网络或类神经网络。神经网络是一种运算模型，由大量的节点（或称神经元）之间相互联接构成。</p>
<p>​    每个节点代表一种特定的输出函数，称为激励函数（activation function）。每两个节点间的连接都代表一个对于通过该连接信号的加权值，称之为权重，这相当于人工神经网络的记忆。网络的输出则依网络的连接方式，权重值和激励函数的不同而不同。而网络自身通常都是对自然界某种算法或者函数的逼近，也可能是对一种逻辑策略的表达。</p>
<h4 id="6-6-3-3、TensorFlow"><a href="#6-6-3-3、TensorFlow" class="headerlink" title="6.6.3.3、TensorFlow"></a>6.6.3.3、TensorFlow</h4><p>​    TensorFlow™是基于数据流编程（dataflow programming）的符号数学系统，在人工智能领域，有这广泛的应用。TensorFlow是今天神经网络训练的主要平台，成就了TensorFlow在今天庞大的用户群。</p>
<p>​    用于各类机器学习（machine learning），前身是谷歌的神经网络算法库DistBelief 。谷歌不仅在大数据领域有着重要的位置，在人工智能方面，谷歌也名列前茅。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148170.png" alt="img"></p>
<p>​    Tensorflow拥有多层级结构，使用面向各种场景，可部署于各类服务器、PC终端和网页，支持GPU和TPU高性能数值计算，开发环境友好。应用于谷歌内部的产品开发和各领域的科学研究 。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148229.png" alt="img"></p>
<h5 id="6-6-3-3-1、发展"><a href="#6-6-3-3-1、发展" class="headerlink" title="6.6.3.3.1、发展"></a>6.6.3.3.1、发展</h5><p>​    TensorFlow由谷歌人工智能团队谷歌大脑（Google Brain）开发和维护，是谷歌核心的人工智能项目。拥有很多子项目：TensorFlow Hub、TensorFlow Lite、TensorFlow Research Cloud、各类应用程序接口。</p>
<p>​    谷歌大脑2011年成立，开展面向大规模深度学习应用研究，谷歌大脑具有自我学习功能，将1.6万处理器连接。TensorFlow的前身DistBelief。DistBelief构建各尺度下的神经网络分布式学习和交互系统，被称为“第一代机器学习系统”，为世界人工智能发展做出了卓越的贡献。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148176.jpeg" alt="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2190712454,4261596438&amp;fm=26&amp;gp=0.jpg"></p>
<p>​    DistBelief在谷歌和Alphabet旗下公司的产品开发中广泛使用，成果颇丰。TensorFlow拥有生态系统，从数据训练，接口导出，到工程应用。2018年4月的TensorFlow开发者峰会，有21个TensorFlow项目非常有价值和意义 。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148400.png" alt="img"></p>
<h5 id="6-6-3-3-2、核心组件"><a href="#6-6-3-3-2、核心组件" class="headerlink" title="6.6.3.3.2、核心组件"></a>6.6.3.3.2、核心组件</h5><p>​    TensorFlow利用GPU做数据训练，可以进行单机也可以进行分布式部署。</p>
<p>​    合作组件互相配合，保证了TensorFlow的运转。分布式TensorFlow的核心组件如下：</p>
<p>​    分发中心（distributed master）；</p>
<p>​    执行器（dataflow executor&#x2F;worker service）；</p>
<p>​    内核应用（kernel implementation）</p>
<p>​    最底端的设备层（device layer）&#x2F;网络层（networking layer）。</p>
<p>​    分发中心从输入的数据流图中剪取子图（subgraph），将其划分为操作片段并启动执行器。分发中心处理数据流图时会进行预设定的操作优化，包括公共子表达式消去（common subexpression elimination）、常量折叠（constant folding）等。</p>
<p>​    执行器负责图操作（graph operation）在进程和设备中的运行、收发其它执行器的结果。分布式TensorFlow拥有参数器（parameter server）以汇总和更新其它执行器返回的模型参数。执行器在调度本地设备时会选择进行并行计算和GPU加速 。</p>
<p>​    内核应用负责单一的图操作，包括数学计算、数组操作（array manipulation）、控制流（control flow）和状态管理操作（state management operations）。内核应用使用Eigen执行张量的并行计算、cuDNN库等执行GPU加速、gemmlowp执行低数值精度计算，此外用户可以在内核应用中注册额外的内核（fused kernels）以提升基础操作，例如激励函数和其梯度计算的运行效率。</p>
<p>​    单进程TensorFlow相对简单，整体部署训练与方便，和分布式相比，维护也很方便。没有分发中心和执行器，使用特殊的会话应用（Session implementation）联系本地设备。</p>
<p>​    TensorFlow的内核是C语言的，提供的原始接口也是C语言的。其它组件&#x2F;API均通过C语言API与核心组件进行交互。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148396.jpeg" alt="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=974600695,3576740431&amp;fm=15&amp;gp=0.jpg"></p>
<h5 id="6-6-3-3-3、组件"><a href="#6-6-3-3-3、组件" class="headerlink" title="6.6.3.3.3、组件"></a>6.6.3.3.3、组件</h5><p>​    TensorFlow Hub是一个允许用户发布、共享和使用TensorFlow模块的库开发项目。用户可以将TensorFlow数据流图或其部分使用Hub进行封装并移植到其它问题中再次利用。TensorFlow Hub页面列出了由谷歌和DeepMind提供的封装模型，其主题包括字符嵌入、视频分类和图像处理。</p>
<p>​    TensorFlow Extended (TFX)，TFX是谷歌基于TensorFlow开发的产品级机器学习平台，其目标是是对产品开发中的模型实现、分析验证和业务化操作进行整合，在实时数据下完成机器学习产品的标准化生产。TFX包含三个算法库：TensorFlow Data Validation对机器学习数据进行统计描述和验证、TensorFlow Transform对模型数据进行预处理、        TensorFlow Model Analysis对机器学习模型进行分析，提供表现评分。另有TensorFlow Serving作为模型业务化的高性能系统，提供模型接口和管理。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148449.png" alt="img"></p>
<p>​    TensorFlow Probability (TFP)，TFP是在TensorFlow Python API基础上开发的统计学算法库，其目标是方便用户将概率模型和深度学习模型相结合使用。TFP包含大量概率分布的生成器、支持构建深度网络的概率层（probabilistic layers）、提供变分贝叶斯推断（Variational inference）和马尔可夫链蒙特卡罗方法（Markov chain Monte Carlo）和一些特殊的优化器，包括Nelder-Mead方案、BFGS算法（Broyden-Fletcher-Goldfarb-Shanno algorithm）和SGLD（Stochastic Gradient Langevin Dynamics）。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148432.png" alt="https://www.yht7.com/upload/image/20200419/1354575-20200418172212742-1807272001.png"></p>
<p>​    TensorFlow.js是TensorFlow的JavaScript API，主要用于网页端的机器学习应用开发。方便网页用户进行人工智能数据训练。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148452.png" alt="img"></p>
<p>​    TensorFlow Lite是为移动和嵌入式设备提供人工智能支持，在Android、iOS系统下机器学习模型的响应时间并降低文件大小。TensorFlow Lite部署了大部分人工智能算法，具有很好的参考价值。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148537.png" alt="img"></p>
<p>​    Swift for TensorFlow是开源版Swift的TensorFlow API开发项目，在深度学习和微分计算方面应用。和Eager Execution很相像，可直接执行数据流图，具备更好的性能。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148583.png" alt="img"></p>
<p>​    TensorFlow Research Cloud是面向科学研究的机器学习TPU云计算平台。该项目拥有1000个云TPU和总计180千万亿次计算力，每个TPU拥有64 GB的高带宽内存 。可以通过互联网申请使用，进行有价值的人工智能数据训练。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148715.png" alt="img"></p>
<h5 id="6-6-3-3-4、其它"><a href="#6-6-3-3-4、其它" class="headerlink" title="6.6.3.3.4、其它"></a>6.6.3.3.4、其它</h5><p>​    Magenta是在艺术领域使用机器学习的研究项目，该项目使用深度学习网络和强化学习算法学习生成音乐、绘画和其它艺术作品，以帮助艺术人员拓展其创作过程 。Magenta项目的研究成果包括音乐创作工具NSynth和混音工具MusicVAE。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148710.png" alt="img"></p>
<p>​    Nucleus是将TensorFlow应用于基因组文件，例如SAM和VCF格式文件的读写和分析的库开发项目 。Nucleus使用Python和C++进行开发。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148725.png" alt="img"></p>
<h4 id="6-6-3-2、PyTorch"><a href="#6-6-3-2、PyTorch" class="headerlink" title="6.6.3.2、PyTorch"></a>6.6.3.2、PyTorch</h4><p>​    PyTorch是一个开源的Python机器学习库，基于Torch，用于自然语言处理等应用程序。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148729.png" alt="img"></p>
<p>​    2017年1月，由Facebook人工智能研究院（FAIR）基于Torch推出了PyTorch。它是一个基于Python的计算包，提供两个高级功能：1、具有强大的GPU加速的张量计算（如NumPy）。2、包含自动求导系统的深度神经网络。</p>
<p>​    PyTorch使用Python重写了很多内容，更加灵活，支持动态图，提供了Python接口。它是由Torch7团队开发，是一个以Python优先的深度学习框架，实现强大的GPU加速，支持动态神经网络。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148793.jpeg" alt="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3593097388,1004973136&amp;fm=26&amp;gp=0.jpg"></p>
<p>​    PyTorch可以看作加入了GPU支持的numpy，也可以看成拥有自动求导功能的强大的深度神经网络。除Facebook外，已经被Twitter、CMU和Salesforce等机构采用。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148838.png" alt="img"></p>
<p>​    PyTorch简洁高效，快速应用的框架，设计追求最少封装，符合人类思维，让用户尽可能地专注于实现自己的想法，与google的Tensorflow类似，FAIR的支持足以确保PyTorch获得持续的开发更新。</p>
<p>  无论对于机器视觉，还是人工智能，相对从前，数据量发生了地覆天翻的变化。传统的运算框架不能满足现实的发展。人工智能影响不是一点一线，而是整个计算体系。</p>
<p>​    从AI&#x2F;AR&#x2F;VR芯片，到GPU数据处理，再到平台架构，框架编程，外部接口调用，都有巨大的变革。今天我们谈一下基于大批量数据的运算框架。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148028.png" alt="img"></p>
<p>​    GPU的参与数据处理已经多年，多年发展过程中，GPU不过是硬件的支持(如下图)，指令的提供，传统的工程师很难进行指令级的开发。所以，运算平台出现了，拓展了技术应用，便捷了软件开发。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148094.png" alt="http://attachbak.dataguru.cn/attachments/forum/201604/24/180629knkh2kffhhwwl23f.png"></p>
<p>​    下面讲述目前最广泛的两个运算平台，英伟达的CUDA和开放的OPENCL平台。</p>
<h4 id="6-6-2-1、CUDA"><a href="#6-6-2-1、CUDA" class="headerlink" title="6.6.2.1、CUDA"></a>6.6.2.1、CUDA</h4><p>​    CUDA（Compute Unified Device Architecture），CUDA™是由NVIDIA推出的并行计算架构，该架构使GPU解决复杂的计算问题。包含了CUDA指令集架构（ISA）以及GPU内部的并行计算引擎。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148827.png" alt="img"></p>
<p>​    开发人员可以使用C语言来为CUDA™架构编写程序，C语言是应用最广泛的一种高级编程语言。编写出的程序可以在支持CUDA™的处理器上以超高性能运行。</p>
<p>​    计算行业从只使用CPU的“中央处理”向CPU与GPU并用的“协同处理”发展。为打造这一全新的计算典范，NVIDIA™（英伟达™）发明了CUDA（Compute Unified Device Architecture，统一计算设备架构）这一编程模型。</p>
<h5 id="6-6-2-1-1、应用"><a href="#6-6-2-1-1、应用" class="headerlink" title="6.6.2.1.1、应用"></a>6.6.2.1.1、应用</h5><p>​    在应用程序中充分利用CPU和GPU各自的优点。该架构已应用于GeForce™（精视™）、ION™（翼扬™）、Quadro以及Tesla GPU（图形处理器）上，对应用程序开发人员来说，这是一个巨大的市场。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148781.png" alt="http://attachbak.dataguru.cn/attachments/forum/201604/24/180626qfnnioezwoc57w15.png"></p>
<p>​    在消费级市场上，几乎每一款重要的消费级视频应用程序都已经使用CUDA加速或很快将会利用CUDA来加速，其中包括Elemental Technologies公司、MotionDSP公司以及LoiLo公司的产品。</p>
<p>​    在科研界，CUDA一直受到热捧。例如，CUDA现已能够对AMBER进行加速。AMBER是一款分子动力学模拟程序，全世界在学术界与制药企业中有超过60，000名研究人员使用该程序来加速新药的探索工作。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148810.png" alt="img"></p>
<p>​    在金融市场，Numerix以及CompatibL针对一款全新的对手风险应用程序发布了CUDA支持并取得了18倍速度提升。Numerix为近400家金融机构所广泛使用。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148816.png" alt="img"></p>
<p>​    CUDA的广泛应用造就了GPU计算专用Tesla GPU的崛起。全球财富五百强企业已经安装了700多个GPU集群，这些企业涉及各个领域，例如能源领域的斯伦贝谢与雪佛龙以及银行业的法国巴黎银行，包括阿里云。</p>
<p>​    GPU计算目前成为主流。在显卡硬件上，GPU将不仅仅是图形处理器，还是应用程序均可使用的通用并行处理器。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148060.png" alt="img"></p>
<p>​    随着显卡的发展，GPU越来越强大，GPU为图像处理做了优化。计算上超越了通用的CPU。强大的芯片不能仅仅进行显示，因此NVIDIA推出CUDA，让显卡可以用于图像计算以外的目的。</p>
<p>​    CUDA架构可以使用GPU来解决商业、工业以及科学方面的复杂计算问题。它是一个完整的GPGPU解决方案，提供了硬件的直接访问接口，而不必像传统方式一样必须依赖图形API接口来实现GPU的访问。</p>
<h5 id="6-6-2-1-2、系统结构"><a href="#6-6-2-1-2、系统结构" class="headerlink" title="6.6.2.1.2、系统结构"></a>6.6.2.1.2、系统结构</h5><p>​    在架构上采用了一种全新的计算体系结构来使用GPU提供的硬件资源，从而给大规模的数据计算应用提供了一种比CPU更加强大的计算能力。CUDA采用C语言作为编程语言提供大量的高性能计算指令开发能力，使开发者能够在GPU的强大计算能力的基础上建立起一种效率更高的密集数据计算解决方案。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148088.png" alt="img"></p>
<p>​    CUDA体系结构包含三部分：开发库、运行期环境和驱动。</p>
<p>​    开发库是基于CUDA技术提供的应用开发库。CUDA1。1版提供了两个标准的数学运算库——CUFFT（离散快速傅立叶变换）和CUBLAS（离散基本线性计算）的实现。这两个数学运算库解决的是典型的大规模并行计算问题，也是在密集数据计算中非常常见的计算类型。开发人员在开发库的基础上快速、方便的建立起自己的计算应用。此外，开发人员也可以在CUDA的技术基础上实现出更多的开发库。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148086.png" alt="img"></p>
<p>​    运行期环境提供了应用开发接口和运行期组件，包括基本数据类型的定义和各类计算、类型转换、内存管理、设备访问和执行调度等函数。基于CUDA开发的程序代码在实际执行中分为两种，一种是运行在CPU上的宿主代码（Host Code），一种是运行在GPU上的设备代码（Device Code）。不同类型代码运行的物理位置不同，访问的资源不同，对应的运行期组件也分为公共组件、宿主组件和设备组件三个部分，囊括了所有在GPGPU开发中所需要的功能和能够使用到的资源接口，开发人员通过运行期环境的编程接口实现各种类型的计算。</p>
<p>​    由于存在着多种GPU版本的NVidia显卡，不同版本的GPU之间都有不同的差异，因此驱动部分基本上可以理解为是CUDA-enable的GPU的设备抽象层，提供硬件设备的抽象访问接口。CUDA提供运行期环境通过这一层来实现各种功能。基于CUDA开发的应用必须有NVIDIA CUDA-enable的硬件支持。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148132.png" alt="http://attachbak.dataguru.cn/attachments/forum/201604/24/180626v66bl8kkukn3unfp.png"></p>
<p>​    NVIDIA公司GPU运算事业部总经理Andy Keane在活动中表示：一个充满生命力的技术平台应该是开放的，CUDA未来也会向这个方向发展。由于CUDA的体系结构中有硬件抽象层的存在，因此今后也有可能发展成为一个通用的GPGPU标准接口，兼容不同厂商的GPU产品。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148328.png" alt="img"></p>
<p>​    支持CUDA的GPU销量逾10亿，数以万计的开发人员正在使用免费的CUDA软件开发工具来解决各种问题。从视频与音频处理和物理效果模拟到石油天然气勘探、产品设计、医学成像以及科学研究，涵盖了各个领域。</p>
<h5 id="6-6-2-1-3、核心"><a href="#6-6-2-1-3、核心" class="headerlink" title="6.6.2.1.3、核心"></a>6.6.2.1.3、核心</h5><p>​    CUDA的核心有三个重要抽象概念： 线程组层次结构、共享存储器、屏蔽同步（barriersynchronization），轻松将其作为C语言的最小扩展级公开给程序员。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148351.png" alt="img"></p>
<p>​    CUDA 软件堆栈由几层组成，一个硬件驱动程序，一个应用程序编程接口（API）和它的Runtime，还有二个高级的通用数学库，CUFFT 和CUBLAS。硬件被设计成支持轻量级的驱动和Runtime 层面，因而提高性能。</p>
<h5 id="6-6-2-1-4、其它"><a href="#6-6-2-1-4、其它" class="headerlink" title="6.6.2.1.4、其它"></a>6.6.2.1.4、其它</h5><p>​    NVIDIA进军高性能计算领域，推出了Tesla&amp;CUDA高性能计算系列解决方案，CUDA技术，一种基于NVIDIA图形处理器（GPU）上全新的并行计算体系架构，让科学家、工程师和其它专业技术人员能够解决以前无法解决的问题，作为一个专用高性能GPU计算解决方案，NVIDIA把超级计算能够带给任何工作站或服务器，以及标准、基于CPU的服务器集群。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148371.png" alt="img"></p>
<p>​    CUDA是用于GPU计算的开发环境，是一个全新的软硬件架构，可以将GPU视为一个并行数据计算的设备，对计算分配和管理。CUDA的架构中，计算不再像过去所谓的GPGPU架构那样必须将计算映射到图形API（OpenGL和Direct 3D）中，对于开发者来说，CUDA的开发门槛大大降低。CUDA编程基于C语言，任何有C语言基础的用户都很容易地开发CUDA的应用程序。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148430.png" alt="img"></p>
<p>​    GPU的特点是处理密集型数据和并行数据计算，因此CUDA非常适合需要大规模并行计算的领域。CUDA除了可以用C、C++、JAVA、Python语言开发。广泛的应用在图形动画、科学计算、地质、生物、物理模拟等领域。</p>
<p>​    计算正在从CPU”中央处理”向CPU与GPU”协同处理”的方向发展。对应用程序开发商来说，英伟达™ CUDA™ 架构拥有庞大的用户群。</p>
<h4 id="6-6-2-2、OPENCL"><a href="#6-6-2-2、OPENCL" class="headerlink" title="6.6.2.2、OPENCL"></a>6.6.2.2、OPENCL</h4><p>​    OpenCL（Open Computing Language，开放运算语言）是第一个面向异构系统并行编程的开放式、免费标准，也是一个统一的编程环境。</p>
<p>​    便于软件开发人员为高性能计算服务器、桌面计算系统、手持设备编写高效轻便的代码，而且广泛适用于多核心处理器(CPU)、图形处理器(GPU)、Cell类型架构以及数字信号处理器(DSP)等其它并行处理器，在游戏、娱乐、科研、医疗等各种领域都有广阔的发展前景。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148356.png" alt="img"></p>
<p>​    OpenCL平台可由CPU，GPU或其它类型的处理器组成。OpenCL用于编写kernels （在OpenCL设备上运行的函数）的语言（基于C99）和一组用于定义并控制平台的API组成。OpenCL提供了基于任务分割和数据分割的并行计算机制。</p>
<p>​    OpenCL类似于另外两个开放的工业标准OpenGL和OpenAL，这两个标准分别用于三维图形和计算机音频方面。OpenCL扩展了GPU用于图形生成之外的能力。OpenCL由非盈利性技术组织Khronos  Group掌管。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148590.png" alt="img"></p>
<h5 id="6-6-2-2-1、发展"><a href="#6-6-2-2-1、发展" class="headerlink" title="6.6.2.2.1、发展"></a>6.6.2.2.1、发展</h5><p>​    OpenCL最初苹果公司开发，拥有其商标权，并在与AMD，IBM，英特尔和NVIDIA技术团队的合作之下初步完善。随后，苹果将这一草案提交至Khronos  Group。</p>
<p>​    2008年6月的WWDC大会上，苹果提出了OpenCL规范，旨在提供一个通用的开放API，在此基础上开发GPU通用计算软件。随后，Khronos  Group宣布成立GPU通用计算开放行业标准工作组，以苹果的提案为基础创立OpenCL行业规范。5个月后的2008年11月18日，该工作组完成了OpenCL 1。0规范的技术细节。2010年6月14日，OpenCL 1。1 发布。2011年11月15日，OpenCL 1。2 发布。2013年11月19日，OpenCL 2。0发布。目前，OpenCL最新版本是3。0。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148672.png" alt="img"></p>
<p>​    2009年6月NVIDIA首家发布了支持OpenCL 1。0通用计算规范的驱动程序，支持Windows和Linux操作系统。</p>
<p>​    2009年8月初AMD首次发布了可支持IA处理器(x86和amd64&#x2F;x64)的OpenCL SDK——ATI Stream SDK v2。0Beta，交由业界标准组织Khronos 进行审核。目前，该SDK更名为AMD APP SDK。</p>
<p>​    2012年2月，intel发布了The Intel&reg; SDK for OpenCL* Applications 2012，支持OpenCL 1。1基于带HD4000&#x2F;2500的显示核心的第三代酷睿CPU（i3，i5，i7)和GPU。</p>
<p>​    2013年6月，intel发布了第四代酷睿CPU haswell 其内置的HD4600&#x2F;4400&#x2F;4200 Iris（锐矩）5000&#x2F;5100&#x2F;pro 5200（自带eDRAM缓存）支持OpenCL 1。2（未来可能升级到OpenCL 2。0）</p>
<p>​    NVIDIA显卡方面 Geforce 8000\9000\100、GTX200-1000，RTX2000均支持OpenCL 1。0-1。2</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148656.png" alt="img"></p>
<p>​    AMD显卡方面 Radeon HD 4000-7000\Rx 200\Rx 300\RX 400-500&#x2F;Fury系列，Vega系列 均支持OpenCL 1。0-1。2，除Radeon HD4000-6000系列外，其余均会支持OpenCL 2。0</p>
<p>​    移动平台方面目前高通adreno320&#x2F;330&#x2F;400系列&#x2F;500系列提供了Android上的OpenCL1。2或者2。0支持，NVIDIA的Tegra K1也提供了OpenCL 支持。</p>
<h5 id="6-6-2-2-2、支持"><a href="#6-6-2-2-2、支持" class="headerlink" title="6.6.2.2.2、支持"></a>6.6.2.2.2、支持</h5><p>​    OpenCL工作组的成员包括：3Dlabs、AMD、苹果、ARM、Codeplay、爱立信、飞思卡尔、华为、HSA基金会、GraphicRemedy、IBM、Imagination Technologies、Intel、诺基亚、NVIDIA、摩托罗拉、QNX、高通，三星、Seaweed、德州仪器、布里斯托尔大学、瑞典Ume大学。像Intel、NVIDIA和AMD都是这个标准的支持者，不过微软并不在其列。目前，NVIDIA显卡对OpenCL技术支持较好。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148659.png" alt="img"></p>
<p>​    在NVIDIA的Quadro、Geforce系列专业显卡中，能够使用OpenCL技术。只要显卡能够达到CUDA的要求，就能够正常使用OpenCL，以获得优异的CPU运算效率。</p>
<p>​    在AMD-ATI的Stream技术中（现已经改名为AMD APP并行加速技术），已经为日常使用、办公、游戏等提供物理加速。基于OpenCL标准开发，其中，ATI Radeon HD 4000-5000、AMD Radeon HD 6000系列同时支持ATI Stream和AMD APP（由于Stream基于CAL和Brook+语言开发，更适合VLIW5和VLIW4这样的SIMD架构），AMD Radeon HD7000和Radeon Rx 200系列支持AMD APP，运算效率较老架构提升十分明显。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148635.png" alt="img"></p>
<h5 id="6-6-2-2-3、API"><a href="#6-6-2-2-3、API" class="headerlink" title="6.6.2.2.3、API"></a>6.6.2.2.3、API</h5><p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148721.png" alt="img"></p>
<p>​    OpenCL平台API：定义了宿主机程序发现OpenCL设备所用的函数以及这些函数的功能，还定义了OpenCL应用创建上下文的函数。</p>
<p>​    OpenCL运行时API：管理上下文来创建命令队列以及运行时发生的其它操作。例如，将命令提交到命令队列的函数就来自OpenCL运行时API。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148915.png" alt="img"></p>
<p>​    OpenCL编程语言：编写内核代码的编程语言。基于ISO C99标准的一个扩展子集，通常称为OpenCL C编程语言。</p>
<h5 id="6-6-2-2-4、总结"><a href="#6-6-2-2-4、总结" class="headerlink" title="6.6.2.2.4、总结"></a>6.6.2.2.4、总结</h5><p>​    综合上述内容，形成OpenCL全景图(如下)，首先是一个定义上下文的宿主机程序。上图中的上下文包含两个OpenCL设备、一个CPU和一个GPU。接下来定义了命令队列。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148901.png" alt="img"></p>
<p>​    这里有两个队列，一个是面向GPU的有序命令队列，另一个是面向CPU的乱序命令队列。然后宿主机程序定义一个程序对象，这个程序对象编译后将为两个OpenCL设备（CPU和GPU）生成内核。</p>
<p>​    接下来宿主机程序定义程序所需的内存对象，并把它们映射到内核的参数。最后，宿主机程序将命令放入命令队列来执行这些内核。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148953.png" alt="img"></p>
<h3 id="6-6-4、其它相关库"><a href="#6-6-4、其它相关库" class="headerlink" title="6.6.4、其它相关库"></a>6.6.4、其它相关库</h3><p>​    智能时代是百花齐放的时代，芯片技术驱动硬件技术，芯片指令提供操作接口，操作接口驱动运算平台，运算平台驱动机器学习库。本主题介绍部分机器视觉和并行计算库。</p>
<h4 id="6-6-4-1、OpenCV"><a href="#6-6-4-1、OpenCV" class="headerlink" title="6.6.4.1、OpenCV"></a>6.6.4.1、OpenCV</h4><p>​    OpenCV是基于BSD许可（开源）发行的跨平台计算机视觉和机器学习软件库，运行在Linux、Windows、Android和Mac OS操作系统上。 轻量高效，由一系列 C 函数和少量 C++ 类构成，提供了Python、Ruby、MATLAB等编程接口，实现了图像处理和计算机视觉方面的通用算法。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148536.png" alt="img"></p>
<h4 id="6-6-4-1、简介"><a href="#6-6-4-1、简介" class="headerlink" title="6.6.4.1、简介"></a>6.6.4.1、简介</h4><p>​    OpenCV用C++语言编写，利用MMX和SSE指令，OpenCV 为Intel® Integrated Performance Primitives（IPP）提供了透明接口。意味着如果有特定处理器优化的 IPP 库，OpenCV 在运行时自动加载这些库。 </p>
<p>​    OpenCV 拥有 500 多个C函数的跨平台的中、高层 API。不依赖于其它的外部库。OpenCV 使用类BSDlicense，对非商业应用和商业应用免费（FREE）。</p>
<p>​    OpenCV的视觉处理算法丰富，部分用C语言编写，开源的特性，处理得当，不需要外部支持可以完整编译链接生成执行程序，方便算法的移植，OpenCV的代码经过适当改写可以正常的运行在DSP系统和ARM嵌入式系统中。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148544.jpeg" alt="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=974700158,1979112963&amp;fm=26&amp;gp=0.jpg"></p>
<h4 id="6-6-4-2、应用"><a href="#6-6-4-2、应用" class="headerlink" title="6.6.4.2、应用"></a>6.6.4.2、应用</h4><p>​    OpenCV致力于真实世界的实时应用，通过优化C代码的编写对其执行速度带来了可观的提升，通过购买Intel的IPP高性能多媒体函数库（Integrated Performance Primitives）得到更快的处理速度。</p>
<p>​    应用领域：人机互动、物体识别、图像分割、人脸识别、动作识别、运动跟踪、机器人、运动分析、机器视觉、结构分析、汽车安全驾驶</p>
<h4 id="6-6-4-3、接口"><a href="#6-6-4-3、接口" class="headerlink" title="6.6.4.3、接口"></a>6.6.4.3、接口</h4><p>​    OpenCV其它接口是用C++接口改编的，主要接口语言也是C++语言，依然保留了大量的C语言接口。该库也有大量的Python、Java and MATLAB&#x2F;OCTAVE、GO、C#、Ch、Ruby等的接口。API接口函数通过在线文档获得。一个使用CUDA的GPU接口也于2010年9月开始实现。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148521.jpeg" alt="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1001109053,1480904686&amp;fm=26&amp;gp=0.jpg"></p>
<p>​    OpenCV可以在Windows，Android，Maemo，FreeBSD，OpenBSD，iOS，Linux 和Mac OS等平台上运行。可以在 SourceForge 获得官方版本，或者从 SVN 获得开发版本。</p>
<h4 id="6-6-4-2、OpenMP"><a href="#6-6-4-2、OpenMP" class="headerlink" title="6.6.4.2、OpenMP"></a>6.6.4.2、OpenMP</h4><p>​    OpenMP是OpenMP Architecture Review Board牵头提出的，已被广泛接受，用于共享内存并行系统的多处理器程序设计，并提供一套指导性编译处理方案(Compiler Directive) 。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148438.png" alt="img"></p>
<p>​    OpenMP支持的编程语言包括C、C++和Fortran；支持OpenMp的编译器包括Sun Compiler，GNU Compiler和Intel Compiler等。</p>
<h5 id="6-6-4-2-1、简介"><a href="#6-6-4-2-1、简介" class="headerlink" title="6.6.4.2.1、简介"></a>6.6.4.2.1、简介</h5><p>​    OpenMp提供了对并行算法的专用描述，源代码中加入专用的pragma指令来指明自己的意图，由此编译器可以自动将程序进行并行化，在必要之处加入同步互斥以及通信。在进行软件开发时间，串行化到并行化是一个提高效率最有效的方法。</p>
<p>忽略这些pragma，或者编译器不支持OpenMp时，程序又可退化为串行程序，代码仍然可以正常运作，这是考虑CPU硬件不同而设定的方案，只是不能利用多线程来加速程序执行。根据硬件支持，进行单线程和多线程的处理。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148450.png" alt="img"></p>
<p>​    OpenMP对于并行描述的高层抽象降低了并行编程的难度和复杂度，程序员可以把更多的精力投入到并行算法本身，而非其具体实现细节，这样让程序员集中精力做某些事情。对基于数据分集的多线程程序设计，OpenMP是一个很好的选择，尤其对计算要求严格的地方。</p>
<p>​    OpenMP提供了更强的灵活性，可以适应不同的并行系统配置。线程粒度和负载平衡等是传统多线程程序设计中的难题，这些问题从前主要靠中间件来进行实现，或者从程序的框架角度来进行考虑。现在，把这些和兴的处理交给程序员直接接触的框架，从而提高了效率。OpenMP中，OpenMP库从程序员手中接管了部分这两方面的工作。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148432.png" alt="https://pic.ikafan.com/imgp/L3Byb3h5L2h0dHAvaW1hZ2VzMC5jbmJsb2dzLmNvbS9ibG9nMjAxNS81MjI0OTAvMjAxNTA2LzI3MjExMzUwNTY0ODI3NC5wbmc=.jpg"></p>
<p>​    作为高层抽象，OpenMP不适合复杂的线程间同步和互斥的场合，这是由于OpenMp本身的结构决定的。OpenMp不能在非共享内存系统，例如计算机集群使用，如果使用，处理效果很不理想。共享内容的系统上，MPI使用较多。在项目开发过程中，技术选型非常重要。</p>
<p>​    OpenMP是作为共享存储标准而问世的。它是为在多处理机上编写并行程序而设计的一个应用编程接口。它包括一套编译指导语句和一个用来支持它的函数库。当今双核、四核的 CPU 当道，而六核的CPU也已经面世多时，所以在多处理机上编写、运行并行程序会变得相当普遍。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148459.png" alt="https://pic.ikafan.com/imgp/L3Byb3h5L2h0dHAvaW1hZ2VzMC5jbmJsb2dzLmNvbS9ibG9nMjAxNS81MjI0OTAvMjAxNTA2LzI3MjExNDQzNTgwNzM3OC5wbmc=.jpg"></p>
<h5 id="6-6-4-2-2、单线程与多线程"><a href="#6-6-4-2-2、单线程与多线程" class="headerlink" title="6.6.4.2.2、单线程与多线程"></a>6.6.4.2.2、单线程与多线程</h5><p>​    一般单线程（single thread）程序，多核心处理器没有办法提升处理效能；对于多线程（multi thread）的程序，就可以通过不同的核心同时计算，来达到加速的目的。程序员在进行开发时间，对效率要有一定的认知，如果效率较高的程序，建议进行并行程序涉及。</p>
<p>​    下面我们举例，单线程程序，一件事一次要十秒的话，要做十次，一颗核心，就是 10 秒 的 10 倍，这就是 100 秒；如果按照多线程的程序运行，可以把一件事，给两颗核心各自完成，每核心各做 5 次，时间就缩短为 50 秒，这样速度提高了1倍。</p>
<p>​    多线程的程序实际上也不简单，我们上面的计算是机械的。在工作的切割、结合上，也是要多花时间的。</p>
<p>​    现实中，在最佳状况，双核心的效能也不会是 1 + 1 &#x3D; 2 这样的理想化情况，这个仅仅是我们不考虑其它情况时间的结果。</p>
<p>​    并不是所有任务都可以切割！很多任务关键在一起，直接切割给不同的处理核心各自并行运算，出来的结果会有问题，这是安全所不能容忍的。多线程的程序在编写、维护上，比单线程的程序复杂了很多。对于效率要求不高，要求健壮性能的程序，单线程稳定还是好的。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148467.png" alt="https://pic.ikafan.com/imgp/L3Byb3h5L2h0dHAvaW1hZ2VzMC5jbmJsb2dzLmNvbS9ibG9nMjAxNS81MjI0OTAvMjAxNTA2LzI3MjExNjA0NDA4MzcxOC5wbmc=.jpg"></p>
<p>​    电脑是多处理器、多核处理器，或具备IntelHyper-ThreadingTechnology 技术，代表同一个时间处理多个线程的功能，把各自独立的工作由单线程改成多线程，执行的效率上，一般是有提升的。</p>
<p>​    微软VS，提供线程控制功能。这种方法，产生多个 thread，策略如下：主线程把工作分配，子线程去然后运算，最后主线程对结果进行整理。</p>
<p>​    OpenMP 通过高阶指令，这些指令往往是对CPU指令进行调用，演化为一系列操作，这中操作在从前是不可想象的。将程序并行化、多线程化的 API，这点免去了软件工程师的大部分工作负担；并行化处理是OpenMp的核心思想，最简单情形，只加一行指令，将循环内的程序并行化处理。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148444.png" alt="https://pic.ikafan.com/imgp/L3Byb3h5L2h0dHAvaW1hZ2VzMC5jbmJsb2dzLmNvbS9ibG9nMjAxNS81MjI0OTAvMjAxNTA2LzI3MTczNjQ2ODMwNTMzMy5wbmc=.jpg"></p>
<h5 id="6-6-4-2-3、OpenMP与MPI"><a href="#6-6-4-2-3、OpenMP与MPI" class="headerlink" title="6.6.4.2.3、OpenMP与MPI"></a>6.6.4.2.3、OpenMP与MPI</h5><p>​    OpenMP 是针对共享内存并行编程的 API。与之前的 MPI 不同的是，OpenMP是线程级并行，比 MPI 的进程级并行要更轻量化一些。轻量级代表更少的改动，共享内容是解决共享的重要手段之一。</p>
<p>​    MPI 的并行需要完全重写整个程序，这点相对麻烦很多，是很多程序员排斥的。将一个串行程序改造成 OpenMP 的并行进行的改动近乎可以忽略不计。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148684.png" alt="img"></p>
<h5 id="6-6-4-2-4、应用"><a href="#6-6-4-2-4、应用" class="headerlink" title="6.6.4.2.4、应用"></a>6.6.4.2.4、应用</h5><p>​    分为Windows环境和Linux环境。</p>
<h6 id="6-6-4-2-4-1、Windows环境下开发"><a href="#6-6-4-2-4-1、Windows环境下开发" class="headerlink" title="6.6.4.2.4.1、Windows环境下开发"></a><strong>6.6.4.2.4.1、Windows环境下开发</strong></h6><p>​    在VC++中使用OpenMP，将 Project 的Properties中C&#x2F;C++里Language的OpenMP Support开启（参数为 &#x2F;openmp），就可以让VC++编译时支持OpenMP 的语法；</p>
<p>​    编写使用OpenMP 的程序时，则需要先include OpenMP的头文件：omp.h。</p>
<p>​    for 循环并行化处理，要在前面加上一行</p>
<p>​    #pragma omp parallel for</p>
<p>​    实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;STDIO.H&gt;</span><br><span class="line">#include &lt;STDLIB。H&gt;</span><br><span class="line">void Test(int n)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0; i &lt; 10000; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        //do nothing， just waste time</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d， &quot;， n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc，char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i &lt; 10; ++i)</span><br><span class="line"></span><br><span class="line">    Test(i);</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面的程序，在 main() 是一个很简单的循环，十次调用Test()这个函数，把循环的执行次数传进Test() 并打印。运行结果：</p>
<p>​    0， 1， 2， 3， 4， 5， 6， 7， 8， 9，</p>
<p>​    OpenMP main() 里平行化处理，按照如下方式进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;omp.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void Test (int n)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0; i &lt; 10000; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        //do nothing， just waste time</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d， &quot;， n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc，char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    #pragma omp parallel for</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; 10; ++i)</span><br><span class="line">        Test( i );</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    运行结果：</p>
<p>​    0， 5， 1， 6， 2， 7， 3， 8， 4， 9，</p>
<p>​    OpenMP把循环分成两部分，拆成 0 - 4， 5 - 9，不同的线程去跑，进行交错输出。</p>
<p>​    怎么确定真的有跑多线程呢，需要从硬件的角度来进行观察。如果本来有多处理器、多核心处理器或有 Hyper Thread 的话，一个单线程程序，最多只会把一颗核心的使用量吃完。</p>
<p>​    单线程的程序，工作管理员中看到CPU使用率最多是50%，说明CPU利用率低。利用 OpenMP 把循环进行平行化处理后，把两颗核心的 CPU 都用了！也就是CPU使用率提高了，可能达到100%，这就证明并行的结果。</p>
<h6 id="6-6-4-2-4-2、Linux环境"><a href="#6-6-4-2-4-2、Linux环境" class="headerlink" title="6.6.4.2.4.2、Linux环境"></a><strong>6.6.4.2.4.2、Linux环境</strong></h6><p>​    gcc 支持 OpenMP是这样的：使用gcc 编译时加上 -fopenmp 开关参数即可：</p>
<p>​    $ gcc -fopenmp &lt;source.c&gt; -o <exec></p>
<p>​    $ g++ -fopenmp &lt;source.cpp&gt; -o <exec></p>
<p>​    示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;omp。h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void hello()</span><br><span class="line">&#123;</span><br><span class="line">  int my_rank = omp_get_thread_num();</span><br><span class="line">  int thread_count = omp_get_num_threads();</span><br><span class="line">  printf(&quot;Hello from thread %d of %d\n&quot;， my_rank， thread_count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int thread_count = 4;</span><br><span class="line">  #pragma omp parallel num_threads(thread_count)</span><br><span class="line">  hello();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面代码首先增加了一个 omp。h 头文件，然后主函数中多出来一句串行代码中没有的预处理器指令，其它的跟正常的串行程序没什么区别。</p>
<p>​    # pragma 是 C&#x2F;C++ 中用以允许非 C 语言规范部分的行为，如果编译器不支持预处理器指令，那么编译时这句话就会被忽略掉。</p>
<p>​    OpenMP 依靠# pragma omp 开头的预处理器指令来进行线程级并行。预处理器指令后面加的是一些子句，用来附加额外控制信息。比如说 num_threads() 子句是用来控制接下来的代码块中需要用多少个线程进行并行。</p>
<p>​    程序编译完成之后直接打开是无法运行的，需要用 mpiexec 来调用生成好的可执行文件，mpiexec 会首先得到运行的目标机器、进程数等情况，然后启动多个进程，等到多进程全部开起来之后，并行就开始了。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148697.png" alt="img"></p>
<p>​    在 OpenMP 中，编译完成之后的可执行文件可以直接运行，程序在一开始是串行运行，到了需要并行的时候，单进程单线程会分裂成单进程多线程（其实是除了主线程以外，又启动了几个新的线程同时执行），执行完毕后又回到单线程串行。而且每次并行的线程数是可以在运行时指定的。</p>
<p>​    OpenMP 可以只把其中的一部分作并行处理，而且并行的时候共享的内存、变量等都是在一起的，从串行程序的基础上改造过来非常容易，可能只要加几段预处理器指令就可以了，剩下的交给编译器和处理器去解决。</p>
<h5 id="6-6-4-2-5、同步协作"><a href="#6-6-4-2-5、同步协作" class="headerlink" title="6.6.4.2.5、同步协作"></a>6.6.4.2.5、同步协作</h5><p>​    MPI 依靠进程间通信完成协作，OpenMP靠内存共享的解决线程写作。</p>
<p>​    OpenMP 冲突解决有四种方法：</p>
<p>A：Crirical 指令 &#x2F; 归约指令</p>
<p>​    例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line">#pragma omp parallel for num_threads(100)</span><br><span class="line">for (int i=0;i&lt;100;i++)</span><br><span class="line">&#123;</span><br><span class="line">       sum += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;%d\n&quot;， sum);</span><br></pre></td></tr></table></figure>

<p>​    运行的结果是每次运行，sum 最终结果可能是不同的。这是什么原因呢，运行时多个线程同时访问 sum 变量，可能前一个线程写上去的内容马上被下一个线程给覆盖掉了，数据共享出现了问题，即出现了数据冲突。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line">#pragma omp parallel for num_threads(100)</span><br><span class="line">for (int i=0;i&lt;100;i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    #pragma omp critical</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;， sum);</span><br></pre></td></tr></table></figure>

<p>​    加上# pragma omp critical 指令，来进行数据处理，会进行特殊的处理，编译器安排线程对下面执行的代码进行互斥访问，这是一种运行约束。每次只能够有一个线程执行下面的这一句代码。这样保证数据处理的有序与安全性能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line">#pragma omp parallel for num_threads(100) reduction(+: sum)</span><br><span class="line">for (int i=0;i&lt;100;i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;%d\n&quot;， sum);</span><br></pre></td></tr></table></figure>

<p>​    reduction(+: sum) 是归约子句，这是一个特定的写法。加上这一句，执行并行任务时，sum 本身是共享的，但这个共享和上面是不一样的，每个线程执行时会产生一个私有变量，在并行块运算结束后，系统会将私有变量的值整合，然后传递给共享变量。这样保证数据的共享性。</p>
<p>B：带命名的 critical 指令</p>
<p>​    用# pragma omp critical(name) 来命名不同的临界区。</p>
<p>​    同一个临界区的访问和上面一样，一次只有一个进程操作，保证数据的安全，不同的临界区有不同的进程进行同时访问，这样保证数据的同步。安全与同步是处理时间必须考虑的因素。</p>
<p>C：atomic 指令：</p>
<p>​    用# pragma omp atomic 的使用形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x &lt;op&gt;= &lt;expression&gt;;</span><br><span class="line">x++;</span><br><span class="line">++x;</span><br><span class="line">x--;</span><br><span class="line">--x;</span><br></pre></td></tr></table></figure>

<p>​    这些语句用 CPU 中的特殊硬件指令来实现，加快处理结果。</p>
<p>D：简单锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">omp_set_lock(&amp;lock);</span><br><span class="line">critical section</span><br><span class="line">omp_unset_lock(&amp;lock);</span><br></pre></td></tr></table></figure>

<p>​    锁住的区域只允许单个线程进行访问，保证数据安全。</p>
<h4 id="6-6-4-3、OpenACC"><a href="#6-6-4-3、OpenACC" class="headerlink" title="6.6.4.3、OpenACC"></a>6.6.4.3、OpenACC</h4><p>  OpenACC，开放式并行编程标准，程序员能够轻松利用异构 CPU&#x2F;GPU 计算系统的强大能力。和CUDA一样，是并行计算的主要平台架构。</p>
<h5 id="6-6-4-3-1、简介"><a href="#6-6-4-3-1、简介" class="headerlink" title="6.6.4.3.1、简介"></a>6.6.4.3.1、简介</h5><p>  OpenACC 为并行程序员给编译器提供简单的提示，通过指令，使编译器能够识别哪些代码部分需要加速，无需程序员修改或改编底层代码本身。简化并行编程标准，把计算任务映射到加速器这方面，指令向编译器呈现出并行机制，从而让编译器能够更好执行工作。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149273.jpeg" alt="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1683434966,140585891&amp;fm=15&amp;gp=0.jpg"></p>
<p>  OpenACC 指令由 PGI、Cray 以及英伟达在 CAPS 的支持下开发而成，是多家企业希望利用指令来简化 GPU 编程模型的一个共同愿景。硬件厂商和技术协会一起，这些企业均致力于支持一种共同的编程标准。共同把并行编程技术推向前进。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149296.png" alt="img"></p>
<p>  OpenACC指令与OpenMP指令工作方式很类似，都是指令级别编程，适用于高度数据并行代码。可插入标准的C，C + +和Fortran程序直接指导编译器进行某些代码段的并行。这些并行的代码，编译器会特别注意数据在CPU和GPU（或其它）之间来回转移的逻辑关系，并将计算映射到适当的处理器上。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149279.png" alt="img"></p>
<p>  这些指令由硬件支持，不需要较大的改动，相对小的改动以标示出加速并行区域。指令设计适用于一个通用并行处理器，这样相同的代码可以运行在多核CPU、GPU或任何编译器支持的其它类型的并行硬件上。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149269.png" alt="img"></p>
<h5 id="6-6-4-3-2、发展与应用"><a href="#6-6-4-3-2、发展与应用" class="headerlink" title="6.6.4.3.2、发展与应用"></a>6.6.4.3.2、发展与应用</h5><p>  2015年7月，北京，全球视觉计算技术行业领袖NVIDIA发布了OpenACC工具套件，通过全新的套件，科学研究将可以做更多事情，并大幅提升计算效率。</p>
<p>  虽然计算核心在短时间内不会变得更快，这是硬件的制约，但处理器的并行计算能力越来越强大。这一趋势十年里一直存在，而且还会持续下去，通过软机制提高效率。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149332.png" alt="img"></p>
<p>  OpenACC已在HPC行业中得到广泛支持，简化GPU等现代处理器的并行编程。2011年Cray、PGI以及NVIDIA等领先的HPC供应商推出OpenACC编程标准以来，已有8000多名研究人员和科学家采用了这一标准。并取得了卓越的成绩，免费的标准</p>
<p>  OpenACC工具套件应用快捷，使用方便，快速对GPU编程。全新的OpenACC工具套件行业领先，获得了广泛的应用。</p>
<p>  该工具套件中，向学术开发者和研究人员免费提供这一编译器，商业用户有90天的免费试用期，黄总还是很厚道的。</p>
<p>  全新的OpenACC工具套件有一个特别的工具：NVProf Profiler，指导用户如何添加 OpenACC“指令”，会进行编译器提示，以加速代码实现。通过真实案例可以方便快捷的入门。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149302.png" alt="img"></p>
<p>  简单的指令让研究人员能够感受到并行计算，运行加速，同时不会破坏现有的CPU代码，不浪费之前所有代码编写花费的时间，这些指令与代码具有着较好的应用。</p>
<h5 id="6-6-4-3-3、硬件独立性"><a href="#6-6-4-3-3、硬件独立性" class="headerlink" title="6.6.4.3.3、硬件独立性"></a>6.6.4.3.3、硬件独立性</h5><p>  硬件独立性代表一个标准，无论对于硬件厂商或者软件厂商，对于HPC用户来说特别重要，无论软件厂商还是硬件厂商，不愿意接受那种受供应商限制的，非便携式编程环境。</p>
<p>  OpenACC的一大主要特性是高性能移植，这主要是硬件独立性的结果。PGI OpenACC编译器则把这一优势推向全新高度，让世人惊叹。该编译器首次能够在x86多核CPU和GPU上加速OpenACC代码，极大程度提高了效率。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149521.png" alt="img"></p>
<p>  没有一台配备GPU的系统时，编译器会在多个 CPU核心上完成代码并行化，进而提升性能。当系统中有GPU时，该编译器将会针对GPU做代码并行化的优化，最终与多核CPU相比可带来5~10倍的性能提升。这种提升大大提高了效率，在今天得到广泛的应用。</p>
<p>  OpenACC代码在C语言基础上进行修改，通过添加compiler directives 编译器指令(pragmas): #pragma 来标示。这个和前面介绍的有些相似。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149551.png" alt="img"></p>
<p>  cuda 中 __syncthreads()进行线程同步，目前的OpenAcc还没有线程同步机制。</p>
<p>  OpenACCDevice model</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149604.png" alt="img"></p>
<p>  OpenACCexcute model</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149618.png" alt="img"></p>
<h5 id="6-6-4-3-4、实例01—parallel-loops"><a href="#6-6-4-3-4、实例01—parallel-loops" class="headerlink" title="6.6.4.3.4、实例01—parallel loops"></a>6.6.4.3.4、实例01—parallel loops</h5><p>  第一段代码和第二段代码等效，在OpenAcc中一个parallel区域有一个单个loop组成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#pragma acc parallel loop copyin(M[0:Mh*Mw])</span><br><span class="line">copyin(N[0:Mw*Nw]) copyout(P[0:Mh*Nw])</span><br><span class="line">for (int i=0; i&lt;Mh; i++)</span><br><span class="line">&#123;</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma acc parallel copyin(M[0:Mh*Mw])</span><br><span class="line">copyin(N[0:Mw*Nw]) copyout(P[0:Mh*Nw])</span><br><span class="line">&#123;</span><br><span class="line">    #pragma acc loop</span><br><span class="line">    for (int i=0; i&lt;Mh; i++) &#123;</span><br><span class="line">    。。。</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  结果说明：</p>
<p>  copyin对应拷贝内存从host到device</p>
<p>  copyout对应拷贝内存从device到host </p>
<h5 id="6-6-4-3-5、实例02—gangs-and-workers"><a href="#6-6-4-3-5、实例02—gangs-and-workers" class="headerlink" title="6.6.4.3.5、实例02—gangs and workers"></a>6.6.4.3.5、实例02—gangs and workers</h5><p>  gangs可以类比成cuda的block；</p>
<p>  workers可以类比成thread。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#pragma acc parallel num_gangs(1024) num_workers(32)</span><br><span class="line">&#123;</span><br><span class="line">    #pragma acc loop gang</span><br><span class="line">    for (int i=0; i&lt;2048; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        #pragma acc loop worker</span><br><span class="line">        for (int j=0; j&lt;512; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            foo(i，j);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  解释：线程分配: 1024<em>32 &#x3D; 32K 个thread，两个循环题一共是执行2048</em>512 &#x3D; 1M， 每个thread执行foo()函数 1M&#x2F;32K &#x3D; 32 次。</p>
<p>  另外一个代码：</p>
<p>  结果说明：代码会分配1023*32个thread，每个gang&#x3D;1024， 对于每个gang来说执行a &#x3D;23 是冗余的，只需要执行一次即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#pragma acc parallel copyout(a) num_gangs(1024) num_workers(32)</span><br><span class="line">&#123;</span><br><span class="line">    a = 23;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  再看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma acc parallel num_gangs(32)</span><br><span class="line">&#123;</span><br><span class="line">    Statement 1;</span><br><span class="line">    #pragma acc loop gang</span><br><span class="line">    for (int i=0; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Statement 2;</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>  Statement 3;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#pragma acc loop gang</span><br><span class="line"></span><br><span class="line">for (int i=0; i&lt;m; i++)</span><br><span class="line">&#123;</span><br><span class="line">        Statement 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Statement 5;</span><br><span class="line"></span><br><span class="line">if (condition) Statement 6;</span><br></pre></td></tr></table></figure>

<p>  结果说明：从循环次数上来说，gang32个，statement2的循环次数n，statement4循环次数是m， 最终到底分配多少个thread取决于编译器，有可能m&gt;n，则分配m个，实际情况可能更加复杂。</p>
<p>  statement1， 3， 5，6 对于32gang来说是冗余的，情况和上面的相同，可以看出OpenAcc中的冗余是对于gang来说的，下面的这种写法可以消除这种冗余：取得更好的效果，在编程时间应该注意。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#pragma acc parallel num_gangs(1)</span><br><span class="line">num_workers(32)</span><br><span class="line">&#123;</span><br><span class="line">    Statement 1;</span><br><span class="line">    #pragma acc loop gang</span><br><span class="line">    for (int i=0; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Statement 2;</span><br><span class="line">    &#125;</span><br><span class="line">    Statement 3;</span><br><span class="line"></span><br><span class="line">    #pragma acc loop gang</span><br><span class="line">    for (int i=0; i&lt;m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Statement 4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Statement 5;</span><br><span class="line"></span><br><span class="line">    if (condition)</span><br><span class="line">    &#123;</span><br><span class="line">        Statement 6;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-6-4-3-6、实例03—kernel-regions"><a href="#6-6-4-3-6、实例03—kernel-regions" class="headerlink" title="6.6.4.3.6、实例03—kernel regions"></a>6.6.4.3.6、实例03—kernel regions</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#pragma acc kernels</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    #pragma acc loop num_gangs(1024)</span><br><span class="line">    for (int i=0; i&lt;2048; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #pragma acc loop num_gangs(512)</span><br><span class="line">    for (int j=0; j&lt;2048; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[j] = a[j]*2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int k=0; k&lt;2048; k++) </span><br><span class="line">    &#123;</span><br><span class="line">        d[k] = c[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  结果说明：</p>
<p>  和前面比较，区别是 acc kernel， 也就是指令不一样，前面代码用的是acc parallel。</p>
<p>  Kernel 结构主要描述程序员意图: 当前程序适合并行，编译器根据描述会有非常灵活的表现。把决定权留给编译器。</p>
<p>  编译器的参与避免了硬件的模糊性，为并行开发提供了便利。</p>
<h4 id="6-6-4-5、OpenAL"><a href="#6-6-4-5、OpenAL" class="headerlink" title="6.6.4.5、OpenAL"></a>6.6.4.5、OpenAL</h4><p>​    OpenAL，英文全称为：Open Audio Library，自由软件界的跨平台音效API，由Loki Software，主要应用是在音效缓冲和收听中编码。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149105.png" alt="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1282481439,2142315962&amp;fm=26&amp;gp=0.jpg"></p>
<p>​    OpenAL设计给多通道三维位置音效的特效表现，其 API 风格模仿自OpenGL。</p>
<p>​    Loki 倒闭以后，该开发接口，开始由自由软件&#x2F;开放源始码社群继续维护。最大的主导者是创新科技，并得到来自 Apple 和自由软件&#x2F;开放源代码爱好者的持续支援。这是今天仍在活跃的基本原因。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149116.png" alt="img"></p>
<p>​    OpenAL 主要功能是在来源物体、音效缓冲和收听者中编码。来源物体包含一个指向缓冲区的指标、声音的速度、位置和方向，以及声音强度。收听者物体包含收听者的速度、位置和方向，以及全部声音的整体增益。缓冲里包含 8 或 16 位元、单声道或立体声 PCM 格式的音效资料，表现引擎进行所有必要的计算，如距离衰减、多普勒效应等。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149120.png" alt="img"></p>
<p>​    不同于 OpenGL 规格，OpenAL 规格包含两个API分支：这是由于OpenAL的特点决定的。以实际 OpenAL 函式组成的核心，和 ALC API，ALC 用于管理表现内容、资源使用情况，并将跨平台风格封在其中。还有ALUT库，提供高阶“易用”的功能，其定位相当于 OpenGL 的 GLUT。</p>
<p>​    支持平台包括：Mac OS X、iOS、Linux、BSD、Solaris、IRIX、Windows PlayStation、Xbox等操作系统上。在如下工具中也进行广泛的应用。Blender - 3D 建模和渲染工具。Unity - 3D 游戏引擎和 IDE。Basic4gl - 编译器和编程软件。</p>
<h4 id="6-6-4-6、OpenGL"><a href="#6-6-4-6、OpenGL" class="headerlink" title="6.6.4.6、OpenGL"></a>6.6.4.6、OpenGL</h4><p>​    略（上主题已有讲述）。</p>
<h3 id="6-6-5、总结"><a href="#6-6-5、总结" class="headerlink" title="6.6.5、总结"></a>6.6.5、总结</h3><p>​    人工智能应用的广泛性，在机器视觉层面，不可能靠一套框架进行开发，未来在机器视觉、人工智能、音视频处理层面不排除有更多支持库的出现。</p>
<p>​    美摄SDK应用人工智能技术，在智能视觉、视音频领域进行着探索，为短视频技术的发展，写下浓重的一笔，</p>
<p>​    基于工业相机的软件编程。厂商提供驱动与程序示例。工程公司参考相关示例，通过算法对相机视频媒体数据进行加工分析。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149159.png" alt="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3462397246,2717035819&amp;fm=26&amp;gp=0.jpg"></p>
<p>​    机器视觉偏向于机器学习&#x2F;并行运算，运用数据挖掘技术，进行模型训练。机器视觉在硬件上往往和GPU关联，在框架支持上和大数据进行关联。</p>
<p>​    国外重点进行人工智能算法研究，人工智能方案策划，人工智能工具研发。国内重点进行工具应用。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149173.png" alt="img"></p>
<p>​    目前，国内应用最多的是TensorFlow和PyTorch，来进行模型训练，导出接口，在应用层面调用。形成各种人工智能系统。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149148.jpeg" alt="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1961163947,2304056094&amp;fm=26&amp;gp=0.jpg"></p>
<p>​    视频领域的人工智能系统是视频智能应用的主要标柱，国内人工智能发展日新月异，在视频方面也有一些完善的框架与接口，为人工智能视频系统提供算法支持。</p>
<h2 id="6-8、启示"><a href="#6-8、启示" class="headerlink" title="6.8、启示"></a>6.8、启示</h2><p>​    硬件是推动软件技术发展的原动力，在硬件技术进步的基础上，智能时代为图形图像、音视频领域添加了人工智能的成分。</p>
<p>​    从图形图像角度来说，不仅是硬性参数的提升，更是对图像数据的智能修复处理。从视频角度来说，不仅仅是摄影、录制、编排硬术的提升，更是对视频数据的深度挖掘。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149908.png" alt="img"></p>
<p>​    智能修复与深度处理从前是不可想象的，当流媒体技术过渡到深度处理时，代表着人类信息加工能力的显著增强。从早期自然语言处理到今天流媒体的并行运算，代表着是技术的巨大进步。</p>
<p>​    硬件水平的进步，尤其是工业相机水平的进步，促进了高清晰领域的图形图像处理。传统相机水平的提升，必将为视频处理提供新的发展方向与发展空间。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149895.png" alt="img"></p>
<p>​    机器视觉技术是智能时代的核心技术，机器视觉技术整体分为两部分。第一部分是基于工业相机的专业处理，第二部分是传统视频智能处理。</p>
<p>​    国外科技公司肩负着智能时代硬件发展的重任，推动GPU、TPU、NPU、专业相机等硬件功能提升。同时提供音视频、图形图像领域的算法验证，给出相关解决方案。</p>
<p>​    国内科技公司担负着人工智能终端应用的重任，以国外底层研发为基础，进行行业分类，市场整合，应用落地。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149919.png" alt="img"></p>
<p>​    在量子计算机发展的大背景下，不远的将来，相信技术将会发生变革，行业将会重新洗牌。人工智能的基础理论将会有翻天覆地的变化，人工智能的应用将会更深刻与广泛。今天的人工智能是量子时代的一个前走而已。真正的人工智能是量子时代人工智能。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149904.png" alt="img"></p>
<p>​    在第四次科技革命的智能时代，黄色面孔、东方公司逐渐增多，这个沉默了200年的民族，开始重新屹立于世界民族之林。</p>
<h1 id="7、显示标准与视频处理单元"><a href="#7、显示标准与视频处理单元" class="headerlink" title="7、显示标准与视频处理单元"></a>7、显示标准与视频处理单元</h1><p>​    消费级视频智能处理大体有10年左右，有了巨大的发展，展望未来，对应于大厂而言，竞争是标准的竞争。包含显示标准与处理单元，竞争推动了科技的进步，市场的繁荣。</p>
<p>​    新的显示硬件也不断发展，GPU基础上，出现了GPGPU、TPU、NPU、VPU、APU等新的视频处理单元，相信未来有更多的数据硬件处理单元出现。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150530.png" alt="img"></p>
<p>​    人工智能还处在初级阶段，标准与规范处在变化中，随着高清晰视频硬件的出现，软件算法很多方面也面临着调整。近些年各国重视人工智能的发展，资本的投入，政策的驱动增添了人工智能发展的活力。</p>
<h2 id="7-1、显示标准"><a href="#7-1、显示标准" class="headerlink" title="7.1、显示标准"></a>7.1、显示标准</h2><p>​    多年江湖厮杀，各路显卡被赶尽杀绝，留下英伟达和AMD，·目前显卡技术的革新，主要就是A卡与N卡技术的发展。英伟达偏重人工智能，AMD偏重于GCN与APU方向。</p>
<p>​    近期倡导的显示技术有英伟达的G-Sync和AMD的Freesync 2。在介绍G-Sync的同时，有必要介绍下V-Sync。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150439.png" alt="img"></p>
<h4 id="7-1-1、V-Sync"><a href="#7-1-1、V-Sync" class="headerlink" title="7.1.1、V-Sync"></a>7.1.1、V-Sync</h4><p>​    垂直同步又称场同步（Vertical synchronization），从CRT显示器的显示原理来看，单个像素组成了水平扫描线，水平扫描线在垂直方向的堆积形成了完整的画面。</p>
<p>​    屏幕的刷新过程是每一行从左到右（行刷新，水平刷新，Horizontal Scanning），从上到下（屏幕刷新，垂直刷新，Vertical Scanning）。当整个屏幕刷新完毕，即一个垂直刷新周期完成，会有短暂的空白期，此时发出 VSync 信号。所以，VSync 中的 V 指的是垂直刷新中的垂直-Vertical。</p>
<p>​    显示器的刷新率受显卡DAC控制，显卡DAC完成一帧扫描后就会产生一个垂直同步信号。打开垂直同步指的是将该信号送入显卡3D图形处理部分，这样让显卡在生成3D图形时受垂直同步信号的制约。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150488.png" alt="img"></p>
<p>​    显示器上的图像是一线一线扫描上去的，无论隔行扫描还是逐行扫描，显示器都有2种同步参数——水平同步和垂直同步。</p>
<p>​    水平同步脉冲（Horizontal synchronization pulse， Hsync）加在两个扫描行之间。它是一个短小的脉冲，一行扫描完成之后，它就会出现，指示着这一行扫描完成，同时也指示着下一行将要开始。</p>
<p>​    水平同步脉冲出现后，会有一小段叫horizontal back porch的时间，这段时间里的像素信号不会被显示出来，过了这一小段时间之后，电子枪就开始扫描新的一行，将要显示的内容扫描到显示器上。</p>
<p>​    垂直同步脉冲（Vertical synchronization， Vsync）是加在两帧之间。跟水平同步脉冲类似，但它指示着前一帧的结束，和新一帧的开始。 垂直同步脉冲是一个持续时间比较长的脉冲，可能持续一行或几行的扫描时间，但在这段时间内，没有像素信号出现。</p>
<h4 id="7-1-2、G-Sync"><a href="#7-1-2、G-Sync" class="headerlink" title="7.1.2、G-Sync"></a>7.1.2、G-Sync</h4><p>​    G-SYNC技术可解决V-SYNC带来的取舍问题，不论画面更新率有多快，它都可以让屏幕与GPU完全同步，提供无与伦比的PC游戏体验。通过NVIDIA G-SYNC技术游戏场景可即时呈现在玩家的眼前，物件也将更清晰锐利，游戏也变得更流畅。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150522.png" alt="img"></p>
<p>​    2013年10月18日，NVIDIA editor’s day第二天，连续发布GameStream PC Game for Shield以及ShadowPlay两项重磅技术之后，NVIDIA在加拿大蒙特利尔正式发布了全新的针对画面连贯性的新技术——G-SYNC。</p>
<p>​    作为垂直同步技术的替代以及自适应垂直同步技术的延伸，G-SYNC技术不仅解决了画面撕裂问题，同时从根本上解决了困扰垂直同步技术许久的画面视觉卡顿问题。 </p>
<p>​    G-SYNC技术在显示器中内置一枚可与GeForce硬件直接通讯的芯片，这枚自带缓存的芯片可以协调显示器与GPU outputbuffer之间的数据同步。</p>
<p>​    通过G-SYNC芯片的控制，显示器的刷新延迟将可以与GPU帧输出延迟保持完全一致，支持G-SYNC技术的显示器会根据GPU当前的性能水平自动调节刷新率，</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150502.png" alt="img"></p>
<p>​    G-SYNC芯片侦测到GPU的帧输出延迟大于16ms时，它会自动延长显示器的刷新延迟，避免传统的帧丢弃导致的视觉卡顿现象。</p>
<p>​    G-Sync能够去除游戏垂直同步（VSync）开启时的画面滞后问题，也能够克服垂直同步关闭时画面失真问题。常规显示器会直接同步GPU的处理结果，借助G-Sync模块，只有当GPU完成一帧的渲染和画面优化后，显示器才会刷新显示内容。 </p>
<p>​    很多公司都推出了支持G-Sync图像增强技术的显示器,消除了屏幕撕裂和垂直同步输入延迟等影响， 增强了现有显示器功能的同时屏幕画面呈现出场景及时出现、物体更加锐利以及游戏运行更加顺畅等出色的显示效果。G-Sync能强制显示器运行在GPU的帧速率下，甚至能让原生刷新率降到更低，提供更好的视觉效果。</p>
<h4 id="7-1-3、FreeSync2"><a href="#7-1-3、FreeSync2" class="headerlink" title="7.1.3、FreeSync2"></a>7.1.3、FreeSync2</h4><p>​    FreeSync 2 是AMD力推的视觉效果增强技术，可有效消除游戏中常见的撕裂(Tearing)、卡顿(Shuttering)现象，保证画面流畅、无撕裂、无卡顿、无伪影。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150545.png" alt="img"></p>
<p>​    图像撕裂是屏幕图像看起来不连贯，这是帧速率（显示图像帧的速率）与显示器刷新率（显示器图像刷新频率）不匹配的结果。FreeSync2为显示器提供可变刷新率，即动态刷新率（VRR &#x2F; DRR）。该功能使显示器的刷新率与AMD Radeon显卡的帧速率相匹配。</p>
<p>​    FreeSync2支持高达240Hz的刷新率，具体取决于显示器。这样，可以享受显卡能够达到的最大帧速率。如果眼睛够敏锐的话，你可能会发现到输入延迟，或者鼠标移动和光标实际移动之间的延迟也降低了。FreeSync基于VESA的自适应同步协议，可以在DisplayPort和HDMI上运行。</p>
<p>​    FreeSync2支持高动态范围&amp;色域支持，低延迟、低刷新率补偿技术等。让游戏显示效果更加逼真。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150733.png" alt="img"></p>
<p>​    从HDR内容到显示器传输时需要进行Tone Mapping，这个额外的计算增加了GPU处理数据，同时增加了延时。FreeSync2取消了传输过程的转换过程，降低HDR转换带来的延迟。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150710.png" alt="img"></p>
<p>​    FreeSync2引入的另一个新功能是LFC，Low Frame Rate Compensation低刷新率补偿技术，当游戏的FPS小于显示器最低刷新率时，通过额外插帧(GPU计算，类似MEMC)，让低FPS的画面更加流畅。LFC技术的应用，即时显卡渲染FPS较低时也可以显著的改善画面流畅度，提高游戏体验。</p>
<h4 id="7-1-4、总结"><a href="#7-1-4、总结" class="headerlink" title="7.1.4、总结"></a>7.1.4、总结</h4><p>​    显示器是显示部分的前端，显示标准对显示硬件的发展起着引导的作用，显示标准的变革通过传统硬件大厂来推动，目前而论，只有NVIDIA、AMD、INTEL才有这样的实力。</p>
<p>​    显示标准对于图形图像、视频、硬件都有着紧密的联系，发展过程中，标准的改变将推动软硬件的发展。</p>
<p>​    美摄SDK，支持G-Sync、V-Sync、FreeSync2标准，支持最新显示规范，彰显短视频价值。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150772.png" alt="img"></p>
<h2 id="7-2-VPU"><a href="#7-2-VPU" class="headerlink" title="7.2 VPU"></a>7.2 VPU</h2><p>   VPU(Video Processing Unit，视频处理单元）是一种全新的视频处理平台核心引擎，具有硬解码功能以及减少CPU负荷的能力。VPU可以减少服务器负载和网络带宽的消耗。</p>
<p>​    VPU由ATI提出，区别于传统GPU（Graph Process Unit，图形处理单元）。图形处理单元又包括视频处理单元、外视频模块和后处理模块这三个主要模块。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150284.png" alt="img"></p>
<h3 id="7-2-1、VPU的基础特性"><a href="#7-2-1、VPU的基础特性" class="headerlink" title="7.2.1、VPU的基础特性"></a>7.2.1、VPU的基础特性</h3><p>​    A、支持视频编解码标准类别丰富，图像高清。</p>
<p>​    B、支持多种抗误码工具、多解码和全双工多方通话同时进行。</p>
<p>​    C、提供了可编程性、柔初性，以及易于升级的解码和编码或主机接口，因为在编解码处理和主接口都实现为可编程微处理中的固件。</p>
<h3 id="7-2-2、VPU特色及应用"><a href="#7-2-2、VPU特色及应用" class="headerlink" title="7.2.2、VPU特色及应用"></a>7.2.2、VPU特色及应用</h3><p>​    VPU针对视觉处理应用而设计，在性能、功耗和功能性方面都有特别的强化，使之更贴近于实际的应用需求，其设计兼顾到多种用途，专门为视觉处理进行硬件系统的优化。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150269.png" alt="img"></p>
<p>​    VPU也是SoC，集成多个主控RISC的CPU、许多硬件加速器单元和矢量处理器阵列，专门为视觉海量像素设计的高性能影像信号处理器(ISP)，以及丰富的高速外围接口。</p>
<p>​    保证强大性能和功能的前提下，VPU采用更先进的集成电路工艺，大大缩小了芯片的尺寸，结合有效的技术手段，降低各个运算单元的功耗。</p>
<p>​    VPU为视觉应用提供了一个强大的平台，更多的开发工作是在软件上，基于VPU的视觉应用系统开发可以充分利用片上的硬件单元及相关的软件资源。</p>
<p>​    包含工具、支持库及框架的完整VPU软件开发套件(SDK)，视频处理器中涉及视觉处理的单元得到了增强，如核心视觉处理单元、线性代数运算矩阵，还有前端影像处理单元，不仅包含ISP处理，还有ISP仿真，支持相机调试工具。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150274.png" alt="img"></p>
<p>​    图形处理能力的提升表现在支持图形检测API，为便于多核异构芯片开发而支持OpenCL。由于在视觉应用中，与高敏感度和超高像素的传感器的接驳尤为重要，因此专门有传感器支持接口单元。</p>
<p>​    VPU特有的工具单元提供视觉调试全面支持。VPU中的主控制器、BSP、HDK等通用单元以开放为主，便于客户进行更多应用开发。</p>
<h3 id="7-2-3、Movidius"><a href="#7-2-3、Movidius" class="headerlink" title="7.2.3、Movidius"></a>7.2.3、Movidius</h3><p>​    作为一个行业的平台领先者需要有足够的积累和不懈的进取，当然还要有强大的财力和物力、人力的支持，VPU平台的创建和发展也绝不轻松。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150303.png" alt="img"></p>
<p>​    Movidius在都柏林成立，位于爱尔兰，在罗马尼亚，硅谷建立研发团队。公司创始人堪称半导体和处理器行业的元老，公司设立有技术指导委员会，确立公司的技术路线和VPU平台发展总体规划。</p>
<p>​    Movidius核心管理层，来源于ATI及其它知名公司资深的高管和专家。公司员工未过百人，研发人员占了九成，五分之一负责VPU芯片硬件设计，其余从事VPU上软件构建，可见VPU应用在很大程度上依赖于软件。2016年，Movidius被intel收购。</p>
<h3 id="7-2-4、INTEL"><a href="#7-2-4、INTEL" class="headerlink" title="7.2.4、INTEL"></a>7.2.4、INTEL</h3><p>​    2019年，英特尔人工智能峰会（Intel AI Summit 2019），英特尔展示了一系列新产品，旨在加速从云端到边缘的人工智能系统开发和部署，迎接人工智能浪潮的到来。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150309.png" alt="img"></p>
<p>​    英特尔展示了面向训练 (NNP-T1000) 和面向推理 (NNP-I1000) 的英特尔Nervana神经网络处理器 (NNP)。作为英特尔为云端和数据中心客户提供的首个针对复杂深度学习的专用 ASIC芯片，英特尔Nervana NNP具备超高扩展性和超高效率。</p>
<p>​    英特尔还发布了下一代英特尔Movidius Myriad视觉处理单元 (VPU)，用于边缘媒体、计算机视觉和推理应用。</p>
<h3 id="7-2-5、代码示例"><a href="#7-2-5、代码示例" class="headerlink" title="7.2.5、代码示例"></a>7.2.5、代码示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * VPUCoder.h</span><br><span class="line"> *</span><br><span class="line"> * Current, Only Support YUV420sp encoder and decoder</span><br><span class="line"> *</span><br><span class="line"> *  Created on: Dec 16, 2013</span><br><span class="line"> *      Author: henry</span><br><span class="line"> *</span><br><span class="line"> *  Example:</span><br><span class="line"> *</span><br><span class="line"> *  int main()</span><br><span class="line"> *  &#123;</span><br><span class="line"> *  int ret = InitCodec();</span><br><span class="line"> *  //===========encode video</span><br><span class="line"> *  ret = StartEnc(&quot;/sdcard/test.mkv&quot;, 1280, 720, 30);</span><br><span class="line"> *</span><br><span class="line"> *  while(1)</span><br><span class="line"> *  &#123;</span><br><span class="line"> *         //get data and length, //unsigned char* data; int length</span><br><span class="line"> *         ret = ProcessEnc(data, length);</span><br><span class="line"> *  &#125;</span><br><span class="line"> *  ret = StopEnc();</span><br><span class="line"> *</span><br><span class="line"> *  //===========decode video</span><br><span class="line"> *  ret = ProcessDec(&quot;/sdcard/test.mkv&quot;, 1280, 720);</span><br><span class="line"> *  return 0;</span><br><span class="line"> *  &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#ifndef VPUCODER_H_</span><br><span class="line">#define VPUCODER_H_</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Init encoder and decoder handle, only call once, must first call</span><br><span class="line"> *</span><br><span class="line"> * @return 0 is successful, another fail</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">int InitCodec();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * setup encoder configure</span><br><span class="line"> * @param filePath   : save file path</span><br><span class="line"> * @param enc_width  : video width</span><br><span class="line"> * @param enc_height : video height</span><br><span class="line"> * @param enc_fps    : video fps</span><br><span class="line"> *</span><br><span class="line"> * @return 0 is successful, another fail</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">int StartEnc(const char* filePath, uint32_t enc_width, uint32_t enc_height, uint32_t enc_fps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * stop encode video</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">void StopEnc();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @params data   : frame data</span><br><span class="line"> * @params length : frame length</span><br><span class="line"> *</span><br><span class="line"> * @return 0 is successful, another fail</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">int ProcessEnc(const unsigned char* data, uint32_t length);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * setup decoder configure</span><br><span class="line"> * @param filePath   : source file path</span><br><span class="line"> * @param enc_width  : video width</span><br><span class="line"> * @param enc_height : video height</span><br><span class="line"> *</span><br><span class="line"> * @return 0 is successful, another fail</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">int ProcessDec(const char* filePath, uint32_t dec_width, uint32_t dec_height);</span><br><span class="line">#endif /* VPUCODER_H_ */</span><br></pre></td></tr></table></figure>

<h3 id="7-2-6、总结"><a href="#7-2-6、总结" class="headerlink" title="7.2.6、总结"></a>7.2.6、总结</h3><p>​    GPU的概念由NVIDIA公司提出，GPU英文全称 Graphic Processing Unit，中文译为“图形处理器”。</p>
<p>​    VPU的概念由ATI公司提出，VPU英文全称 Visual Processing Unit，中文译为“视觉处理器”。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150391.png" alt="img"></p>
<p>​    GPU与VPU实际均为显示处理核心，GPU提供了更多图形接口，VPU提供了更多视频接口。2006年，ATI公司被AMD公司收购之后，已正式采用GPU的名字。</p>
<p>​    INTEL的加入，VPU近些年取得巨大的发展，社会发展中，视频处理愈来愈重要，VPU适应实时潮流，尤其在嵌入式领域应用广泛。</p>
<p>​    美摄SDK，国际领先的视频引擎，优秀的视频运算架构，引领短视频发展的方向。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150565.png" alt="img"></p>
<h2 id="7-3-APU"><a href="#7-3-APU" class="headerlink" title="7.3 APU"></a>7.3 APU</h2><p>APU是“Accelerated Processing Units”的简称，中文名字叫加速处理器，是AMD融聚未来理念的产品，它第一次将处理器和独显核心做在一个晶片上。</p>
<p>​    CPU与APU协同计算、彼此加速，具有高性能处理器和最新支持DX11独立显卡的处理性能，大幅提升电脑运行效率，实现了CPU与GPU真正的融合。APU是处理器未来发展的趋势。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150692.png" alt="img"></p>
<h3 id="7-3-1、AMD与APU"><a href="#7-3-1、AMD与APU" class="headerlink" title="7.3.1、AMD与APU"></a>7.3.1、AMD与APU</h3><p>​    从APU发展来看，AMD让CPU和GPU彻底融为一体，无论是AMD的Llano，还是Brazos，目标都是一致的。</p>
<p>​    AMD认为，CPU和GPU的融合分为四步进行：</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150725.png" alt="img"></p>
<p>​    第一步：物理整合(Physical Integration)，将CPU和GPU集成在同一块硅芯片上，利用高带宽的内部总线通讯，集成高性能的内存控制器，借助开放的软件系统促成异构计算。</p>
<p>​    第二步：平台优化(Optimized Platforms)，CPU和GPU之间互连接口进一步增强，统一进行双向电源管理，GPU支持高级编程语言。</p>
<p>​    第三步：架构整合(Architectural Integration)，实现统一的CPU&#x2F;GPU寻址空间、GPU使用可分页系统内存、GPU硬件可调度、CPU&#x2F;GPU&#x2F;APU内存协同一致。</p>
<p>​    第四步：架构和系统整合(Architectural &amp; OS Integration)，主要特点包括GPU计算环境切换、GPU图形优先计算、独立显卡的PCI-E协同、任务并行运行实时整合等等。</p>
<p>​    AMD Fusion系列APU将多核(x86)中央处理器、支持DX11标准的强大独立显卡性能以及高速总线融合在一块芯片上，拥有并行处理引擎和专门高清视频加速模块，实现数据在不同处理核心间的加速传递。</p>
<p>​    基于AMD Fusion APU的台式机、笔记本和高清轻薄本已经销售多年。基于AMD Fusion APU的平板电脑和嵌入式电脑有很多优点。高清视频播放效果流畅，满足多种应用的突破性的计算能力，全面支持DX以及强大的电池续航能力。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150720.png" alt="img"></p>
<p>​    AMD通过和宏碁、华硕、戴尔、富士通、惠普、联想、微星、三星、索尼、东芝等领先PC厂商合作，在电脑上推出基于AMD Fusion APU的新品。</p>
<p>AMD公司高级副总裁Rick Bergman表示：“简而言之，我认为AMD Fusion加速处理器是自从x86架构问世之后40余年来处理器领域最伟大的进步。通过这一跨越，我们让顾客能够随时随地体验高清视频、享受    超级个人计算体验，并且让笔记本电脑具备全天的电池续航能力。这是一个全新的产品系列，全新的视角，给消费者带来全新的精彩应用体验。”</p>
<h3 id="7-3-2、VISION引擎"><a href="#7-3-2、VISION引擎" class="headerlink" title="7.3.2、VISION引擎"></a>7.3.2、VISION引擎</h3><p>​    随着硬件技术的进步，高清视频的时代到来了。从YouTube视频网站到DirectX12电脑游戏再到蓝光碟片，得到广泛应用。AMD VISION引擎横空出世，一系列与高清视频相关的独特性能将使基于AMD APU的个人电脑为用户带来更加生动与逼真的高清视频体验。</p>
<p>​    VISION引擎汇集了下列功能：</p>
<ol>
<li>支持DirectX11标准</li>
<li>强大的并行处理能力加速应用性能提升</li>
<li>AMD Radeon™ HD 6800系列显卡整合UVD3视频加速模块</li>
<li>独特的图形驱动程序，每月更新，不断提高视频性能。</li>
</ol>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150709.png" alt="img"></p>
<p>​    带有VISION引擎标识的电脑代表着更强大的性能。更流畅的上网体验；华丽、流畅、安静的高清视频播放；使标清视频播放出高清效果；将2D内容转换成更立体的3D格式；轻松高清应用；为用户带来3D游戏体验。</p>
<p>​    运算体验与软件密不可分，开发者受到CPU和GPU处理信息时各自为战进行独立计算的制约。今天，AMD Fusion APU消除了这一障碍，开发者可以利用GPU的并行处理能力。</p>
<p>​    AMD Fusion技术全天电池续航能力，续航时间长达10小时以上。单芯片设计所带来的节电效果超过我们的预料。</p>
<h3 id="7-3-3、APU新品"><a href="#7-3-3、APU新品" class="headerlink" title="7.3.3、APU新品"></a>7.3.3、APU新品</h3><p>​    锐龙7 5700G处理器采用Cezanne（塞尚）核心，与AMD路线图中一致。其最高频率大约为4.75GHz，为8核16线程，三级缓存为16MB，只有“标准版”的一半，CPU测试成绩则绝对是锐龙5000级别的，轻松压制十代酷睿和自家的锐龙3000。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150701.png" alt="img"></p>
<h3 id="7-3-4、APU编程"><a href="#7-3-4、APU编程" class="headerlink" title="7.3.4、APU编程"></a>7.3.4、APU编程</h3><p>​    APU没有设计独立的开发环境，APU目前支持OpenCL与OpenGL、DirectX等。在并行编程领域，主要支持的是OpenCL。</p>
<p>   下面是OpenCL示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;CL/cl.h&gt;</span><br><span class="line"></span><br><span class="line">const int ARRAY_SIZE = 1000;</span><br><span class="line"></span><br><span class="line">//一、 选择OpenCL平台并创建一个上下文</span><br><span class="line">cl_context CreateContext()</span><br><span class="line">&#123;</span><br><span class="line">       cl_int errNum;</span><br><span class="line">       cl_uint numPlatforms;</span><br><span class="line">       cl_platform_id firstPlatformId;</span><br><span class="line">       cl_context context = NULL;</span><br><span class="line"></span><br><span class="line">       //选择可用的平台中的第一个</span><br><span class="line">       errNum = clGetPlatformIDs(1, &amp;firstPlatformId, &amp;numPlatforms);</span><br><span class="line">       if (errNum != CL_SUCCESS || numPlatforms &lt;= 0)</span><br><span class="line">       &#123;</span><br><span class="line">              std::cerr &lt;&lt; &quot;Failed to find any OpenCL platforms.&quot; &lt;&lt; std::endl;</span><br><span class="line">              return NULL;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //创建一个OpenCL上下文环境</span><br><span class="line">       cl_context_properties contextProperties[] =</span><br><span class="line">       &#123;</span><br><span class="line">              CL_CONTEXT_PLATFORM,</span><br><span class="line">              (cl_context_properties)firstPlatformId,</span><br><span class="line">              0</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       context = clCreateContextFromType(contextProperties, CL_DEVICE_TYPE_GPU,</span><br><span class="line">              NULL, NULL, &amp;errNum);</span><br><span class="line"></span><br><span class="line">       return context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//二、 创建设备并创建命令队列</span><br><span class="line">cl_command_queue CreateCommandQueue(cl_context context, cl_device_id *device)</span><br><span class="line">&#123;</span><br><span class="line">       cl_int errNum;</span><br><span class="line">       cl_device_id *devices;</span><br><span class="line">       cl_command_queue commandQueue = NULL;</span><br><span class="line">       size_t deviceBufferSize = -1;</span><br><span class="line">       // 获取设备缓冲区大小</span><br><span class="line">       errNum = clGetContextInfo(context, CL_CONTEXT_DEVICES, 0, NULL, &amp;deviceBufferSize);</span><br><span class="line">       if (deviceBufferSize &lt;= 0)</span><br><span class="line">       &#123;</span><br><span class="line">              std::cerr &lt;&lt; &quot;No devices available.&quot;;</span><br><span class="line">              return NULL;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // 为设备分配缓存空间</span><br><span class="line">       devices = new cl_device_id[deviceBufferSize / sizeof(cl_device_id)];</span><br><span class="line">       errNum = clGetContextInfo(context, CL_CONTEXT_DEVICES, deviceBufferSize, devices, NULL);</span><br><span class="line"></span><br><span class="line">       //选取可用设备中的第一个</span><br><span class="line">       commandQueue = clCreateCommandQueue(context, devices[0], 0, NULL);</span><br><span class="line"></span><br><span class="line">       *device = devices[0];</span><br><span class="line">       delete[] devices;</span><br><span class="line">       return commandQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 三、创建和构建程序对象</span><br><span class="line">cl_program CreateProgram(cl_context context, cl_device_id device, const char* fileName)</span><br><span class="line">&#123;</span><br><span class="line">       cl_int errNum;</span><br><span class="line">       cl_program program;</span><br><span class="line"></span><br><span class="line">       std::ifstream kernelFile(fileName, std::ios::in);</span><br><span class="line">       if (!kernelFile.is_open())</span><br><span class="line">       &#123;</span><br><span class="line">              std::cerr &lt;&lt; &quot;Failed to open file for reading: &quot; &lt;&lt; fileName &lt;&lt; std::endl;</span><br><span class="line">              return NULL;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       std::ostringstream oss;</span><br><span class="line">       oss &lt;&lt; kernelFile.rdbuf();</span><br><span class="line">       std::string srcStdStr = oss.str();</span><br><span class="line">       const char *srcStr = srcStdStr.c_str();</span><br><span class="line">       program = clCreateProgramWithSource(context, 1,</span><br><span class="line">              (const char**)&amp;srcStr,</span><br><span class="line">              NULL, NULL);</span><br><span class="line"></span><br><span class="line">       errNum = clBuildProgram(program, 0, NULL, NULL, NULL, NULL);</span><br><span class="line">       return program;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建和构建程序对象</span><br><span class="line">bool CreateMemObjects(cl_context context, cl_mem memObjects[3],</span><br><span class="line">       float *a, float *b)</span><br><span class="line">&#123;</span><br><span class="line">       memObjects[0] = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,</span><br><span class="line">              sizeof(float) * ARRAY_SIZE, a, NULL);</span><br><span class="line">       memObjects[1] = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,</span><br><span class="line">              sizeof(float) * ARRAY_SIZE, b, NULL);</span><br><span class="line">       memObjects[2] = clCreateBuffer(context, CL_MEM_READ_WRITE,</span><br><span class="line">              sizeof(float) * ARRAY_SIZE, NULL, NULL);</span><br><span class="line">       return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放OpenCL资源</span><br><span class="line">void Cleanup(cl_context context, cl_command_queue commandQueue,</span><br><span class="line">       cl_program program, cl_kernel kernel, cl_mem memObjects[3])</span><br><span class="line">&#123;</span><br><span class="line">       for (int i = 0; i &lt; 3; i++)</span><br><span class="line">       &#123;</span><br><span class="line">              if (memObjects[i] != 0)</span><br><span class="line">                     clReleaseMemObject(memObjects[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       if (commandQueue != 0)</span><br><span class="line">              clReleaseCommandQueue(commandQueue);</span><br><span class="line"></span><br><span class="line">       if (kernel != 0)</span><br><span class="line">              clReleaseKernel(kernel);</span><br><span class="line">       if (program != 0)</span><br><span class="line">              clReleaseProgram(program);</span><br><span class="line">       if (context != 0)</span><br><span class="line">              clReleaseContext(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">       cl_context context = 0;</span><br><span class="line">       cl_command_queue commandQueue = 0;</span><br><span class="line">       cl_program program = 0;</span><br><span class="line">       cl_device_id device = 0;</span><br><span class="line">       cl_kernel kernel = 0;</span><br><span class="line">       cl_mem memObjects[3] = &#123; 0, 0, 0 &#125;;</span><br><span class="line">       cl_int errNum;</span><br><span class="line"></span><br><span class="line">       // 一、选择OpenCL平台并创建一个上下文</span><br><span class="line">       context = CreateContext();</span><br><span class="line"></span><br><span class="line">       // 二、 创建设备并创建命令队列</span><br><span class="line">       commandQueue = CreateCommandQueue(context, &amp;device);</span><br><span class="line"></span><br><span class="line">       //创建和构建程序对象</span><br><span class="line">       program = CreateProgram(context, device, &quot;HelloWorld.cl&quot;);</span><br><span class="line"></span><br><span class="line">       // 四、 创建OpenCL内核并分配内存空间</span><br><span class="line">       kernel = clCreateKernel(program, &quot;hello_kernel&quot;, NULL);</span><br><span class="line"></span><br><span class="line">       //创建要处理的数据</span><br><span class="line">       float result[ARRAY_SIZE];</span><br><span class="line">       float a[ARRAY_SIZE];</span><br><span class="line">       float b[ARRAY_SIZE];</span><br><span class="line">       for (int i = 0; i &lt; ARRAY_SIZE; i++)</span><br><span class="line">       &#123;</span><br><span class="line">              a[i] = (float)i;</span><br><span class="line">              b[i] = (float)(ARRAY_SIZE - i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //创建内存对象</span><br><span class="line">       if (!CreateMemObjects(context, memObjects, a, b))</span><br><span class="line">       &#123;</span><br><span class="line">              Cleanup(context, commandQueue, program, kernel, memObjects);</span><br><span class="line">              return 1;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // 五、 设置内核数据并执行内核</span><br><span class="line">       errNum = clSetKernelArg(kernel, 0, sizeof(cl_mem), &amp;memObjects[0]);</span><br><span class="line">       errNum |= clSetKernelArg(kernel, 1, sizeof(cl_mem), &amp;memObjects[1]);</span><br><span class="line">       errNum |= clSetKernelArg(kernel, 2, sizeof(cl_mem), &amp;memObjects[2]);</span><br><span class="line"></span><br><span class="line">       size_t globalWorkSize[1] = &#123; ARRAY_SIZE &#125;;</span><br><span class="line">       size_t localWorkSize[1] = &#123; 1 &#125;;</span><br><span class="line"></span><br><span class="line">       errNum = clEnqueueNDRangeKernel(commandQueue, kernel, 1, NULL,</span><br><span class="line">              globalWorkSize, localWorkSize,</span><br><span class="line">              0, NULL, NULL);</span><br><span class="line"></span><br><span class="line">       // 六、 读取执行结果并释放OpenCL资源</span><br><span class="line">       errNum = clEnqueueReadBuffer(commandQueue, memObjects[2], CL_TRUE,</span><br><span class="line">              0, ARRAY_SIZE * sizeof(float), result,</span><br><span class="line">              0, NULL, NULL);</span><br><span class="line"></span><br><span class="line">       for (int i = 0; i &lt; ARRAY_SIZE; i++)</span><br><span class="line">       &#123;</span><br><span class="line">              std::cout &lt;&lt; result[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       std::cout &lt;&lt; std::endl;</span><br><span class="line">       std::cout &lt;&lt; &quot;Executed program succesfully.&quot; &lt;&lt; std::endl;</span><br><span class="line">       getchar();</span><br><span class="line">       Cleanup(context, commandQueue, program, kernel, memObjects);</span><br><span class="line"></span><br><span class="line">       return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-5、总结"><a href="#7-3-5、总结" class="headerlink" title="7.3.5、总结"></a>7.3.5、总结</h3><p>​    APU的成功，巩固了AMD的市场，和INTEL形成有力的竞争。推动处理器技术、架构技术、并行计算技术的发展。多年以来，INTEL吊打AMD，APU的出现，这一局面得到改变。</p>
<p>​    并行计算领域，APU主要支持OpenCL技术，随着时间的推移，OpenCL技术将不断完善，驱动将不断更新。</p>
<p>​    AMD有着光辉的过去，也应该有着辉煌的明天。为处理器的发展做出了卓越的贡献。图为台湾籍AMD总裁苏姿丰女士。英伟达的黄仁勋为苏姿丰的舅舅。在芯片领域，台籍华人有着卓越的贡献。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150730.png" alt="img"></p>
<h2 id="7-4-gpgpu"><a href="#7-4-gpgpu" class="headerlink" title="7.4 gpgpu"></a>7.4 gpgpu</h2><p>  通用图形处理器（General-purpose computing on graphics processing units，简称GPGPU），利用处理图形任务的图形处理器来计算原本由中央处理器处理的通用计算任务。这些通用计算与图形处理没有关系。</p>
<p>​    现代图形处理器有强大的并行处理能力和可编程流水线，流处理器可以处理非图形数据。在面对单指令流多数据流（SIMD），且数据处理的运算量远大于数据调度和传输的需要时，通用图形处理器在性能上大大超越了传统的中央处理器应用程序。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150945.png" alt="img"></p>
<h3 id="7-4-1、主要功能"><a href="#7-4-1、主要功能" class="headerlink" title="7.4.1、主要功能"></a>7.4.1、主要功能</h3><p>​    通用图形处理器是近年来出现的计算机芯片，在航空航天及防务应用中的高性能嵌入式计算中广泛应用。前一个十年里作为高端计算机游戏的图形处理引擎引入，是一种大规模并行处理器。不仅有助于复杂的浮点计算，而且容易编程。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150014.png" alt="img"></p>
<p>​    通用图形处理器芯片的主要设计制造商：加利福尼亚州圣克拉拉的NVIDIA公司和加利福亚州桑尼维尔的先进微型器件公司（AMD公司）。</p>
<h3 id="7-4-2、设计优势"><a href="#7-4-2、设计优势" class="headerlink" title="7.4.2、设计优势"></a>7.4.2、设计优势</h3><p>​    通用图形处理器广泛使用，其设计支持：包括“开放性图形库”（Open Graphics Library， OpenGL）语言、NVIDIA公司创造的并行处理编程语言CUDA、最近出现的“开放性计算语言”（ Open Computing Language， OpenCL）。硬件平台的支持为软件开发提供了便利。</p>
<p>​    下图是中国天树之新推出的最新7NM GPGPU。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150926.png" alt="img"></p>
<p>​    在OpenGL，CUDA和OpenCL编程技术出现之前，大规模并行处理的编程是一项困难的任务，为数不多的专家采用极其神秘(小众编程)语言才能够完成。新出现的软件编程框架，尤其是OpenCL有助于熟悉C语言和C++语言的程序编制人员接受通用图形处理器技术。</p>
<p>​    通用图形处理器中，多个处理核规则排列在一起，随着时间的推移，器件中处理核的数量会越来越多，通用图形处理器的软件没有必要随着处理器核数量的增加而重新编写。需要有较好的编程支持。软件框架应该适应硬件设计的改变。</p>
<h3 id="7-4-3、技术原理"><a href="#7-4-3、技术原理" class="headerlink" title="7.4.3、技术原理"></a>7.4.3、技术原理</h3><p>​    富兰克林说，通用图形处理器可以用来解析事物以得到可利用的信息，传递周围环境中的有用材料。通用图形处理器所擅长的是完成两方面的工作，一是表现事物，二是解析事物。</p>
<p>​    通用图形处理器芯片的应用领域从单一的图形处理装置扩展到了信号处理装置，通用图形处理器的软件编程语言也在向着信号处理和通用处理扩展。类似于“开放性图形库”（OpenGL）那样的图形处理语言就可以用于通用处理。</p>
<p>​    通用计算技术，让显卡参与原本CPU计算任务的技术，从提出到现在十余年时间，但是发展神速。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150899.png" alt="img"></p>
<p>​    十年前，高清视频刚流行时，编码高清视频对于电脑来说，处理非常困难。视频编码过程中，大部分运算都是浮点类型的，CPU不善于做这种运算，GPU对于这种类型的计算相当拿手，计算起来量又大又快，那个年代人们在思索，能否用GPU来编码高清视频。</p>
<p>​    当时业界的研究重点转向了GPGPU，英伟达凭借着强大的技术实力，在硬件与计算机平台领域。英伟达第一个推出了一套比较完整的解决方案，将原本CPU的运算搬到了GPU之上，视频编码速度比原先快了几倍。</p>
<p>​    CPU有着通用性的需求，它上面单个核心会设计的非常大而全面，并且由于CPU计算的特性，核心中很大一部分面积用来构建缓存（一个核心中往往有L1和L2两级缓存）和控制单元（解码器与分支预测等前端单元）。CPU功能的强大，代表着CPU本身体量的大，尤其对于缓存的集中。</p>
<p>​    实际用来运算的单元面积可能仅仅只占整个核心的一半甚至不到（如图）。种种原因使CPU没有办法做非常大的规模，一个核心中能塞入的东西有限，总体的核心数需要控制在一个合理范围中，多了就会发生各种问题。硬件集成是很麻烦的事情，当工艺没有足够进步的时间，集成发展的大门就关闭了。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150043.png" alt="img"></p>
<p>​    八核Coffee Lake的核心图，可以看到，四个核心的面积已经接近右边的集成GPU。而GPU的设计理念就简单很多，图形计算是一项简单直接的“粗活”，相对单调直接。复杂度远不如CPU要负责的各种各样不同类型的工作，当年想要提高图形计算速度的一个简单办法就是扩大处理器中含有的单元数量。</p>
<p>​    GPU对于特定的计算任务，有更大的计算单元，在运算能力上远超CPU，表现出来就是现在的GPU在浮点运算吞吐量上远超CPU。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150923.png" alt="img"></p>
<p>​    CPU与GPU在构造上的不同</p>
<p>​    GPU适合大批量特定计算，尤其是并行计算，几大图形软硬件厂商都推出了自己的GPGPU计算解决方案，下面主题进行介绍。</p>
<h3 id="7-4-4、支持方"><a href="#7-4-4、支持方" class="headerlink" title="7.4.4、支持方"></a>7.4.4、支持方</h3><h4 id="7-4-4-1、ATI-Stream"><a href="#7-4-4-1、ATI-Stream" class="headerlink" title="7.4.4.1、ATI Stream"></a>7.4.4.1、ATI Stream</h4><p>​    首先提出GPGPU实现的厂商是被AMD收购前的ATI，并专门提供了一套开发工具包（SDK），让程序员用该套工具调用GPU来参与计算的能力。不过由于各种限制和AMD收购ATI后支持不足，当时管理也比较混乱，这套SDK在与Nvidia CUDA的竞争中处于下风，后来AMD官方转向支持    OpenCL，这套SDK最终停止了开发。今天很少有人听到这套并行计算框架</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150205.png" alt="img"></p>
<p>​    ATI Stream Logo</p>
<h4 id="7-4-4-2、CUDA"><a href="#7-4-4-2、CUDA" class="headerlink" title="7.4.4.2、CUDA"></a>7.4.4.2、CUDA</h4><p>​    CUDA是Nvidia在G80时代推出的一项技术，也是今天最流行的技术。全称Compute Unified Device Architechture，统一计算架构。从G80核心开始，Nvidia率先采用了一种统一设计的架构，将原本管线分工式设计转变为统一化的处理器设计。</p>
<p>​    CUDA伴随着G80核心的发布一起公之于众，让程序员用C和C++来编写用GPU运行的程序，学习成本比ATI Stream要低一些。今天在并行计算集群领域，CUDA有着广泛的应用。例如TensorFlow和各种音视频引擎平台。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150197.png" alt="img"></p>
<p>​    Nvidia CUDA Logo</p>
<p>​    CUDA是目前应用最为广泛的一种GPGPU实现， Nvidia的强力推广之下，CUDA在许多领域大放异彩，今天拥有最光大的市场。英伟达曾经设计过无数成功的硬件，CUDA可以说是英伟达设计的最成功的并行计算平台。CUDA同时推动了英伟达硬件技术的应用</p>
<h4 id="7-4-4-3、OpenCL"><a href="#7-4-4-3、OpenCL" class="headerlink" title="7.4.4.3、OpenCL"></a>7.4.4.3、OpenCL</h4><p>​    上面两个GPGPU的实现都是有平台针对性的，要想用他们的解决方案你就得用AMD和英伟达的硬件，而OpenCL就不一样了。所谓Open就是一个开放的标准，但是需要各家硬件厂商为OpenCL提供驱动程序。</p>
<p>​    OpenCL最早由苹果公司开发出的异构计算框架，苹果公司将这套框架的草案提交到Khronos 组织，作为开放标准供业界使用。在2008年末，1.0版本正式公开，目前Intel、AMD与Nvidia的GPU都支持这套框架。这是除了CUDA之后，另一个流行的GPGPU计算框架。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150202.png" alt="img"></p>
<p>​    OpenCL不仅限于x86平台上提供的异构计算框架，跨平台和开放标注的特性，还可以使用专门的可编程电路来加速计算。有广泛的支持空间，业界对于它的支持非常广泛，下图是OpenCL联盟成员。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150253.png" alt="img"></p>
<p>​    OpenCL联盟</p>
<h4 id="7-4-4-4、DirectCompute"><a href="#7-4-4-4、DirectCompute" class="headerlink" title="7.4.4.4、DirectCompute"></a>7.4.4.4、DirectCompute</h4><p>​    微软是软件行业的老大，在并行计算领域，微软也在进行积极的探索。DirectCompute是微软从DirectX 10开始加入的用于通用计算目的的API集，调用GPU进行加速计算。</p>
<p>​    从Vista开始，Windows的各种桌面特效就开始采用DirectCompute来加速计算。在DirectX 11中，微软完善了这套API，并且在Windows系统上更多地使用GPU来加速计算系统界面的各种特效。</p>
<p>​    不仅仅是专业的图形图像、音视频领域，在操作系统领域，对并行计算的要求也很好。当我们在使用微软的VS技术时间，VS技术的一大技术支柱就是并行计算技术。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150332.png" alt="img"></p>
<p>​    GPU-Z显示该GPU支持的通用计算特性</p>
<h3 id="7-4-5、媒体编码加速"><a href="#7-4-5、媒体编码加速" class="headerlink" title="7.4.5、媒体编码加速"></a>7.4.5、媒体编码加速</h3><p>​    十年前，H.264等面向高清应用的视频编码刚流行，CPU的性能限制，编码一段H.264的视频是一件相当耗费时间的事情，所以人们想到了用GPU来加速视频的编码。</p>
<p>​    Nvidia刚推出CUDA的时候，就将加速视频编码作为该技术的一大卖点，免费提供了一个支持CUDA技术来转码的软件BadaBoom。后来，Nvidia在显卡上加入了专门用于视频编解码的硬件电路，开放了名为NVENC的编码API供软件工程师调用，通用计算也就此离开了这个距离我们最近的领域。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150434.png" alt="img"></p>
<p>​    BadaBoom加速视频转码</p>
<p>​    Adobe是图形图像、音视频技术的霸主。很早就在旗下的CS和CC软件中加入了GPGPU的支持，Premiere Pro和After Effect都支持OpenCL来加速视频实时预览和特效。Adode对并行计算技术的应用走在各家公司前列。</p>
<h3 id="7-4-6、视频补帧与画面优化"><a href="#7-4-6、视频补帧与画面优化" class="headerlink" title="7.4.6、视频补帧与画面优化"></a>7.4.6、视频补帧与画面优化</h3><p>​    英伟达、英特尔和AMD三家相继在自己的GPU中加入专用计算电路用以加速编解码视频之后，通用计算就离开了这个领域。不满足于既有的视频品质的人们，又相继开发出了新的可以利用GPGPU的功能：视频补帧。大大改善了视频质量。</p>
<p>​    视频补帧：是原本低帧数的视频，通过上下帧的计算，渲染出一帧原本不存在的画面补在两帧之间，使其观感更加流畅。</p>
<p>​    比如将24帧的视频补帧至60帧，视频质量圆润流畅。因为这个过程计算量过于庞大，使用CPU跟不上视频播放的速度，没法做到实时补帧，开发者就将这个功能搬到了GPU上来运行，很多人都曾经使用的SVP4，就是一个利用GPGPU的补帧软件。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150467.png" alt="img"></p>
<p>​    SVP4补帧软件界面</p>
<p>​    科技发展永无止境，视频技术也不例外。视频画面优化领域，强大的视频渲染器MadVR也是利用GPGPU来优化视频画面。</p>
<p>​    比如视频播放中出现的色带、色环，在压制过程中出现的瑕疵等，可以使用GPGPU在视频播放过程中进行实时的弥补。使视频更加圆润与高清，视频技术的发展永无止境。</p>
<h3 id="7-4-7、人工智能与深度学习"><a href="#7-4-7、人工智能与深度学习" class="headerlink" title="7.4.7、人工智能与深度学习"></a>7.4.7、人工智能与深度学习</h3><p>​    人工智能与深度学习是近年来非常热门的两个有关联的领域，训练人工智能需要非常大的数据计算量，这时候就可以利用上GPU的强大功能，谷歌的深度学习框架TensorFlow，以及FaceBook的Pytorch就使用CUDA来加速学习。</p>
<p>​    Nvidia这两年不断展示了它们在机器学习方面的一些结果，在RTX系列上引入的DLSS（深度学习抗锯齿）技术就是利用机器学习来达成的。</p>
<p>​    英伟达今天在人工智能领域占据着重要的位置，在科技发展过程中，很多公司靠软件驱动技术发展，英伟达靠硬件驱动技术的发展。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150471.png" alt="img"></p>
<p>​    DLSS技术</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150487.png" alt="img"></p>
<p>​    上图是CUDA在科研领域的一些应用，可以看到GPU就在我们的身边。</p>
<h3 id="7-4-8、超级计算机"><a href="#7-4-8、超级计算机" class="headerlink" title="7.4.8、超级计算机"></a>7.4.8、超级计算机</h3><p>​    英伟达在G80开始就推出同架构的高品质计算卡，Tesla品牌之下。诞生了很多用Tesla计算卡来组建的超级计算机。硬件技术的优势，导致英伟达在超算领域领跑全球。</p>
<p>​    人工智能是英伟达的发展方向，相信近几年，使用英伟达技术的计算机会逐渐增多。会曾经竞争贝尔·戈登奖的六个入围者中，五个使用了NVIDIA GPU提供支持的超级计算机。</p>
<p>​    英伟达联手ARM，在超级计算机领域中继续发力，预计未来采用GPGPU技术的超级计算机将会越来越多。</p>
<p>​    近些年，超级计算机硬件领域，英伟达有着强大的技术实力。在云平台上，英伟达超级计算硬件应用较多。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150578.png" alt="img"></p>
<p>​    GPGPU相对于PC，是新的概念，十余年的发展已经不仅局限于PC，还走向了其它领域，扎根于我们生活的每个角落。GPGPU已经在许多云计算平台上得到了应用，相信在以后，GPU会更加深入生活的更多方面，尤其与人工智能技术的结合，具有着巨大的应用空间。</p>
<h3 id="7-4-9、示例代码"><a href="#7-4-9、示例代码" class="headerlink" title="7.4.9、示例代码"></a>7.4.9、示例代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;CL/cl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &quot;tool.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/** convert the kernel file into a string */</span><br><span class="line">int convertToString(const char *filename, std::string&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    size_t size;</span><br><span class="line">    char*  str;</span><br><span class="line">    std::fstream f(filename, (std::fstream::in | std::fstream::binary));</span><br><span class="line"></span><br><span class="line">    if(f.is_open())</span><br><span class="line">    &#123;</span><br><span class="line">        size_t fileSize;</span><br><span class="line">        f.seekg(0, std::fstream::end);</span><br><span class="line">        size = fileSize = (size_t)f.tellg();</span><br><span class="line">        f.seekg(0, std::fstream::beg);</span><br><span class="line">        str = new char[size+1];</span><br><span class="line">        if(!str)</span><br><span class="line">        &#123;</span><br><span class="line">            f.close();</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f.read(str, fileSize);</span><br><span class="line">        f.close();</span><br><span class="line">        str[size] = &#x27;\0&#x27;;</span><br><span class="line">        s = str;</span><br><span class="line">        delete[] str;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;Error: failed to open file\n:&quot;&lt;&lt;filename&lt;&lt;endl;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**Getting platforms and choose an available one.*/</span><br><span class="line">int getPlatform(cl_platform_id &amp;platform)</span><br><span class="line">&#123;</span><br><span class="line">    platform = NULL;//the chosen platform</span><br><span class="line"></span><br><span class="line">    cl_uint numPlatforms;//the NO. of platforms</span><br><span class="line">    cl_int    status = clGetPlatformIDs(0, NULL, &amp;numPlatforms);</span><br><span class="line">    if (status != CL_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Error: Getting platforms!&quot;&lt;&lt;endl;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**For clarity, choose the first available platform. */</span><br><span class="line">    if(numPlatforms &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        cl_platform_id* platforms =</span><br><span class="line">            (cl_platform_id* )malloc(numPlatforms* sizeof(cl_platform_id));</span><br><span class="line">        status = clGetPlatformIDs(numPlatforms, platforms, NULL);</span><br><span class="line">        platform = platforms[0];</span><br><span class="line">        free(platforms);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**Step 2:Query the platform and choose the first GPU device if has one.*/</span><br><span class="line">cl_device_id *getCl_device_id(cl_platform_id &amp;platform)</span><br><span class="line">&#123;</span><br><span class="line">    cl_uint numDevices = 0;</span><br><span class="line">    cl_device_id *devices=NULL;</span><br><span class="line">    cl_int    status = clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, 0, NULL, &amp;numDevices);</span><br><span class="line">    if (numDevices &gt; 0) //GPU available.</span><br><span class="line">    &#123;</span><br><span class="line">        devices = (cl_device_id*)malloc(numDevices * sizeof(cl_device_id));</span><br><span class="line">        status = clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, numDevices, devices, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    return devices;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-10、总结"><a href="#7-4-10、总结" class="headerlink" title="7.4.10、总结"></a>7.4.10、总结</h3><p>​    GPGPU，带CPU处理能力的GPU。主要是GPU的工作，GPU的能力，可以协助CPU进行运算力，GPGPU（通用图形处理）超出GPU的能力范围，完全具备通用的数据处理。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150634.png" alt="img"></p>
<p>​    GPU，用于图形处理的芯片。（GPU也是一种CPU，相对于显卡）早期显卡是没有专门用做图形处理的GPU的，不支持3D。</p>
<p>​    CPU，用于数据处理的芯片（图形也可以认为是数据）。中央处理器，一种相对的概念。潜移默化被认定是放在主板上，通过向GPU传送指令，控制GPU。</p>
<p>​    AMD-APU，加速处理器。集成GPU核心的CPU，并且融合。不同于Intel I系（GPU与CPU独立工作）。</p>
<p>​    美摄SDK，采用CUDA、OpenCL、DirectCompute并行计算技术。基于CPU、GPU、GPGPU硬件平台，优秀的音视频引擎，推动音视频技术发展。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150707.png" alt="img"></p>
<h2 id="7-5-TPU"><a href="#7-5-TPU" class="headerlink" title="7.5 TPU"></a>7.5 TPU</h2><p>  TPU（Tensor Processing Unit）张量处理单元，为机器学习定制的芯片，经过专门深度机器学习方面的训练，它有更高效能（每瓦计算能力）。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150029.png" alt="img"></p>
<p>​    谷歌，2015年6月，I&#x2F;O开发者大会上推出的计算神经网络专用芯片，为优化自身的TensorFlow机器学习框架而打造，主要用于AlphaGo系统，谷歌地图、谷歌相册和谷歌翻译等应用中。进行搜索、图像、语音等模型和技术的并行处理。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150999.png" alt="img"></p>
<h3 id="7-5-1、TPU发展史"><a href="#7-5-1、TPU发展史" class="headerlink" title="7.5.1、TPU发展史"></a>7.5.1、TPU发展史</h3><p>​    2016 年，AlphaGo以4:1总分打败围棋世界冠军李世石，随后独战群雄，在与排名世界第一围棋的冠军柯洁对战胜利后宣布“隐退江湖”，背后的芯片开启了芯片产业的新篇章。</p>
<p>​    地覆天翻的四年，AI芯片领域，尤其是云端AI芯片，市场规模一路扶摇直上，成为芯片巨头和新势力虎视眈眈之地。</p>
<p>​    赛迪2019年8月发布的《中国人工智能芯片产业发展白皮书》，2018年全球云端AI芯片市场规模为62.1亿美元，这一数值预计在2021年达到221.5亿美元，巨大的市场将如火山爆发般呈现在众人眼前，芯片制造的高光时刻到来了。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150983.png" alt="img"></p>
<p>​    这片蓝海中，有一个角色起到了划时代的意义，它就是谷歌TPU（Tensor Processing Unit，张量处理单元）。</p>
<p>​    与李世石、柯洁，以及中日韩数十位围棋高手的围棋对战中脱颖而出后，谷歌TPU曾一路狂飙突进，独步天下，现在已演进到了第四代。它的出现，无疑打破了GPU、GPGPU曾一度称霸神经网络推理和训练市场的局面。在大数据、人工智能领域，谷歌的王者之风逐渐显现。</p>
<p>​    2019年5月，谷歌I&#x2F;O开发者大会上，万众瞩目的第四代TPU意外缺席，取而代之的是以1000个TPUv3组成的TPUv3 Pod，以及边缘AI芯片Edge TPU。即便如此，它仍通过一定程度的对外开放，以及辅助谷歌内部服务器应用深刻地影响着云端AI芯片市场。那次大会，后知后觉的人们意识到，谷歌卖的是方案与思想，谷歌已经脱离了技术。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150023.png" alt="img"></p>
<p>​    从市场角度看，未来云端AI芯片巨大的发展潜力和市场机遇为谷歌TPU提供了肥沃的土壤；另一方面，紧迫的算力瓶颈和摩尔定律放缓等问题也越来越难以忽视。谷歌属于未来科技公司，有无穷的可能。</p>
<h4 id="7-5-1-1、始于算力瓶颈，首秀人类围棋界"><a href="#7-5-1-1、始于算力瓶颈，首秀人类围棋界" class="headerlink" title="7.5.1.1、始于算力瓶颈，首秀人类围棋界"></a>7.5.1.1、始于算力瓶颈，首秀人类围棋界</h4><p>​    区别于GPU、GPGPU，谷歌TPU是一种ASIC芯片方案。ASIC全称为Application-Specific Integrated Circuit（应用型专用集成电路），是专为某种特定应用需求而定制的芯片。但一般来说，ASIC芯片的开发不仅需要花费数年的时间，且研发成本也极高，一直是个别公司的阵地。</p>
<p>​    对于数据中心机房中AI工作负载的高算力需求，许多厂商更愿意继续采用现有的GPU集群或GPU+CPU异构计算解决方案，也甚少在ASIC领域冒险。但谷歌说不了。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150008.png" alt="img"></p>
<p>​    谷歌2006年起产生了要为神经网络研发一款专用芯片的想法，而这一需求在2013年也开始变得愈发急迫。谷歌这家超前的公司，在未雨绸缪。当时，谷歌提供的谷歌图像搜索、谷歌照片、谷歌云视觉API、谷歌翻译等多种产品和服务，都需要用到深度神经网络。</p>
<p>​    庞大的应用规模下，谷歌意识到，夜以继日运行的数百万台服务器，它们内部快速增长的计算需求，使得数据中心的数量需要再翻一倍才能得到满足。然而，从成本还是从算力上看，内部中心已不能依靠GPU和CPU来维持。制造芯片的冲动变成了现实。</p>
<p>​    种种因素的推动下，不差钱的谷歌正式开始了TPU的研发之旅。经过研发人员15个月的设计、验证和构建，TPU 2014年研发完成，率先部署在谷歌内部的数据中心。谷歌强大的财力保证了研发的成功，成功很大程度源于不差钱。</p>
<p>​    内部秘密运行了一年外，谷歌TPU还在围棋界“大杀四方”，斩获“人机大战”的神话。在今天，谷歌还有多少技术，还装在黑匣子中呢？</p>
<p>​    使用TPU之前，AlphaGo内置1202个CPU和176个GPU击败欧洲冠军范惠。2015年与李世石对战时，AlphaGo才开始使用TPU，而当时部署的TPU数量，只有48个。TPU大开杀戒，进入无人之境。</p>
<p>​    这场对战胜利的“秘密武器”也在一年后的谷歌I&#x2F;O开发者大会上被揭开神秘面纱，TPU正式面世。在技术上，谷歌隐藏的太深。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150990.png" alt="img"></p>
<h4 id="7-5-1-2、谷歌TPU的迭代、云端构建、终端应用"><a href="#7-5-1-2、谷歌TPU的迭代、云端构建、终端应用" class="headerlink" title="7.5.1.2、谷歌TPU的迭代、云端构建、终端应用"></a>7.5.1.2、谷歌TPU的迭代、云端构建、终端应用</h4><p>​    面世后短短两年，谷歌TPU已经迭代到了第四代，性能亦不断跃升。随着研发的投入和广泛应用，谷歌也逐步推出可扩展云端超级计算机TPU Pod，以及Edge TPU。谷歌最终目的是超算领域与人工智能。今天，谷歌与英伟达成为超算领域的头狼。    </p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>发布日期</strong></th>
<th><strong>性能</strong></th>
<th><strong>应用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>TPU V1</td>
<td>2016年</td>
<td>28nm 功耗40w，主频700MHZ</td>
<td>深度学习推理</td>
</tr>
<tr>
<td>TPU V2</td>
<td>2017年</td>
<td>180TFLOPs浮点运算、64GB高带宽内存(HBM)</td>
<td>机器学习训练和推理，开始在Google Compute Engine上运行，以用于TensorFlow应用程序</td>
</tr>
<tr>
<td>TPU V3</td>
<td>2018年</td>
<td>420TFLOPs浮点运算，128GB(HBM)</td>
<td>扩展至更广泛的深度学习训练和推理领域，已进入Alpha测试阶段。</td>
</tr>
<tr>
<td>EDGE TPU</td>
<td>2018年</td>
<td>内建EDGE TPU、网络功能和加密芯片，具有高吞吐量。</td>
<td>企业中的机器学习任务而设计，主要执行AI推理。</td>
</tr>
<tr>
<td>TPU V2 POD</td>
<td>2019年</td>
<td>每秒11.5千万亿次浮点运算，4TB (HBM)、环面网状网络</td>
<td>深度学习领域</td>
</tr>
<tr>
<td>TPU V3 POD</td>
<td>2019年</td>
<td>每秒100千万亿次浮点运算、32TB(HBM)，环面网状网络。</td>
<td>深度学习领域</td>
</tr>
</tbody></table>
<h5 id="7-5-1-2-1、2016年：第一代TPU"><a href="#7-5-1-2-1、2016年：第一代TPU" class="headerlink" title="7.5.1.2.1、2016年：第一代TPU"></a>7.5.1.2.1、2016年：第一代TPU</h5><p>​    为神经网络而研发，但谷歌最初的第一代TPU仅用于深度学习推理。从性能上看，第一代谷歌TPU采用了28nm工艺制造，功耗约为40W，主频700MHz。</p>
<p>​    研发之初，谷歌需要尽快将TPU部署到内部现有的服务器中，因此研发人员选择将处理器打包成外部加速卡，以插入SATA硬盘插槽后进行嵌入式安装。毫无疑问的是，这种设计是成功的，并很快投入了应用。</p>
<p>​    TPU通过PCIe Gen3 x16总线连接到主机，实现了12.5GB&#x2F;s的有效带宽。除了在AlphaGo上应用之外，谷歌第一代TPU还用于谷歌的搜索、翻译和相册等应用的机器学习模型中。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150272.png" alt="img"></p>
<p>​    ▲Google第一代TPU（左），在谷歌数据中心中部署的TPU（右）</p>
<h5 id="7-5-1-2-2、2017年：第二代TPU，引入Google-Cloud"><a href="#7-5-1-2-2、2017年：第二代TPU，引入Google-Cloud" class="headerlink" title="7.5.1.2.2、2017年：第二代TPU，引入Google Cloud"></a>7.5.1.2.2、2017年：第二代TPU，引入Google Cloud</h5><p>​    一年更新、研发和迭代，谷歌在2017年5月发布了第二代TPU，并从这一代起能够用于机器学习模型的训练和推理。</p>
<p>​    与第一代相比，第二代TPU实现180TFLOPs浮点运算的计算能力，同时其高带宽内存（HBM）也提升到了64GB，解决了第一代TPU内存受带宽限制的问题。电子硬件的发展堪称神速。</p>
<p>​    运行AI工作负载上，谷歌第二代TPU与同期的CPU、GPU相比，性能比传统的GPU高了15倍，比CPU高了30倍，每瓦性能亦提高了30至80倍。硬件有强大的提升空间，保障谷歌思想的实现。</p>
<p>​    从第二代TPU起，谷歌第二代TPU引入Google Cloud，应用在谷歌计算引擎（Google Compute Engine ，简称GCE）中，也称为Cloud TPU，进一步优化谷歌搜索引擎、Gmail、YouTube和其他服务的运行。谷歌通过K8S进行云端软件技术处理，TPU提供硬件保障。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150286.png" alt="img"></p>
<p>​    同时，Cloud TPU通过TensorFlow进行编程，并与CPU、GPU及基础设施和服务结合，以根据用户应用需求构建和优化机器学习系统。谷歌在云上的技术铺垫深厚，谷歌未来的主战场是云端。</p>
<p>​    谷歌第二代TPU的发布，新一轮的人机大战也再次揭开序幕。而这一代AlphaGo的芯片配置，仅用了4块TPUv2，击败当时的世界围棋冠军柯洁。</p>
<p>​    谷歌除了推出第二代TPU外，还宣布计划研发可扩展云端超级计算机TPU Pods，通过新的计算机网络将64块Cloud TPU相结合，能够提供约11500万亿次浮点运算能力。强大的运算能力为谷歌平台提供了技术保障。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150307.png" alt="img"></p>
<h5 id="7-5-1-2-3、2018年：第三代TPU，边缘AI芯片Edge-TPU"><a href="#7-5-1-2-3、2018年：第三代TPU，边缘AI芯片Edge-TPU" class="headerlink" title="7.5.1.2.3、2018年：第三代TPU，边缘AI芯片Edge TPU"></a>7.5.1.2.3、2018年：第三代TPU，边缘AI芯片Edge TPU</h5><p>​    2018年5月，谷歌不出意外地发布了第三代TPU，其各方面性能不仅实现了升级，也进一步扩展到更广泛的深度学习训练和推理领域。我们怀疑的是，第三代TPU应该在2017年研发完成。</p>
<p>​    谷歌表示，第三代TPU的性能均是第二代TPU的两倍，可实现420TFLOPs浮点运算，以及128GB的高带宽内存。同时，它还可部署在基于云计算的超级计算机TPU Pod中，其中的芯片数量是上一代的四倍。这些数据表明，微电子技术的发展方兴未艾。</p>
<p>​    与第二代TPU Pod的部署相比，第三代每个Pod的性能提高了8倍，且每个Pod最多拥有1024个芯片。这些TPU的集群，形成了强大的狼群并行处理能力。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150437.png" alt="img"></p>
<p>​    谷歌2018年发布了用于边缘推理的微型AI加速芯片——Edge TPU，专为企业机器学习任务而设计，用于IoT设备中。市场是细分的，技术必须根据市场变动。</p>
<p>​    Edge TPU同样是一款ASIC芯片。从应用上看，它与Cloud TPU相互补，用户能够先使用Cloud TPU对机器学习模型进行加速训练，再将训练好的模型放入相关设备中，进一步用Edge TPU进行机器学习推理。TPU的芯片向纵深发展。</p>
<p>​    据了解，Edge TPU能够让IoT设备以每秒30帧以上的速度，在高分辨率视频上运行多个先进的计算机视觉模型。数据处理重要的一部分是计算机视觉，谷歌TPU这种技术，很可能在未来的某一天，这些硬件产品出现在我们身边。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150332.png" alt="img"></p>
<p>​    谷歌还为Edge TPU推出了一套名为Cloud IoT Edge的软件平台，该平台拥有Edge IoT Core和Edge ML两大主要组件，能够帮助用户将在Google Cloud上构建和训练的机器学习模型，通过Edge TPU扩展到边缘设备中运行。技术的开源是未来的发展趋势，软件平台的出现，为谷歌技术的推广推波助澜。</p>
<h5 id="7-5-1-2-4、2019年：第二-三代TPU-Pod"><a href="#7-5-1-2-4、2019年：第二-三代TPU-Pod" class="headerlink" title="7.5.1.2.4、2019年：第二&#x2F;三代TPU Pod"></a>7.5.1.2.4、2019年：第二&#x2F;三代TPU Pod</h5><p>​    这一年谷歌并未发布第四代TPU，却上演了另一个重头戏——发布第二代和第三代TPU Pod，可以配置超过1000颗TPU。强大的集群带来了强大的性能，在硬件技术突破的同时，谷歌在软件集群技术上也在进行着发展。</p>
<p>​    作为TPU的“升级版”，谷歌第二代TPU Pod能够容纳512个内核，实现每秒11.5千万亿次浮点运算；第三代TPU Pod速度则更快，可实现每秒超过100千万亿次浮点运算。这次升级之后，我们期待着谷歌新一代TPU的发布，相信带来更强大的性能。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150336.png" alt="img"></p>
<p>​    据悉，在相同配置（265块TPU）下训练ResNet-50模型时，第二代TPU Pod需要11.3分钟，而第三代TPU Pod只需7.1分钟。这些数据的背后，是TPU集群快速增长的结果。让我们很难想象的是，谷歌TPU在集群技术路上还能走多远。</p>
<h4 id="7-5-1-3、架构创新，掀起云端造芯大浪潮"><a href="#7-5-1-3、架构创新，掀起云端造芯大浪潮" class="headerlink" title="7.5.1.3、架构创新，掀起云端造芯大浪潮"></a>7.5.1.3、架构创新，掀起云端造芯大浪潮</h4><p>​    谷歌TPU系列芯片的出现，不仅突破了最初深度学习硬件执行的瓶颈，还在一定程度上撼动了英伟达、英特尔等传统GPU芯片巨头的地位。英伟达、AMD、INTEL在PC市场上这些传统霸主地位受到了挑战。</p>
<p>​    2015年以来，与AI芯片相关的研发逐渐成为整个芯片行业的热点，在云端的深度学习训练和推理领域，已然不是GPU，尤其是英伟达独霸一方。</p>
<p>​    谷歌TPU的诞生，越来越多的公司前赴后继地尝试设计GPU之外的专用AI芯片，进一步实现更高效的性能。这是一条成功的路线，科技巨头都在进行着尝试。</p>
<p>​    技术层面看，谷歌TPU的出现在架构创新上也为行业带来了以下思考。这种影响，在未来几十年将会深刻的感受到。</p>
<h5 id="7-5-1-3-1、大规模片上内存"><a href="#7-5-1-3-1、大规模片上内存" class="headerlink" title="7.5.1.3.1、大规模片上内存"></a>7.5.1.3.1、大规模片上内存</h5><p>​    谷歌看来，片外内存低是GPU能效比低的主要原因。一些GPU由于片上内存较少，因此在运行过程中需要不断地去访问片外动态随机存取存储器（DRAM），从而在一定程度上浪费了不必要的能耗。在从前，关于CPU与GPU上的内存是争论的喋喋不休的话题，在功耗等各方面都有考量。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150499.png" alt="img"></p>
<p>​    因此，谷歌在最初设计TPU时，总共设计了占总芯片面积37%的内存，其中包括24MB的局部内存、6MB的累加器内存，以及用于与主控处理器对接的内存。谷歌反其道而行之，用功耗换取效率。</p>
<h5 id="7-5-1-3-2、用量化技术进行整数运算"><a href="#7-5-1-3-2、用量化技术进行整数运算" class="headerlink" title="7.5.1.3.2、用量化技术进行整数运算"></a>7.5.1.3.2、用量化技术进行整数运算</h5><p>​    一般来说，神经网络的预测并不需要32位或16位的浮点计算精度，因此它可以通过8位低精度运算的方法，在保证适当准确度的同时，对神经网络进行预测。这种精细化的设计，适应了神经网络技术的需求。</p>
<p>​    通过量化技术，神经网络预测的成本大大减少，相应减少了内存的使用。例如，当研发人员将量化应用于流行的图像识别模型Inception时，芯片内存从91MB压缩到了23MB，约为其原始大小的四分之一。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150592.png" alt="img"></p>
<p>​    人工智能时代每一种算法数据都有自己的特点，神经网络作为人工智能的主流算法，有自己的计算特点，谷歌深谙此道，并对硬件改进，取得了GPU的成功。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150581.png" alt="img"></p>
<h5 id="7-5-1-3-3、可编程性"><a href="#7-5-1-3-3、可编程性" class="headerlink" title="7.5.1.3.3、可编程性"></a>7.5.1.3.3、可编程性</h5><p>​    虽然谷歌TPU是ASIC芯片，但却与FPGA又有些类似，它具备一定的可编程性能力。谷歌看来，TPU的研发并非只用于运行一种神经网络模型。因此，谷歌选择采用了复杂指令集（CISC）作为TPU指令集的基础，能够较为侧重地运行更复杂的任务。软硬件技术的结合是TPU成功的关键因素。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150636.png" alt="img"></p>
<p>​    谷歌还定义了十二个专门为神经网络推理而设计的高级指令，能够在输入数据和权重之间执行矩阵乘法，并应用激活函数。今天，国内的学习是从指令开始起步。</p>
<p>​    为了能进一步对TPU进行编程，谷歌还创建了一个编译器和软件堆栈，能够调用TensorFlow图中的API，转化成TPU指令。TPU与TensorFlow的融合，让TPU开始接底气，并为TensorFlow做大规模的神经网络数据训练打下基础。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150632.png" alt="img"></p>
<h5 id="7-5-1-3-4、并行计算"><a href="#7-5-1-3-4、并行计算" class="headerlink" title="7.5.1.3.4、并行计算"></a>7.5.1.3.4、并行计算</h5><p>​    谷歌为TPU设计了矩阵乘法单元（MXU）的并行计算。并行计算是数据发展的要求，今天并行计算是人工智能面临的第一个问题。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150715.png" alt="img"></p>
<p>​    它能够在一个时钟周期内处理数十万次矩阵运算，相当于一次打印一个字符、一次打印一行字或一次打印一页文档。这种高效的形式，是成功的关键因素所在。</p>
<h5 id="7-5-1-3-5、脉动阵列设计"><a href="#7-5-1-3-5、脉动阵列设计" class="headerlink" title="7.5.1.3.5、脉动阵列设计"></a>7.5.1.3.5、脉动阵列设计</h5><p>​    MXU具有与传统CPU和GPU截然不同的架构，又称为脉动阵列（systolic array）。不同硬件设计带来的效果是惊人的。</p>
<p>​    脉动阵列使得在每次运算过程中，谷歌TPU能够将多个运算逻辑单元（ALU）串联在一起，并复用从一个寄存器中都取得结果。脉动阵列设计形式，大大提高了效率。</p>
<p>​    这种设计，不仅能够将数据复用实现最大化，减少芯片在运算过程中的内存访问次数，同时也降低了内存带宽压力，进而降低内存访问的能耗。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150733.png" alt="img"></p>
<p>​    ▲TPU的矩阵乘法器单元（MXU）</p>
<p>​    谷歌TPU的一鸣惊人，不仅为AI芯片领域带来了架构创新，同时亚马逊、微软等一众科技巨头，以及寒武纪、天数智芯等新势力亦开始纷纷入局，云端AI芯片市场开始风起云涌，掀起行业云端造芯大浪潮。</p>
<p>​    这是一个芯片制造的年代，如果没有技术的积淀与雄厚资本的支持，芯片制造是水中花、镜中月，革命性芯片的研发投入在百亿以上。国内的弘芯、龙芯值得我们深思。</p>
<h3 id="7-5-2、TPU与机器学习"><a href="#7-5-2、TPU与机器学习" class="headerlink" title="7.5.2、TPU与机器学习"></a>7.5.2、TPU与机器学习</h3><p>​    TPU的出现，加速了第二代人工智能系统TensorFlow的运行，效率也大大超过GPU,Google的深层神经网络由TensorFlow引擎驱动。TPU是专为机器学习量身定做，执行每个操作所需的晶体管数量更少，自然效率更高。补充说明的是，能耗也更高。</p>
<p>​    TPU与同期的CPU和GPU相比，可以提供15-30倍的性能提升，以及30-80倍的效率（性能&#x2F;瓦特）提升。在人工智能发展过程中，效率的提升可以对算法进行有效的测试。由于效率问题，很多算法暂时无法测试。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150794.png" alt="img"></p>
<p>​    TPU每瓦能为机器学习提供比所有商用GPU和FPGA更高的量级指令，高性能计算得以在民间应用。TPU为机器学习应用特别开发，使芯片在计算精度降低的情况下更耐用。</p>
<p>​    在人工智能年代，未来，指令级编程将称为常态。对于国内大多数技术人员而言，对指令的熟悉程度影响着个人技术的发展。</p>
<p>​    每一个操作只需要更少的晶体管，用更多精密且大功率的机器学习模型，并快速应用这些模型，因此用户便能得到更正确的结果。</p>
<h3 id="7-5-3、对比说明"><a href="#7-5-3、对比说明" class="headerlink" title="7.5.3、对比说明"></a>7.5.3、对比说明</h3><p>​    CPU和GPU都是较为通用的芯片，但是有句老话是这样讲的：万能工具的效率永远比不上专用工具。而TPU就是一个专业工具。</p>
<p>​    随着社会的计算需求越来越专业化，芯片的专业化需求在增强。便产生了ASIC（专用集成电路）的概念。这个概念其实很早就出现了，但是ASIC不是任何一家公司都能尝试的，其复杂程度、集成程度堪称技术的堡垒。</p>
<p>​    ASIC是指依产品需求不同而定制化的特殊规格集成电路，由特定使用者要求和特定电子系统的需要而设计、制造。这些是定制化的芯片开发，定制化的芯片开发一直广泛存在。在这个领域，谷歌的TPU技术是成功的尝试。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150880.png" alt="img"></p>
<p>​    因为ASIC很“专一”，只做一件事，它就比CPU、GPU等能做很多件事的芯片在某件事上做的更好，实现更高的处理速度和更低的能耗。相应的，ASIC的生产成本也非常高。</p>
<p>​    TPU就是谷歌专门为加速深层神经网络运算能力而研发的一款芯片，其实也是一款ASIC。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150903.png" alt="img"></p>
<p>​    图：谷歌第二代TPU</p>
<p>​    原来很多的机器学习以及图像处理算法大部分都跑在GPU与FPGA（半定制化芯片）上面，但这两种芯片都还是一种通用性芯片，在效能与功耗上不能更紧密的适配机器学习算法。硬件改变的初衷便形成了</p>
<p>​    Google一直坚信伟大的软件将在伟大的硬件的帮助下更加大放异彩，所以Google便想，可不可以做出一款专用机机器学习算法的专用芯片，TPU便诞生了。</p>
<p>​    据称，TPU与同期的CPU和GPU相比，可提供15-30倍的性能提升，以及30-80倍的效率（性能&#x2F;瓦特）提升。第一代TPU只能做推理，依靠Google云实时收集数据并产生结果，训练过程还需要额外的资源；第二代TPU既可以用于训练神经网络，又可以用于推理。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150940.png" alt="img"></p>
<p>​    图：TPU 各模块的框图</p>
<p>​    如上图所示，TPU在芯片上使用了高达24MB的局部内存，6MB的累加器内存以及用于与主控处理器进行对接的内存，总共占芯片面积的37%（图中蓝色部分）。这在从前是不可想象的。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150992.png" alt="img"></p>
<p>​    图：TPU芯片布局图</p>
<p>​    这表示谷歌充分意识到了片外内存访问是GPU能效比低的问题所在，不惜成本的在芯片上放了巨大的内存。相比之下，同时期英伟达的K80只有8MB片上内存，需要不断地去访问片外DRAM。这种设计，和传统硬件设计有巨大的区别，也许只有谷歌财大气粗的公司才有如此的魄力吧。</p>
<h3 id="7-5-4、TPU性能与应用"><a href="#7-5-4、TPU性能与应用" class="headerlink" title="7.5.4、TPU性能与应用"></a>7.5.4、TPU性能与应用</h3><p>​    TPU的高性能还来源于对于低运算精度的容忍。研究结果表明，低精度运算带来的算法准确率损失很小，但是在硬件实现上却可以带来巨大的便利，包括功耗更低、速度更快、占芯片面积更小的运算单元、更小的内存带宽需求等。TPU采用了8比特的低精度运算。</p>
<p>​    不同的技术有不同的应用，不同的应用有不同的算法，不同的算法有不同的精度，TPU的神经网络不需要传统的精度，这和从前的很多设计思路是有区别的。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150043.png" alt="img"></p>
<p>​    目前为止，TPU已经干了很多惊天动地的事情，并且为我们服务了很多年。并且在更多领域应用。</p>
<p>​    机器学习人工智能系统RankBrain，帮助Google用户处理搜索结果；街景Street View，提高地图与导航的准确性；下围棋的计算机程序AlphaGo。这些大事记背后，代表着人工智能时代到来了。</p>
<h3 id="7-5-5、示例代码"><a href="#7-5-5、示例代码" class="headerlink" title="7.5.5、示例代码"></a>7.5.5、示例代码</h3><h4 id="7-5-5-1、变分程序"><a href="#7-5-5-1、变分程序" class="headerlink" title="7.5.5.1、变分程序"></a>7.5.5.1、变分程序</h4><p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150067.png" alt="img"></p>
<h4 id="7-5-5-2、并行VAE程序"><a href="#7-5-5-2、并行VAE程序" class="headerlink" title="7.5.5.2、并行VAE程序"></a>7.5.5.2、并行VAE程序</h4><p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150095.png" alt="img"></p>
<h3 id="7-5-6、总结"><a href="#7-5-6、总结" class="headerlink" title="7.5.6、总结"></a>7.5.6、总结</h3><p>​    从CPU到GPU，再到如今ASIC和FPGA相继入局，云端AI芯片市场百花齐放，与谷歌TPU的推动息息相关。</p>
<p>​    今天，云端AI芯片市场杀得热火朝天，前有赛灵思和寒武纪等新老势力不断崛起，进一步蚕食非GPU领域的市场，后有科技巨头四处找寻机会“大鱼吃小鱼”，合并有潜力的新玩家，整片市场呈一派割据混战、百家争鸣之势。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150188.png" alt="img"></p>
<p>​    不容忽视的是，随着云端AI芯片不断发展，大数据、云平台持续爆发，以及摩尔定律逐渐放缓，算力也再次来到新的瓶颈。</p>
<p>​    玩家是通过先进制程再次撕开云端AI芯片的新技术领域，还是依靠研发创新架构来实现算力的飞跃，不管走向哪条路都需直面种种挑战。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150244.png" alt="img"></p>
<p>​    在AI芯片市场开辟之初，谷歌凭借TPU逐渐打开云端AI芯片市场新的竞争格局，但当云端AI芯片开始进入新时代，谷歌在云平台大数据的技术优势，相信TPU能再次延续过往辉煌，为市场开辟新的方向和路径。</p>
<p>​    TPU由谷歌独家提出，独家研发，独家应用，这些能给我们多少启示呢？谷歌从一个搜索科技公司，过渡到大数据、云计算公司，进而走在人工智能、硬件科技的大道上。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150287.png" alt="img"></p>
<h2 id="7-6-npu"><a href="#7-6-npu" class="headerlink" title="7.6 npu"></a>7.6 npu</h2><p>NPU（Neural network Processing Unit）， 即神经网络处理器。用电路模拟人类的神经元和突触结构。NPU为神经网络而生，对神经网络进行硬件支持。</p>
<p>​    嵌入式神经网络处理器（NPU）采用“数据驱动并行计算”的架构，特别擅长处理视频、图像类的海量多媒体数据。视频与图像是人工智能数据的重要组成部分，在今天有着最广泛的应用。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151451.png" alt="img"></p>
<p>​    NPU是网络处理器，可以认为是一个组件（或者子系统），有时候也称为NPU协处理器。NPU和TPU一样，偏向于并行架构设计。</p>
<h3 id="7-6-1、生物神经网络"><a href="#7-6-1、生物神经网络" class="headerlink" title="7.6.1、生物神经网络"></a>7.6.1、生物神经网络</h3><p>​    生物神经系统是一个高度组织和相互作用的数量巨大的细胞组织群体。人类大脑的神经细胞大约在1011–1013个左右。神经细胞也称神经元，是神经系统的基本单元，按不同的结合方式构成复杂的神经网络。通过神经元及其联接的可塑性，使大脑具有学习、记忆和认知等各种智能。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151471.png" alt="img"></p>
<p>​    生物神经网络由若干人工神经元结点相互连接，神经元之间通过突触两两连接，突触记录了神经元之间的联系。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151523.png" alt="img"></p>
<p>​    生物神经元主要由以下几个部分组成：</p>
<p>​    胞体，是神经细胞的本体;</p>
<p>​    树突，用以接受来自其它细胞元的信号;</p>
<p>​    轴突，用以输出信号，与多个神经元连接;</p>
<p>​    突触，是一个神经元与另一个神经元相联系的特殊部位，神经元轴突的端部靠化学接触和电接触将信号传递给下一个神经元的树突或胞体。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151461.png" alt="img"></p>
<h3 id="7-6-2、人类神经网络"><a href="#7-6-2、人类神经网络" class="headerlink" title="7.6.2、人类神经网络"></a>7.6.2、人类神经网络</h3><p>​    电路模仿人类神经元，把每个神经元抽象为一个激励函数，函数输入由与其相连的神经元输出以及连接神经元的突触共同决定。</p>
<p>​    为了表达特定的知识，使用者通过某些特定的算法，调整人工神经网络中突触的取值、网络的拓扑结构等。该过程称为“学习”。学习方法有很多，这种方法，也叫算法。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151511.png" alt="img"></p>
<p>​    学习之后，人工神经网络通过习得的知识来解决特定的问题。生物神经网络的深度学习，基本操作是神经元和突触的处理。现在变成计算机处理，传统的处理器指令集（包括x86和ARM等）是为了进行通用计算发展起来的，其基本操作为算术操作（加减乘除）和逻辑操作（与或非），需要数百上千指令才能完成一个神经元的处理，深度学习的处理效率不高。</p>
<p>​    从通用计算到并行计算，再到神经网络计算，是近些年计算发展的一个重要特征。神经网络对人工智能的发展影响深远，人工智能科技公司的brain计划，神经网络往往占有较大成分。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151486.png" alt="img"></p>
<p>​    经典的冯·诺伊曼结构不能满足要求，神经网络中存储和处理是一体化的，通过突触权重来体现。冯·诺伊曼结构中，存储和处理是分离的，由存储器和运算器实现，二者之间存在巨大的差异。在TPU设计上，关于存储与运算也进行了深刻的论证。</p>
<p>​    现有的基于冯·诺伊曼结构的经典计算机（如X86处理器和英伟达GPU）来跑神经网络应用时，不可避免地受到存储和处理分离式结构的制约，影响效率。这也就是专门针对人工智能的专业芯片，能够对传统芯片有一定先天优势的原因之一，NPU实现了计算与存储的结合。。</p>
<h3 id="7-6-3、出现"><a href="#7-6-3、出现" class="headerlink" title="7.6.3、出现"></a>7.6.3、出现</h3><p>​    国内NPU典型代表有寒武纪芯片和国外IBM的TrueNorth芯片。以寒武纪为例，DianNaoYu指令直接面对大规模神经元和突触的处理，一条指令即完成一组神经元的处理，并对神经元和突触数据在芯片上的传输提供了一系列专门的支持。</p>
<p>​    指令编程不论对于人工智能，对于大数据处理、对于音视频和图形图像都有着重要的意义。</p>
<p>​    CPU、GPU、NPU相比，有百倍以上性能或能耗比差距。寒武纪团队和Inria联合发表的DianNao论文为例——DianNao为单核处理器，主频为0.98GHz，峰值达每秒4520亿次神经网络基本运算，65nm工艺下功耗为0.485W，面积3.02平方毫米mm。这就是专业设计的优势所在。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151735.png" alt="img"></p>
<p>​    mate10中的麒麟970芯片，集成了寒武纪的NPU，实现所谓的照片优化功能，保证手机用了很长时间后还能不卡。</p>
<p>​    华为从麒麟810芯片开始，使用自家研发的达芬奇架构集成NPU，大大提升了芯片的AI处理能力，至今采用了华为NPU的手机AI高性能计算仍是卖点之一。2018年10月，华为发布了最新的NPU芯片，包括用于云端训练的晟腾910和用于终端推理的晟腾310，晟腾系列NPU正式走入人们的视野。</p>
<p>​    华为手机使用NPU芯片，也是华为手机的成功要素之一。手机是终端，对视音频图形图像有着更多的应用，NPU的支持，保障应用的顺利进行。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151721.png" alt="img"></p>
<p>​    2019年9月25日，“云栖大会”上阿里正式对外发布了全新的含光800芯片。含光800是一款高性能的采用ASIC技术的用于云端推理的AI芯片NPU。</p>
<p>​    1颗含光800的算力相当于10颗GPU，含光800推理性能达到78563 IPS，能效比500 IPS&#x2F;W。相比传统GPU算力，性价比提升100%。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151789.png" alt="img"></p>
<p>​    举国造芯激动人心的时刻到来了，财大气粗的阿里不再沉默，达摩院重要的使命之一，就是造芯，资本的投入推动芯片技术的发展。</p>
<p>​    嵌入式神经网络处理器（NPU）采用“数据驱动并行计算”架构，擅长处理视频、图像类的海量多媒体数据。</p>
<p>​    NPU处理器专门为物联网人工智能而设计，用于加速神经网络的运算，解决传统芯片在神经网络运算时效率低下的问题。近些年，神经网络称为人工智能算法的重要支柱。</p>
<p>​    NPU可以和CPU、GPU、MCU结合，成为其中的一部分，NPU这种组合的模式，已经广泛使用。NPU也可以进行定制，大大加强了NPU的范围应用。</p>
<p>​    GX8010中，CPU和MCU各有一个NPU，MCU中的NPU相对较小，也被称为SNPU。NPU的应用已经步入家家户户，未来还有很大的发展空间。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151773.png" alt="img"></p>
<h3 id="7-6-4、组成"><a href="#7-6-4、组成" class="headerlink" title="7.6.4、组成"></a>7.6.4、组成</h3><p>​    NPU的结构充分考虑了神经网络运算的特点，专为神经网络运算而设计，各个模块通力结合，保障了神经网络算法的高效执行。</p>
<p>​    NPU处理器有如下几部分组成：乘加、激活函数、二维数据运算、解压缩等模块。</p>
<p>​    乘加模块用于计算矩阵乘加、卷积、点乘等功能，NPU内部有64个MAC，SNPU有32。</p>
<p>​    激活函数模块采用最高12阶参数拟合的方式实现神经网络中的激活函数，NPU内部有6个MAC，SNPU有3个。</p>
<p>​    二维数据运算模块用于实现对一个平面运算，如降采样、平面数据拷贝等，NPU内部有1个MAC，SNPU有1个。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151815.png" alt="img"></p>
<p>​    解压缩模块用于对权重数据的解压。为解决物联网设备中内存带宽小的特点，在NPU编译器中会对神经网络中的权重进行压缩，在不影响精度的情况下，可以实现6-10倍的压缩效果。</p>
<p>​    专业的设计，考虑了运算的方方面面，简单直接，面向问题。对通用专业硬件设计有一定的借鉴作用。下图为高通的NPU芯片，高通一直是嵌入式领域的王者。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151847.png" alt="img"></p>
<h3 id="7-6-5、代码示例"><a href="#7-6-5、代码示例" class="headerlink" title="7.6.5、代码示例"></a>7.6.5、代码示例</h3><p>​    华为NPU编程示例代码：</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151042.png" alt="img"></p>
<h3 id="7-6-6、总结"><a href="#7-6-6、总结" class="headerlink" title="7.6.6、总结"></a>7.6.6、总结</h3><p>​    NPU在现实中有着广泛应用，尤其在智能计算、图形AI识别领域。下面总结AI场景，对NPU应用进行整理。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151053.png" alt="img"></p>
<p>​    拍照时通过NPU实现AI场景识别，并利用NPU运算修图、.NPU判断光源和暗光细节合成超级夜景、通过NPU实现语音助手的运行、.使用NPU记录用户使用习惯杀后台。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151073.png" alt="img"></p>
<p>​    NPU配合GPU Turbo预判下一帧实现提前渲染提高游戏流畅度、NPU预判触控提高跟手度和灵敏度、NPU判断前台后台网速需求差异配合实现Link Turbo、跑分。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151075.png" alt="img"></p>
<p>​    NPU判断游戏渲染负载智能调整分辨率、NPU辅助清理系统18月不卡、把降低游戏时AI的运算负载交给NPU以省电、NPU实现CPU和GPU的动态调度。</p>
<p>​    利用NPU和人工智能算法定期更换壁纸的功能、NPU辅助大数据广告推送、NPU实现输入法AI智能联想词的功能。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151129.png" alt="img"></p>
<p>​    应用场景的支持下，NPU已经成为最重要的芯片。目前，NPU技术已经成熟，已经广泛应用愈交互领域。在手机、军工、嵌入式领域广泛应用。</p>
<p>​    美摄SDK，完美支持CPU、GPU、NPU运算。20年视音频技术积淀，在短视频领域，把人工智能应用做到极致。</p>
<p>​    <img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151207.png" alt="img"></p>
<p>  时光变幻，岁月横流，计算机应用的深度与广度增大，对图形图像处理也提出了更高的要求。传统的硬件设计、计算框架、运算理论、软件接口都面临着极大的挑战。为了适应人工智能技术的发展，软硬件技术都在进行着巨变。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151523.png" alt="img"></p>
<p>​    智能时代创造了很多机会，塑造了无数的科技巨头，公司有更大的科技自由度。智能时代技术百花齐放，硬件辈出、框架争鸣、平台显现、万马奔腾。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151543.png" alt="img"></p>
<p>​    不同的硬件框架适应显示的需求。显示技术的后面，有着GPU架构和并行计算架构在支持。在相关专题。阐述主流的CPU、GPU架构，CPU、GPU并行计算模型。</p>
<p>​    计算显示硬件发展的历史，可以看出，专业计算显示硬件往往是民间计算显示硬件发展的前奏，专业硬件发展成熟时，民间消费应用的春天到来了。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151495.png" alt="img"></p>
<p>​    专业性开发承担着更多的研发成本，各家公司道路不尽相同，成本相对高的项目，承担着巨大的风险。人工智能时代不仅仅是新的软件理论，计算框架，更是硬件技术的进步。</p>
<h1 id="8-前置说明："><a href="#8-前置说明：" class="headerlink" title="8 前置说明："></a>8 前置说明：</h1><p>​     至此、整个主题全部结束，借鉴了一些资料，如有异议，请联系作者。下面主题，开始讲述处理器架构与指令。</p>
<p>​    材料与制造技术的进步推动了微电子技术的发展，微电子技术的进步推动集成电路的发展，集成电路的发展推动了显示芯片的发展。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151795.png" alt="img"></p>
<p>​    显示技术发展过程中，遵从了双色芯片，2D芯片，3D芯片，再到智能芯片的发展过程，在芯片发展的背后，计算机图形学从早期的文本显示到后来2D、3D世界的呈现，再到今天机器视觉技术的发展。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151793.png" alt="img"></p>
<p>​    硬件技术的提升，带来了显示标准的变化。显示标准从早期的MDA，EGA、VGA、V-Sync到今天的G-Sync和Freesync 2。标准的出现指导着硬件的发展，为图形图像API、引擎的出现做了铺垫。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151796.png" alt="img"></p>
<p>​    从早期驱动编程，到API编程(GDI，GDI+，D2D，AGG，Cairo，Cocoa Drawing)，到专业图形引擎编程(Glide，OpenGL，D3D)，代表着图形图像技术的繁荣，图形图像引擎推动了音视频技术的发展。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151796.png" alt="img"></p>
<p>​    不同的显示标准带来计算机图形学的发展变化。图形图像硬件变革上，AMD推出APU的概念，同时推出APP并行运算框架，并对OpenCI大力支持，推出VEGA架构的显卡。英伟达推出自己的CUDA并行计算技术。Intel推出了Xe图形架构的显卡，推出图形库TBB，pafor编程包。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151823.png" alt="img"></p>
<p>​    硬件架构、运算平台、软件架构、编程框架是硬件厂商的问题，软件架构、编程框架面向终端市场。</p>
<p>​    国内大力激励半导体产业发展，寻求半导体技术的自主可控，芯片IP产业有望进入黄金时代。对于这个时代来说，选择从头做研发是很困难的事，将已有的IP放到芯片中则容易得多。</p>
<p>​    类似Imagination的这种总部在欧洲、具有中资背景，且具有几十年GPU IP积淀的半导体IP企业有望迎来新的契机。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151807.jpeg" alt="img"></p>
<p>​    人工智能发展大背景下，神经网络异军突起。为音视频发展注入了智能因素，把音视频深度应用推向一个新的高度。</p>
<p>​    美摄科技，以音视频技术为基础，以并行计算为依托，以人工智能技术、图形图像技术为双翼，推动融媒技术发展。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151835.jpeg" alt="img"></p>
<h1 id="9-常用术语"><a href="#9-常用术语" class="headerlink" title="9 常用术语"></a>9 常用术语</h1><h2 id="9-1、APU"><a href="#9-1、APU" class="headerlink" title="9.1、APU"></a>9.1、APU</h2><p>​    APU：Accelerated Processing Unit，加速处理器。AMD公司推出加速图像处理芯片产品。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151273.png" alt="img"></p>
<h2 id="9-2、BPU"><a href="#9-2、BPU" class="headerlink" title="9.2、BPU"></a>9.2、BPU</h2><p>​    BPU： Brain Processing Unit，大脑处理器。地平线科技提出的嵌入式人工智能处理器架构。第一代是高斯架构，第二代是伯努利架构，第三代是贝叶斯架构。目前地平线已经设计出了第一代高斯架构，并与英特尔在2017年CES展会上联合推出了ADAS系统（高级驾驶辅助系统）。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151290.png" alt="img"></p>
<h2 id="9-3、CPU"><a href="#9-3、CPU" class="headerlink" title="9.3、CPU"></a>9.3、CPU</h2><p>​    CPU：Central Processing Unit，中央处理器。目前PC 核心主流产品。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151313.png" alt="img"></p>
<h2 id="9-4、DPU"><a href="#9-4、DPU" class="headerlink" title="9.4、DPU"></a>9.4、DPU</h2><p>​    DPU：Deep learning Processing Unit，深度学习处理器。最早国内深鉴科技提出，基于Xilinx可重构特性的FPGA芯片，设计专用的深度学习处理单元，可基于已有的逻辑单元，设计并行高效的乘法器及逻辑电路，属于IP范畴，抽象出定制化的指令集和编译器，而非使用OpenCL，从而实现快速的开发与产品迭代。事实上，深鉴提出的DPU属于半定制化的FPGA。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151420.png" alt="img"></p>
<h2 id="9-5、FPU"><a href="#9-5、FPU" class="headerlink" title="9.5、FPU"></a>9.5、FPU</h2><p>​    FPU：Floating Processing Unit，浮点计算单元。通用处理器中的浮点运算模块。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151333.png" alt="img"></p>
<h2 id="9-6、GPU"><a href="#9-6、GPU" class="headerlink" title="9.6、GPU"></a>9.6、GPU</h2><p>​    GPU：Graphics Processing Unit，图形处理器。采用多线程SIMD架构，为图形处理而生。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151452.png" alt="img"></p>
<h2 id="9-7、HPU"><a href="#9-7、HPU" class="headerlink" title="9.7、HPU"></a>9.7、HPU</h2><p>​    HPU：Holographics Processing Unit，全息图像处理器。微软出品的全息计算芯片与设备。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151596.png" alt="img"></p>
<h2 id="9-8、IPU"><a href="#9-8、IPU" class="headerlink" title="9.8、IPU"></a>9.8、IPU</h2><p>​    IPU：Intelligence Processing Unit或者Image Processing Unit。与相机，显示相关。Deep Mind投资的Graphcore公司，开发出的AI处理器。包括：Display、Camera、Image Rotation, Inversion, Color Space Conversion、Image quality enhancement、 Video&#x2F;graphics combining。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151623.png" alt="img"></p>
<h4 id="9-9、MPU"><a href="#9-9、MPU" class="headerlink" title="9.9、MPU"></a>9.9、MPU</h4><p>​    MPU&#x2F;MCU：Microprocessor&#x2F;Micro controller Unit，微处理器&#x2F;微控制器。用于低计算应用的RISC计算机体系架构产品，如ARM-M系列处理器。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151616.png" alt="img"></p>
<h2 id="9-10、NPU"><a href="#9-10、NPU" class="headerlink" title="9.10、NPU"></a>9.10、NPU</h2><p>​    NPU：Neural Network Processing Unit，神经网络处理器。基于神经网络算法与加速的新型处理器总称，如中科院计算所&#x2F;寒武纪公司出品的diannao系列。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151718.png" alt="img"></p>
<h2 id="9-11、RPU"><a href="#9-11、RPU" class="headerlink" title="9.11、RPU"></a>9.11、RPU</h2><p>​    RPU：Radio Processing Unit，无线电处理器。Imagination Technologies公司推出的集合集Wifi&#x2F;蓝牙&#x2F;FM&#x2F;处理器为单片的处理器。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151782.png" alt="img"></p>
<h2 id="9-12、TPU"><a href="#9-12、TPU" class="headerlink" title="9.12、TPU"></a>9.12、TPU</h2><p>​    TPU：Tensor Processing Unit，张量处理器。Google 公司推出的加速人工智能算法的专用处理器。目前一代TPU面向Inference，第二代面向训练。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151725.png" alt="img"></p>
<h2 id="9-13、VPU"><a href="#9-13、VPU" class="headerlink" title="9.13、VPU"></a>9.13、VPU</h2><p>​    VPU：Vector Processing Unit，矢量处理器。Intel收购的Movidius公司推出的图像处理与人工智能的专用芯片的加速计算核心。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151878.png" alt="img"></p>
<h2 id="9-14、WPU"><a href="#9-14、WPU" class="headerlink" title="9.14、WPU"></a>9.14、WPU</h2><p>​    WPU：Wearable Processing Unit，可穿戴处理器。Ineda Systems公司推出的可穿戴片上系统产品，包含GPU&#x2F;MIPS CPU等IP。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151933.png" alt="img"></p>
<h4 id="9-15、XPU"><a href="#9-15、XPU" class="headerlink" title="9.15、XPU"></a>9.15、XPU</h4><p>​    XPU：百度与Xilinx公司在2017年Hotchips大会上发布的FPGA智能云加速，含256核。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151944.png" alt="img"></p>
<h2 id="9-16、ZPU"><a href="#9-16、ZPU" class="headerlink" title="9.16、ZPU"></a>9.16、ZPU</h2><p>​    ZPU：Zylin Processing Unit。 由挪威Zylin 公司推出的一款32位开源处理器。</p>
<h2 id="9-17、凸凹贴图"><a href="#9-17、凸凹贴图" class="headerlink" title="9.17、凸凹贴图"></a>9.17、凸凹贴图</h2><p>​    凹凸贴图：计算机图形学在三维场景中凸凹处理的一个技术。</p>
<p><img src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151998.png" alt="img"></p>
<h2 id="9-18、像素填充率"><a href="#9-18、像素填充率" class="headerlink" title="9.18、像素填充率"></a>9.18、像素填充率</h2><p>​    像素填充率：每秒渲染的像素数量，早期10亿级别，现在100亿级别。</p>
<h2 id="9-19、三角形生成速度"><a href="#9-19、三角形生成速度" class="headerlink" title="9.19、三角形生成速度"></a>9.19、三角形生成速度</h2><p>​    三角形生成速度：三角形是三维图形渲染的重要单元，当前从千万到亿级别不等。</p>
<h2 id="9-20、硬件T-L"><a href="#9-20、硬件T-L" class="headerlink" title="9.20、硬件T&amp;L"></a>9.20、硬件T&amp;L</h2><p>​    硬件T&amp;L：显卡坐标转换和光源编程。</p>
<h2 id="9-21、DDR-显存"><a href="#9-21、DDR-显存" class="headerlink" title="9.21、DDR 显存"></a>9.21、DDR 显存</h2><p>​    DDR 显存：显卡的高速颗粒，有更快的数据交互速度。</p>
<h2 id="9-22、HyperZ-技术"><a href="#9-22、HyperZ-技术" class="headerlink" title="9.22、HyperZ 技术"></a>9.22、HyperZ 技术</h2><p>​    HyperZ 技术：显存优化管理单元，通过快速Z轴清除等手段优化显存的利用效率。</p>
<h2 id="9-23、显卡流水线"><a href="#9-23、显卡流水线" class="headerlink" title="9.23、显卡流水线"></a>9.23、显卡流水线</h2><p>​    显卡流水线：数量的多少决定显卡性能高低的一个很重要的指标，Nvidia和AMD-ATI也在不断地增加显卡的流处理器数量使显卡的性能达到跳跃式增长。这个和核心构建，显存带宽等因素配合，单一多，意义不大。</p>
<h2 id="9-24、F-Buffer"><a href="#9-24、F-Buffer" class="headerlink" title="9.24、F-Buffer"></a>9.24、F-Buffer</h2><p>​    F-Buffer：片断流缓冲区技术，处理无限制指令长度的阴影着色程序。执行原理：把需要经过渲染引擎多次处理的像素临时存储起来，而不是把它们写到帧缓冲里面。只有那些需要单通道处理的数据被写到帧缓冲。这样节省显存的带宽，从而使VPU工作得更加有效率。缺点：F-Buffer只能对所有流程都是基于同一视点的多流程渲染有效，对于用于生成不同视点图像的多流程渲染没用，在日常3D应用中，不同视点的多流程渲染十分普遍。其次F-Buffer的执行过程有可能产生溢出，一旦产生溢出其处理过程十分复杂，会影响GPU的执行效率。</p>
<h2 id="9-25、FPGA"><a href="#9-25、FPGA" class="headerlink" title="9.25、FPGA"></a>9.25、FPGA</h2><p>FPGA：可编程逻辑，计算效率高，更接近底层IO，通过冗余晶体管和连线实现逻辑可编辑。本质上是无指令、无需共享内存，计算效率比CPU、GPU高。主要应用于智能手机、便携式移动设备、汽车。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2023/11/19/0-0-15%20%E6%98%BE%E7%A4%BA%E7%A1%AC%E4%BB%B6%E5%8F%91%E5%B1%95%E4%B8%8E%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%89%AB%E7%9B%B2/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81/" rel="tag">音视频编解码</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/11/20/0-0-16%20debian%E5%92%8Cubuntu%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA%E8%AF%A6%E8%A7%A3/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            0-0-16 ubuntu和debian文件系统构建详解
          
        </div>
      </a>
    
    
      <a href="/2023/11/19/0-0-14%20%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">0-0-14 音视频编解码相关知识学习</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> chai
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="热爱学习的未来酱"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E7%91%9E%E8%8A%AF%E5%BE%AE">瑞芯微</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%AD%A6%E4%B9%A0">学习</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=0&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>