<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>0-0-15 显示硬件发展与视频开发知识点扫盲 | 热爱学习的未来酱</title><meta name="keywords" content="音视频编解码"><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="0-0-15 显示硬件发展与视频开发知识点扫盲"><meta name="application-name" content="0-0-15 显示硬件发展与视频开发知识点扫盲"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="0-0-15 显示硬件发展与视频开发知识点扫盲"><meta property="og:url" content="http://example.com/2023/11/19/0-0-15%20%E6%98%BE%E7%A4%BA%E7%A1%AC%E4%BB%B6%E5%8F%91%E5%B1%95%E4%B8%8E%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%89%AB%E7%9B%B2/index.html"><meta property="og:site_name" content="热爱学习的未来酱"><meta property="og:description" content="电脑上炫酷的展示，生动的形象，离不开硬件的支持，硬件是音视频编程文化的一部分。开发者有必要对相关硬件大概了解。本专题涉及视频硬件相关话题，音频相关以后讲述。 ​    视频编程的本质是图形图像编程，本专题以时间为主线，以公司硬件发展为点位，以图像图像开发接口为切面，宏观进行介绍，希望对视频编程开"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="John Doe"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="电脑上炫酷的展示，生动的形象，离不开硬件的支持，硬件是音视频编程文化的一部分。开发者有必要对相关硬件大概了解。本专题涉及视频硬件相关话题，音频相关以后讲述。 ​    视频编程的本质是图形图像编程，本专题以时间为主线，以公司硬件发展为点位，以图像图像开发接口为切面，宏观进行介绍，希望对视频编程开"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2023/11/19/0-0-15%20%E6%98%BE%E7%A4%BA%E7%A1%AC%E4%BB%B6%E5%8F%91%E5%B1%95%E4%B8%8E%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%89%AB%E7%9B%B2/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: John Doe","link":"链接: ","source":"来源: 热爱学习的未来酱","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '热爱学习的未来酱',
  title: '0-0-15 显示硬件发展与视频开发知识点扫盲',
  postAI: '',
  pageFillDescription: '1、早期概述, 2、VGA编程, 3、2D时代, 3.1、公司, 3.1.1、Amiga, 3.1.2、IBM, 3.1.3、S3, 3.1.4、Trident, 3.1.5、Matrox（迈创）, 3.2、图形技术, 3.2.1、GDI编程, 3.2.2、GDI+编程, 3.2.3、Direct 2D, 3.2.4、AGG, 3.2.5、Cairo, 3.2.6、Cocoa Drawing, 3.3、总结, 4、3D时代, 4.1、公司, 4.1.1、3Dfx, 4.1.2、ATI, 4.1.3、NVIDIA, 4.1.4、3DLabs, 4.1.5、Video Logic, 4.1.6、intel, 4.1.7、AMD, 4.2、软件与硬件, 4.2.1、接口与硬件, 4.2.2、3D引擎, 4.2.2.1．OpenGL, 4.2.2.2、DirectX, 4.2.3、Shader编程, 4.2.2.1、Metal, 4.2.2.2、Vulkan, 4.3、启示, 5、移动时代, 5.1、手机时代, 5.2、移动端主流显示芯片, 5.2.1、ARM, 5.2.2、Qualcomm, 5.2.3、Apple, 5.2.4、Imagination Technologies, 5.2.5、Vivante, 5.2.6、NVIDIA、AMD、Intel, 5.3、移动图形库, 5.3.1、OpenGL ES, 5.3.1.1、OpenGL ES 版本与功能, 5.3.1.2、OpenGL ES 3.0新功能, 5.3.1.3、OpenGL ES 示例代码, 5.3.2、其它, 5.4、启示, 6 人工智能时代, 6.1、人工智能发展历史, 6.1.1、大事记, 6.1.2、启示, 6.2、硬件发展, 6.2.1、AIx2FARx2FVR芯片, 6.2.2、相机芯片, 6.2.2.1、传统相机, 6.2.2.1.1、CCD, 6.2.2.1.2、CMOS, 6.2.2.2、工业相机, 6.2.2.3、总结, 6.3、机器视觉, 6.4、机器视觉系统, 6.5、计算机视觉, 6.6、智能时代软件发展, 6.6.1、人工智能编程语言, 6.6.1.1、LISP, 6.6.1.2、Prolog, 6.6.1.3、OPS83, 6.6.1.4、Python, 6.6.1.4、启示, 6.6.3、机器学习库, 6.6.3.1、生物神经网络, 6.6.3.2、人工神经网络, 6.6.3.3、TensorFlow, 6.6.3.3.1、发展, 6.6.3.3.2、核心组件, 6.6.3.3.3、组件, 6.6.3.3.4、其它, 6.6.3.2、PyTorch, 6.6.2.1、CUDA, 6.6.2.1.1、应用, 6.6.2.1.2、系统结构, 6.6.2.1.3、核心, 6.6.2.1.4、其它, 6.6.2.2、OPENCL, 6.6.2.2.1、发展, 6.6.2.2.2、支持, 6.6.2.2.3、API, 6.6.2.2.4、总结, 6.6.4、其它相关库, 6.6.4.1、OpenCV, 6.6.4.1、简介, 6.6.4.2、应用, 6.6.4.3、接口, 6.6.4.2、OpenMP, 6.6.4.2.1、简介, 6.6.4.2.2、单线程与多线程, 6.6.4.2.3、OpenMP与MPI, 6.6.4.2.4、应用, 6.6.4.2.4.1、Windows环境下开发, 6.6.4.2.4.2、Linux环境, 6.6.4.2.5、同步协作, 6.6.4.3、OpenACC, 6.6.4.3.1、简介, 6.6.4.3.2、发展与应用, 6.6.4.3.3、硬件独立性, 6.6.4.3.4、实例01—parallel loops, 6.6.4.3.5、实例02—gangs and workers, 6.6.4.3.6、实例03—kernel regions, 6.6.4.5、OpenAL, 6.6.4.6、OpenGL, 6.6.5、总结, 6.8、启示, 7、显示标准与视频处理单元, 7.1、显示标准, 7.1.1、V-Sync, 7.1.2、G-Sync, 7.1.3、FreeSync2, 7.1.4、总结, 7.2 VPU, 7.2.1、VPU的基础特性, 7.2.2、VPU特色及应用, 7.2.3、Movidius, 7.2.4、INTEL, 7.2.5、代码示例, 7.2.6、总结, 7.3 APU, 7.3.1、AMD与APU, 7.3.2、VISION引擎, 7.3.3、APU新品, 7.3.4、APU编程, 7.3.5、总结, 7.4 gpgpu, 7.4.1、主要功能, 7.4.2、设计优势, 7.4.3、技术原理, 7.4.4、支持方, 7.4.4.1、ATI Stream, 7.4.4.2、CUDA, 7.4.4.3、OpenCL, 7.4.4.4、DirectCompute, 7.4.5、媒体编码加速, 7.4.6、视频补帧与画面优化, 7.4.7、人工智能与深度学习, 7.4.8、超级计算机, 7.4.9、示例代码, 7.4.10、总结, 7.5 TPU, 7.5.1、TPU发展史, 7.5.1.1、始于算力瓶颈首秀人类围棋界, 7.5.1.2、谷歌TPU的迭代、云端构建、终端应用, 7.5.1.2.1、2016年：第一代TPU, 7.5.1.2.2、2017年：第二代TPU引入Google Cloud, 7.5.1.2.3、2018年：第三代TPU边缘AI芯片Edge TPU, 7.5.1.2.4、2019年：第二x2F三代TPU Pod, 7.5.1.3、架构创新掀起云端造芯大浪潮, 7.5.1.3.1、大规模片上内存, 7.5.1.3.2、用量化技术进行整数运算, 7.5.1.3.3、可编程性, 7.5.1.3.4、并行计算, 7.5.1.3.5、脉动阵列设计, 7.5.2、TPU与机器学习, 7.5.3、对比说明, 7.5.4、TPU性能与应用, 7.5.5、示例代码, 7.5.5.1、变分程序, 7.5.5.2、并行VAE程序, 7.5.6、总结, 7.6 npu, 7.6.1、生物神经网络, 7.6.2、人类神经网络, 7.6.3、出现, 7.6.4、组成, 7.6.5、代码示例, 7.6.6、总结, 8 前置说明：, 9 常用术语, 9.1、APU, 9.2、BPU, 9.3、CPU, 9.4、DPU, 9.5、FPU, 9.6、GPU, 9.7、HPU, 9.8、IPU, 9.9、MPU, 9.10、NPU, 9.11、RPU, 9.12、TPU, 9.13、VPU, 9.14、WPU, 9.15、XPU, 9.16、ZPU, 9.17、凸凹贴图, 9.18、像素填充率, 9.19、三角形生成速度, 9.20、硬件TampL, 9.21、DDR 显存, 9.22、HyperZ 技术, 9.23、显卡流水线, 9.24、F-Buffer, 9.25、FPGA电脑上炫酷的展示生动的形象离不开硬件的支持硬件是音视频编程文化的一部分开发者有必要对相关硬件大概了解本专题涉及视频硬件相关话题音频相关以后讲述视频编程的本质是图形图像编程本专题以时间为主线以公司硬件发展为点位以图像图像开发接口为切面宏观进行介绍希望对视频编程开发者进行有益的启示本系列文章依发展顺序从早期起源开始再到时代时代移动时代智能时代最后到显示标准与专业视频处理单元大体分为部分早期概述回顾之前的电脑以及一些图形图像工作站那个年代图形图像编程起源于欧美发达国家毫不夸张的说欧美打开了计算机世界的大门后面简单描述了早期图形编程时代回顾了当年硬件产品编程接口等时代的到来迈出了图形图像编程的第一步拉开了多媒体编程的序幕时代是计算机图形学大发展的年代引擎的出现为图形学的发展注入了活力可以说时代的降临音视频技术的春天到来了移动时代是图形图像技术在嵌入式设备上拓展的年代多媒体引擎也发生了一些变化多媒体功能是手机最重要的功能之一未来音视频技术在手机上将会有大的发展人工智能的发展智能时代到来了音视频方面是人工智能应用最广泛的分支音视频技术是人工智能最重要的方向未来人工智能技术是音视频技术最核心的技术之一技术的发展没有穷尽硬件技术的进步显示标准和工业化硬件的出现给技术的发发展指明了方向早期概述早期图形图像处理主要靠一些工作站来完成之前的电脑仅进行基本的双色文本显示显示主要靠显示器和主板显示原器件做支持下图是年的和年的图形工作站其中是地球上第一台图形工作站之前国内谈不上电脑的视频编程专业的音视频处理主要靠图形图像工作站完成设备全靠进口图形图像软件的开发是国外专业芯片公司计算机设备公司开发当年的视频编程没有走向民间后来在消费级领域一些图形加速卡出现为图形图像编程做了前期的准备之前的图形图像工作站编程历史已经久远本专题不做阐述技术的发展推动了显示标准的改变从显示标准对硬件厂商做了规格的约束指引着显示技术的方向影响着图形图像技术的发展对视频研发产生影响推动末端技术应用历史的烽烟过去年代已经久远广袤的互联网上很难找到工作站编程的资料编程的出现显卡作为独立功能部件从主板上剥离这个改变图形图像编程的曙光出现了当年的图形图像编程还必须依靠厂家提供的视频驱动视频驱动的完备程度很大程度决定了硬件厂商的生存下面的代码老一代程序员应该对此并不陌生也就是这样的代码拉开了图形编程的序幕迈出了视频编程的第一步调用驱动程序设定背景颜色为黑色设定画线的颜色为白色设置当前线型实线线图样线宽四个像素画线起点终点当前位置到坐标画直线计算机发展过程中显示部件在设计上发生着变化下图是从年代到今天显卡发展过程图自从计算的出现相比其它领域计算机领域发展更快对社会影响更远厂商竞争更为激烈下面从公司产品技术的角度探讨时代时代几十年工艺改进解决了基本制造问题计算机开始向应用过渡显示问题是首当其冲的问题多年的思辨与实践技术横空出世完善发展为计算机的应用推广做出了卓越的贡献双色显示的星星之火在时代终于熊熊燃烧计算机走向民间的时代到来了下面从公司产品的角度回顾时代的图形图像编程公司是年代图形性能最强大的电脑之一拥有专门处理图形的芯片杰迈纳是当年显卡芯片设计的灵魂人物下图拆机红圈内的芯片就是专门用来负责处理图形的是真正意义上的加速卡这家公司在音视频多媒体领域超越当年的与遗憾的是最好的技术也被市场所淘汰年推出个人电脑提供了两种显卡一种是单色显卡简称一种是彩色绘图卡简称年又推出了又称大力士卡除了显示图形外还保留了原来的功能是世界第一块显卡制造商在年开始造显卡画质领域无人能及盛极一时的也无奈败下阵来最经典的产品当属有着高速的性能和强大的软解实力支持的分辨率在低分辨率下支持最高真彩色那是一个满天飞的年代显卡的解压能力是视频底层技术的一个突破几经被转卖先被威盛收编后被揽入囊中今天步履蹒跚生死一线这家公司当年在显卡领域红极一时在当年的产品专柜里多次看到其身影后期由于技术方向原因在显卡年代被淘汰最终在年被收购而最终在后来被纳入麾下迈创曾经独显领域的主要玩家显卡时代声名显赫时代落寞最终转向小众视频市场如今说起显卡很多人脑海里只会浮现两个名字在上个世纪末迈创的名字如雷贯耳它的资格比要老得多迈创来自加拿大也是成立于年比早年比早年图形技术年年是沉闷寂寥的时代显示技术发展缓慢图形图像编程近乎停滞市场期待着集成电路的发展微电子技术的爆发年之后硬件技术的春天到来了显卡涌现性能和技术有很大提升鸟语花香百家争鸣厂商不断推陈出新才能生存跟不上节奏的企业逃不了被收购的命运缅怀过去继往开来技术多年的发展为技术做了年的铺垫结合过去历史回顾当年编程的技术编程当时图形图像编程多使用技术代码示例编程的出现代表了消费级图像编程的兴起编程是的增强版想当年平台的上的图形图像技术走在各个平台的前端编程为和做了铺垫代码示例无论还是技术都代表着图形图像编程的年代到来了的出现代表着引擎技术的到来体现了市场对图形图像音视频技术的强烈需求在引擎的背后封装了图形图像技术的专业性与复杂性代码示例全名一个开源的高效图形库的功能与的功能类似提供了比更灵活的编程接口产生的图形的质量非常高跨平台的图形引擎可在等平台上运行设计上师出库使用了大量的语法规则包括模板仿函数等处理为了能在更多平台上使用并没有直接使用和库自己实现了部分功能是一个免费的矢量绘图软件库可以绘制多种输出格式支持许多平台包括等绘图可以通过系统图像缓冲格式或上下文来实现的主要设计目标是提供尽可能接近的输出这种一致的输出使非常适合工具集编程和跨平台应用程序开发使用同一个绘图库打印高分辨率的屏幕和绘制屏幕内容这种功能具有显著的优点在支持的目标平台上尝试智能化地使用底层硬件和软件支持高质量矢量图形和高性能的结合使成为优秀的绘图系统用编写的为大多数常用的语言提供了绑定选用语言有助于创建新的绑定在进行语言调用时提供高性能和绑定支持快速原型开发降低了学习绘图的门槛代码示例是苹果公司的图形图像开发类库在下运用旨在推广苹果公司的技术纵然苹果一直有着很强的图形图像处理能力但仅局限于苹果公司本身的软件苹果在早期一直没有很好的图形图像编程引擎近些年苹果的技术才可以算作苹果公司真正的技术创举代码示例总结计算机功能的强大代表本身的强大本身的强大代表体系的复杂模块的组合视频技术也不例外从宏观角度来看图形图像编程框架如下图软硬件技术是紧密结合的硬件技术的进步推动了软件编程的繁荣软件技术的应用促进了硬件的推广早期的硬件公司驱动设计专业级的编程接口研发到后期消费级市场软件技术的繁荣图形图像编程形成独立的软件阵地呼唤着时代的到来时代历史长河中科技进步是人类文明的主要推动力沧海桑田天下多变人类对科技的研究与探索从未停止计算显示技术也不例外现实是的显示硬件注定也是的透过历史的云烟得到岁月的启示硬件对技术的支持是显卡厂商存活的根本硬件对图形图像引擎的支持是显示芯片公司做大做强的基础引擎支持主要包括和引擎支持在年前尤为明显科技的风风雨雨面临着技术的抉择和选型无论辉煌黯淡时光默然前行那些远行的技术做了科学的辩证公司年成立在当时是一家小公司定位明确很快就推出了业界的第一块真正意义的图形加速卡在当年在速度以及色彩方面的表现让喜欢游戏的用户为之疯狂几乎是玩家们唯一的选择当年的专用引擎接口统治了整个世界当年一个专业图形引擎可拯救一系列产品成就一家硬件厂商引擎提供了专业的图形显示接口可以说是一套接口库凭借硬件与引擎的结合创造了发展历史上的奇迹的成功就是在硬件支持和相关引擎支持良好的表现从硬件上实现了缓存和双缓存可进行光栅化之类的操作实现了的特征集从繁重的像素填充任务中解脱出来当然当年的技术不成熟顶点变换必须在中完成光栅化之后的像素操作也很有限说起显卡我们不能不提由于对技术支持较好以及紧跟和步伐多年和英伟达齐名后来由于显卡驱动问题造就了卡追击卡的局面提供了良好的编程接口成为推广的一个重要因素的欻创始人何国源先生广东新会人在很多年间都是芯片界的顶级人物在年以亿美元收购何国源从此退出显卡芯片行业今天世界上很多电脑的显卡都有的技术下面是显卡领域的两个风云人物何先生已金盆洗手退出江湖黄药师依然皮衣挂帅征战一线市场风云变幻毫无疑问是幸运的当年潜图问鼎雄霸天下直至后来被高价收购多年后的今天卡依然笑傲江湖提起显卡必须提及另外一个厂家英伟达的创始人黄仁勋先生台湾台北人江湖人称黄药师老黄近年以来世界顶级芯片巨头在图形处理芯片上何国源和黄仁勋都做出了不可磨灭的贡献图形处理芯片的前身就是今天的是英伟达推出的通过系列产品小试牛刀通过系列产品出征江湖屡战屡胜战功显赫今天稳坐显示领域第一把交椅无人出其左右在人工智能数据分析方面英伟达依然战功显赫想当年显示领域是英伟达和的天下两者相互竞争推动了显示技术的发展成就了今天的显示规范当年的竞争本质是显示指令编程效率的竞争英伟达的开始支持取得了巨大的成功后期开始支持也就是前期对这些框架支持不足导致经营举步维艰年月公司发布了一款代号为的图形芯片是图形芯片领域开天辟地的产品因为它是第一款提出概念的产品所采用的核心技术有硬件立方环境材质贴图和顶点混合纹理压缩和凹凸映射贴图双重纹理四像素位渲染引擎等硬件的出现让显示芯片具备了以前只有高端工作站才有的顶点变换能力同时期的和都提供了硬件顶点变换的编程接口年的概念就这样出现了的推出不仅仅是硬件体系的革命性变化更是对显示标准的强大支持今天引擎编程核心主要也是面向的编程后期被收购纵然没有英伟达耀眼但整体发展还算顺利形成了卡和卡竞争的格局年英伟达收购市值超过亿美元超过亿美元成为全球市值排名在西方的土地上一个黄种人一个台湾人战功显赫技术飞速发展专业显卡需求增大专业公司应运而生就是这样的公司开发高端绘图芯片对的完美支持性能强大当时的普通显卡难以完全支持当年在专业显卡市场的产品几乎是唯一选择面对瞬息万变的世界还是落后了对技术重视不足和对过度依赖最终被黄药师的干掉于年被创新科技收购成为旗下子公司对的支持程度不仅仅影响民间显卡对专业显卡也有很大的影响显卡的发展不仅仅要考虑更要考虑是微软的操作系统是微软的垄断操作系统的存在对是一个强大的支持公司决定软件软件决定硬件又一次得到体现前期主打产品是当年也涉足桌面显卡市场比较有名的就是芯片性能强大支持然而驱动程序兼容性较差游戏运行有问题对要求较高影响了销售即使如此在很长时间内市场占有率一直保持第二对图形图像引擎的支持驱动的友好程度决定了硬件的发展后期由于优化不好兼容性问题软件冲突等容易引起渲染错误或性能下降离不开最终被转卖的命运相比太多厂商是幸运的桌面市场失败了但睿智的转向了移动图形市场避免了桌面市场的残酷竞争发挥了自己的技术优势移动端成为未来的趋势成为移动显示领域的重要力量端计算机图形学发展的同时移动端技术的兴起移动端细分专业显示芯片的出现进而发展成为独立的领域计算机图形学向精细化发展英特尔是美国一家以研制为主的公司是全球最大的个人计算机零件和制造商成立于年具有年产品创新和市场领导的历史年英特尔推出了全球第一个微处理器微处理器所带来的计算机和互联网革命改变了整个世界年月英特尔推出处理器至强采用了多达个处理器核心成为英特尔核心数最多的处理器年月英特尔推出至强铂金它有个线程是线程最多的处理器年月福布斯全球品牌价值强发布英特尔排名第位月日英特尔推出了新的极简主义谈到显卡不能回避由于特殊的地位相比其它厂商在显卡的道路上走的相对平稳与踏实就是推出的第一款产品极大的推动了标准的发展专注于集成显卡领域从之后再也没有推出过独立显卡成了独立显卡的绝唱纵然在显卡领域没有大的建树但一直在坚守显卡即被收购显卡俗称卡搭载公司的显示芯片与齐名同为世界两大显示芯片厂商之一由于收购关系在本专题中不做过多讲述是目前业内唯一一个可以提供高性能高性能独立显卡主板芯片组三大组件的半导体公司为明确其优势提出平台新标志在笔记本领域有标志的就表示该电脑采用构建方案今天显卡市场是卡与卡的天下年第四季度出货量环比大增份额减少份额微增份额由于计算将核显算在内并无优势在独显方面出货量占比较上季度的和去年的均有增加但仍旧以垄断剩余市场今年架构独显将面世对独显格局有一定冲击显卡与显卡相比有更高的功耗与更高的性能显卡的子品牌有和显卡型号众多今天显卡技术坚挺依然耀眼软件与硬件接口与硬件专业图形图像领域缓存和双缓存称为了图形技术的标配在今天的流行图形图像里当年的缓冲和双缓冲仅仅是今天图形图像引擎的一个参数或者一个函数而已参数和函数的背后是硬件的支持显卡插口有和两种在数据处理上逐渐支持高速和并行具有着更大的传输速率更复杂数据的处理能力硬件技术的变革推动了软件技术的进步任何技术的发展都不是一帆风顺的显示技术也不例外每一次技术的革新都可能带来革命性的变化那些曾经被淘汰被边缘化的技术为主流技术的发展做了助攻在显卡技术发展过程中硬件的升级架构的改变都代表着功能的提升下图从另外一个角度展现显卡发展的过程引擎遥想当年视频编程主要靠专业引擎来体现各家公司雄心勃勃开宗立派在数家公司的专业图形图像接口里和最终胜出今天消费级市场主要通过和来体现可悲的是早期在上很少有图形图像编程的处理一直到今天图形图像工作主要还是在和上进行时光的河流流淌着一个真理对的支持以及对相关图形系统的支持是硬件厂商存活的根本这里的支持就是引擎当年的图形图像编程刚刚起步很多公司提供的应用引擎都是对和的封装是渲染数字图形的跨语言跨平台的应用程序编程接口由近个函数组成绘制简单图形和复杂三维景象常用于虚拟现实科学可视化和游戏开发等直接操纵图形硬件高效进行图形图像编程实现一般由显示设备厂商提供是对显卡编程的工业接口规范由年成立的架构评审委员会维护由业界顶级软硬件公司组成下图是的发展过程定义了若干被客户端程序调用的函数以及一些整型常量这些实现方便了开发者调用与语言平台无关规范没有获得和管理上下文相关的内容将这些细节交给底层窗口系统专注图像渲染不提供输入音频及窗口相关的不断进化新版规范定期由发布新版本通过扩展来支持各种新功能每个版本细节由成员一致决定包括显卡厂商操作系统设计人员以及类似和谷歌的技术性公司除了核心功能供应商通过扩展的形式提供额外功能扩展引入新功能和新常量增加或取消现有功能每个扩展与一个标识符联系标识符基于开发公司的名称例如英伟达的标识符是如果多个供应商同意使用相同的来实现相同功能那么就用标志符这种情况更进一步的架构评审委员正式批准该扩展那么就被称为一个标准扩展标识符使用第一个扩展是每个新版本中引入的功能特别是和类型的扩展通常由数个被广泛实现的扩展功能组合而成代码示例微软在业界的大哥地位影响力不言而喻在发展史上多次和对博公堂微软宣布凡是的电脑不能安装操作系统软件厂商要挟硬件厂商在微软发展历史上留下了光辉的一页音视频是电脑最核心的功能之一作为系统供应商微软推出了自己的产品该产品在年前后十几年间决定了很多硬件厂商的生死示例代码当我们平心静气面对这些技术和代码时深刻的感受到尤其在早期当年的技术对显卡厂家的影响是可怕的对技术的支持程度代表了显卡的受欢迎程度当年的技术应用最主要是游戏领域从的发展得到岁月的启示垄断阻碍了技术的发展相信在某一天也终究会退出技术的舞台编程在编程里面占据着重要的地位是等引擎中最核心的概念成了图形图像编程的核心标配示例代码是苹果公司的图形编程库近两年取得了巨大的发展在平台和平台音视频开发上是一个很好的选择提供对的直接访问技术人员最大程度地发挥和中的图形硬件计算潜能构建于易用的低开销架构之上提供预编译的着色器和精细的资源控制支持多线程支持驱动命令创建支持阵列编程充分利用和的专业级多媒体功能渲染示例代码画的内容这个代理方法会按帧率执行获取颜色设置背景色创建一个命令缓冲区渲染过程用于保存渲染过程的结果结束编码注册一个可绘制图像提交命令到视口发生变化会被调用是一个跨平台的和绘图应用程序接口科纳斯组织在年游戏开发者大会上发布目前是世界多媒体音视频图形图像领域的核心协会拥有世界顶级会员单元拥有世界级的技术标准科纳斯把称为下一代行动或就像针对实时程序如电子游戏设计并计划提供高性能和低管理负担这也是和的的目标兼容的一个分支并使用了的一些组件是的后续版本继承了强大的低开销架构使软件开发能够全面获取与多核的性能效率和功能支持深入硬件底层的控制为各种系统带来更快的性能和更高的影像质量还提供超高的兼容性渲染特性和硬件效率基于架构的显卡拥有强大的异步计算功能使显卡并行处理几何图形与计算工作量当游戏需要同时计算复杂照明与渲染人物时这种功能就找到了用武之地这些任务并不需要在显卡上串行运行节约时间提升整体帧速率在近期和系统上都有很好的应用目前得到广泛的的支持在硬件上无论是服务器桌面移动端都进行了完好的支持在系统层面上都为提供了完备的接口示例代码启示计算机图形学的发展不是一蹴而就的前期发展过程中百花齐放百家争鸣各家接口不一处于蓬勃不稳定发展期系统厂商硬件厂商软件厂商行业协会一起共同推出软硬件规范就是一个成功的表现技术发展过程中一些厂商没有明确的规范或没有明确的支持规范进而失败了没有硬件厂商支持的规范同样是可悲的很快被淘汰了软件运行在硬件之上硬件在一定程度上决定着软件软件反过来影响着硬件时代绚丽多彩现实生活姹紫嫣红多年技术积淀在时代五彩斑斓应用辈出显示技术的应用发挥到了极致对计算技术的发展做出了卓越的贡献时代的到来为显示技术的精细化发展吹响了号角在计算机图形图像技术发展史上承前启后继往开来移动时代移动时代可以追踪到很远从古老的电台到年贝尔实验室的到年摩托罗拉的机寻呼机的发展历史主要是通讯技术的进步和主题有一定偏差不做阐述翻开半个多世纪的画卷历史没有想到的是通讯技术在今天有如此傲娇的成绩早期电脑至上后来移动至上不可怀疑的是移动互联网高速发展的今天手机成为应用系统最重要的终端移动端图形系统的研究是移动应用终端开发的重中之重也是手机底层技术的核心要素本篇从手机发展史起笔到移动显示芯片厂家移动芯片技术与流行图形库讲述希望给移动端音视频开发带来有益的启示手机时代那年的能否勾起你绵绵的情思这颗圆圆的行星之声奏响了银河系无线通讯的号角那个年代手提电话也叫移动电话还不叫手机绰号大哥大也叫板砖当年的大哥大仅仅局限通话短信功能也不具备有了大哥大不学数理化大哥大成为了身份的象征硬件技术的进步手机向小型化发展两个企业的高光时刻带来了当年的摩托罗拉和诺基亚堪称业界大哥赚钱赚到罗马从早期的单色屏逐渐发展到彩色屏从年到年那是诺基亚和摩托罗拉的时代昨日年少英雄指点江山今天英雄白发美人谢幕互联网给我们多少唏嘘工艺的提升不仅推动硬件设计的进步更推动软件系统的发展手机应该拥有更强大的功能在这一大环境下手机操作系统不断涌现为智能手机系统发展发起了前期的火力侦察乔布斯担负着上帝赋予的伟大使命年诞生了伴随着的诞生的出现智能时代到来了完成了伟大使命的乔帮主这位天选之子年之后撒手人寰魂归天堂而他留下了这颗行星上市值最高的公司智能手机的兴起促进移动端硬件提升显示技术也有很大变化移动时代硬件发展同样精彩充满了竞争与杀戮野蛮和邪恶和端同样精彩软件方面相对平滑平淡没有大的开开合合手机的发展史也是一部无线技术的发展史硬件技术与通讯规范密切相关翻开移动通讯的日记从到感时光如梭叹技术神速通讯技术规范不属于本主题内容不做阐述移动时代芯片科技看到了中国企业的影子东方用资本开始了买买买的过程对芯片技术的渴求资本是最直接的倾诉期望不远的未来有一家拥有核心技术的东方芯片厂商在技术的长河中书写浓重的一笔在芯片的交响乐中奏出中国的声音波澜壮阔的手机应用后台是芯片技术的驱动下一节我们从芯片的角度回顾移动端主流显示芯片不仅进行嵌入式架构授权也进行架构授权在芯片架构设计上稳坐头把交椅年完成对挪威公司的收购获得其移动技术完成对原有技术的扩展也就是从那个年代开始闪亮登场是有先见之明的年后广泛用于智能手机和平板电脑等多种设备年时间技术成为全球出货量第一的预计年总计出货量就超过亿在移动图形硬件发展史上是必谈的技术架构发展了代和的代表是三星的用的就是这款至今的一些电视芯片还在使用例如小米电视的型号是系列联发科就用的是而的型号是系列的可以说是的黄金搭档架构上不是最先进普及率非常高低廉的授权费是芯片厂商比较喜欢的科技与方案的授权保证了技术纯粹降低了经营风险是一款高端将图形视觉娱乐变为现实市场占安卓智能手机以上可与系列对比应用基于体系结构的移动设备上得益于占有率发展迅猛系列为所有嵌入式图形和视频提供完善的解决方案使设备制造商和内容开发商能够为最广泛的消费类设备手机游戏机智能本提供最高质量的尖端多媒体解决方案是近些年硬件最重要的应用之一当年收购简直是神来之笔为的做大做强埋下了伏笔嵌入式图形设计用于提高能源效率和解决性能问题包括世界上最小的完整多核可扩展性最高可达用于可视计算的的通用计算以及多用途应用程序所有都受预先集成的图形驱动程序软件支持灵活性是要考虑的一个重要因素支持的业界标准开放式包括以及这些是成功的基础在芯片架构设计上有多见的经验积累高通在通讯领域里有最好的技术产品高通的英文是翻译就是高质量通信创始人雅各布斯是搞通信工程搞到卫星领域的男人高通今天连接万物的使命从创立那天就奠定了这是一家超强的公司其技术延续性与强大性首屈一指在这个年代的人都用过高通的产品或者技术年成立的公司在开始推广业界的注意力都在技术上后来演变成高通靠着自己的实验和测试让在年成为行业标准并和分庭抗礼这就是高通的水平高通研发投入占比常年在收入的以上前年高通累计投入了超过亿美元的研发经费获得了超过万项全球专利年那一年发生了两件改变世界的事情乔布斯发布高通推出了骁龙芯片年间高通在移动领域打赢过两次重大战役第一次让德州仪器英伟达这些业界大厂退出了移动高端市场第二次则是让联发科败走中高端中途还插播过英特尔靠着补贴打了几年酱油的历史这些恐怖成绩的存在是高通对硬件技术的不懈追求时间线调回年从那时开始高通每年的都会带着新的制程新的和调制解调器亮相高通在调制解调器上的优势犹如不可逾越的鸿沟把其它大厂排挤在千里之外高通把调制解调器分为两种一种骁龙一种其它年安卓和的蛮荒时代高通这些上古的连都已经支持了比国内称为元年的年还早了整整年作为移动技术的顶级元老这个不让人意外移动特别是系列在近几年一直维持着远超摩尔定律的性能增速这个故事出现得最密集的词就是暴涨二字在众多公司中高通像一个工程师一样坚守硬件设计的阵地年隶属骁龙搭载的其浮点性能是而年初的上浮点性能已经暴涨了数倍达到手机和电脑有一定的区别手机是整合到内的电脑可以有独立显卡高通的的技术部分源自高通从收购的移动部门高通的市场占有率很高的表现也足够优秀支持足够多的新特性性能比较强功耗表现也很理想如果说年之前其他厂商的还算和高通追得很紧的话那在骁龙的开始高通就进入了无人之境或是从绝对性能或是从能耗比上拉开了和苹果三星海思联发科的差距现在唯一能在性能上跟着高通的就只剩苹果了但同代产品上高通总是能在能耗比上压苹果一头让人疯狂的是除了能耗比其它公司占优之外高通的几乎常年都是用着同代面积最小的芯片面积三星上的面积达到了上也有但高通硬生生只用了出头的芯片面积做到了更强的性能更低的能耗高通在嵌入式技术上的能力是有目共睹的嵌入式硬件对移动端提供了核心的支持在图形图像视频硬件技术上高通道高一丈在互联网众多科技公司中高通算是厚积薄发在企业发展上稳健踏实在芯片领域具有举足轻重的地位在互联网人工智能高速发展的今天高通的硬实力展现出来苹果感谢高通高通的存在阻击了一线科技公司对苹果的围剿在技术大潮中高通不断为苹果输送技术的血液成就了苹果的万亿帝国年到年和在移动市场竞争中完全失策丢掉全球移动主要供应商的同时苹果一步步取代他们并成为最强大最主流的处理器的生产者和重蹈的覆辙丢掉移动市场当年未能预料的潜力忽视了移动市场让从一家基础移动处理器生产商一跃成为智能手机和平板处理器的主要生产商而移动的发展也十分相似历史不断的给苹果机会并给与其把握机会的能力符合用户知觉视觉美观图形环境归功于加速这是销量居高不下的因素完全没有意识到成功的关键对的重视让适合游戏从一开始游戏是苹果应用商店里的主角改变了大众对苹果没有游戏的印象还有年的均作为独立的移动游戏设备颠覆了游戏市场苹果推出了新的很多优秀的开发者都利用了这套新的开发新应用可以让游戏和其他需要图形性能的应用绕过利用苹果位处理器的强大苹果在图形处理速度上有很大优势在移动游戏方面尤其明显而则让优势进一步增加苹果把的人挖了之后自研了然后把这帮人解散了这件事情告诉我们苹果是靠不住的不知道哪天又会卸磨杀驴近些年苹果走向自研道路未来谁掌握了最强的手机图形性能谁就可以在市场上获得更大主动权苹果深谙此道在进行技术拓展的同时进一步巩固系列芯片的性能优势尽管采用的是和骁龙一样的工艺整体性能仍然强于骁龙相比提升了三核心设计并对沉浸式游戏和增强现实进行了优化这是苹果第一代自研苹果真正能把自己的完善起来还需要年时间那时系列和融合的会更加紧密在性能和能耗上会有更大的突破发展的关键时刻上帝偏爱苹果面临技术抉择时苹果往往押宝成功看似孤傲独行重大战役到来时总有友军出现这些因素的综合使苹果稳坐科技公司第一宝座前身是公司曾经的全球移动龙头深耕内核研发和设计曾是苹果御用图形技术提供商总部位于英国年被中资背景企业收购未来发展不明的核心产品是系列产品被设计为可应用于各种场景的支持自动驾驶数字电视机顶盒移动设备等智能应用系列在多个市场中授权客户这点和相像首批搭载该的器件在年供货宣布紫光已获得最新一代神经网络加速器半导体授权许可是面向中高端移动设备市场的系统级芯片散热条件限制大多数移动很难提供持续一致的游戏体验芯片发热其性能下降到不可接受的水平系列则以一致的帧速提供持续可靠的性能以及更长游戏时间避免了因芯片过热导致时钟降频甚至故障等过热情况系列有一定的技术优势系列采用的技术独立的硬件控制通道被隔离在内存中将不同的任务同时提交给实现多任务处理通过在可以提供图形处理功能的同时使用备用资源支持可编程以及固定功能即高度优化的神经网络加速器在最小的芯片面积中提供可编程的人工智能统一的软件栈可实现灵活出色的性能曾经是苹果御用的性能表现强大架构先进不仅在领域在安卓领域使用也很广泛当年的一代神联发科就使用了大幅度超频的性能是低端机里的翘楚但是因为较高的授权费用逐渐失去了安卓市场客户纷纷转向更廉价的虽然有联发科等的支持仍然是强弩之末再加上苹果的抛弃苹果宣布自研和挖墙脚等待的只有卖身的悲惨命运技术的选择是很多芯片公司做强做大的基础尤其是智能时代的带来的应用汹涌澎湃风卷云涌图芯曾经是嵌入式图形处理器的技术先行者总部位于加州为全球移动设备和家庭娱乐市场提供顶级应用超级处理器解决方案曾经拥有种类繁多的图形处理器用硅印模为业界标准应用程序接口提供强大支持图芯芯片技术将桌面质量图象和性能带入汽车手掌中的屏幕优秀可升级的嵌入式解决方案是可升级的建立在业界标准之上且优化功耗性能和大小图芯不断增长的产品系列与全球多家公司成功合作对移动视觉逼真和高清视觉逼真的核心技术成为当年顶级移动端图形图像技术供应商年月日图芯被中国芯原收购产品开始沉默对的成功支持是图芯前期成功的核心要素移动端图形技术的快速发展加速了移动时代的到来当年端显示技术的大佬们变得孤单与寂寞这能告诉我们什么呢手机不能单卖需要可用的基带并没有基带在不需要基带的移动上做的很好例如英伟达开发过手机芯片系列现在已经谢幕当年使用芯片手机风行一时英伟达在及之前的架构叫号称核但架构十分老旧是时代的分离渲染架构因为基带芯片问题退出手机市场后来推出了用上先进的架构但是一切都太晚了现在和可预见的将来都没有手机产品这是不能接受的期望有一天在移动端显示芯片上上演王者归来不仅缺少移动还几乎没有市场份额在补贴硬件厂商让它们使用产品造成了每年亿美元的损失世界上影响力最大的两个厂家和两个微处理器的发明者和德州仪器几乎全都被苹果逐出了移动市场现在市场中只有低端零件厂商苹果高端高销量的设备竞争这令人感叹苹果跳出了时代的局限性在桌面端和移动端成为最成功的企业上帝太偏爱苹果了当年买了之后折腾没有下文年宣告放弃现在想用只能外挂基带黄药师仰天长啸移动端报国无门外挂是可以的上接用然后有自己显存这个不是手机能接受的如果用访问内存没有问题但有其它局限性后黄总就不用互联了和英伟达道路相似时代雄起移动时代沉寂智能时代奋起每一家公司都有各自的领地那些成功的跨界成就了技术的艳遇就工艺而言相对于技术难度低一些这也是众多小厂开始向迈进的原因在移动时代科技的发展创造机会很多传统的大厂由于固守轨道错过了发展的黄金时代移动图形库移动手机图形接口上没有桌面端的万马奔腾百舸争流整体相对平稳与自然无论还是都是的内核所以在移动图形库的选型与发展上和桌面端图形库有一个很好的承接桌面端不可撼动的地位移动端的简化版应运而生是三维图形的子集针对手机和游戏主机等嵌入式设备而设计是裁剪定制而来去除了复杂图元等非绝对必要的特性参照规范定义免授权并且跨平台强大的和图形应用程序接口针对多种嵌入式系统专门设计包括控制台移动电话手持设备家电设备和汽车由精心定义的桌面子集组成实现了软件与图形加速间灵活强大的底层交互接口版本与功能包含浮点运算和顶点运算及便携设备的本地视窗系统规范面向功能固定的硬件所设计并提供加速支持图形质量及性能标准也就是固定管线编程提供包括遮盖器技术在内的全可编程图形算法则在可编程管线上进行了增强提高了不同消费电子设备的图形渲染速度在嵌入式系统上实现了全面可编程的图形工作组在六个月内更新采纳者项目提供兼容性测试并提供相关源代码目前高通等都表达了对的大力支持最新就支持新功能渲染管线多重增强实现先进视觉效果的加速包括遮挡查询变缓反馈实例渲染更多渲染目标支持高质量纹理压缩格式成为一项标准功能不同平台上不再需要不同的纹理集新版着色语言全面支持整数和位浮点操作纹理功能增强支持浮点纹理纹理深度纹理顶点纹理纹理单双通道纹理不可变纹理阵列纹理无二次幂限制纹理阴影对比调配与无缝立方体贴图采样对象纹理抗锯齿渲染器更多精确尺寸纹理和渲染缓冲格式便携移动应用更简单示例代码其它和不仅是时代的图形框架也是移动领域的核心图形图像框架关于和的知识参考前面主题启示梳理这段历史时我们发现信息科技的核心是芯片芯片技术被国外巨头垄断偶尔有中资公司的影子大多昙花一现芯片技术是百年大计很难实现弯道超车在计算科技白皮书里大多是欧美科技的影子东方公司比重较低这注定了科技赶超是一个长期的过程在软件规范制定上面临同样的情况未来几十年在软件规范上我们埋头苦干奋勇向前通讯核心技术上依然有很大不足但在市场应用上我们拔得头筹在移动商务移动支付短视频应用上捷报频传美摄科技坚持音视频核心技术研究底层硬件技术研发在技术接口产业应用上乘风破浪激流勇进在祖国图形图像技术建设上做出应有的贡献缘聚缘散时空变换年之后科技的春天再次到来了从基础芯片软件规范到行业应用我们流年笑掷坚信未来可期人工智能时代人工智能发展历史人工智能是科技永久的话题计算机本身是一个工具人工智能发展史上计算机的出现是人工智能发展的伟大节点世纪仅仅是人工智能的开端人工智能的发展方兴未艾早期的人工智能偏重于理论西方的神学大师哲学先驱数学巨匠一起为人工智能奠定了文化基础下面我们开始与大师的对话大事记年前巴贝奇一个英国数学家设计了第一台计算二次多项式的计算机器叫做差分机摇动手柄计算出式子的值当时的东方大清皇朝即将面临血色的辉煌年几个科学家聚会在美国汉诺思小镇宁静的达特茅斯学院利用暑假的两个月进行封闭式的讨论研究主题是达特茅斯夏季人工智能研究计划首次提出人工智能简称这一概念人工智能学科应运而生了当年简单的两个单词成为今天科技的主旋律年塞缪尔讲到计算机可以比人更好地编程进行国际象棋游戏时创造了机器学习一词上承接人工智能下承接自然语言与机器视觉编程邂逅人工智能人工智能青梅竹马的年代开始了年开发一个交互式计算机程序用英语与人交谈有一个目标证明人工智能思维与人类思维之间的沟通是肤浅的这是第一个通过图灵测试的软件程序对话就是模式匹配代表着自然语言技术的开端年后的今天自然语言技术应用广泛年卡耐基梅隆大学开发自动选配计算机配件的程序年投入工厂使用包含条规则后续几年处理了超过条订单准确度超过每年节省超过万美元这是早期的专家系统开始于生产应用我们今天进行自动购物时很少有人知道半个世纪以前在大洋彼岸已被广泛应用年斯坦福大学制造了无人驾驶车这是汽车的第一次依靠视觉感应器在没有人工干预的情况下自主穿过散乱扔着椅子的房间需要几个小时才能完成当年的视觉感应器就是今天的机器视觉当年的无人工干预就是今天的自动驾驶年英国科学家霍普菲尔德几乎同时与杰弗里辛顿发现了具有学习能力的神经网络算法沉寂年之后神经网络有了新的进展从此神经网络高速发展年代开始商业化用于文字图像识别和语音识别今天的神经网络工程师们鲜有人知道这两位大师的名字年梅赛德斯奔驰的指导下建造并发布了一辆配备摄像头和传感器的无人驾驶厢式货车能够在没有人类驾驶员的道路上行驶高达英里小时当年的神奇幻想今天的美好现实成为了自动驾驶的鼻祖当年的奔驰货车也称了自动驾驶的先驱年和发明了第一款玩具机器人年前后日本科技公司凭借着较好的工业基础在早期智能时代占据着不可或缺的位置年索尼推出价值美元的机器人宠物狗与环境所有者和其它的互动来学习功能包括能解和响应多个语音命令并与人类所有者进行对话年自动机器人真空吸尘器避开障碍物进行清洁年杰弗里辛顿出版奠定神经网络的全新架构今天人工智能的核心技术短短年间数学冰山背后春风化雨夏露凝香年出生于北京美国国家工程院院士独立董事组建一个注释图像数据库帮助物体识别年吴恩达使用图形处理器而不是进行大规模无监督式机器学习取得了惊人的成就向世人展示了一个超强的神经网络它在自主观看千万张图片之后识别小猫的图像这是历史上在没有人工干预下自主强化学习的里程碑式事件向世人展示了无监督学习的价值自此识别温柔了岁月惊艳了时光年电视游戏中回答创建的计算机自然语言问题击败了两个前冠军肯詹宁斯和布拉德鲁特自然语言处理逐步开始步入人类生活谷歌的计算机程序击败了各种人类冠军当时名噪一时为人工智能做了最好的技术营销年谷歌发力自动驾驶今天是自动驾驶排行第一名当年满头青丝的今天已是白发苍苍下图右为年沈向洋微软亚洲研究院视觉计算组开发的基于深度卷积神经网络的计算机视觉系统在这项视觉识别挑战中第一个超越人类视觉能力的计算机系统年沈向洋离开微软成为清华大学双聘教授这位来自南京人工智能国际巨人把中国的人工智能技术推向一个新的高度微软组建微软人工智能与研究事业部人工智能是微软的梦想年盖茨先生就做过人工智能的预言人工智能在模拟仿真游戏方面也有着广泛的应用国内年以前仿真领域是人工智能最核心的领域以后逐渐向其它领域过渡启示年前后人工智能迎来了高速发展期年人工智能元年大数据数据挖掘机器学习等理论百花齐放人工智能的时代终于到来了凝视这段历史时早期的人工智能偏重于模拟仿真没有实时性摄像与视频技术的进步人工智能向实时性发展实时性有着重要意义开启了人工智能社会应用新篇章人工智能代表着大数据量的到来没有大的数据量无法进行有效的分析数据处理是人工智能的核心要素数据处理今天由并行计算来完成大的数据量不仅对算法有要求对算力也是一个考验人工智能需要巨大的算力没有算力谈不上人工智能目前在人工智能初级阶段科技公司算力主要靠大的科技公司靠超算中心等来解决大数据的超强能力为人工智能的算力提供强有力的支持人工智能目前阶段两个主要表现第一个是自然语言处理第二个是机器视觉自然文字符号和音视频是人类信息两个重要的载体机器视觉很多年前国外有一些公司在做仅限于一些专业领域年代进入国内后中科院物理所引进国外专业相机结合国内应用开发出相关检测系统新的硬件与显示标准对智能视觉处理有着很大推动随着并行计算的发展可以坚信的是视觉智能是未来人工智能发展的重要方向硬件发展人工智能时代需要硬件的支持不仅仅是外设更是数据计算在此需求下不仅外设的繁荣更是芯片技术的爆发芯片技术为智能处理提供了基础在数据阶段处理为提供物理计算基础在此基础上有了并行计算架构无论云平台大数据机器学习区块链无一不是建立在并行计算的基础上年代中国挥剑斩芯片丧失发展先机今天倾国之力十万亿级投资发展芯片留给我们多少启示下面通过芯片相机传感器硬件角度讲述其它层面参考相关资料智能时代的机器视觉视频来自于相机考虑了相机因素芯片人工智能首先是硬件技术的进步硬件技术的核心是芯片芯片技术是集成电路的高度封装芯片技术是半导体技术的体现整个生产过程与产业链较长需要多家公司合作才能完成顶级科技公司钟情于芯片研发包括芯片研发微软特斯拉英伟达谷歌华为等人工智能时代的到来芯片的多样性与功能性都有很大变化技术的风起云涌为芯片制造提供了契机人工智能时代芯片快速发展为人工智能提供澎湃动力支持芯片技术是人工智能后续阶段的关键技术没有芯片技术的进步人工智能将会举步不前相机芯片相机记录着社会文明相机留存着社会点滴相机助力着生产生活相机是机器视觉第一步的表达整个视频处理流程相机是前端机器视觉部分处理在前端实现学习机器视觉有必要对相机简单了解对于工业视频而言相机是重中之重相机技术有很多分类本部分通过传统相机和工业相机进行讲述传统相机相机技术发展多年主要是图像传感器的发展目前分为和两种芯片是将光信号转换成电信号的芯片在数码相机摄像机中光信号转换成电信号然后处理编程数码照片文件芯片使用高感光度的半导体材料制成把光线转变成电荷通过模数转换器芯片转换成数字信号数字信号经过压缩后由相机内部的存储设备保存然后把数据传输给计算机借助于计算机的处理手段根据需要和想像来修改图像芯片由感光单位组成通常以百万像素为单位表面受到光线照射时每个感光单位会将电荷反映在组件上所有的感光单位所产生的信号加在一起构成了一幅完整的画面图像传感器是按一定规律排列的金属氧化物半导体电容器组成的阵列在型或型硅衬底上生长一层很薄约的二氧化硅再在二氧化硅薄层上依次序沉积金属或掺杂多晶硅电极栅极形成规则的电容器阵列再加上两端的输入及输出二极管就构成了芯片相机采用图像传感器的设备一般应用在普通数码设备中一般应用高档数码设备中比单位成像的效果要好镜头比分辨率要高和在制造上的主要区别是是集成在半导体单晶材料上而是集成在被称做金属氧化物的半导体材料上只有少数几个厂商索尼松下等掌握这种技术制造工艺较复杂采用的摄像头价格昂贵相同像素下的成像通透性明锐度都很好色彩还原曝光可以保证基本准确由于低廉的价格以及高度的整合性因此在摄像头领域还是得到了广泛的应用的信号是以点为单位的电荷信号而是以行为单位的电流信号前者更为敏感速度也更快更为省电高级的并不比一般差工艺还不是十分成熟普通的一般分辨率低而成像较差或基本上都是利用矽感光二极体进行光与电的转换光线越强电力越强反之光线越弱电力也越弱的道理将光影像转换为电子数字信号每曝光一次在快门关闭后进行像素转移处理将每一行中每一个像素的电荷信号依序传入缓冲器中由底端的线路引导输出至旁的放大器进行放大再串联输出相对地的设计中每个像素旁就直接连着放大兼类比数字信号转换器信号直接放大并转换成数字信号的充分保持信号传输时不失真透过每一个像素集合至单一放大器上再做统一处理保持资料的完整性制程简单没有专属通道必须先放大再整合各个像素资料由于每个像素包含了放大器与转换电路过多的额外设备压缩单一像素的感光区域的表面积因此相同像素下同样大小之感光器尺寸的感光度会低于应用半导体工业常用的制程一次整合全部周边设施于单晶片中节省加工晶片所需负担的成本和良率的损失采用电荷传递的方式输出资讯必须另辟传输通道如果通道中有一个像素故障就会导致一整排的讯号壅塞无法传递每个感光二极体旁都搭配一个放大器如果以百万像素计需要百万个以上的放大器虽然是统一制造下的产品每个放大器或多或少都有些微的差异存在很难达到同步放大的效果对比单一个放大器的最终计算出的噪点就比较多市场销售的数码摄像头中以感光器件的为主在采用为感光元器件的产品中采用影像光源自动增益补强技术自动亮度白平衡控制技术色饱和度对比度边缘增强以及伽马矫正等先进的影像控制技术完全可以达到与摄像头相媲美的效果尽管在影像品质等方面均优于不可否认的具有低成本低耗电以及高整合度的特性的低成本和稳定供货所以广泛使用制造技术不断地改良更新使得与两者的差异逐渐缩小工业相机工业相机是机器视觉系统中的关键组件本质功能就是将光信号转变成有序的电信号选择合适的相机也是机器视觉系统设计中的重要环节相机的选择不仅直接决定所采集到的图像分辨率图像质量等同时与整个视觉系统的运行模式直接相关工业相机俗称摄像机相比于传统的民用相机摄像机而言它具有高的图像稳定性高传输能力和高抗干扰能力等市面上工业相机大多是基于或芯片的相机是目前机器视觉常用的图像传感器它集光电转换及电荷存贮电荷转移信号读取于一体是典型的固体成像器件突出特点是以电荷作为信号不同于其它器件是以电流或者电压为信号通过光电转换形成电荷包而后在驱动脉冲的作用下转移放大输出图像信号典型的相机由光学镜头时序及同步信号发生器垂直驱动器模拟数字信号处理电路组成作为一种功能器件与真空管相比具有无灼伤无滞后低电压工作低功耗等优点图像传感器的开发最早出现在世纪年代初年代初期超大规模集成电路制造工艺技术的发展图像传感器得到迅速发展图像传感器将光敏元阵列图像信号放大器信号读取电路模数转换电路图像信号处理器及控制器集成在一块芯片上还具有局部像素的编程随机访问的优点图像传感器以其良好的集成性低功耗高速传输和宽动态范围等特点得到了广泛的应用工业视觉离不开相机的支持在一些高端领域必须用工业相机来处理工业相机是民用相机的增强版本质依然采用或者技术相对民用相机用更高的软硬件配置更大的功耗获得更好的质量总结人工智能图像处理工业上对高清晰照片进行处理其它领域是消费级的处理技术的进步高清晰相机在消费级市场应用高清照片的消费级技术处理将会显现工业视频的处理靠高端硬件实现消费级高清视频的处理还需要新的技术框架支持在未来几年将有新的机会出现机器视觉机器视觉是人工智能快速发展的一个分支也是智能视觉重要的一部分机器视觉就是用机器代替人眼来做测量和判断机器视觉系统通过机器视觉产品即图像摄取装置分和两种将被摄取目标转换成图像信号传送给专用的图像处理系统得到被摄目标的形态信息根据像素分布和亮度颜色等信息转变成数字化信号图像系统对这些信号进行各种运算来抽取目标的特征进而根据判别的结果控制现场的设备动作机器视觉是一项综合技术包括图像处理机械工程技术控制电光源照明光学成像传感器模拟与数字视频技术计算机软硬件技术图像增强和分析算法图像卡卡等很多年前机器视觉就在广泛应用目前在深度和广度方面拓展未来年机器视觉对人类生活将会有革命性的变化机器视觉是一门技术机器视觉系统是技术的应用下一主题我们讲述机器视觉系统机器视觉系统一个典型的机器视觉应用系统包括图像捕捉光源系统图像数字化模块数字图像处理模块智能判断决策模块和机械控制执行模块机器视觉系统基本的特点就是提高生产的灵活性和自动化程度在不适于人工作业的危险工作环境或者人工视觉难以满足要求的场合用机器视觉来替代人工视觉在大批量重复性工业生产中用机器视觉检测方法提高生产的效率和自动化程度机器视觉系统提高生产的柔性和自动化程度在一些不适合人工作业的危险工作环境或人工视觉难以满足要求的场合常用机器视觉来替代人工视觉同时在大批量工业生产过程中用人工视觉检查产品质量效率低且精度不高用机器视觉检测方法大大提高生产效率和自动化程度机器视觉易于实现信息集成是实现计算机集成制造的基础技术之一工业机器视觉系统包括光源镜头定焦镜头变倍镜头远心镜头显微镜头相机包括相机和相机图像处理单元或图像捕获卡图像处理软件监视器通讯输入输出单元等机器视觉检测系统采用照相机将被检测的目标转换成图像信号传送给专用的图像处理系统依据像素分布和亮度颜色等信息转变成数字化信号图像处理系统对这些信号进行各种运算来抽取目标的特征如面积数量位置长度再根据预设的允许度和其它条件输出结果包括尺寸角度个数合格不合格有无等实现自动识别功能目前机器视觉系统主要应用在工业生产领域互联网应用正在兴起在居家生活应用上方兴未艾计算机视觉计算机视觉是研究如何使机器看的科学用摄影机和电脑代替人眼对目标进行识别跟踪和测量等并进一步做图形处理使电脑处理更适合人眼观察或传送给仪器检测的图像计算机视觉可以看作如何使人工系统从图像或多维数据中感知的科学计算机视觉是一门关于如何运用照相机和计算机来获取我们所需的被拍摄对象的数据与信息的学问形象地说就是给计算机安装上眼睛照相机和大脑算法让计算机能够感知环境计算机视觉既是工程领域也是科学领域中重要研究领域计算机视觉是一门综合性的学科吸引了众多研究者参加到对它的研究之中包括计算机科学和工程信号处理物理学应用数学和统计学神经生理学和认知科学等计算机视觉开始于年代初年代取得很多重大进展计算机视觉与人类视觉密切相关对人类视觉有正确的认识对计算机视觉的研究非常有益计算机视觉用各种成像系统代替视觉器官作为输入敏感手段由计算机来代替大脑完成处理和解释计算机视觉的研究目标就是使计算机象人那样通过视觉观察和理解世界具有自主适应环境的能力计算机视觉根据计算机系统的特点进行视觉信息处理迄今为止人类视觉系统是功能最强大和完善的视觉系统对人类视觉处理机制的研究将给计算机视觉的研究提供启发和指导计算机信息处理的方法是研究人类视觉的机理建立人类视觉计算理论称为计算视觉计算视觉是计算机视觉中的一个研究领域计算机视觉和机器视觉的定义有很多认知的区别很多文献中有不同的论述笔者认为两者都是人工智能的分支侧重点不一样在今天学术领域都没有严格的定义智能时代软件发展天下事物发展一分为二软硬件技术也不例外第二次工业革命电磁理论石破天惊在后期推动了计算机技术的进步为第四次科技革命的发展做好了硬件的铺垫在硬件大力发展背后智能时代软件的号角吹响了人类在智能科技方面的探索没有终点也很难找到起点人工智能探索过程中软件方面有着天翻地覆的变化下面从编程语言运算平台机器学习库等方面分别进行阐述人工智能编程语言人工智能编程语言是一类适应于人工智能和知识工程领域的具有符号处理和逻辑推理能力的计算机程序设计语言能够用它来编写程序求解非数值计算知识处理推理规划决策等具有智能的各种复杂问题事实上已经有多种对应于各种不同知识表示方式的人工智能编程语言按所对应的知识表示方式不同可以区分为以下几类对应于产生式规则知识表示的语言例如由美国卡耐基梅农大学的福基等人年开发的当时用它来为公司开发了一个解决计算机系统配置问题的专家系统对应于逻辑公式知识表示的语言一种已广为应用的逻辑语言就是年由法国马塞大学的柯迈豪埃所开发的对应于框架或语义网知识表示的语言这是面向对象的语言其中一个有代表性的语种就是年首创后来版本不断更新对应于函数知识表示或函数式程序设计风格的语言的列表处理语言函数式编程语言理论上很完美建立在坚实的数学基础之上对于人工智能问题在常规计算机上很难实现世纪年代末麻省理工学院的约翰麦卡锡等人首先开发的列表处理语言迄今仍然广泛用于编写人工智能应用程序特别是用于开发专家系统人工智能编程语言有共同特点语言都面向要解决的问题结合知识表示完全脱离当代计算机的诺依曼结构特性而独立设计的处于比面向过程的高级编程语言更高的抽象层次用这些语言编写的程序在现代计算机环境中无论是解释或编译执行往往效率很低尤其程序规模很大复杂时浪费大量系统资源系统性能往往会下降到难以容忍的地步世纪年代后期麻省理工学院的就开始了人工智能的研究当时致力于设计一个用表处理的递归系统在世纪年代初研制出了语言语言是一个用于处理符号表达式的相当简单的函数式程序设计语言以数学中的函数与函数作用的概念作为设计原理奠定了函数式语言的基础语言是完全非风格的它没有使用等语言中所采用的可修改变量赋值语句转向语句等结构语言中的有关概念程序与其数据结构采用了相同的结构形式与处理方式方便地编写解释程序语言除了用一表达式来统一处理数据与程序外还引入了前缀运算符表示法递归数据结构递归控制结构以及新的条件表达式形式是一种逻辑编程语言建立在逻辑学的理论基础之上最初被运用于自然语言等研究领域现已广泛应用在人工智能的研究中可以用来建造专家系统自然语言理解智能知识库等对一些应用程序的编写很有帮助能够比其它语言更快速开发程序的编程方法更像是使用逻辑语言来描述程序具有鲜明的逻辑编程语言特色包括没有特定的运行顺序运行顺序是由计算机决定的而不是程序员程序中没有这样的控制流程语句程序和数据高度统一其程序实际上是一个智能数据库具有强大的递归功能年日本政府宣布第代计算机系统项目以为基础语言以来成为了人工智能研究领域的主导语言是应用于专家系统的程序设计语言支持早期版本也支持或这些常规程序设计语言所具有的过程设计能力它不是对所有程序设计任务都适宜较之的早期版本对许多问题处理的更目然更有效是由美国宾夕法尼亚州卡内基一梅隆大学的等人开发最早版本是在年开发的之后几经修改形成了多种版本年出现了采用产生式系统的知识表示模式和正向精确推理方式它提供了两种交互环境一是和用户的界面二是和知识工程师的界面调试环境包括三个主要部分知识库推理机和工作存贮器知识库又称规则库每条规则均以语言来表示的推理过程由若干识别一动作周期组成每个周期包括三个动作或阶段匹配冲突解决或选择和执行匹配是数据和已有规则的匹配匹配的结果形成了冲突集是所有满足条件的规则的集合然后推理机从冲突集中选择规则执行工作存贮器用来存贮推理机在推理过程中的初始状态中间状态和目标等信息各个模块可作为独立的文件存放在存贮器中单独编译然后连接在一起运行数据类型语句子程序等与一般程序设计语言类似使用的知识工程师有一个类似于过程描述型语言的编程环境年圣诞节期间荷兰人吉多范罗苏姆在阿姆斯特丹为了打发圣诞节的无趣决心开发一个新的脚本解释程序作为语言的继承还受到了的影响结合了和的习惯本人看来语言优美强大为非专业程序员设计但是语言并没有成功究其原因认为是其非开放造成的在中避免这一错误同时他还想实现在中闪现过但未曾实现的东西语法和动态类型以及解释型语言的本质使它成为多数平台上写脚本和快速开发应用的编程语言随着版本的更新和语言新功能的添加逐渐被用于独立的大型项目的开发解释器易于扩展可以使用或或者其它可以通过调用的语言扩展新的功能和数据类型也可用于可定制化软件中的扩展程序语言丰富的标准库提供了适用于各个主要系统平台的源码或机器码由于语言的简洁性易读性以及可扩展性在国内外用做科学计算的研究机构日益增多很多知名大学已经采用来教授程序设计课程例如卡耐基梅隆大学麻省理工学院等众多开源的科学计算软件包都提供了的调用接口例如著名的计算机视觉库三维可视化库医学图像处理库专用的科学计算扩展库十分流行例如如下个经典的科学计算扩展库和它们分别为提供了快速数组处理数值运算以及绘图功能语言及其众多的扩展库所构成的开发环境适合工程技术科研人员处理实验数据制作图表甚至开发科学计算应用程序并可用于机器学习领域让人惊奇的是今天成为人工智能应用层上最主要的外部接口尤其在图形图像领域使用尤其广泛例如和等这应该是所不曾想到的启示诚然编程语言很多描述这段历史时应该认识到的是不同的编程语言与当时的硬件环境软件理论相照应在今天只需要一概而过对于深度研发有一定认知的必要人工智能是一场科技革命不仅仅是理论的发展更是实践的应用随着硬件技术的进步人工智能理念的变幻软件方面也将有很大的发展编程语言发展上人工智能有很大的发展编程语言与硬件系统紧密结合编程语言与框架模式协作并行才会有更大的突破在未来人工智能方面编程语言的发展有这样三个思索研制与某种语言完全适应的新一代计算机例如机数据流机机面向对象的体系结构等但举步维艰前景渺茫以诺依曼机为核心的现代通用计算机已经广泛普及而且性能不断提高积累了巨大的软件资源任何与现代计算机不兼容的专用机最多满足特殊需求难以与现代通用计算机抗衡在没有很大商业机会的前提下这种办法是不可能实现的把不同风格的编程语言结合起来发展复合语言或嵌入式语言取长补短使系统性能得以进一步提高把面向对象语言的设计思路融汇到常用的面向过程的高级语言中语言就是一个突出的例子这种改变相对来说影响较小毕竟不是脱胎换骨用面向问题的人工智能编程语言的特点先选择某种语言编写出一个简洁明了而易于调试的程序原型通过验证调试再仿照这个原型改编为某种面向过程的高级语言程序例如或达到提高最终应用系统开发质量和执行效率的目的用等来开发专家系统原型已有不少先例在技术变幻的前提下这种方式有一定的价值计算机发展史上基于冯诺伊曼的硬件系统很难发生变化计算机编程语言的发展从未停止我们得到一个启示思想最容易在软件方面实现而计算机编程语言的发展也就不足为奇关于计算机体系结构的发展有一定价值的是在未来量子计算机的体系结构将会是一个重要的方向随着量子技术的进步对于商业而言再次掀起市场的沧海桑田腥风血雨机器学习库机器学习是人工智能的重要组成部分机器学习是一个完善的生态环境对于人工智能而言算法库是重中之重降低了智能视觉分析的门槛加大了人工智能的应用人工智能算法库有很多本部分重点讨论应用广泛的两个神经网络库和神经网络可以指向两种一个是生物神经网络一个是人工神经网络生物神经网络生物神经网络一般指生物的大脑神经元细胞触点等组成的网络用于产生生物的意识帮助生物进行思考和行动人工神经网络人工神经网络简写为也简称为神经网络或称作连接模型它是一种模仿动物神经网络行为特征进行分布式并行信息处理的算法数学模型这种网络依靠系统的复杂程度通过调整内部大量节点之间相互连接的关系从而达到处理信息的目的人工神经网络是一种应用类似于大脑神经突触联接的结构进行信息处理的数学模型在工程与学术界也常直接简称为神经网络或类神经网络人工神经网络即是世纪年代以来人工智能领域兴起的研究热点它从信息处理角度对人脑神经元网络进行抽象建立某种简单模型按不同的连接方式组成不同的网络在工程与学术界也常直接简称为神经网络或类神经网络神经网络是一种运算模型由大量的节点或称神经元之间相互联接构成每个节点代表一种特定的输出函数称为激励函数每两个节点间的连接都代表一个对于通过该连接信号的加权值称之为权重这相当于人工神经网络的记忆网络的输出则依网络的连接方式权重值和激励函数的不同而不同而网络自身通常都是对自然界某种算法或者函数的逼近也可能是对一种逻辑策略的表达是基于数据流编程的符号数学系统在人工智能领域有这广泛的应用是今天神经网络训练的主要平台成就了在今天庞大的用户群用于各类机器学习前身是谷歌的神经网络算法库谷歌不仅在大数据领域有着重要的位置在人工智能方面谷歌也名列前茅拥有多层级结构使用面向各种场景可部署于各类服务器终端和网页支持和高性能数值计算开发环境友好应用于谷歌内部的产品开发和各领域的科学研究发展由谷歌人工智能团队谷歌大脑开发和维护是谷歌核心的人工智能项目拥有很多子项目各类应用程序接口谷歌大脑年成立开展面向大规模深度学习应用研究谷歌大脑具有自我学习功能将万处理器连接的前身构建各尺度下的神经网络分布式学习和交互系统被称为第一代机器学习系统为世界人工智能发展做出了卓越的贡献在谷歌和旗下公司的产品开发中广泛使用成果颇丰拥有生态系统从数据训练接口导出到工程应用年月的开发者峰会有个项目非常有价值和意义核心组件利用做数据训练可以进行单机也可以进行分布式部署合作组件互相配合保证了的运转分布式的核心组件如下分发中心执行器内核应用最底端的设备层网络层分发中心从输入的数据流图中剪取子图将其划分为操作片段并启动执行器分发中心处理数据流图时会进行预设定的操作优化包括公共子表达式消去常量折叠等执行器负责图操作在进程和设备中的运行收发其它执行器的结果分布式拥有参数器以汇总和更新其它执行器返回的模型参数执行器在调度本地设备时会选择进行并行计算和加速内核应用负责单一的图操作包括数学计算数组操作控制流和状态管理操作内核应用使用执行张量的并行计算库等执行加速执行低数值精度计算此外用户可以在内核应用中注册额外的内核以提升基础操作例如激励函数和其梯度计算的运行效率单进程相对简单整体部署训练与方便和分布式相比维护也很方便没有分发中心和执行器使用特殊的会话应用联系本地设备的内核是语言的提供的原始接口也是语言的其它组件均通过语言与核心组件进行交互组件是一个允许用户发布共享和使用模块的库开发项目用户可以将数据流图或其部分使用进行封装并移植到其它问题中再次利用页面列出了由谷歌和提供的封装模型其主题包括字符嵌入视频分类和图像处理是谷歌基于开发的产品级机器学习平台其目标是是对产品开发中的模型实现分析验证和业务化操作进行整合在实时数据下完成机器学习产品的标准化生产包含三个算法库对机器学习数据进行统计描述和验证对模型数据进行预处理对机器学习模型进行分析提供表现评分另有作为模型业务化的高性能系统提供模型接口和管理是在基础上开发的统计学算法库其目标是方便用户将概率模型和深度学习模型相结合使用包含大量概率分布的生成器支持构建深度网络的概率层提供变分贝叶斯推断和马尔可夫链蒙特卡罗方法和一些特殊的优化器包括方案算法和是的主要用于网页端的机器学习应用开发方便网页用户进行人工智能数据训练是为移动和嵌入式设备提供人工智能支持在系统下机器学习模型的响应时间并降低文件大小部署了大部分人工智能算法具有很好的参考价值是开源版的开发项目在深度学习和微分计算方面应用和很相像可直接执行数据流图具备更好的性能是面向科学研究的机器学习云计算平台该项目拥有个云和总计千万亿次计算力每个拥有的高带宽内存可以通过互联网申请使用进行有价值的人工智能数据训练其它是在艺术领域使用机器学习的研究项目该项目使用深度学习网络和强化学习算法学习生成音乐绘画和其它艺术作品以帮助艺术人员拓展其创作过程项目的研究成果包括音乐创作工具和混音工具是将应用于基因组文件例如和格式文件的读写和分析的库开发项目使用和进行开发是一个开源的机器学习库基于用于自然语言处理等应用程序年月由人工智能研究院基于推出了它是一个基于的计算包提供两个高级功能具有强大的加速的张量计算如包含自动求导系统的深度神经网络使用重写了很多内容更加灵活支持动态图提供了接口它是由团队开发是一个以优先的深度学习框架实现强大的加速支持动态神经网络可以看作加入了支持的也可以看成拥有自动求导功能的强大的深度神经网络除外已经被和等机构采用简洁高效快速应用的框架设计追求最少封装符合人类思维让用户尽可能地专注于实现自己的想法与的类似的支持足以确保获得持续的开发更新无论对于机器视觉还是人工智能相对从前数据量发生了地覆天翻的变化传统的运算框架不能满足现实的发展人工智能影响不是一点一线而是整个计算体系从芯片到数据处理再到平台架构框架编程外部接口调用都有巨大的变革今天我们谈一下基于大批量数据的运算框架的参与数据处理已经多年多年发展过程中不过是硬件的支持如下图指令的提供传统的工程师很难进行指令级的开发所以运算平台出现了拓展了技术应用便捷了软件开发下面讲述目前最广泛的两个运算平台英伟达的和开放的平台是由推出的并行计算架构该架构使解决复杂的计算问题包含了指令集架构以及内部的并行计算引擎开发人员可以使用语言来为架构编写程序语言是应用最广泛的一种高级编程语言编写出的程序可以在支持的处理器上以超高性能运行计算行业从只使用的中央处理向与并用的协同处理发展为打造这一全新的计算典范英伟达发明了统一计算设备架构这一编程模型应用在应用程序中充分利用和各自的优点该架构已应用于精视翼扬以及图形处理器上对应用程序开发人员来说这是一个巨大的市场在消费级市场上几乎每一款重要的消费级视频应用程序都已经使用加速或很快将会利用来加速其中包括公司公司以及公司的产品在科研界一直受到热捧例如现已能够对进行加速是一款分子动力学模拟程序全世界在学术界与制药企业中有超过名研究人员使用该程序来加速新药的探索工作在金融市场以及针对一款全新的对手风险应用程序发布了支持并取得了倍速度提升为近家金融机构所广泛使用的广泛应用造就了计算专用的崛起全球财富五百强企业已经安装了多个集群这些企业涉及各个领域例如能源领域的斯伦贝谢与雪佛龙以及银行业的法国巴黎银行包括阿里云计算目前成为主流在显卡硬件上将不仅仅是图形处理器还是应用程序均可使用的通用并行处理器随着显卡的发展越来越强大为图像处理做了优化计算上超越了通用的强大的芯片不能仅仅进行显示因此推出让显卡可以用于图像计算以外的目的架构可以使用来解决商业工业以及科学方面的复杂计算问题它是一个完整的解决方案提供了硬件的直接访问接口而不必像传统方式一样必须依赖图形接口来实现的访问系统结构在架构上采用了一种全新的计算体系结构来使用提供的硬件资源从而给大规模的数据计算应用提供了一种比更加强大的计算能力采用语言作为编程语言提供大量的高性能计算指令开发能力使开发者能够在的强大计算能力的基础上建立起一种效率更高的密集数据计算解决方案体系结构包含三部分开发库运行期环境和驱动开发库是基于技术提供的应用开发库版提供了两个标准的数学运算库离散快速傅立叶变换和离散基本线性计算的实现这两个数学运算库解决的是典型的大规模并行计算问题也是在密集数据计算中非常常见的计算类型开发人员在开发库的基础上快速方便的建立起自己的计算应用此外开发人员也可以在的技术基础上实现出更多的开发库运行期环境提供了应用开发接口和运行期组件包括基本数据类型的定义和各类计算类型转换内存管理设备访问和执行调度等函数基于开发的程序代码在实际执行中分为两种一种是运行在上的宿主代码一种是运行在上的设备代码不同类型代码运行的物理位置不同访问的资源不同对应的运行期组件也分为公共组件宿主组件和设备组件三个部分囊括了所有在开发中所需要的功能和能够使用到的资源接口开发人员通过运行期环境的编程接口实现各种类型的计算由于存在着多种版本的显卡不同版本的之间都有不同的差异因此驱动部分基本上可以理解为是的的设备抽象层提供硬件设备的抽象访问接口提供运行期环境通过这一层来实现各种功能基于开发的应用必须有的硬件支持公司运算事业部总经理在活动中表示一个充满生命力的技术平台应该是开放的未来也会向这个方向发展由于的体系结构中有硬件抽象层的存在因此今后也有可能发展成为一个通用的标准接口兼容不同厂商的产品支持的销量逾亿数以万计的开发人员正在使用免费的软件开发工具来解决各种问题从视频与音频处理和物理效果模拟到石油天然气勘探产品设计医学成像以及科学研究涵盖了各个领域核心的核心有三个重要抽象概念线程组层次结构共享存储器屏蔽同步轻松将其作为语言的最小扩展级公开给程序员软件堆栈由几层组成一个硬件驱动程序一个应用程序编程接口和它的还有二个高级的通用数学库和硬件被设计成支持轻量级的驱动和层面因而提高性能其它进军高性能计算领域推出了高性能计算系列解决方案技术一种基于图形处理器上全新的并行计算体系架构让科学家工程师和其它专业技术人员能够解决以前无法解决的问题作为一个专用高性能计算解决方案把超级计算能够带给任何工作站或服务器以及标准基于的服务器集群是用于计算的开发环境是一个全新的软硬件架构可以将视为一个并行数据计算的设备对计算分配和管理的架构中计算不再像过去所谓的架构那样必须将计算映射到图形和中对于开发者来说的开发门槛大大降低编程基于语言任何有语言基础的用户都很容易地开发的应用程序的特点是处理密集型数据和并行数据计算因此非常适合需要大规模并行计算的领域除了可以用语言开发广泛的应用在图形动画科学计算地质生物物理模拟等领域计算正在从中央处理向与协同处理的方向发展对应用程序开发商来说英伟达架构拥有庞大的用户群开放运算语言是第一个面向异构系统并行编程的开放式免费标准也是一个统一的编程环境便于软件开发人员为高性能计算服务器桌面计算系统手持设备编写高效轻便的代码而且广泛适用于多核心处理器图形处理器类型架构以及数字信号处理器等其它并行处理器在游戏娱乐科研医疗等各种领域都有广阔的发展前景平台可由或其它类型的处理器组成用于编写在设备上运行的函数的语言基于和一组用于定义并控制平台的组成提供了基于任务分割和数据分割的并行计算机制类似于另外两个开放的工业标准和这两个标准分别用于三维图形和计算机音频方面扩展了用于图形生成之外的能力由非盈利性技术组织掌管发展最初苹果公司开发拥有其商标权并在与英特尔和技术团队的合作之下初步完善随后苹果将这一草案提交至年月的大会上苹果提出了规范旨在提供一个通用的开放在此基础上开发通用计算软件随后宣布成立通用计算开放行业标准工作组以苹果的提案为基础创立行业规范个月后的年月日该工作组完成了规范的技术细节年月日发布年月日发布年月日发布目前最新版本是年月首家发布了支持通用计算规范的驱动程序支持和操作系统年月初首次发布了可支持处理器和的交由业界标准组织进行审核目前该更名为年月发布了支持基于带的显示核心的第三代酷睿和年月发布了第四代酷睿其内置的锐矩自带缓存支持未来可能升级到显卡方面均支持显卡方面系列系列均支持除系列外其余均会支持移动平台方面目前高通系列系列提供了上的或者支持的也提供了支持支持工作组的成员包括苹果爱立信飞思卡尔华为基金会诺基亚摩托罗拉高通三星德州仪器布里斯托尔大学瑞典大学像和都是这个标准的支持者不过微软并不在其列目前显卡对技术支持较好在的系列专业显卡中能够使用技术只要显卡能够达到的要求就能够正常使用以获得优异的运算效率在的技术中现已经改名为并行加速技术已经为日常使用办公游戏等提供物理加速基于标准开发其中系列同时支持和由于基于和语言开发更适合和这样的架构和系列支持运算效率较老架构提升十分明显平台定义了宿主机程序发现设备所用的函数以及这些函数的功能还定义了应用创建上下文的函数运行时管理上下文来创建命令队列以及运行时发生的其它操作例如将命令提交到命令队列的函数就来自运行时编程语言编写内核代码的编程语言基于标准的一个扩展子集通常称为编程语言总结综合上述内容形成全景图如下首先是一个定义上下文的宿主机程序上图中的上下文包含两个设备一个和一个接下来定义了命令队列这里有两个队列一个是面向的有序命令队列另一个是面向的乱序命令队列然后宿主机程序定义一个程序对象这个程序对象编译后将为两个设备和生成内核接下来宿主机程序定义程序所需的内存对象并把它们映射到内核的参数最后宿主机程序将命令放入命令队列来执行这些内核其它相关库智能时代是百花齐放的时代芯片技术驱动硬件技术芯片指令提供操作接口操作接口驱动运算平台运算平台驱动机器学习库本主题介绍部分机器视觉和并行计算库是基于许可开源发行的跨平台计算机视觉和机器学习软件库运行在和操作系统上轻量高效由一系列函数和少量类构成提供了等编程接口实现了图像处理和计算机视觉方面的通用算法简介用语言编写利用和指令为提供了透明接口意味着如果有特定处理器优化的库在运行时自动加载这些库拥有多个函数的跨平台的中高层不依赖于其它的外部库使用类对非商业应用和商业应用免费的视觉处理算法丰富部分用语言编写开源的特性处理得当不需要外部支持可以完整编译链接生成执行程序方便算法的移植的代码经过适当改写可以正常的运行在系统和嵌入式系统中应用致力于真实世界的实时应用通过优化代码的编写对其执行速度带来了可观的提升通过购买的高性能多媒体函数库得到更快的处理速度应用领域人机互动物体识别图像分割人脸识别动作识别运动跟踪机器人运动分析机器视觉结构分析汽车安全驾驶接口其它接口是用接口改编的主要接口语言也是语言依然保留了大量的语言接口该库也有大量的等的接口接口函数通过在线文档获得一个使用的接口也于年月开始实现可以在和等平台上运行可以在获得官方版本或者从获得开发版本是牵头提出的已被广泛接受用于共享内存并行系统的多处理器程序设计并提供一套指导性编译处理方案支持的编程语言包括和支持的编译器包括和等简介提供了对并行算法的专用描述源代码中加入专用的指令来指明自己的意图由此编译器可以自动将程序进行并行化在必要之处加入同步互斥以及通信在进行软件开发时间串行化到并行化是一个提高效率最有效的方法忽略这些或者编译器不支持时程序又可退化为串行程序代码仍然可以正常运作这是考虑硬件不同而设定的方案只是不能利用多线程来加速程序执行根据硬件支持进行单线程和多线程的处理对于并行描述的高层抽象降低了并行编程的难度和复杂度程序员可以把更多的精力投入到并行算法本身而非其具体实现细节这样让程序员集中精力做某些事情对基于数据分集的多线程程序设计是一个很好的选择尤其对计算要求严格的地方提供了更强的灵活性可以适应不同的并行系统配置线程粒度和负载平衡等是传统多线程程序设计中的难题这些问题从前主要靠中间件来进行实现或者从程序的框架角度来进行考虑现在把这些和兴的处理交给程序员直接接触的框架从而提高了效率中库从程序员手中接管了部分这两方面的工作作为高层抽象不适合复杂的线程间同步和互斥的场合这是由于本身的结构决定的不能在非共享内存系统例如计算机集群使用如果使用处理效果很不理想共享内容的系统上使用较多在项目开发过程中技术选型非常重要是作为共享存储标准而问世的它是为在多处理机上编写并行程序而设计的一个应用编程接口它包括一套编译指导语句和一个用来支持它的函数库当今双核四核的当道而六核的也已经面世多时所以在多处理机上编写运行并行程序会变得相当普遍单线程与多线程一般单线程程序多核心处理器没有办法提升处理效能对于多线程的程序就可以通过不同的核心同时计算来达到加速的目的程序员在进行开发时间对效率要有一定的认知如果效率较高的程序建议进行并行程序涉及下面我们举例单线程程序一件事一次要十秒的话要做十次一颗核心就是秒的倍这就是秒如果按照多线程的程序运行可以把一件事给两颗核心各自完成每核心各做次时间就缩短为秒这样速度提高了倍多线程的程序实际上也不简单我们上面的计算是机械的在工作的切割结合上也是要多花时间的现实中在最佳状况双核心的效能也不会是这样的理想化情况这个仅仅是我们不考虑其它情况时间的结果并不是所有任务都可以切割很多任务关键在一起直接切割给不同的处理核心各自并行运算出来的结果会有问题这是安全所不能容忍的多线程的程序在编写维护上比单线程的程序复杂了很多对于效率要求不高要求健壮性能的程序单线程稳定还是好的电脑是多处理器多核处理器或具备技术代表同一个时间处理多个线程的功能把各自独立的工作由单线程改成多线程执行的效率上一般是有提升的微软提供线程控制功能这种方法产生多个策略如下主线程把工作分配子线程去然后运算最后主线程对结果进行整理通过高阶指令这些指令往往是对指令进行调用演化为一系列操作这中操作在从前是不可想象的将程序并行化多线程化的这点免去了软件工程师的大部分工作负担并行化处理是的核心思想最简单情形只加一行指令将循环内的程序并行化处理与是针对共享内存并行编程的与之前的不同的是是线程级并行比的进程级并行要更轻量化一些轻量级代表更少的改动共享内容是解决共享的重要手段之一的并行需要完全重写整个程序这点相对麻烦很多是很多程序员排斥的将一个串行程序改造成的并行进行的改动近乎可以忽略不计应用分为环境和环境环境下开发在中使用将的中里的开启参数为就可以让编译时支持的语法编写使用的程序时则需要先的头文件循环并行化处理要在前面加上一行实例上面的程序在是一个很简单的循环十次调用这个函数把循环的执行次数传进并打印运行结果里平行化处理按照如下方式进行运行结果把循环分成两部分拆成不同的线程去跑进行交错输出怎么确定真的有跑多线程呢需要从硬件的角度来进行观察如果本来有多处理器多核心处理器或有的话一个单线程程序最多只会把一颗核心的使用量吃完单线程的程序工作管理员中看到使用率最多是说明利用率低利用把循环进行平行化处理后把两颗核心的都用了也就是使用率提高了可能达到这就证明并行的结果环境支持是这样的使用编译时加上开关参数即可示例上面代码首先增加了一个头文件然后主函数中多出来一句串行代码中没有的预处理器指令其它的跟正常的串行程序没什么区别是中用以允许非语言规范部分的行为如果编译器不支持预处理器指令那么编译时这句话就会被忽略掉依靠开头的预处理器指令来进行线程级并行预处理器指令后面加的是一些子句用来附加额外控制信息比如说子句是用来控制接下来的代码块中需要用多少个线程进行并行程序编译完成之后直接打开是无法运行的需要用来调用生成好的可执行文件会首先得到运行的目标机器进程数等情况然后启动多个进程等到多进程全部开起来之后并行就开始了在中编译完成之后的可执行文件可以直接运行程序在一开始是串行运行到了需要并行的时候单进程单线程会分裂成单进程多线程其实是除了主线程以外又启动了几个新的线程同时执行执行完毕后又回到单线程串行而且每次并行的线程数是可以在运行时指定的可以只把其中的一部分作并行处理而且并行的时候共享的内存变量等都是在一起的从串行程序的基础上改造过来非常容易可能只要加几段预处理器指令就可以了剩下的交给编译器和处理器去解决同步协作依靠进程间通信完成协作靠内存共享的解决线程写作冲突解决有四种方法指令归约指令例如运行的结果是每次运行最终结果可能是不同的这是什么原因呢运行时多个线程同时访问变量可能前一个线程写上去的内容马上被下一个线程给覆盖掉了数据共享出现了问题即出现了数据冲突加上指令来进行数据处理会进行特殊的处理编译器安排线程对下面执行的代码进行互斥访问这是一种运行约束每次只能够有一个线程执行下面的这一句代码这样保证数据处理的有序与安全性能是归约子句这是一个特定的写法加上这一句执行并行任务时本身是共享的但这个共享和上面是不一样的每个线程执行时会产生一个私有变量在并行块运算结束后系统会将私有变量的值整合然后传递给共享变量这样保证数据的共享性带命名的指令用来命名不同的临界区同一个临界区的访问和上面一样一次只有一个进程操作保证数据的安全不同的临界区有不同的进程进行同时访问这样保证数据的同步安全与同步是处理时间必须考虑的因素指令用的使用形式为这些语句用中的特殊硬件指令来实现加快处理结果简单锁锁住的区域只允许单个线程进行访问保证数据安全开放式并行编程标准程序员能够轻松利用异构计算系统的强大能力和一样是并行计算的主要平台架构简介为并行程序员给编译器提供简单的提示通过指令使编译器能够识别哪些代码部分需要加速无需程序员修改或改编底层代码本身简化并行编程标准把计算任务映射到加速器这方面指令向编译器呈现出并行机制从而让编译器能够更好执行工作指令由以及英伟达在的支持下开发而成是多家企业希望利用指令来简化编程模型的一个共同愿景硬件厂商和技术协会一起这些企业均致力于支持一种共同的编程标准共同把并行编程技术推向前进指令与指令工作方式很类似都是指令级别编程适用于高度数据并行代码可插入标准的和程序直接指导编译器进行某些代码段的并行这些并行的代码编译器会特别注意数据在和或其它之间来回转移的逻辑关系并将计算映射到适当的处理器上这些指令由硬件支持不需要较大的改动相对小的改动以标示出加速并行区域指令设计适用于一个通用并行处理器这样相同的代码可以运行在多核或任何编译器支持的其它类型的并行硬件上发展与应用年月北京全球视觉计算技术行业领袖发布了工具套件通过全新的套件科学研究将可以做更多事情并大幅提升计算效率虽然计算核心在短时间内不会变得更快这是硬件的制约但处理器的并行计算能力越来越强大这一趋势十年里一直存在而且还会持续下去通过软机制提高效率已在行业中得到广泛支持简化等现代处理器的并行编程年以及等领先的供应商推出编程标准以来已有多名研究人员和科学家采用了这一标准并取得了卓越的成绩免费的标准工具套件应用快捷使用方便快速对编程全新的工具套件行业领先获得了广泛的应用该工具套件中向学术开发者和研究人员免费提供这一编译器商业用户有天的免费试用期黄总还是很厚道的全新的工具套件有一个特别的工具指导用户如何添加指令会进行编译器提示以加速代码实现通过真实案例可以方便快捷的入门简单的指令让研究人员能够感受到并行计算运行加速同时不会破坏现有的代码不浪费之前所有代码编写花费的时间这些指令与代码具有着较好的应用硬件独立性硬件独立性代表一个标准无论对于硬件厂商或者软件厂商对于用户来说特别重要无论软件厂商还是硬件厂商不愿意接受那种受供应商限制的非便携式编程环境的一大主要特性是高性能移植这主要是硬件独立性的结果编译器则把这一优势推向全新高度让世人惊叹该编译器首次能够在多核和上加速代码极大程度提高了效率没有一台配备的系统时编译器会在多个核心上完成代码并行化进而提升性能当系统中有时该编译器将会针对做代码并行化的优化最终与多核相比可带来倍的性能提升这种提升大大提高了效率在今天得到广泛的应用代码在语言基础上进行修改通过添加编译器指令来标示这个和前面介绍的有些相似中进行线程同步目前的还没有线程同步机制实例第一段代码和第二段代码等效在中一个区域有一个单个组成等价于结果说明对应拷贝内存从到对应拷贝内存从到实例可以类比成的可以类比成解释线程分配个两个循环题一共是执行每个执行函数次另外一个代码结果说明代码会分配个每个对于每个来说执行是冗余的只需要执行一次即可再看下面的例子结果说明从循环次数上来说个的循环次数循环次数是最终到底分配多少个取决于编译器有可能则分配个实际情况可能更加复杂对于来说是冗余的情况和上面的相同可以看出中的冗余是对于来说的下面的这种写法可以消除这种冗余取得更好的效果在编程时间应该注意实例结果说明和前面比较区别是也就是指令不一样前面代码用的是结构主要描述程序员意图当前程序适合并行编译器根据描述会有非常灵活的表现把决定权留给编译器编译器的参与避免了硬件的模糊性为并行开发提供了便利英文全称为自由软件界的跨平台音效由主要应用是在音效缓冲和收听中编码设计给多通道三维位置音效的特效表现其风格模仿自倒闭以后该开发接口开始由自由软件开放源始码社群继续维护最大的主导者是创新科技并得到来自和自由软件开放源代码爱好者的持续支援这是今天仍在活跃的基本原因主要功能是在来源物体音效缓冲和收听者中编码来源物体包含一个指向缓冲区的指标声音的速度位置和方向以及声音强度收听者物体包含收听者的速度位置和方向以及全部声音的整体增益缓冲里包含或位元单声道或立体声格式的音效资料表现引擎进行所有必要的计算如距离衰减多普勒效应等不同于规格规格包含两个分支这是由于的特点决定的以实际函式组成的核心和用于管理表现内容资源使用情况并将跨平台风格封在其中还有库提供高阶易用的功能其定位相当于的支持平台包括等操作系统上在如下工具中也进行广泛的应用建模和渲染工具游戏引擎和编译器和编程软件略上主题已有讲述总结人工智能应用的广泛性在机器视觉层面不可能靠一套框架进行开发未来在机器视觉人工智能音视频处理层面不排除有更多支持库的出现美摄应用人工智能技术在智能视觉视音频领域进行着探索为短视频技术的发展写下浓重的一笔基于工业相机的软件编程厂商提供驱动与程序示例工程公司参考相关示例通过算法对相机视频媒体数据进行加工分析机器视觉偏向于机器学习并行运算运用数据挖掘技术进行模型训练机器视觉在硬件上往往和关联在框架支持上和大数据进行关联国外重点进行人工智能算法研究人工智能方案策划人工智能工具研发国内重点进行工具应用目前国内应用最多的是和来进行模型训练导出接口在应用层面调用形成各种人工智能系统视频领域的人工智能系统是视频智能应用的主要标柱国内人工智能发展日新月异在视频方面也有一些完善的框架与接口为人工智能视频系统提供算法支持启示硬件是推动软件技术发展的原动力在硬件技术进步的基础上智能时代为图形图像音视频领域添加了人工智能的成分从图形图像角度来说不仅是硬性参数的提升更是对图像数据的智能修复处理从视频角度来说不仅仅是摄影录制编排硬术的提升更是对视频数据的深度挖掘智能修复与深度处理从前是不可想象的当流媒体技术过渡到深度处理时代表着人类信息加工能力的显著增强从早期自然语言处理到今天流媒体的并行运算代表着是技术的巨大进步硬件水平的进步尤其是工业相机水平的进步促进了高清晰领域的图形图像处理传统相机水平的提升必将为视频处理提供新的发展方向与发展空间机器视觉技术是智能时代的核心技术机器视觉技术整体分为两部分第一部分是基于工业相机的专业处理第二部分是传统视频智能处理国外科技公司肩负着智能时代硬件发展的重任推动专业相机等硬件功能提升同时提供音视频图形图像领域的算法验证给出相关解决方案国内科技公司担负着人工智能终端应用的重任以国外底层研发为基础进行行业分类市场整合应用落地在量子计算机发展的大背景下不远的将来相信技术将会发生变革行业将会重新洗牌人工智能的基础理论将会有翻天覆地的变化人工智能的应用将会更深刻与广泛今天的人工智能是量子时代的一个前走而已真正的人工智能是量子时代人工智能在第四次科技革命的智能时代黄色面孔东方公司逐渐增多这个沉默了年的民族开始重新屹立于世界民族之林显示标准与视频处理单元消费级视频智能处理大体有年左右有了巨大的发展展望未来对应于大厂而言竞争是标准的竞争包含显示标准与处理单元竞争推动了科技的进步市场的繁荣新的显示硬件也不断发展基础上出现了等新的视频处理单元相信未来有更多的数据硬件处理单元出现人工智能还处在初级阶段标准与规范处在变化中随着高清晰视频硬件的出现软件算法很多方面也面临着调整近些年各国重视人工智能的发展资本的投入政策的驱动增添了人工智能发展的活力显示标准多年江湖厮杀各路显卡被赶尽杀绝留下英伟达和目前显卡技术的革新主要就是卡与卡技术的发展英伟达偏重人工智能偏重于与方向近期倡导的显示技术有英伟达的和的在介绍的同时有必要介绍下垂直同步又称场同步从显示器的显示原理来看单个像素组成了水平扫描线水平扫描线在垂直方向的堆积形成了完整的画面屏幕的刷新过程是每一行从左到右行刷新水平刷新从上到下屏幕刷新垂直刷新当整个屏幕刷新完毕即一个垂直刷新周期完成会有短暂的空白期此时发出信号所以中的指的是垂直刷新中的垂直显示器的刷新率受显卡控制显卡完成一帧扫描后就会产生一个垂直同步信号打开垂直同步指的是将该信号送入显卡图形处理部分这样让显卡在生成图形时受垂直同步信号的制约显示器上的图像是一线一线扫描上去的无论隔行扫描还是逐行扫描显示器都有种同步参数水平同步和垂直同步水平同步脉冲加在两个扫描行之间它是一个短小的脉冲一行扫描完成之后它就会出现指示着这一行扫描完成同时也指示着下一行将要开始水平同步脉冲出现后会有一小段叫的时间这段时间里的像素信号不会被显示出来过了这一小段时间之后电子枪就开始扫描新的一行将要显示的内容扫描到显示器上垂直同步脉冲是加在两帧之间跟水平同步脉冲类似但它指示着前一帧的结束和新一帧的开始垂直同步脉冲是一个持续时间比较长的脉冲可能持续一行或几行的扫描时间但在这段时间内没有像素信号出现技术可解决带来的取舍问题不论画面更新率有多快它都可以让屏幕与完全同步提供无与伦比的游戏体验通过技术游戏场景可即时呈现在玩家的眼前物件也将更清晰锐利游戏也变得更流畅年月日第二天连续发布以及两项重磅技术之后在加拿大蒙特利尔正式发布了全新的针对画面连贯性的新技术作为垂直同步技术的替代以及自适应垂直同步技术的延伸技术不仅解决了画面撕裂问题同时从根本上解决了困扰垂直同步技术许久的画面视觉卡顿问题技术在显示器中内置一枚可与硬件直接通讯的芯片这枚自带缓存的芯片可以协调显示器与之间的数据同步通过芯片的控制显示器的刷新延迟将可以与帧输出延迟保持完全一致支持技术的显示器会根据当前的性能水平自动调节刷新率芯片侦测到的帧输出延迟大于时它会自动延长显示器的刷新延迟避免传统的帧丢弃导致的视觉卡顿现象能够去除游戏垂直同步开启时的画面滞后问题也能够克服垂直同步关闭时画面失真问题常规显示器会直接同步的处理结果借助模块只有当完成一帧的渲染和画面优化后显示器才会刷新显示内容很多公司都推出了支持图像增强技术的显示器消除了屏幕撕裂和垂直同步输入延迟等影响增强了现有显示器功能的同时屏幕画面呈现出场景及时出现物体更加锐利以及游戏运行更加顺畅等出色的显示效果能强制显示器运行在的帧速率下甚至能让原生刷新率降到更低提供更好的视觉效果是力推的视觉效果增强技术可有效消除游戏中常见的撕裂卡顿现象保证画面流畅无撕裂无卡顿无伪影图像撕裂是屏幕图像看起来不连贯这是帧速率显示图像帧的速率与显示器刷新率显示器图像刷新频率不匹配的结果为显示器提供可变刷新率即动态刷新率该功能使显示器的刷新率与显卡的帧速率相匹配支持高达的刷新率具体取决于显示器这样可以享受显卡能够达到的最大帧速率如果眼睛够敏锐的话你可能会发现到输入延迟或者鼠标移动和光标实际移动之间的延迟也降低了基于的自适应同步协议可以在和上运行支持高动态范围色域支持低延迟低刷新率补偿技术等让游戏显示效果更加逼真从内容到显示器传输时需要进行这个额外的计算增加了处理数据同时增加了延时取消了传输过程的转换过程降低转换带来的延迟引入的另一个新功能是低刷新率补偿技术当游戏的小于显示器最低刷新率时通过额外插帧计算类似让低的画面更加流畅技术的应用即时显卡渲染较低时也可以显著的改善画面流畅度提高游戏体验总结显示器是显示部分的前端显示标准对显示硬件的发展起着引导的作用显示标准的变革通过传统硬件大厂来推动目前而论只有才有这样的实力显示标准对于图形图像视频硬件都有着紧密的联系发展过程中标准的改变将推动软硬件的发展美摄支持标准支持最新显示规范彰显短视频价值视频处理单元是一种全新的视频处理平台核心引擎具有硬解码功能以及减少负荷的能力可以减少服务器负载和网络带宽的消耗由提出区别于传统图形处理单元图形处理单元又包括视频处理单元外视频模块和后处理模块这三个主要模块的基础特性支持视频编解码标准类别丰富图像高清支持多种抗误码工具多解码和全双工多方通话同时进行提供了可编程性柔初性以及易于升级的解码和编码或主机接口因为在编解码处理和主接口都实现为可编程微处理中的固件特色及应用针对视觉处理应用而设计在性能功耗和功能性方面都有特别的强化使之更贴近于实际的应用需求其设计兼顾到多种用途专门为视觉处理进行硬件系统的优化也是集成多个主控的许多硬件加速器单元和矢量处理器阵列专门为视觉海量像素设计的高性能影像信号处理器以及丰富的高速外围接口保证强大性能和功能的前提下采用更先进的集成电路工艺大大缩小了芯片的尺寸结合有效的技术手段降低各个运算单元的功耗为视觉应用提供了一个强大的平台更多的开发工作是在软件上基于的视觉应用系统开发可以充分利用片上的硬件单元及相关的软件资源包含工具支持库及框架的完整软件开发套件视频处理器中涉及视觉处理的单元得到了增强如核心视觉处理单元线性代数运算矩阵还有前端影像处理单元不仅包含处理还有仿真支持相机调试工具图形处理能力的提升表现在支持图形检测为便于多核异构芯片开发而支持由于在视觉应用中与高敏感度和超高像素的传感器的接驳尤为重要因此专门有传感器支持接口单元特有的工具单元提供视觉调试全面支持中的主控制器等通用单元以开放为主便于客户进行更多应用开发作为一个行业的平台领先者需要有足够的积累和不懈的进取当然还要有强大的财力和物力人力的支持平台的创建和发展也绝不轻松在都柏林成立位于爱尔兰在罗马尼亚硅谷建立研发团队公司创始人堪称半导体和处理器行业的元老公司设立有技术指导委员会确立公司的技术路线和平台发展总体规划核心管理层来源于及其它知名公司资深的高管和专家公司员工未过百人研发人员占了九成五分之一负责芯片硬件设计其余从事上软件构建可见应用在很大程度上依赖于软件年被收购年英特尔人工智能峰会英特尔展示了一系列新产品旨在加速从云端到边缘的人工智能系统开发和部署迎接人工智能浪潮的到来英特尔展示了面向训练和面向推理的英特尔神经网络处理器作为英特尔为云端和数据中心客户提供的首个针对复杂深度学习的专用芯片英特尔具备超高扩展性和超高效率英特尔还发布了下一代英特尔视觉处理单元用于边缘媒体计算机视觉和推理应用代码示例总结的概念由公司提出英文全称中文译为图形处理器的概念由公司提出英文全称中文译为视觉处理器与实际均为显示处理核心提供了更多图形接口提供了更多视频接口年公司被公司收购之后已正式采用的名字的加入近些年取得巨大的发展社会发展中视频处理愈来愈重要适应实时潮流尤其在嵌入式领域应用广泛美摄国际领先的视频引擎优秀的视频运算架构引领短视频发展的方向是的简称中文名字叫加速处理器是融聚未来理念的产品它第一次将处理器和独显核心做在一个晶片上与协同计算彼此加速具有高性能处理器和最新支持独立显卡的处理性能大幅提升电脑运行效率实现了与真正的融合是处理器未来发展的趋势与从发展来看让和彻底融为一体无论是的还是目标都是一致的认为和的融合分为四步进行第一步物理整合将和集成在同一块硅芯片上利用高带宽的内部总线通讯集成高性能的内存控制器借助开放的软件系统促成异构计算第二步平台优化和之间互连接口进一步增强统一进行双向电源管理支持高级编程语言第三步架构整合实现统一的寻址空间使用可分页系统内存硬件可调度内存协同一致第四步架构和系统整合主要特点包括计算环境切换图形优先计算独立显卡的协同任务并行运行实时整合等等系列将多核中央处理器支持标准的强大独立显卡性能以及高速总线融合在一块芯片上拥有并行处理引擎和专门高清视频加速模块实现数据在不同处理核心间的加速传递基于的台式机笔记本和高清轻薄本已经销售多年基于的平板电脑和嵌入式电脑有很多优点高清视频播放效果流畅满足多种应用的突破性的计算能力全面支持以及强大的电池续航能力通过和宏碁华硕戴尔富士通惠普联想微星三星索尼东芝等领先厂商合作在电脑上推出基于的新品公司高级副总裁表示简而言之我认为加速处理器是自从架构问世之后余年来处理器领域最伟大的进步通过这一跨越我们让顾客能够随时随地体验高清视频享受超级个人计算体验并且让笔记本电脑具备全天的电池续航能力这是一个全新的产品系列全新的视角给消费者带来全新的精彩应用体验引擎随着硬件技术的进步高清视频的时代到来了从视频网站到电脑游戏再到蓝光碟片得到广泛应用引擎横空出世一系列与高清视频相关的独特性能将使基于的个人电脑为用户带来更加生动与逼真的高清视频体验引擎汇集了下列功能支持标准强大的并行处理能力加速应用性能提升系列显卡整合视频加速模块独特的图形驱动程序每月更新不断提高视频性能带有引擎标识的电脑代表着更强大的性能更流畅的上网体验华丽流畅安静的高清视频播放使标清视频播放出高清效果将内容转换成更立体的格式轻松高清应用为用户带来游戏体验运算体验与软件密不可分开发者受到和处理信息时各自为战进行独立计算的制约今天消除了这一障碍开发者可以利用的并行处理能力技术全天电池续航能力续航时间长达小时以上单芯片设计所带来的节电效果超过我们的预料新品锐龙处理器采用塞尚核心与路线图中一致其最高频率大约为为核线程三级缓存为只有标准版的一半测试成绩则绝对是锐龙级别的轻松压制十代酷睿和自家的锐龙编程没有设计独立的开发环境目前支持与等在并行编程领域主要支持的是下面是示例代码一选择平台并创建一个上下文选择可用的平台中的第一个创建一个上下文环境二创建设备并创建命令队列获取设备缓冲区大小为设备分配缓存空间选取可用设备中的第一个三创建和构建程序对象创建和构建程序对象释放资源一选择平台并创建一个上下文二创建设备并创建命令队列创建和构建程序对象四创建内核并分配内存空间创建要处理的数据创建内存对象五设置内核数据并执行内核六读取执行结果并释放资源总结的成功巩固了的市场和形成有力的竞争推动处理器技术架构技术并行计算技术的发展多年以来吊打的出现这一局面得到改变并行计算领域主要支持技术随着时间的推移技术将不断完善驱动将不断更新有着光辉的过去也应该有着辉煌的明天为处理器的发展做出了卓越的贡献图为台湾籍总裁苏姿丰女士英伟达的黄仁勋为苏姿丰的舅舅在芯片领域台籍华人有着卓越的贡献通用图形处理器简称利用处理图形任务的图形处理器来计算原本由中央处理器处理的通用计算任务这些通用计算与图形处理没有关系现代图形处理器有强大的并行处理能力和可编程流水线流处理器可以处理非图形数据在面对单指令流多数据流且数据处理的运算量远大于数据调度和传输的需要时通用图形处理器在性能上大大超越了传统的中央处理器应用程序主要功能通用图形处理器是近年来出现的计算机芯片在航空航天及防务应用中的高性能嵌入式计算中广泛应用前一个十年里作为高端计算机游戏的图形处理引擎引入是一种大规模并行处理器不仅有助于复杂的浮点计算而且容易编程通用图形处理器芯片的主要设计制造商加利福尼亚州圣克拉拉的公司和加利福亚州桑尼维尔的先进微型器件公司公司设计优势通用图形处理器广泛使用其设计支持包括开放性图形库语言公司创造的并行处理编程语言最近出现的开放性计算语言硬件平台的支持为软件开发提供了便利下图是中国天树之新推出的最新在和编程技术出现之前大规模并行处理的编程是一项困难的任务为数不多的专家采用极其神秘小众编程语言才能够完成新出现的软件编程框架尤其是有助于熟悉语言和语言的程序编制人员接受通用图形处理器技术通用图形处理器中多个处理核规则排列在一起随着时间的推移器件中处理核的数量会越来越多通用图形处理器的软件没有必要随着处理器核数量的增加而重新编写需要有较好的编程支持软件框架应该适应硬件设计的改变技术原理富兰克林说通用图形处理器可以用来解析事物以得到可利用的信息传递周围环境中的有用材料通用图形处理器所擅长的是完成两方面的工作一是表现事物二是解析事物通用图形处理器芯片的应用领域从单一的图形处理装置扩展到了信号处理装置通用图形处理器的软件编程语言也在向着信号处理和通用处理扩展类似于开放性图形库那样的图形处理语言就可以用于通用处理通用计算技术让显卡参与原本计算任务的技术从提出到现在十余年时间但是发展神速十年前高清视频刚流行时编码高清视频对于电脑来说处理非常困难视频编码过程中大部分运算都是浮点类型的不善于做这种运算对于这种类型的计算相当拿手计算起来量又大又快那个年代人们在思索能否用来编码高清视频当时业界的研究重点转向了英伟达凭借着强大的技术实力在硬件与计算机平台领域英伟达第一个推出了一套比较完整的解决方案将原本的运算搬到了之上视频编码速度比原先快了几倍有着通用性的需求它上面单个核心会设计的非常大而全面并且由于计算的特性核心中很大一部分面积用来构建缓存一个核心中往往有和两级缓存和控制单元解码器与分支预测等前端单元功能的强大代表着本身体量的大尤其对于缓存的集中实际用来运算的单元面积可能仅仅只占整个核心的一半甚至不到如图种种原因使没有办法做非常大的规模一个核心中能塞入的东西有限总体的核心数需要控制在一个合理范围中多了就会发生各种问题硬件集成是很麻烦的事情当工艺没有足够进步的时间集成发展的大门就关闭了八核的核心图可以看到四个核心的面积已经接近右边的集成而的设计理念就简单很多图形计算是一项简单直接的粗活相对单调直接复杂度远不如要负责的各种各样不同类型的工作当年想要提高图形计算速度的一个简单办法就是扩大处理器中含有的单元数量对于特定的计算任务有更大的计算单元在运算能力上远超表现出来就是现在的在浮点运算吞吐量上远超与在构造上的不同适合大批量特定计算尤其是并行计算几大图形软硬件厂商都推出了自己的计算解决方案下面主题进行介绍支持方首先提出实现的厂商是被收购前的并专门提供了一套开发工具包让程序员用该套工具调用来参与计算的能力不过由于各种限制和收购后支持不足当时管理也比较混乱这套在与的竞争中处于下风后来官方转向支持这套最终停止了开发今天很少有人听到这套并行计算框架是在时代推出的一项技术也是今天最流行的技术全称统一计算架构从核心开始率先采用了一种统一设计的架构将原本管线分工式设计转变为统一化的处理器设计伴随着核心的发布一起公之于众让程序员用和来编写用运行的程序学习成本比要低一些今天在并行计算集群领域有着广泛的应用例如和各种音视频引擎平台是目前应用最为广泛的一种实现的强力推广之下在许多领域大放异彩今天拥有最光大的市场英伟达曾经设计过无数成功的硬件可以说是英伟达设计的最成功的并行计算平台同时推动了英伟达硬件技术的应用上面两个的实现都是有平台针对性的要想用他们的解决方案你就得用和英伟达的硬件而就不一样了所谓就是一个开放的标准但是需要各家硬件厂商为提供驱动程序最早由苹果公司开发出的异构计算框架苹果公司将这套框架的草案提交到组织作为开放标准供业界使用在年末版本正式公开目前与的都支持这套框架这是除了之后另一个流行的计算框架不仅限于平台上提供的异构计算框架跨平台和开放标注的特性还可以使用专门的可编程电路来加速计算有广泛的支持空间业界对于它的支持非常广泛下图是联盟成员联盟微软是软件行业的老大在并行计算领域微软也在进行积极的探索是微软从开始加入的用于通用计算目的的集调用进行加速计算从开始的各种桌面特效就开始采用来加速计算在中微软完善了这套并且在系统上更多地使用来加速计算系统界面的各种特效不仅仅是专业的图形图像音视频领域在操作系统领域对并行计算的要求也很好当我们在使用微软的技术时间技术的一大技术支柱就是并行计算技术显示该支持的通用计算特性媒体编码加速十年前等面向高清应用的视频编码刚流行的性能限制编码一段的视频是一件相当耗费时间的事情所以人们想到了用来加速视频的编码刚推出的时候就将加速视频编码作为该技术的一大卖点免费提供了一个支持技术来转码的软件后来在显卡上加入了专门用于视频编解码的硬件电路开放了名为的编码供软件工程师调用通用计算也就此离开了这个距离我们最近的领域加速视频转码是图形图像音视频技术的霸主很早就在旗下的和软件中加入了的支持和都支持来加速视频实时预览和特效对并行计算技术的应用走在各家公司前列视频补帧与画面优化英伟达英特尔和三家相继在自己的中加入专用计算电路用以加速编解码视频之后通用计算就离开了这个领域不满足于既有的视频品质的人们又相继开发出了新的可以利用的功能视频补帧大大改善了视频质量视频补帧是原本低帧数的视频通过上下帧的计算渲染出一帧原本不存在的画面补在两帧之间使其观感更加流畅比如将帧的视频补帧至帧视频质量圆润流畅因为这个过程计算量过于庞大使用跟不上视频播放的速度没法做到实时补帧开发者就将这个功能搬到了上来运行很多人都曾经使用的就是一个利用的补帧软件补帧软件界面科技发展永无止境视频技术也不例外视频画面优化领域强大的视频渲染器也是利用来优化视频画面比如视频播放中出现的色带色环在压制过程中出现的瑕疵等可以使用在视频播放过程中进行实时的弥补使视频更加圆润与高清视频技术的发展永无止境人工智能与深度学习人工智能与深度学习是近年来非常热门的两个有关联的领域训练人工智能需要非常大的数据计算量这时候就可以利用上的强大功能谷歌的深度学习框架以及的就使用来加速学习这两年不断展示了它们在机器学习方面的一些结果在系列上引入的深度学习抗锯齿技术就是利用机器学习来达成的英伟达今天在人工智能领域占据着重要的位置在科技发展过程中很多公司靠软件驱动技术发展英伟达靠硬件驱动技术的发展技术上图是在科研领域的一些应用可以看到就在我们的身边超级计算机英伟达在开始就推出同架构的高品质计算卡品牌之下诞生了很多用计算卡来组建的超级计算机硬件技术的优势导致英伟达在超算领域领跑全球人工智能是英伟达的发展方向相信近几年使用英伟达技术的计算机会逐渐增多会曾经竞争贝尔戈登奖的六个入围者中五个使用了提供支持的超级计算机英伟达联手在超级计算机领域中继续发力预计未来采用技术的超级计算机将会越来越多近些年超级计算机硬件领域英伟达有着强大的技术实力在云平台上英伟达超级计算硬件应用较多相对于是新的概念十余年的发展已经不仅局限于还走向了其它领域扎根于我们生活的每个角落已经在许多云计算平台上得到了应用相信在以后会更加深入生活的更多方面尤其与人工智能技术的结合具有着巨大的应用空间示例代码总结带处理能力的主要是的工作的能力可以协助进行运算力通用图形处理超出的能力范围完全具备通用的数据处理用于图形处理的芯片也是一种相对于显卡早期显卡是没有专门用做图形处理的的不支持用于数据处理的芯片图形也可以认为是数据中央处理器一种相对的概念潜移默化被认定是放在主板上通过向传送指令控制加速处理器集成核心的并且融合不同于系与独立工作美摄采用并行计算技术基于硬件平台优秀的音视频引擎推动音视频技术发展张量处理单元为机器学习定制的芯片经过专门深度机器学习方面的训练它有更高效能每瓦计算能力谷歌年月开发者大会上推出的计算神经网络专用芯片为优化自身的机器学习框架而打造主要用于系统谷歌地图谷歌相册和谷歌翻译等应用中进行搜索图像语音等模型和技术的并行处理发展史年以总分打败围棋世界冠军李世石随后独战群雄在与排名世界第一围棋的冠军柯洁对战胜利后宣布隐退江湖背后的芯片开启了芯片产业的新篇章地覆天翻的四年芯片领域尤其是云端芯片市场规模一路扶摇直上成为芯片巨头和新势力虎视眈眈之地赛迪年月发布的中国人工智能芯片产业发展白皮书年全球云端芯片市场规模为亿美元这一数值预计在年达到亿美元巨大的市场将如火山爆发般呈现在众人眼前芯片制造的高光时刻到来了这片蓝海中有一个角色起到了划时代的意义它就是谷歌张量处理单元与李世石柯洁以及中日韩数十位围棋高手的围棋对战中脱颖而出后谷歌曾一路狂飙突进独步天下现在已演进到了第四代它的出现无疑打破了曾一度称霸神经网络推理和训练市场的局面在大数据人工智能领域谷歌的王者之风逐渐显现年月谷歌开发者大会上万众瞩目的第四代意外缺席取而代之的是以个组成的以及边缘芯片即便如此它仍通过一定程度的对外开放以及辅助谷歌内部服务器应用深刻地影响着云端芯片市场那次大会后知后觉的人们意识到谷歌卖的是方案与思想谷歌已经脱离了技术从市场角度看未来云端芯片巨大的发展潜力和市场机遇为谷歌提供了肥沃的土壤另一方面紧迫的算力瓶颈和摩尔定律放缓等问题也越来越难以忽视谷歌属于未来科技公司有无穷的可能始于算力瓶颈首秀人类围棋界区别于谷歌是一种芯片方案全称为应用型专用集成电路是专为某种特定应用需求而定制的芯片但一般来说芯片的开发不仅需要花费数年的时间且研发成本也极高一直是个别公司的阵地对于数据中心机房中工作负载的高算力需求许多厂商更愿意继续采用现有的集群或异构计算解决方案也甚少在领域冒险但谷歌说不了谷歌年起产生了要为神经网络研发一款专用芯片的想法而这一需求在年也开始变得愈发急迫谷歌这家超前的公司在未雨绸缪当时谷歌提供的谷歌图像搜索谷歌照片谷歌云视觉谷歌翻译等多种产品和服务都需要用到深度神经网络庞大的应用规模下谷歌意识到夜以继日运行的数百万台服务器它们内部快速增长的计算需求使得数据中心的数量需要再翻一倍才能得到满足然而从成本还是从算力上看内部中心已不能依靠和来维持制造芯片的冲动变成了现实种种因素的推动下不差钱的谷歌正式开始了的研发之旅经过研发人员个月的设计验证和构建年研发完成率先部署在谷歌内部的数据中心谷歌强大的财力保证了研发的成功成功很大程度源于不差钱内部秘密运行了一年外谷歌还在围棋界大杀四方斩获人机大战的神话在今天谷歌还有多少技术还装在黑匣子中呢使用之前内置个和个击败欧洲冠军范惠年与李世石对战时才开始使用而当时部署的数量只有个大开杀戒进入无人之境这场对战胜利的秘密武器也在一年后的谷歌开发者大会上被揭开神秘面纱正式面世在技术上谷歌隐藏的太深谷歌的迭代云端构建终端应用面世后短短两年谷歌已经迭代到了第四代性能亦不断跃升随着研发的投入和广泛应用谷歌也逐步推出可扩展云端超级计算机以及谷歌最终目的是超算领域与人工智能今天谷歌与英伟达成为超算领域的头狼名称发布日期性能应用年功耗主频深度学习推理年浮点运算高带宽内存机器学习训练和推理开始在上运行以用于应用程序年浮点运算扩展至更广泛的深度学习训练和推理领域已进入测试阶段年内建网络功能和加密芯片具有高吞吐量企业中的机器学习任务而设计主要执行推理年每秒千万亿次浮点运算环面网状网络深度学习领域年每秒千万亿次浮点运算环面网状网络深度学习领域年第一代为神经网络而研发但谷歌最初的第一代仅用于深度学习推理从性能上看第一代谷歌采用了工艺制造功耗约为主频研发之初谷歌需要尽快将部署到内部现有的服务器中因此研发人员选择将处理器打包成外部加速卡以插入硬盘插槽后进行嵌入式安装毫无疑问的是这种设计是成功的并很快投入了应用通过总线连接到主机实现了的有效带宽除了在上应用之外谷歌第一代还用于谷歌的搜索翻译和相册等应用的机器学习模型中第一代左在谷歌数据中心中部署的右年第二代引入一年更新研发和迭代谷歌在年月发布了第二代并从这一代起能够用于机器学习模型的训练和推理与第一代相比第二代实现浮点运算的计算能力同时其高带宽内存也提升到了解决了第一代内存受带宽限制的问题电子硬件的发展堪称神速运行工作负载上谷歌第二代与同期的相比性能比传统的高了倍比高了倍每瓦性能亦提高了至倍硬件有强大的提升空间保障谷歌思想的实现从第二代起谷歌第二代引入应用在谷歌计算引擎简称中也称为进一步优化谷歌搜索引擎和其他服务的运行谷歌通过进行云端软件技术处理提供硬件保障同时通过进行编程并与及基础设施和服务结合以根据用户应用需求构建和优化机器学习系统谷歌在云上的技术铺垫深厚谷歌未来的主战场是云端谷歌第二代的发布新一轮的人机大战也再次揭开序幕而这一代的芯片配置仅用了块击败当时的世界围棋冠军柯洁谷歌除了推出第二代外还宣布计划研发可扩展云端超级计算机通过新的计算机网络将块相结合能够提供约万亿次浮点运算能力强大的运算能力为谷歌平台提供了技术保障年第三代边缘芯片年月谷歌不出意外地发布了第三代其各方面性能不仅实现了升级也进一步扩展到更广泛的深度学习训练和推理领域我们怀疑的是第三代应该在年研发完成谷歌表示第三代的性能均是第二代的两倍可实现浮点运算以及的高带宽内存同时它还可部署在基于云计算的超级计算机中其中的芯片数量是上一代的四倍这些数据表明微电子技术的发展方兴未艾与第二代的部署相比第三代每个的性能提高了倍且每个最多拥有个芯片这些的集群形成了强大的狼群并行处理能力谷歌年发布了用于边缘推理的微型加速芯片专为企业机器学习任务而设计用于设备中市场是细分的技术必须根据市场变动同样是一款芯片从应用上看它与相互补用户能够先使用对机器学习模型进行加速训练再将训练好的模型放入相关设备中进一步用进行机器学习推理的芯片向纵深发展据了解能够让设备以每秒帧以上的速度在高分辨率视频上运行多个先进的计算机视觉模型数据处理重要的一部分是计算机视觉谷歌这种技术很可能在未来的某一天这些硬件产品出现在我们身边谷歌还为推出了一套名为的软件平台该平台拥有和两大主要组件能够帮助用户将在上构建和训练的机器学习模型通过扩展到边缘设备中运行技术的开源是未来的发展趋势软件平台的出现为谷歌技术的推广推波助澜年第二三代这一年谷歌并未发布第四代却上演了另一个重头戏发布第二代和第三代可以配置超过颗强大的集群带来了强大的性能在硬件技术突破的同时谷歌在软件集群技术上也在进行着发展作为的升级版谷歌第二代能够容纳个内核实现每秒千万亿次浮点运算第三代速度则更快可实现每秒超过千万亿次浮点运算这次升级之后我们期待着谷歌新一代的发布相信带来更强大的性能据悉在相同配置块下训练模型时第二代需要分钟而第三代只需分钟这些数据的背后是集群快速增长的结果让我们很难想象的是谷歌在集群技术路上还能走多远架构创新掀起云端造芯大浪潮谷歌系列芯片的出现不仅突破了最初深度学习硬件执行的瓶颈还在一定程度上撼动了英伟达英特尔等传统芯片巨头的地位英伟达在市场上这些传统霸主地位受到了挑战年以来与芯片相关的研发逐渐成为整个芯片行业的热点在云端的深度学习训练和推理领域已然不是尤其是英伟达独霸一方谷歌的诞生越来越多的公司前赴后继地尝试设计之外的专用芯片进一步实现更高效的性能这是一条成功的路线科技巨头都在进行着尝试技术层面看谷歌的出现在架构创新上也为行业带来了以下思考这种影响在未来几十年将会深刻的感受到大规模片上内存谷歌看来片外内存低是能效比低的主要原因一些由于片上内存较少因此在运行过程中需要不断地去访问片外动态随机存取存储器从而在一定程度上浪费了不必要的能耗在从前关于与上的内存是争论的喋喋不休的话题在功耗等各方面都有考量因此谷歌在最初设计时总共设计了占总芯片面积的内存其中包括的局部内存的累加器内存以及用于与主控处理器对接的内存谷歌反其道而行之用功耗换取效率用量化技术进行整数运算一般来说神经网络的预测并不需要位或位的浮点计算精度因此它可以通过位低精度运算的方法在保证适当准确度的同时对神经网络进行预测这种精细化的设计适应了神经网络技术的需求通过量化技术神经网络预测的成本大大减少相应减少了内存的使用例如当研发人员将量化应用于流行的图像识别模型时芯片内存从压缩到了约为其原始大小的四分之一人工智能时代每一种算法数据都有自己的特点神经网络作为人工智能的主流算法有自己的计算特点谷歌深谙此道并对硬件改进取得了的成功可编程性虽然谷歌是芯片但却与又有些类似它具备一定的可编程性能力谷歌看来的研发并非只用于运行一种神经网络模型因此谷歌选择采用了复杂指令集作为指令集的基础能够较为侧重地运行更复杂的任务软硬件技术的结合是成功的关键因素谷歌还定义了十二个专门为神经网络推理而设计的高级指令能够在输入数据和权重之间执行矩阵乘法并应用激活函数今天国内的学习是从指令开始起步为了能进一步对进行编程谷歌还创建了一个编译器和软件堆栈能够调用图中的转化成指令与的融合让开始接底气并为做大规模的神经网络数据训练打下基础并行计算谷歌为设计了矩阵乘法单元的并行计算并行计算是数据发展的要求今天并行计算是人工智能面临的第一个问题它能够在一个时钟周期内处理数十万次矩阵运算相当于一次打印一个字符一次打印一行字或一次打印一页文档这种高效的形式是成功的关键因素所在脉动阵列设计具有与传统和截然不同的架构又称为脉动阵列不同硬件设计带来的效果是惊人的脉动阵列使得在每次运算过程中谷歌能够将多个运算逻辑单元串联在一起并复用从一个寄存器中都取得结果脉动阵列设计形式大大提高了效率这种设计不仅能够将数据复用实现最大化减少芯片在运算过程中的内存访问次数同时也降低了内存带宽压力进而降低内存访问的能耗的矩阵乘法器单元谷歌的一鸣惊人不仅为芯片领域带来了架构创新同时亚马逊微软等一众科技巨头以及寒武纪天数智芯等新势力亦开始纷纷入局云端芯片市场开始风起云涌掀起行业云端造芯大浪潮这是一个芯片制造的年代如果没有技术的积淀与雄厚资本的支持芯片制造是水中花镜中月革命性芯片的研发投入在百亿以上国内的弘芯龙芯值得我们深思与机器学习的出现加速了第二代人工智能系统的运行效率也大大超过的深层神经网络由引擎驱动是专为机器学习量身定做执行每个操作所需的晶体管数量更少自然效率更高补充说明的是能耗也更高与同期的和相比可以提供倍的性能提升以及倍的效率性能瓦特提升在人工智能发展过程中效率的提升可以对算法进行有效的测试由于效率问题很多算法暂时无法测试每瓦能为机器学习提供比所有商用和更高的量级指令高性能计算得以在民间应用为机器学习应用特别开发使芯片在计算精度降低的情况下更耐用在人工智能年代未来指令级编程将称为常态对于国内大多数技术人员而言对指令的熟悉程度影响着个人技术的发展每一个操作只需要更少的晶体管用更多精密且大功率的机器学习模型并快速应用这些模型因此用户便能得到更正确的结果对比说明和都是较为通用的芯片但是有句老话是这样讲的万能工具的效率永远比不上专用工具而就是一个专业工具随着社会的计算需求越来越专业化芯片的专业化需求在增强便产生了专用集成电路的概念这个概念其实很早就出现了但是不是任何一家公司都能尝试的其复杂程度集成程度堪称技术的堡垒是指依产品需求不同而定制化的特殊规格集成电路由特定使用者要求和特定电子系统的需要而设计制造这些是定制化的芯片开发定制化的芯片开发一直广泛存在在这个领域谷歌的技术是成功的尝试因为很专一只做一件事它就比等能做很多件事的芯片在某件事上做的更好实现更高的处理速度和更低的能耗相应的的生产成本也非常高就是谷歌专门为加速深层神经网络运算能力而研发的一款芯片其实也是一款图谷歌第二代原来很多的机器学习以及图像处理算法大部分都跑在与半定制化芯片上面但这两种芯片都还是一种通用性芯片在效能与功耗上不能更紧密的适配机器学习算法硬件改变的初衷便形成了一直坚信伟大的软件将在伟大的硬件的帮助下更加大放异彩所以便想可不可以做出一款专用机机器学习算法的专用芯片便诞生了据称与同期的和相比可提供倍的性能提升以及倍的效率性能瓦特提升第一代只能做推理依靠云实时收集数据并产生结果训练过程还需要额外的资源第二代既可以用于训练神经网络又可以用于推理图各模块的框图如上图所示在芯片上使用了高达的局部内存的累加器内存以及用于与主控处理器进行对接的内存总共占芯片面积的图中蓝色部分这在从前是不可想象的图芯片布局图这表示谷歌充分意识到了片外内存访问是能效比低的问题所在不惜成本的在芯片上放了巨大的内存相比之下同时期英伟达的只有片上内存需要不断地去访问片外这种设计和传统硬件设计有巨大的区别也许只有谷歌财大气粗的公司才有如此的魄力吧性能与应用的高性能还来源于对于低运算精度的容忍研究结果表明低精度运算带来的算法准确率损失很小但是在硬件实现上却可以带来巨大的便利包括功耗更低速度更快占芯片面积更小的运算单元更小的内存带宽需求等采用了比特的低精度运算不同的技术有不同的应用不同的应用有不同的算法不同的算法有不同的精度的神经网络不需要传统的精度这和从前的很多设计思路是有区别的目前为止已经干了很多惊天动地的事情并且为我们服务了很多年并且在更多领域应用机器学习人工智能系统帮助用户处理搜索结果街景提高地图与导航的准确性下围棋的计算机程序这些大事记背后代表着人工智能时代到来了示例代码变分程序并行程序总结从到再到如今和相继入局云端芯片市场百花齐放与谷歌的推动息息相关今天云端芯片市场杀得热火朝天前有赛灵思和寒武纪等新老势力不断崛起进一步蚕食非领域的市场后有科技巨头四处找寻机会大鱼吃小鱼合并有潜力的新玩家整片市场呈一派割据混战百家争鸣之势不容忽视的是随着云端芯片不断发展大数据云平台持续爆发以及摩尔定律逐渐放缓算力也再次来到新的瓶颈玩家是通过先进制程再次撕开云端芯片的新技术领域还是依靠研发创新架构来实现算力的飞跃不管走向哪条路都需直面种种挑战在芯片市场开辟之初谷歌凭借逐渐打开云端芯片市场新的竞争格局但当云端芯片开始进入新时代谷歌在云平台大数据的技术优势相信能再次延续过往辉煌为市场开辟新的方向和路径由谷歌独家提出独家研发独家应用这些能给我们多少启示呢谷歌从一个搜索科技公司过渡到大数据云计算公司进而走在人工智能硬件科技的大道上即神经网络处理器用电路模拟人类的神经元和突触结构为神经网络而生对神经网络进行硬件支持嵌入式神经网络处理器采用数据驱动并行计算的架构特别擅长处理视频图像类的海量多媒体数据视频与图像是人工智能数据的重要组成部分在今天有着最广泛的应用是网络处理器可以认为是一个组件或者子系统有时候也称为协处理器和一样偏向于并行架构设计生物神经网络生物神经系统是一个高度组织和相互作用的数量巨大的细胞组织群体人类大脑的神经细胞大约在个左右神经细胞也称神经元是神经系统的基本单元按不同的结合方式构成复杂的神经网络通过神经元及其联接的可塑性使大脑具有学习记忆和认知等各种智能生物神经网络由若干人工神经元结点相互连接神经元之间通过突触两两连接突触记录了神经元之间的联系生物神经元主要由以下几个部分组成胞体是神经细胞的本体树突用以接受来自其它细胞元的信号轴突用以输出信号与多个神经元连接突触是一个神经元与另一个神经元相联系的特殊部位神经元轴突的端部靠化学接触和电接触将信号传递给下一个神经元的树突或胞体人类神经网络电路模仿人类神经元把每个神经元抽象为一个激励函数函数输入由与其相连的神经元输出以及连接神经元的突触共同决定为了表达特定的知识使用者通过某些特定的算法调整人工神经网络中突触的取值网络的拓扑结构等该过程称为学习学习方法有很多这种方法也叫算法学习之后人工神经网络通过习得的知识来解决特定的问题生物神经网络的深度学习基本操作是神经元和突触的处理现在变成计算机处理传统的处理器指令集包括和等是为了进行通用计算发展起来的其基本操作为算术操作加减乘除和逻辑操作与或非需要数百上千指令才能完成一个神经元的处理深度学习的处理效率不高从通用计算到并行计算再到神经网络计算是近些年计算发展的一个重要特征神经网络对人工智能的发展影响深远人工智能科技公司的计划神经网络往往占有较大成分经典的冯诺伊曼结构不能满足要求神经网络中存储和处理是一体化的通过突触权重来体现冯诺伊曼结构中存储和处理是分离的由存储器和运算器实现二者之间存在巨大的差异在设计上关于存储与运算也进行了深刻的论证现有的基于冯诺伊曼结构的经典计算机如处理器和英伟达来跑神经网络应用时不可避免地受到存储和处理分离式结构的制约影响效率这也就是专门针对人工智能的专业芯片能够对传统芯片有一定先天优势的原因之一实现了计算与存储的结合出现国内典型代表有寒武纪芯片和国外的芯片以寒武纪为例指令直接面对大规模神经元和突触的处理一条指令即完成一组神经元的处理并对神经元和突触数据在芯片上的传输提供了一系列专门的支持指令编程不论对于人工智能对于大数据处理对于音视频和图形图像都有着重要的意义相比有百倍以上性能或能耗比差距寒武纪团队和联合发表的论文为例为单核处理器主频为峰值达每秒亿次神经网络基本运算工艺下功耗为面积平方毫米这就是专业设计的优势所在中的麒麟芯片集成了寒武纪的实现所谓的照片优化功能保证手机用了很长时间后还能不卡华为从麒麟芯片开始使用自家研发的达芬奇架构集成大大提升了芯片的处理能力至今采用了华为的手机高性能计算仍是卖点之一年月华为发布了最新的芯片包括用于云端训练的晟腾和用于终端推理的晟腾晟腾系列正式走入人们的视野华为手机使用芯片也是华为手机的成功要素之一手机是终端对视音频图形图像有着更多的应用的支持保障应用的顺利进行年月日云栖大会上阿里正式对外发布了全新的含光芯片含光是一款高性能的采用技术的用于云端推理的芯片颗含光的算力相当于颗含光推理性能达到能效比相比传统算力性价比提升举国造芯激动人心的时刻到来了财大气粗的阿里不再沉默达摩院重要的使命之一就是造芯资本的投入推动芯片技术的发展嵌入式神经网络处理器采用数据驱动并行计算架构擅长处理视频图像类的海量多媒体数据处理器专门为物联网人工智能而设计用于加速神经网络的运算解决传统芯片在神经网络运算时效率低下的问题近些年神经网络称为人工智能算法的重要支柱可以和结合成为其中的一部分这种组合的模式已经广泛使用也可以进行定制大大加强了的范围应用中和各有一个中的相对较小也被称为的应用已经步入家家户户未来还有很大的发展空间组成的结构充分考虑了神经网络运算的特点专为神经网络运算而设计各个模块通力结合保障了神经网络算法的高效执行处理器有如下几部分组成乘加激活函数二维数据运算解压缩等模块乘加模块用于计算矩阵乘加卷积点乘等功能内部有个有激活函数模块采用最高阶参数拟合的方式实现神经网络中的激活函数内部有个有个二维数据运算模块用于实现对一个平面运算如降采样平面数据拷贝等内部有个有个解压缩模块用于对权重数据的解压为解决物联网设备中内存带宽小的特点在编译器中会对神经网络中的权重进行压缩在不影响精度的情况下可以实现倍的压缩效果专业的设计考虑了运算的方方面面简单直接面向问题对通用专业硬件设计有一定的借鉴作用下图为高通的芯片高通一直是嵌入式领域的王者代码示例华为编程示例代码总结在现实中有着广泛应用尤其在智能计算图形识别领域下面总结场景对应用进行整理拍照时通过实现场景识别并利用运算修图判断光源和暗光细节合成超级夜景通过实现语音助手的运行使用记录用户使用习惯杀后台配合预判下一帧实现提前渲染提高游戏流畅度预判触控提高跟手度和灵敏度判断前台后台网速需求差异配合实现跑分判断游戏渲染负载智能调整分辨率辅助清理系统月不卡把降低游戏时的运算负载交给以省电实现和的动态调度利用和人工智能算法定期更换壁纸的功能辅助大数据广告推送实现输入法智能联想词的功能应用场景的支持下已经成为最重要的芯片目前技术已经成熟已经广泛应用愈交互领域在手机军工嵌入式领域广泛应用美摄完美支持运算年视音频技术积淀在短视频领域把人工智能应用做到极致时光变幻岁月横流计算机应用的深度与广度增大对图形图像处理也提出了更高的要求传统的硬件设计计算框架运算理论软件接口都面临着极大的挑战为了适应人工智能技术的发展软硬件技术都在进行着巨变智能时代创造了很多机会塑造了无数的科技巨头公司有更大的科技自由度智能时代技术百花齐放硬件辈出框架争鸣平台显现万马奔腾不同的硬件框架适应显示的需求显示技术的后面有着架构和并行计算架构在支持在相关专题阐述主流的架构并行计算模型计算显示硬件发展的历史可以看出专业计算显示硬件往往是民间计算显示硬件发展的前奏专业硬件发展成熟时民间消费应用的春天到来了专业性开发承担着更多的研发成本各家公司道路不尽相同成本相对高的项目承担着巨大的风险人工智能时代不仅仅是新的软件理论计算框架更是硬件技术的进步前置说明至此整个主题全部结束借鉴了一些资料如有异议请联系作者下面主题开始讲述处理器架构与指令材料与制造技术的进步推动了微电子技术的发展微电子技术的进步推动集成电路的发展集成电路的发展推动了显示芯片的发展显示技术发展过程中遵从了双色芯片芯片芯片再到智能芯片的发展过程在芯片发展的背后计算机图形学从早期的文本显示到后来世界的呈现再到今天机器视觉技术的发展硬件技术的提升带来了显示标准的变化显示标准从早期的到今天的和标准的出现指导着硬件的发展为图形图像引擎的出现做了铺垫从早期驱动编程到编程到专业图形引擎编程代表着图形图像技术的繁荣图形图像引擎推动了音视频技术的发展不同的显示标准带来计算机图形学的发展变化图形图像硬件变革上推出的概念同时推出并行运算框架并对大力支持推出架构的显卡英伟达推出自己的并行计算技术推出了图形架构的显卡推出图形库编程包硬件架构运算平台软件架构编程框架是硬件厂商的问题软件架构编程框架面向终端市场国内大力激励半导体产业发展寻求半导体技术的自主可控芯片产业有望进入黄金时代对于这个时代来说选择从头做研发是很困难的事将已有的放到芯片中则容易得多类似的这种总部在欧洲具有中资背景且具有几十年积淀的半导体企业有望迎来新的契机人工智能发展大背景下神经网络异军突起为音视频发展注入了智能因素把音视频深度应用推向一个新的高度美摄科技以音视频技术为基础以并行计算为依托以人工智能技术图形图像技术为双翼推动融媒技术发展常用术语加速处理器公司推出加速图像处理芯片产品大脑处理器地平线科技提出的嵌入式人工智能处理器架构第一代是高斯架构第二代是伯努利架构第三代是贝叶斯架构目前地平线已经设计出了第一代高斯架构并与英特尔在年展会上联合推出了系统高级驾驶辅助系统中央处理器目前核心主流产品深度学习处理器最早国内深鉴科技提出基于可重构特性的芯片设计专用的深度学习处理单元可基于已有的逻辑单元设计并行高效的乘法器及逻辑电路属于范畴抽象出定制化的指令集和编译器而非使用从而实现快速的开发与产品迭代事实上深鉴提出的属于半定制化的浮点计算单元通用处理器中的浮点运算模块图形处理器采用多线程架构为图形处理而生全息图像处理器微软出品的全息计算芯片与设备或者与相机显示相关投资的公司开发出的处理器包括微处理器微控制器用于低计算应用的计算机体系架构产品如系列处理器神经网络处理器基于神经网络算法与加速的新型处理器总称如中科院计算所寒武纪公司出品的系列无线电处理器公司推出的集合集蓝牙处理器为单片的处理器张量处理器公司推出的加速人工智能算法的专用处理器目前一代面向第二代面向训练矢量处理器收购的公司推出的图像处理与人工智能的专用芯片的加速计算核心可穿戴处理器公司推出的可穿戴片上系统产品包含等百度与公司在年大会上发布的智能云加速含核由挪威公司推出的一款位开源处理器凸凹贴图凹凸贴图计算机图形学在三维场景中凸凹处理的一个技术像素填充率像素填充率每秒渲染的像素数量早期亿级别现在亿级别三角形生成速度三角形生成速度三角形是三维图形渲染的重要单元当前从千万到亿级别不等硬件硬件显卡坐标转换和光源编程显存显存显卡的高速颗粒有更快的数据交互速度技术技术显存优化管理单元通过快速轴清除等手段优化显存的利用效率显卡流水线显卡流水线数量的多少决定显卡性能高低的一个很重要的指标和也在不断地增加显卡的流处理器数量使显卡的性能达到跳跃式增长这个和核心构建显存带宽等因素配合单一多意义不大片断流缓冲区技术处理无限制指令长度的阴影着色程序执行原理把需要经过渲染引擎多次处理的像素临时存储起来而不是把它们写到帧缓冲里面只有那些需要单通道处理的数据被写到帧缓冲这样节省显存的带宽从而使工作得更加有效率缺点只能对所有流程都是基于同一视点的多流程渲染有效对于用于生成不同视点图像的多流程渲染没用在日常应用中不同视点的多流程渲染十分普遍其次的执行过程有可能产生溢出一旦产生溢出其处理过程十分复杂会影响的执行效率可编程逻辑计算效率高更接近底层通过冗余晶体管和连线实现逻辑可编辑本质上是无指令无需共享内存计算效率比高主要应用于智能手机便携式移动设备汽车',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-19 22:05:12',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="热爱学习的未来酱" type="application/atom+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">热爱学习的未来酱</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/3588-npu/" style="font-size: 1.05rem;">3588 npu<sup>6</sup></a><a href="/tags/PCB%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">PCB学习<sup>1</sup></a><a href="/tags/buildroot/" style="font-size: 1.05rem;">buildroot<sup>1</sup></a><a href="/tags/deb%E5%8C%85%E5%88%B6%E4%BD%9C/" style="font-size: 1.05rem;">deb包制作<sup>1</sup></a><a href="/tags/deb%E5%8C%85%E7%9A%84%E5%88%B6%E4%BD%9C/" style="font-size: 1.05rem;">deb包的制作<sup>1</sup></a><a href="/tags/docker/" style="font-size: 1.05rem;">docker<sup>1</sup></a><a href="/tags/hexo/" style="font-size: 1.05rem;">hexo<sup>3</sup></a><a href="/tags/markdown/" style="font-size: 1.05rem;">markdown<sup>2</sup></a><a href="/tags/opencv/" style="font-size: 1.05rem;">opencv<sup>1</sup></a><a href="/tags/systemd%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">systemd学习<sup>1</sup></a><a href="/tags/%E5%9C%A8%E5%AE%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" style="font-size: 1.05rem;">在家学习记录<sup>1</sup></a><a href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" style="font-size: 1.05rem;">文件系统构建<sup>1</sup></a><a href="/tags/%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9/" style="font-size: 1.05rem;">源码修改<sup>1</sup></a><a href="/tags/%E7%91%9E%E8%8A%AF%E5%BE%AE%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/" style="font-size: 1.05rem;">瑞芯微脚本分析<sup>18</sup></a><a href="/tags/%E7%BF%BB%E5%A2%99/" style="font-size: 1.05rem;">翻墙<sup>1</sup></a><a href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B5%8B%E8%AF%95/" style="font-size: 1.05rem;">音视频测试<sup>1</sup></a><a href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81/" style="font-size: 1.05rem;">音视频编解码<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">29</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81/" itemprop="url">音视频编解码</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>音视频编解码</span></a></span></div></div><h1 class="post-title" itemprop="name headline">0-0-15 显示硬件发展与视频开发知识点扫盲</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-11-19T13:16:56.000Z" title="发表于 2023-11-19 21:16:56">2023-11-19</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-11-19T14:05:12.499Z" title="更新于 2023-11-19 22:05:12">2023-11-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2023/11/19/0-0-15%20%E6%98%BE%E7%A4%BA%E7%A1%AC%E4%BB%B6%E5%8F%91%E5%B1%95%E4%B8%8E%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%89%AB%E7%9B%B2/"><header><a class="post-meta-categories" href="/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81/" itemprop="url">音视频编解码</a><a href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81/" tabindex="-1" itemprop="url">音视频编解码</a><h1 id="CrawlerTitle" itemprop="name headline">0-0-15 显示硬件发展与视频开发知识点扫盲</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">John Doe</span><time itemprop="dateCreated datePublished" datetime="2023-11-19T13:16:56.000Z" title="发表于 2023-11-19 21:16:56">2023-11-19</time><time itemprop="dateCreated datePublished" datetime="2023-11-19T14:05:12.499Z" title="更新于 2023-11-19 22:05:12">2023-11-19</time></header><hr>
<p> 电脑上炫酷的展示，生动的形象，离不开硬件的支持，硬件是音视频编程文化的一部分。开发者有必要对相关硬件大概了解。本专题涉及视频硬件相关话题，音频相关以后讲述。</p>
<p>​    视频编程的本质是图形图像编程，本专题以时间为主线，以公司硬件发展为点位，以图像图像开发接口为切面，宏观进行介绍，希望对视频编程开发者进行有益的启示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192138685.png" alt="img"></p>
<p>​    本系列文章依发展顺序，从早期起源开始，再到2D时代，3D时代，移动时代，智能时代，最后到显示标准与专业视频处理单元，大体分为6部分。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192138724.png" alt="img"></p>
<p>​    早期概述回顾286之前的电脑，以及一些图形图像工作站。那个年代图形图像编程起源于欧美发达国家。毫不夸张的说，欧美打开了计算机世界的大门，后面简单描述了VGA早期图形编程。</p>
<p>​    2D时代回顾了当年硬件产品、2D编程接口。GDI、GDI+、D2D、AGG、Cairo、Cocoa Drawing等。2D时代的到来，迈出了图形图像编程的第一步，拉开了多媒体编程的序幕。</p>
<p>​    3D时代是计算机图形学大发展的年代，3D引擎的出现，为图形学的发展注入了活力。可以说，3D时代的降临，音视频技术的春天到来了。</p>
<p>​    移动时代是图形图像技术在嵌入式设备上拓展的年代，多媒体引擎也发生了一些变化。多媒体功能是手机最重要的功能之一，未来音视频技术在手机上将会有大的发展。</p>
<p>​    人工智能的发展，智能时代到来了，音视频方面是人工智能应用最广泛的分支。音视频技术是人工智能最重要的方向，未来，人工智能技术是音视频技术最核心的技术之一。</p>
<p>​    技术的发展没有穷尽，硬件技术的进步，显示标准和工业化硬件的出现。给技术的发发展指明了方向。</p>
<h1 id="1、早期概述"><a href="#1、早期概述" class="headerlink" title="1、早期概述"></a>1、早期概述</h1><p>​    早期图形图像处理主要靠一些工作站来完成。286之前的电脑仅进行基本的双色文本显示。显示主要靠显示器和主板显示原器件做支持。下图是1973年的Alto和1980年的Perq图形工作站，其中Alto是地球上第一台图形工作站。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192138787.png" alt="img"></p>
<p>​    286之前，国内谈不上电脑的视频编程。专业的音视频处理主要靠图形图像工作站完成，设备全靠进口，图形图像软件的开发是国外专业芯片公司、计算机设备公司开发，当年的视频编程没有走向民间。后来，在消费级领域，一些图形加速卡出现，为图形图像编程做了前期的准备。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192138694.png" alt="img"></p>
<p>​    286之前的图形图像工作站编程，历史已经久远，本专题不做阐述。</p>
<p>​    技术的发展推动了显示标准的改变，从MDA—CGA—EGA—VGA。显示标准对硬件厂商做了规格的约束，指引着显示技术的方向，影响着图形图像技术的发展，对视频研发产生影响，推动末端技术应用。</p>
<p>​    历史的烽烟过去，年代已经久远，广袤的互联网上，很难找到工作站编程的资料。</p>
<h1 id="2、VGA编程"><a href="#2、VGA编程" class="headerlink" title="2、VGA编程"></a>2、VGA编程</h1><p>​    VGA的出现，显卡作为独立功能部件，从主板上剥离。这个改变，图形图像编程的曙光出现了，当年的图形图像编程还必须依靠厂家提供的视频驱动。视频驱动的完备程度，很大程度决定了硬件厂商的生存。</p>
<p>​    下面的代码，老一代程序员应该对此并不陌生。也就是这样的代码，拉开了图形编程的序幕，迈出了视频编程的第一步。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//调用VGA驱动程序</span><br><span class="line">int  gdriver=DETECT， gmode;</span><br><span class="line">initgraph ( &amp;gdriver， &amp;gmode， “c:\\tc\\bgi”);</span><br><span class="line">setbkcolor ( BLACK);                 //设定背景颜色为黑色</span><br><span class="line">setcolor ( WHITE);                   //设定画线的颜色为白色</span><br><span class="line">setlinestyle (0， 4444， 4);          //设置当前线型 实线  线图样  线宽四个像素</span><br><span class="line">line ( x1， y1， x2，y2);            //画线  x1 y1起点  x2y2终点</span><br><span class="line">lineto( x， y);                      //当前位置到xy坐标画直线</span><br></pre></td></tr></table></figure>

<p>​    计算机发展过程中，显示部件在设计上发生着变化，下图是从70年代到今天显卡发展过程图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192138742.png" alt="img"></p>
<p>​    自从计算的出现，相比其它领域，计算机领域发展更快，对社会影响更远，厂商竞争更为激烈。下面从公司、产品、技术的角度探讨。</p>
<ol start="2">
<li>2d时代</li>
</ol>
<h1 id="3、2D时代"><a href="#3、2D时代" class="headerlink" title="3、2D时代"></a>3、2D时代</h1><p>​    几十年工艺改进，解决了基本制造问题，计算机开始向应用过渡。显示问题是首当其冲的问题，多年的思辨与实践，2D技术横空出世，完善发展，为计算机的应用推广做出了卓越的贡献。双色显示的星星之火，在2D时代终于熊熊燃烧，计算机走向民间的时代到来了。</p>
<p>​    下面从公司产品的角度，回顾2D时代的图形图像编程。</p>
<h2 id="3-1、公司"><a href="#3-1、公司" class="headerlink" title="3.1、公司"></a>3.1、公司</h2><h3 id="3-1-1、Amiga"><a href="#3-1-1、Amiga" class="headerlink" title="3.1.1、Amiga"></a>3.1.1、Amiga</h3><p>​    Amiga是80年代图形性能最强大的电脑之一，拥有专门处理图形的芯片。杰.迈纳是当年显卡芯片设计的灵魂人物。下图Amiga500拆机，红圈内的denise芯片就是专门用来负责处理图形的，denise是真正意义上的2d加速卡。</p>
<p>​    这家公司在音视频多媒体领域超越当年的IBM与Apple，遗憾的是，最好的技术也被市场所淘汰。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139556.png" alt="img"></p>
<h3 id="3-1-2、IBM"><a href="#3-1-2、IBM" class="headerlink" title="3.1.2、IBM"></a>3.1.2、IBM</h3><p>​    1981年， IBM推出个人电脑，提供了两种显卡，一种是“单色显卡”(简称 MDA)， 一种是 “彩色绘图卡” (简称 CGA)。</p>
<p>​    1982年，IBM又推出了MGA（Monochrome Graphic Adapter）， 又称Hercules Card (大力士卡)， 除了显示图形外，还保留了原来MDA的功能，IBM是世界第一块显卡制造商。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139564.png" alt="img"></p>
<h3 id="3-1-3、S3"><a href="#3-1-3、S3" class="headerlink" title="3.1.3、S3"></a>3.1.3、S3</h3><p>​    S3在1989年开始造显卡，2D画质领域无人能及，盛极一时的Trident也无奈败下阵来。S3最经典的产品当属Trio64V+，有着高速的2D性能和强大的VCD软解实力，支持1024×768的分辨率，在低分辨率下支持最高32Bit真彩色。</p>
<p>​    那是一个VCD满天飞的年代，显卡的VCD解压能力是视频底层技术的一个突破。S3几经被转卖，先被威盛收编，后被HTC揽入囊中。今天，HTC步履蹒跚，生死一线。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139538.png" alt="img"></p>
<h3 id="3-1-4、Trident"><a href="#3-1-4、Trident" class="headerlink" title="3.1.4、Trident"></a>3.1.4、Trident</h3><p>​    Trident，这家公司当年在2D显卡领域红极一时，在当年的产品专柜里，多次看到其身影，后期由于技术方向原因，在3D显卡年代被淘汰。最终在2003年被XGI收购。而XGI最终在后来被ATI纳入麾下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139600.png" alt="img"></p>
<h3 id="3-1-5、Matrox（迈创）"><a href="#3-1-5、Matrox（迈创）" class="headerlink" title="3.1.5、Matrox（迈创）"></a>3.1.5、Matrox（迈创）</h3><p>​    曾经独显领域的主要玩家，2D显卡时代声名显赫，3D时代落寞，最终转向小众视频市场。如今说起显卡GPU，很多人脑海里只会浮现NVIDIA、AMD两个名字，在上个世纪末，Matrox(迈创)的名字如雷贯耳。它的资格比NVIDIA、AMD要老得多。迈创来自加拿大(ATI也是)，Matrox成立于1976年，比ATI早9年，比NVIDIA早17年。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139577.png" alt="img"></p>
<h2 id="3-2、图形技术"><a href="#3-2、图形技术" class="headerlink" title="3.2、图形技术"></a>3.2、图形技术</h2><p>​    1976年~1995年是沉闷寂寥的2D时代，显示技术发展缓慢，，图形图像编程近乎停滞。市场期待着集成电路的发展、微电子技术的爆发。</p>
<p>​    1995年之后，硬件技术的春天到来了，3D显卡涌现，性能和技术有很大提升，鸟语花香，百家争鸣。厂商不断推陈出新才能生存，跟不上节奏的企业，逃不了被收购的命运。缅怀过去，继往开来，2D技术多年的发展为3D技术做了20年的铺垫。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139542.png" alt="img"></p>
<p>​    结合过去历史，回顾当年2D编程的技术。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139738.png" alt="img"></p>
<h3 id="3-2-1、GDI编程"><a href="#3-2-1、GDI编程" class="headerlink" title="3.2.1、GDI编程"></a>3.2.1、GDI编程</h3><p>​    当时图形图像编程多使用GDI技术。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139839.png" alt="img"></p>
<p>​    代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CDC *pDC = GetDC();</span><br><span class="line">pDC-&gt;SelectObject(&amp;…);</span><br><span class="line">ReleaseDC(pDC);</span><br></pre></td></tr></table></figure>

<p>​    GDI编程的出现，代表了消费级图像编程的兴起。</p>
<h3 id="3-2-2、GDI-编程"><a href="#3-2-2、GDI-编程" class="headerlink" title="3.2.2、GDI+编程"></a>3.2.2、GDI+编程</h3><p>​    GDI+是GDI的增强版，想当年，Windows平台的上的图形图像技术，走在各个平台的前端。</p>
<p>​    GDI编程为OpenGL和DirectX做了铺垫。</p>
<p>​    代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">HINSTANCE hInst = AfxGetResourceHandle();</span><br><span class="line">HRSRC hRsrc = ::FindResource (hInst，MAKEINTRESOURCE(nID)，sTR); // type</span><br><span class="line"></span><br><span class="line">if (!hRsrc)</span><br><span class="line">return FALSE;</span><br><span class="line"></span><br><span class="line">// load resource into memory</span><br><span class="line"></span><br><span class="line">DWORD len = SizeofResource(hInst， hRsrc);</span><br><span class="line">BYTE* lpRsrc = (BYTE*)LoadResource(hInst， hRsrc);</span><br><span class="line">if (!lpRsrc)</span><br><span class="line">return FALSE;</span><br><span class="line"></span><br><span class="line">// Allocate global memory on which to create stream</span><br><span class="line">HGLOBAL m_hMem = GlobalAlloc(GMEM_FIXED， len);</span><br><span class="line">BYTE* pmem = (BYTE*)GlobalLock(m_hMem);</span><br><span class="line">memcpy(pmem，lpRsrc，len);</span><br><span class="line">IStream* pstm;</span><br><span class="line">CreateStreamOnHGlobal(m_hMem，FALSE，&amp;pstm);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// load from stream</span><br><span class="line">pImg=Gdiplus::Image::FromStream(pstm);</span><br><span class="line"></span><br><span class="line">// free/release stuff</span><br><span class="line">GlobalUnlock(m_hMem);</span><br><span class="line">pstm-&gt;Release();</span><br><span class="line">FreeResource(lpRsrc);</span><br></pre></td></tr></table></figure>

<p>​    无论GDI还是GDI+技术，都代表着图形图像编程的年代到来了。</p>
<h3 id="3-2-3、Direct-2D"><a href="#3-2-3、Direct-2D" class="headerlink" title="3.2.3、Direct 2D"></a>3.2.3、Direct 2D</h3><p>​    Direct2D的出现代表着引擎技术的到来，体现了市场对图形图像、音视频技术的强烈需求，在引擎的背后，封装了图形图像技术的专业性与复杂性。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139869.png" alt="img"></p>
<p>​    代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt; </span><br><span class="line">#include &lt;d2d1.h&gt; </span><br><span class="line">#include &lt;d2d1helper.h&gt; </span><br><span class="line">#include &lt;dwrite.h&gt; </span><br><span class="line">#pragma comment(lib,&quot;dwrite.lib&quot;) </span><br><span class="line">#pragma comment(libd&quot;d2d1.lib&quot;) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static HINSTANCE g_hinst; </span><br><span class="line">static HWND g_hwnd;</span><br><span class="line">static bool g_flag_app_exit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static ID2D1Factory * g_factory; </span><br><span class="line">static ID2D1HwndRenderTarget * g_render_target; </span><br><span class="line"></span><br><span class="line">g_render_target-&gt;Resize(D2D1::SizeU(LOWORD(lparam)，HIWORD(lparam))); </span><br><span class="line">D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED， &amp;g_factory); </span><br><span class="line"></span><br><span class="line">RECT rc; </span><br><span class="line">GetClientRect(g_hwnd， &amp;rc); </span><br><span class="line"></span><br><span class="line">g_factory-&gt;CreateHwndRenderTarget(</span><br><span class="line">        D2D1::RenderTargetProperties()， </span><br><span class="line">        D2D1::HwndRenderTargetProperties(g_hwnd，</span><br><span class="line">D2D1::SizeU(rc。right - rc。left， rc。bottom - rc。top)    )， </span><br><span class="line">        &amp;g_render_target); </span><br><span class="line"></span><br><span class="line">g_render_target-&gt;BeginDraw(); </span><br><span class="line">g_render_target-&gt;Clear(D2D1::ColorF(0。63， 0。84， 0。00));  </span><br><span class="line">g_render_target-&gt;EndDraw(); </span><br><span class="line">g_render_target-&gt;Release(); </span><br><span class="line">g_factory-&gt;Release(); </span><br></pre></td></tr></table></figure>

<h3 id="3-2-4、AGG"><a href="#3-2-4、AGG" class="headerlink" title="3.2.4、AGG"></a>3.2.4、AGG</h3><p>​    AGG，全名：Anti-Grain Geometry，一个开源的、高效2D图形库。AGG的功能与GDI+的功能类似，提供了比GDI+更灵活的编程接口，产生的图形的质量非常高，跨平台的2D图形引擎，可在Windows、Wince、Linux等平台上运行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139845.png" alt="img"></p>
<p>​    设计上，师出Boost库，使用了大量的C++语法规则，包括模板、仿函数等处理。为了能在更多平台上使用，并没有直接使用Boost和STL库，自己实现了部分STL功能。”</p>
<h3 id="3-2-5、Cairo"><a href="#3-2-5、Cairo" class="headerlink" title="3.2.5、Cairo"></a>3.2.5、Cairo</h3><p>​    cairo 是一个免费的矢量绘图软件库，可以绘制多种输出格式。cairo支持许多平台，包括 Linux、BSD、Windows等。Linux 绘图可以通过 X Window 系统、Quartz、图像缓冲格式或 OpenGL 上下文来实现。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139859.png" alt="img"></p>
<p>​    cairo 的主要设计目标是提供尽可能接近的输出。这种一致的输出使 cairo 非常适合 GUI 工具集编程和跨平台应用程序开发。使用同一个绘图库打印高分辨率的屏幕和绘制屏幕内容，这种功能具有显著的优点。</p>
<p>​    在支持的目标平台上，cairo 尝试智能化地使用底层硬件和软件支持。高质量矢量图形和高性能的结合使cairo成为优秀的绘图系统。</p>
<p>​    cairo 用C编写的，为大多数常用的语言提供了绑定。选用C语言有助于创建新的绑定，在进行C语言调用时提供高性能。和Python绑定，支持快速原型开发，降低了学习 cairo绘图API的门槛。</p>
<p>​    代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cairo.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc， <span class="type">char</span> *argv[])</span> </span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">cairo_surface_t</span> *surface; </span><br><span class="line">    <span class="type">cairo_t</span> *cr; </span><br><span class="line">    <span class="type">int</span> width = <span class="number">640</span>; </span><br><span class="line">    <span class="type">int</span> height = <span class="number">480</span>; </span><br><span class="line">    surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32， width， height); </span><br><span class="line">    cr = cairo_create (surface); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Drawing code goes here */</span> </span><br><span class="line">    cairo_set_line_width (cr， <span class="number">10</span>); </span><br><span class="line">    cairo_set_source_rgb (cr， <span class="number">0</span>， <span class="number">0</span>， <span class="number">0</span>); </span><br><span class="line">    cairo_rectangle (cr， width/<span class="number">4</span>， height/<span class="number">4</span>， width/<span class="number">2</span>， height/<span class="number">2</span>); </span><br><span class="line">    cairo_stroke (cr); </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Write output and clean up */</span> </span><br><span class="line">   cairo_surface_write_to_png (surface， <span class="string">&quot;rectangle。png&quot;</span>); </span><br><span class="line">   cairo_destroy (cr); </span><br><span class="line">   cairo_surface_destroy (surface); </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-6、Cocoa-Drawing"><a href="#3-2-6、Cocoa-Drawing" class="headerlink" title="3.2.6、Cocoa Drawing"></a>3.2.6、Cocoa Drawing</h3><p>​    Cocoa Drawing是苹果公司的2D图形图像开发类库，在XCode下运用，旨在推广苹果公司的技术。纵然苹果一直有着很强的图形图像处理能力，但仅局限于苹果公司本身的软件，苹果在早期一直没有很好的图形图像编程引擎。</p>
<p>​    近些年苹果的Metal技术，才可以算作苹果公司真正的技术创举。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139889.png" alt="img"></p>
<p>​    代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[NSGraphicsContext saveGraphicsState];</span><br><span class="line"></span><br><span class="line">// Create the path and add the shapes</span><br><span class="line">NSBezierPath* clipPath = [NSBezierPath bezierPath];</span><br><span class="line">[clipPath appendBezierPathWithRect:NSMakeRect(0.0，0.0，100.0，100.0)];</span><br><span class="line">[clipPath appendBezierPathWithOvalInRect:NSMakeRect(50.0，50.0，100.0，100.0)];</span><br><span class="line"></span><br><span class="line">// Add the path to the clip shape。</span><br><span class="line">[clipPath addClip];</span><br><span class="line"></span><br><span class="line">// Draw the image。</span><br><span class="line">[NSGraphicsContext restoreGraphicsState];</span><br></pre></td></tr></table></figure>

<h2 id="3-3、总结"><a href="#3-3、总结" class="headerlink" title="3.3、总结"></a>3.3、总结</h2><p>​    计算机功能的强大，代表本身的强大，本身的强大代表体系的复杂，模块的组合，视频技术也不例外，从宏观角度来看，图形图像编程框架如下图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139912.png" alt="img"></p>
<p>​    软硬件技术是紧密结合的，硬件技术的进步推动了软件编程的繁荣，软件技术的应用促进了硬件的推广。早期的硬件公司驱动设计、专业级的编程接口研发，到后期消费级市场软件技术的繁荣。图形图像编程形成独立的软件阵地，呼唤着3D时代的到来。</p>
<h1 id="4、3D时代"><a href="#4、3D时代" class="headerlink" title="4、3D时代"></a>4、3D时代</h1><p>​    历史长河中，科技进步是人类文明的主要推动力。沧海桑田，天下多变，人类对科技的研究与探索从未停止，计算显示技术也不例外。</p>
<p>​    现实是3D的，显示硬件注定也是3D的。透过历史的云烟，得到岁月的启示，硬件对3D技术的支持是显卡厂商存活的根本。硬件对图形图像引擎的支持，是显示芯片公司做大做强的基础。引擎支持主要包括OpenGL和D3D引擎支持，在2000年前尤为明显。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139634.png" alt="img"></p>
<p>​    科技的风风雨雨，面临着技术的抉择和选型，无论辉煌黯淡，时光默然前行，那些远行的技术，做了科学的辩证。</p>
<h2 id="4-1、公司"><a href="#4-1、公司" class="headerlink" title="4.1、公司"></a>4.1、公司</h2><h3 id="4-1-1、3Dfx"><a href="#4-1-1、3Dfx" class="headerlink" title="4.1.1、3Dfx"></a>4.1.1、3Dfx</h3><p>​    1994年，3Dfx成立，在当时是一家小公司，定位明确，很快就推出了业界的第一块真正意义的3D图形加速卡：Voodoo。在当年，Voodoo在速度以及色彩方面的表现让喜欢游戏的用户为之疯狂，Voodoo几乎是玩家们唯一的选择，当年3Dfx的专用Glide引擎接口统治了整个3D世界。当年一个专业图形引擎，可拯救一系列产品，成就一家硬件厂商。</p>
<p>​    Glide引擎提供了专业的3D图形显示接口，Glide可以说是一套3D接口库，3Dfx凭借硬件与引擎的结合创造了发展历史上的奇迹。3Dfx的成功就是在3D硬件支持和相关引擎支持良好的表现。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139557.png" alt="img"></p>
<p>​    3Dfx从硬件上实现了Z缓存和双缓存，可进行光栅化之类的操作，实现了DirectX 6的特征集。CPU从繁重的像素填充任务中解脱出来。当然，当年的技术不成熟，顶点变换必须在CPU中完成，光栅化之后的像素操作也很有限。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139575.png" alt="img"></p>
<h3 id="4-1-2、ATI"><a href="#4-1-2、ATI" class="headerlink" title="4.1.2、ATI"></a>4.1.2、ATI</h3><p>​    说起显卡，我们不能不提ATI，由于对3D技术支持较好以及紧跟OpenGL和DirectX步伐。多年和英伟达齐名。后来由于显卡驱动问题，造就了A卡追击N卡的局面。ATI提供了良好的编程接口，成为推广的一个重要因素。</p>
<p>​    ATI的欻创始人何国源先生，广东新会人，在很多年间都是芯片界的顶级人物。AMD在2006年以54亿美元收购ATI，何国源从此退出显卡芯片行业。今天世界上很多电脑的显卡都有ATI的技术。下面是显卡领域的两个风云人物，何先生已金盆洗手，退出江湖，黄药师依然皮衣挂帅，征战一线。</p>
<p>​    市场风云变幻，毫无疑问，ATI是幸运的，当年潜图问鼎，雄霸天下。直至后来被高价收购，多年后的今天，A卡依然笑傲江湖。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139678.png" alt="img"></p>
<h3 id="4-1-3、NVIDIA"><a href="#4-1-3、NVIDIA" class="headerlink" title="4.1.3、NVIDIA"></a>4.1.3、NVIDIA</h3><p>​    提起显卡，必须提及另外一个厂家NViDia，英伟达的创始人黄仁勋先生，台湾台北人，江湖人称黄药师（老黄）。近20年以来，世界顶级芯片巨头。在图形处理芯片上，何国源和黄仁勋都做出了不可磨灭的贡献，图形处理芯片的前身，就是今天的GPU，GPU是英伟达推出的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139618.png" alt="img"></p>
<p>​    NVIDIA 通过NV系列产品小试牛刀，通过GeForce 系列产品出征江湖，屡战屡胜，战功显赫，今天稳坐显示领域第一把交椅，无人出其左右。在人工智能数据分析方面，英伟达依然战功显赫。</p>
<p>​    想当年，显示领域是英伟达和ATI的天下，两者相互竞争，推动了显示技术的发展。成就了今天的显示规范。当年的竞争本质是显示指令、Shader编程、效率的竞争。</p>
<p>​    英伟达的NV3开始支持OpenGL，取得了巨大的成功。后期开始支持Direct3D。也就是前期对这些框架支持不足，导致经营举步维艰。</p>
<p>​    1999年8月，NVIDIA公司发布了一款代号为NV10的图形芯片Geforce 256。Geforce 256是图形芯片领域开天辟地的产品，因为它是第一款提出GPU概念的产品。</p>
<p>​    Geforce 256所采用的核心技术有“T&amp;L”硬件、立方环境材质贴图和顶点混合、纹理压缩和凹凸映射贴图、双重纹理四像素、256位渲染引擎等。“T&amp;L”硬件的出现，让显示芯片具备了以前只有高端工作站才有的顶点变换能力，同时期的OpenGL和DirectX 7都提供了硬件顶点变换的编程接口。1999年，GPU的概念就这样出现了。</p>
<p>​    GPU的推出，不仅仅是硬件体系的革命性变化，更是对显示标准的强大支持。今天3D引擎编程，核心主要也是面向GPU的编程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139564.png" alt="img"></p>
<p>​    后期ATI被AMD收购，纵然没有英伟达耀眼，但整体发展还算顺利，形成了A卡和N卡竞争的格局。</p>
<p>​    2020年，英伟达收购ARM，市值超过3300亿美元，超过INTEL 1000亿美元，成为全球市值排名TOP10。在西方的土地上，一个黄种人，一个台湾人，战功显赫。</p>
<h3 id="4-1-4、3DLabs"><a href="#4-1-4、3DLabs" class="headerlink" title="4.1.4、3DLabs"></a>4.1.4、3DLabs</h3><p>​    3D技术飞速发展，专业显卡需求增大。专业公司应运而生。3DLabs就是这样的公司，开发高端绘图芯片，对OpenGL的完美支持，性能强大，当时的OpenGL普通显卡难以完全支持。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139756.png" alt="img"></p>
<p>​    当年在专业显卡市场，3DLabs的产品几乎是唯一选择。面对瞬息万变的世界，3DLabs还是落后了，对D3D技术重视不足和对OpenGL过度依赖，最终被黄药师的Quadro干掉。于2002年被创新科技收购，成为旗下子公司。</p>
<p>​    对D3D的支持程度不仅仅影响民间显卡，对专业显卡也有很大的影响。显卡的发展不仅仅要考虑OpenGL，更要考虑D3D。D3D是微软的，操作系统是微软的，Windows垄断操作系统的存在，对D3D是一个强大的支持。公司决定软件，软件决定硬件又一次得到体现。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139865.png" alt="img"></p>
<h3 id="4-1-5、Video-Logic"><a href="#4-1-5、Video-Logic" class="headerlink" title="4.1.5、Video Logic"></a>4.1.5、Video Logic</h3><p>​    Video Logic前期主打产品是PowerVR，当年PowerVR也涉足桌面显卡市场，比较有名的就是PCX2芯片，性能强大，支持D3D、OpenGL，然而驱动程序兼容性较差，游戏运行有问题，对CPU要求较高，影响了销售。即使如此，在很长时间内，市场占有率一直保持第二。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139862.png" alt="img"></p>
<p>​    对图形图像引擎的支持、驱动的友好程度决定了硬件的发展。后期由于优化不好，兼容性问题、软件冲突等，容易引起渲染错误或性能下降。离不开最终被转卖的命运。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139912.png" alt="img"></p>
<p>​    相比太多厂商，PowerVR是幸运的，桌面市场失败了，但PowerVR睿智的转向了移动图形市场，避免了桌面市场的残酷竞争，发挥了自己的技术优势，移动端成为未来的趋势，PowerVR成为移动显示领域的重要力量。</p>
<p>​    PC端计算机图形学发展的同时，移动端技术的兴起，移动端细分专业显示芯片的出现，进而发展成为独立的领域，计算机图形学向精细化发展。</p>
<h3 id="4-1-6、intel"><a href="#4-1-6、intel" class="headerlink" title="4.1.6、intel"></a>4.1.6、intel</h3><p>​    英特尔是美国一家以研制CPU为主的公司，是全球最大的个人计算机零件和CPU制造商，成立于1968年，具有52年产品创新和市场领导的历史。</p>
<p>​    1971年，英特尔推出了全球第一个微处理器。微处理器所带来的计算机和互联网革命，改变了整个世界。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139935.png" alt="img"></p>
<p>​    2016年4月，英特尔推出处理器至强7290F采用了多达72个处理器核心，成为英特尔核心数最多的处理器。2019年2月，英特尔推出至强铂金9282，它有112个线程，是线程最多的处理器。</p>
<p>​    2020年7月，福布斯2020全球品牌价值100强发布，英特尔排名第12位。9月3日，英特尔推出了新的极简主义 Logo。</p>
<p>​    谈到显卡，不能回避intel，由于特殊的地位，相比其它厂商，在显卡的道路上，走的相对平稳与踏实。i740就是Intel推出的第一款产品，极大的推动了AGP标准的发展。</p>
<p>​    intel专注于集成显卡领域，从i740之后，再也没有推出过独立显卡，i740成了Intel独立显卡的绝唱。纵然在显卡领域没有大的建树，但intel一直在坚守。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139916.png" alt="img"></p>
<h3 id="4-1-7、AMD"><a href="#4-1-7、AMD" class="headerlink" title="4.1.7、AMD"></a>4.1.7、AMD</h3><p>​    AMD显卡即ATI(被AMD收购)显卡，俗称A卡。搭载AMD公司的显示芯片。与NVIDIA齐名，同为世界两大显示芯片厂商之一。由于收购关系，在本专题中，不做过多讲述。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139966.png" alt="img"></p>
<p>​    AMD是目前业内唯一一个可以提供高性能CPU、高性能独立显卡、主板芯片组三大组件的半导体公司，为明确其优势，提出3A平台新标志，在笔记本领域有“AMD VISION”标志的就表示该电脑采用3A构建方案。</p>
<p>​    今天显卡市场，是A卡与N卡的天下，19年第四季度，AMD出货量环比大增22.6%，份额19%，NVIDIA减少1.9%，份额18%，Intel微增0.2%，份额63%。由于计算将Intel核显、APU算在内，NVIDIA并无优势。</p>
<p>​    在独显方面，AMD出货量占比27%，较上季度的24%和去年的26%均有增加，但NVIDIA仍旧以73%垄断剩余市场。今年，Intel Xe架构独显将面世，对独显格局有一定冲击。</p>
<p>​    AMD显卡与NVIDIA显卡相比，有更高的功耗与更高的性能。AMD显卡的子品牌有 ATI 和 Radeon，显卡型号众多。今天，AMD(ATI)显卡技术坚挺，依然耀眼。</p>
<h2 id="4-2、软件与硬件"><a href="#4-2、软件与硬件" class="headerlink" title="4.2、软件与硬件"></a>4.2、软件与硬件</h2><h3 id="4-2-1、接口与硬件"><a href="#4-2-1、接口与硬件" class="headerlink" title="4.2.1、接口与硬件"></a>4.2.1、接口与硬件</h3><p>​    专业图形图像领域，Z缓存和双缓存称为了3D图形技术的标配。在今天的流行图形图像API里，当年的Z缓冲和双缓冲，仅仅是今天图形图像引擎的一个参数或者一个函数而已，参数和函数的背后，是硬件的支持。</p>
<p>​    显卡插口有PCI和AGP两种。在数据处理上，逐渐支持高速和并行。具有着更大的传输速率，更复杂数据的处理能力。硬件技术的变革推动了软件技术的进步。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139076.png" alt="img"></p>
<p>​    任何技术的发展都不是一帆风顺的，显示技术也不例外。每一次技术的革新，都可能带来革命性的变化。那些曾经被淘汰、被边缘化的技术，为主流技术的发展做了助攻。在显卡技术发展过程中，硬件的升级，架构的改变，都代表着功能的提升。</p>
<p>​    下图从另外一个角度，展现显卡发展的过程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139165.png" alt="img"></p>
<h3 id="4-2-2、3D引擎"><a href="#4-2-2、3D引擎" class="headerlink" title="4.2.2、3D引擎"></a>4.2.2、3D引擎</h3><p>​    遥想当年，视频编程主要靠专业引擎来体现，各家公司雄心勃勃，开宗立派，在数家公司的专业图形图像接口里，OpenGL和DirectX最终胜出。今天，消费级市场主要通过OpenGL和DirectX来体现。</p>
<p>​    可悲的是，早期在linux上很少有图形图像编程的处理。一直到今天，图形图像工作主要还是在Windows和Mac上进行。</p>
<p>​    时光的河流，流淌着一个真理，对3D的支持，以及对3D相关图形系统的支持，是硬件厂商存活的根本。这里的3D支持，就是3D引擎。</p>
<p>​    当年的图形图像编程，OpenGL刚刚起步，很多公司提供的应用引擎都是对OpenGL和D3D的封装。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139192.png" alt="img"></p>
<h4 id="4-2-2-1．OpenGL"><a href="#4-2-2-1．OpenGL" class="headerlink" title="4.2.2.1．OpenGL"></a>4.2.2.1．OpenGL</h4><p>​    OpenGL是渲染2D、3D数字图形的跨语言、跨平台的应用程序编程接口（API）。由近350个函数组成，绘制简单图形和复杂三维景象。OpenGL常用于CAD、虚拟现实、科学可视化和游戏开发等。OpenGL直接操纵图形硬件，高效进行图形图像编程，实现一般由显示设备厂商提供。OpenGL是对显卡编程的工业接口。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139175.png" alt="img"></p>
<p>​    OpenGL规范由1992年成立的OpenGL架构评审委员会（ARB）维护。ARB由业界顶级软硬件公司组成，下图是OpenGL的发展过程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139161.png" alt="img"></p>
<p>​    OpenGL API定义了若干被客户端程序调用的函数，以及一些整型常量。这些实现方便了开发者调用。</p>
<p>​    OpenGL与语言平台无关。规范没有获得和管理OpenGL上下文相关的内容，将这些细节交给底层窗口系统。OpenGL专注图像渲染，不提供输入、音频及窗口相关的API。</p>
<p>​    OpenGL不断进化API。新版规范定期由Khronos Group发布，新版本通过扩展API来支持各种新功能。每个版本细节由Khronos Group成员一致决定，包括显卡厂商、操作系统设计人员以及类似Mozilla和谷歌的技术性公司。</p>
<p>​    除了核心API功能，GPU供应商通过扩展的形式提供额外功能。扩展引入新功能和新常量，增加或取消现有OpenGL功能。</p>
<p>​    每个扩展与一个标识符联系，标识符基于开发公司的名称。例如，英伟达（nVidia）的标识符是NV。如果多个供应商同意使用相同的API来实现相同功能，那么就用EXT标志符。这种情况更进一步，Khronos Group的架构评审委员（Architecture Review Board，ARB）正式批准该扩展，那么就被称为一个“标准扩展”，标识符使用ARB。第一个ARB扩展是GL_ARB_multitexture。</p>
<p>​    OpenGL每个新版本中引入的功能，特别是ARB和EXT类型的扩展，通常由数个被广泛实现的扩展功能组合而成。</p>
<p>​    代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;GLTools。h&gt;             // OpenGL toolkit</span><br><span class="line">#include &lt;GLShaderManager。h&gt;    // Shader Manager Class</span><br><span class="line"></span><br><span class="line">GLBatch	triangleBatch;</span><br><span class="line">GLShaderManager	shaderManager;</span><br><span class="line"></span><br><span class="line">void ChangeSize(int w， int h);</span><br><span class="line">void SetupRC();</span><br><span class="line">void RenderScene(void);</span><br><span class="line">gltSetWorkingDirectory(argv[0]);</span><br><span class="line">glutInit(&amp;argc， argv);</span><br><span class="line">glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH | GLUT_STENCIL);</span><br><span class="line">glutInitWindowSize(800， 600);</span><br><span class="line">glutCreateWindow(&quot;Triangle&quot;);</span><br><span class="line">glutReshapeFunc(ChangeSize);</span><br><span class="line">glutDisplayFunc(RenderScene);</span><br><span class="line"></span><br><span class="line">SetupRC();</span><br><span class="line">glutMainLoop();</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-2、DirectX"><a href="#4-2-2-2、DirectX" class="headerlink" title="4.2.2.2、DirectX"></a>4.2.2.2、DirectX</h4><p>​    微软在业界的大哥地位，影响力不言而喻。在发展史上，多次和IBM对博公堂，微软宣布，凡是IBM的电脑，不能安装Windows操作系统。软件厂商要挟硬件厂商，在微软发展历史上，留下了光辉的一页。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139171.png" alt="img"></p>
<p>​    音视频是电脑最核心的功能之一，作为系统供应商，微软推出了自己的DirectX产品，该产品在1995年前后十几年间，决定了很多硬件厂商的生死。</p>
<p>​    示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#pragma comment(lib，&quot;d3d9.lib&quot;)</span><br><span class="line">#pragma comment(lib，&quot;d3dx9.lib&quot;)</span><br><span class="line">#include &lt;d3dx9。h&gt;</span><br><span class="line">LPDIRECT3D9 g_pD3D = NULL;</span><br><span class="line">LPDIRECT3DDEVICE9 g_pD3DDevice = NULL;</span><br><span class="line">LPDIRECT3DVERTEXBUFFER9 g_pVertexBuffer = NULL; </span><br><span class="line"></span><br><span class="line">HRESULT InitialiseD3D(HWND hWnd)</span><br><span class="line">HRESULT InitialiseVertexBuffer()</span><br><span class="line">void SetupRotation()</span><br><span class="line">void SetupCamera()</span><br><span class="line">void SetupPerspective()</span><br><span class="line">void Render()</span><br><span class="line">void CleanUp()</span><br></pre></td></tr></table></figure>

<p>​    当我们平心静气面对这些技术和代码时，深刻的感受到，尤其在早期，当年的D3D技术对显卡厂家的影响是可怕的，对D3D技术的支持程度代表了显卡的受欢迎程度。当年的D3D技术应用最主要是游戏领域。</p>
<p>​    从D3D的发展，得到岁月的启示，垄断阻碍了技术的发展，相信在某一天，D3D也终究会退出技术的舞台。</p>
<h3 id="4-2-3、Shader编程"><a href="#4-2-3、Shader编程" class="headerlink" title="4.2.3、Shader编程"></a>4.2.3、Shader编程</h3><p>​    Shader在3D编程里面占据着重要的地位，是OpenGL、DirectX、Unity等引擎中最核心的概念。成了3D图形图像编程的核心标配。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139313.png" alt="img"></p>
<p>​    示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#version 130</span><br><span class="line">in vec4 vVertex;</span><br><span class="line">in vec3 vNormal;</span><br><span class="line"></span><br><span class="line">uniform vec4    ambientColor;</span><br><span class="line">uniform vec4    diffuseColor;	</span><br><span class="line">uniform vec4    specularColor;</span><br><span class="line">uniform vec3	   vLightPosition;</span><br><span class="line">uniform mat4	   mvpMatrix;</span><br><span class="line">uniform mat4	   mvMatrix;</span><br><span class="line">uniform mat3	   normalMatrix;</span><br><span class="line">smooth out vec4 vVaryingColor;</span><br><span class="line"></span><br><span class="line">void main(void) </span><br><span class="line">&#123; </span><br><span class="line">    vec3 vEyeNormal = normalMatrix * vNormal;</span><br><span class="line">    vec4 vPosition4 = mvMatrix * vVertex;</span><br><span class="line">    vec3 vPosition3 = vPosition4。xyz / vPosition4。w;</span><br><span class="line">    vec3 vLightDir = normalize(vLightPosition - vPosition3);</span><br><span class="line">    float diff = max(0。0， dot(vEyeNormal， vLightDir));</span><br><span class="line">    vVaryingColor = diff * diffuseColor;</span><br><span class="line">    vVaryingColor += ambientColor;</span><br><span class="line">    vec3 vReflection = normalize(reflect(-vLightDir， vEyeNormal));</span><br><span class="line">    float spec = max(0。0， dot(vEyeNormal， vReflection));</span><br><span class="line">if(diff != 0) </span><br><span class="line">&#123;</span><br><span class="line">        float fSpec = pow(spec， 128。0);</span><br><span class="line">        vVaryingColor。rgb += vec3(fSpec， fSpec， fSpec);</span><br><span class="line">	&#125;</span><br><span class="line">    gl_Position = mvpMatrix * vVertex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-1、Metal"><a href="#4-2-2-1、Metal" class="headerlink" title="4.2.2.1、Metal"></a>4.2.2.1、Metal</h4><p>​    Metal是苹果公司的图形编程库，近两年取得了巨大的发展。在Mac平台和IOS平台音视频开发上，Metal是一个很好的选择。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139423.png" alt="img"></p>
<p>​    Metal提供对GPU的直接访问，技术人员最大程度地发挥 iOS、macOS和Apple tvOS app中的图形硬件计算潜能。Metal构建于易用的低开销架构之上，提供预编译的GPU 着色器和精细的资源控制。</p>
<p>​    Metal支持多线程，支持 GPU 驱动命令创建。支持GPU阵列编程，充分利用 Mac Pro 和 Pro Display XDR 的专业级多媒体功能。</p>
<p>​    渲染示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;Renderer.h&quot;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    float red, green , blue, alpha;</span><br><span class="line">&#125;Color;</span><br><span class="line"></span><br><span class="line">@implementation Renderer</span><br><span class="line">&#123;</span><br><span class="line">    id&lt;MTLDevice&gt; _device;</span><br><span class="line">    id&lt;MTLCommandQueue&gt; _commandQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//画view的内容，这个代理方法会按帧率执行</span><br><span class="line">-(void)drawInMTKView:(MTKView *)view&#123;</span><br><span class="line">    //获取颜色</span><br><span class="line">    Color color = [self makeFancyColor];</span><br><span class="line">    //设置背景色</span><br><span class="line">    view.clearColor = MTLClearColorMake(color.red, color.green, color.blue, color.alpha);</span><br><span class="line">    </span><br><span class="line">    //创建一个命令缓冲区</span><br><span class="line">    id&lt;MTLCommandBuffer&gt; commandBuffer = [_commandQueue commandBuffer];</span><br><span class="line">    commandBuffer.label = @&quot;mycommand&quot;;</span><br><span class="line">    </span><br><span class="line">    //渲染过程，用于保存渲染过程的结果</span><br><span class="line">    MTLRenderPassDescriptor *renderPassDescriptor = view.currentRenderPassDescriptor;</span><br><span class="line">    </span><br><span class="line">    if (renderPassDescriptor != nil) &#123;</span><br><span class="line">        id&lt;MTLRenderCommandEncoder&gt; renderEncoder = [commandBuffer renderCommandEncoderWithDescriptor:renderPassDescriptor];</span><br><span class="line">        renderEncoder.label = @&quot;myrenderEncoder&quot;;</span><br><span class="line">        </span><br><span class="line">        //结束编码</span><br><span class="line">        [renderEncoder endEncoding];</span><br><span class="line">        </span><br><span class="line">        //注册一个可绘制图像</span><br><span class="line">        [commandBuffer presentDrawable:view.currentDrawable];</span><br><span class="line">    &#125;</span><br><span class="line">    //提交命令到GPU</span><br><span class="line">    [commandBuffer commit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//视口发生变化会被调用</span><br><span class="line">- (void)mtkView:(nonnull MTKView *)view drawableSizeWillChange:(CGSize)size &#123;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-2、Vulkan"><a href="#4-2-2-2、Vulkan" class="headerlink" title="4.2.2.2、Vulkan"></a>4.2.2.2、Vulkan</h4><p>​    Vulkan是一个跨平台的2D和3D绘图应用程序接口（API），科纳斯组织（Khronos Group）在2015年游戏开发者大会（GDC）上发布。</p>
<p>​    Khronos Group目前是世界多媒体、音视频、图形图像领域的核心协会，拥有世界顶级会员单元，拥有世界级的技术标准。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139417.png" alt="img"></p>
<p>​    科纳斯把Vulkan API称为“下一代OpenGL行动”（next generation OpenGL initiative）或“glNext”。就像OpenGL，Vulkan针对实时3D程序（如电子游戏）设计，Vulkan并计划提供高性能和低CPU管理负担（overhead），这也是Direct3D12和AMD的Mantle的目标。Vulkan兼容Mantle的一个分支，并使用了Mantle的一些组件。</p>
<p>​    Vulkan 是 AMD Mantle 的后续版本，继承了强大的低开销架构，使软件开发能够全面获取 Radeo GPU 与多核 CPU 的性能、效率和功能。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139433.png" alt="img"></p>
<p>​    Vulkan 支持深入硬件底层的控制，为各种系统带来更快的性能和更高的影像质量。Vulkan API 还提供超高的 OS 兼容性、渲染特性和硬件效率。</p>
<p>​    基于GCN架构的Radeon 显卡拥有强大的“异步计算”功能，使显卡并行处理3D几何图形与计算工作量。当游戏需要同时计算复杂照明与渲染人物时，这种功能就找到了用武之地。这些任务并不需要在Radeon显卡上串行运行，节约时间、提升整体帧速率。Vulkan在近期Windows和Linux系统上都有很好的应用。</p>
<p>​    目前，Vulkan得到广泛的的支持，在硬件上，无论是服务器、桌面、移动端，都进行了完好的支持。在系统层面上，Linux、Windows、Mac、Android、IOS都为Vulkan提供了完备的接口。</p>
<p>​    示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vulkan/vulkan.h&gt;</span><br><span class="line">#include &lt;stdexcept&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">class HelloTriangleApplication </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void run() </span><br><span class="line">&#123;</span><br><span class="line">        initVulkan();</span><br><span class="line">        mainLoop();</span><br><span class="line">        cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">void initVulkan() &#123;&#125;</span><br><span class="line">void mainLoop() &#123;&#125;</span><br><span class="line">void cleanup() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    HelloTriangleApplication app;</span><br><span class="line">try </span><br><span class="line">&#123;</span><br><span class="line">        app.run();</span><br><span class="line">&#125;</span><br><span class="line">catch (const std::runtime_error&amp; e) </span><br><span class="line">&#123;</span><br><span class="line">        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;</span><br><span class="line">        return EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3、启示"><a href="#4-3、启示" class="headerlink" title="4.3、启示"></a>4.3、启示</h2><p>​    计算机图形学的发展不是一蹴而就的，前期发展过程中，百花齐放，百家争鸣。各家接口不一，处于蓬勃不稳定发展期，系统厂商、硬件厂商、软件厂商、行业协会一起，共同推出软硬件规范，OpenGL就是一个成功的表现。</p>
<p>​    技术发展过程中，一些厂商没有明确的规范或没有明确的支持规范，进而失败了。没有硬件厂商支持的规范同样是可悲的，很快被淘汰了。软件运行在硬件之上，硬件在一定程度上决定着软件。软件反过来影响着硬件。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192139426.png" alt="img"></p>
<p>​    3D时代绚丽多彩，现实生活姹紫嫣红，多年技术积淀，在3D时代五彩斑斓，应用辈出。显示技术的应用发挥到了极致，对计算技术的发展做出了卓越的贡献。</p>
<p>​    3D时代的到来，为显示技术的精细化发展吹响了号角。在计算机图形图像技术发展史上，承前启后，继往开来。</p>
<h1 id="5、移动时代"><a href="#5、移动时代" class="headerlink" title="5、移动时代"></a>5、移动时代</h1><p>​    移动时代可以追踪到很远，从古老的电台到1948年贝尔实验室的Bell boy，到1956年摩托罗拉的BP机。寻呼机的发展历史，主要是通讯技术的进步。和主题有一定偏差，不做阐述。翻开半个多世纪的画卷，历史没有想到的是，通讯技术在今天有如此傲娇的成绩。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146034.png" alt="img"></p>
<p>​    早期电脑至上，后来移动至上。不可怀疑的是，移动互联网高速发展的今天，手机成为应用系统最重要的终端。</p>
<p>​    移动端图形系统的研究，是移动应用终端开发的重中之重，也是手机底层技术的核心要素。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146054.png" alt="img"></p>
<p>​    本篇从手机发展史起笔，到移动显示芯片厂家、移动芯片技术与流行图形库讲述，希望给移动端音视频开发带来有益的启示。</p>
<h2 id="5-1、手机时代"><a href="#5-1、手机时代" class="headerlink" title="5.1、手机时代"></a>5.1、手机时代</h2><p>​    那年的“hello moto”，能否勾起你绵绵的情思。这颗圆圆的行星，”hello moto”之声奏响了银河系无线通讯的号角。那个年代手提电话(也叫移动电话)，还不叫手机，绰号大哥大，也叫板砖。当年的大哥大仅仅局限通话，短信功能也不具备。有了大哥大，不学数理化，大哥大成为了身份的象征。</p>
<p>​    硬件技术的进步，手机向小型化发展。两个企业的高光时刻带来了，当年的摩托罗拉和诺基亚堪称业界大哥，赚钱赚到罗马。从早期的单色屏逐渐发展到彩色屏。从1990年到2005年，那是诺基亚和摩托罗拉的时代。昨日年少英雄，指点江山，今天英雄白发，美人谢幕。互联网给我们多少唏嘘。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146040.png" alt="img"></p>
<p>​    工艺的提升不仅推动硬件设计的进步，更推动软件系统的发展，手机应该拥有更强大的功能。在这一大环境下，SmartPhone、Symbian、Linux手机操作系统不断涌现，为智能手机系统发展发起了前期的火力侦察。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146031.png" alt="img"></p>
<p>​    乔布斯担负着上帝赋予的伟大使命，2007年，Iphone诞生了。伴随着Iphone的诞生，Android的出现，智能时代到来了。完成了伟大使命的乔帮主，这位天选之子，4年之后，撒手人寰，魂归天堂。而他，留下了这颗行星上市值最高的公司。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146048.png" alt="img"></p>
<p>​    智能手机的兴起，促进移动端硬件提升，显示技术也有很大变化。移动时代硬件发展同样精彩,充满了竞争与杀戮，野蛮和邪恶，和PC端同样精彩。软件方面相对平滑平淡，没有大的开开合合。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146075.png" alt="img"></p>
<p>​    手机的发展史，也是一部无线技术的发展史。硬件技术与通讯规范密切相关，翻开移动通讯的日记，从1G到5G，感时光如梭，叹技术神速。通讯技术规范不属于本主题内容，不做阐述。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146307.png" alt="img"></p>
<p>​    移动时代芯片科技，看到了中国企业的影子，东方用资本开始了买买买的过程。对芯片技术的渴求，资本是最直接的倾诉。期望不远的未来，有一家拥有核心技术的东方芯片厂商。在技术的长河中，书写浓重的一笔。在芯片的交响乐中，奏出中国的声音。</p>
<p>​    波澜壮阔的手机应用，后台是芯片技术的驱动。下一节，我们从芯片的角度回顾。</p>
<h2 id="5-2、移动端主流显示芯片"><a href="#5-2、移动端主流显示芯片" class="headerlink" title="5.2、移动端主流显示芯片"></a>5.2、移动端主流显示芯片</h2><h3 id="5-2-1、ARM"><a href="#5-2-1、ARM" class="headerlink" title="5.2.1、ARM"></a>5.2.1、ARM</h3><p>​    ARM不仅进行嵌入式CPU架构授权，也进行GPU架构授权。在芯片架构设计上，ARM稳坐头把交椅。2006年，ARM 完成对挪威Falanx公司的收购，获得其移动GPU技术，完成对原有IP技术的扩展。也就是从那个年代开始，ARM闪亮登场。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146341.png" alt="img"></p>
<p>​    ARM是有先见之明的，15年后，GPU广泛用于智能手机、DTV和平板电脑等多种设备。15年时间，ARM Mali技术成为全球出货量第一的GPU，预计2020年总计出货量就超过15亿。在移动图形硬件发展史上，ARM mail是必谈的技术。</p>
<p>​    Mali GPU架构发展了3代，Utgard、Midgard和Bifrost。Utgard的代表是Mali-400 MP，三星的Exynos4412用的就是这款GPU，Mali-450至今的一些电视芯片还在使用（例如小米电视）。Midgard的型号是Mali-T系列，联发科Helio X20就用的是Mali-T880，而Bifrost的型号是Mali-G系列。</p>
<p>​    ARM的Mali可以说是ARM CPU的“黄金搭档”，架构上不是最先进，普及率非常高，低廉的授权费是芯片厂商比较喜欢的。ARM科技与方案的授权，保证了技术纯粹，降低了经营风险。</p>
<p>​    Mali是一款高端GPU，将图形IP视觉娱乐变为现实，市场占安卓智能手机30%以上，可与PowerVR SGX系列GPU对比。</p>
<p>​    应用基于ARM体系结构的移动设备上，得益于CPU占有率发展迅猛。ARM® Mali™ 系列 GPU 为所有嵌入式图形 IP 和视频 IP 提供完善的解决方案，使设备制造商和内容开发商能够为最广泛的消费类设备（手机、游戏机、智能本、HDTV）提供最高质量的尖端多媒体解决方案。GPU是近些年硬件最重要的应用之一，当年ARM收购Falanx简直是神来之笔，为ARM的做大做强埋下了伏笔。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146348.png" alt="img"></p>
<p>​    Mali 嵌入式图形 IP 设计用于提高能源效率和解决性能问题，包括世界上最小的 GPU、完整多核可扩展性（最高可达 1080p）、用于可视计算的 GPU 的通用计算 (GPGPU) 以及多用途应用程序。所有 Mali GPU 都受预先集成的 Mali 图形驱动程序软件支持。</p>
<p>​    灵活性是要考虑的一个重要因素，支持的业界标准开放式 API 包括OpenVG、OpenGL ES、OpenCL以及DirectX®。这些是ARM成功的基础。</p>
<p>​    ARM在芯片架构设计上，有多见的经验积累。高通在通讯领域里，有最好的技术产品。</p>
<h3 id="5-2-2、Qualcomm"><a href="#5-2-2、Qualcomm" class="headerlink" title="5.2.2、Qualcomm"></a>5.2.2、Qualcomm</h3><p>​    高通（Qualcomm）的英文是Quality Communications，翻译就是高质量通信。创始人雅各布斯是搞通信工程搞到卫星领域的男人，高通今天“连接万物”的使命从创立那天就奠定了。这是一家超强的公司，其技术延续性与强大性首屈一指。在这个年代的人，都用过高通的产品或者技术。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146324.png" alt="img"></p>
<p>​    1985年成立的公司，在1989开始推广CDMA。业界的注意力都在TDMA技术上（后来演变成GSM），高通靠着自己的实验和测试，让CDMA在1993年成为行业标准并和GSM分庭抗礼，这就是高通的水平。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146383.png" alt="img"></p>
<p>​    高通研发投入占比常年在收入的20%以上。前30年，高通累计投入了超过440亿美元的研发经费，获得了超过13万项全球专利。</p>
<p>​    2007年，那一年发生了两件改变世界的事情：乔布斯发布iPhone，高通推出了骁龙芯片Snapdragon S1。</p>
<p>​    13年间，高通在移动SoC领域打赢过两次重大战役，第一次让德州仪器、英伟达这些业界大厂退出了移动高端市场。第二次则是让联发科败走中高端。中途还插播过英特尔靠着Atom+补贴，打了几年酱油的历史。这些恐怖成绩的存在，是高通对硬件技术的不懈追求。</p>
<p>​    时间线调回2007年，从那时开始，高通每年的SoC，都会带着新的制程、新的CPU、GPU和调制解调器亮相。高通在调制解调器上的优势，犹如不可逾越的鸿沟，把其它大厂排挤在千里之外。高通把调制解调器分为两种，一种骁龙，一种其它。</p>
<p>​    2007年安卓和Windows Mobile的蛮荒时代，高通MSM7225&#x2F;7625这些上古的SoC连GPU都已经支持3G了，比国内称为3G元年的2009年还早了整整2年。作为移动技术的顶级元老，这个不让人意外。</p>
<p>​    移动GPU，特别是Adreno系列，在近10几年一直维持着远超摩尔定律的性能增速。这个故事出现得最密集的词，就是“暴涨”二字。在众多公司中，高通像一个工程师一样，坚守硬件设计的阵地。</p>
<p>​    2009年，MSM7227（隶属骁龙S1）搭载的Adreno 200，其浮点性能是2.1GFLOPS。而2012年初的Adreno 225上，浮点性能已经暴涨了10数倍，达到25 GFLOPS。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146377.png" alt="img"></p>
<p>​    手机GPU和电脑有一定的区别，手机GPU是整合到SoC内的，电脑可以有独立显卡。高通的adreno的技术部分源自高通从AMD收购的移动GPU部门。</p>
<p>​    高通的GPU市场占有率很高，adreno的表现也足够优秀，支持足够多的新特性，性能比较强，功耗表现也很理想。</p>
<p>​    如果说2015年之前，其他厂商的GPU还算和高通追得很紧的话，那在骁龙820&#x2F;821的Adreno 530开始，高通就进入了无人之境。或是从绝对性能，或是从能耗比上，拉开了和苹果、三星、海思、联发科的差距。现在唯一能在GPU性能上跟着高通的，就只剩苹果了。但同代产品上，高通总是能在能耗比上压苹果一头。</p>
<p>​    让人疯狂的是，除了能耗比其它公司占优之外，高通的Adreno几乎常年都是用着同代面积最小的GPU芯片面积。三星Exynos 9810上的GPU面积达到了25 mm2，Kirin 970上也有18 mm2，但高通硬生生只用了10 mm2出头的芯片面积，做到了更强的性能更低的能耗。</p>
<p>​    高通在嵌入式技术上的能力是有目共睹的，嵌入式硬件对移动端提供了核心的支持。在图形图像视频硬件技术上，高通道高一丈。、</p>
<p>​    在互联网众多科技公司中，高通算是厚积薄发。在企业发展上，稳健踏实，在芯片领域具有举足轻重的地位。在互联网、人工智能高速发展的今天，高通的硬实力展现出来。</p>
<p>​    苹果感谢高通，高通的存在，阻击了一线科技公司对苹果的围剿。在技术大潮中，高通不断为苹果输送技术的血液，成就了苹果的万亿帝国。</p>
<h3 id="5-2-3、Apple"><a href="#5-2-3、Apple" class="headerlink" title="5.2.3、Apple"></a>5.2.3、Apple</h3><p>​    2006年到2013年，AMD和NVIDIA在移动市场竞争中完全失策。丢掉全球移动GPU主要供应商的同时，苹果一步步取代他们并成为最强大、最主流的GPU处理器的生产者。AMD和NVIDIA重蹈Intel的覆辙，丢掉移动GPU市场。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146543.png" alt="img"></p>
<p>​    当年Intel未能预料iPhone的潜力，忽视了移动市场。让ARM从一家基础移动处理器生产商一跃成为智能手机和平板处理器的主要生产商，而移动GPU的发展也十分相似。历史不断的给苹果机会，并给与其把握机会的能力。</p>
<p>​    iOS符合用户知觉，视觉美观，图形环境(归功于GPU加速)，这是iPhone销量居高不下的因素。Google完全没有意识到iPhone成功的关键。</p>
<p>​    iPhone对GPU的重视，让iPhone适合游戏。从一开始，游戏是苹果应用商店里的主角，改变了大众对苹果“没有游戏”的印象。iPhone、iPod touch还有2010年的iPad，均作为独立的移动游戏设备颠覆了游戏市场。</p>
<p>​    苹果推出了新的API：Metal。很多优秀的开发者都利用了这套新的API开发新应用。Metal可以让游戏和其他需要图形性能的应用绕过OpenGL，利用苹果64位处理器的强大GPU。苹果在图形处理速度上有很大优势，在移动游戏方面尤其明显；而Metal则让优势进一步增加。</p>
<p>​    苹果把Imagination的人挖了之后自研了GPU，然后把这帮人解散了。这件事情告诉我们，苹果是靠不住的，不知道哪天又会卸磨杀驴。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146606.png" alt="img"></p>
<p>​    近些年苹果GPU走向自研道路。未来谁掌握了最强的手机图形性能，谁就可以在市场上获得更大主动权，苹果深谙此道。在进行技术拓展的同时，进一步巩固A系列芯片的性能优势。</p>
<p>​    A11尽管采用的是和骁龙835一样的10nm工艺，整体性能仍然强于骁龙835。GPU相比A10提升了30%，三核心设计，并对沉浸式 3D 游戏和 AR 增强现实进行了优化。这是苹果第一代自研GPU，苹果真正能把自己的GPU完善起来还需要1-2年时间。那时A系列GPU和CPU融合的会更加紧密，在性能和能耗上会有更大的突破。</p>
<p>​    发展的关键时刻，上帝偏爱苹果。面临技术抉择时，苹果往往押宝成功。看似孤傲独行，重大战役到来时，总有友军出现。这些因素的综合，使苹果稳坐科技公司第一宝座。</p>
<h3 id="5-2-4、Imagination-Technologies"><a href="#5-2-4、Imagination-Technologies" class="headerlink" title="5.2.4、Imagination Technologies"></a>5.2.4、Imagination Technologies</h3><p>​    Imagination Technologies前身是video logic公司。曾经的全球移动 GPU IP龙头，深耕GPU 内核研发和设计，曾是苹果御用图形技术提供商，总部位于英国。2018年被中资背景企业收购，未来发展不明。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146692.png" alt="img"></p>
<p>​    Imagination Technologies的核心产品是IMG A系列产品，被设计为可应用于各种场景的GPU，支持自动驾驶、AIoT、数字电视、机顶盒、移动设备等智能应用。</p>
<p>​    IMG A系列在多个市场中授权客户，这点和ARM相像。首批搭载该IP的SoC器件在2020年供货。Imagination Technologies宣布，紫光已获得最新一代神经网络加速器（NNA）PowerVR Series3NX半导体IP授权许可，是面向中高端移动设备市场的系统级芯片。</p>
<p>​    散热条件限制，大多数移动GPU很难提供持续一致的游戏体验，芯片发热其性能下降到不可接受的水平。IMG A系列则以一致的帧速提供持续可靠的性能以及更长游戏时间，避免了因芯片过热导致时钟降频甚至故障等过热情况，IMG A系列有一定的技术优势。</p>
<p>​    IMG A系列采用Imagination的HyperLane技术，独立的硬件控制通道被隔离在内存中，将不同的任务同时提交给GPU，实现GPU多任务处理。</p>
<p>​    通过AI Synergy，GPU在可以提供图形处理功能的同时，使用备用资源支持可编程AI以及固定功能，即高度优化的Imagination神经网络加速器。AI Synergy在最小的芯片面积中提供可编程的人工智能，统一的软件栈可实现灵活出色的性能。</p>
<p>​    PowerVR曾经是苹果“御用”的GPU，性能表现强大、架构先进，不仅在iOS领域，在安卓领域使用也很广泛。当年的一代神U联发科MT6577就使用了大幅度超频的SGX531，性能是低端机里的翘楚。</p>
<p>​    但是，因为较高的授权费用，PVR逐渐失去了安卓市场，客户纷纷转向更廉价的ARM Mali。虽然有联发科Helio X30等的支持，PVR仍然是强弩之末。再加上苹果的抛弃（苹果宣布自研GPU）和挖墙脚，等待Imagination的只有卖身的悲惨命运。</p>
<p>​    GPU技术的选择，是很多芯片公司做强做大的基础。尤其是智能时代的带来，GPU的应用汹涌澎湃，风卷云涌。</p>
<h3 id="5-2-5、Vivante"><a href="#5-2-5、Vivante" class="headerlink" title="5.2.5、Vivante"></a>5.2.5、Vivante</h3><p>​    Vivante(图芯)曾经是嵌入式图形处理器（GPU）的技术先行者。总部位于加州，为全球移动设备和家庭娱乐市场提供顶级应用，超级处理器解决方案。曾经拥有种类繁多的2D&#x2F;3D图形处理器。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146625.png" alt="img"></p>
<p>​    用硅印模，为业界标准应用程序接口提供强大支持。图芯芯片技术将桌面质量图象和性能带入汽车、手掌中的屏幕。优秀可升级的嵌入式解决方案是可升级的，建立在业界标准之上，且优化功耗、性能和大小。</p>
<p>​    图芯不断增长的产品系列，与全球多家公司成功合作。对移动视觉逼真和高清视觉逼真的核心技术，成为当年顶级移动端图形图像技术供应商。</p>
<p>​    2016年01月08日，图芯被中国芯原收购，产品开始沉默。对OpenGL ES、OpenVG、DirectX的成功支持，是图芯前期成功的核心要素。</p>
<h3 id="5-2-6、NVIDIA、AMD、Intel"><a href="#5-2-6、NVIDIA、AMD、Intel" class="headerlink" title="5.2.6、NVIDIA、AMD、Intel"></a>5.2.6、NVIDIA、AMD、Intel</h3><p>​    移动端图形技术的快速发展，加速了移动时代的到来。当年PC端显示技术的大佬们，变得孤单与寂寞，这能告诉我们什么呢？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146638.png" alt="img"></p>
<p>​    手机gpu不能单卖，需要可用的基带，NVIDIA并没有基带。在不需要基带的移动gpu上，NVIDIA做的很好，例如switch gpu。</p>
<p>​    英伟达开发过手机芯片——Tegra系列，现在Tegra已经谢幕，当年使用Tegra芯片手机风行一时。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146708.png" alt="img"></p>
<p>​    英伟达在Tegra4及之前的GPU架构叫GeForce ULP，Tegra4号称“72核GPU”，但架构十分老旧，是DX9时代的分离渲染架构。Tegra因为基带芯片问题退出手机市场，后来推出了Tegra K1用上先进的Kepler架构，但是一切都太晚了。</p>
<p>​    NVIDIA现在和可预见的将来都没有手机产品，这是NVIDIA不能接受的。期望有一天，在移动端显示芯片上，上演王者归来。AMD不仅缺少移动GPU，还几乎没有市场份额。Intel在补贴硬件厂商让它们使用Intel产品(造成了每年400亿美元的损失)。</p>
<p>​    世界上影响力最大的两个GPU厂家，AMD和NVIDIA。两个微处理器的发明者Intel和德州仪器，几乎全都被苹果逐出了移动市场。现在市场中只有低端零件厂商、苹果高端、高销量的iOS设备竞争。这令人感叹，苹果跳出了时代的局限性，在桌面端和移动端成为最成功的企业，上帝太偏爱苹果了。</p>
<p>​    当年Nvidia买了Icera，i500之后，折腾SoC，没有下文。15年宣告放弃，现在想用只能外挂基带。黄药师仰天长啸，移动端报国无门。</p>
<p>​    外挂是可以的，DrivePX2上接GPU用PCIE 4x，然后GPU有自己显存，这个不是手机能接受的。如果用CCI，访问内存没有问题，但有其它局限性。Tegra X1后黄总就不用CCI互联了。</p>
<p>​    AMD、INTEL和英伟达道路相似，3D时代雄起，移动时代沉寂，智能时代奋起。每一家公司都有各自的领地。那些成功的跨界，成就了技术的艳遇。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146815.png" alt="img"></p>
<p>​    就工艺而言，相对于CPU，GPU技术难度低一些。这也是众多小厂开始向GPU迈进的原因。在移动时代，科技的发展创造机会，很多传统的CPU、GPU大厂由于固守轨道，错过了GPU发展的黄金时代。</p>
<h2 id="5-3、移动图形库"><a href="#5-3、移动图形库" class="headerlink" title="5.3、移动图形库"></a>5.3、移动图形库</h2><p>​    移动手机图形接口上，没有桌面端的万马奔腾、百舸争流，整体相对平稳与自然。无论Android还是IOS，都是Linux的内核。所以在移动图形库的选型与发展上，和桌面端图形库有一个很好的承接。OpenGL桌面端不可撼动的地位，移动端，OpenGL的简化版OpenGL ES应运而生。</p>
<h3 id="5-3-1、OpenGL-ES"><a href="#5-3-1、OpenGL-ES" class="headerlink" title="5.3.1、OpenGL ES"></a>5.3.1、OpenGL ES</h3><p>​    OpenGL ES 是 OpenGL三维图形 API 的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146838.png" alt="img"></p>
<p>​    OpenGL ES 是 OpenGL 裁剪定制而来，去除了复杂图元等非绝对必要的特性。OpenGL ES 2.0 参照 OpenGL 2.0 规范定义。</p>
<p>​    OpenGL ES 免授权并且跨平台，强大的2D和3D图形应用程序接口API，针对多种嵌入式系统专门设计，包括控制台、移动电话、手持设备、家电设备和汽车。由精心定义的桌面OpenGL子集组成，实现了软件与图形加速间灵活强大的底层交互接口。</p>
<h4 id="5-3-1-1、OpenGL-ES-版本与功能"><a href="#5-3-1-1、OpenGL-ES-版本与功能" class="headerlink" title="5.3.1.1、OpenGL ES 版本与功能"></a>5.3.1.1、OpenGL ES 版本与功能</h4><p>​    OpenGL ES包含浮点运算和顶点运算，及EGL便携设备的本地视窗系统规范。</p>
<p>​    OpenGL ES 1.X 面向功能固定的硬件所设计，并提供加速支持、图形质量及性能标准，也就是固定管线编程。OpenGL ES 2.X 提供包括遮盖器技术在内的全可编程3D图形算法。OpenGL ES 3.x则在可编程管线上进行了增强。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146870.png" alt="img"></p>
<p>​    OpenGL ES提高了不同消费电子设备的3D图形渲染速度，在嵌入式系统上实现了全面可编程的3D图形。</p>
<p>​    OpenGL ES工作组在六个月内更新OpenGL ES采纳者项目，提供兼容性测试，并提供相关源代码。目前 Corporation、Imagination、NVIDIA、高通、ZiiLABS等都表达了对OpenGL ES 3.0的大力支持。最新GPU就支持OpenGL ES 3.0。</p>
<h4 id="5-3-1-2、OpenGL-ES-3-0新功能"><a href="#5-3-1-2、OpenGL-ES-3-0新功能" class="headerlink" title="5.3.1.2、OpenGL ES 3.0新功能"></a>5.3.1.2、OpenGL ES 3.0新功能</h4><p>​    1、渲染管线多重增强，实现先进视觉效果的加速，包括遮挡查询(Occlusion Query)、变缓反馈(Transform Feedback)、实例渲染(Instanced Rendering)、更多渲染目标支持。</p>
<p>​    2、高质量ETC2&#x2F;EAC纹理压缩格式成为一项标准功能，不同平台上不再需要不同的纹理集。</p>
<p>​    3、新版GLSL ES 3.0着色语言，全面支持整数和32位浮点操作。</p>
<p>​    4、纹理功能增强，支持浮点纹理、3D纹理、深度纹理、顶点纹理、NPOT纹理、R&#x2F;RG单双通道纹理、不可变纹理、2D阵列纹理、无二次幂限制纹理、阴影对比、调配(swizzle)、LOD与mip level clamps、无缝立方体贴图、采样对象、纹理MSAA抗锯齿渲染器。</p>
<p>​    5、更多精确尺寸纹理和渲染缓冲格式，便携移动应用更简单。</p>
<h4 id="5-3-1-3、OpenGL-ES-示例代码"><a href="#5-3-1-3、OpenGL-ES-示例代码" class="headerlink" title="5.3.1.3、OpenGL ES 示例代码"></a>5.3.1.3、OpenGL ES 示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">       private final int CONTEXT_CLIENT_VERSION = 3;</span><br><span class="line">       private GLSurfaceView mGLSurfaceView;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">              super.onCreate(savedInstanceState);</span><br><span class="line">              mGLSurfaceView = new GLSurfaceView(this);</span><br><span class="line">              if (detectOpenGLES30()) &#123;</span><br><span class="line">              mGLSurfaceView.setEGLContextClientVersion(CONTEXT_CLIENT_VERSION);</span><br><span class="line">                     mGLSurfaceView.setRenderer(new RendererJNI(this));</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                     Log.e(&quot;opengles30&quot;, &quot;OpenGL ES 3.0 not supported on device.  Exiting...&quot;);</span><br><span class="line">                     finish();</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              setContentView(mGLSurfaceView);</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       protected void onResume() &#123;</span><br><span class="line">              super.onResume();</span><br><span class="line">              mGLSurfaceView.onResume();</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line">       @Override</span><br><span class="line">       protected void onPause() &#123;</span><br><span class="line">              super.onPause();</span><br><span class="line">              mGLSurfaceView.onPause();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       private boolean detectOpenGLES30() &#123;</span><br><span class="line">              ActivityManager am = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">              ConfigurationInfo info = am.getDeviceConfigurationInfo();        </span><br><span class="line">              return (info.reqGlEsVersion &gt;= 0x30000);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-2、其它"><a href="#5-3-2、其它" class="headerlink" title="5.3.2、其它"></a>5.3.2、其它</h3><p>​    Vulkan和Metal不仅是3D时代的图形框架，也是移动领域的核心图形图像框架。关于Metal和Vulkan的知识，参考前面主题。</p>
<h2 id="5-4、启示"><a href="#5-4、启示" class="headerlink" title="5.4、启示"></a>5.4、启示</h2><p>​    梳理这段历史时，我们发现，信息科技的核心是芯片，芯片技术被国外巨头垄断。偶尔有中资公司的影子，大多昙花一现。芯片技术是百年大计，很难实现弯道超车。</p>
<p>​    在计算科技白皮书里，大多是欧美科技的影子，东方公司比重较低。这注定了科技赶超是一个长期的过程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146955.png" alt="img"></p>
<p>​    在软件规范制定上，面临同样的情况。未来几十年，在软件规范上，我们埋头苦干，奋勇向前。</p>
<p>​    通讯核心技术上，依然有很大不足。但在市场应用上，我们拔得头筹。在移动商务、移动支付、短视频应用上，捷报频传。</p>
<p>​    美摄科技坚持音视频核心技术研究，底层硬件技术研发。在技术接口，产业应用上乘风破浪，激流勇进。在祖国图形图像技术建设上，做出应有的贡献。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146972.png" alt="img"></p>
<p>​    缘聚缘散，时空变换。1978年之后，科技的春天再次到来了。从基础芯片，软件规范，到行业应用。我们流年笑掷，坚信未来可期。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192146007.png" alt="img"></p>
<h1 id="6-人工智能时代"><a href="#6-人工智能时代" class="headerlink" title="6 人工智能时代"></a>6 人工智能时代</h1><h2 id="6-1、人工智能发展历史"><a href="#6-1、人工智能发展历史" class="headerlink" title="6.1、人工智能发展历史"></a>6.1、人工智能发展历史</h2><p>​    人工智能是科技永久的话题，计算机本身是一个工具，人工智能发展史上，计算机的出现，是人工智能发展的伟大节点。21世纪仅仅是人工智能的开端，人工智能的发展方兴未艾。</p>
<p>​    早期的人工智能偏重于理论，西方的神学大师、哲学先驱、数学巨匠一起，为人工智能奠定了文化基础，下面我们开始与大师的对话。</p>
<h3 id="6-1-1、大事记"><a href="#6-1-1、大事记" class="headerlink" title="6.1.1、大事记"></a>6.1.1、大事记</h3><p>​    200年前，巴贝奇，一个英国数学家，设计了第一台计算二次多项式的计算机器，叫做差分机，摇动手柄，计算出x*x+a式子的值。当时的东方，大清皇朝，即将面临血色的辉煌。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144726.png" alt="img"></p>
<p>​    1956年，几个科学家，聚会在美国汉诺思小镇宁静的达特茅斯学院，利用暑假的两个月进行封闭式的讨论研究，主题是“达特茅斯夏季人工智能研究计划”。首次提出“人工智能（Artificial Intelligence，简称AI）”这一概念，人工智能学科应运而生了。当年简单的两个单词，成为今天科技的主旋律。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144719.png" alt="img"></p>
<p>​    1959年，塞缪尔讲到，计算机可以比人更好地编程，进行国际象棋游戏时，创造了“机器学习”(Machine Learning)一词。上承接人工智能，下承接自然语言与机器视觉。编程邂逅人工智能，人工智能青梅竹马的年代开始了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144994.png" alt="img"></p>
<p>​    1965年，Joseph Weizenbaum，开发ELIZA，一个交互式计算机程序，用英语与人交谈。Weizenbaum有一个目标，证明人工智能思维与人类思维之间的沟通是肤浅的。这是第一个通过图灵测试的软件程序，“对话就是模式匹配”，代表着自然语言技术的开端。60年后的今天，自然语言技术应用广泛。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144980.png" alt="img"></p>
<p>​    1978年，卡耐基梅隆大学，开发自动选配计算机配件的程序XCON，1980年投入工厂使用，包含2500条规则，后续几年处理了超过80000条订单，准确度超过95%，每年节省超过2500万美元。这是早期的专家系统，开始于生产应用。我们今天进行自动购物时，很少有人知道半个世纪以前，在大洋彼岸已被广泛应用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144020.png" alt="img"></p>
<p>​    1979年，斯坦福大学，制造了无人驾驶车Stanford Cart，这是汽车的第一次，依靠视觉感应器，在没有人工干预的情况下，自主穿过散乱扔着椅子的房间，需要几个小时才能完成。当年的视觉感应器，就是今天的机器视觉，当年的无人工干预，就是今天的自动驾驶。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144044.png" alt="img"></p>
<p>​    1982年，英国科学家霍普菲尔德几乎同时与杰弗里·辛顿，发现了具有学习能力的神经网络算法，沉寂10年之后，神经网络有了新的进展。从此神经网络高速发展，90年代开始商业化，用于文字图像识别和语音识别。今天的神经网络工程师们，鲜有人知道这两位大师的名字。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144071.png" alt="img"></p>
<p>​    1986年，梅赛德斯 - 奔驰，Ernst Dickmanns的指导下建造并发布了一辆配备摄像头和传感器的无人驾驶厢式货车。能够在没有人类驾驶员的道路上行驶高达55英里&#x2F;小时。当年的神奇幻想，今天的美好现实。Ernst Dickmanns，成为了自动驾驶的鼻祖，当年的奔驰货车，也称了自动驾驶的先驱。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144102.png" alt="img"></p>
<p>​    1998年，Dave Hampton和Caleb Chung。发明了Furby，第一款玩具机器人。2000年前后，日本科技公司凭借着较好的工业基础，在早期智能时代占据着不可或缺的位置。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144234.png" alt="img"></p>
<p>​    1999年，索尼。推出AIBO，价值2000美元的机器人宠物狗，与环境，所有者和其它AIBO的互动来“学习”。功能包括能解和响应100多个语音命令并与人类所有者进行对话。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144268.png" alt="img"></p>
<p>​    2002年，Roomba，自动机器人真空吸尘器，避开障碍物进行清洁。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144255.png" alt="img"></p>
<p>​    2006年，杰弗里辛顿。出版《Learning Multiple Layers of Representation》，奠定神经网络的全新架构，今天人工智能的核心技术。短短10年间，数学冰山背后，春风化雨，夏露凝香。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144331.png" alt="img"></p>
<p>​    2007年，Fei Fei Li。出生于北京，美国国家工程院院士，Twitter独立董事。组建ImageNet，一个注释图像数据库，帮助物体识别。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144320.png" alt="img"></p>
<p>​    2009年，吴恩达，使用图形处理器（GPU而不是CPU）进行大规模无监督式机器学习。取得了惊人的成就，向世人展示了一个超强的神经网络，它在自主观看千万张图片之后，识别小猫的图像。这是历史上在没有人工干预下，自主强化学习的里程碑式事件。向世人展示了无监督学习的价值，自此AI识别，温柔了岁月，惊艳了时光。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144408.png" alt="img"></p>
<p>​    2011年，Watson，电视游戏中。回答IBM创建的计算机自然语言问题，击败了两个前Jeopardy冠军，肯詹宁斯和布拉德鲁特。自然语言处理逐步开始步入人类生活。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144475.png" alt="img"></p>
<p>​    2015-2017，AlphaGo，谷歌Go的计算机程序，击败了各种（人类）冠军。当时名噪一时，为人工智能做了最好的技术营销。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144464.png" alt="img"></p>
<p>​    2015年，谷歌。发力自动驾驶，Waymo今天是自动驾驶排行第一名。当年满头青丝的Ernst Dickmanns，今天已是白发苍苍。下图右为Ernst Dickmanns。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144489.png" alt="img"></p>
<p>​    2015 年，沈向洋，微软亚洲研究院视觉计算组开发的基于深度卷积神经网络（CNN）的计算机视觉系统，在 ImageNet1000 这项视觉识别挑战中第一个超越人类视觉能力的计算机系统。2019年，沈向洋离开微软，成为清华大学双聘教授。这位来自南京，人工智能国际巨人，把中国的人工智能技术推向一个新的高度。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144595.png" alt="img"></p>
<p>​    2016，微软。组建“微软人工智能与研究事业部”(MicrosoftAI and Research Group)。人工智能是微软的梦想，1991年，盖茨先生就做过人工智能的预言。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144600.png" alt="img"></p>
<p>​        人工智能在模拟、仿真、游戏方面也有着广泛的应用，国内2015年以前，仿真领域是人工智能最核心的领域，以后逐渐向其它领域过渡。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144674.png" alt="img"></p>
<h3 id="6-1-2、启示"><a href="#6-1-2、启示" class="headerlink" title="6.1.2、启示"></a>6.1.2、启示</h3><p>​    2020年前后，人工智能迎来了高速发展期，2019年，人工智能元年。大数据、数据挖掘、机器学习等理论百花齐放，人工智能的时代终于到来了。</p>
<p>​    凝视这段历史时，早期的人工智能偏重于模拟仿真，没有实时性。摄像与视频技术的进步，人工智能向实时性发展，实时性有着重要意义，开启了人工智能社会应用新篇章。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144706.png" alt="img"></p>
<p>​    人工智能代表着大数据量的到来，没有大的数据量无法进行有效的分析，数据处理是人工智能的核心要素，数据处理今天由并行计算来完成。</p>
<p>​    大的数据量不仅对算法有要求，对算力也是一个考验。人工智能需要巨大的算力，没有算力谈不上人工智能。目前在人工智能初级阶段，科技公司算力主要靠CPU、GPU。大的科技公司靠超算中心、VPG、APU、TPU、NPU等来解决。大数据的超强能力，为人工智能的算力提供强有力的支持。</p>
<p>​    人工智能目前阶段两个主要表现，第一个是自然语言处理，第二个是机器视觉。自然文字符号和音视频是人类信息两个重要的载体。</p>
<p>​    机器视觉，很多年前，国外有一些公司在做，仅限于一些专业领域。90年代进入国内后，中科院物理所引进国外专业相机，结合国内应用，开发出相关检测系统。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192144737.png" alt="img"></p>
<p>​    新的硬件与显示标准对智能视觉处理有着很大推动，随着并行计算的发展。可以坚信的是，视觉智能是未来人工智能发展的重要方向。</p>
<h2 id="6-2、硬件发展"><a href="#6-2、硬件发展" class="headerlink" title="6.2、硬件发展"></a>6.2、硬件发展</h2><p>​    人工智能时代需要硬件的支持，不仅仅是外设，更是数据计算。在此需求下，不仅外设的繁荣，更是芯片技术的爆发。</p>
<p>​    芯片技术为智能处理提供了基础，在数据阶段处理，为CPU、GPU提供物理计算基础，在此基础上，有了并行计算架构。无论云平台、大数据、机器学习、区块链无一不是建立在并行计算的基础上。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147639.jpeg" alt="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3453621467,281658853&amp;fm=26&amp;gp=0.jpg"></p>
<p>​    60年代，中国挥剑斩芯片，丧失发展先机。今天，倾国之力，十万亿级投资，发展芯片，留给我们多少启示。</p>
<p>​    下面通过芯片、相机传感器硬件角度讲述，其它层面参考相关资料。智能时代的机器视觉视频来自于相机，考虑了相机因素。</p>
<h3 id="6-2-1、AI-AR-VR芯片"><a href="#6-2-1、AI-AR-VR芯片" class="headerlink" title="6.2.1、AI&#x2F;AR&#x2F;VR芯片"></a>6.2.1、AI&#x2F;AR&#x2F;VR芯片</h3><p>​    人工智能首先是硬件技术的进步，硬件技术的核心是芯片。芯片技术是集成电路的高度封装。芯片技术是半导体技术的体现，整个生产过程与产业链较长，需要多家公司合作才能完成。</p>
<p>​    顶级科技公司钟情于芯片研发，包括AI&#x2F;AR&#x2F;VR芯片研发。微软、特斯拉、英伟达、facebook、谷歌、NXP、华为等。人工智能时代的到来，芯片的多样性与功能性都有很大变化。技术的风起云涌，为芯片制造提供了契机。</p>
<p>​    人工智能时代，AI&#x2F;AR&#x2F;VR芯片快速发展，为人工智能提供澎湃动力支持。芯片技术是人工智能后续阶段的关键技术，没有芯片技术的进步，人工智能将会举步不前。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147689.png" alt="img"></p>
<h3 id="6-2-2、相机芯片"><a href="#6-2-2、相机芯片" class="headerlink" title="6.2.2、相机芯片"></a>6.2.2、相机芯片</h3><p>​    相机，记录着社会文明。相机，留存着社会点滴。相机，助力着生产生活。相机，是机器视觉第一步的表达。</p>
<p>​    整个视频处理流程，相机是前端，机器视觉部分处理在前端实现。学习机器视觉，有必要对相机简单了解。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147646.png" alt="img"></p>
<p>​        对于工业视频而言，相机是重中之重，相机技术有很多分类。本部分通过传统相机和工业相机进行讲述。</p>
<h4 id="6-2-2-1、传统相机"><a href="#6-2-2-1、传统相机" class="headerlink" title="6.2.2.1、传统相机"></a>6.2.2.1、传统相机</h4><p>​    相机技术发展多年，主要是图像传感器的发展，目前分为CCD和CMOS两种。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147725.png" alt="img"></p>
<h5 id="6-2-2-1-1、CCD"><a href="#6-2-2-1-1、CCD" class="headerlink" title="6.2.2.1.1、CCD"></a>6.2.2.1.1、CCD</h5><p>​    CCD芯片是将光信号转换成电信号的芯片，在数码相机、摄像机中，光信号转换成电信号，然后处理，编程数码照片文件。</p>
<p>​    CCD芯片，使用高感光度的半导体材料制成，把光线转变成电荷，通过模数转换器芯片转换成数字信号，数字信号经过压缩后由相机内部的存储设备保存，然后把数据传输给计算机，借助于计算机的处理手段，根据需要和想像来修改图像。</p>
<p>​    CCD芯片由感光单位组成，通常以百万像素为单位。CCD表面受到光线照射时，每个感光单位会将电荷反映在组件上，所有的感光单位所产生的信号加在一起，构成了一幅完整的画面。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147694.png" alt="img"></p>
<p>​    CCD图像传感器是按一定规律排列的mos（金属—氧化物—半导体）电容器组成的阵列，在p型或n型硅衬底上生长一层很薄（约120nm）的二氧化硅，再在二氧化硅薄层上依次序沉积金属或掺杂多晶硅电极（栅极），形成规则的mos电容器阵列，再加上两端的输入及输出二极管就构成了CCD芯片。</p>
<h5 id="6-2-2-1-2、CMOS"><a href="#6-2-2-1-2、CMOS" class="headerlink" title="6.2.2.1.2、CMOS"></a>6.2.2.1.2、CMOS</h5><p>​    CMOS相机采用CMOS图像传感器的设备。CMOS一般应用在普通数码设备中，CCD一般应用高档数码设备中，CCD比CMOS单位成像的效果要好。CCD镜头比CMOS分辨率要高。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147761.png" alt="img"></p>
<p>​    CCD和CMOS在制造上的主要区别是CCD是集成在半导体单晶材料上，而CMOS是集成在被称做金属氧化物的半导体材料上。CCD只有少数几个厂商索尼、松下等掌握这种技术。CCD制造工艺较复杂，采用CCD的摄像头价格昂贵。</p>
<p>​    相同像素下CCD的成像通透性、明锐度都很好，色彩还原、曝光可以保证基本准确。CMOS由于低廉的价格以及高度的整合性，因此在摄像头领域还是得到了广泛的应用。</p>
<p>​    CMOS的信号是以点为单位的电荷信号，而CCD是以行为单位的电流信号，前者更为敏感，速度也更快，更为省电。高级的CMOS并不比一般CCD差，CMOS工艺还不是十分成熟，普通的CMOS一般分辨率低而成像较差。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147893.png" alt="img"></p>
<p>​    CCD或CMOS，基本上都是利用矽感光二极体进行光与电的转换。光线越强、电力越强；反之，光线越弱、电力也越弱的道理，将光影像转换为电子数字信号。</p>
<p>​    CCD每曝光一次，在快门关闭后进行像素转移处理，将每一行中每一个像素（pixel）的电荷信号依序传入“缓冲器”中，由底端的线路引导输出至CCD旁的放大器进行放大，再串联ADC输出；相对地，CMOS的设计中每个像素旁就直接连着ADC（放大兼类比数字信号转换器），信号直接放大并转换成数字信号。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147035.png" alt="img"></p>
<p>​    CCD的充分保持信号传输时不失真，透过每一个像素集合至单一放大器上再做统一处理，保持资料的完整性；CMOS制程简单，没有专属通道，必须先放大再整合各个像素资料。</p>
<p>​    由于CMOS每个像素包含了放大器与A&#x2F;D转换电路，过多的额外设备压缩单一像素的感光区域的表面积，因此相同像素下，同样大小之感光器尺寸，CMOS的感光度会低于CCD。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147982.png" alt="img"></p>
<p>​    CMOS应用半导体工业常用的MOS制程，一次整合全部周边设施于单晶片中，节省加工晶片所需负担的成本和良率的损失；CCD采用电荷传递的方式输出资讯，必须另辟传输通道，如果通道中有一个像素故障（Fail），就会导致一整排的讯号壅塞，无法传递。</p>
<p>​    CMOS每个感光二极体旁都搭配一个ADC放大器，如果以百万像素计，需要百万个以上的ADC放大器，虽然是统一制造下的产品，每个放大器或多或少都有些微的差异存在，很难达到同步放大的效果，对比单一个放大器的CCD，CMOS最终计算出的噪点就比较多。</p>
<p>​    市场销售的数码摄像头中以CMOS感光器件的为主。在采用CMOS为感光元器件的产品中，采用影像光源自动增益补强技术，自动亮度、白平衡控制技术，色饱和度、对比度、边缘增强以及伽马矫正等先进的影像控制技术，完全可以达到与CCD摄像头相媲美的效果。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147015.png" alt="img"></p>
<p>​    尽管CCD在影像品质等方面均优于CMOS，不可否认的CMOS具有低成本、低耗电以及高整合度的特性。CMOS的低成本和稳定供货，所以广泛使用，制造技术不断地改良更新，使得CCD与CMOS两者的差异逐渐缩小。</p>
<h4 id="6-2-2-2、工业相机"><a href="#6-2-2-2、工业相机" class="headerlink" title="6.2.2.2、工业相机"></a>6.2.2.2、工业相机</h4><p>​    工业相机是机器视觉系统中的关键组件，本质功能就是将光信号转变成有序的电信号。选择合适的相机也是机器视觉系统设计中的重要环节，相机的选择不仅直接决定所采集到的图像分辨率、图像质量等，同时与整个视觉系统的运行模式直接相关。 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147005.jpeg" alt="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1608566505281&amp;di=7b7d2283ab97792c4f33165fd0252355&amp;imgtype=0&amp;src=http%3A%2F%2Fa.img.youboy.com%2Fcoimg%2F2010%2F4%2F16%2Fg3_2764572.jpg"></p>
<p>​    工业相机俗称摄像机，相比于传统的民用相机（摄像机）而言，它具有高的图像稳定性、高传输能力和高抗干扰能力等，市面上工业相机大多是基于CCD（Charge Coupled Device）或CMOS（Complementary Metal Oxide Semiconductor）芯片的相机。</p>
<p>​    CCD是目前机器视觉常用的图像传感器。它集光电转换及电荷存贮、电荷转移、信号读取于一体，是典型的固体成像器件。突出特点是以电荷作为信号，不同于其它器件是以电流或者电压为信号。通过光电转换形成电荷包，而后在驱动脉冲的作用下转移、放大输出图像信号。典型的CCD相机由光学镜头、时序及同步信号发生器、垂直驱动器、模拟&#x2F;数字信号处理电路组成。CCD作为一种功能器件，与真空管相比，具有无灼伤、无滞后、低电压工作、低功耗等优点。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147051.png" alt="img"></p>
<p>​    CMOS图像传感器的开发最早出现在20世纪70 年代初，90 年代初期，超大规模集成电路 (VLSI)制造工艺技术的发展，CMOS图像传感器得到迅速发展。CMOS图像传感器将光敏元阵列、图像信号放大器、信号读取电路、模数转换电路、图像信号处理器及控制器集成在一块芯片上，还具有局部像素的编程随机访问的优点。CMOS图像传感器以其良好的集成性、低功耗、高速传输和宽动态范围等特点得到了广泛的应用。</p>
<p>​    工业视觉离不开相机的支持，在一些高端领域，必须用工业相机来处理。工业相机是民用相机的增强版，本质依然采用CCD或者CMOS技术。相对民用相机，用更高的软硬件配置，更大的功耗获得更好的质量。</p>
<h3 id="6-2-2-3、总结"><a href="#6-2-2-3、总结" class="headerlink" title="6.2.2.3、总结"></a>6.2.2.3、总结</h3><p>​    人工智能图像处理，工业上，对高清晰照片进行处理。其它领域，是消费级的处理。技术的进步，高清晰相机在消费级市场应用，高清照片的消费级技术处理将会显现。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147242.png" alt="img"></p>
<p>​    工业视频的处理靠高端硬件实现，消费级高清视频的处理，还需要新的技术框架支持。在未来几年将有新的机会出现。</p>
<h2 id="6-3、机器视觉"><a href="#6-3、机器视觉" class="headerlink" title="6.3、机器视觉"></a>6.3、机器视觉</h2><p>​    机器视觉是人工智能快速发展的一个分支，也是智能视觉重要的一部分。机器视觉就是用机器代替人眼来做测量和判断。</p>
<p>​    机器视觉系统通过机器视觉产品(即图像摄取装置，分CMOS和CCD两种)将被摄取目标转换成图像信号，传送给专用的图像处理系统，得到被摄目标的形态信息。根据像素分布和亮度、颜色等信息，转变成数字化信号;图像系统对这些信号进行各种运算来抽取目标的特征，进而根据判别的结果控制现场的设备动作。 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147722.png" alt="img"></p>
<p>​    机器视觉是一项综合技术，包括图像处理、机械工程技术、控制、电光源照明、光学成像、传感器、模拟与数字视频技术、计算机软硬件技术(图像增强和分析算法、图像卡、 I&#x2F;O卡等)。</p>
<p>​    很多年前，机器视觉就在广泛应用。目前，在深度和广度方面拓展。未来10年，机器视觉对人类生活，将会有革命性的变化。</p>
<p>​    机器视觉是一门技术，机器视觉系统是技术的应用，下一主题，我们讲述机器视觉系统。</p>
<h2 id="6-4、机器视觉系统"><a href="#6-4、机器视觉系统" class="headerlink" title="6.4、机器视觉系统"></a>6.4、机器视觉系统</h2><p>​    一个典型的机器视觉应用系统包括图像捕捉、光源系统、图像数字化模块、数字图像处理模块、智能判断决策模块和机械控制执行模块。</p>
<p>​    机器视觉系统基本的特点就是提高生产的灵活性和自动化程度。在不适于人工作业的危险工作环境或者人工视觉难以满足要求的场合，用机器视觉来替代人工视觉。在大批量重复性工业生产中，用机器视觉检测方法提高生产的效率和自动化程度。 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147712.png" alt="img"></p>
<p>​    机器视觉系统提高生产的柔性和自动化程度。在一些不适合人工作业的危险工作环境或人工视觉难以满足要求的场合，常用机器视觉来替代人工视觉；同时在大批量工业生产过程中，用人工视觉检查产品质量效率低且精度不高，用机器视觉检测方法大大提高生产效率和自动化程度。机器视觉易于实现信息集成，是实现计算机集成制造的基础技术之一。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147680.jpeg" alt="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1608562528401&amp;di=e64ba214572a7b1d069c2c1c0522dc5c&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.mv186.com%2Fuploads%2Fimage%2F20150902%2F1441176652869171.png"></p>
<p>​    工业机器视觉系统包括：光源、镜头（定焦镜头、变倍镜头、远心镜头、显微镜头）、 相机（包括CCD相机和COMS相机）、图像处理单元（或图像捕获卡）、图像处理软件、监视器、通讯 &#x2F; 输入输出单元等。</p>
<p>​    机器视觉检测系统采用CCD照相机将被检测的目标转换成图像信号，传送给专用的图像处理系统，依据像素分布和亮度、颜色等信息，转变成数字化信号，图像处理系统对这些信号进行各种运算来抽取目标的特征，如面积、数量、位置、长度，再根据预设的允许度和其它条件输出结果，包括尺寸、角度、个数、合格&#x2F;不合格、有&#x2F;无等，实现自动识别功能。</p>
<p>​    目前，机器视觉系统主要应用在工业生产领域，互联网应用正在兴起，在居家生活应用上方兴未艾。</p>
<h2 id="6-5、计算机视觉"><a href="#6-5、计算机视觉" class="headerlink" title="6.5、计算机视觉"></a>6.5、计算机视觉</h2><p>​    计算机视觉是研究如何使机器“看”的科学，用摄影机和电脑代替人眼对目标进行识别、跟踪和测量等，并进一步做图形处理，使电脑处理更适合人眼观察或传送给仪器检测的图像。计算机视觉可以看作，如何使人工系统从图像或多维数据中“感知”的科学。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147700.png" alt="img"></p>
<p>​    计算机视觉是一门关于如何运用照相机和计算机来获取我们所需的，被拍摄对象的数据与信息的学问。形象地说，就是给计算机安装上眼睛（照相机）和大脑（算法），让计算机能够感知环境。</p>
<p>​    计算机视觉既是工程领域，也是科学领域中重要研究领域。计算机视觉是一门综合性的学科，吸引了众多研究者参加到对它的研究之中。包括计算机科学和工程、信号处理、物理学、应用数学和统计学，神经生理学和认知科学等。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147672.png" alt="img"></p>
<p>​    计算机视觉开始于60年代初，80年代取得很多重大进展。计算机视觉与人类视觉密切相关，对人类视觉有正确的认识对计算机视觉的研究非常有益。</p>
<p>​    计算机视觉用各种成像系统代替视觉器官作为输入敏感手段，由计算机来代替大脑完成处理和解释。计算机视觉的研究目标就是使计算机象人那样通过视觉观察和理解世界，具有自主适应环境的能力。</p>
<p>​    计算机视觉根据计算机系统的特点进行视觉信息处理。迄今为止人类视觉系统，是功能最强大和完善的视觉系统。对人类视觉处理机制的研究将给计算机视觉的研究提供启发和指导。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192147682.jpeg" alt="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.zhimg.com%2Fv2-5f3ab881181f49338b21dfa143f8bffc_b.jpg&amp;refer=http%3A%2F%2Fpic1.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1615908110&amp;t=0cc3aa72b4535c39f9657f6823f990b2"></p>
<p>​    计算机信息处理的方法是研究人类视觉的机理，建立人类视觉计算理论。称为计算视觉（Computational Vision）。计算视觉是计算机视觉中的一个研究领域。</p>
<p>​    计算机视觉和机器视觉的定义有很多认知的区别，很多文献中有不同的论述，笔者认为，两者都是人工智能的分支，侧重点不一样。在今天学术领域，都没有严格的定义。</p>
<h2 id="6-6、智能时代软件发展"><a href="#6-6、智能时代软件发展" class="headerlink" title="6.6、智能时代软件发展"></a>6.6、智能时代软件发展</h2><p>​    天下事物发展一分为二，软硬件技术也不例外，第二次工业革命电磁理论，石破天惊，在后期推动了计算机技术的进步。为第四次科技革命的发展做好了硬件的铺垫。在硬件大力发展背后，智能时代软件的号角吹响了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148933.png" alt="img"></p>
<p>​    人类在智能科技方面的探索没有终点，也很难找到起点。人工智能探索过程中，软件方面有着天翻地覆的变化，下面从编程语言、运算平台、机器学习库等方面分别进行阐述。</p>
<h3 id="6-6-1、人工智能编程语言"><a href="#6-6-1、人工智能编程语言" class="headerlink" title="6.6.1、人工智能编程语言"></a>6.6.1、人工智能编程语言</h3><p>​    人工智能编程语言是一类适应于人工智能和知识工程领域的、具有符号处理和逻辑推理能力的计算机程序设计语言。能够用它来编写程序求解非数值计算、知识处理、推理、规划、决策等具有智能的各种复杂问题。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148892.jpeg" alt="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1385822726,935678861&amp;fm=26&amp;gp=0.jpg"></p>
<p>​    事实上，已经有多种对应于各种不同知识表示方式的人工智能编程语言。按所对应的知识表示方式不同。可以区分为以下几类：</p>
<p>​    A、对应于产生式规则知识表示的语言。例如，由美国卡耐基·梅农大学的C·L·福基（C。L。Forgy）等人1977年开发的OPS(official production system)，当时用它来为DEC公司开发了一个解决VAX计算机系统配置问题的专家系统X1&#x2F;XCON。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148938.png" alt="img"></p>
<p>​    B、对应于逻辑公式知识表示的语言。一种已广为应用的逻辑语言就是PROLOG。1970年由法国马塞大学的 A。柯迈豪埃(Alain Colmerauer)所开发的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148894.png" alt="img"></p>
<p>​    C、对应于框架或语义网知识表示的语言。这是“面向对象”的(object-oriented)语言。其中一个有代表性的语种就是Smalltalk。1980年首创，后来版本不断更新。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148927.png" alt="img"></p>
<p>​    D、对应于函数知识表示或函数式程序设计风格的语言的列表处理语言。函数式编程语言，理论上很完美，建立在坚实的数学基础之上，对于人工智能问题，在常规计算机上很难实现。20世纪50年代末，麻省理工学院的约翰·麦卡锡等人首先开发的列表处理语言LISP（LISt Processing）迄今仍然广泛用于编写人工智能应用程序，特别是用于开发专家系统。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148886.jpeg" alt="https://ss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/baike/w%3D268%3Bg%3D0/sign=cd791b07708b4710ce2ffacafbf5a4c0/1b4c510fd9f9d72a1781f33bd62a2834349bbb2b.jpg"></p>
<p>​    人工智能编程语言有共同特点，语言都面向要解决的问题、结合知识表示、完全脱离当代计算机的诺依曼结构特性而独立设计的；处于比面向过程的高级编程语言更高的抽象层次。</p>
<p>​    用这些语言编写的程序，在现代计算机环境中，无论是解释或编译执行，往往效率很低。尤其程序规模很大、复杂时，浪费大量系统资源，系统性能往往会下降到难以容忍的地步。 </p>
<h4 id="6-6-1-1、LISP"><a href="#6-6-1-1、LISP" class="headerlink" title="6.6.1.1、LISP"></a>6.6.1.1、LISP</h4><p>​    20世纪50年代后期，麻省理工学院的John McCarthy就开始了人工智能的研究，当时致力于设计一个用表处理的递归系统，在20世纪60年代初研制出了LISP语言。</p>
<p>​    LISP语言是一个用于处理符号表达式的、相当简单的函数式程序设计语言，以数学中的函数与函数作用的概念作为设计原理，奠定了函数式语言的基础。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148104.png" alt="img"></p>
<p>​    LISP语言是完全非von Neumann风格的，它没有使用ALGOL60等语言中所采用的可修改变量、赋值语句、转向语句等von Neumann结构语言中的有关概念。LISP程序与其数据结构采用了相同的结构形式与处理方式。</p>
<p>​    LISP方便地编写解释程序。LISP语言除了用s一表达式来统一处理数据与程序外，还引入了前缀运算符表示法、递归数据结构、递归控制结构以及新的条件表达式形式。</p>
<h4 id="6-6-1-2、Prolog"><a href="#6-6-1-2、Prolog" class="headerlink" title="6.6.1.2、Prolog"></a>6.6.1.2、Prolog</h4><p>​    Prolog(Programming in Logic)是一种逻辑编程语言，建立在逻辑学的理论基础之上，最初被运用于自然语言等研究领域。现已广泛应用在人工智能的研究中，可以用来建造专家系统、自然语言理解、智能知识库等。</p>
<p>​    对一些应用程序的编写很有帮助，能够比其它语言更快速开发程序，Prolog的编程方法更像是使用逻辑语言来描述程序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148111.png" alt="img"></p>
<p>​    Prolog具有鲜明的逻辑编程语言特色，包括：没有特定的运行顺序，运行顺序是由计算机决定的，而不是程序员；程序中没有if、when、case、for这样的控制流程语句；Prolog程序和数据高度统一，其程序实际上是一个智能数据库；具有强大的递归功能。</p>
<p>​    1981年日本政府宣布第5代计算机系统(FGCS)项目以Prolog为基础语言以来，Prolog成为了人工智能研究领域的主导语言。</p>
<h4 id="6-6-1-3、OPS83"><a href="#6-6-1-3、OPS83" class="headerlink" title="6.6.1.3、OPS83"></a>6.6.1.3、OPS83</h4><p>​    OPS83是应用于专家系统的程序设计语言，支持OPS早期版本，也支持PASCAL或C这些常规程序设计语言所具有的过程设计能力。它不是对所有程序设计任务都适宜，OPS83较之OPS的早期版本，对许多问题处理的更目然、更有效。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148162.png" alt="img"></p>
<p>​    OPS是由美国宾夕法尼亚州卡内基一梅隆大学的C.L.Forgy等人开发。最早版本是在1975年开发的，之后几经修改形成了OPSl、OPS2(1978)、OPS4(1979)、OPS5(1981)多种版本，1986年出现了OPS83。 </p>
<p>​    OSP83采用产生式系统的知识表示模式和正向精确推理方式。它提供了两种交互环境：一是和用户的界面；二是和知识工程师的界面(调试环境)。OPS83包括三个主要部分：知识库、推理机和工作存贮器。</p>
<p>​    知识库又称规则库。每条规则均以0PS83语言来表示。OPS83的推理过程由若干“识别一动作”周期组成。每个周期包括三个动作或阶段：匹配、冲突解决(或选择)和执行。</p>
<p>​    匹配是数据和已有规则的匹配。匹配的结果形成了冲突集。是所有满足条件的规则的集合。然后，推理机从冲突集中选择规则执行。工作存贮器(Work Memory，WM)用来存贮推理机在推理过程中的初始状态、中间状态和目标等信息。</p>
<p>​    各个模块可作为独立的文件存放在存贮器中，单独编译，然后连接在一起运行。数据类型、语句、子程序等与一般程序设计语言类似，使用OPS83的知识工程师有一个类似于过程描述型语言的编程环境。</p>
<h4 id="6-6-1-4、Python"><a href="#6-6-1-4、Python" class="headerlink" title="6.6.1.4、Python"></a>6.6.1.4、Python</h4><p>​    1989年圣诞节期间，荷兰人吉多·范罗苏姆（Guido van Rossum），在阿姆斯特丹，为了打发圣诞节的无趣，决心开发一个新的脚本解释程序，作为ABC语言的继承。还受到了Modula-3的影响，结合了Unix shell和C的习惯。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148214.png" alt="img"></p>
<p>​    Guido本人看来，ABC语言优美强大，为非专业程序员设计。但是ABC语言并没有成功，究其原因，Guido认为是其非开放造成的。Guido在Python中避免这一错误。同时，他还想实现在ABC中闪现过但未曾实现的东西。</p>
<p>​    Python语法和动态类型，以及解释型语言的本质，使它成为多数平台上写脚本和快速开发应用的编程语言，随着版本的更新和语言新功能的添加，逐渐被用于独立的、大型项目的开发。</p>
<p>​    Python解释器易于扩展，可以使用C或C++（或者其它可以通过C调用的语言）扩展新的功能和数据类型。Python 也可用于可定制化软件中的扩展程序语言。丰富的标准库，提供了适用于各个主要系统平台的源码或机器码。</p>
<p>​    由于Python语言的简洁性、易读性以及可扩展性，在国内外用Python做科学计算的研究机构日益增多，很多知名大学已经采用Python来教授程序设计课程。例如卡耐基梅隆大学、麻省理工学院等。</p>
<p>​    众多开源的科学计算软件包都提供了Python的调用接口，例如著名的计算机视觉库OpenCV、三维可视化库VTK、医学图像处理库ITK。Python专用的科学计算扩展库十分流行，例如如下3个经典的科学计算扩展库：NumPy、SciPy和matplotlib，它们分别为Python提供了快速数组处理、数值运算以及绘图功能。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148197.png" alt="img"></p>
<p>​    Python语言及其众多的扩展库所构成的开发环境适合工程技术、科研人员处理实验数据、制作图表，甚至开发科学计算应用程序，并可用于机器学习领域。</p>
<p>​    让人惊奇的是，Python今天成为人工智能应用层上最主要的外部接口，尤其在图形图像领域，使用尤其广泛，例如TensorFlow和PyTorch等。这应该是Guido所不曾想到的。</p>
<h3 id="6-6-1-4、启示"><a href="#6-6-1-4、启示" class="headerlink" title="6.6.1.4、启示"></a>6.6.1.4、启示</h3><p>​    诚然，编程语言很多，描述这段历史时，应该认识到的是，不同的编程语言与当时的硬件环境、软件理论相照应。在今天，只需要一概而过，对于深度研发，有一定认知的必要。</p>
<p>​    人工智能是一场科技革命，不仅仅是理论的发展，更是实践的应用，随着硬件技术的进步，人工智能理念的变幻，软件方面也将有很大的发展。</p>
<p>​    编程语言发展上，人工智能有很大的发展，编程语言与硬件系统紧密结合，编程语言与框架模式协作并行，才会有更大的突破。在未来，人工智能方面编程语言的发展，有这样三个思索。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148251.png" alt="img"></p>
<p>​    A、研制与某种语言完全适应的新一代计算机。例如LlSP机、数据流机、PROLOG机、面向对象的体系结构等。但举步维艰、前景渺茫。以诺依曼机为核心的现代通用计算机已经广泛普及而且性能不断提高，积累了巨大的软件资源。任何与现代计算机不兼容的专用机，最多满足特殊需求，难以与现代通用计算机抗衡。在没有很大商业机会的前提下，这种办法是不可能实现的。</p>
<p>​    B、把不同风格的编程语言结合起来，发展复合语言或嵌入式语言，取长补短，使系统性能得以进一步提高。把面向对象语言的设计思路融汇到常用的面向过程的高级语言中。C++语言就是一个突出的例子。这种改变相对来说影响较小，毕竟不是脱胎换骨。</p>
<p>​    C、用面向问题的人工智能编程语言的特点，先选择某种语言编写出一个简洁明了而易于调试的程序原型。通过验证、调试，再仿照这个原型，改编为某种面向过程的高级语言程序，例如C或C++，达到提高最终应用系统开发质量和执行效率的目的。用PROLOG、 LISP、OPS等来开发专家系统原型，已有不少先例。在技术变幻的前提下，这种方式有一定的价值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148324.jpeg" alt="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1263603027,3603698295&amp;fm=26&amp;gp=0.jpg"></p>
<p>​    计算机发展史上，基于冯·诺伊曼的硬件系统很难发生变化，计算机编程语言的发展从未停止。我们得到一个启示，思想最容易在软件方面实现，而计算机编程语言的发展也就不足为奇。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148373.png" alt="img"></p>
<p>​    关于计算机体系结构的发展，有一定价值的是，在未来，量子计算机的体系结构将会是一个重要的方向。随着量子技术的进步，对于商业而言，再次掀起市场的沧海桑田，腥风血雨。</p>
<h3 id="6-6-3、机器学习库"><a href="#6-6-3、机器学习库" class="headerlink" title="6.6.3、机器学习库"></a>6.6.3、机器学习库</h3><p>​    机器学习是人工智能的重要组成部分，机器学习是一个完善的生态环境，对于人工智能而言，算法库是重中之重。降低了智能视觉分析的门槛，加大了人工智能的应用。人工智能算法库有很多，本部分重点讨论应用广泛的两个神经网络库，TensorFlow和PyTorch。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148162.png" alt="img"></p>
<p>​    神经网络可以指向两种，一个是生物神经网络，一个是人工神经网络。</p>
<h4 id="6-6-3-1、生物神经网络"><a href="#6-6-3-1、生物神经网络" class="headerlink" title="6.6.3.1、生物神经网络"></a>6.6.3.1、生物神经网络</h4><p>​    生物神经网络：一般指生物的大脑神经元，细胞，触点等组成的网络，用于产生生物的意识，帮助生物进行思考和行动。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148129.jpeg" alt="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1907824141,1397086773&amp;fm=26&amp;gp=0.jpg"></p>
<h4 id="6-6-3-2、人工神经网络"><a href="#6-6-3-2、人工神经网络" class="headerlink" title="6.6.3.2、人工神经网络"></a>6.6.3.2、人工神经网络</h4><p>​    人工神经网络（Artificial Neural Networks，简写为ANNs）也简称为神经网络（NNs）或称作连接模型（Connection Model），它是一种模仿动物神经网络行为特征，进行分布式并行信息处理的算法数学模型。这种网络依靠系统的复杂程度，通过调整内部大量节点之间相互连接的关系，从而达到处理信息的目的。</p>
<p>​    人工神经网络：是一种应用类似于大脑神经突触联接的结构进行信息处理的数学模型。在工程与学术界也常直接简称为“神经网络”或类神经网络。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148142.png" alt="img"></p>
<p>​    人工神经网络（Artificial Neural Network，即ANN ），是20世纪80 年代以来人工智能领域兴起的研究热点。它从信息处理角度对人脑神经元网络进行抽象， 建立某种简单模型，按不同的连接方式组成不同的网络。在工程与学术界也常直接简称为神经网络或类神经网络。神经网络是一种运算模型，由大量的节点（或称神经元）之间相互联接构成。</p>
<p>​    每个节点代表一种特定的输出函数，称为激励函数（activation function）。每两个节点间的连接都代表一个对于通过该连接信号的加权值，称之为权重，这相当于人工神经网络的记忆。网络的输出则依网络的连接方式，权重值和激励函数的不同而不同。而网络自身通常都是对自然界某种算法或者函数的逼近，也可能是对一种逻辑策略的表达。</p>
<h4 id="6-6-3-3、TensorFlow"><a href="#6-6-3-3、TensorFlow" class="headerlink" title="6.6.3.3、TensorFlow"></a>6.6.3.3、TensorFlow</h4><p>​    TensorFlow™是基于数据流编程（dataflow programming）的符号数学系统，在人工智能领域，有这广泛的应用。TensorFlow是今天神经网络训练的主要平台，成就了TensorFlow在今天庞大的用户群。</p>
<p>​    用于各类机器学习（machine learning），前身是谷歌的神经网络算法库DistBelief 。谷歌不仅在大数据领域有着重要的位置，在人工智能方面，谷歌也名列前茅。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148170.png" alt="img"></p>
<p>​    Tensorflow拥有多层级结构，使用面向各种场景，可部署于各类服务器、PC终端和网页，支持GPU和TPU高性能数值计算，开发环境友好。应用于谷歌内部的产品开发和各领域的科学研究 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148229.png" alt="img"></p>
<h5 id="6-6-3-3-1、发展"><a href="#6-6-3-3-1、发展" class="headerlink" title="6.6.3.3.1、发展"></a>6.6.3.3.1、发展</h5><p>​    TensorFlow由谷歌人工智能团队谷歌大脑（Google Brain）开发和维护，是谷歌核心的人工智能项目。拥有很多子项目：TensorFlow Hub、TensorFlow Lite、TensorFlow Research Cloud、各类应用程序接口。</p>
<p>​    谷歌大脑2011年成立，开展面向大规模深度学习应用研究，谷歌大脑具有自我学习功能，将1.6万处理器连接。TensorFlow的前身DistBelief。DistBelief构建各尺度下的神经网络分布式学习和交互系统，被称为“第一代机器学习系统”，为世界人工智能发展做出了卓越的贡献。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148176.jpeg" alt="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2190712454,4261596438&amp;fm=26&amp;gp=0.jpg"></p>
<p>​    DistBelief在谷歌和Alphabet旗下公司的产品开发中广泛使用，成果颇丰。TensorFlow拥有生态系统，从数据训练，接口导出，到工程应用。2018年4月的TensorFlow开发者峰会，有21个TensorFlow项目非常有价值和意义 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148400.png" alt="img"></p>
<h5 id="6-6-3-3-2、核心组件"><a href="#6-6-3-3-2、核心组件" class="headerlink" title="6.6.3.3.2、核心组件"></a>6.6.3.3.2、核心组件</h5><p>​    TensorFlow利用GPU做数据训练，可以进行单机也可以进行分布式部署。</p>
<p>​    合作组件互相配合，保证了TensorFlow的运转。分布式TensorFlow的核心组件如下：</p>
<p>​    分发中心（distributed master）；</p>
<p>​    执行器（dataflow executor&#x2F;worker service）；</p>
<p>​    内核应用（kernel implementation）</p>
<p>​    最底端的设备层（device layer）&#x2F;网络层（networking layer）。</p>
<p>​    分发中心从输入的数据流图中剪取子图（subgraph），将其划分为操作片段并启动执行器。分发中心处理数据流图时会进行预设定的操作优化，包括公共子表达式消去（common subexpression elimination）、常量折叠（constant folding）等。</p>
<p>​    执行器负责图操作（graph operation）在进程和设备中的运行、收发其它执行器的结果。分布式TensorFlow拥有参数器（parameter server）以汇总和更新其它执行器返回的模型参数。执行器在调度本地设备时会选择进行并行计算和GPU加速 。</p>
<p>​    内核应用负责单一的图操作，包括数学计算、数组操作（array manipulation）、控制流（control flow）和状态管理操作（state management operations）。内核应用使用Eigen执行张量的并行计算、cuDNN库等执行GPU加速、gemmlowp执行低数值精度计算，此外用户可以在内核应用中注册额外的内核（fused kernels）以提升基础操作，例如激励函数和其梯度计算的运行效率。</p>
<p>​    单进程TensorFlow相对简单，整体部署训练与方便，和分布式相比，维护也很方便。没有分发中心和执行器，使用特殊的会话应用（Session implementation）联系本地设备。</p>
<p>​    TensorFlow的内核是C语言的，提供的原始接口也是C语言的。其它组件&#x2F;API均通过C语言API与核心组件进行交互。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148396.jpeg" alt="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=974600695,3576740431&amp;fm=15&amp;gp=0.jpg"></p>
<h5 id="6-6-3-3-3、组件"><a href="#6-6-3-3-3、组件" class="headerlink" title="6.6.3.3.3、组件"></a>6.6.3.3.3、组件</h5><p>​    TensorFlow Hub是一个允许用户发布、共享和使用TensorFlow模块的库开发项目。用户可以将TensorFlow数据流图或其部分使用Hub进行封装并移植到其它问题中再次利用。TensorFlow Hub页面列出了由谷歌和DeepMind提供的封装模型，其主题包括字符嵌入、视频分类和图像处理。</p>
<p>​    TensorFlow Extended (TFX)，TFX是谷歌基于TensorFlow开发的产品级机器学习平台，其目标是是对产品开发中的模型实现、分析验证和业务化操作进行整合，在实时数据下完成机器学习产品的标准化生产。TFX包含三个算法库：TensorFlow Data Validation对机器学习数据进行统计描述和验证、TensorFlow Transform对模型数据进行预处理、        TensorFlow Model Analysis对机器学习模型进行分析，提供表现评分。另有TensorFlow Serving作为模型业务化的高性能系统，提供模型接口和管理。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148449.png" alt="img"></p>
<p>​    TensorFlow Probability (TFP)，TFP是在TensorFlow Python API基础上开发的统计学算法库，其目标是方便用户将概率模型和深度学习模型相结合使用。TFP包含大量概率分布的生成器、支持构建深度网络的概率层（probabilistic layers）、提供变分贝叶斯推断（Variational inference）和马尔可夫链蒙特卡罗方法（Markov chain Monte Carlo）和一些特殊的优化器，包括Nelder-Mead方案、BFGS算法（Broyden-Fletcher-Goldfarb-Shanno algorithm）和SGLD（Stochastic Gradient Langevin Dynamics）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148432.png" alt="https://www.yht7.com/upload/image/20200419/1354575-20200418172212742-1807272001.png"></p>
<p>​    TensorFlow.js是TensorFlow的JavaScript API，主要用于网页端的机器学习应用开发。方便网页用户进行人工智能数据训练。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148452.png" alt="img"></p>
<p>​    TensorFlow Lite是为移动和嵌入式设备提供人工智能支持，在Android、iOS系统下机器学习模型的响应时间并降低文件大小。TensorFlow Lite部署了大部分人工智能算法，具有很好的参考价值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148537.png" alt="img"></p>
<p>​    Swift for TensorFlow是开源版Swift的TensorFlow API开发项目，在深度学习和微分计算方面应用。和Eager Execution很相像，可直接执行数据流图，具备更好的性能。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148583.png" alt="img"></p>
<p>​    TensorFlow Research Cloud是面向科学研究的机器学习TPU云计算平台。该项目拥有1000个云TPU和总计180千万亿次计算力，每个TPU拥有64 GB的高带宽内存 。可以通过互联网申请使用，进行有价值的人工智能数据训练。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148715.png" alt="img"></p>
<h5 id="6-6-3-3-4、其它"><a href="#6-6-3-3-4、其它" class="headerlink" title="6.6.3.3.4、其它"></a>6.6.3.3.4、其它</h5><p>​    Magenta是在艺术领域使用机器学习的研究项目，该项目使用深度学习网络和强化学习算法学习生成音乐、绘画和其它艺术作品，以帮助艺术人员拓展其创作过程 。Magenta项目的研究成果包括音乐创作工具NSynth和混音工具MusicVAE。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148710.png" alt="img"></p>
<p>​    Nucleus是将TensorFlow应用于基因组文件，例如SAM和VCF格式文件的读写和分析的库开发项目 。Nucleus使用Python和C++进行开发。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148725.png" alt="img"></p>
<h4 id="6-6-3-2、PyTorch"><a href="#6-6-3-2、PyTorch" class="headerlink" title="6.6.3.2、PyTorch"></a>6.6.3.2、PyTorch</h4><p>​    PyTorch是一个开源的Python机器学习库，基于Torch，用于自然语言处理等应用程序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148729.png" alt="img"></p>
<p>​    2017年1月，由Facebook人工智能研究院（FAIR）基于Torch推出了PyTorch。它是一个基于Python的计算包，提供两个高级功能：1、具有强大的GPU加速的张量计算（如NumPy）。2、包含自动求导系统的深度神经网络。</p>
<p>​    PyTorch使用Python重写了很多内容，更加灵活，支持动态图，提供了Python接口。它是由Torch7团队开发，是一个以Python优先的深度学习框架，实现强大的GPU加速，支持动态神经网络。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148793.jpeg" alt="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3593097388,1004973136&amp;fm=26&amp;gp=0.jpg"></p>
<p>​    PyTorch可以看作加入了GPU支持的numpy，也可以看成拥有自动求导功能的强大的深度神经网络。除Facebook外，已经被Twitter、CMU和Salesforce等机构采用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148838.png" alt="img"></p>
<p>​    PyTorch简洁高效，快速应用的框架，设计追求最少封装，符合人类思维，让用户尽可能地专注于实现自己的想法，与google的Tensorflow类似，FAIR的支持足以确保PyTorch获得持续的开发更新。</p>
<p>  无论对于机器视觉，还是人工智能，相对从前，数据量发生了地覆天翻的变化。传统的运算框架不能满足现实的发展。人工智能影响不是一点一线，而是整个计算体系。</p>
<p>​    从AI&#x2F;AR&#x2F;VR芯片，到GPU数据处理，再到平台架构，框架编程，外部接口调用，都有巨大的变革。今天我们谈一下基于大批量数据的运算框架。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148028.png" alt="img"></p>
<p>​    GPU的参与数据处理已经多年，多年发展过程中，GPU不过是硬件的支持(如下图)，指令的提供，传统的工程师很难进行指令级的开发。所以，运算平台出现了，拓展了技术应用，便捷了软件开发。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148094.png" alt="http://attachbak.dataguru.cn/attachments/forum/201604/24/180629knkh2kffhhwwl23f.png"></p>
<p>​    下面讲述目前最广泛的两个运算平台，英伟达的CUDA和开放的OPENCL平台。</p>
<h4 id="6-6-2-1、CUDA"><a href="#6-6-2-1、CUDA" class="headerlink" title="6.6.2.1、CUDA"></a>6.6.2.1、CUDA</h4><p>​    CUDA（Compute Unified Device Architecture），CUDA™是由NVIDIA推出的并行计算架构，该架构使GPU解决复杂的计算问题。包含了CUDA指令集架构（ISA）以及GPU内部的并行计算引擎。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148827.png" alt="img"></p>
<p>​    开发人员可以使用C语言来为CUDA™架构编写程序，C语言是应用最广泛的一种高级编程语言。编写出的程序可以在支持CUDA™的处理器上以超高性能运行。</p>
<p>​    计算行业从只使用CPU的“中央处理”向CPU与GPU并用的“协同处理”发展。为打造这一全新的计算典范，NVIDIA™（英伟达™）发明了CUDA（Compute Unified Device Architecture，统一计算设备架构）这一编程模型。</p>
<h5 id="6-6-2-1-1、应用"><a href="#6-6-2-1-1、应用" class="headerlink" title="6.6.2.1.1、应用"></a>6.6.2.1.1、应用</h5><p>​    在应用程序中充分利用CPU和GPU各自的优点。该架构已应用于GeForce™（精视™）、ION™（翼扬™）、Quadro以及Tesla GPU（图形处理器）上，对应用程序开发人员来说，这是一个巨大的市场。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148781.png" alt="http://attachbak.dataguru.cn/attachments/forum/201604/24/180626qfnnioezwoc57w15.png"></p>
<p>​    在消费级市场上，几乎每一款重要的消费级视频应用程序都已经使用CUDA加速或很快将会利用CUDA来加速，其中包括Elemental Technologies公司、MotionDSP公司以及LoiLo公司的产品。</p>
<p>​    在科研界，CUDA一直受到热捧。例如，CUDA现已能够对AMBER进行加速。AMBER是一款分子动力学模拟程序，全世界在学术界与制药企业中有超过60，000名研究人员使用该程序来加速新药的探索工作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148810.png" alt="img"></p>
<p>​    在金融市场，Numerix以及CompatibL针对一款全新的对手风险应用程序发布了CUDA支持并取得了18倍速度提升。Numerix为近400家金融机构所广泛使用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148816.png" alt="img"></p>
<p>​    CUDA的广泛应用造就了GPU计算专用Tesla GPU的崛起。全球财富五百强企业已经安装了700多个GPU集群，这些企业涉及各个领域，例如能源领域的斯伦贝谢与雪佛龙以及银行业的法国巴黎银行，包括阿里云。</p>
<p>​    GPU计算目前成为主流。在显卡硬件上，GPU将不仅仅是图形处理器，还是应用程序均可使用的通用并行处理器。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148060.png" alt="img"></p>
<p>​    随着显卡的发展，GPU越来越强大，GPU为图像处理做了优化。计算上超越了通用的CPU。强大的芯片不能仅仅进行显示，因此NVIDIA推出CUDA，让显卡可以用于图像计算以外的目的。</p>
<p>​    CUDA架构可以使用GPU来解决商业、工业以及科学方面的复杂计算问题。它是一个完整的GPGPU解决方案，提供了硬件的直接访问接口，而不必像传统方式一样必须依赖图形API接口来实现GPU的访问。</p>
<h5 id="6-6-2-1-2、系统结构"><a href="#6-6-2-1-2、系统结构" class="headerlink" title="6.6.2.1.2、系统结构"></a>6.6.2.1.2、系统结构</h5><p>​    在架构上采用了一种全新的计算体系结构来使用GPU提供的硬件资源，从而给大规模的数据计算应用提供了一种比CPU更加强大的计算能力。CUDA采用C语言作为编程语言提供大量的高性能计算指令开发能力，使开发者能够在GPU的强大计算能力的基础上建立起一种效率更高的密集数据计算解决方案。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148088.png" alt="img"></p>
<p>​    CUDA体系结构包含三部分：开发库、运行期环境和驱动。</p>
<p>​    开发库是基于CUDA技术提供的应用开发库。CUDA1。1版提供了两个标准的数学运算库——CUFFT（离散快速傅立叶变换）和CUBLAS（离散基本线性计算）的实现。这两个数学运算库解决的是典型的大规模并行计算问题，也是在密集数据计算中非常常见的计算类型。开发人员在开发库的基础上快速、方便的建立起自己的计算应用。此外，开发人员也可以在CUDA的技术基础上实现出更多的开发库。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148086.png" alt="img"></p>
<p>​    运行期环境提供了应用开发接口和运行期组件，包括基本数据类型的定义和各类计算、类型转换、内存管理、设备访问和执行调度等函数。基于CUDA开发的程序代码在实际执行中分为两种，一种是运行在CPU上的宿主代码（Host Code），一种是运行在GPU上的设备代码（Device Code）。不同类型代码运行的物理位置不同，访问的资源不同，对应的运行期组件也分为公共组件、宿主组件和设备组件三个部分，囊括了所有在GPGPU开发中所需要的功能和能够使用到的资源接口，开发人员通过运行期环境的编程接口实现各种类型的计算。</p>
<p>​    由于存在着多种GPU版本的NVidia显卡，不同版本的GPU之间都有不同的差异，因此驱动部分基本上可以理解为是CUDA-enable的GPU的设备抽象层，提供硬件设备的抽象访问接口。CUDA提供运行期环境通过这一层来实现各种功能。基于CUDA开发的应用必须有NVIDIA CUDA-enable的硬件支持。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148132.png" alt="http://attachbak.dataguru.cn/attachments/forum/201604/24/180626v66bl8kkukn3unfp.png"></p>
<p>​    NVIDIA公司GPU运算事业部总经理Andy Keane在活动中表示：一个充满生命力的技术平台应该是开放的，CUDA未来也会向这个方向发展。由于CUDA的体系结构中有硬件抽象层的存在，因此今后也有可能发展成为一个通用的GPGPU标准接口，兼容不同厂商的GPU产品。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148328.png" alt="img"></p>
<p>​    支持CUDA的GPU销量逾10亿，数以万计的开发人员正在使用免费的CUDA软件开发工具来解决各种问题。从视频与音频处理和物理效果模拟到石油天然气勘探、产品设计、医学成像以及科学研究，涵盖了各个领域。</p>
<h5 id="6-6-2-1-3、核心"><a href="#6-6-2-1-3、核心" class="headerlink" title="6.6.2.1.3、核心"></a>6.6.2.1.3、核心</h5><p>​    CUDA的核心有三个重要抽象概念： 线程组层次结构、共享存储器、屏蔽同步（barriersynchronization），轻松将其作为C语言的最小扩展级公开给程序员。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148351.png" alt="img"></p>
<p>​    CUDA 软件堆栈由几层组成，一个硬件驱动程序，一个应用程序编程接口（API）和它的Runtime，还有二个高级的通用数学库，CUFFT 和CUBLAS。硬件被设计成支持轻量级的驱动和Runtime 层面，因而提高性能。</p>
<h5 id="6-6-2-1-4、其它"><a href="#6-6-2-1-4、其它" class="headerlink" title="6.6.2.1.4、其它"></a>6.6.2.1.4、其它</h5><p>​    NVIDIA进军高性能计算领域，推出了Tesla&amp;CUDA高性能计算系列解决方案，CUDA技术，一种基于NVIDIA图形处理器（GPU）上全新的并行计算体系架构，让科学家、工程师和其它专业技术人员能够解决以前无法解决的问题，作为一个专用高性能GPU计算解决方案，NVIDIA把超级计算能够带给任何工作站或服务器，以及标准、基于CPU的服务器集群。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148371.png" alt="img"></p>
<p>​    CUDA是用于GPU计算的开发环境，是一个全新的软硬件架构，可以将GPU视为一个并行数据计算的设备，对计算分配和管理。CUDA的架构中，计算不再像过去所谓的GPGPU架构那样必须将计算映射到图形API（OpenGL和Direct 3D）中，对于开发者来说，CUDA的开发门槛大大降低。CUDA编程基于C语言，任何有C语言基础的用户都很容易地开发CUDA的应用程序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148430.png" alt="img"></p>
<p>​    GPU的特点是处理密集型数据和并行数据计算，因此CUDA非常适合需要大规模并行计算的领域。CUDA除了可以用C、C++、JAVA、Python语言开发。广泛的应用在图形动画、科学计算、地质、生物、物理模拟等领域。</p>
<p>​    计算正在从CPU”中央处理”向CPU与GPU”协同处理”的方向发展。对应用程序开发商来说，英伟达™ CUDA™ 架构拥有庞大的用户群。</p>
<h4 id="6-6-2-2、OPENCL"><a href="#6-6-2-2、OPENCL" class="headerlink" title="6.6.2.2、OPENCL"></a>6.6.2.2、OPENCL</h4><p>​    OpenCL（Open Computing Language，开放运算语言）是第一个面向异构系统并行编程的开放式、免费标准，也是一个统一的编程环境。</p>
<p>​    便于软件开发人员为高性能计算服务器、桌面计算系统、手持设备编写高效轻便的代码，而且广泛适用于多核心处理器(CPU)、图形处理器(GPU)、Cell类型架构以及数字信号处理器(DSP)等其它并行处理器，在游戏、娱乐、科研、医疗等各种领域都有广阔的发展前景。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148356.png" alt="img"></p>
<p>​    OpenCL平台可由CPU，GPU或其它类型的处理器组成。OpenCL用于编写kernels （在OpenCL设备上运行的函数）的语言（基于C99）和一组用于定义并控制平台的API组成。OpenCL提供了基于任务分割和数据分割的并行计算机制。</p>
<p>​    OpenCL类似于另外两个开放的工业标准OpenGL和OpenAL，这两个标准分别用于三维图形和计算机音频方面。OpenCL扩展了GPU用于图形生成之外的能力。OpenCL由非盈利性技术组织Khronos  Group掌管。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148590.png" alt="img"></p>
<h5 id="6-6-2-2-1、发展"><a href="#6-6-2-2-1、发展" class="headerlink" title="6.6.2.2.1、发展"></a>6.6.2.2.1、发展</h5><p>​    OpenCL最初苹果公司开发，拥有其商标权，并在与AMD，IBM，英特尔和NVIDIA技术团队的合作之下初步完善。随后，苹果将这一草案提交至Khronos  Group。</p>
<p>​    2008年6月的WWDC大会上，苹果提出了OpenCL规范，旨在提供一个通用的开放API，在此基础上开发GPU通用计算软件。随后，Khronos  Group宣布成立GPU通用计算开放行业标准工作组，以苹果的提案为基础创立OpenCL行业规范。5个月后的2008年11月18日，该工作组完成了OpenCL 1。0规范的技术细节。2010年6月14日，OpenCL 1。1 发布。2011年11月15日，OpenCL 1。2 发布。2013年11月19日，OpenCL 2。0发布。目前，OpenCL最新版本是3。0。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148672.png" alt="img"></p>
<p>​    2009年6月NVIDIA首家发布了支持OpenCL 1。0通用计算规范的驱动程序，支持Windows和Linux操作系统。</p>
<p>​    2009年8月初AMD首次发布了可支持IA处理器(x86和amd64&#x2F;x64)的OpenCL SDK——ATI Stream SDK v2。0Beta，交由业界标准组织Khronos 进行审核。目前，该SDK更名为AMD APP SDK。</p>
<p>​    2012年2月，intel发布了The Intel&reg; SDK for OpenCL* Applications 2012，支持OpenCL 1。1基于带HD4000&#x2F;2500的显示核心的第三代酷睿CPU（i3，i5，i7)和GPU。</p>
<p>​    2013年6月，intel发布了第四代酷睿CPU haswell 其内置的HD4600&#x2F;4400&#x2F;4200 Iris（锐矩）5000&#x2F;5100&#x2F;pro 5200（自带eDRAM缓存）支持OpenCL 1。2（未来可能升级到OpenCL 2。0）</p>
<p>​    NVIDIA显卡方面 Geforce 8000\9000\100、GTX200-1000，RTX2000均支持OpenCL 1。0-1。2</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148656.png" alt="img"></p>
<p>​    AMD显卡方面 Radeon HD 4000-7000\Rx 200\Rx 300\RX 400-500&#x2F;Fury系列，Vega系列 均支持OpenCL 1。0-1。2，除Radeon HD4000-6000系列外，其余均会支持OpenCL 2。0</p>
<p>​    移动平台方面目前高通adreno320&#x2F;330&#x2F;400系列&#x2F;500系列提供了Android上的OpenCL1。2或者2。0支持，NVIDIA的Tegra K1也提供了OpenCL 支持。</p>
<h5 id="6-6-2-2-2、支持"><a href="#6-6-2-2-2、支持" class="headerlink" title="6.6.2.2.2、支持"></a>6.6.2.2.2、支持</h5><p>​    OpenCL工作组的成员包括：3Dlabs、AMD、苹果、ARM、Codeplay、爱立信、飞思卡尔、华为、HSA基金会、GraphicRemedy、IBM、Imagination Technologies、Intel、诺基亚、NVIDIA、摩托罗拉、QNX、高通，三星、Seaweed、德州仪器、布里斯托尔大学、瑞典Ume大学。像Intel、NVIDIA和AMD都是这个标准的支持者，不过微软并不在其列。目前，NVIDIA显卡对OpenCL技术支持较好。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148659.png" alt="img"></p>
<p>​    在NVIDIA的Quadro、Geforce系列专业显卡中，能够使用OpenCL技术。只要显卡能够达到CUDA的要求，就能够正常使用OpenCL，以获得优异的CPU运算效率。</p>
<p>​    在AMD-ATI的Stream技术中（现已经改名为AMD APP并行加速技术），已经为日常使用、办公、游戏等提供物理加速。基于OpenCL标准开发，其中，ATI Radeon HD 4000-5000、AMD Radeon HD 6000系列同时支持ATI Stream和AMD APP（由于Stream基于CAL和Brook+语言开发，更适合VLIW5和VLIW4这样的SIMD架构），AMD Radeon HD7000和Radeon Rx 200系列支持AMD APP，运算效率较老架构提升十分明显。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148635.png" alt="img"></p>
<h5 id="6-6-2-2-3、API"><a href="#6-6-2-2-3、API" class="headerlink" title="6.6.2.2.3、API"></a>6.6.2.2.3、API</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148721.png" alt="img"></p>
<p>​    OpenCL平台API：定义了宿主机程序发现OpenCL设备所用的函数以及这些函数的功能，还定义了OpenCL应用创建上下文的函数。</p>
<p>​    OpenCL运行时API：管理上下文来创建命令队列以及运行时发生的其它操作。例如，将命令提交到命令队列的函数就来自OpenCL运行时API。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148915.png" alt="img"></p>
<p>​    OpenCL编程语言：编写内核代码的编程语言。基于ISO C99标准的一个扩展子集，通常称为OpenCL C编程语言。</p>
<h5 id="6-6-2-2-4、总结"><a href="#6-6-2-2-4、总结" class="headerlink" title="6.6.2.2.4、总结"></a>6.6.2.2.4、总结</h5><p>​    综合上述内容，形成OpenCL全景图(如下)，首先是一个定义上下文的宿主机程序。上图中的上下文包含两个OpenCL设备、一个CPU和一个GPU。接下来定义了命令队列。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148901.png" alt="img"></p>
<p>​    这里有两个队列，一个是面向GPU的有序命令队列，另一个是面向CPU的乱序命令队列。然后宿主机程序定义一个程序对象，这个程序对象编译后将为两个OpenCL设备（CPU和GPU）生成内核。</p>
<p>​    接下来宿主机程序定义程序所需的内存对象，并把它们映射到内核的参数。最后，宿主机程序将命令放入命令队列来执行这些内核。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148953.png" alt="img"></p>
<h3 id="6-6-4、其它相关库"><a href="#6-6-4、其它相关库" class="headerlink" title="6.6.4、其它相关库"></a>6.6.4、其它相关库</h3><p>​    智能时代是百花齐放的时代，芯片技术驱动硬件技术，芯片指令提供操作接口，操作接口驱动运算平台，运算平台驱动机器学习库。本主题介绍部分机器视觉和并行计算库。</p>
<h4 id="6-6-4-1、OpenCV"><a href="#6-6-4-1、OpenCV" class="headerlink" title="6.6.4.1、OpenCV"></a>6.6.4.1、OpenCV</h4><p>​    OpenCV是基于BSD许可（开源）发行的跨平台计算机视觉和机器学习软件库，运行在Linux、Windows、Android和Mac OS操作系统上。 轻量高效，由一系列 C 函数和少量 C++ 类构成，提供了Python、Ruby、MATLAB等编程接口，实现了图像处理和计算机视觉方面的通用算法。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148536.png" alt="img"></p>
<h4 id="6-6-4-1、简介"><a href="#6-6-4-1、简介" class="headerlink" title="6.6.4.1、简介"></a>6.6.4.1、简介</h4><p>​    OpenCV用C++语言编写，利用MMX和SSE指令，OpenCV 为Intel® Integrated Performance Primitives（IPP）提供了透明接口。意味着如果有特定处理器优化的 IPP 库，OpenCV 在运行时自动加载这些库。 </p>
<p>​    OpenCV 拥有 500 多个C函数的跨平台的中、高层 API。不依赖于其它的外部库。OpenCV 使用类BSDlicense，对非商业应用和商业应用免费（FREE）。</p>
<p>​    OpenCV的视觉处理算法丰富，部分用C语言编写，开源的特性，处理得当，不需要外部支持可以完整编译链接生成执行程序，方便算法的移植，OpenCV的代码经过适当改写可以正常的运行在DSP系统和ARM嵌入式系统中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148544.jpeg" alt="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=974700158,1979112963&amp;fm=26&amp;gp=0.jpg"></p>
<h4 id="6-6-4-2、应用"><a href="#6-6-4-2、应用" class="headerlink" title="6.6.4.2、应用"></a>6.6.4.2、应用</h4><p>​    OpenCV致力于真实世界的实时应用，通过优化C代码的编写对其执行速度带来了可观的提升，通过购买Intel的IPP高性能多媒体函数库（Integrated Performance Primitives）得到更快的处理速度。</p>
<p>​    应用领域：人机互动、物体识别、图像分割、人脸识别、动作识别、运动跟踪、机器人、运动分析、机器视觉、结构分析、汽车安全驾驶</p>
<h4 id="6-6-4-3、接口"><a href="#6-6-4-3、接口" class="headerlink" title="6.6.4.3、接口"></a>6.6.4.3、接口</h4><p>​    OpenCV其它接口是用C++接口改编的，主要接口语言也是C++语言，依然保留了大量的C语言接口。该库也有大量的Python、Java and MATLAB&#x2F;OCTAVE、GO、C#、Ch、Ruby等的接口。API接口函数通过在线文档获得。一个使用CUDA的GPU接口也于2010年9月开始实现。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148521.jpeg" alt="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1001109053,1480904686&amp;fm=26&amp;gp=0.jpg"></p>
<p>​    OpenCV可以在Windows，Android，Maemo，FreeBSD，OpenBSD，iOS，Linux 和Mac OS等平台上运行。可以在 SourceForge 获得官方版本，或者从 SVN 获得开发版本。</p>
<h4 id="6-6-4-2、OpenMP"><a href="#6-6-4-2、OpenMP" class="headerlink" title="6.6.4.2、OpenMP"></a>6.6.4.2、OpenMP</h4><p>​    OpenMP是OpenMP Architecture Review Board牵头提出的，已被广泛接受，用于共享内存并行系统的多处理器程序设计，并提供一套指导性编译处理方案(Compiler Directive) 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148438.png" alt="img"></p>
<p>​    OpenMP支持的编程语言包括C、C++和Fortran；支持OpenMp的编译器包括Sun Compiler，GNU Compiler和Intel Compiler等。</p>
<h5 id="6-6-4-2-1、简介"><a href="#6-6-4-2-1、简介" class="headerlink" title="6.6.4.2.1、简介"></a>6.6.4.2.1、简介</h5><p>​    OpenMp提供了对并行算法的专用描述，源代码中加入专用的pragma指令来指明自己的意图，由此编译器可以自动将程序进行并行化，在必要之处加入同步互斥以及通信。在进行软件开发时间，串行化到并行化是一个提高效率最有效的方法。</p>
<p>忽略这些pragma，或者编译器不支持OpenMp时，程序又可退化为串行程序，代码仍然可以正常运作，这是考虑CPU硬件不同而设定的方案，只是不能利用多线程来加速程序执行。根据硬件支持，进行单线程和多线程的处理。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148450.png" alt="img"></p>
<p>​    OpenMP对于并行描述的高层抽象降低了并行编程的难度和复杂度，程序员可以把更多的精力投入到并行算法本身，而非其具体实现细节，这样让程序员集中精力做某些事情。对基于数据分集的多线程程序设计，OpenMP是一个很好的选择，尤其对计算要求严格的地方。</p>
<p>​    OpenMP提供了更强的灵活性，可以适应不同的并行系统配置。线程粒度和负载平衡等是传统多线程程序设计中的难题，这些问题从前主要靠中间件来进行实现，或者从程序的框架角度来进行考虑。现在，把这些和兴的处理交给程序员直接接触的框架，从而提高了效率。OpenMP中，OpenMP库从程序员手中接管了部分这两方面的工作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148432.png" alt="https://pic.ikafan.com/imgp/L3Byb3h5L2h0dHAvaW1hZ2VzMC5jbmJsb2dzLmNvbS9ibG9nMjAxNS81MjI0OTAvMjAxNTA2LzI3MjExMzUwNTY0ODI3NC5wbmc=.jpg"></p>
<p>​    作为高层抽象，OpenMP不适合复杂的线程间同步和互斥的场合，这是由于OpenMp本身的结构决定的。OpenMp不能在非共享内存系统，例如计算机集群使用，如果使用，处理效果很不理想。共享内容的系统上，MPI使用较多。在项目开发过程中，技术选型非常重要。</p>
<p>​    OpenMP是作为共享存储标准而问世的。它是为在多处理机上编写并行程序而设计的一个应用编程接口。它包括一套编译指导语句和一个用来支持它的函数库。当今双核、四核的 CPU 当道，而六核的CPU也已经面世多时，所以在多处理机上编写、运行并行程序会变得相当普遍。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148459.png" alt="https://pic.ikafan.com/imgp/L3Byb3h5L2h0dHAvaW1hZ2VzMC5jbmJsb2dzLmNvbS9ibG9nMjAxNS81MjI0OTAvMjAxNTA2LzI3MjExNDQzNTgwNzM3OC5wbmc=.jpg"></p>
<h5 id="6-6-4-2-2、单线程与多线程"><a href="#6-6-4-2-2、单线程与多线程" class="headerlink" title="6.6.4.2.2、单线程与多线程"></a>6.6.4.2.2、单线程与多线程</h5><p>​    一般单线程（single thread）程序，多核心处理器没有办法提升处理效能；对于多线程（multi thread）的程序，就可以通过不同的核心同时计算，来达到加速的目的。程序员在进行开发时间，对效率要有一定的认知，如果效率较高的程序，建议进行并行程序涉及。</p>
<p>​    下面我们举例，单线程程序，一件事一次要十秒的话，要做十次，一颗核心，就是 10 秒 的 10 倍，这就是 100 秒；如果按照多线程的程序运行，可以把一件事，给两颗核心各自完成，每核心各做 5 次，时间就缩短为 50 秒，这样速度提高了1倍。</p>
<p>​    多线程的程序实际上也不简单，我们上面的计算是机械的。在工作的切割、结合上，也是要多花时间的。</p>
<p>​    现实中，在最佳状况，双核心的效能也不会是 1 + 1 &#x3D; 2 这样的理想化情况，这个仅仅是我们不考虑其它情况时间的结果。</p>
<p>​    并不是所有任务都可以切割！很多任务关键在一起，直接切割给不同的处理核心各自并行运算，出来的结果会有问题，这是安全所不能容忍的。多线程的程序在编写、维护上，比单线程的程序复杂了很多。对于效率要求不高，要求健壮性能的程序，单线程稳定还是好的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148467.png" alt="https://pic.ikafan.com/imgp/L3Byb3h5L2h0dHAvaW1hZ2VzMC5jbmJsb2dzLmNvbS9ibG9nMjAxNS81MjI0OTAvMjAxNTA2LzI3MjExNjA0NDA4MzcxOC5wbmc=.jpg"></p>
<p>​    电脑是多处理器、多核处理器，或具备IntelHyper-ThreadingTechnology 技术，代表同一个时间处理多个线程的功能，把各自独立的工作由单线程改成多线程，执行的效率上，一般是有提升的。</p>
<p>​    微软VS，提供线程控制功能。这种方法，产生多个 thread，策略如下：主线程把工作分配，子线程去然后运算，最后主线程对结果进行整理。</p>
<p>​    OpenMP 通过高阶指令，这些指令往往是对CPU指令进行调用，演化为一系列操作，这中操作在从前是不可想象的。将程序并行化、多线程化的 API，这点免去了软件工程师的大部分工作负担；并行化处理是OpenMp的核心思想，最简单情形，只加一行指令，将循环内的程序并行化处理。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148444.png" alt="https://pic.ikafan.com/imgp/L3Byb3h5L2h0dHAvaW1hZ2VzMC5jbmJsb2dzLmNvbS9ibG9nMjAxNS81MjI0OTAvMjAxNTA2LzI3MTczNjQ2ODMwNTMzMy5wbmc=.jpg"></p>
<h5 id="6-6-4-2-3、OpenMP与MPI"><a href="#6-6-4-2-3、OpenMP与MPI" class="headerlink" title="6.6.4.2.3、OpenMP与MPI"></a>6.6.4.2.3、OpenMP与MPI</h5><p>​    OpenMP 是针对共享内存并行编程的 API。与之前的 MPI 不同的是，OpenMP是线程级并行，比 MPI 的进程级并行要更轻量化一些。轻量级代表更少的改动，共享内容是解决共享的重要手段之一。</p>
<p>​    MPI 的并行需要完全重写整个程序，这点相对麻烦很多，是很多程序员排斥的。将一个串行程序改造成 OpenMP 的并行进行的改动近乎可以忽略不计。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148684.png" alt="img"></p>
<h5 id="6-6-4-2-4、应用"><a href="#6-6-4-2-4、应用" class="headerlink" title="6.6.4.2.4、应用"></a>6.6.4.2.4、应用</h5><p>​    分为Windows环境和Linux环境。</p>
<h6 id="6-6-4-2-4-1、Windows环境下开发"><a href="#6-6-4-2-4-1、Windows环境下开发" class="headerlink" title="6.6.4.2.4.1、Windows环境下开发"></a><strong>6.6.4.2.4.1、Windows环境下开发</strong></h6><p>​    在VC++中使用OpenMP，将 Project 的Properties中C&#x2F;C++里Language的OpenMP Support开启（参数为 &#x2F;openmp），就可以让VC++编译时支持OpenMP 的语法；</p>
<p>​    编写使用OpenMP 的程序时，则需要先include OpenMP的头文件：omp.h。</p>
<p>​    for 循环并行化处理，要在前面加上一行</p>
<p>​    #pragma omp parallel for</p>
<p>​    实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;STDIO.H&gt;</span><br><span class="line">#include &lt;STDLIB。H&gt;</span><br><span class="line">void Test(int n)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0; i &lt; 10000; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        //do nothing， just waste time</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d， &quot;， n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc，char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i &lt; 10; ++i)</span><br><span class="line"></span><br><span class="line">    Test(i);</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面的程序，在 main() 是一个很简单的循环，十次调用Test()这个函数，把循环的执行次数传进Test() 并打印。运行结果：</p>
<p>​    0， 1， 2， 3， 4， 5， 6， 7， 8， 9，</p>
<p>​    OpenMP main() 里平行化处理，按照如下方式进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;omp.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void Test (int n)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0; i &lt; 10000; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        //do nothing， just waste time</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d， &quot;， n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc，char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    #pragma omp parallel for</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; 10; ++i)</span><br><span class="line">        Test( i );</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    运行结果：</p>
<p>​    0， 5， 1， 6， 2， 7， 3， 8， 4， 9，</p>
<p>​    OpenMP把循环分成两部分，拆成 0 - 4， 5 - 9，不同的线程去跑，进行交错输出。</p>
<p>​    怎么确定真的有跑多线程呢，需要从硬件的角度来进行观察。如果本来有多处理器、多核心处理器或有 Hyper Thread 的话，一个单线程程序，最多只会把一颗核心的使用量吃完。</p>
<p>​    单线程的程序，工作管理员中看到CPU使用率最多是50%，说明CPU利用率低。利用 OpenMP 把循环进行平行化处理后，把两颗核心的 CPU 都用了！也就是CPU使用率提高了，可能达到100%，这就证明并行的结果。</p>
<h6 id="6-6-4-2-4-2、Linux环境"><a href="#6-6-4-2-4-2、Linux环境" class="headerlink" title="6.6.4.2.4.2、Linux环境"></a><strong>6.6.4.2.4.2、Linux环境</strong></h6><p>​    gcc 支持 OpenMP是这样的：使用gcc 编译时加上 -fopenmp 开关参数即可：</p>
<p>​    $ gcc -fopenmp &lt;source.c&gt; -o <exec></p>
<p>​    $ g++ -fopenmp &lt;source.cpp&gt; -o <exec></p>
<p>​    示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;omp。h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void hello()</span><br><span class="line">&#123;</span><br><span class="line">  int my_rank = omp_get_thread_num();</span><br><span class="line">  int thread_count = omp_get_num_threads();</span><br><span class="line">  printf(&quot;Hello from thread %d of %d\n&quot;， my_rank， thread_count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int thread_count = 4;</span><br><span class="line">  #pragma omp parallel num_threads(thread_count)</span><br><span class="line">  hello();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面代码首先增加了一个 omp。h 头文件，然后主函数中多出来一句串行代码中没有的预处理器指令，其它的跟正常的串行程序没什么区别。</p>
<p>​    # pragma 是 C&#x2F;C++ 中用以允许非 C 语言规范部分的行为，如果编译器不支持预处理器指令，那么编译时这句话就会被忽略掉。</p>
<p>​    OpenMP 依靠# pragma omp 开头的预处理器指令来进行线程级并行。预处理器指令后面加的是一些子句，用来附加额外控制信息。比如说 num_threads() 子句是用来控制接下来的代码块中需要用多少个线程进行并行。</p>
<p>​    程序编译完成之后直接打开是无法运行的，需要用 mpiexec 来调用生成好的可执行文件，mpiexec 会首先得到运行的目标机器、进程数等情况，然后启动多个进程，等到多进程全部开起来之后，并行就开始了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192148697.png" alt="img"></p>
<p>​    在 OpenMP 中，编译完成之后的可执行文件可以直接运行，程序在一开始是串行运行，到了需要并行的时候，单进程单线程会分裂成单进程多线程（其实是除了主线程以外，又启动了几个新的线程同时执行），执行完毕后又回到单线程串行。而且每次并行的线程数是可以在运行时指定的。</p>
<p>​    OpenMP 可以只把其中的一部分作并行处理，而且并行的时候共享的内存、变量等都是在一起的，从串行程序的基础上改造过来非常容易，可能只要加几段预处理器指令就可以了，剩下的交给编译器和处理器去解决。</p>
<h5 id="6-6-4-2-5、同步协作"><a href="#6-6-4-2-5、同步协作" class="headerlink" title="6.6.4.2.5、同步协作"></a>6.6.4.2.5、同步协作</h5><p>​    MPI 依靠进程间通信完成协作，OpenMP靠内存共享的解决线程写作。</p>
<p>​    OpenMP 冲突解决有四种方法：</p>
<p>A：Crirical 指令 &#x2F; 归约指令</p>
<p>​    例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line">#pragma omp parallel for num_threads(100)</span><br><span class="line">for (int i=0;i&lt;100;i++)</span><br><span class="line">&#123;</span><br><span class="line">       sum += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;%d\n&quot;， sum);</span><br></pre></td></tr></table></figure>

<p>​    运行的结果是每次运行，sum 最终结果可能是不同的。这是什么原因呢，运行时多个线程同时访问 sum 变量，可能前一个线程写上去的内容马上被下一个线程给覆盖掉了，数据共享出现了问题，即出现了数据冲突。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line">#pragma omp parallel for num_threads(100)</span><br><span class="line">for (int i=0;i&lt;100;i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    #pragma omp critical</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;， sum);</span><br></pre></td></tr></table></figure>

<p>​    加上# pragma omp critical 指令，来进行数据处理，会进行特殊的处理，编译器安排线程对下面执行的代码进行互斥访问，这是一种运行约束。每次只能够有一个线程执行下面的这一句代码。这样保证数据处理的有序与安全性能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line">#pragma omp parallel for num_threads(100) reduction(+: sum)</span><br><span class="line">for (int i=0;i&lt;100;i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;%d\n&quot;， sum);</span><br></pre></td></tr></table></figure>

<p>​    reduction(+: sum) 是归约子句，这是一个特定的写法。加上这一句，执行并行任务时，sum 本身是共享的，但这个共享和上面是不一样的，每个线程执行时会产生一个私有变量，在并行块运算结束后，系统会将私有变量的值整合，然后传递给共享变量。这样保证数据的共享性。</p>
<p>B：带命名的 critical 指令</p>
<p>​    用# pragma omp critical(name) 来命名不同的临界区。</p>
<p>​    同一个临界区的访问和上面一样，一次只有一个进程操作，保证数据的安全，不同的临界区有不同的进程进行同时访问，这样保证数据的同步。安全与同步是处理时间必须考虑的因素。</p>
<p>C：atomic 指令：</p>
<p>​    用# pragma omp atomic 的使用形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x &lt;op&gt;= &lt;expression&gt;;</span><br><span class="line">x++;</span><br><span class="line">++x;</span><br><span class="line">x--;</span><br><span class="line">--x;</span><br></pre></td></tr></table></figure>

<p>​    这些语句用 CPU 中的特殊硬件指令来实现，加快处理结果。</p>
<p>D：简单锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">omp_set_lock(&amp;lock);</span><br><span class="line">critical section</span><br><span class="line">omp_unset_lock(&amp;lock);</span><br></pre></td></tr></table></figure>

<p>​    锁住的区域只允许单个线程进行访问，保证数据安全。</p>
<h4 id="6-6-4-3、OpenACC"><a href="#6-6-4-3、OpenACC" class="headerlink" title="6.6.4.3、OpenACC"></a>6.6.4.3、OpenACC</h4><p>  OpenACC，开放式并行编程标准，程序员能够轻松利用异构 CPU&#x2F;GPU 计算系统的强大能力。和CUDA一样，是并行计算的主要平台架构。</p>
<h5 id="6-6-4-3-1、简介"><a href="#6-6-4-3-1、简介" class="headerlink" title="6.6.4.3.1、简介"></a>6.6.4.3.1、简介</h5><p>  OpenACC 为并行程序员给编译器提供简单的提示，通过指令，使编译器能够识别哪些代码部分需要加速，无需程序员修改或改编底层代码本身。简化并行编程标准，把计算任务映射到加速器这方面，指令向编译器呈现出并行机制，从而让编译器能够更好执行工作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149273.jpeg" alt="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1683434966,140585891&amp;fm=15&amp;gp=0.jpg"></p>
<p>  OpenACC 指令由 PGI、Cray 以及英伟达在 CAPS 的支持下开发而成，是多家企业希望利用指令来简化 GPU 编程模型的一个共同愿景。硬件厂商和技术协会一起，这些企业均致力于支持一种共同的编程标准。共同把并行编程技术推向前进。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149296.png" alt="img"></p>
<p>  OpenACC指令与OpenMP指令工作方式很类似，都是指令级别编程，适用于高度数据并行代码。可插入标准的C，C + +和Fortran程序直接指导编译器进行某些代码段的并行。这些并行的代码，编译器会特别注意数据在CPU和GPU（或其它）之间来回转移的逻辑关系，并将计算映射到适当的处理器上。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149279.png" alt="img"></p>
<p>  这些指令由硬件支持，不需要较大的改动，相对小的改动以标示出加速并行区域。指令设计适用于一个通用并行处理器，这样相同的代码可以运行在多核CPU、GPU或任何编译器支持的其它类型的并行硬件上。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149269.png" alt="img"></p>
<h5 id="6-6-4-3-2、发展与应用"><a href="#6-6-4-3-2、发展与应用" class="headerlink" title="6.6.4.3.2、发展与应用"></a>6.6.4.3.2、发展与应用</h5><p>  2015年7月，北京，全球视觉计算技术行业领袖NVIDIA发布了OpenACC工具套件，通过全新的套件，科学研究将可以做更多事情，并大幅提升计算效率。</p>
<p>  虽然计算核心在短时间内不会变得更快，这是硬件的制约，但处理器的并行计算能力越来越强大。这一趋势十年里一直存在，而且还会持续下去，通过软机制提高效率。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149332.png" alt="img"></p>
<p>  OpenACC已在HPC行业中得到广泛支持，简化GPU等现代处理器的并行编程。2011年Cray、PGI以及NVIDIA等领先的HPC供应商推出OpenACC编程标准以来，已有8000多名研究人员和科学家采用了这一标准。并取得了卓越的成绩，免费的标准</p>
<p>  OpenACC工具套件应用快捷，使用方便，快速对GPU编程。全新的OpenACC工具套件行业领先，获得了广泛的应用。</p>
<p>  该工具套件中，向学术开发者和研究人员免费提供这一编译器，商业用户有90天的免费试用期，黄总还是很厚道的。</p>
<p>  全新的OpenACC工具套件有一个特别的工具：NVProf Profiler，指导用户如何添加 OpenACC“指令”，会进行编译器提示，以加速代码实现。通过真实案例可以方便快捷的入门。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149302.png" alt="img"></p>
<p>  简单的指令让研究人员能够感受到并行计算，运行加速，同时不会破坏现有的CPU代码，不浪费之前所有代码编写花费的时间，这些指令与代码具有着较好的应用。</p>
<h5 id="6-6-4-3-3、硬件独立性"><a href="#6-6-4-3-3、硬件独立性" class="headerlink" title="6.6.4.3.3、硬件独立性"></a>6.6.4.3.3、硬件独立性</h5><p>  硬件独立性代表一个标准，无论对于硬件厂商或者软件厂商，对于HPC用户来说特别重要，无论软件厂商还是硬件厂商，不愿意接受那种受供应商限制的，非便携式编程环境。</p>
<p>  OpenACC的一大主要特性是高性能移植，这主要是硬件独立性的结果。PGI OpenACC编译器则把这一优势推向全新高度，让世人惊叹。该编译器首次能够在x86多核CPU和GPU上加速OpenACC代码，极大程度提高了效率。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149521.png" alt="img"></p>
<p>  没有一台配备GPU的系统时，编译器会在多个 CPU核心上完成代码并行化，进而提升性能。当系统中有GPU时，该编译器将会针对GPU做代码并行化的优化，最终与多核CPU相比可带来5~10倍的性能提升。这种提升大大提高了效率，在今天得到广泛的应用。</p>
<p>  OpenACC代码在C语言基础上进行修改，通过添加compiler directives 编译器指令(pragmas): #pragma 来标示。这个和前面介绍的有些相似。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149551.png" alt="img"></p>
<p>  cuda 中 __syncthreads()进行线程同步，目前的OpenAcc还没有线程同步机制。</p>
<p>  OpenACCDevice model</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149604.png" alt="img"></p>
<p>  OpenACCexcute model</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149618.png" alt="img"></p>
<h5 id="6-6-4-3-4、实例01—parallel-loops"><a href="#6-6-4-3-4、实例01—parallel-loops" class="headerlink" title="6.6.4.3.4、实例01—parallel loops"></a>6.6.4.3.4、实例01—parallel loops</h5><p>  第一段代码和第二段代码等效，在OpenAcc中一个parallel区域有一个单个loop组成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#pragma acc parallel loop copyin(M[0:Mh*Mw])</span><br><span class="line">copyin(N[0:Mw*Nw]) copyout(P[0:Mh*Nw])</span><br><span class="line">for (int i=0; i&lt;Mh; i++)</span><br><span class="line">&#123;</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma acc parallel copyin(M[0:Mh*Mw])</span><br><span class="line">copyin(N[0:Mw*Nw]) copyout(P[0:Mh*Nw])</span><br><span class="line">&#123;</span><br><span class="line">    #pragma acc loop</span><br><span class="line">    for (int i=0; i&lt;Mh; i++) &#123;</span><br><span class="line">    。。。</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  结果说明：</p>
<p>  copyin对应拷贝内存从host到device</p>
<p>  copyout对应拷贝内存从device到host </p>
<h5 id="6-6-4-3-5、实例02—gangs-and-workers"><a href="#6-6-4-3-5、实例02—gangs-and-workers" class="headerlink" title="6.6.4.3.5、实例02—gangs and workers"></a>6.6.4.3.5、实例02—gangs and workers</h5><p>  gangs可以类比成cuda的block；</p>
<p>  workers可以类比成thread。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#pragma acc parallel num_gangs(1024) num_workers(32)</span><br><span class="line">&#123;</span><br><span class="line">    #pragma acc loop gang</span><br><span class="line">    for (int i=0; i&lt;2048; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        #pragma acc loop worker</span><br><span class="line">        for (int j=0; j&lt;512; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            foo(i，j);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  解释：线程分配: 1024<em>32 &#x3D; 32K 个thread，两个循环题一共是执行2048</em>512 &#x3D; 1M， 每个thread执行foo()函数 1M&#x2F;32K &#x3D; 32 次。</p>
<p>  另外一个代码：</p>
<p>  结果说明：代码会分配1023*32个thread，每个gang&#x3D;1024， 对于每个gang来说执行a &#x3D;23 是冗余的，只需要执行一次即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#pragma acc parallel copyout(a) num_gangs(1024) num_workers(32)</span><br><span class="line">&#123;</span><br><span class="line">    a = 23;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  再看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma acc parallel num_gangs(32)</span><br><span class="line">&#123;</span><br><span class="line">    Statement 1;</span><br><span class="line">    #pragma acc loop gang</span><br><span class="line">    for (int i=0; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Statement 2;</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>  Statement 3;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#pragma acc loop gang</span><br><span class="line"></span><br><span class="line">for (int i=0; i&lt;m; i++)</span><br><span class="line">&#123;</span><br><span class="line">        Statement 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Statement 5;</span><br><span class="line"></span><br><span class="line">if (condition) Statement 6;</span><br></pre></td></tr></table></figure>

<p>  结果说明：从循环次数上来说，gang32个，statement2的循环次数n，statement4循环次数是m， 最终到底分配多少个thread取决于编译器，有可能m&gt;n，则分配m个，实际情况可能更加复杂。</p>
<p>  statement1， 3， 5，6 对于32gang来说是冗余的，情况和上面的相同，可以看出OpenAcc中的冗余是对于gang来说的，下面的这种写法可以消除这种冗余：取得更好的效果，在编程时间应该注意。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#pragma acc parallel num_gangs(1)</span><br><span class="line">num_workers(32)</span><br><span class="line">&#123;</span><br><span class="line">    Statement 1;</span><br><span class="line">    #pragma acc loop gang</span><br><span class="line">    for (int i=0; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Statement 2;</span><br><span class="line">    &#125;</span><br><span class="line">    Statement 3;</span><br><span class="line"></span><br><span class="line">    #pragma acc loop gang</span><br><span class="line">    for (int i=0; i&lt;m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Statement 4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Statement 5;</span><br><span class="line"></span><br><span class="line">    if (condition)</span><br><span class="line">    &#123;</span><br><span class="line">        Statement 6;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-6-4-3-6、实例03—kernel-regions"><a href="#6-6-4-3-6、实例03—kernel-regions" class="headerlink" title="6.6.4.3.6、实例03—kernel regions"></a>6.6.4.3.6、实例03—kernel regions</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#pragma acc kernels</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    #pragma acc loop num_gangs(1024)</span><br><span class="line">    for (int i=0; i&lt;2048; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #pragma acc loop num_gangs(512)</span><br><span class="line">    for (int j=0; j&lt;2048; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[j] = a[j]*2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int k=0; k&lt;2048; k++) </span><br><span class="line">    &#123;</span><br><span class="line">        d[k] = c[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  结果说明：</p>
<p>  和前面比较，区别是 acc kernel， 也就是指令不一样，前面代码用的是acc parallel。</p>
<p>  Kernel 结构主要描述程序员意图: 当前程序适合并行，编译器根据描述会有非常灵活的表现。把决定权留给编译器。</p>
<p>  编译器的参与避免了硬件的模糊性，为并行开发提供了便利。</p>
<h4 id="6-6-4-5、OpenAL"><a href="#6-6-4-5、OpenAL" class="headerlink" title="6.6.4.5、OpenAL"></a>6.6.4.5、OpenAL</h4><p>​    OpenAL，英文全称为：Open Audio Library，自由软件界的跨平台音效API，由Loki Software，主要应用是在音效缓冲和收听中编码。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149105.png" alt="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1282481439,2142315962&amp;fm=26&amp;gp=0.jpg"></p>
<p>​    OpenAL设计给多通道三维位置音效的特效表现，其 API 风格模仿自OpenGL。</p>
<p>​    Loki 倒闭以后，该开发接口，开始由自由软件&#x2F;开放源始码社群继续维护。最大的主导者是创新科技，并得到来自 Apple 和自由软件&#x2F;开放源代码爱好者的持续支援。这是今天仍在活跃的基本原因。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149116.png" alt="img"></p>
<p>​    OpenAL 主要功能是在来源物体、音效缓冲和收听者中编码。来源物体包含一个指向缓冲区的指标、声音的速度、位置和方向，以及声音强度。收听者物体包含收听者的速度、位置和方向，以及全部声音的整体增益。缓冲里包含 8 或 16 位元、单声道或立体声 PCM 格式的音效资料，表现引擎进行所有必要的计算，如距离衰减、多普勒效应等。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149120.png" alt="img"></p>
<p>​    不同于 OpenGL 规格，OpenAL 规格包含两个API分支：这是由于OpenAL的特点决定的。以实际 OpenAL 函式组成的核心，和 ALC API，ALC 用于管理表现内容、资源使用情况，并将跨平台风格封在其中。还有ALUT库，提供高阶“易用”的功能，其定位相当于 OpenGL 的 GLUT。</p>
<p>​    支持平台包括：Mac OS X、iOS、Linux、BSD、Solaris、IRIX、Windows PlayStation、Xbox等操作系统上。在如下工具中也进行广泛的应用。Blender - 3D 建模和渲染工具。Unity - 3D 游戏引擎和 IDE。Basic4gl - 编译器和编程软件。</p>
<h4 id="6-6-4-6、OpenGL"><a href="#6-6-4-6、OpenGL" class="headerlink" title="6.6.4.6、OpenGL"></a>6.6.4.6、OpenGL</h4><p>​    略（上主题已有讲述）。</p>
<h3 id="6-6-5、总结"><a href="#6-6-5、总结" class="headerlink" title="6.6.5、总结"></a>6.6.5、总结</h3><p>​    人工智能应用的广泛性，在机器视觉层面，不可能靠一套框架进行开发，未来在机器视觉、人工智能、音视频处理层面不排除有更多支持库的出现。</p>
<p>​    美摄SDK应用人工智能技术，在智能视觉、视音频领域进行着探索，为短视频技术的发展，写下浓重的一笔，</p>
<p>​    基于工业相机的软件编程。厂商提供驱动与程序示例。工程公司参考相关示例，通过算法对相机视频媒体数据进行加工分析。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149159.png" alt="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3462397246,2717035819&amp;fm=26&amp;gp=0.jpg"></p>
<p>​    机器视觉偏向于机器学习&#x2F;并行运算，运用数据挖掘技术，进行模型训练。机器视觉在硬件上往往和GPU关联，在框架支持上和大数据进行关联。</p>
<p>​    国外重点进行人工智能算法研究，人工智能方案策划，人工智能工具研发。国内重点进行工具应用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149173.png" alt="img"></p>
<p>​    目前，国内应用最多的是TensorFlow和PyTorch，来进行模型训练，导出接口，在应用层面调用。形成各种人工智能系统。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149148.jpeg" alt="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1961163947,2304056094&amp;fm=26&amp;gp=0.jpg"></p>
<p>​    视频领域的人工智能系统是视频智能应用的主要标柱，国内人工智能发展日新月异，在视频方面也有一些完善的框架与接口，为人工智能视频系统提供算法支持。</p>
<h2 id="6-8、启示"><a href="#6-8、启示" class="headerlink" title="6.8、启示"></a>6.8、启示</h2><p>​    硬件是推动软件技术发展的原动力，在硬件技术进步的基础上，智能时代为图形图像、音视频领域添加了人工智能的成分。</p>
<p>​    从图形图像角度来说，不仅是硬性参数的提升，更是对图像数据的智能修复处理。从视频角度来说，不仅仅是摄影、录制、编排硬术的提升，更是对视频数据的深度挖掘。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149908.png" alt="img"></p>
<p>​    智能修复与深度处理从前是不可想象的，当流媒体技术过渡到深度处理时，代表着人类信息加工能力的显著增强。从早期自然语言处理到今天流媒体的并行运算，代表着是技术的巨大进步。</p>
<p>​    硬件水平的进步，尤其是工业相机水平的进步，促进了高清晰领域的图形图像处理。传统相机水平的提升，必将为视频处理提供新的发展方向与发展空间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149895.png" alt="img"></p>
<p>​    机器视觉技术是智能时代的核心技术，机器视觉技术整体分为两部分。第一部分是基于工业相机的专业处理，第二部分是传统视频智能处理。</p>
<p>​    国外科技公司肩负着智能时代硬件发展的重任，推动GPU、TPU、NPU、专业相机等硬件功能提升。同时提供音视频、图形图像领域的算法验证，给出相关解决方案。</p>
<p>​    国内科技公司担负着人工智能终端应用的重任，以国外底层研发为基础，进行行业分类，市场整合，应用落地。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149919.png" alt="img"></p>
<p>​    在量子计算机发展的大背景下，不远的将来，相信技术将会发生变革，行业将会重新洗牌。人工智能的基础理论将会有翻天覆地的变化，人工智能的应用将会更深刻与广泛。今天的人工智能是量子时代的一个前走而已。真正的人工智能是量子时代人工智能。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192149904.png" alt="img"></p>
<p>​    在第四次科技革命的智能时代，黄色面孔、东方公司逐渐增多，这个沉默了200年的民族，开始重新屹立于世界民族之林。</p>
<h1 id="7、显示标准与视频处理单元"><a href="#7、显示标准与视频处理单元" class="headerlink" title="7、显示标准与视频处理单元"></a>7、显示标准与视频处理单元</h1><p>​    消费级视频智能处理大体有10年左右，有了巨大的发展，展望未来，对应于大厂而言，竞争是标准的竞争。包含显示标准与处理单元，竞争推动了科技的进步，市场的繁荣。</p>
<p>​    新的显示硬件也不断发展，GPU基础上，出现了GPGPU、TPU、NPU、VPU、APU等新的视频处理单元，相信未来有更多的数据硬件处理单元出现。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150530.png" alt="img"></p>
<p>​    人工智能还处在初级阶段，标准与规范处在变化中，随着高清晰视频硬件的出现，软件算法很多方面也面临着调整。近些年各国重视人工智能的发展，资本的投入，政策的驱动增添了人工智能发展的活力。</p>
<h2 id="7-1、显示标准"><a href="#7-1、显示标准" class="headerlink" title="7.1、显示标准"></a>7.1、显示标准</h2><p>​    多年江湖厮杀，各路显卡被赶尽杀绝，留下英伟达和AMD，·目前显卡技术的革新，主要就是A卡与N卡技术的发展。英伟达偏重人工智能，AMD偏重于GCN与APU方向。</p>
<p>​    近期倡导的显示技术有英伟达的G-Sync和AMD的Freesync 2。在介绍G-Sync的同时，有必要介绍下V-Sync。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150439.png" alt="img"></p>
<h4 id="7-1-1、V-Sync"><a href="#7-1-1、V-Sync" class="headerlink" title="7.1.1、V-Sync"></a>7.1.1、V-Sync</h4><p>​    垂直同步又称场同步（Vertical synchronization），从CRT显示器的显示原理来看，单个像素组成了水平扫描线，水平扫描线在垂直方向的堆积形成了完整的画面。</p>
<p>​    屏幕的刷新过程是每一行从左到右（行刷新，水平刷新，Horizontal Scanning），从上到下（屏幕刷新，垂直刷新，Vertical Scanning）。当整个屏幕刷新完毕，即一个垂直刷新周期完成，会有短暂的空白期，此时发出 VSync 信号。所以，VSync 中的 V 指的是垂直刷新中的垂直-Vertical。</p>
<p>​    显示器的刷新率受显卡DAC控制，显卡DAC完成一帧扫描后就会产生一个垂直同步信号。打开垂直同步指的是将该信号送入显卡3D图形处理部分，这样让显卡在生成3D图形时受垂直同步信号的制约。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150488.png" alt="img"></p>
<p>​    显示器上的图像是一线一线扫描上去的，无论隔行扫描还是逐行扫描，显示器都有2种同步参数——水平同步和垂直同步。</p>
<p>​    水平同步脉冲（Horizontal synchronization pulse， Hsync）加在两个扫描行之间。它是一个短小的脉冲，一行扫描完成之后，它就会出现，指示着这一行扫描完成，同时也指示着下一行将要开始。</p>
<p>​    水平同步脉冲出现后，会有一小段叫horizontal back porch的时间，这段时间里的像素信号不会被显示出来，过了这一小段时间之后，电子枪就开始扫描新的一行，将要显示的内容扫描到显示器上。</p>
<p>​    垂直同步脉冲（Vertical synchronization， Vsync）是加在两帧之间。跟水平同步脉冲类似，但它指示着前一帧的结束，和新一帧的开始。 垂直同步脉冲是一个持续时间比较长的脉冲，可能持续一行或几行的扫描时间，但在这段时间内，没有像素信号出现。</p>
<h4 id="7-1-2、G-Sync"><a href="#7-1-2、G-Sync" class="headerlink" title="7.1.2、G-Sync"></a>7.1.2、G-Sync</h4><p>​    G-SYNC技术可解决V-SYNC带来的取舍问题，不论画面更新率有多快，它都可以让屏幕与GPU完全同步，提供无与伦比的PC游戏体验。通过NVIDIA G-SYNC技术游戏场景可即时呈现在玩家的眼前，物件也将更清晰锐利，游戏也变得更流畅。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150522.png" alt="img"></p>
<p>​    2013年10月18日，NVIDIA editor’s day第二天，连续发布GameStream PC Game for Shield以及ShadowPlay两项重磅技术之后，NVIDIA在加拿大蒙特利尔正式发布了全新的针对画面连贯性的新技术——G-SYNC。</p>
<p>​    作为垂直同步技术的替代以及自适应垂直同步技术的延伸，G-SYNC技术不仅解决了画面撕裂问题，同时从根本上解决了困扰垂直同步技术许久的画面视觉卡顿问题。 </p>
<p>​    G-SYNC技术在显示器中内置一枚可与GeForce硬件直接通讯的芯片，这枚自带缓存的芯片可以协调显示器与GPU outputbuffer之间的数据同步。</p>
<p>​    通过G-SYNC芯片的控制，显示器的刷新延迟将可以与GPU帧输出延迟保持完全一致，支持G-SYNC技术的显示器会根据GPU当前的性能水平自动调节刷新率，</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150502.png" alt="img"></p>
<p>​    G-SYNC芯片侦测到GPU的帧输出延迟大于16ms时，它会自动延长显示器的刷新延迟，避免传统的帧丢弃导致的视觉卡顿现象。</p>
<p>​    G-Sync能够去除游戏垂直同步（VSync）开启时的画面滞后问题，也能够克服垂直同步关闭时画面失真问题。常规显示器会直接同步GPU的处理结果，借助G-Sync模块，只有当GPU完成一帧的渲染和画面优化后，显示器才会刷新显示内容。 </p>
<p>​    很多公司都推出了支持G-Sync图像增强技术的显示器,消除了屏幕撕裂和垂直同步输入延迟等影响， 增强了现有显示器功能的同时屏幕画面呈现出场景及时出现、物体更加锐利以及游戏运行更加顺畅等出色的显示效果。G-Sync能强制显示器运行在GPU的帧速率下，甚至能让原生刷新率降到更低，提供更好的视觉效果。</p>
<h4 id="7-1-3、FreeSync2"><a href="#7-1-3、FreeSync2" class="headerlink" title="7.1.3、FreeSync2"></a>7.1.3、FreeSync2</h4><p>​    FreeSync 2 是AMD力推的视觉效果增强技术，可有效消除游戏中常见的撕裂(Tearing)、卡顿(Shuttering)现象，保证画面流畅、无撕裂、无卡顿、无伪影。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150545.png" alt="img"></p>
<p>​    图像撕裂是屏幕图像看起来不连贯，这是帧速率（显示图像帧的速率）与显示器刷新率（显示器图像刷新频率）不匹配的结果。FreeSync2为显示器提供可变刷新率，即动态刷新率（VRR &#x2F; DRR）。该功能使显示器的刷新率与AMD Radeon显卡的帧速率相匹配。</p>
<p>​    FreeSync2支持高达240Hz的刷新率，具体取决于显示器。这样，可以享受显卡能够达到的最大帧速率。如果眼睛够敏锐的话，你可能会发现到输入延迟，或者鼠标移动和光标实际移动之间的延迟也降低了。FreeSync基于VESA的自适应同步协议，可以在DisplayPort和HDMI上运行。</p>
<p>​    FreeSync2支持高动态范围&amp;色域支持，低延迟、低刷新率补偿技术等。让游戏显示效果更加逼真。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150733.png" alt="img"></p>
<p>​    从HDR内容到显示器传输时需要进行Tone Mapping，这个额外的计算增加了GPU处理数据，同时增加了延时。FreeSync2取消了传输过程的转换过程，降低HDR转换带来的延迟。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150710.png" alt="img"></p>
<p>​    FreeSync2引入的另一个新功能是LFC，Low Frame Rate Compensation低刷新率补偿技术，当游戏的FPS小于显示器最低刷新率时，通过额外插帧(GPU计算，类似MEMC)，让低FPS的画面更加流畅。LFC技术的应用，即时显卡渲染FPS较低时也可以显著的改善画面流畅度，提高游戏体验。</p>
<h4 id="7-1-4、总结"><a href="#7-1-4、总结" class="headerlink" title="7.1.4、总结"></a>7.1.4、总结</h4><p>​    显示器是显示部分的前端，显示标准对显示硬件的发展起着引导的作用，显示标准的变革通过传统硬件大厂来推动，目前而论，只有NVIDIA、AMD、INTEL才有这样的实力。</p>
<p>​    显示标准对于图形图像、视频、硬件都有着紧密的联系，发展过程中，标准的改变将推动软硬件的发展。</p>
<p>​    美摄SDK，支持G-Sync、V-Sync、FreeSync2标准，支持最新显示规范，彰显短视频价值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150772.png" alt="img"></p>
<h2 id="7-2-VPU"><a href="#7-2-VPU" class="headerlink" title="7.2 VPU"></a>7.2 VPU</h2><p>   VPU(Video Processing Unit，视频处理单元）是一种全新的视频处理平台核心引擎，具有硬解码功能以及减少CPU负荷的能力。VPU可以减少服务器负载和网络带宽的消耗。</p>
<p>​    VPU由ATI提出，区别于传统GPU（Graph Process Unit，图形处理单元）。图形处理单元又包括视频处理单元、外视频模块和后处理模块这三个主要模块。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150284.png" alt="img"></p>
<h3 id="7-2-1、VPU的基础特性"><a href="#7-2-1、VPU的基础特性" class="headerlink" title="7.2.1、VPU的基础特性"></a>7.2.1、VPU的基础特性</h3><p>​    A、支持视频编解码标准类别丰富，图像高清。</p>
<p>​    B、支持多种抗误码工具、多解码和全双工多方通话同时进行。</p>
<p>​    C、提供了可编程性、柔初性，以及易于升级的解码和编码或主机接口，因为在编解码处理和主接口都实现为可编程微处理中的固件。</p>
<h3 id="7-2-2、VPU特色及应用"><a href="#7-2-2、VPU特色及应用" class="headerlink" title="7.2.2、VPU特色及应用"></a>7.2.2、VPU特色及应用</h3><p>​    VPU针对视觉处理应用而设计，在性能、功耗和功能性方面都有特别的强化，使之更贴近于实际的应用需求，其设计兼顾到多种用途，专门为视觉处理进行硬件系统的优化。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150269.png" alt="img"></p>
<p>​    VPU也是SoC，集成多个主控RISC的CPU、许多硬件加速器单元和矢量处理器阵列，专门为视觉海量像素设计的高性能影像信号处理器(ISP)，以及丰富的高速外围接口。</p>
<p>​    保证强大性能和功能的前提下，VPU采用更先进的集成电路工艺，大大缩小了芯片的尺寸，结合有效的技术手段，降低各个运算单元的功耗。</p>
<p>​    VPU为视觉应用提供了一个强大的平台，更多的开发工作是在软件上，基于VPU的视觉应用系统开发可以充分利用片上的硬件单元及相关的软件资源。</p>
<p>​    包含工具、支持库及框架的完整VPU软件开发套件(SDK)，视频处理器中涉及视觉处理的单元得到了增强，如核心视觉处理单元、线性代数运算矩阵，还有前端影像处理单元，不仅包含ISP处理，还有ISP仿真，支持相机调试工具。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150274.png" alt="img"></p>
<p>​    图形处理能力的提升表现在支持图形检测API，为便于多核异构芯片开发而支持OpenCL。由于在视觉应用中，与高敏感度和超高像素的传感器的接驳尤为重要，因此专门有传感器支持接口单元。</p>
<p>​    VPU特有的工具单元提供视觉调试全面支持。VPU中的主控制器、BSP、HDK等通用单元以开放为主，便于客户进行更多应用开发。</p>
<h3 id="7-2-3、Movidius"><a href="#7-2-3、Movidius" class="headerlink" title="7.2.3、Movidius"></a>7.2.3、Movidius</h3><p>​    作为一个行业的平台领先者需要有足够的积累和不懈的进取，当然还要有强大的财力和物力、人力的支持，VPU平台的创建和发展也绝不轻松。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150303.png" alt="img"></p>
<p>​    Movidius在都柏林成立，位于爱尔兰，在罗马尼亚，硅谷建立研发团队。公司创始人堪称半导体和处理器行业的元老，公司设立有技术指导委员会，确立公司的技术路线和VPU平台发展总体规划。</p>
<p>​    Movidius核心管理层，来源于ATI及其它知名公司资深的高管和专家。公司员工未过百人，研发人员占了九成，五分之一负责VPU芯片硬件设计，其余从事VPU上软件构建，可见VPU应用在很大程度上依赖于软件。2016年，Movidius被intel收购。</p>
<h3 id="7-2-4、INTEL"><a href="#7-2-4、INTEL" class="headerlink" title="7.2.4、INTEL"></a>7.2.4、INTEL</h3><p>​    2019年，英特尔人工智能峰会（Intel AI Summit 2019），英特尔展示了一系列新产品，旨在加速从云端到边缘的人工智能系统开发和部署，迎接人工智能浪潮的到来。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150309.png" alt="img"></p>
<p>​    英特尔展示了面向训练 (NNP-T1000) 和面向推理 (NNP-I1000) 的英特尔Nervana神经网络处理器 (NNP)。作为英特尔为云端和数据中心客户提供的首个针对复杂深度学习的专用 ASIC芯片，英特尔Nervana NNP具备超高扩展性和超高效率。</p>
<p>​    英特尔还发布了下一代英特尔Movidius Myriad视觉处理单元 (VPU)，用于边缘媒体、计算机视觉和推理应用。</p>
<h3 id="7-2-5、代码示例"><a href="#7-2-5、代码示例" class="headerlink" title="7.2.5、代码示例"></a>7.2.5、代码示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * VPUCoder.h</span><br><span class="line"> *</span><br><span class="line"> * Current, Only Support YUV420sp encoder and decoder</span><br><span class="line"> *</span><br><span class="line"> *  Created on: Dec 16, 2013</span><br><span class="line"> *      Author: henry</span><br><span class="line"> *</span><br><span class="line"> *  Example:</span><br><span class="line"> *</span><br><span class="line"> *  int main()</span><br><span class="line"> *  &#123;</span><br><span class="line"> *  int ret = InitCodec();</span><br><span class="line"> *  //===========encode video</span><br><span class="line"> *  ret = StartEnc(&quot;/sdcard/test.mkv&quot;, 1280, 720, 30);</span><br><span class="line"> *</span><br><span class="line"> *  while(1)</span><br><span class="line"> *  &#123;</span><br><span class="line"> *         //get data and length, //unsigned char* data; int length</span><br><span class="line"> *         ret = ProcessEnc(data, length);</span><br><span class="line"> *  &#125;</span><br><span class="line"> *  ret = StopEnc();</span><br><span class="line"> *</span><br><span class="line"> *  //===========decode video</span><br><span class="line"> *  ret = ProcessDec(&quot;/sdcard/test.mkv&quot;, 1280, 720);</span><br><span class="line"> *  return 0;</span><br><span class="line"> *  &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#ifndef VPUCODER_H_</span><br><span class="line">#define VPUCODER_H_</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Init encoder and decoder handle, only call once, must first call</span><br><span class="line"> *</span><br><span class="line"> * @return 0 is successful, another fail</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">int InitCodec();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * setup encoder configure</span><br><span class="line"> * @param filePath   : save file path</span><br><span class="line"> * @param enc_width  : video width</span><br><span class="line"> * @param enc_height : video height</span><br><span class="line"> * @param enc_fps    : video fps</span><br><span class="line"> *</span><br><span class="line"> * @return 0 is successful, another fail</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">int StartEnc(const char* filePath, uint32_t enc_width, uint32_t enc_height, uint32_t enc_fps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * stop encode video</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">void StopEnc();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @params data   : frame data</span><br><span class="line"> * @params length : frame length</span><br><span class="line"> *</span><br><span class="line"> * @return 0 is successful, another fail</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">int ProcessEnc(const unsigned char* data, uint32_t length);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * setup decoder configure</span><br><span class="line"> * @param filePath   : source file path</span><br><span class="line"> * @param enc_width  : video width</span><br><span class="line"> * @param enc_height : video height</span><br><span class="line"> *</span><br><span class="line"> * @return 0 is successful, another fail</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">int ProcessDec(const char* filePath, uint32_t dec_width, uint32_t dec_height);</span><br><span class="line">#endif /* VPUCODER_H_ */</span><br></pre></td></tr></table></figure>

<h3 id="7-2-6、总结"><a href="#7-2-6、总结" class="headerlink" title="7.2.6、总结"></a>7.2.6、总结</h3><p>​    GPU的概念由NVIDIA公司提出，GPU英文全称 Graphic Processing Unit，中文译为“图形处理器”。</p>
<p>​    VPU的概念由ATI公司提出，VPU英文全称 Visual Processing Unit，中文译为“视觉处理器”。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150391.png" alt="img"></p>
<p>​    GPU与VPU实际均为显示处理核心，GPU提供了更多图形接口，VPU提供了更多视频接口。2006年，ATI公司被AMD公司收购之后，已正式采用GPU的名字。</p>
<p>​    INTEL的加入，VPU近些年取得巨大的发展，社会发展中，视频处理愈来愈重要，VPU适应实时潮流，尤其在嵌入式领域应用广泛。</p>
<p>​    美摄SDK，国际领先的视频引擎，优秀的视频运算架构，引领短视频发展的方向。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150565.png" alt="img"></p>
<h2 id="7-3-APU"><a href="#7-3-APU" class="headerlink" title="7.3 APU"></a>7.3 APU</h2><p>APU是“Accelerated Processing Units”的简称，中文名字叫加速处理器，是AMD融聚未来理念的产品，它第一次将处理器和独显核心做在一个晶片上。</p>
<p>​    CPU与APU协同计算、彼此加速，具有高性能处理器和最新支持DX11独立显卡的处理性能，大幅提升电脑运行效率，实现了CPU与GPU真正的融合。APU是处理器未来发展的趋势。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150692.png" alt="img"></p>
<h3 id="7-3-1、AMD与APU"><a href="#7-3-1、AMD与APU" class="headerlink" title="7.3.1、AMD与APU"></a>7.3.1、AMD与APU</h3><p>​    从APU发展来看，AMD让CPU和GPU彻底融为一体，无论是AMD的Llano，还是Brazos，目标都是一致的。</p>
<p>​    AMD认为，CPU和GPU的融合分为四步进行：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150725.png" alt="img"></p>
<p>​    第一步：物理整合(Physical Integration)，将CPU和GPU集成在同一块硅芯片上，利用高带宽的内部总线通讯，集成高性能的内存控制器，借助开放的软件系统促成异构计算。</p>
<p>​    第二步：平台优化(Optimized Platforms)，CPU和GPU之间互连接口进一步增强，统一进行双向电源管理，GPU支持高级编程语言。</p>
<p>​    第三步：架构整合(Architectural Integration)，实现统一的CPU&#x2F;GPU寻址空间、GPU使用可分页系统内存、GPU硬件可调度、CPU&#x2F;GPU&#x2F;APU内存协同一致。</p>
<p>​    第四步：架构和系统整合(Architectural &amp; OS Integration)，主要特点包括GPU计算环境切换、GPU图形优先计算、独立显卡的PCI-E协同、任务并行运行实时整合等等。</p>
<p>​    AMD Fusion系列APU将多核(x86)中央处理器、支持DX11标准的强大独立显卡性能以及高速总线融合在一块芯片上，拥有并行处理引擎和专门高清视频加速模块，实现数据在不同处理核心间的加速传递。</p>
<p>​    基于AMD Fusion APU的台式机、笔记本和高清轻薄本已经销售多年。基于AMD Fusion APU的平板电脑和嵌入式电脑有很多优点。高清视频播放效果流畅，满足多种应用的突破性的计算能力，全面支持DX以及强大的电池续航能力。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150720.png" alt="img"></p>
<p>​    AMD通过和宏碁、华硕、戴尔、富士通、惠普、联想、微星、三星、索尼、东芝等领先PC厂商合作，在电脑上推出基于AMD Fusion APU的新品。</p>
<p>AMD公司高级副总裁Rick Bergman表示：“简而言之，我认为AMD Fusion加速处理器是自从x86架构问世之后40余年来处理器领域最伟大的进步。通过这一跨越，我们让顾客能够随时随地体验高清视频、享受    超级个人计算体验，并且让笔记本电脑具备全天的电池续航能力。这是一个全新的产品系列，全新的视角，给消费者带来全新的精彩应用体验。”</p>
<h3 id="7-3-2、VISION引擎"><a href="#7-3-2、VISION引擎" class="headerlink" title="7.3.2、VISION引擎"></a>7.3.2、VISION引擎</h3><p>​    随着硬件技术的进步，高清视频的时代到来了。从YouTube视频网站到DirectX12电脑游戏再到蓝光碟片，得到广泛应用。AMD VISION引擎横空出世，一系列与高清视频相关的独特性能将使基于AMD APU的个人电脑为用户带来更加生动与逼真的高清视频体验。</p>
<p>​    VISION引擎汇集了下列功能：</p>
<ol>
<li>支持DirectX11标准</li>
<li>强大的并行处理能力加速应用性能提升</li>
<li>AMD Radeon™ HD 6800系列显卡整合UVD3视频加速模块</li>
<li>独特的图形驱动程序，每月更新，不断提高视频性能。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150709.png" alt="img"></p>
<p>​    带有VISION引擎标识的电脑代表着更强大的性能。更流畅的上网体验；华丽、流畅、安静的高清视频播放；使标清视频播放出高清效果；将2D内容转换成更立体的3D格式；轻松高清应用；为用户带来3D游戏体验。</p>
<p>​    运算体验与软件密不可分，开发者受到CPU和GPU处理信息时各自为战进行独立计算的制约。今天，AMD Fusion APU消除了这一障碍，开发者可以利用GPU的并行处理能力。</p>
<p>​    AMD Fusion技术全天电池续航能力，续航时间长达10小时以上。单芯片设计所带来的节电效果超过我们的预料。</p>
<h3 id="7-3-3、APU新品"><a href="#7-3-3、APU新品" class="headerlink" title="7.3.3、APU新品"></a>7.3.3、APU新品</h3><p>​    锐龙7 5700G处理器采用Cezanne（塞尚）核心，与AMD路线图中一致。其最高频率大约为4.75GHz，为8核16线程，三级缓存为16MB，只有“标准版”的一半，CPU测试成绩则绝对是锐龙5000级别的，轻松压制十代酷睿和自家的锐龙3000。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150701.png" alt="img"></p>
<h3 id="7-3-4、APU编程"><a href="#7-3-4、APU编程" class="headerlink" title="7.3.4、APU编程"></a>7.3.4、APU编程</h3><p>​    APU没有设计独立的开发环境，APU目前支持OpenCL与OpenGL、DirectX等。在并行编程领域，主要支持的是OpenCL。</p>
<p>   下面是OpenCL示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;CL/cl.h&gt;</span><br><span class="line"></span><br><span class="line">const int ARRAY_SIZE = 1000;</span><br><span class="line"></span><br><span class="line">//一、 选择OpenCL平台并创建一个上下文</span><br><span class="line">cl_context CreateContext()</span><br><span class="line">&#123;</span><br><span class="line">       cl_int errNum;</span><br><span class="line">       cl_uint numPlatforms;</span><br><span class="line">       cl_platform_id firstPlatformId;</span><br><span class="line">       cl_context context = NULL;</span><br><span class="line"></span><br><span class="line">       //选择可用的平台中的第一个</span><br><span class="line">       errNum = clGetPlatformIDs(1, &amp;firstPlatformId, &amp;numPlatforms);</span><br><span class="line">       if (errNum != CL_SUCCESS || numPlatforms &lt;= 0)</span><br><span class="line">       &#123;</span><br><span class="line">              std::cerr &lt;&lt; &quot;Failed to find any OpenCL platforms.&quot; &lt;&lt; std::endl;</span><br><span class="line">              return NULL;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //创建一个OpenCL上下文环境</span><br><span class="line">       cl_context_properties contextProperties[] =</span><br><span class="line">       &#123;</span><br><span class="line">              CL_CONTEXT_PLATFORM,</span><br><span class="line">              (cl_context_properties)firstPlatformId,</span><br><span class="line">              0</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       context = clCreateContextFromType(contextProperties, CL_DEVICE_TYPE_GPU,</span><br><span class="line">              NULL, NULL, &amp;errNum);</span><br><span class="line"></span><br><span class="line">       return context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//二、 创建设备并创建命令队列</span><br><span class="line">cl_command_queue CreateCommandQueue(cl_context context, cl_device_id *device)</span><br><span class="line">&#123;</span><br><span class="line">       cl_int errNum;</span><br><span class="line">       cl_device_id *devices;</span><br><span class="line">       cl_command_queue commandQueue = NULL;</span><br><span class="line">       size_t deviceBufferSize = -1;</span><br><span class="line">       // 获取设备缓冲区大小</span><br><span class="line">       errNum = clGetContextInfo(context, CL_CONTEXT_DEVICES, 0, NULL, &amp;deviceBufferSize);</span><br><span class="line">       if (deviceBufferSize &lt;= 0)</span><br><span class="line">       &#123;</span><br><span class="line">              std::cerr &lt;&lt; &quot;No devices available.&quot;;</span><br><span class="line">              return NULL;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // 为设备分配缓存空间</span><br><span class="line">       devices = new cl_device_id[deviceBufferSize / sizeof(cl_device_id)];</span><br><span class="line">       errNum = clGetContextInfo(context, CL_CONTEXT_DEVICES, deviceBufferSize, devices, NULL);</span><br><span class="line"></span><br><span class="line">       //选取可用设备中的第一个</span><br><span class="line">       commandQueue = clCreateCommandQueue(context, devices[0], 0, NULL);</span><br><span class="line"></span><br><span class="line">       *device = devices[0];</span><br><span class="line">       delete[] devices;</span><br><span class="line">       return commandQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 三、创建和构建程序对象</span><br><span class="line">cl_program CreateProgram(cl_context context, cl_device_id device, const char* fileName)</span><br><span class="line">&#123;</span><br><span class="line">       cl_int errNum;</span><br><span class="line">       cl_program program;</span><br><span class="line"></span><br><span class="line">       std::ifstream kernelFile(fileName, std::ios::in);</span><br><span class="line">       if (!kernelFile.is_open())</span><br><span class="line">       &#123;</span><br><span class="line">              std::cerr &lt;&lt; &quot;Failed to open file for reading: &quot; &lt;&lt; fileName &lt;&lt; std::endl;</span><br><span class="line">              return NULL;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       std::ostringstream oss;</span><br><span class="line">       oss &lt;&lt; kernelFile.rdbuf();</span><br><span class="line">       std::string srcStdStr = oss.str();</span><br><span class="line">       const char *srcStr = srcStdStr.c_str();</span><br><span class="line">       program = clCreateProgramWithSource(context, 1,</span><br><span class="line">              (const char**)&amp;srcStr,</span><br><span class="line">              NULL, NULL);</span><br><span class="line"></span><br><span class="line">       errNum = clBuildProgram(program, 0, NULL, NULL, NULL, NULL);</span><br><span class="line">       return program;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建和构建程序对象</span><br><span class="line">bool CreateMemObjects(cl_context context, cl_mem memObjects[3],</span><br><span class="line">       float *a, float *b)</span><br><span class="line">&#123;</span><br><span class="line">       memObjects[0] = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,</span><br><span class="line">              sizeof(float) * ARRAY_SIZE, a, NULL);</span><br><span class="line">       memObjects[1] = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,</span><br><span class="line">              sizeof(float) * ARRAY_SIZE, b, NULL);</span><br><span class="line">       memObjects[2] = clCreateBuffer(context, CL_MEM_READ_WRITE,</span><br><span class="line">              sizeof(float) * ARRAY_SIZE, NULL, NULL);</span><br><span class="line">       return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放OpenCL资源</span><br><span class="line">void Cleanup(cl_context context, cl_command_queue commandQueue,</span><br><span class="line">       cl_program program, cl_kernel kernel, cl_mem memObjects[3])</span><br><span class="line">&#123;</span><br><span class="line">       for (int i = 0; i &lt; 3; i++)</span><br><span class="line">       &#123;</span><br><span class="line">              if (memObjects[i] != 0)</span><br><span class="line">                     clReleaseMemObject(memObjects[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       if (commandQueue != 0)</span><br><span class="line">              clReleaseCommandQueue(commandQueue);</span><br><span class="line"></span><br><span class="line">       if (kernel != 0)</span><br><span class="line">              clReleaseKernel(kernel);</span><br><span class="line">       if (program != 0)</span><br><span class="line">              clReleaseProgram(program);</span><br><span class="line">       if (context != 0)</span><br><span class="line">              clReleaseContext(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">       cl_context context = 0;</span><br><span class="line">       cl_command_queue commandQueue = 0;</span><br><span class="line">       cl_program program = 0;</span><br><span class="line">       cl_device_id device = 0;</span><br><span class="line">       cl_kernel kernel = 0;</span><br><span class="line">       cl_mem memObjects[3] = &#123; 0, 0, 0 &#125;;</span><br><span class="line">       cl_int errNum;</span><br><span class="line"></span><br><span class="line">       // 一、选择OpenCL平台并创建一个上下文</span><br><span class="line">       context = CreateContext();</span><br><span class="line"></span><br><span class="line">       // 二、 创建设备并创建命令队列</span><br><span class="line">       commandQueue = CreateCommandQueue(context, &amp;device);</span><br><span class="line"></span><br><span class="line">       //创建和构建程序对象</span><br><span class="line">       program = CreateProgram(context, device, &quot;HelloWorld.cl&quot;);</span><br><span class="line"></span><br><span class="line">       // 四、 创建OpenCL内核并分配内存空间</span><br><span class="line">       kernel = clCreateKernel(program, &quot;hello_kernel&quot;, NULL);</span><br><span class="line"></span><br><span class="line">       //创建要处理的数据</span><br><span class="line">       float result[ARRAY_SIZE];</span><br><span class="line">       float a[ARRAY_SIZE];</span><br><span class="line">       float b[ARRAY_SIZE];</span><br><span class="line">       for (int i = 0; i &lt; ARRAY_SIZE; i++)</span><br><span class="line">       &#123;</span><br><span class="line">              a[i] = (float)i;</span><br><span class="line">              b[i] = (float)(ARRAY_SIZE - i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //创建内存对象</span><br><span class="line">       if (!CreateMemObjects(context, memObjects, a, b))</span><br><span class="line">       &#123;</span><br><span class="line">              Cleanup(context, commandQueue, program, kernel, memObjects);</span><br><span class="line">              return 1;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // 五、 设置内核数据并执行内核</span><br><span class="line">       errNum = clSetKernelArg(kernel, 0, sizeof(cl_mem), &amp;memObjects[0]);</span><br><span class="line">       errNum |= clSetKernelArg(kernel, 1, sizeof(cl_mem), &amp;memObjects[1]);</span><br><span class="line">       errNum |= clSetKernelArg(kernel, 2, sizeof(cl_mem), &amp;memObjects[2]);</span><br><span class="line"></span><br><span class="line">       size_t globalWorkSize[1] = &#123; ARRAY_SIZE &#125;;</span><br><span class="line">       size_t localWorkSize[1] = &#123; 1 &#125;;</span><br><span class="line"></span><br><span class="line">       errNum = clEnqueueNDRangeKernel(commandQueue, kernel, 1, NULL,</span><br><span class="line">              globalWorkSize, localWorkSize,</span><br><span class="line">              0, NULL, NULL);</span><br><span class="line"></span><br><span class="line">       // 六、 读取执行结果并释放OpenCL资源</span><br><span class="line">       errNum = clEnqueueReadBuffer(commandQueue, memObjects[2], CL_TRUE,</span><br><span class="line">              0, ARRAY_SIZE * sizeof(float), result,</span><br><span class="line">              0, NULL, NULL);</span><br><span class="line"></span><br><span class="line">       for (int i = 0; i &lt; ARRAY_SIZE; i++)</span><br><span class="line">       &#123;</span><br><span class="line">              std::cout &lt;&lt; result[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       std::cout &lt;&lt; std::endl;</span><br><span class="line">       std::cout &lt;&lt; &quot;Executed program succesfully.&quot; &lt;&lt; std::endl;</span><br><span class="line">       getchar();</span><br><span class="line">       Cleanup(context, commandQueue, program, kernel, memObjects);</span><br><span class="line"></span><br><span class="line">       return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-5、总结"><a href="#7-3-5、总结" class="headerlink" title="7.3.5、总结"></a>7.3.5、总结</h3><p>​    APU的成功，巩固了AMD的市场，和INTEL形成有力的竞争。推动处理器技术、架构技术、并行计算技术的发展。多年以来，INTEL吊打AMD，APU的出现，这一局面得到改变。</p>
<p>​    并行计算领域，APU主要支持OpenCL技术，随着时间的推移，OpenCL技术将不断完善，驱动将不断更新。</p>
<p>​    AMD有着光辉的过去，也应该有着辉煌的明天。为处理器的发展做出了卓越的贡献。图为台湾籍AMD总裁苏姿丰女士。英伟达的黄仁勋为苏姿丰的舅舅。在芯片领域，台籍华人有着卓越的贡献。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150730.png" alt="img"></p>
<h2 id="7-4-gpgpu"><a href="#7-4-gpgpu" class="headerlink" title="7.4 gpgpu"></a>7.4 gpgpu</h2><p>  通用图形处理器（General-purpose computing on graphics processing units，简称GPGPU），利用处理图形任务的图形处理器来计算原本由中央处理器处理的通用计算任务。这些通用计算与图形处理没有关系。</p>
<p>​    现代图形处理器有强大的并行处理能力和可编程流水线，流处理器可以处理非图形数据。在面对单指令流多数据流（SIMD），且数据处理的运算量远大于数据调度和传输的需要时，通用图形处理器在性能上大大超越了传统的中央处理器应用程序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150945.png" alt="img"></p>
<h3 id="7-4-1、主要功能"><a href="#7-4-1、主要功能" class="headerlink" title="7.4.1、主要功能"></a>7.4.1、主要功能</h3><p>​    通用图形处理器是近年来出现的计算机芯片，在航空航天及防务应用中的高性能嵌入式计算中广泛应用。前一个十年里作为高端计算机游戏的图形处理引擎引入，是一种大规模并行处理器。不仅有助于复杂的浮点计算，而且容易编程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150014.png" alt="img"></p>
<p>​    通用图形处理器芯片的主要设计制造商：加利福尼亚州圣克拉拉的NVIDIA公司和加利福亚州桑尼维尔的先进微型器件公司（AMD公司）。</p>
<h3 id="7-4-2、设计优势"><a href="#7-4-2、设计优势" class="headerlink" title="7.4.2、设计优势"></a>7.4.2、设计优势</h3><p>​    通用图形处理器广泛使用，其设计支持：包括“开放性图形库”（Open Graphics Library， OpenGL）语言、NVIDIA公司创造的并行处理编程语言CUDA、最近出现的“开放性计算语言”（ Open Computing Language， OpenCL）。硬件平台的支持为软件开发提供了便利。</p>
<p>​    下图是中国天树之新推出的最新7NM GPGPU。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150926.png" alt="img"></p>
<p>​    在OpenGL，CUDA和OpenCL编程技术出现之前，大规模并行处理的编程是一项困难的任务，为数不多的专家采用极其神秘(小众编程)语言才能够完成。新出现的软件编程框架，尤其是OpenCL有助于熟悉C语言和C++语言的程序编制人员接受通用图形处理器技术。</p>
<p>​    通用图形处理器中，多个处理核规则排列在一起，随着时间的推移，器件中处理核的数量会越来越多，通用图形处理器的软件没有必要随着处理器核数量的增加而重新编写。需要有较好的编程支持。软件框架应该适应硬件设计的改变。</p>
<h3 id="7-4-3、技术原理"><a href="#7-4-3、技术原理" class="headerlink" title="7.4.3、技术原理"></a>7.4.3、技术原理</h3><p>​    富兰克林说，通用图形处理器可以用来解析事物以得到可利用的信息，传递周围环境中的有用材料。通用图形处理器所擅长的是完成两方面的工作，一是表现事物，二是解析事物。</p>
<p>​    通用图形处理器芯片的应用领域从单一的图形处理装置扩展到了信号处理装置，通用图形处理器的软件编程语言也在向着信号处理和通用处理扩展。类似于“开放性图形库”（OpenGL）那样的图形处理语言就可以用于通用处理。</p>
<p>​    通用计算技术，让显卡参与原本CPU计算任务的技术，从提出到现在十余年时间，但是发展神速。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150899.png" alt="img"></p>
<p>​    十年前，高清视频刚流行时，编码高清视频对于电脑来说，处理非常困难。视频编码过程中，大部分运算都是浮点类型的，CPU不善于做这种运算，GPU对于这种类型的计算相当拿手，计算起来量又大又快，那个年代人们在思索，能否用GPU来编码高清视频。</p>
<p>​    当时业界的研究重点转向了GPGPU，英伟达凭借着强大的技术实力，在硬件与计算机平台领域。英伟达第一个推出了一套比较完整的解决方案，将原本CPU的运算搬到了GPU之上，视频编码速度比原先快了几倍。</p>
<p>​    CPU有着通用性的需求，它上面单个核心会设计的非常大而全面，并且由于CPU计算的特性，核心中很大一部分面积用来构建缓存（一个核心中往往有L1和L2两级缓存）和控制单元（解码器与分支预测等前端单元）。CPU功能的强大，代表着CPU本身体量的大，尤其对于缓存的集中。</p>
<p>​    实际用来运算的单元面积可能仅仅只占整个核心的一半甚至不到（如图）。种种原因使CPU没有办法做非常大的规模，一个核心中能塞入的东西有限，总体的核心数需要控制在一个合理范围中，多了就会发生各种问题。硬件集成是很麻烦的事情，当工艺没有足够进步的时间，集成发展的大门就关闭了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150043.png" alt="img"></p>
<p>​    八核Coffee Lake的核心图，可以看到，四个核心的面积已经接近右边的集成GPU。而GPU的设计理念就简单很多，图形计算是一项简单直接的“粗活”，相对单调直接。复杂度远不如CPU要负责的各种各样不同类型的工作，当年想要提高图形计算速度的一个简单办法就是扩大处理器中含有的单元数量。</p>
<p>​    GPU对于特定的计算任务，有更大的计算单元，在运算能力上远超CPU，表现出来就是现在的GPU在浮点运算吞吐量上远超CPU。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150923.png" alt="img"></p>
<p>​    CPU与GPU在构造上的不同</p>
<p>​    GPU适合大批量特定计算，尤其是并行计算，几大图形软硬件厂商都推出了自己的GPGPU计算解决方案，下面主题进行介绍。</p>
<h3 id="7-4-4、支持方"><a href="#7-4-4、支持方" class="headerlink" title="7.4.4、支持方"></a>7.4.4、支持方</h3><h4 id="7-4-4-1、ATI-Stream"><a href="#7-4-4-1、ATI-Stream" class="headerlink" title="7.4.4.1、ATI Stream"></a>7.4.4.1、ATI Stream</h4><p>​    首先提出GPGPU实现的厂商是被AMD收购前的ATI，并专门提供了一套开发工具包（SDK），让程序员用该套工具调用GPU来参与计算的能力。不过由于各种限制和AMD收购ATI后支持不足，当时管理也比较混乱，这套SDK在与Nvidia CUDA的竞争中处于下风，后来AMD官方转向支持    OpenCL，这套SDK最终停止了开发。今天很少有人听到这套并行计算框架</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150205.png" alt="img"></p>
<p>​    ATI Stream Logo</p>
<h4 id="7-4-4-2、CUDA"><a href="#7-4-4-2、CUDA" class="headerlink" title="7.4.4.2、CUDA"></a>7.4.4.2、CUDA</h4><p>​    CUDA是Nvidia在G80时代推出的一项技术，也是今天最流行的技术。全称Compute Unified Device Architechture，统一计算架构。从G80核心开始，Nvidia率先采用了一种统一设计的架构，将原本管线分工式设计转变为统一化的处理器设计。</p>
<p>​    CUDA伴随着G80核心的发布一起公之于众，让程序员用C和C++来编写用GPU运行的程序，学习成本比ATI Stream要低一些。今天在并行计算集群领域，CUDA有着广泛的应用。例如TensorFlow和各种音视频引擎平台。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150197.png" alt="img"></p>
<p>​    Nvidia CUDA Logo</p>
<p>​    CUDA是目前应用最为广泛的一种GPGPU实现， Nvidia的强力推广之下，CUDA在许多领域大放异彩，今天拥有最光大的市场。英伟达曾经设计过无数成功的硬件，CUDA可以说是英伟达设计的最成功的并行计算平台。CUDA同时推动了英伟达硬件技术的应用</p>
<h4 id="7-4-4-3、OpenCL"><a href="#7-4-4-3、OpenCL" class="headerlink" title="7.4.4.3、OpenCL"></a>7.4.4.3、OpenCL</h4><p>​    上面两个GPGPU的实现都是有平台针对性的，要想用他们的解决方案你就得用AMD和英伟达的硬件，而OpenCL就不一样了。所谓Open就是一个开放的标准，但是需要各家硬件厂商为OpenCL提供驱动程序。</p>
<p>​    OpenCL最早由苹果公司开发出的异构计算框架，苹果公司将这套框架的草案提交到Khronos 组织，作为开放标准供业界使用。在2008年末，1.0版本正式公开，目前Intel、AMD与Nvidia的GPU都支持这套框架。这是除了CUDA之后，另一个流行的GPGPU计算框架。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150202.png" alt="img"></p>
<p>​    OpenCL不仅限于x86平台上提供的异构计算框架，跨平台和开放标注的特性，还可以使用专门的可编程电路来加速计算。有广泛的支持空间，业界对于它的支持非常广泛，下图是OpenCL联盟成员。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150253.png" alt="img"></p>
<p>​    OpenCL联盟</p>
<h4 id="7-4-4-4、DirectCompute"><a href="#7-4-4-4、DirectCompute" class="headerlink" title="7.4.4.4、DirectCompute"></a>7.4.4.4、DirectCompute</h4><p>​    微软是软件行业的老大，在并行计算领域，微软也在进行积极的探索。DirectCompute是微软从DirectX 10开始加入的用于通用计算目的的API集，调用GPU进行加速计算。</p>
<p>​    从Vista开始，Windows的各种桌面特效就开始采用DirectCompute来加速计算。在DirectX 11中，微软完善了这套API，并且在Windows系统上更多地使用GPU来加速计算系统界面的各种特效。</p>
<p>​    不仅仅是专业的图形图像、音视频领域，在操作系统领域，对并行计算的要求也很好。当我们在使用微软的VS技术时间，VS技术的一大技术支柱就是并行计算技术。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150332.png" alt="img"></p>
<p>​    GPU-Z显示该GPU支持的通用计算特性</p>
<h3 id="7-4-5、媒体编码加速"><a href="#7-4-5、媒体编码加速" class="headerlink" title="7.4.5、媒体编码加速"></a>7.4.5、媒体编码加速</h3><p>​    十年前，H.264等面向高清应用的视频编码刚流行，CPU的性能限制，编码一段H.264的视频是一件相当耗费时间的事情，所以人们想到了用GPU来加速视频的编码。</p>
<p>​    Nvidia刚推出CUDA的时候，就将加速视频编码作为该技术的一大卖点，免费提供了一个支持CUDA技术来转码的软件BadaBoom。后来，Nvidia在显卡上加入了专门用于视频编解码的硬件电路，开放了名为NVENC的编码API供软件工程师调用，通用计算也就此离开了这个距离我们最近的领域。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150434.png" alt="img"></p>
<p>​    BadaBoom加速视频转码</p>
<p>​    Adobe是图形图像、音视频技术的霸主。很早就在旗下的CS和CC软件中加入了GPGPU的支持，Premiere Pro和After Effect都支持OpenCL来加速视频实时预览和特效。Adode对并行计算技术的应用走在各家公司前列。</p>
<h3 id="7-4-6、视频补帧与画面优化"><a href="#7-4-6、视频补帧与画面优化" class="headerlink" title="7.4.6、视频补帧与画面优化"></a>7.4.6、视频补帧与画面优化</h3><p>​    英伟达、英特尔和AMD三家相继在自己的GPU中加入专用计算电路用以加速编解码视频之后，通用计算就离开了这个领域。不满足于既有的视频品质的人们，又相继开发出了新的可以利用GPGPU的功能：视频补帧。大大改善了视频质量。</p>
<p>​    视频补帧：是原本低帧数的视频，通过上下帧的计算，渲染出一帧原本不存在的画面补在两帧之间，使其观感更加流畅。</p>
<p>​    比如将24帧的视频补帧至60帧，视频质量圆润流畅。因为这个过程计算量过于庞大，使用CPU跟不上视频播放的速度，没法做到实时补帧，开发者就将这个功能搬到了GPU上来运行，很多人都曾经使用的SVP4，就是一个利用GPGPU的补帧软件。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150467.png" alt="img"></p>
<p>​    SVP4补帧软件界面</p>
<p>​    科技发展永无止境，视频技术也不例外。视频画面优化领域，强大的视频渲染器MadVR也是利用GPGPU来优化视频画面。</p>
<p>​    比如视频播放中出现的色带、色环，在压制过程中出现的瑕疵等，可以使用GPGPU在视频播放过程中进行实时的弥补。使视频更加圆润与高清，视频技术的发展永无止境。</p>
<h3 id="7-4-7、人工智能与深度学习"><a href="#7-4-7、人工智能与深度学习" class="headerlink" title="7.4.7、人工智能与深度学习"></a>7.4.7、人工智能与深度学习</h3><p>​    人工智能与深度学习是近年来非常热门的两个有关联的领域，训练人工智能需要非常大的数据计算量，这时候就可以利用上GPU的强大功能，谷歌的深度学习框架TensorFlow，以及FaceBook的Pytorch就使用CUDA来加速学习。</p>
<p>​    Nvidia这两年不断展示了它们在机器学习方面的一些结果，在RTX系列上引入的DLSS（深度学习抗锯齿）技术就是利用机器学习来达成的。</p>
<p>​    英伟达今天在人工智能领域占据着重要的位置，在科技发展过程中，很多公司靠软件驱动技术发展，英伟达靠硬件驱动技术的发展。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150471.png" alt="img"></p>
<p>​    DLSS技术</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150487.png" alt="img"></p>
<p>​    上图是CUDA在科研领域的一些应用，可以看到GPU就在我们的身边。</p>
<h3 id="7-4-8、超级计算机"><a href="#7-4-8、超级计算机" class="headerlink" title="7.4.8、超级计算机"></a>7.4.8、超级计算机</h3><p>​    英伟达在G80开始就推出同架构的高品质计算卡，Tesla品牌之下。诞生了很多用Tesla计算卡来组建的超级计算机。硬件技术的优势，导致英伟达在超算领域领跑全球。</p>
<p>​    人工智能是英伟达的发展方向，相信近几年，使用英伟达技术的计算机会逐渐增多。会曾经竞争贝尔·戈登奖的六个入围者中，五个使用了NVIDIA GPU提供支持的超级计算机。</p>
<p>​    英伟达联手ARM，在超级计算机领域中继续发力，预计未来采用GPGPU技术的超级计算机将会越来越多。</p>
<p>​    近些年，超级计算机硬件领域，英伟达有着强大的技术实力。在云平台上，英伟达超级计算硬件应用较多。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150578.png" alt="img"></p>
<p>​    GPGPU相对于PC，是新的概念，十余年的发展已经不仅局限于PC，还走向了其它领域，扎根于我们生活的每个角落。GPGPU已经在许多云计算平台上得到了应用，相信在以后，GPU会更加深入生活的更多方面，尤其与人工智能技术的结合，具有着巨大的应用空间。</p>
<h3 id="7-4-9、示例代码"><a href="#7-4-9、示例代码" class="headerlink" title="7.4.9、示例代码"></a>7.4.9、示例代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;CL/cl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &quot;tool.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/** convert the kernel file into a string */</span><br><span class="line">int convertToString(const char *filename, std::string&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    size_t size;</span><br><span class="line">    char*  str;</span><br><span class="line">    std::fstream f(filename, (std::fstream::in | std::fstream::binary));</span><br><span class="line"></span><br><span class="line">    if(f.is_open())</span><br><span class="line">    &#123;</span><br><span class="line">        size_t fileSize;</span><br><span class="line">        f.seekg(0, std::fstream::end);</span><br><span class="line">        size = fileSize = (size_t)f.tellg();</span><br><span class="line">        f.seekg(0, std::fstream::beg);</span><br><span class="line">        str = new char[size+1];</span><br><span class="line">        if(!str)</span><br><span class="line">        &#123;</span><br><span class="line">            f.close();</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f.read(str, fileSize);</span><br><span class="line">        f.close();</span><br><span class="line">        str[size] = &#x27;\0&#x27;;</span><br><span class="line">        s = str;</span><br><span class="line">        delete[] str;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;Error: failed to open file\n:&quot;&lt;&lt;filename&lt;&lt;endl;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**Getting platforms and choose an available one.*/</span><br><span class="line">int getPlatform(cl_platform_id &amp;platform)</span><br><span class="line">&#123;</span><br><span class="line">    platform = NULL;//the chosen platform</span><br><span class="line"></span><br><span class="line">    cl_uint numPlatforms;//the NO. of platforms</span><br><span class="line">    cl_int    status = clGetPlatformIDs(0, NULL, &amp;numPlatforms);</span><br><span class="line">    if (status != CL_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Error: Getting platforms!&quot;&lt;&lt;endl;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**For clarity, choose the first available platform. */</span><br><span class="line">    if(numPlatforms &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        cl_platform_id* platforms =</span><br><span class="line">            (cl_platform_id* )malloc(numPlatforms* sizeof(cl_platform_id));</span><br><span class="line">        status = clGetPlatformIDs(numPlatforms, platforms, NULL);</span><br><span class="line">        platform = platforms[0];</span><br><span class="line">        free(platforms);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**Step 2:Query the platform and choose the first GPU device if has one.*/</span><br><span class="line">cl_device_id *getCl_device_id(cl_platform_id &amp;platform)</span><br><span class="line">&#123;</span><br><span class="line">    cl_uint numDevices = 0;</span><br><span class="line">    cl_device_id *devices=NULL;</span><br><span class="line">    cl_int    status = clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, 0, NULL, &amp;numDevices);</span><br><span class="line">    if (numDevices &gt; 0) //GPU available.</span><br><span class="line">    &#123;</span><br><span class="line">        devices = (cl_device_id*)malloc(numDevices * sizeof(cl_device_id));</span><br><span class="line">        status = clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, numDevices, devices, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    return devices;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-10、总结"><a href="#7-4-10、总结" class="headerlink" title="7.4.10、总结"></a>7.4.10、总结</h3><p>​    GPGPU，带CPU处理能力的GPU。主要是GPU的工作，GPU的能力，可以协助CPU进行运算力，GPGPU（通用图形处理）超出GPU的能力范围，完全具备通用的数据处理。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150634.png" alt="img"></p>
<p>​    GPU，用于图形处理的芯片。（GPU也是一种CPU，相对于显卡）早期显卡是没有专门用做图形处理的GPU的，不支持3D。</p>
<p>​    CPU，用于数据处理的芯片（图形也可以认为是数据）。中央处理器，一种相对的概念。潜移默化被认定是放在主板上，通过向GPU传送指令，控制GPU。</p>
<p>​    AMD-APU，加速处理器。集成GPU核心的CPU，并且融合。不同于Intel I系（GPU与CPU独立工作）。</p>
<p>​    美摄SDK，采用CUDA、OpenCL、DirectCompute并行计算技术。基于CPU、GPU、GPGPU硬件平台，优秀的音视频引擎，推动音视频技术发展。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150707.png" alt="img"></p>
<h2 id="7-5-TPU"><a href="#7-5-TPU" class="headerlink" title="7.5 TPU"></a>7.5 TPU</h2><p>  TPU（Tensor Processing Unit）张量处理单元，为机器学习定制的芯片，经过专门深度机器学习方面的训练，它有更高效能（每瓦计算能力）。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150029.png" alt="img"></p>
<p>​    谷歌，2015年6月，I&#x2F;O开发者大会上推出的计算神经网络专用芯片，为优化自身的TensorFlow机器学习框架而打造，主要用于AlphaGo系统，谷歌地图、谷歌相册和谷歌翻译等应用中。进行搜索、图像、语音等模型和技术的并行处理。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150999.png" alt="img"></p>
<h3 id="7-5-1、TPU发展史"><a href="#7-5-1、TPU发展史" class="headerlink" title="7.5.1、TPU发展史"></a>7.5.1、TPU发展史</h3><p>​    2016 年，AlphaGo以4:1总分打败围棋世界冠军李世石，随后独战群雄，在与排名世界第一围棋的冠军柯洁对战胜利后宣布“隐退江湖”，背后的芯片开启了芯片产业的新篇章。</p>
<p>​    地覆天翻的四年，AI芯片领域，尤其是云端AI芯片，市场规模一路扶摇直上，成为芯片巨头和新势力虎视眈眈之地。</p>
<p>​    赛迪2019年8月发布的《中国人工智能芯片产业发展白皮书》，2018年全球云端AI芯片市场规模为62.1亿美元，这一数值预计在2021年达到221.5亿美元，巨大的市场将如火山爆发般呈现在众人眼前，芯片制造的高光时刻到来了。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150983.png" alt="img"></p>
<p>​    这片蓝海中，有一个角色起到了划时代的意义，它就是谷歌TPU（Tensor Processing Unit，张量处理单元）。</p>
<p>​    与李世石、柯洁，以及中日韩数十位围棋高手的围棋对战中脱颖而出后，谷歌TPU曾一路狂飙突进，独步天下，现在已演进到了第四代。它的出现，无疑打破了GPU、GPGPU曾一度称霸神经网络推理和训练市场的局面。在大数据、人工智能领域，谷歌的王者之风逐渐显现。</p>
<p>​    2019年5月，谷歌I&#x2F;O开发者大会上，万众瞩目的第四代TPU意外缺席，取而代之的是以1000个TPUv3组成的TPUv3 Pod，以及边缘AI芯片Edge TPU。即便如此，它仍通过一定程度的对外开放，以及辅助谷歌内部服务器应用深刻地影响着云端AI芯片市场。那次大会，后知后觉的人们意识到，谷歌卖的是方案与思想，谷歌已经脱离了技术。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150023.png" alt="img"></p>
<p>​    从市场角度看，未来云端AI芯片巨大的发展潜力和市场机遇为谷歌TPU提供了肥沃的土壤；另一方面，紧迫的算力瓶颈和摩尔定律放缓等问题也越来越难以忽视。谷歌属于未来科技公司，有无穷的可能。</p>
<h4 id="7-5-1-1、始于算力瓶颈，首秀人类围棋界"><a href="#7-5-1-1、始于算力瓶颈，首秀人类围棋界" class="headerlink" title="7.5.1.1、始于算力瓶颈，首秀人类围棋界"></a>7.5.1.1、始于算力瓶颈，首秀人类围棋界</h4><p>​    区别于GPU、GPGPU，谷歌TPU是一种ASIC芯片方案。ASIC全称为Application-Specific Integrated Circuit（应用型专用集成电路），是专为某种特定应用需求而定制的芯片。但一般来说，ASIC芯片的开发不仅需要花费数年的时间，且研发成本也极高，一直是个别公司的阵地。</p>
<p>​    对于数据中心机房中AI工作负载的高算力需求，许多厂商更愿意继续采用现有的GPU集群或GPU+CPU异构计算解决方案，也甚少在ASIC领域冒险。但谷歌说不了。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150008.png" alt="img"></p>
<p>​    谷歌2006年起产生了要为神经网络研发一款专用芯片的想法，而这一需求在2013年也开始变得愈发急迫。谷歌这家超前的公司，在未雨绸缪。当时，谷歌提供的谷歌图像搜索、谷歌照片、谷歌云视觉API、谷歌翻译等多种产品和服务，都需要用到深度神经网络。</p>
<p>​    庞大的应用规模下，谷歌意识到，夜以继日运行的数百万台服务器，它们内部快速增长的计算需求，使得数据中心的数量需要再翻一倍才能得到满足。然而，从成本还是从算力上看，内部中心已不能依靠GPU和CPU来维持。制造芯片的冲动变成了现实。</p>
<p>​    种种因素的推动下，不差钱的谷歌正式开始了TPU的研发之旅。经过研发人员15个月的设计、验证和构建，TPU 2014年研发完成，率先部署在谷歌内部的数据中心。谷歌强大的财力保证了研发的成功，成功很大程度源于不差钱。</p>
<p>​    内部秘密运行了一年外，谷歌TPU还在围棋界“大杀四方”，斩获“人机大战”的神话。在今天，谷歌还有多少技术，还装在黑匣子中呢？</p>
<p>​    使用TPU之前，AlphaGo内置1202个CPU和176个GPU击败欧洲冠军范惠。2015年与李世石对战时，AlphaGo才开始使用TPU，而当时部署的TPU数量，只有48个。TPU大开杀戒，进入无人之境。</p>
<p>​    这场对战胜利的“秘密武器”也在一年后的谷歌I&#x2F;O开发者大会上被揭开神秘面纱，TPU正式面世。在技术上，谷歌隐藏的太深。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150990.png" alt="img"></p>
<h4 id="7-5-1-2、谷歌TPU的迭代、云端构建、终端应用"><a href="#7-5-1-2、谷歌TPU的迭代、云端构建、终端应用" class="headerlink" title="7.5.1.2、谷歌TPU的迭代、云端构建、终端应用"></a>7.5.1.2、谷歌TPU的迭代、云端构建、终端应用</h4><p>​    面世后短短两年，谷歌TPU已经迭代到了第四代，性能亦不断跃升。随着研发的投入和广泛应用，谷歌也逐步推出可扩展云端超级计算机TPU Pod，以及Edge TPU。谷歌最终目的是超算领域与人工智能。今天，谷歌与英伟达成为超算领域的头狼。    </p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>发布日期</strong></th>
<th><strong>性能</strong></th>
<th><strong>应用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>TPU V1</td>
<td>2016年</td>
<td>28nm 功耗40w，主频700MHZ</td>
<td>深度学习推理</td>
</tr>
<tr>
<td>TPU V2</td>
<td>2017年</td>
<td>180TFLOPs浮点运算、64GB高带宽内存(HBM)</td>
<td>机器学习训练和推理，开始在Google Compute Engine上运行，以用于TensorFlow应用程序</td>
</tr>
<tr>
<td>TPU V3</td>
<td>2018年</td>
<td>420TFLOPs浮点运算，128GB(HBM)</td>
<td>扩展至更广泛的深度学习训练和推理领域，已进入Alpha测试阶段。</td>
</tr>
<tr>
<td>EDGE TPU</td>
<td>2018年</td>
<td>内建EDGE TPU、网络功能和加密芯片，具有高吞吐量。</td>
<td>企业中的机器学习任务而设计，主要执行AI推理。</td>
</tr>
<tr>
<td>TPU V2 POD</td>
<td>2019年</td>
<td>每秒11.5千万亿次浮点运算，4TB (HBM)、环面网状网络</td>
<td>深度学习领域</td>
</tr>
<tr>
<td>TPU V3 POD</td>
<td>2019年</td>
<td>每秒100千万亿次浮点运算、32TB(HBM)，环面网状网络。</td>
<td>深度学习领域</td>
</tr>
</tbody></table>
<h5 id="7-5-1-2-1、2016年：第一代TPU"><a href="#7-5-1-2-1、2016年：第一代TPU" class="headerlink" title="7.5.1.2.1、2016年：第一代TPU"></a>7.5.1.2.1、2016年：第一代TPU</h5><p>​    为神经网络而研发，但谷歌最初的第一代TPU仅用于深度学习推理。从性能上看，第一代谷歌TPU采用了28nm工艺制造，功耗约为40W，主频700MHz。</p>
<p>​    研发之初，谷歌需要尽快将TPU部署到内部现有的服务器中，因此研发人员选择将处理器打包成外部加速卡，以插入SATA硬盘插槽后进行嵌入式安装。毫无疑问的是，这种设计是成功的，并很快投入了应用。</p>
<p>​    TPU通过PCIe Gen3 x16总线连接到主机，实现了12.5GB&#x2F;s的有效带宽。除了在AlphaGo上应用之外，谷歌第一代TPU还用于谷歌的搜索、翻译和相册等应用的机器学习模型中。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150272.png" alt="img"></p>
<p>​    ▲Google第一代TPU（左），在谷歌数据中心中部署的TPU（右）</p>
<h5 id="7-5-1-2-2、2017年：第二代TPU，引入Google-Cloud"><a href="#7-5-1-2-2、2017年：第二代TPU，引入Google-Cloud" class="headerlink" title="7.5.1.2.2、2017年：第二代TPU，引入Google Cloud"></a>7.5.1.2.2、2017年：第二代TPU，引入Google Cloud</h5><p>​    一年更新、研发和迭代，谷歌在2017年5月发布了第二代TPU，并从这一代起能够用于机器学习模型的训练和推理。</p>
<p>​    与第一代相比，第二代TPU实现180TFLOPs浮点运算的计算能力，同时其高带宽内存（HBM）也提升到了64GB，解决了第一代TPU内存受带宽限制的问题。电子硬件的发展堪称神速。</p>
<p>​    运行AI工作负载上，谷歌第二代TPU与同期的CPU、GPU相比，性能比传统的GPU高了15倍，比CPU高了30倍，每瓦性能亦提高了30至80倍。硬件有强大的提升空间，保障谷歌思想的实现。</p>
<p>​    从第二代TPU起，谷歌第二代TPU引入Google Cloud，应用在谷歌计算引擎（Google Compute Engine ，简称GCE）中，也称为Cloud TPU，进一步优化谷歌搜索引擎、Gmail、YouTube和其他服务的运行。谷歌通过K8S进行云端软件技术处理，TPU提供硬件保障。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150286.png" alt="img"></p>
<p>​    同时，Cloud TPU通过TensorFlow进行编程，并与CPU、GPU及基础设施和服务结合，以根据用户应用需求构建和优化机器学习系统。谷歌在云上的技术铺垫深厚，谷歌未来的主战场是云端。</p>
<p>​    谷歌第二代TPU的发布，新一轮的人机大战也再次揭开序幕。而这一代AlphaGo的芯片配置，仅用了4块TPUv2，击败当时的世界围棋冠军柯洁。</p>
<p>​    谷歌除了推出第二代TPU外，还宣布计划研发可扩展云端超级计算机TPU Pods，通过新的计算机网络将64块Cloud TPU相结合，能够提供约11500万亿次浮点运算能力。强大的运算能力为谷歌平台提供了技术保障。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150307.png" alt="img"></p>
<h5 id="7-5-1-2-3、2018年：第三代TPU，边缘AI芯片Edge-TPU"><a href="#7-5-1-2-3、2018年：第三代TPU，边缘AI芯片Edge-TPU" class="headerlink" title="7.5.1.2.3、2018年：第三代TPU，边缘AI芯片Edge TPU"></a>7.5.1.2.3、2018年：第三代TPU，边缘AI芯片Edge TPU</h5><p>​    2018年5月，谷歌不出意外地发布了第三代TPU，其各方面性能不仅实现了升级，也进一步扩展到更广泛的深度学习训练和推理领域。我们怀疑的是，第三代TPU应该在2017年研发完成。</p>
<p>​    谷歌表示，第三代TPU的性能均是第二代TPU的两倍，可实现420TFLOPs浮点运算，以及128GB的高带宽内存。同时，它还可部署在基于云计算的超级计算机TPU Pod中，其中的芯片数量是上一代的四倍。这些数据表明，微电子技术的发展方兴未艾。</p>
<p>​    与第二代TPU Pod的部署相比，第三代每个Pod的性能提高了8倍，且每个Pod最多拥有1024个芯片。这些TPU的集群，形成了强大的狼群并行处理能力。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150437.png" alt="img"></p>
<p>​    谷歌2018年发布了用于边缘推理的微型AI加速芯片——Edge TPU，专为企业机器学习任务而设计，用于IoT设备中。市场是细分的，技术必须根据市场变动。</p>
<p>​    Edge TPU同样是一款ASIC芯片。从应用上看，它与Cloud TPU相互补，用户能够先使用Cloud TPU对机器学习模型进行加速训练，再将训练好的模型放入相关设备中，进一步用Edge TPU进行机器学习推理。TPU的芯片向纵深发展。</p>
<p>​    据了解，Edge TPU能够让IoT设备以每秒30帧以上的速度，在高分辨率视频上运行多个先进的计算机视觉模型。数据处理重要的一部分是计算机视觉，谷歌TPU这种技术，很可能在未来的某一天，这些硬件产品出现在我们身边。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150332.png" alt="img"></p>
<p>​    谷歌还为Edge TPU推出了一套名为Cloud IoT Edge的软件平台，该平台拥有Edge IoT Core和Edge ML两大主要组件，能够帮助用户将在Google Cloud上构建和训练的机器学习模型，通过Edge TPU扩展到边缘设备中运行。技术的开源是未来的发展趋势，软件平台的出现，为谷歌技术的推广推波助澜。</p>
<h5 id="7-5-1-2-4、2019年：第二-三代TPU-Pod"><a href="#7-5-1-2-4、2019年：第二-三代TPU-Pod" class="headerlink" title="7.5.1.2.4、2019年：第二&#x2F;三代TPU Pod"></a>7.5.1.2.4、2019年：第二&#x2F;三代TPU Pod</h5><p>​    这一年谷歌并未发布第四代TPU，却上演了另一个重头戏——发布第二代和第三代TPU Pod，可以配置超过1000颗TPU。强大的集群带来了强大的性能，在硬件技术突破的同时，谷歌在软件集群技术上也在进行着发展。</p>
<p>​    作为TPU的“升级版”，谷歌第二代TPU Pod能够容纳512个内核，实现每秒11.5千万亿次浮点运算；第三代TPU Pod速度则更快，可实现每秒超过100千万亿次浮点运算。这次升级之后，我们期待着谷歌新一代TPU的发布，相信带来更强大的性能。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150336.png" alt="img"></p>
<p>​    据悉，在相同配置（265块TPU）下训练ResNet-50模型时，第二代TPU Pod需要11.3分钟，而第三代TPU Pod只需7.1分钟。这些数据的背后，是TPU集群快速增长的结果。让我们很难想象的是，谷歌TPU在集群技术路上还能走多远。</p>
<h4 id="7-5-1-3、架构创新，掀起云端造芯大浪潮"><a href="#7-5-1-3、架构创新，掀起云端造芯大浪潮" class="headerlink" title="7.5.1.3、架构创新，掀起云端造芯大浪潮"></a>7.5.1.3、架构创新，掀起云端造芯大浪潮</h4><p>​    谷歌TPU系列芯片的出现，不仅突破了最初深度学习硬件执行的瓶颈，还在一定程度上撼动了英伟达、英特尔等传统GPU芯片巨头的地位。英伟达、AMD、INTEL在PC市场上这些传统霸主地位受到了挑战。</p>
<p>​    2015年以来，与AI芯片相关的研发逐渐成为整个芯片行业的热点，在云端的深度学习训练和推理领域，已然不是GPU，尤其是英伟达独霸一方。</p>
<p>​    谷歌TPU的诞生，越来越多的公司前赴后继地尝试设计GPU之外的专用AI芯片，进一步实现更高效的性能。这是一条成功的路线，科技巨头都在进行着尝试。</p>
<p>​    技术层面看，谷歌TPU的出现在架构创新上也为行业带来了以下思考。这种影响，在未来几十年将会深刻的感受到。</p>
<h5 id="7-5-1-3-1、大规模片上内存"><a href="#7-5-1-3-1、大规模片上内存" class="headerlink" title="7.5.1.3.1、大规模片上内存"></a>7.5.1.3.1、大规模片上内存</h5><p>​    谷歌看来，片外内存低是GPU能效比低的主要原因。一些GPU由于片上内存较少，因此在运行过程中需要不断地去访问片外动态随机存取存储器（DRAM），从而在一定程度上浪费了不必要的能耗。在从前，关于CPU与GPU上的内存是争论的喋喋不休的话题，在功耗等各方面都有考量。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150499.png" alt="img"></p>
<p>​    因此，谷歌在最初设计TPU时，总共设计了占总芯片面积37%的内存，其中包括24MB的局部内存、6MB的累加器内存，以及用于与主控处理器对接的内存。谷歌反其道而行之，用功耗换取效率。</p>
<h5 id="7-5-1-3-2、用量化技术进行整数运算"><a href="#7-5-1-3-2、用量化技术进行整数运算" class="headerlink" title="7.5.1.3.2、用量化技术进行整数运算"></a>7.5.1.3.2、用量化技术进行整数运算</h5><p>​    一般来说，神经网络的预测并不需要32位或16位的浮点计算精度，因此它可以通过8位低精度运算的方法，在保证适当准确度的同时，对神经网络进行预测。这种精细化的设计，适应了神经网络技术的需求。</p>
<p>​    通过量化技术，神经网络预测的成本大大减少，相应减少了内存的使用。例如，当研发人员将量化应用于流行的图像识别模型Inception时，芯片内存从91MB压缩到了23MB，约为其原始大小的四分之一。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150592.png" alt="img"></p>
<p>​    人工智能时代每一种算法数据都有自己的特点，神经网络作为人工智能的主流算法，有自己的计算特点，谷歌深谙此道，并对硬件改进，取得了GPU的成功。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150581.png" alt="img"></p>
<h5 id="7-5-1-3-3、可编程性"><a href="#7-5-1-3-3、可编程性" class="headerlink" title="7.5.1.3.3、可编程性"></a>7.5.1.3.3、可编程性</h5><p>​    虽然谷歌TPU是ASIC芯片，但却与FPGA又有些类似，它具备一定的可编程性能力。谷歌看来，TPU的研发并非只用于运行一种神经网络模型。因此，谷歌选择采用了复杂指令集（CISC）作为TPU指令集的基础，能够较为侧重地运行更复杂的任务。软硬件技术的结合是TPU成功的关键因素。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150636.png" alt="img"></p>
<p>​    谷歌还定义了十二个专门为神经网络推理而设计的高级指令，能够在输入数据和权重之间执行矩阵乘法，并应用激活函数。今天，国内的学习是从指令开始起步。</p>
<p>​    为了能进一步对TPU进行编程，谷歌还创建了一个编译器和软件堆栈，能够调用TensorFlow图中的API，转化成TPU指令。TPU与TensorFlow的融合，让TPU开始接底气，并为TensorFlow做大规模的神经网络数据训练打下基础。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150632.png" alt="img"></p>
<h5 id="7-5-1-3-4、并行计算"><a href="#7-5-1-3-4、并行计算" class="headerlink" title="7.5.1.3.4、并行计算"></a>7.5.1.3.4、并行计算</h5><p>​    谷歌为TPU设计了矩阵乘法单元（MXU）的并行计算。并行计算是数据发展的要求，今天并行计算是人工智能面临的第一个问题。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150715.png" alt="img"></p>
<p>​    它能够在一个时钟周期内处理数十万次矩阵运算，相当于一次打印一个字符、一次打印一行字或一次打印一页文档。这种高效的形式，是成功的关键因素所在。</p>
<h5 id="7-5-1-3-5、脉动阵列设计"><a href="#7-5-1-3-5、脉动阵列设计" class="headerlink" title="7.5.1.3.5、脉动阵列设计"></a>7.5.1.3.5、脉动阵列设计</h5><p>​    MXU具有与传统CPU和GPU截然不同的架构，又称为脉动阵列（systolic array）。不同硬件设计带来的效果是惊人的。</p>
<p>​    脉动阵列使得在每次运算过程中，谷歌TPU能够将多个运算逻辑单元（ALU）串联在一起，并复用从一个寄存器中都取得结果。脉动阵列设计形式，大大提高了效率。</p>
<p>​    这种设计，不仅能够将数据复用实现最大化，减少芯片在运算过程中的内存访问次数，同时也降低了内存带宽压力，进而降低内存访问的能耗。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150733.png" alt="img"></p>
<p>​    ▲TPU的矩阵乘法器单元（MXU）</p>
<p>​    谷歌TPU的一鸣惊人，不仅为AI芯片领域带来了架构创新，同时亚马逊、微软等一众科技巨头，以及寒武纪、天数智芯等新势力亦开始纷纷入局，云端AI芯片市场开始风起云涌，掀起行业云端造芯大浪潮。</p>
<p>​    这是一个芯片制造的年代，如果没有技术的积淀与雄厚资本的支持，芯片制造是水中花、镜中月，革命性芯片的研发投入在百亿以上。国内的弘芯、龙芯值得我们深思。</p>
<h3 id="7-5-2、TPU与机器学习"><a href="#7-5-2、TPU与机器学习" class="headerlink" title="7.5.2、TPU与机器学习"></a>7.5.2、TPU与机器学习</h3><p>​    TPU的出现，加速了第二代人工智能系统TensorFlow的运行，效率也大大超过GPU,Google的深层神经网络由TensorFlow引擎驱动。TPU是专为机器学习量身定做，执行每个操作所需的晶体管数量更少，自然效率更高。补充说明的是，能耗也更高。</p>
<p>​    TPU与同期的CPU和GPU相比，可以提供15-30倍的性能提升，以及30-80倍的效率（性能&#x2F;瓦特）提升。在人工智能发展过程中，效率的提升可以对算法进行有效的测试。由于效率问题，很多算法暂时无法测试。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150794.png" alt="img"></p>
<p>​    TPU每瓦能为机器学习提供比所有商用GPU和FPGA更高的量级指令，高性能计算得以在民间应用。TPU为机器学习应用特别开发，使芯片在计算精度降低的情况下更耐用。</p>
<p>​    在人工智能年代，未来，指令级编程将称为常态。对于国内大多数技术人员而言，对指令的熟悉程度影响着个人技术的发展。</p>
<p>​    每一个操作只需要更少的晶体管，用更多精密且大功率的机器学习模型，并快速应用这些模型，因此用户便能得到更正确的结果。</p>
<h3 id="7-5-3、对比说明"><a href="#7-5-3、对比说明" class="headerlink" title="7.5.3、对比说明"></a>7.5.3、对比说明</h3><p>​    CPU和GPU都是较为通用的芯片，但是有句老话是这样讲的：万能工具的效率永远比不上专用工具。而TPU就是一个专业工具。</p>
<p>​    随着社会的计算需求越来越专业化，芯片的专业化需求在增强。便产生了ASIC（专用集成电路）的概念。这个概念其实很早就出现了，但是ASIC不是任何一家公司都能尝试的，其复杂程度、集成程度堪称技术的堡垒。</p>
<p>​    ASIC是指依产品需求不同而定制化的特殊规格集成电路，由特定使用者要求和特定电子系统的需要而设计、制造。这些是定制化的芯片开发，定制化的芯片开发一直广泛存在。在这个领域，谷歌的TPU技术是成功的尝试。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150880.png" alt="img"></p>
<p>​    因为ASIC很“专一”，只做一件事，它就比CPU、GPU等能做很多件事的芯片在某件事上做的更好，实现更高的处理速度和更低的能耗。相应的，ASIC的生产成本也非常高。</p>
<p>​    TPU就是谷歌专门为加速深层神经网络运算能力而研发的一款芯片，其实也是一款ASIC。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150903.png" alt="img"></p>
<p>​    图：谷歌第二代TPU</p>
<p>​    原来很多的机器学习以及图像处理算法大部分都跑在GPU与FPGA（半定制化芯片）上面，但这两种芯片都还是一种通用性芯片，在效能与功耗上不能更紧密的适配机器学习算法。硬件改变的初衷便形成了</p>
<p>​    Google一直坚信伟大的软件将在伟大的硬件的帮助下更加大放异彩，所以Google便想，可不可以做出一款专用机机器学习算法的专用芯片，TPU便诞生了。</p>
<p>​    据称，TPU与同期的CPU和GPU相比，可提供15-30倍的性能提升，以及30-80倍的效率（性能&#x2F;瓦特）提升。第一代TPU只能做推理，依靠Google云实时收集数据并产生结果，训练过程还需要额外的资源；第二代TPU既可以用于训练神经网络，又可以用于推理。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150940.png" alt="img"></p>
<p>​    图：TPU 各模块的框图</p>
<p>​    如上图所示，TPU在芯片上使用了高达24MB的局部内存，6MB的累加器内存以及用于与主控处理器进行对接的内存，总共占芯片面积的37%（图中蓝色部分）。这在从前是不可想象的。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150992.png" alt="img"></p>
<p>​    图：TPU芯片布局图</p>
<p>​    这表示谷歌充分意识到了片外内存访问是GPU能效比低的问题所在，不惜成本的在芯片上放了巨大的内存。相比之下，同时期英伟达的K80只有8MB片上内存，需要不断地去访问片外DRAM。这种设计，和传统硬件设计有巨大的区别，也许只有谷歌财大气粗的公司才有如此的魄力吧。</p>
<h3 id="7-5-4、TPU性能与应用"><a href="#7-5-4、TPU性能与应用" class="headerlink" title="7.5.4、TPU性能与应用"></a>7.5.4、TPU性能与应用</h3><p>​    TPU的高性能还来源于对于低运算精度的容忍。研究结果表明，低精度运算带来的算法准确率损失很小，但是在硬件实现上却可以带来巨大的便利，包括功耗更低、速度更快、占芯片面积更小的运算单元、更小的内存带宽需求等。TPU采用了8比特的低精度运算。</p>
<p>​    不同的技术有不同的应用，不同的应用有不同的算法，不同的算法有不同的精度，TPU的神经网络不需要传统的精度，这和从前的很多设计思路是有区别的。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150043.png" alt="img"></p>
<p>​    目前为止，TPU已经干了很多惊天动地的事情，并且为我们服务了很多年。并且在更多领域应用。</p>
<p>​    机器学习人工智能系统RankBrain，帮助Google用户处理搜索结果；街景Street View，提高地图与导航的准确性；下围棋的计算机程序AlphaGo。这些大事记背后，代表着人工智能时代到来了。</p>
<h3 id="7-5-5、示例代码"><a href="#7-5-5、示例代码" class="headerlink" title="7.5.5、示例代码"></a>7.5.5、示例代码</h3><h4 id="7-5-5-1、变分程序"><a href="#7-5-5-1、变分程序" class="headerlink" title="7.5.5.1、变分程序"></a>7.5.5.1、变分程序</h4><p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150067.png" alt="img"></p>
<h4 id="7-5-5-2、并行VAE程序"><a href="#7-5-5-2、并行VAE程序" class="headerlink" title="7.5.5.2、并行VAE程序"></a>7.5.5.2、并行VAE程序</h4><p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150095.png" alt="img"></p>
<h3 id="7-5-6、总结"><a href="#7-5-6、总结" class="headerlink" title="7.5.6、总结"></a>7.5.6、总结</h3><p>​    从CPU到GPU，再到如今ASIC和FPGA相继入局，云端AI芯片市场百花齐放，与谷歌TPU的推动息息相关。</p>
<p>​    今天，云端AI芯片市场杀得热火朝天，前有赛灵思和寒武纪等新老势力不断崛起，进一步蚕食非GPU领域的市场，后有科技巨头四处找寻机会“大鱼吃小鱼”，合并有潜力的新玩家，整片市场呈一派割据混战、百家争鸣之势。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150188.png" alt="img"></p>
<p>​    不容忽视的是，随着云端AI芯片不断发展，大数据、云平台持续爆发，以及摩尔定律逐渐放缓，算力也再次来到新的瓶颈。</p>
<p>​    玩家是通过先进制程再次撕开云端AI芯片的新技术领域，还是依靠研发创新架构来实现算力的飞跃，不管走向哪条路都需直面种种挑战。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150244.png" alt="img"></p>
<p>​    在AI芯片市场开辟之初，谷歌凭借TPU逐渐打开云端AI芯片市场新的竞争格局，但当云端AI芯片开始进入新时代，谷歌在云平台大数据的技术优势，相信TPU能再次延续过往辉煌，为市场开辟新的方向和路径。</p>
<p>​    TPU由谷歌独家提出，独家研发，独家应用，这些能给我们多少启示呢？谷歌从一个搜索科技公司，过渡到大数据、云计算公司，进而走在人工智能、硬件科技的大道上。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192150287.png" alt="img"></p>
<h2 id="7-6-npu"><a href="#7-6-npu" class="headerlink" title="7.6 npu"></a>7.6 npu</h2><p>NPU（Neural network Processing Unit）， 即神经网络处理器。用电路模拟人类的神经元和突触结构。NPU为神经网络而生，对神经网络进行硬件支持。</p>
<p>​    嵌入式神经网络处理器（NPU）采用“数据驱动并行计算”的架构，特别擅长处理视频、图像类的海量多媒体数据。视频与图像是人工智能数据的重要组成部分，在今天有着最广泛的应用。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151451.png" alt="img"></p>
<p>​    NPU是网络处理器，可以认为是一个组件（或者子系统），有时候也称为NPU协处理器。NPU和TPU一样，偏向于并行架构设计。</p>
<h3 id="7-6-1、生物神经网络"><a href="#7-6-1、生物神经网络" class="headerlink" title="7.6.1、生物神经网络"></a>7.6.1、生物神经网络</h3><p>​    生物神经系统是一个高度组织和相互作用的数量巨大的细胞组织群体。人类大脑的神经细胞大约在1011–1013个左右。神经细胞也称神经元，是神经系统的基本单元，按不同的结合方式构成复杂的神经网络。通过神经元及其联接的可塑性，使大脑具有学习、记忆和认知等各种智能。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151471.png" alt="img"></p>
<p>​    生物神经网络由若干人工神经元结点相互连接，神经元之间通过突触两两连接，突触记录了神经元之间的联系。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151523.png" alt="img"></p>
<p>​    生物神经元主要由以下几个部分组成：</p>
<p>​    胞体，是神经细胞的本体;</p>
<p>​    树突，用以接受来自其它细胞元的信号;</p>
<p>​    轴突，用以输出信号，与多个神经元连接;</p>
<p>​    突触，是一个神经元与另一个神经元相联系的特殊部位，神经元轴突的端部靠化学接触和电接触将信号传递给下一个神经元的树突或胞体。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151461.png" alt="img"></p>
<h3 id="7-6-2、人类神经网络"><a href="#7-6-2、人类神经网络" class="headerlink" title="7.6.2、人类神经网络"></a>7.6.2、人类神经网络</h3><p>​    电路模仿人类神经元，把每个神经元抽象为一个激励函数，函数输入由与其相连的神经元输出以及连接神经元的突触共同决定。</p>
<p>​    为了表达特定的知识，使用者通过某些特定的算法，调整人工神经网络中突触的取值、网络的拓扑结构等。该过程称为“学习”。学习方法有很多，这种方法，也叫算法。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151511.png" alt="img"></p>
<p>​    学习之后，人工神经网络通过习得的知识来解决特定的问题。生物神经网络的深度学习，基本操作是神经元和突触的处理。现在变成计算机处理，传统的处理器指令集（包括x86和ARM等）是为了进行通用计算发展起来的，其基本操作为算术操作（加减乘除）和逻辑操作（与或非），需要数百上千指令才能完成一个神经元的处理，深度学习的处理效率不高。</p>
<p>​    从通用计算到并行计算，再到神经网络计算，是近些年计算发展的一个重要特征。神经网络对人工智能的发展影响深远，人工智能科技公司的brain计划，神经网络往往占有较大成分。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151486.png" alt="img"></p>
<p>​    经典的冯·诺伊曼结构不能满足要求，神经网络中存储和处理是一体化的，通过突触权重来体现。冯·诺伊曼结构中，存储和处理是分离的，由存储器和运算器实现，二者之间存在巨大的差异。在TPU设计上，关于存储与运算也进行了深刻的论证。</p>
<p>​    现有的基于冯·诺伊曼结构的经典计算机（如X86处理器和英伟达GPU）来跑神经网络应用时，不可避免地受到存储和处理分离式结构的制约，影响效率。这也就是专门针对人工智能的专业芯片，能够对传统芯片有一定先天优势的原因之一，NPU实现了计算与存储的结合。。</p>
<h3 id="7-6-3、出现"><a href="#7-6-3、出现" class="headerlink" title="7.6.3、出现"></a>7.6.3、出现</h3><p>​    国内NPU典型代表有寒武纪芯片和国外IBM的TrueNorth芯片。以寒武纪为例，DianNaoYu指令直接面对大规模神经元和突触的处理，一条指令即完成一组神经元的处理，并对神经元和突触数据在芯片上的传输提供了一系列专门的支持。</p>
<p>​    指令编程不论对于人工智能，对于大数据处理、对于音视频和图形图像都有着重要的意义。</p>
<p>​    CPU、GPU、NPU相比，有百倍以上性能或能耗比差距。寒武纪团队和Inria联合发表的DianNao论文为例——DianNao为单核处理器，主频为0.98GHz，峰值达每秒4520亿次神经网络基本运算，65nm工艺下功耗为0.485W，面积3.02平方毫米mm。这就是专业设计的优势所在。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151735.png" alt="img"></p>
<p>​    mate10中的麒麟970芯片，集成了寒武纪的NPU，实现所谓的照片优化功能，保证手机用了很长时间后还能不卡。</p>
<p>​    华为从麒麟810芯片开始，使用自家研发的达芬奇架构集成NPU，大大提升了芯片的AI处理能力，至今采用了华为NPU的手机AI高性能计算仍是卖点之一。2018年10月，华为发布了最新的NPU芯片，包括用于云端训练的晟腾910和用于终端推理的晟腾310，晟腾系列NPU正式走入人们的视野。</p>
<p>​    华为手机使用NPU芯片，也是华为手机的成功要素之一。手机是终端，对视音频图形图像有着更多的应用，NPU的支持，保障应用的顺利进行。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151721.png" alt="img"></p>
<p>​    2019年9月25日，“云栖大会”上阿里正式对外发布了全新的含光800芯片。含光800是一款高性能的采用ASIC技术的用于云端推理的AI芯片NPU。</p>
<p>​    1颗含光800的算力相当于10颗GPU，含光800推理性能达到78563 IPS，能效比500 IPS&#x2F;W。相比传统GPU算力，性价比提升100%。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151789.png" alt="img"></p>
<p>​    举国造芯激动人心的时刻到来了，财大气粗的阿里不再沉默，达摩院重要的使命之一，就是造芯，资本的投入推动芯片技术的发展。</p>
<p>​    嵌入式神经网络处理器（NPU）采用“数据驱动并行计算”架构，擅长处理视频、图像类的海量多媒体数据。</p>
<p>​    NPU处理器专门为物联网人工智能而设计，用于加速神经网络的运算，解决传统芯片在神经网络运算时效率低下的问题。近些年，神经网络称为人工智能算法的重要支柱。</p>
<p>​    NPU可以和CPU、GPU、MCU结合，成为其中的一部分，NPU这种组合的模式，已经广泛使用。NPU也可以进行定制，大大加强了NPU的范围应用。</p>
<p>​    GX8010中，CPU和MCU各有一个NPU，MCU中的NPU相对较小，也被称为SNPU。NPU的应用已经步入家家户户，未来还有很大的发展空间。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151773.png" alt="img"></p>
<h3 id="7-6-4、组成"><a href="#7-6-4、组成" class="headerlink" title="7.6.4、组成"></a>7.6.4、组成</h3><p>​    NPU的结构充分考虑了神经网络运算的特点，专为神经网络运算而设计，各个模块通力结合，保障了神经网络算法的高效执行。</p>
<p>​    NPU处理器有如下几部分组成：乘加、激活函数、二维数据运算、解压缩等模块。</p>
<p>​    乘加模块用于计算矩阵乘加、卷积、点乘等功能，NPU内部有64个MAC，SNPU有32。</p>
<p>​    激活函数模块采用最高12阶参数拟合的方式实现神经网络中的激活函数，NPU内部有6个MAC，SNPU有3个。</p>
<p>​    二维数据运算模块用于实现对一个平面运算，如降采样、平面数据拷贝等，NPU内部有1个MAC，SNPU有1个。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151815.png" alt="img"></p>
<p>​    解压缩模块用于对权重数据的解压。为解决物联网设备中内存带宽小的特点，在NPU编译器中会对神经网络中的权重进行压缩，在不影响精度的情况下，可以实现6-10倍的压缩效果。</p>
<p>​    专业的设计，考虑了运算的方方面面，简单直接，面向问题。对通用专业硬件设计有一定的借鉴作用。下图为高通的NPU芯片，高通一直是嵌入式领域的王者。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151847.png" alt="img"></p>
<h3 id="7-6-5、代码示例"><a href="#7-6-5、代码示例" class="headerlink" title="7.6.5、代码示例"></a>7.6.5、代码示例</h3><p>​    华为NPU编程示例代码：</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151042.png" alt="img"></p>
<h3 id="7-6-6、总结"><a href="#7-6-6、总结" class="headerlink" title="7.6.6、总结"></a>7.6.6、总结</h3><p>​    NPU在现实中有着广泛应用，尤其在智能计算、图形AI识别领域。下面总结AI场景，对NPU应用进行整理。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151053.png" alt="img"></p>
<p>​    拍照时通过NPU实现AI场景识别，并利用NPU运算修图、.NPU判断光源和暗光细节合成超级夜景、通过NPU实现语音助手的运行、.使用NPU记录用户使用习惯杀后台。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151073.png" alt="img"></p>
<p>​    NPU配合GPU Turbo预判下一帧实现提前渲染提高游戏流畅度、NPU预判触控提高跟手度和灵敏度、NPU判断前台后台网速需求差异配合实现Link Turbo、跑分。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151075.png" alt="img"></p>
<p>​    NPU判断游戏渲染负载智能调整分辨率、NPU辅助清理系统18月不卡、把降低游戏时AI的运算负载交给NPU以省电、NPU实现CPU和GPU的动态调度。</p>
<p>​    利用NPU和人工智能算法定期更换壁纸的功能、NPU辅助大数据广告推送、NPU实现输入法AI智能联想词的功能。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151129.png" alt="img"></p>
<p>​    应用场景的支持下，NPU已经成为最重要的芯片。目前，NPU技术已经成熟，已经广泛应用愈交互领域。在手机、军工、嵌入式领域广泛应用。</p>
<p>​    美摄SDK，完美支持CPU、GPU、NPU运算。20年视音频技术积淀，在短视频领域，把人工智能应用做到极致。</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151207.png" alt="img"></p>
<p>  时光变幻，岁月横流，计算机应用的深度与广度增大，对图形图像处理也提出了更高的要求。传统的硬件设计、计算框架、运算理论、软件接口都面临着极大的挑战。为了适应人工智能技术的发展，软硬件技术都在进行着巨变。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151523.png" alt="img"></p>
<p>​    智能时代创造了很多机会，塑造了无数的科技巨头，公司有更大的科技自由度。智能时代技术百花齐放，硬件辈出、框架争鸣、平台显现、万马奔腾。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151543.png" alt="img"></p>
<p>​    不同的硬件框架适应显示的需求。显示技术的后面，有着GPU架构和并行计算架构在支持。在相关专题。阐述主流的CPU、GPU架构，CPU、GPU并行计算模型。</p>
<p>​    计算显示硬件发展的历史，可以看出，专业计算显示硬件往往是民间计算显示硬件发展的前奏，专业硬件发展成熟时，民间消费应用的春天到来了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151495.png" alt="img"></p>
<p>​    专业性开发承担着更多的研发成本，各家公司道路不尽相同，成本相对高的项目，承担着巨大的风险。人工智能时代不仅仅是新的软件理论，计算框架，更是硬件技术的进步。</p>
<h1 id="8-前置说明："><a href="#8-前置说明：" class="headerlink" title="8 前置说明："></a>8 前置说明：</h1><p>​     至此、整个主题全部结束，借鉴了一些资料，如有异议，请联系作者。下面主题，开始讲述处理器架构与指令。</p>
<p>​    材料与制造技术的进步推动了微电子技术的发展，微电子技术的进步推动集成电路的发展，集成电路的发展推动了显示芯片的发展。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151795.png" alt="img"></p>
<p>​    显示技术发展过程中，遵从了双色芯片，2D芯片，3D芯片，再到智能芯片的发展过程，在芯片发展的背后，计算机图形学从早期的文本显示到后来2D、3D世界的呈现，再到今天机器视觉技术的发展。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151793.png" alt="img"></p>
<p>​    硬件技术的提升，带来了显示标准的变化。显示标准从早期的MDA，EGA、VGA、V-Sync到今天的G-Sync和Freesync 2。标准的出现指导着硬件的发展，为图形图像API、引擎的出现做了铺垫。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151796.png" alt="img"></p>
<p>​    从早期驱动编程，到API编程(GDI，GDI+，D2D，AGG，Cairo，Cocoa Drawing)，到专业图形引擎编程(Glide，OpenGL，D3D)，代表着图形图像技术的繁荣，图形图像引擎推动了音视频技术的发展。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151796.png" alt="img"></p>
<p>​    不同的显示标准带来计算机图形学的发展变化。图形图像硬件变革上，AMD推出APU的概念，同时推出APP并行运算框架，并对OpenCI大力支持，推出VEGA架构的显卡。英伟达推出自己的CUDA并行计算技术。Intel推出了Xe图形架构的显卡，推出图形库TBB，pafor编程包。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151823.png" alt="img"></p>
<p>​    硬件架构、运算平台、软件架构、编程框架是硬件厂商的问题，软件架构、编程框架面向终端市场。</p>
<p>​    国内大力激励半导体产业发展，寻求半导体技术的自主可控，芯片IP产业有望进入黄金时代。对于这个时代来说，选择从头做研发是很困难的事，将已有的IP放到芯片中则容易得多。</p>
<p>​    类似Imagination的这种总部在欧洲、具有中资背景，且具有几十年GPU IP积淀的半导体IP企业有望迎来新的契机。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151807.jpeg" alt="img"></p>
<p>​    人工智能发展大背景下，神经网络异军突起。为音视频发展注入了智能因素，把音视频深度应用推向一个新的高度。</p>
<p>​    美摄科技，以音视频技术为基础，以并行计算为依托，以人工智能技术、图形图像技术为双翼，推动融媒技术发展。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151835.jpeg" alt="img"></p>
<h1 id="9-常用术语"><a href="#9-常用术语" class="headerlink" title="9 常用术语"></a>9 常用术语</h1><h2 id="9-1、APU"><a href="#9-1、APU" class="headerlink" title="9.1、APU"></a>9.1、APU</h2><p>​    APU：Accelerated Processing Unit，加速处理器。AMD公司推出加速图像处理芯片产品。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151273.png" alt="img"></p>
<h2 id="9-2、BPU"><a href="#9-2、BPU" class="headerlink" title="9.2、BPU"></a>9.2、BPU</h2><p>​    BPU： Brain Processing Unit，大脑处理器。地平线科技提出的嵌入式人工智能处理器架构。第一代是高斯架构，第二代是伯努利架构，第三代是贝叶斯架构。目前地平线已经设计出了第一代高斯架构，并与英特尔在2017年CES展会上联合推出了ADAS系统（高级驾驶辅助系统）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151290.png" alt="img"></p>
<h2 id="9-3、CPU"><a href="#9-3、CPU" class="headerlink" title="9.3、CPU"></a>9.3、CPU</h2><p>​    CPU：Central Processing Unit，中央处理器。目前PC 核心主流产品。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151313.png" alt="img"></p>
<h2 id="9-4、DPU"><a href="#9-4、DPU" class="headerlink" title="9.4、DPU"></a>9.4、DPU</h2><p>​    DPU：Deep learning Processing Unit，深度学习处理器。最早国内深鉴科技提出，基于Xilinx可重构特性的FPGA芯片，设计专用的深度学习处理单元，可基于已有的逻辑单元，设计并行高效的乘法器及逻辑电路，属于IP范畴，抽象出定制化的指令集和编译器，而非使用OpenCL，从而实现快速的开发与产品迭代。事实上，深鉴提出的DPU属于半定制化的FPGA。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151420.png" alt="img"></p>
<h2 id="9-5、FPU"><a href="#9-5、FPU" class="headerlink" title="9.5、FPU"></a>9.5、FPU</h2><p>​    FPU：Floating Processing Unit，浮点计算单元。通用处理器中的浮点运算模块。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151333.png" alt="img"></p>
<h2 id="9-6、GPU"><a href="#9-6、GPU" class="headerlink" title="9.6、GPU"></a>9.6、GPU</h2><p>​    GPU：Graphics Processing Unit，图形处理器。采用多线程SIMD架构，为图形处理而生。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151452.png" alt="img"></p>
<h2 id="9-7、HPU"><a href="#9-7、HPU" class="headerlink" title="9.7、HPU"></a>9.7、HPU</h2><p>​    HPU：Holographics Processing Unit，全息图像处理器。微软出品的全息计算芯片与设备。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151596.png" alt="img"></p>
<h2 id="9-8、IPU"><a href="#9-8、IPU" class="headerlink" title="9.8、IPU"></a>9.8、IPU</h2><p>​    IPU：Intelligence Processing Unit或者Image Processing Unit。与相机，显示相关。Deep Mind投资的Graphcore公司，开发出的AI处理器。包括：Display、Camera、Image Rotation, Inversion, Color Space Conversion、Image quality enhancement、 Video&#x2F;graphics combining。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151623.png" alt="img"></p>
<h4 id="9-9、MPU"><a href="#9-9、MPU" class="headerlink" title="9.9、MPU"></a>9.9、MPU</h4><p>​    MPU&#x2F;MCU：Microprocessor&#x2F;Micro controller Unit，微处理器&#x2F;微控制器。用于低计算应用的RISC计算机体系架构产品，如ARM-M系列处理器。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151616.png" alt="img"></p>
<h2 id="9-10、NPU"><a href="#9-10、NPU" class="headerlink" title="9.10、NPU"></a>9.10、NPU</h2><p>​    NPU：Neural Network Processing Unit，神经网络处理器。基于神经网络算法与加速的新型处理器总称，如中科院计算所&#x2F;寒武纪公司出品的diannao系列。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151718.png" alt="img"></p>
<h2 id="9-11、RPU"><a href="#9-11、RPU" class="headerlink" title="9.11、RPU"></a>9.11、RPU</h2><p>​    RPU：Radio Processing Unit，无线电处理器。Imagination Technologies公司推出的集合集Wifi&#x2F;蓝牙&#x2F;FM&#x2F;处理器为单片的处理器。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151782.png" alt="img"></p>
<h2 id="9-12、TPU"><a href="#9-12、TPU" class="headerlink" title="9.12、TPU"></a>9.12、TPU</h2><p>​    TPU：Tensor Processing Unit，张量处理器。Google 公司推出的加速人工智能算法的专用处理器。目前一代TPU面向Inference，第二代面向训练。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151725.png" alt="img"></p>
<h2 id="9-13、VPU"><a href="#9-13、VPU" class="headerlink" title="9.13、VPU"></a>9.13、VPU</h2><p>​    VPU：Vector Processing Unit，矢量处理器。Intel收购的Movidius公司推出的图像处理与人工智能的专用芯片的加速计算核心。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151878.png" alt="img"></p>
<h2 id="9-14、WPU"><a href="#9-14、WPU" class="headerlink" title="9.14、WPU"></a>9.14、WPU</h2><p>​    WPU：Wearable Processing Unit，可穿戴处理器。Ineda Systems公司推出的可穿戴片上系统产品，包含GPU&#x2F;MIPS CPU等IP。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151933.png" alt="img"></p>
<h4 id="9-15、XPU"><a href="#9-15、XPU" class="headerlink" title="9.15、XPU"></a>9.15、XPU</h4><p>​    XPU：百度与Xilinx公司在2017年Hotchips大会上发布的FPGA智能云加速，含256核。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151944.png" alt="img"></p>
<h2 id="9-16、ZPU"><a href="#9-16、ZPU" class="headerlink" title="9.16、ZPU"></a>9.16、ZPU</h2><p>​    ZPU：Zylin Processing Unit。 由挪威Zylin 公司推出的一款32位开源处理器。</p>
<h2 id="9-17、凸凹贴图"><a href="#9-17、凸凹贴图" class="headerlink" title="9.17、凸凹贴图"></a>9.17、凸凹贴图</h2><p>​    凹凸贴图：计算机图形学在三维场景中凸凹处理的一个技术。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://chai-1301855619.cos.ap-beijing.myqcloud.com/202311192151998.png" alt="img"></p>
<h2 id="9-18、像素填充率"><a href="#9-18、像素填充率" class="headerlink" title="9.18、像素填充率"></a>9.18、像素填充率</h2><p>​    像素填充率：每秒渲染的像素数量，早期10亿级别，现在100亿级别。</p>
<h2 id="9-19、三角形生成速度"><a href="#9-19、三角形生成速度" class="headerlink" title="9.19、三角形生成速度"></a>9.19、三角形生成速度</h2><p>​    三角形生成速度：三角形是三维图形渲染的重要单元，当前从千万到亿级别不等。</p>
<h2 id="9-20、硬件T-L"><a href="#9-20、硬件T-L" class="headerlink" title="9.20、硬件T&amp;L"></a>9.20、硬件T&amp;L</h2><p>​    硬件T&amp;L：显卡坐标转换和光源编程。</p>
<h2 id="9-21、DDR-显存"><a href="#9-21、DDR-显存" class="headerlink" title="9.21、DDR 显存"></a>9.21、DDR 显存</h2><p>​    DDR 显存：显卡的高速颗粒，有更快的数据交互速度。</p>
<h2 id="9-22、HyperZ-技术"><a href="#9-22、HyperZ-技术" class="headerlink" title="9.22、HyperZ 技术"></a>9.22、HyperZ 技术</h2><p>​    HyperZ 技术：显存优化管理单元，通过快速Z轴清除等手段优化显存的利用效率。</p>
<h2 id="9-23、显卡流水线"><a href="#9-23、显卡流水线" class="headerlink" title="9.23、显卡流水线"></a>9.23、显卡流水线</h2><p>​    显卡流水线：数量的多少决定显卡性能高低的一个很重要的指标，Nvidia和AMD-ATI也在不断地增加显卡的流处理器数量使显卡的性能达到跳跃式增长。这个和核心构建，显存带宽等因素配合，单一多，意义不大。</p>
<h2 id="9-24、F-Buffer"><a href="#9-24、F-Buffer" class="headerlink" title="9.24、F-Buffer"></a>9.24、F-Buffer</h2><p>​    F-Buffer：片断流缓冲区技术，处理无限制指令长度的阴影着色程序。执行原理：把需要经过渲染引擎多次处理的像素临时存储起来，而不是把它们写到帧缓冲里面。只有那些需要单通道处理的数据被写到帧缓冲。这样节省显存的带宽，从而使VPU工作得更加有效率。缺点：F-Buffer只能对所有流程都是基于同一视点的多流程渲染有效，对于用于生成不同视点图像的多流程渲染没用，在日常3D应用中，不同视点的多流程渲染十分普遍。其次F-Buffer的执行过程有可能产生溢出，一旦产生溢出其处理过程十分复杂，会影响GPU的执行效率。</p>
<h2 id="9-25、FPGA"><a href="#9-25、FPGA" class="headerlink" title="9.25、FPGA"></a>9.25、FPGA</h2><p>FPGA：可编程逻辑，计算效率高，更接近底层IO，通过冗余晶体管和连线实现逻辑可编辑。本质上是无指令、无需共享内存，计算效率比CPU、GPU高。主要应用于智能手机、便携式移动设备、汽车。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">John Doe</div><div class="post-copyright__author_desc">热爱学习</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2023/11/19/0-0-15%20%E6%98%BE%E7%A4%BA%E7%A1%AC%E4%BB%B6%E5%8F%91%E5%B1%95%E4%B8%8E%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%89%AB%E7%9B%B2/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2023/11/19/0-0-15%20%E6%98%BE%E7%A4%BA%E7%A1%AC%E4%BB%B6%E5%8F%91%E5%B1%95%E4%B8%8E%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%89%AB%E7%9B%B2/')">0-0-15 显示硬件发展与视频开发知识点扫盲</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2023/11/19/0-0-15%20%E6%98%BE%E7%A4%BA%E7%A1%AC%E4%BB%B6%E5%8F%91%E5%B1%95%E4%B8%8E%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%89%AB%E7%9B%B2/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=0-0-15 显示硬件发展与视频开发知识点扫盲&amp;url=http://example.com/2023/11/19/0-0-15%20%E6%98%BE%E7%A4%BA%E7%A1%AC%E4%BB%B6%E5%8F%91%E5%B1%95%E4%B8%8E%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%89%AB%E7%9B%B2/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">热爱学习的未来酱</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>音视频编解码<span class="tagsPageCount">2</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/19/0-0-14%20%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">0-0-14 音视频编解码相关知识学习</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/20/0-0-16%20debian%E5%92%8Cubuntu%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA%E8%AF%A6%E8%A7%A3/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">0-0-16 ubuntu和debian文件系统构建详解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2023/11/19/0-0-14%20%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/" title="0-0-14 音视频编解码相关知识学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-19</div><div class="title">0-0-14 音视频编解码相关知识学习</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">永远年轻，永远热泪盈眶</div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81%E6%97%A9%E6%9C%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1、早期概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81VGA%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">2、VGA编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%812D%E6%97%B6%E4%BB%A3"><span class="toc-number">3.</span> <span class="toc-text">3、2D时代</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81%E5%85%AC%E5%8F%B8"><span class="toc-number">3.1.</span> <span class="toc-text">3.1、公司</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1%E3%80%81Amiga"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1、Amiga</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2%E3%80%81IBM"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2、IBM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3%E3%80%81S3"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3、S3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4%E3%80%81Trident"><span class="toc-number">3.1.4.</span> <span class="toc-text">3.1.4、Trident</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-5%E3%80%81Matrox%EF%BC%88%E8%BF%88%E5%88%9B%EF%BC%89"><span class="toc-number">3.1.5.</span> <span class="toc-text">3.1.5、Matrox（迈创）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81%E5%9B%BE%E5%BD%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">3.2.</span> <span class="toc-text">3.2、图形技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1%E3%80%81GDI%E7%BC%96%E7%A8%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1、GDI编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2%E3%80%81GDI-%E7%BC%96%E7%A8%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2、GDI+编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3%E3%80%81Direct-2D"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3、Direct 2D</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4%E3%80%81AGG"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4、AGG</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-5%E3%80%81Cairo"><span class="toc-number">3.2.5.</span> <span class="toc-text">3.2.5、Cairo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-6%E3%80%81Cocoa-Drawing"><span class="toc-number">3.2.6.</span> <span class="toc-text">3.2.6、Cocoa Drawing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">3.3.</span> <span class="toc-text">3.3、总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%813D%E6%97%B6%E4%BB%A3"><span class="toc-number">4.</span> <span class="toc-text">4、3D时代</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E3%80%81%E5%85%AC%E5%8F%B8"><span class="toc-number">4.1.</span> <span class="toc-text">4.1、公司</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1%E3%80%813Dfx"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1、3Dfx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2%E3%80%81ATI"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2、ATI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3%E3%80%81NVIDIA"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.1.3、NVIDIA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4%E3%80%813DLabs"><span class="toc-number">4.1.4.</span> <span class="toc-text">4.1.4、3DLabs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-5%E3%80%81Video-Logic"><span class="toc-number">4.1.5.</span> <span class="toc-text">4.1.5、Video Logic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-6%E3%80%81intel"><span class="toc-number">4.1.6.</span> <span class="toc-text">4.1.6、intel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-7%E3%80%81AMD"><span class="toc-number">4.1.7.</span> <span class="toc-text">4.1.7、AMD</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E3%80%81%E8%BD%AF%E4%BB%B6%E4%B8%8E%E7%A1%AC%E4%BB%B6"><span class="toc-number">4.2.</span> <span class="toc-text">4.2、软件与硬件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%A1%AC%E4%BB%B6"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1、接口与硬件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2%E3%80%813D%E5%BC%95%E6%93%8E"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2、3D引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-1%EF%BC%8EOpenGL"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">4.2.2.1．OpenGL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-2%E3%80%81DirectX"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">4.2.2.2、DirectX</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3%E3%80%81Shader%E7%BC%96%E7%A8%8B"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3、Shader编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-1%E3%80%81Metal"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">4.2.2.1、Metal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-2%E3%80%81Vulkan"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">4.2.2.2、Vulkan</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E3%80%81%E5%90%AF%E7%A4%BA"><span class="toc-number">4.3.</span> <span class="toc-text">4.3、启示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81%E7%A7%BB%E5%8A%A8%E6%97%B6%E4%BB%A3"><span class="toc-number">5.</span> <span class="toc-text">5、移动时代</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E3%80%81%E6%89%8B%E6%9C%BA%E6%97%B6%E4%BB%A3"><span class="toc-number">5.1.</span> <span class="toc-text">5.1、手机时代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E3%80%81%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%BB%E6%B5%81%E6%98%BE%E7%A4%BA%E8%8A%AF%E7%89%87"><span class="toc-number">5.2.</span> <span class="toc-text">5.2、移动端主流显示芯片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1%E3%80%81ARM"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1、ARM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2%E3%80%81Qualcomm"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2、Qualcomm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3%E3%80%81Apple"><span class="toc-number">5.2.3.</span> <span class="toc-text">5.2.3、Apple</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4%E3%80%81Imagination-Technologies"><span class="toc-number">5.2.4.</span> <span class="toc-text">5.2.4、Imagination Technologies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-5%E3%80%81Vivante"><span class="toc-number">5.2.5.</span> <span class="toc-text">5.2.5、Vivante</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-6%E3%80%81NVIDIA%E3%80%81AMD%E3%80%81Intel"><span class="toc-number">5.2.6.</span> <span class="toc-text">5.2.6、NVIDIA、AMD、Intel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E3%80%81%E7%A7%BB%E5%8A%A8%E5%9B%BE%E5%BD%A2%E5%BA%93"><span class="toc-number">5.3.</span> <span class="toc-text">5.3、移动图形库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1%E3%80%81OpenGL-ES"><span class="toc-number">5.3.1.</span> <span class="toc-text">5.3.1、OpenGL ES</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-1%E3%80%81OpenGL-ES-%E7%89%88%E6%9C%AC%E4%B8%8E%E5%8A%9F%E8%83%BD"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">5.3.1.1、OpenGL ES 版本与功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-2%E3%80%81OpenGL-ES-3-0%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">5.3.1.2、OpenGL ES 3.0新功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-3%E3%80%81OpenGL-ES-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">5.3.1.3.</span> <span class="toc-text">5.3.1.3、OpenGL ES 示例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2%E3%80%81%E5%85%B6%E5%AE%83"><span class="toc-number">5.3.2.</span> <span class="toc-text">5.3.2、其它</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4%E3%80%81%E5%90%AF%E7%A4%BA"><span class="toc-number">5.4.</span> <span class="toc-text">5.4、启示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%97%B6%E4%BB%A3"><span class="toc-number">6.</span> <span class="toc-text">6 人工智能时代</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E3%80%81%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="toc-number">6.1.</span> <span class="toc-text">6.1、人工智能发展历史</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1%E3%80%81%E5%A4%A7%E4%BA%8B%E8%AE%B0"><span class="toc-number">6.1.1.</span> <span class="toc-text">6.1.1、大事记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2%E3%80%81%E5%90%AF%E7%A4%BA"><span class="toc-number">6.1.2.</span> <span class="toc-text">6.1.2、启示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E3%80%81%E7%A1%AC%E4%BB%B6%E5%8F%91%E5%B1%95"><span class="toc-number">6.2.</span> <span class="toc-text">6.2、硬件发展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1%E3%80%81AI-AR-VR%E8%8A%AF%E7%89%87"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.2.1、AI&#x2F;AR&#x2F;VR芯片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2%E3%80%81%E7%9B%B8%E6%9C%BA%E8%8A%AF%E7%89%87"><span class="toc-number">6.2.2.</span> <span class="toc-text">6.2.2、相机芯片</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-1%E3%80%81%E4%BC%A0%E7%BB%9F%E7%9B%B8%E6%9C%BA"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">6.2.2.1、传统相机</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-2-1-1%E3%80%81CCD"><span class="toc-number">6.2.2.1.1.</span> <span class="toc-text">6.2.2.1.1、CCD</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-2-1-2%E3%80%81CMOS"><span class="toc-number">6.2.2.1.2.</span> <span class="toc-text">6.2.2.1.2、CMOS</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-2%E3%80%81%E5%B7%A5%E4%B8%9A%E7%9B%B8%E6%9C%BA"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">6.2.2.2、工业相机</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-3%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">6.2.3.</span> <span class="toc-text">6.2.2.3、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3%E3%80%81%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89"><span class="toc-number">6.3.</span> <span class="toc-text">6.3、机器视觉</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4%E3%80%81%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.4.</span> <span class="toc-text">6.4、机器视觉系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89"><span class="toc-number">6.5.</span> <span class="toc-text">6.5、计算机视觉</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6%E3%80%81%E6%99%BA%E8%83%BD%E6%97%B6%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%8F%91%E5%B1%95"><span class="toc-number">6.6.</span> <span class="toc-text">6.6、智能时代软件发展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-1%E3%80%81%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">6.6.1.</span> <span class="toc-text">6.6.1、人工智能编程语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-1-1%E3%80%81LISP"><span class="toc-number">6.6.1.1.</span> <span class="toc-text">6.6.1.1、LISP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-1-2%E3%80%81Prolog"><span class="toc-number">6.6.1.2.</span> <span class="toc-text">6.6.1.2、Prolog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-1-3%E3%80%81OPS83"><span class="toc-number">6.6.1.3.</span> <span class="toc-text">6.6.1.3、OPS83</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-1-4%E3%80%81Python"><span class="toc-number">6.6.1.4.</span> <span class="toc-text">6.6.1.4、Python</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-1-4%E3%80%81%E5%90%AF%E7%A4%BA"><span class="toc-number">6.6.2.</span> <span class="toc-text">6.6.1.4、启示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-3%E3%80%81%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BA%93"><span class="toc-number">6.6.3.</span> <span class="toc-text">6.6.3、机器学习库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-3-1%E3%80%81%E7%94%9F%E7%89%A9%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-number">6.6.3.1.</span> <span class="toc-text">6.6.3.1、生物神经网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-3-2%E3%80%81%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-number">6.6.3.2.</span> <span class="toc-text">6.6.3.2、人工神经网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-3-3%E3%80%81TensorFlow"><span class="toc-number">6.6.3.3.</span> <span class="toc-text">6.6.3.3、TensorFlow</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-3-3-1%E3%80%81%E5%8F%91%E5%B1%95"><span class="toc-number">6.6.3.3.1.</span> <span class="toc-text">6.6.3.3.1、发展</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-3-3-2%E3%80%81%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">6.6.3.3.2.</span> <span class="toc-text">6.6.3.3.2、核心组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-3-3-3%E3%80%81%E7%BB%84%E4%BB%B6"><span class="toc-number">6.6.3.3.3.</span> <span class="toc-text">6.6.3.3.3、组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-3-3-4%E3%80%81%E5%85%B6%E5%AE%83"><span class="toc-number">6.6.3.3.4.</span> <span class="toc-text">6.6.3.3.4、其它</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-3-2%E3%80%81PyTorch"><span class="toc-number">6.6.3.4.</span> <span class="toc-text">6.6.3.2、PyTorch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-2-1%E3%80%81CUDA"><span class="toc-number">6.6.3.5.</span> <span class="toc-text">6.6.2.1、CUDA</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-2-1-1%E3%80%81%E5%BA%94%E7%94%A8"><span class="toc-number">6.6.3.5.1.</span> <span class="toc-text">6.6.2.1.1、应用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-2-1-2%E3%80%81%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">6.6.3.5.2.</span> <span class="toc-text">6.6.2.1.2、系统结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-2-1-3%E3%80%81%E6%A0%B8%E5%BF%83"><span class="toc-number">6.6.3.5.3.</span> <span class="toc-text">6.6.2.1.3、核心</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-2-1-4%E3%80%81%E5%85%B6%E5%AE%83"><span class="toc-number">6.6.3.5.4.</span> <span class="toc-text">6.6.2.1.4、其它</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-2-2%E3%80%81OPENCL"><span class="toc-number">6.6.3.6.</span> <span class="toc-text">6.6.2.2、OPENCL</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-2-2-1%E3%80%81%E5%8F%91%E5%B1%95"><span class="toc-number">6.6.3.6.1.</span> <span class="toc-text">6.6.2.2.1、发展</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-2-2-2%E3%80%81%E6%94%AF%E6%8C%81"><span class="toc-number">6.6.3.6.2.</span> <span class="toc-text">6.6.2.2.2、支持</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-2-2-3%E3%80%81API"><span class="toc-number">6.6.3.6.3.</span> <span class="toc-text">6.6.2.2.3、API</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-2-2-4%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">6.6.3.6.4.</span> <span class="toc-text">6.6.2.2.4、总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-4%E3%80%81%E5%85%B6%E5%AE%83%E7%9B%B8%E5%85%B3%E5%BA%93"><span class="toc-number">6.6.4.</span> <span class="toc-text">6.6.4、其它相关库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-4-1%E3%80%81OpenCV"><span class="toc-number">6.6.4.1.</span> <span class="toc-text">6.6.4.1、OpenCV</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-4-1%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-number">6.6.4.2.</span> <span class="toc-text">6.6.4.1、简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-4-2%E3%80%81%E5%BA%94%E7%94%A8"><span class="toc-number">6.6.4.3.</span> <span class="toc-text">6.6.4.2、应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-4-3%E3%80%81%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.6.4.4.</span> <span class="toc-text">6.6.4.3、接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-4-2%E3%80%81OpenMP"><span class="toc-number">6.6.4.5.</span> <span class="toc-text">6.6.4.2、OpenMP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-4-2-1%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-number">6.6.4.5.1.</span> <span class="toc-text">6.6.4.2.1、简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-4-2-2%E3%80%81%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">6.6.4.5.2.</span> <span class="toc-text">6.6.4.2.2、单线程与多线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-4-2-3%E3%80%81OpenMP%E4%B8%8EMPI"><span class="toc-number">6.6.4.5.3.</span> <span class="toc-text">6.6.4.2.3、OpenMP与MPI</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-4-2-4%E3%80%81%E5%BA%94%E7%94%A8"><span class="toc-number">6.6.4.5.4.</span> <span class="toc-text">6.6.4.2.4、应用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#6-6-4-2-4-1%E3%80%81Windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%BC%80%E5%8F%91"><span class="toc-number">6.6.4.5.4.1.</span> <span class="toc-text">6.6.4.2.4.1、Windows环境下开发</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-6-4-2-4-2%E3%80%81Linux%E7%8E%AF%E5%A2%83"><span class="toc-number">6.6.4.5.4.2.</span> <span class="toc-text">6.6.4.2.4.2、Linux环境</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-4-2-5%E3%80%81%E5%90%8C%E6%AD%A5%E5%8D%8F%E4%BD%9C"><span class="toc-number">6.6.4.5.5.</span> <span class="toc-text">6.6.4.2.5、同步协作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-4-3%E3%80%81OpenACC"><span class="toc-number">6.6.4.6.</span> <span class="toc-text">6.6.4.3、OpenACC</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-4-3-1%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-number">6.6.4.6.1.</span> <span class="toc-text">6.6.4.3.1、简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-4-3-2%E3%80%81%E5%8F%91%E5%B1%95%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-number">6.6.4.6.2.</span> <span class="toc-text">6.6.4.3.2、发展与应用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-4-3-3%E3%80%81%E7%A1%AC%E4%BB%B6%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="toc-number">6.6.4.6.3.</span> <span class="toc-text">6.6.4.3.3、硬件独立性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-4-3-4%E3%80%81%E5%AE%9E%E4%BE%8B01%E2%80%94parallel-loops"><span class="toc-number">6.6.4.6.4.</span> <span class="toc-text">6.6.4.3.4、实例01—parallel loops</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-4-3-5%E3%80%81%E5%AE%9E%E4%BE%8B02%E2%80%94gangs-and-workers"><span class="toc-number">6.6.4.6.5.</span> <span class="toc-text">6.6.4.3.5、实例02—gangs and workers</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-4-3-6%E3%80%81%E5%AE%9E%E4%BE%8B03%E2%80%94kernel-regions"><span class="toc-number">6.6.4.6.6.</span> <span class="toc-text">6.6.4.3.6、实例03—kernel regions</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-4-5%E3%80%81OpenAL"><span class="toc-number">6.6.4.7.</span> <span class="toc-text">6.6.4.5、OpenAL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-4-6%E3%80%81OpenGL"><span class="toc-number">6.6.4.8.</span> <span class="toc-text">6.6.4.6、OpenGL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-5%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">6.6.5.</span> <span class="toc-text">6.6.5、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8%E3%80%81%E5%90%AF%E7%A4%BA"><span class="toc-number">6.7.</span> <span class="toc-text">6.8、启示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81%E6%98%BE%E7%A4%BA%E6%A0%87%E5%87%86%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83"><span class="toc-number">7.</span> <span class="toc-text">7、显示标准与视频处理单元</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1%E3%80%81%E6%98%BE%E7%A4%BA%E6%A0%87%E5%87%86"><span class="toc-number">7.1.</span> <span class="toc-text">7.1、显示标准</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-1%E3%80%81V-Sync"><span class="toc-number">7.1.0.1.</span> <span class="toc-text">7.1.1、V-Sync</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-2%E3%80%81G-Sync"><span class="toc-number">7.1.0.2.</span> <span class="toc-text">7.1.2、G-Sync</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-3%E3%80%81FreeSync2"><span class="toc-number">7.1.0.3.</span> <span class="toc-text">7.1.3、FreeSync2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-4%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">7.1.0.4.</span> <span class="toc-text">7.1.4、总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-VPU"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 VPU</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1%E3%80%81VPU%E7%9A%84%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7"><span class="toc-number">7.2.1.</span> <span class="toc-text">7.2.1、VPU的基础特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2%E3%80%81VPU%E7%89%B9%E8%89%B2%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="toc-number">7.2.2.</span> <span class="toc-text">7.2.2、VPU特色及应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3%E3%80%81Movidius"><span class="toc-number">7.2.3.</span> <span class="toc-text">7.2.3、Movidius</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-4%E3%80%81INTEL"><span class="toc-number">7.2.4.</span> <span class="toc-text">7.2.4、INTEL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-5%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.2.5.</span> <span class="toc-text">7.2.5、代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-6%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">7.2.6.</span> <span class="toc-text">7.2.6、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-APU"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 APU</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1%E3%80%81AMD%E4%B8%8EAPU"><span class="toc-number">7.3.1.</span> <span class="toc-text">7.3.1、AMD与APU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2%E3%80%81VISION%E5%BC%95%E6%93%8E"><span class="toc-number">7.3.2.</span> <span class="toc-text">7.3.2、VISION引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-3%E3%80%81APU%E6%96%B0%E5%93%81"><span class="toc-number">7.3.3.</span> <span class="toc-text">7.3.3、APU新品</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-4%E3%80%81APU%E7%BC%96%E7%A8%8B"><span class="toc-number">7.3.4.</span> <span class="toc-text">7.3.4、APU编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-5%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">7.3.5.</span> <span class="toc-text">7.3.5、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-gpgpu"><span class="toc-number">7.4.</span> <span class="toc-text">7.4 gpgpu</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-1%E3%80%81%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-number">7.4.1.</span> <span class="toc-text">7.4.1、主要功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-2%E3%80%81%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8A%BF"><span class="toc-number">7.4.2.</span> <span class="toc-text">7.4.2、设计优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-3%E3%80%81%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86"><span class="toc-number">7.4.3.</span> <span class="toc-text">7.4.3、技术原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-4%E3%80%81%E6%94%AF%E6%8C%81%E6%96%B9"><span class="toc-number">7.4.4.</span> <span class="toc-text">7.4.4、支持方</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-4-1%E3%80%81ATI-Stream"><span class="toc-number">7.4.4.1.</span> <span class="toc-text">7.4.4.1、ATI Stream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-4-2%E3%80%81CUDA"><span class="toc-number">7.4.4.2.</span> <span class="toc-text">7.4.4.2、CUDA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-4-3%E3%80%81OpenCL"><span class="toc-number">7.4.4.3.</span> <span class="toc-text">7.4.4.3、OpenCL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-4-4%E3%80%81DirectCompute"><span class="toc-number">7.4.4.4.</span> <span class="toc-text">7.4.4.4、DirectCompute</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-5%E3%80%81%E5%AA%92%E4%BD%93%E7%BC%96%E7%A0%81%E5%8A%A0%E9%80%9F"><span class="toc-number">7.4.5.</span> <span class="toc-text">7.4.5、媒体编码加速</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-6%E3%80%81%E8%A7%86%E9%A2%91%E8%A1%A5%E5%B8%A7%E4%B8%8E%E7%94%BB%E9%9D%A2%E4%BC%98%E5%8C%96"><span class="toc-number">7.4.6.</span> <span class="toc-text">7.4.6、视频补帧与画面优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-7%E3%80%81%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0"><span class="toc-number">7.4.7.</span> <span class="toc-text">7.4.7、人工智能与深度学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-8%E3%80%81%E8%B6%85%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA"><span class="toc-number">7.4.8.</span> <span class="toc-text">7.4.8、超级计算机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-9%E3%80%81%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">7.4.9.</span> <span class="toc-text">7.4.9、示例代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-10%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">7.4.10.</span> <span class="toc-text">7.4.10、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-TPU"><span class="toc-number">7.5.</span> <span class="toc-text">7.5 TPU</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-1%E3%80%81TPU%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-number">7.5.1.</span> <span class="toc-text">7.5.1、TPU发展史</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-1-1%E3%80%81%E5%A7%8B%E4%BA%8E%E7%AE%97%E5%8A%9B%E7%93%B6%E9%A2%88%EF%BC%8C%E9%A6%96%E7%A7%80%E4%BA%BA%E7%B1%BB%E5%9B%B4%E6%A3%8B%E7%95%8C"><span class="toc-number">7.5.1.1.</span> <span class="toc-text">7.5.1.1、始于算力瓶颈，首秀人类围棋界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-1-2%E3%80%81%E8%B0%B7%E6%AD%8CTPU%E7%9A%84%E8%BF%AD%E4%BB%A3%E3%80%81%E4%BA%91%E7%AB%AF%E6%9E%84%E5%BB%BA%E3%80%81%E7%BB%88%E7%AB%AF%E5%BA%94%E7%94%A8"><span class="toc-number">7.5.1.2.</span> <span class="toc-text">7.5.1.2、谷歌TPU的迭代、云端构建、终端应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-5-1-2-1%E3%80%812016%E5%B9%B4%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%BB%A3TPU"><span class="toc-number">7.5.1.2.1.</span> <span class="toc-text">7.5.1.2.1、2016年：第一代TPU</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-5-1-2-2%E3%80%812017%E5%B9%B4%EF%BC%9A%E7%AC%AC%E4%BA%8C%E4%BB%A3TPU%EF%BC%8C%E5%BC%95%E5%85%A5Google-Cloud"><span class="toc-number">7.5.1.2.2.</span> <span class="toc-text">7.5.1.2.2、2017年：第二代TPU，引入Google Cloud</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-5-1-2-3%E3%80%812018%E5%B9%B4%EF%BC%9A%E7%AC%AC%E4%B8%89%E4%BB%A3TPU%EF%BC%8C%E8%BE%B9%E7%BC%98AI%E8%8A%AF%E7%89%87Edge-TPU"><span class="toc-number">7.5.1.2.3.</span> <span class="toc-text">7.5.1.2.3、2018年：第三代TPU，边缘AI芯片Edge TPU</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-5-1-2-4%E3%80%812019%E5%B9%B4%EF%BC%9A%E7%AC%AC%E4%BA%8C-%E4%B8%89%E4%BB%A3TPU-Pod"><span class="toc-number">7.5.1.2.4.</span> <span class="toc-text">7.5.1.2.4、2019年：第二&#x2F;三代TPU Pod</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-1-3%E3%80%81%E6%9E%B6%E6%9E%84%E5%88%9B%E6%96%B0%EF%BC%8C%E6%8E%80%E8%B5%B7%E4%BA%91%E7%AB%AF%E9%80%A0%E8%8A%AF%E5%A4%A7%E6%B5%AA%E6%BD%AE"><span class="toc-number">7.5.1.3.</span> <span class="toc-text">7.5.1.3、架构创新，掀起云端造芯大浪潮</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-5-1-3-1%E3%80%81%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%89%87%E4%B8%8A%E5%86%85%E5%AD%98"><span class="toc-number">7.5.1.3.1.</span> <span class="toc-text">7.5.1.3.1、大规模片上内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-5-1-3-2%E3%80%81%E7%94%A8%E9%87%8F%E5%8C%96%E6%8A%80%E6%9C%AF%E8%BF%9B%E8%A1%8C%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97"><span class="toc-number">7.5.1.3.2.</span> <span class="toc-text">7.5.1.3.2、用量化技术进行整数运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-5-1-3-3%E3%80%81%E5%8F%AF%E7%BC%96%E7%A8%8B%E6%80%A7"><span class="toc-number">7.5.1.3.3.</span> <span class="toc-text">7.5.1.3.3、可编程性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-5-1-3-4%E3%80%81%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97"><span class="toc-number">7.5.1.3.4.</span> <span class="toc-text">7.5.1.3.4、并行计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-5-1-3-5%E3%80%81%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.5.1.3.5.</span> <span class="toc-text">7.5.1.3.5、脉动阵列设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-2%E3%80%81TPU%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"><span class="toc-number">7.5.2.</span> <span class="toc-text">7.5.2、TPU与机器学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-3%E3%80%81%E5%AF%B9%E6%AF%94%E8%AF%B4%E6%98%8E"><span class="toc-number">7.5.3.</span> <span class="toc-text">7.5.3、对比说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-4%E3%80%81TPU%E6%80%A7%E8%83%BD%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-number">7.5.4.</span> <span class="toc-text">7.5.4、TPU性能与应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-5%E3%80%81%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">7.5.5.</span> <span class="toc-text">7.5.5、示例代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-5-1%E3%80%81%E5%8F%98%E5%88%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">7.5.5.1.</span> <span class="toc-text">7.5.5.1、变分程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-5-2%E3%80%81%E5%B9%B6%E8%A1%8CVAE%E7%A8%8B%E5%BA%8F"><span class="toc-number">7.5.5.2.</span> <span class="toc-text">7.5.5.2、并行VAE程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-6%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">7.5.6.</span> <span class="toc-text">7.5.6、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-npu"><span class="toc-number">7.6.</span> <span class="toc-text">7.6 npu</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-1%E3%80%81%E7%94%9F%E7%89%A9%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-number">7.6.1.</span> <span class="toc-text">7.6.1、生物神经网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-2%E3%80%81%E4%BA%BA%E7%B1%BB%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-number">7.6.2.</span> <span class="toc-text">7.6.2、人类神经网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-3%E3%80%81%E5%87%BA%E7%8E%B0"><span class="toc-number">7.6.3.</span> <span class="toc-text">7.6.3、出现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-4%E3%80%81%E7%BB%84%E6%88%90"><span class="toc-number">7.6.4.</span> <span class="toc-text">7.6.4、组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-5%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.6.5.</span> <span class="toc-text">7.6.5、代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-6%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">7.6.6.</span> <span class="toc-text">7.6.6、总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%89%8D%E7%BD%AE%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">8.</span> <span class="toc-text">8 前置说明：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD"><span class="toc-number">9.</span> <span class="toc-text">9 常用术语</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1%E3%80%81APU"><span class="toc-number">9.1.</span> <span class="toc-text">9.1、APU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2%E3%80%81BPU"><span class="toc-number">9.2.</span> <span class="toc-text">9.2、BPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3%E3%80%81CPU"><span class="toc-number">9.3.</span> <span class="toc-text">9.3、CPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4%E3%80%81DPU"><span class="toc-number">9.4.</span> <span class="toc-text">9.4、DPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5%E3%80%81FPU"><span class="toc-number">9.5.</span> <span class="toc-text">9.5、FPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6%E3%80%81GPU"><span class="toc-number">9.6.</span> <span class="toc-text">9.6、GPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-7%E3%80%81HPU"><span class="toc-number">9.7.</span> <span class="toc-text">9.7、HPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-8%E3%80%81IPU"><span class="toc-number">9.8.</span> <span class="toc-text">9.8、IPU</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-9%E3%80%81MPU"><span class="toc-number">9.8.0.1.</span> <span class="toc-text">9.9、MPU</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-10%E3%80%81NPU"><span class="toc-number">9.9.</span> <span class="toc-text">9.10、NPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-11%E3%80%81RPU"><span class="toc-number">9.10.</span> <span class="toc-text">9.11、RPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-12%E3%80%81TPU"><span class="toc-number">9.11.</span> <span class="toc-text">9.12、TPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-13%E3%80%81VPU"><span class="toc-number">9.12.</span> <span class="toc-text">9.13、VPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-14%E3%80%81WPU"><span class="toc-number">9.13.</span> <span class="toc-text">9.14、WPU</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-15%E3%80%81XPU"><span class="toc-number">9.13.0.1.</span> <span class="toc-text">9.15、XPU</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-16%E3%80%81ZPU"><span class="toc-number">9.14.</span> <span class="toc-text">9.16、ZPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-17%E3%80%81%E5%87%B8%E5%87%B9%E8%B4%B4%E5%9B%BE"><span class="toc-number">9.15.</span> <span class="toc-text">9.17、凸凹贴图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-18%E3%80%81%E5%83%8F%E7%B4%A0%E5%A1%AB%E5%85%85%E7%8E%87"><span class="toc-number">9.16.</span> <span class="toc-text">9.18、像素填充率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-19%E3%80%81%E4%B8%89%E8%A7%92%E5%BD%A2%E7%94%9F%E6%88%90%E9%80%9F%E5%BA%A6"><span class="toc-number">9.17.</span> <span class="toc-text">9.19、三角形生成速度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-20%E3%80%81%E7%A1%AC%E4%BB%B6T-L"><span class="toc-number">9.18.</span> <span class="toc-text">9.20、硬件T&amp;L</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-21%E3%80%81DDR-%E6%98%BE%E5%AD%98"><span class="toc-number">9.19.</span> <span class="toc-text">9.21、DDR 显存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-22%E3%80%81HyperZ-%E6%8A%80%E6%9C%AF"><span class="toc-number">9.20.</span> <span class="toc-text">9.22、HyperZ 技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-23%E3%80%81%E6%98%BE%E5%8D%A1%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">9.21.</span> <span class="toc-text">9.23、显卡流水线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-24%E3%80%81F-Buffer"><span class="toc-number">9.22.</span> <span class="toc-text">9.24、F-Buffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-25%E3%80%81FPGA"><span class="toc-number">9.23.</span> <span class="toc-text">9.25、FPGA</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/20/0-0-16%20debian%E5%92%8Cubuntu%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA%E8%AF%A6%E8%A7%A3/" title="0-0-16 ubuntu和debian文件系统构建详解">0-0-16 ubuntu和debian文件系统构建详解</a><time datetime="2023-11-20T13:16:57.000Z" title="发表于 2023-11-20 21:16:57">2023-11-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/19/0-0-15%20%E6%98%BE%E7%A4%BA%E7%A1%AC%E4%BB%B6%E5%8F%91%E5%B1%95%E4%B8%8E%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%89%AB%E7%9B%B2/" title="0-0-15 显示硬件发展与视频开发知识点扫盲">0-0-15 显示硬件发展与视频开发知识点扫盲</a><time datetime="2023-11-19T13:16:56.000Z" title="发表于 2023-11-19 21:16:56">2023-11-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/19/0-0-14%20%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/" title="0-0-14 音视频编解码相关知识学习">0-0-14 音视频编解码相关知识学习</a><time datetime="2023-11-19T09:16:56.000Z" title="发表于 2023-11-19 17:16:56">2023-11-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/14/0-0-13%20rk%20deb%E5%8C%85%E7%9A%84%E5%88%B6%E4%BD%9C/" title="0-0-13 rkdeb包的制作">0-0-13 rkdeb包的制作</a><time datetime="2023-11-14T11:55:17.000Z" title="发表于 2023-11-14 19:55:17">2023-11-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/12/0-0-13%20ad%E5%AD%A6%E4%B9%A0/" title="PCB学习">PCB学习</a><time datetime="2023-11-12T13:55:17.000Z" title="发表于 2023-11-12 21:55:17">2023-11-12</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2023 By <a class="footer-bar-link" href="/" title="John Doe" target="_blank">John Doe</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">20</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/3588-npu/" style="font-size: 0.88rem;">3588 npu<sup>6</sup></a><a href="/tags/PCB%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">PCB学习<sup>1</sup></a><a href="/tags/buildroot/" style="font-size: 0.88rem;">buildroot<sup>1</sup></a><a href="/tags/deb%E5%8C%85%E5%88%B6%E4%BD%9C/" style="font-size: 0.88rem;">deb包制作<sup>1</sup></a><a href="/tags/deb%E5%8C%85%E7%9A%84%E5%88%B6%E4%BD%9C/" style="font-size: 0.88rem;">deb包的制作<sup>1</sup></a><a href="/tags/docker/" style="font-size: 0.88rem;">docker<sup>1</sup></a><a href="/tags/hexo/" style="font-size: 0.88rem;">hexo<sup>3</sup></a><a href="/tags/markdown/" style="font-size: 0.88rem;">markdown<sup>2</sup></a><a href="/tags/opencv/" style="font-size: 0.88rem;">opencv<sup>1</sup></a><a href="/tags/systemd%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">systemd学习<sup>1</sup></a><a href="/tags/%E5%9C%A8%E5%AE%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" style="font-size: 0.88rem;">在家学习记录<sup>1</sup></a><a href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" style="font-size: 0.88rem;">文件系统构建<sup>1</sup></a><a href="/tags/%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9/" style="font-size: 0.88rem;">源码修改<sup>1</sup></a><a href="/tags/%E7%91%9E%E8%8A%AF%E5%BE%AE%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/" style="font-size: 0.88rem;">瑞芯微脚本分析<sup>18</sup></a><a href="/tags/%E7%BF%BB%E5%A2%99/" style="font-size: 0.88rem;">翻墙<sup>1</sup></a><a href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B5%8B%E8%AF%95/" style="font-size: 0.88rem;">音视频测试<sup>1</sup></a><a href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81/" style="font-size: 0.88rem;">音视频编解码<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.9",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 John Doe 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>